From chiselwright at mail.berlios.de  Tue Oct  7 20:46:12 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:46:12 +0200
Subject: [Parley-svn] r933 - / trunk trunk/lib/Parley/I18N trunk/todo.i18n
Message-ID: <200810071846.m97IkCpr026958@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:46:12 +0200 (Tue, 07 Oct 2008)
New Revision: 933

Modified:
   /
   trunk/Changes
   trunk/Changes.i18n
   trunk/lib/Parley/I18N/nl.po
   trunk/todo.i18n/nl
Log:
 r8167 at wiggin:  chisel | 2008-10-06 09:03:58 +0100
 + added outstanding .nl translations



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:6038
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8167
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-08-14 16:41:26 UTC (rev 932)
+++ trunk/Changes	2008-10-07 18:46:12 UTC (rev 933)
@@ -8,7 +8,7 @@
     - resolved some bugs and errors when deploying from scratch
     - added more comprehensive instructions for getting started
     - updated to new Authentication and Authorization modules
-    - added recent i18n translations
+    - added recent i18n translations (.it and .nl)`
 
 
 After knackering up the version numbers towards the end of 0.59

Modified: trunk/Changes.i18n
===================================================================
--- trunk/Changes.i18n	2008-08-14 16:41:26 UTC (rev 932)
+++ trunk/Changes.i18n	2008-10-07 18:46:12 UTC (rev 933)
@@ -6,8 +6,18 @@
 will be used as the 'en' i18n file.
 It's unlikely that we'll need an 'en' file in the project.
 
-1.0.0 (UNDER DEVELOPMENT)
+1.0.0
 
+    Differences are now tracked and reported using a script that compares
+    a given language with 'i_default'.
+    The comparisons are generated and viewed as follows:
+
+       ./script/update_i18n_todo.sh
+       more todo.i18n/*
+
+    (2008-10-06)
+
+
     i_default.po:
         - added:
             - "User has never posted"
@@ -46,6 +56,16 @@
             - "We're not in Kansas any more"
             - "You don't have the required privileges to do that"
 
+    nl.po:
+        - fixed:
+            - "Searching for"
+
+        - added:
+            - "IP Information"
+            - "Manage user roles"
+            - "Unauthorized!"
+            - "User has never posted"
+
 0.59
     i_default.po:
         - added:

Modified: trunk/lib/Parley/I18N/nl.po
===================================================================
--- trunk/lib/Parley/I18N/nl.po	2008-08-14 16:41:26 UTC (rev 932)
+++ trunk/lib/Parley/I18N/nl.po	2008-10-07 18:46:12 UTC (rev 933)
@@ -258,6 +258,9 @@
 msgid "IP Bans"
 msgstr "IP Verboden"
 
+msgid "IP Information"
+msgstr "IP-Informatie"
+
 msgid "IP Logged"
 msgstr "IP Geregistreerd"
 
@@ -333,6 +336,9 @@
 msgid "Manage"
 msgstr "Leid"
 
+msgid "Manage user roles"
+msgstr "Beheren rollen van gebruikers"
+
 msgid "Me"
 msgstr "Me"
 
@@ -601,11 +607,14 @@
 msgstr "De Resultaten van het onderzoek"
 
 msgid "Searching for"
-msgstr "Het zoeken naar
+msgstr "Het zoeken naar"
 
 msgid "Select Zone"
 msgstr "Selecteer Streek"
 
+#msgid "Select Zone"
+#msgstr "Kies Tijdzone"
+
 msgid "Service"
 msgstr "De dienst"
 
@@ -738,6 +747,9 @@
 msgid "Topic"
 msgstr "Onderwerp"
 
+msgid "Unauthorized!"
+msgstr "Toestemming geweigerd!"
+
 msgid "Unknown field name"
 msgstr "Onbekende gebiedsnaam"
 
@@ -771,6 +783,9 @@
 msgid "USER AUTHENTICATED"
 msgstr "Uw registratie is voor authentiek verklaard"
 
+msgid "User has never posted"
+msgstr "Geen berichten van deze gebruiker"
+
 msgid "User Profile"
 msgstr "Het Profiel van de gebruiker"
 

Modified: trunk/todo.i18n/nl
===================================================================
--- trunk/todo.i18n/nl	2008-08-14 16:41:26 UTC (rev 932)
+++ trunk/todo.i18n/nl	2008-10-07 18:46:12 UTC (rev 933)
@@ -1,20 +1,7 @@
 Missing phrases in 'nl' translation:
 
-  IP Information
-    IP Information
+ - NONE -
 
-  Manage user roles
-    Manage user roles
-
-  Select Zone
-    Select Zone
-
-  Unauthorized!
-    Unauthorized!
-
-  User has never posted
-    User has never posted
-
 Additional phrases in 'nl' translation:
 
  - NONE -



From chiselwright at mail.berlios.de  Tue Oct  7 20:46:21 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:46:21 +0200
Subject: [Parley-svn] r934 - / trunk trunk/lib/Template/Plugin trunk/t
Message-ID: <200810071846.m97IkL2n027028@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:46:21 +0200 (Tue, 07 Oct 2008)
New Revision: 934

Modified:
   /
   trunk/Changes
   trunk/lib/Template/Plugin/ForumCode.pm
   trunk/t/04_forumcode.t
Log:
 r8168 at wiggin:  chisel | 2008-10-06 09:25:22 +0100
 + extended ::ForumCode to work with bbcode/explosm [URL] and [IMG] syntax



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8167
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8168
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-07 18:46:12 UTC (rev 933)
+++ trunk/Changes	2008-10-07 18:46:21 UTC (rev 934)
@@ -8,7 +8,8 @@
     - resolved some bugs and errors when deploying from scratch
     - added more comprehensive instructions for getting started
     - updated to new Authentication and Authorization modules
-    - added recent i18n translations (.it and .nl)`
+    - added recent i18n translations (.it and .nl)
+    - extended ::ForumCode to work with bbcode/explosm [URL] and [IMG] syntax
 
 
 After knackering up the version numbers towards the end of 0.59

Modified: trunk/lib/Template/Plugin/ForumCode.pm
===================================================================
--- trunk/lib/Template/Plugin/ForumCode.pm	2008-10-07 18:46:12 UTC (rev 933)
+++ trunk/lib/Template/Plugin/ForumCode.pm	2008-10-07 18:46:21 UTC (rev 934)
@@ -109,6 +109,15 @@
         \[/url\]        # close the URL tag
     }
     {<a href="$2">$1</a>}xmsg;
+    # bbcode / explosm style urls
+    $$textref =~ s{
+        \[URL=&quot;    # opening url tag
+        (.+?)           # the url
+        &quot;\]        # close-opening tag
+        (.+?)           # link name/text/label
+        \[/URL]         # closing tag
+    }
+    {<a href="$1">$2</a>}ximsg;
 }
 
 sub _images {
@@ -122,7 +131,8 @@
         (.+?)
         \[/img\]
     }
-    {<img src="$2"$1 />}xmsg;
+    {<img src="$2"$1 />}ximsg;
+    # bbcode / explosm style images
 }
 
 sub _colouring {

Modified: trunk/t/04_forumcode.t
===================================================================
--- trunk/t/04_forumcode.t	2008-10-07 18:46:12 UTC (rev 933)
+++ trunk/t/04_forumcode.t	2008-10-07 18:46:21 UTC (rev 934)
@@ -86,6 +86,10 @@
             in  => '[url name="Google" ]http://www.google.com/[/url]',
             out => '<a href="http://www.google.com/">Google</a>',
         },
+        {
+            in  => '[URL="http://www.google.com/"]Google[/URL]',
+            out => '<a href="http://www.google.com/">Google</a>',
+        },
 
         # let people put odd stuff in the name if they really want
         {
@@ -138,6 +142,11 @@
             out     => q{<img src="http://somewhere.com/myImage.jpg" alt=&quot;Foo&quot; />},
             diag    => 'Test this URL in browsers!',
         },
+        # explosm / cyanide style
+        {
+            in      => q{[IMG]http://www.flashasylum.com/db/files/Comics/Rob/luckyunderwear.png[/IMG]},
+            out     => q{<img src="http://www.flashasylum.com/db/files/Comics/Rob/luckyunderwear.png" />},
+        },
 
         {
             in      =>q{One:
@@ -214,6 +223,13 @@
             in      => q{[quote quoting="Joe"]quote markup test[/quote]},
             out     => q{<div class="forumcode_quote"><div class="forumcode_quoting">Quoting Joe:</div>quote markup test</div>},
         },
+
+
+        # Cyanide Comic (explosm.com) forum-code
+        {
+            in      => q{[URL="http://www.explosm.net/comics/1393/"][IMG]http://www.flashasylum.com/db/files/Comics/Rob/luckyunderwear.png[/IMG][/URL]},
+            out     => q{<a href="http://www.explosm.net/comics/1393/"><img src="http://www.flashasylum.com/db/files/Comics/Rob/luckyunderwear.png" /></a>},
+        },
     );
 
     # test count is a fixed number of tests + the length of the @tests array



From chiselwright at mail.berlios.de  Tue Oct  7 20:46:34 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:46:34 +0200
Subject: [Parley-svn] r935 - / trunk/lib/Parley
Message-ID: <200810071846.m97IkXhK027115@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:46:33 +0200 (Tue, 07 Oct 2008)
New Revision: 935

Modified:
   /
   trunk/lib/Parley/Contributors.pm
Log:
 r8169 at wiggin:  chisel | 2008-10-06 19:05:15 +0100
 + added Kevin Golding to .nl translation section



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8168
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8169
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/lib/Parley/Contributors.pm
===================================================================
--- trunk/lib/Parley/Contributors.pm	2008-10-07 18:46:21 UTC (rev 934)
+++ trunk/lib/Parley/Contributors.pm	2008-10-07 18:46:33 UTC (rev 935)
@@ -32,6 +32,8 @@
 
 Translation by Rob Partridge
 
+Additional translations by Kevin Golding
+
 =head2 Italian
 
 Translation by Darius Jokilehto



From chiselwright at mail.berlios.de  Tue Oct  7 20:46:42 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:46:42 +0200
Subject: [Parley-svn] r936 - / trunk
Message-ID: <200810071846.m97Ikg2r027199@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:46:42 +0200 (Tue, 07 Oct 2008)
New Revision: 936

Modified:
   /
   trunk/Changes
Log:
 r8170 at wiggin:  chisel | 2008-10-06 19:09:14 +0100
 + added timestamp to 1.0.0 header



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8169
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8170
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-07 18:46:33 UTC (rev 935)
+++ trunk/Changes	2008-10-07 18:46:42 UTC (rev 936)
@@ -1,6 +1,6 @@
 This file documents the revision history for Parley.
 
-1.0.0 *DEVELOPMENT*
+1.0.0   Mon Oct  6 19:08:22 BST 2008
     - upgrade to YUI 2.5.1
     - moved README.* into doc/
     - added parley.sites-enabled



From chiselwright at mail.berlios.de  Tue Oct  7 20:46:55 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:46:55 +0200
Subject: [Parley-svn] r937 - / trunk
Message-ID: <200810071846.m97IktvV027279@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:46:55 +0200 (Tue, 07 Oct 2008)
New Revision: 937

Modified:
   /
   trunk/MANIFEST
Log:
 r8171 at wiggin:  chisel | 2008-10-06 19:09:57 +0100
 Update MANIFEST



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8170
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8171
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/MANIFEST
===================================================================
--- trunk/MANIFEST	2008-10-07 18:46:42 UTC (rev 936)
+++ trunk/MANIFEST	2008-10-07 18:46:55 UTC (rev 937)
@@ -29,6 +29,7 @@
 doc/README.admin
 doc/README.gravatar
 doc/setup.html
+inc-wibble/Module/Install.pm
 inc/Module/Install.pm
 inc/Module/Install/Base.pm
 inc/Module/Install/Can.pm



From chiselwright at mail.berlios.de  Tue Oct  7 20:47:16 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:47:16 +0200
Subject: [Parley-svn] r938 - / tags
Message-ID: <200810071847.m97IlGvU027385@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:47:16 +0200 (Tue, 07 Oct 2008)
New Revision: 938

Added:
   tags/parley-1.0.0/
Modified:
   /
Log:
 r8172 at wiggin:  chisel | 2008-10-06 19:14:57 +0100
 Tagging v1.0.0



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8171
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8172
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Copied: tags/parley-1.0.0 (from rev 937, trunk)



From chiselwright at mail.berlios.de  Tue Oct  7 20:47:45 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:47:45 +0200
Subject: [Parley-svn] r939 - / trunk trunk/lib/Parley
Message-ID: <200810071847.m97IljlV027510@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:47:44 +0200 (Tue, 07 Oct 2008)
New Revision: 939

Modified:
   /
   trunk/Makefile.PL
   trunk/lib/Parley/Version.pm
Log:
 r8173 at wiggin:  chisel | 2008-10-07 19:12:39 +0100
 / bump current version to v1.0.1



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8172
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8173
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Makefile.PL
===================================================================
--- trunk/Makefile.PL	2008-10-07 18:47:16 UTC (rev 938)
+++ trunk/Makefile.PL	2008-10-07 18:47:44 UTC (rev 939)
@@ -8,7 +8,7 @@
 author          ('Chisel Wright<chiselwright at users.berlios.de>');
 abstract        ('Message board / forum application');
 license         ('perl');
-version         ('1.0.0');
+version         ('1.0.1');
 
 requires(
     'Catalyst'                                                  => '5.008001',

Modified: trunk/lib/Parley/Version.pm
===================================================================
--- trunk/lib/Parley/Version.pm	2008-10-07 18:47:16 UTC (rev 938)
+++ trunk/lib/Parley/Version.pm	2008-10-07 18:47:44 UTC (rev 939)
@@ -5,7 +5,7 @@
 
 # from mst on #catalyst
 #our $VERSION = '1.000000'; $VERSION = eval $VERSION;
-use version; our $VERSION = qv(1.0.0)->numify;
+use version; our $VERSION = qv(1.0.1)->numify;
 
 
 package Parley::Version;



From chiselwright at mail.berlios.de  Tue Oct  7 20:47:56 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:47:56 +0200
Subject: [Parley-svn] r940 - / trunk
Message-ID: <200810071847.m97IluKV027587@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:47:56 +0200 (Tue, 07 Oct 2008)
New Revision: 940

Modified:
   /
   trunk/Changes
   trunk/Changes.i18n
Log:
 r8174 at wiggin:  chisel | 2008-10-07 19:13:41 +0100
 + added 1.0.1 sections to change log files



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8173
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8174
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-07 18:47:44 UTC (rev 939)
+++ trunk/Changes	2008-10-07 18:47:56 UTC (rev 940)
@@ -1,5 +1,8 @@
 This file documents the revision history for Parley.
 
+1.0.1
+    - ?
+
 1.0.0   Mon Oct  6 19:08:22 BST 2008
     - upgrade to YUI 2.5.1
     - moved README.* into doc/

Modified: trunk/Changes.i18n
===================================================================
--- trunk/Changes.i18n	2008-10-07 18:47:44 UTC (rev 939)
+++ trunk/Changes.i18n	2008-10-07 18:47:56 UTC (rev 940)
@@ -6,7 +6,7 @@
 will be used as the 'en' i18n file.
 It's unlikely that we'll need an 'en' file in the project.
 
-1.0.0
+1.0.1
 
     Differences are now tracked and reported using a script that compares
     a given language with 'i_default'.
@@ -17,6 +17,7 @@
 
     (2008-10-06)
 
+1.0.0
 
     i_default.po:
         - added:



From chiselwright at mail.berlios.de  Tue Oct  7 20:48:05 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:48:05 +0200
Subject: [Parley-svn] r941 - / trunk trunk/lib/Parley
	trunk/lib/Parley/Controller trunk/lib/Parley/Model
	trunk/lib/Parley/ResultSet trunk/lib/Parley/Schema
Message-ID: <200810071848.m97Im5nj027665@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:48:04 +0200 (Tue, 07 Oct 2008)
New Revision: 941

Modified:
   /
   trunk/Changes
   trunk/lib/Parley/Controller/Forum.pm
   trunk/lib/Parley/Controller/My.pm
   trunk/lib/Parley/Controller/Search.pm
   trunk/lib/Parley/Controller/Site.pm
   trunk/lib/Parley/Controller/Terms.pm
   trunk/lib/Parley/Controller/Thread.pm
   trunk/lib/Parley/Model/ParleyDB.pm
   trunk/lib/Parley/ResultSet/Forum.pm
   trunk/lib/Parley/ResultSet/IpBanType.pm
   trunk/lib/Parley/ResultSet/Role.pm
   trunk/lib/Parley/ResultSet/Terms.pm
   trunk/lib/Parley/ResultSet/Thread.pm
   trunk/lib/Parley/Schema.pm
   trunk/lib/Parley/Schema/Person.pm
   trunk/lib/Parley/Schema/Thread.pm
   trunk/parley.conf
Log:
 r8175 at wiggin:  chisel | 2008-10-07 19:17:37 +0100
 + added config options to use quote_char and name_sep in DB calls
 / updated order_by params in searches to work with quote_char
 - removed config block in Model::ParleyDB (it comes from parley.conf, and this saves confusion)



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8174
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8175
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/Changes	2008-10-07 18:48:04 UTC (rev 941)
@@ -1,7 +1,10 @@
 This file documents the revision history for Parley.
 
 1.0.1
-    - ?
+    - added config options to use quote_char and name_sep in DB calls
+    - updated order_by params in searches to work with quote_char
+    - removed config block in Model::ParleyDB (it comes from parley.conf, and
+      this saves confusion)
 
 1.0.0   Mon Oct  6 19:08:22 BST 2008
     - upgrade to YUI 2.5.1

Modified: trunk/lib/Parley/Controller/Forum.pm
===================================================================
--- trunk/lib/Parley/Controller/Forum.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Controller/Forum.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -37,7 +37,7 @@
             },
             {
                 join        => 'last_post',
-                order_by    => 'sticky DESC, last_post.created DESC',
+                order_by    => [\'sticky DESC', \'last_post.created DESC'],
                 # pager information
                 rows        => $c->config->{threads_per_page},
                 page        => $c->stash->{current_page},

Modified: trunk/lib/Parley/Controller/My.pm
===================================================================
--- trunk/lib/Parley/Controller/My.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Controller/My.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -102,7 +102,7 @@
         $c->model('ParleyDB')->resultset('PreferenceTimeString')->search(
             {},     # fetch everything
             {
-                order_by    => 'sample',    # order by the "preview/sample" string
+                order_by    => [\'sample ASC'],    # order by the "preview/sample" string
             }
         );
 
@@ -160,7 +160,7 @@
             watched     => 1,
         },
         {
-            order_by    => 'last_post.created DESC',
+            order_by    => [\'last_post.created DESC'],
             join        => {
                 'thread' => 'last_post',
             },

Modified: trunk/lib/Parley/Controller/Search.pm
===================================================================
--- trunk/lib/Parley/Controller/Search.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Controller/Search.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -89,7 +89,7 @@
         $where,
         {
             join        => \@join,
-            order_by    => q{created DESC},
+            order_by    => [\'created DESC'],
             # results paging
             rows        => $c->config->{search_results_per_page},
             page        => $c->stash->{current_page},

Modified: trunk/lib/Parley/Controller/Site.pm
===================================================================
--- trunk/lib/Parley/Controller/Site.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Controller/Site.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -84,7 +84,7 @@
             forum_name => { -ilike => $c->request->param('query') . q{%} },
         },
         {
-            'order_by' => 'forum_name',
+            'order_by' => [\'forum_name ASC'],
             columns => [qw/id forum_name first_name last_name/],
         }
     );

Modified: trunk/lib/Parley/Controller/Terms.pm
===================================================================
--- trunk/lib/Parley/Controller/Terms.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Controller/Terms.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -28,7 +28,7 @@
         $c->model('ParleyDB')->resultset('Terms')->search(
             {},
             {
-                'order_by' => 'created DESC',
+                'order_by' => [\'created DESC'],
             }
         )
     ;

Modified: trunk/lib/Parley/Controller/Thread.pm
===================================================================
--- trunk/lib/Parley/Controller/Thread.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Controller/Thread.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -174,7 +174,7 @@
             'me.thread_id' => $c->_current_thread->id(),
         },
         {
-            order_by    => 'me.created ASC',
+            order_by    => [\'me.created ASC'],
             rows        => $c->config->{posts_per_page},
             page        => $c->stash->{current_page},
 
@@ -305,7 +305,7 @@
             watched     => 1,
         },
         {
-            order_by    => 'last_post.created DESC',
+            order_by    => [\'last_post.created DESC'],
             join        => {
                 'thread' => 'last_post',
             },
@@ -499,7 +499,7 @@
                 'thread_id' => $c->_current_thread()->id(),
             },
             {
-                order_by    => 'created ASC',
+                order_by    => [\'created ASC'],
                 rows        => 1,
             }
         );

Modified: trunk/lib/Parley/Model/ParleyDB.pm
===================================================================
--- trunk/lib/Parley/Model/ParleyDB.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Model/ParleyDB.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -5,15 +5,17 @@
 use Parley::Version;  our $VERSION = $Parley::VERSION;
 use base 'Catalyst::Model::DBIC::Schema';
 
-__PACKAGE__->config(
-    schema_class => 'Parley::Schema',
-    connect_info => [
-        'dbi:Pg:dbname=parley',
-        'parley',
-        
-    ],
-);
+#__PACKAGE__->config(
+#    schema_class => 'Parley::Schema',
+#    connect_info => [
+#        'dbi:Pg:dbname=parley',
+#        'parley',
+#        
+#    ],
+#);
 
+# CONFIG COMES FROM parley.conf
+
 =head1 NAME
 
 Parley::Model::ParleyDB - Catalyst DBIC Schema Model

Modified: trunk/lib/Parley/ResultSet/Forum.pm
===================================================================
--- trunk/lib/Parley/ResultSet/Forum.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/ResultSet/Forum.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -17,7 +17,7 @@
             active  => 1,
         },
         {
-            order_by    => 'name ASC',
+            order_by    => [\'name ASC'],
         }
     );
 
@@ -33,7 +33,7 @@
             active => 1,
         },
         {
-            'order_by'  => 'me.id ASC',
+            'order_by'  => [\'me.id ASC'],
             prefetch => [
                 {'last_post' => { 'creator' => 'authentication' } },
             ],

Modified: trunk/lib/Parley/ResultSet/IpBanType.pm
===================================================================
--- trunk/lib/Parley/ResultSet/IpBanType.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/ResultSet/IpBanType.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -14,7 +14,7 @@
     $rs = $resultsource->search(
         {},
         {
-            'order_by'  => ['name ASC'],
+            'order_by'  => [\'name ASC'],
         }
     );
 

Modified: trunk/lib/Parley/ResultSet/Role.pm
===================================================================
--- trunk/lib/Parley/ResultSet/Role.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/ResultSet/Role.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -15,7 +15,7 @@
         {
         },
         {
-            'order_by' => [ 'idx ASC', 'description ASC' ],
+            'order_by' => [ \'idx ASC', \'description ASC' ],
         },
     );
 

Modified: trunk/lib/Parley/ResultSet/Terms.pm
===================================================================
--- trunk/lib/Parley/ResultSet/Terms.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/ResultSet/Terms.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -15,7 +15,7 @@
         },
         {
             rows        => 1,
-            order_by    => 'created DESC',
+            order_by    => [\'created DESC'],
         }
     );
 

Modified: trunk/lib/Parley/ResultSet/Thread.pm
===================================================================
--- trunk/lib/Parley/ResultSet/Thread.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/ResultSet/Thread.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -48,7 +48,7 @@
             },
             {
                 rows        => 1,
-                order_by    => 'created ASC',
+                order_by    => [\'created ASC'],
             }
         );
 
@@ -75,7 +75,7 @@
             },
             {
                 rows        => 1,
-                order_by    => 'created DESC',
+                order_by    => [\'created DESC'],
             }
         );
 
@@ -115,7 +115,7 @@
         $where,
         {
             join        => \@join,
-            order_by    => 'last_post.created DESC',
+            order_by    => [\'last_post.created DESC'],
 
             rows        => $c->config->{threads_per_page},
             page        => $c->stash->{current_page},

Modified: trunk/lib/Parley/Schema/Person.pm
===================================================================
--- trunk/lib/Parley/Schema/Person.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Schema/Person.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -255,7 +255,7 @@
         {
             join => [qw( action )],
             rows => 1,
-            order_by    => 'created DESC',
+            order_by    => [\'created DESC'],
         }
     );
 

Modified: trunk/lib/Parley/Schema/Thread.pm
===================================================================
--- trunk/lib/Parley/Schema/Thread.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Schema/Thread.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -152,7 +152,7 @@
             },
             {
                 rows        => 1,
-                order_by    => 'created ASC',
+                order_by    => [\'created ASC'],
             }
         );
 
@@ -177,7 +177,7 @@
         },
         {
             rows        => 1,
-            order_by    => 'created DESC',
+            order_by    => [\'created DESC'],
         }
     );
 

Modified: trunk/lib/Parley/Schema.pm
===================================================================
--- trunk/lib/Parley/Schema.pm	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/lib/Parley/Schema.pm	2008-10-07 18:48:04 UTC (rev 941)
@@ -32,4 +32,7 @@
     ]
 );
 
+# XXX doesn't play at all well with postgres
+#__PACKAGE__->load_components(qw/+DBIx::Class::Schema::Versioned/);
+
 1;

Modified: trunk/parley.conf
===================================================================
--- trunk/parley.conf	2008-10-07 18:47:56 UTC (rev 940)
+++ trunk/parley.conf	2008-10-07 18:48:04 UTC (rev 941)
@@ -22,9 +22,11 @@
     schema_class            Parley::Schema
     connect_info            dbi:Pg:dbname=parley;host=localhost
     connect_info            parley
-    connect_info   
+    connect_info
     <connect_info>
         AutoCommit          1
+        quote_char          __literal(")__
+        name_sep            __literal(.)__
     </connect_info>
 </Model::ParleyDB>
 



From chiselwright at mail.berlios.de  Tue Oct  7 20:48:13 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Tue, 7 Oct 2008 20:48:13 +0200
Subject: [Parley-svn] r942 - / trunk
Message-ID: <200810071848.m97ImDlo027735@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-07 20:48:13 +0200 (Tue, 07 Oct 2008)
New Revision: 942

Modified:
   /
   trunk/ROADMAP
Log:
 r8176 at wiggin:  chisel | 2008-10-07 19:21:17 +0100
 / update RoadMap



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8175
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8176
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/ROADMAP
===================================================================
--- trunk/ROADMAP	2008-10-07 18:48:04 UTC (rev 941)
+++ trunk/ROADMAP	2008-10-07 18:48:13 UTC (rev 942)
@@ -36,7 +36,7 @@
 
 ** VERSION FORMAT ALTERATION **
 
-1.0.0:
+1.0.0 (Oct 2008):
 
     - [D] upgrade to YUI 2.5.x
     - [D] update to use "new catalyst authentication"



From chiselwright at mail.berlios.de  Wed Oct  8 01:30:57 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 01:30:57 +0200
Subject: [Parley-svn] r943 - / trunk/root/static/css
Message-ID: <200810072330.m97NUvGG021122@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 01:30:54 +0200 (Wed, 08 Oct 2008)
New Revision: 943

Modified:
   /
   trunk/root/static/css/parley.css
Log:
 r8187 at wiggin:  chisel | 2008-10-08 00:23:47 +0100
 + add CSS to make lists "look normal"



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8176
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8187
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/root/static/css/parley.css
===================================================================
--- trunk/root/static/css/parley.css	2008-10-07 18:48:13 UTC (rev 942)
+++ trunk/root/static/css/parley.css	2008-10-07 23:30:54 UTC (rev 943)
@@ -90,6 +90,18 @@
     text-decoration:    none;
 }
 
+/* lists */
+ol li {
+    list-style-type:        decimal;
+    list-style-position:    inside;
+}
+
+ul li {
+    list-style-type:        disc;
+    list-style-position:    inside;
+}
+
+
 /* tables */
 th {
     font-size:          100%;



From chiselwright at mail.berlios.de  Wed Oct  8 01:31:07 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 01:31:07 +0200
Subject: [Parley-svn] r944 - / trunk/root/static/css
Message-ID: <200810072331.m97NV7Ov021371@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 01:31:07 +0200 (Wed, 08 Oct 2008)
New Revision: 944

Modified:
   /
   trunk/root/static/css/parley-min.css
Log:
 r8188 at wiggin:  chisel | 2008-10-08 00:24:42 +0100
 / compressed new CSS



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8187
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8188
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/root/static/css/parley-min.css
===================================================================
--- trunk/root/static/css/parley-min.css	2008-10-07 23:30:54 UTC (rev 943)
+++ trunk/root/static/css/parley-min.css	2008-10-07 23:31:07 UTC (rev 944)
@@ -1 +1 @@
-body{background-color:#fff;font-family:Verdana,Arial,Helvetica,sans-serif;}#hd{height:80px;line-height:80px;margin:0;padding-left:10px;background:#EEE url('/static/images/parley_logo.jpg') no-repeat left;color:#79B30B color:#36C;}#hd h1{font-size:200%;text-align:left;}div#ft{background:#666;color:#FFF;font-size:77%;margin-top:20px;}div#ft p{border:none;margin-top:30px;padding:5px 10px 5px 10px;text-align:right;display:block;}div#ft a{color:#ccc;}div#user_information{line-height:1em;font-size:85%;color:#000;background-color:transparent;position:absolute;top:0;right:10px;height:70px;width:200px;padding-top:3px;text-align:center;}div#user_information .user_info_actions{margin-top:3px;}.caretfix{overflow:auto;}#bd h1{font-weight:bold;background:#666;padding:4px;text-align:left;margin-top:5px;margin-bottom:5px;}#bd h2{font-weight:bold;background:#999;padding:4px;text-align:left;margin-top:5px;margin-bottom:5px;}#bd h3{font-weight:bold;background:#eee;padding:4px;text-align:left;!
 margin-top:5px;margin-bottom:5px;color:#79B30B color:#36C;}a.nav:hover{background:#000;color:#fff;}a,a:link,a:visited,a:active{background:transparent;color:blue;text-decoration:none;}th{font-size:100%;text-align:left;font-weight:bold;}#login_dialog form{margin:0;padding:0;min-width:400px;max-width:600px;}#login_dialog form fieldset{/ * clear:both;note that this clear causes inputs to break to left in ie5.x mac,commented out */ padding:10px;margin:0;border:none;}#login_dialog form label{display:block;float:left;width:150px;padding:0;margin:5px 0 0;text-align:right;font-weight:bold;margin-bottom:0;}#login_dialog form input,form textarea{width:auto;margin:5px 0 0 10px;}#login_dialog form p{font-size:85%;}.row{border-top:1px dotted #666;border-bottom:1px dotted #666;}.row_odd{background:#eee;}.row_even{background:#ddd;}.admin_edited_post{color:#000;background:#ccc;padding:2px;padding-left:10px;padding-right:10px;border:1px dashed #000;margin-left:15px;font-size:93%;text-align:r!
 ight;}.align_right{text-align:right;}.error_messages{margin-to!
 p:5px;di
splay:block;line-height:1.7em;padding:5px;background-color:#930;color:#fff;text-transform:none;font-family:Arial,Avenir,"Lucida Grande",Verdana,"Bitstream Vera Sans",Helvetica,sans-serif;font-weight:bold;voice-family:"\"}\"";voice-family:inherit;font-size:1.0em;border:none;}.forum_description{font-size:93%;}.forum_lastpost{font-size:85%;text-align:right;}.forum_lastpost_subject a{color:#79B30B color:#36C;}.forum_link{font-size:100%;font-weight:bold;}.forum_list{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.forum_list td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.forum_mini_pager{font-size:85%;}.forum_mini_pager a{color:#666;}.forum_name{font-size:100%;text-align:left;font-weight:bold;margin-top:5px;}.forum_name a{color:#79B30B color:#36C;}.forum_postcount{font-size:85%;text-align:right;margin-top:5px;}.forum_view{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;fon!
 t-size:93%;}.forum_view td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.help li{margin-top:25px;margin-right:25px;list-style-type:none;border-left:2px solid #666;padding-top:5px;padding-bottom:5px;padding-left:10px;background-color:#ddd;}.help li ul li,.help li ol li{margin-top:5px;margin-left:10px;list-style-type:disc;border-left:none;padding-left:none;padding-top:none;padding-bottom:none;background-color:transparent;}.innerpost{margin-left:10px;padding:5px;overflow:auto;font-size:93%;}.moderator_list{font-size:77%;margin-bottom:5px;margin-top:5px;text-align:right;}.pager_advanced{font-size:77%;margin-bottom:5px;margin-top:5px;}.post{padding-top:5px;vertical-align:top;border-left:1px solid #ddd;}.post_created{text-align:right;font-size:85%;}.post_creator{font-weight:bold;font-style:italic;font-size:85%;}.post_edited_alert{font-weight:bold;font-style:italic;}.post_info{font-size:77%;line-height:1.1em;margin-to!
 p:10px;margin-bottom:2px;text-align:right;}.post_subject{font-!
 weight:b
old;}.quote{background-color:#F9FBFF;border:1px solid #333;font-size:85%;margin:0 0 2px 4px;padding:6px;width:85%;overflow:hidden;}.recently_updated{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.recently_updated td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.reply_post_message{border:1px dashed #666;}.search_match_context{font-size:85%;}.search_results{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.search_results td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;padding-top:5px;padding-bottom:5px;}.service_list{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.service_list td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.site_terms{width:80%;margin-left:auto;margin-right:auto;margin-bottom:10px;pad!
 ding:5px;border:1px solid #666;}.thread_add{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.thread_add td{padding-top:4px;padding-bottom:4px;}.thread_add .input_text{width:450px;margin-left:10px;}.thread_add_topic{text-align:right;padding-right:5px;}.thread_add_message{text-align:right;vertical-align:top;padding-right:5px;}.thread_header{font-weight:bold;background:#666;padding:4px;text-align:left;}.thread_header a{color:#ccc;}.thread_info{margin:0;width:100%;border:none;padding:0;margin-bottom:10px;}.thread_info td{border:none;padding:0;}.thread_lastpost{font-size:85%;text-align:right;}.thread_post_row{border-top:1px solid #ddd;border-bottom:1px solid #ddd;}.thread_post_row td{margin-top:10px;margin-bottom:10px;}.thread_posts{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.thread_recent_forum{float:right;font-size:85%;}.thread_recent_forum a{color:#333;}.thread_reply{font-size:93%;}.thread_reply tr{vertical-align:!
 top;}.thread_reply td{padding-top:10px;padding-left:10px;}.thr!
 ead_repl
y textarea{background-color:transparent;border:2px inset black;}.thread_subject a{font-size:93%;color:#79B30B color:#36C;}.thread_watch{margin-top:5px;font-size:77%;text-align:left;}.top_padded{margin-top:10px;}.topic_creator{display:block;font-size:85%;text-align:right;}.user_login form{width:350px;margin-left:auto;margin-right:auto;margin-top:20px;}.user_login p{margin-top:5px;margin-bottom:5px;}.user_permission_list{margin-left:auto;margin-right:auto;margin-top:15px;font-size:93%;width:100%;}.user_permission_list td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:150%;padding-left:10px;padding-right:10px;padding-top:5px;padding-bottom:5px;}.user_permission_list img{vertical-align:middle;}.forum_moderator_list div input{height:150%;}.forum_moderator_list img{vertical-align:middle;}.user_post_info{background:#ccc;background:transparent;font-size:77%;margin-left:auto;margin-right:auto;text-align:center;vertical-align:top;width:110px;}a[href $='.jpg']{paddin!
 g-left:20px;background:transparent url(/static/images/filetypes/image.png) no-repeat center left;}a[href $='.pdf']{padding-left:20px;background:transparent url(/static/images/filetypes/pdf.png) no-repeat center left;}#loader_wait.yui-overlay{position:fixed;float:right;top:10px;right:10px;border:none;text-align:right;}#preview_overlay{border:1px dashed #ccc;text-align:left;padding:0;}#thread_message{font-family:monospace;text-align:left;padding:0;background-color:#eee;font-size:93%;width:450px;}#ysearch{text-align:center;}#ysearchinput{position:static;width:20em;}#ysearchcontainer{text-align:left;width:20em;}.forumcode_code{font-family:monospace;border:1px solid #333;font-size:85%;margin:15px 20px 15px 20px;padding:6px;width:85%;overflow:auto;color:#ff0;background-color:#333;border:1px solid #666;white-space:pre;}.forumcode_pre{background-color:transparent;font-family:monospace;border:1px dashed #333;font-size:85%;margin:15px 20px 15px 20px;padding:6px;width:85%;overflow:aut!
 o;white-space:pre;}.forumcode_quote{background-color:#eee;font!
 -family:
monospace;font-style:italic;border:1px dotted #333;font-size:85%;margin:15px 20px 15px 20px;padding:6px;width:85%;overflow:auto;}.forumcode_quoting{font-weight:bold;margin-bottom:3px;}.yuimenuitem .disabled{color:#A6A6A6;cursor:default;}.yui-skin-sam .yui-navset .yui-nav,.yui-skin-sam .yui-navset .yui-navset-top .yui-nav{border:solid #333;border-width:0 0 5px;Xposition:relative;zoom:1;}.yui-skin-sam .yui-navset .yui-content{background:transparent;}.yui-skin-sam .yui-navset .yui-nav a,.yui-skin-sam .yui-navset .yui-navset-top .yui-nav a{background-image:none;background-color:#999;border:solid #a3a3a3;border-width:0 1px;color:#fff;text-decoration:none;}.yui-skin-sam .yui-navset .yui-nav .selected a,.yui-skin-sam .yui-navset .yui-nav .selected a:focus,.yui-skin-sam .yui-navset .yui-nav .selected a:hover{background:#333;color:#fff;}.yui-skin-sam .yui-navset .yui-nav a:hover,.yui-skin-sam .yui-navset .yui-nav a:focus{background:#666;color:#fff;outline:0;}
\ No newline at end of file
+body{background-color:#fff;font-family:Verdana,Arial,Helvetica,sans-serif;}#hd{height:80px;line-height:80px;margin:0;padding-left:10px;background:#EEE url('/static/images/parley_logo.jpg') no-repeat left;color:#79B30B color:#36C;}#hd h1{font-size:200%;text-align:left;}div#ft{background:#666;color:#FFF;font-size:77%;margin-top:20px;}div#ft p{border:none;margin-top:30px;padding:5px 10px 5px 10px;text-align:right;display:block;}div#ft a{color:#ccc;}div#user_information{line-height:1em;font-size:85%;color:#000;background-color:transparent;position:absolute;top:0;right:10px;height:70px;width:200px;padding-top:3px;text-align:center;}div#user_information .user_info_actions{margin-top:3px;}.caretfix{overflow:auto;}#bd h1{font-weight:bold;background:#666;padding:4px;text-align:left;margin-top:5px;margin-bottom:5px;}#bd h2{font-weight:bold;background:#999;padding:4px;text-align:left;margin-top:5px;margin-bottom:5px;}#bd h3{font-weight:bold;background:#eee;padding:4px;text-align:left;!
 margin-top:5px;margin-bottom:5px;color:#79B30B color:#36C;}a.nav:hover{background:#000;color:#fff;}a,a:link,a:visited,a:active{background:transparent;color:blue;text-decoration:none;}ol li{list-style-type:decimal;list-style-position:inside;}ul li{list-style-type:disc;list-style-position:inside;}th{font-size:100%;text-align:left;font-weight:bold;}#login_dialog form{margin:0;padding:0;min-width:400px;max-width:600px;}#login_dialog form fieldset{/ * clear:both;note that this clear causes inputs to break to left in ie5.x mac,commented out */ padding:10px;margin:0;border:none;}#login_dialog form label{display:block;float:left;width:150px;padding:0;margin:5px 0 0;text-align:right;font-weight:bold;margin-bottom:0;}#login_dialog form input,form textarea{width:auto;margin:5px 0 0 10px;}#login_dialog form p{font-size:85%;}.row{border-top:1px dotted #666;border-bottom:1px dotted #666;}.row_odd{background:#eee;}.row_even{background:#ddd;}.admin_edited_post{color:#000;background:#ccc;pa!
 dding:2px;padding-left:10px;padding-right:10px;border:1px dash!
 ed #000;
margin-left:15px;font-size:93%;text-align:right;}.align_right{text-align:right;}.error_messages{margin-top:5px;display:block;line-height:1.7em;padding:5px;background-color:#930;color:#fff;text-transform:none;font-family:Arial,Avenir,"Lucida Grande",Verdana,"Bitstream Vera Sans",Helvetica,sans-serif;font-weight:bold;voice-family:"\"}\"";voice-family:inherit;font-size:1.0em;border:none;}.forum_description{font-size:93%;}.forum_lastpost{font-size:85%;text-align:right;}.forum_lastpost_subject a{color:#79B30B color:#36C;}.forum_link{font-size:100%;font-weight:bold;}.forum_list{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.forum_list td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.forum_mini_pager{font-size:85%;}.forum_mini_pager a{color:#666;}.forum_name{font-size:100%;text-align:left;font-weight:bold;margin-top:5px;}.forum_name a{color:#79B30B color:#36C;}.forum_postcount{font-size:8!
 5%;text-align:right;margin-top:5px;}.forum_view{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.forum_view td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.help li{margin-top:25px;margin-right:25px;list-style-type:none;border-left:2px solid #666;padding-top:5px;padding-bottom:5px;padding-left:10px;background-color:#ddd;}.help li ul li,.help li ol li{margin-top:5px;margin-left:10px;list-style-type:disc;border-left:none;padding-left:none;padding-top:none;padding-bottom:none;background-color:transparent;}.innerpost{margin-left:10px;padding:5px;overflow:auto;font-size:93%;}.moderator_list{font-size:77%;margin-bottom:5px;margin-top:5px;text-align:right;}.pager_advanced{font-size:77%;margin-bottom:5px;margin-top:5px;}.post{padding-top:5px;vertical-align:top;border-left:1px solid #ddd;}.post_created{text-align:right;font-size:85%;}.post_creator{font-weight:bold;font-style:italic;font-size!
 :85%;}.post_edited_alert{font-weight:bold;font-style:italic;}.!
 post_inf
o{font-size:77%;line-height:1.1em;margin-top:10px;margin-bottom:2px;text-align:right;}.post_subject{font-weight:bold;}.quote{background-color:#F9FBFF;border:1px solid #333;font-size:85%;margin:0 0 2px 4px;padding:6px;width:85%;overflow:hidden;}.recently_updated{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.recently_updated td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;}.reply_post_message{border:1px dashed #666;}.search_match_context{font-size:85%;}.search_results{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.search_results td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padding-left:10px;padding-right:10px;padding-top:5px;padding-bottom:5px;}.service_list{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.service_list td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:120%;padd!
 ing-left:10px;padding-right:10px;}.site_terms{width:80%;margin-left:auto;margin-right:auto;margin-bottom:10px;padding:5px;border:1px solid #666;}.thread_add{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.thread_add td{padding-top:4px;padding-bottom:4px;}.thread_add .input_text{width:450px;margin-left:10px;}.thread_add_topic{text-align:right;padding-right:5px;}.thread_add_message{text-align:right;vertical-align:top;padding-right:5px;}.thread_header{font-weight:bold;background:#666;padding:4px;text-align:left;}.thread_header a{color:#ccc;}.thread_info{margin:0;width:100%;border:none;padding:0;margin-bottom:10px;}.thread_info td{border:none;padding:0;}.thread_lastpost{font-size:85%;text-align:right;}.thread_post_row{border-top:1px solid #ddd;border-bottom:1px solid #ddd;}.thread_post_row td{margin-top:10px;margin-bottom:10px;}.thread_posts{margin-left:auto;margin-right:auto;margin-top:15px;width:100%;font-size:93%;}.thread_recent_forum{float:righ!
 t;font-size:85%;}.thread_recent_forum a{color:#333;}.thread_re!
 ply{font
-size:93%;}.thread_reply tr{vertical-align:top;}.thread_reply td{padding-top:10px;padding-left:10px;}.thread_reply textarea{background-color:transparent;border:2px inset black;}.thread_subject a{font-size:93%;color:#79B30B color:#36C;}.thread_watch{margin-top:5px;font-size:77%;text-align:left;}.top_padded{margin-top:10px;}.topic_creator{display:block;font-size:85%;text-align:right;}.user_login form{width:350px;margin-left:auto;margin-right:auto;margin-top:20px;}.user_login p{margin-top:5px;margin-bottom:5px;}.user_permission_list{margin-left:auto;margin-right:auto;margin-top:15px;font-size:93%;width:100%;}.user_permission_list td{vertical-align:top;border:1px dashed #ddd;border:none;line-height:150%;padding-left:10px;padding-right:10px;padding-top:5px;padding-bottom:5px;}.user_permission_list img{vertical-align:middle;}.forum_moderator_list div input{height:150%;}.forum_moderator_list img{vertical-align:middle;}.user_post_info{background:#ccc;background:transparent;font-size!
 :77%;margin-left:auto;margin-right:auto;text-align:center;vertical-align:top;width:110px;}a[href $='.jpg']{padding-left:20px;background:transparent url(/static/images/filetypes/image.png) no-repeat center left;}a[href $='.pdf']{padding-left:20px;background:transparent url(/static/images/filetypes/pdf.png) no-repeat center left;}#loader_wait.yui-overlay{position:fixed;float:right;top:10px;right:10px;border:none;text-align:right;}#preview_overlay{border:1px dashed #ccc;text-align:left;padding:0;}#thread_message{font-family:monospace;text-align:left;padding:0;background-color:#eee;font-size:93%;width:450px;}#ysearch{text-align:center;}#ysearchinput{position:static;width:20em;}#ysearchcontainer{text-align:left;width:20em;}.forumcode_code{font-family:monospace;border:1px solid #333;font-size:85%;margin:15px 20px 15px 20px;padding:6px;width:85%;overflow:auto;color:#ff0;background-color:#333;border:1px solid #666;white-space:pre;}.forumcode_pre{background-color:transparent;font-fa!
 mily:monospace;border:1px dashed #333;font-size:85%;margin:15p!
 x 20px 1
5px 20px;padding:6px;width:85%;overflow:auto;white-space:pre;}.forumcode_quote{background-color:#eee;font-family:monospace;font-style:italic;border:1px dotted #333;font-size:85%;margin:15px 20px 15px 20px;padding:6px;width:85%;overflow:auto;}.forumcode_quoting{font-weight:bold;margin-bottom:3px;}.yuimenuitem .disabled{color:#A6A6A6;cursor:default;}.yui-skin-sam .yui-navset .yui-nav,.yui-skin-sam .yui-navset .yui-navset-top .yui-nav{border:solid #333;border-width:0 0 5px;Xposition:relative;zoom:1;}.yui-skin-sam .yui-navset .yui-content{background:transparent;}.yui-skin-sam .yui-navset .yui-nav a,.yui-skin-sam .yui-navset .yui-navset-top .yui-nav a{background-image:none;background-color:#999;border:solid #a3a3a3;border-width:0 1px;color:#fff;text-decoration:none;}.yui-skin-sam .yui-navset .yui-nav .selected a,.yui-skin-sam .yui-navset .yui-nav .selected a:focus,.yui-skin-sam .yui-navset .yui-nav .selected a:hover{background:#333;color:#fff;}.yui-skin-sam .yui-navset .yui-nav a!
 :hover,.yui-skin-sam .yui-navset .yui-nav a:focus{background:#666;color:#fff;outline:0;}
\ No newline at end of file



From chiselwright at mail.berlios.de  Wed Oct  8 01:31:30 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 01:31:30 +0200
Subject: [Parley-svn] r945 - / tags
Message-ID: <200810072331.m97NVUrC021669@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 01:31:29 +0200 (Wed, 08 Oct 2008)
New Revision: 945

Added:
   tags/parley-1.0.1/
Modified:
   /
Log:
 r8189 at wiggin:  chisel | 2008-10-08 00:29:04 +0100
 Tagging v1.0.1



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8188
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8189
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Copied: tags/parley-1.0.1 (from rev 944, trunk)



From chiselwright at mail.berlios.de  Wed Oct  8 11:26:26 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 11:26:26 +0200
Subject: [Parley-svn] r946 - / trunk trunk/lib/Parley
Message-ID: <200810080926.m989QQD9022392@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 11:26:25 +0200 (Wed, 08 Oct 2008)
New Revision: 946

Modified:
   /
   trunk/Changes
   trunk/Makefile.PL
   trunk/ROADMAP
   trunk/lib/Parley/Version.pm
Log:
 r8193 at wiggin:  chisel | 2008-10-08 08:45:02 +0100
 / updated Changed; timestamped v1.0.1
 / version bump to 1.0.2
 / modified roadmap: 1.0.x --> 1.x.0 for future releases, giving room for bug-fixes after each milestone



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8189
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8193
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-07 23:31:29 UTC (rev 945)
+++ trunk/Changes	2008-10-08 09:26:25 UTC (rev 946)
@@ -1,10 +1,11 @@
 This file documents the revision history for Parley.
 
-1.0.1
+1.0.1   Wed Oct  8 00:26:29 BST 2008
     - added config options to use quote_char and name_sep in DB calls
     - updated order_by params in searches to work with quote_char
     - removed config block in Model::ParleyDB (it comes from parley.conf, and
       this saves confusion)
+    - fixed CSS list (ol, ul) item display issue
 
 1.0.0   Mon Oct  6 19:08:22 BST 2008
     - upgrade to YUI 2.5.1

Modified: trunk/Makefile.PL
===================================================================
--- trunk/Makefile.PL	2008-10-07 23:31:29 UTC (rev 945)
+++ trunk/Makefile.PL	2008-10-08 09:26:25 UTC (rev 946)
@@ -8,7 +8,7 @@
 author          ('Chisel Wright<chiselwright at users.berlios.de>');
 abstract        ('Message board / forum application');
 license         ('perl');
-version         ('1.0.1');
+version         ('1.0.2');
 
 requires(
     'Catalyst'                                                  => '5.008001',

Modified: trunk/ROADMAP
===================================================================
--- trunk/ROADMAP	2008-10-07 23:31:29 UTC (rev 945)
+++ trunk/ROADMAP	2008-10-08 09:26:25 UTC (rev 946)
@@ -43,15 +43,15 @@
     - [D] replace Graphics::Magick (Image::Mate?)
     - [D] write decent Getting Started docs
 
-1.0.1:
+1.1.0:
 
     - advanced search
 
-1.0.2:
+1.2.0:
 
     - admin: add/edit/order forums
 
-1.0.3:
+1.3.0:
 
     - user prefs:
         - language preference
@@ -60,7 +60,7 @@
         - realtime time-format example update
         - gravatar support
 
-1.0.4:
+1.4.0:
 
     - quick reply
     - quick help

Modified: trunk/lib/Parley/Version.pm
===================================================================
--- trunk/lib/Parley/Version.pm	2008-10-07 23:31:29 UTC (rev 945)
+++ trunk/lib/Parley/Version.pm	2008-10-08 09:26:25 UTC (rev 946)
@@ -5,7 +5,7 @@
 
 # from mst on #catalyst
 #our $VERSION = '1.000000'; $VERSION = eval $VERSION;
-use version; our $VERSION = qv(1.0.1)->numify;
+use version; our $VERSION = qv(1.0.2)->numify;
 
 
 package Parley::Version;



From chiselwright at mail.berlios.de  Wed Oct  8 11:26:33 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 11:26:33 +0200
Subject: [Parley-svn] r947 - / tags/parley-1.0.1
Message-ID: <200810080926.m989QXjh022469@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 11:26:33 +0200 (Wed, 08 Oct 2008)
New Revision: 947

Modified:
   /
   tags/parley-1.0.1/Changes
   tags/parley-1.0.1/MANIFEST
   tags/parley-1.0.1/MANIFEST.SKIP
Log:
 r8194 at wiggin:  chisel | 2008-10-08 08:50:24 +0100
 / minor tweaks to 1.0.1



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8193
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8194
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: tags/parley-1.0.1/Changes
===================================================================
--- tags/parley-1.0.1/Changes	2008-10-08 09:26:25 UTC (rev 946)
+++ tags/parley-1.0.1/Changes	2008-10-08 09:26:33 UTC (rev 947)
@@ -1,10 +1,11 @@
 This file documents the revision history for Parley.
 
-1.0.1
+1.0.1   Wed Oct  8 00:26:29 BST 2008
     - added config options to use quote_char and name_sep in DB calls
     - updated order_by params in searches to work with quote_char
     - removed config block in Model::ParleyDB (it comes from parley.conf, and
       this saves confusion)
+    - fixed CSS list (ol, ul) item display issue
 
 1.0.0   Mon Oct  6 19:08:22 BST 2008
     - upgrade to YUI 2.5.1

Modified: tags/parley-1.0.1/MANIFEST
===================================================================
--- tags/parley-1.0.1/MANIFEST	2008-10-08 09:26:25 UTC (rev 946)
+++ tags/parley-1.0.1/MANIFEST	2008-10-08 09:26:33 UTC (rev 947)
@@ -29,7 +29,6 @@
 doc/README.admin
 doc/README.gravatar
 doc/setup.html
-inc-wibble/Module/Install.pm
 inc/Module/Install.pm
 inc/Module/Install/Base.pm
 inc/Module/Install/Can.pm
@@ -106,7 +105,6 @@
 MANIFEST.SKIP
 META.yml
 parley.conf
-parley.nl
 README
 ROADMAP
 root/base/about/modules

Modified: tags/parley-1.0.1/MANIFEST.SKIP
===================================================================
--- tags/parley-1.0.1/MANIFEST.SKIP	2008-10-08 09:26:25 UTC (rev 946)
+++ tags/parley-1.0.1/MANIFEST.SKIP	2008-10-08 09:26:33 UTC (rev 947)
@@ -21,3 +21,4 @@
 .*YUI.*
 root/base/yui
 .*\.sqlite3
+\.svk



From chiselwright at mail.berlios.de  Wed Oct  8 11:26:39 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 11:26:39 +0200
Subject: [Parley-svn] r948 - / tags/parley-1.0.1/t.output
Message-ID: <200810080926.m989Qdpi022543@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 11:26:39 +0200 (Wed, 08 Oct 2008)
New Revision: 948

Added:
   tags/parley-1.0.1/t.output/1.0.1
Modified:
   /
Log:
 r8195 at wiggin:  chisel | 2008-10-08 08:53:56 +0100
 + added results from: make test > t.output/1.0.1



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8194
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8195
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Added: tags/parley-1.0.1/t.output/1.0.1
===================================================================
--- tags/parley-1.0.1/t.output/1.0.1	2008-10-08 09:26:33 UTC (rev 947)
+++ tags/parley-1.0.1/t.output/1.0.1	2008-10-08 09:26:39 UTC (rev 948)
@@ -0,0 +1,48 @@
+PERL_DL_NONLAZY=1 /usr/bin/perl "-MExtUtils::Command::MM" "-e" "test_harness(0, 'inc', 'blib/lib', 'blib/arch')" t/*.t t/bug/*.t t/mechanize/*.t t/schema/*.t
+t/01app...................................ok
+t/02pod...................................skipped: Test::Pod 1.14 required
+t/03podcoverage...........................skipped: Test::Pod::Coverage 1.04 required
+t/04_forumcode............................ok
+t/05.userroles............................ok
+t/50.text_search.sql......................ok
+t/bug/01.forum_list_no_posts..............ok
+t/controller_Admin........................ok
+t/controller_Forum........................ok
+t/controller_Help.........................ok
+t/controller_My...........................ok
+t/controller_Post.........................ok
+t/controller_Search.......................ok
+t/controller_Site.........................ok
+t/controller_Terms........................ok
+t/controller_Thread.......................ok
+t/controller_User.........................ok
+t/mechanize/00.login......................ok
+t/mechanize/01.main_page..................ok
+t/mechanize/02.forum......................ok
+t/model_ParleyDB..........................ok
+t/model_Post..............................ok
+t/schema/adminaction......................ok
+t/schema/authentication...................ok
+t/schema/email_queue......................ok
+t/schema/forum............................ok
+t/schema/forum_moderator..................ok
+t/schema/ip_ban...........................ok
+t/schema/ip_ban_type......................ok
+t/schema/logadminaction...................ok
+t/schema/password_reset...................ok
+t/schema/person...........................ok
+t/schema/post.............................ok
+t/schema/preference.......................ok
+t/schema/preference_time_string...........ok
+t/schema/registration_authentication......ok
+t/schema/role.............................ok
+t/schema/terms............................ok
+t/schema/terms_agreed.....................ok
+t/schema/thread...........................ok
+t/schema/thread_view......................ok
+t/schema/user_role........................ok
+t/view_Plain..............................ok
+t/view_TT.................................ok
+All tests successful.
+Files=44, Tests=461, 46 wallclock secs ( 0.18 usr  0.03 sys + 38.41 cusr  2.49 csys = 41.11 CPU)
+Result: PASS



From chiselwright at mail.berlios.de  Wed Oct  8 11:26:46 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 11:26:46 +0200
Subject: [Parley-svn] r949 - / trunk
Message-ID: <200810080926.m989QkF4022620@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 11:26:46 +0200 (Wed, 08 Oct 2008)
New Revision: 949

Modified:
   /
   trunk/MANIFEST
   trunk/MANIFEST.SKIP
Log:
 r8196 at wiggin:  chisel | 2008-10-08 08:55:26 +0100
 / remove undesirables from MANIFEST
 + ignore '.svk' directory (floating svk checkout)



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8195
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8196
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/MANIFEST
===================================================================
--- trunk/MANIFEST	2008-10-08 09:26:39 UTC (rev 948)
+++ trunk/MANIFEST	2008-10-08 09:26:46 UTC (rev 949)
@@ -29,7 +29,6 @@
 doc/README.admin
 doc/README.gravatar
 doc/setup.html
-inc-wibble/Module/Install.pm
 inc/Module/Install.pm
 inc/Module/Install/Base.pm
 inc/Module/Install/Can.pm
@@ -106,7 +105,6 @@
 MANIFEST.SKIP
 META.yml
 parley.conf
-parley.nl
 README
 ROADMAP
 root/base/about/modules

Modified: trunk/MANIFEST.SKIP
===================================================================
--- trunk/MANIFEST.SKIP	2008-10-08 09:26:39 UTC (rev 948)
+++ trunk/MANIFEST.SKIP	2008-10-08 09:26:46 UTC (rev 949)
@@ -21,3 +21,4 @@
 .*YUI.*
 root/base/yui
 .*\.sqlite3
+\.svk



From chiselwright at mail.berlios.de  Wed Oct  8 12:47:16 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 12:47:16 +0200
Subject: [Parley-svn] r950 - / trunk/root/base/help/i_default
Message-ID: <200810081047.m98AlGNW017789@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 12:47:10 +0200 (Wed, 08 Oct 2008)
New Revision: 950

Modified:
   /
   trunk/root/base/help/i_default/contents
Log:
 r8201 at wiggin:  chisel | 2008-10-08 11:46:31 +0100
 / fixed typo



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8196
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8201
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/root/base/help/i_default/contents
===================================================================
--- trunk/root/base/help/i_default/contents	2008-10-08 09:26:46 UTC (rev 949)
+++ trunk/root/base/help/i_default/contents	2008-10-08 10:47:10 UTC (rev 950)
@@ -10,7 +10,7 @@
 
 <h2>Posting</h2>
 <ol start="2">
-    <li><a href="help/formatting_posts">Adding (ForumCode) formating to posts</a></li>
+    <li><a href="help/formatting_posts">Adding (ForumCode) formattiing to posts</a></li>
 </ol>
 
 <h2>General Information</h2>



From chiselwright at mail.berlios.de  Wed Oct  8 13:17:39 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 13:17:39 +0200
Subject: [Parley-svn] r951 - / trunk/root/base/help/i_default
Message-ID: <200810081117.m98BHdWq020888@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 13:17:38 +0200 (Wed, 08 Oct 2008)
New Revision: 951

Modified:
   /
   trunk/root/base/help/i_default/contents
Log:
 r8203 at wiggin:  chisel | 2008-10-08 12:15:19 +0100
 / fixing the typo I introduced when fixing the previous typo



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8201
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8203
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/root/base/help/i_default/contents
===================================================================
--- trunk/root/base/help/i_default/contents	2008-10-08 10:47:10 UTC (rev 950)
+++ trunk/root/base/help/i_default/contents	2008-10-08 11:17:38 UTC (rev 951)
@@ -10,7 +10,7 @@
 
 <h2>Posting</h2>
 <ol start="2">
-    <li><a href="help/formatting_posts">Adding (ForumCode) formattiing to posts</a></li>
+    <li><a href="help/formatting_posts">Adding (ForumCode) formatting to posts</a></li>
 </ol>
 
 <h2>General Information</h2>



From chiselwright at mail.berlios.de  Wed Oct  8 13:42:52 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 8 Oct 2008 13:42:52 +0200
Subject: [Parley-svn] r952 - / tags/parley-0.53 tags/parley-0.53/db
 tags/parley-0.53/lib tags/parley-0.53/lib/Parley/Controller
 tags/parley-0.53/lib/Parley/Controller/User
 tags/parley-0.53/lib/Parley/Schema tags/parley-0.53/lib/Template/Plugin
 tags/parley-0.53/root/base/forum tags/parley-0.53/root/base/menu
 tags/parley-0.53/root/base/menu/left tags/parley-0.53/root/base/my
 tags/parley-0.53/root/base/thread tags/parley-0.53/root/css
 tags/parley-0.53/root/static/magic tags/parley-0.53/root/static/magic/src
 tags/parley-0.53/root/static/magic/src/animation
 tags/parley-0.53/root/static/magic/src/collections
 tags/parley-0.53/root/static/magic/src/compat
 tags/parley-0.53/root/static/magic/src/crypto
 tags/parley-0.53/root/static/magic/src/data
 tags/parley-0.53/root/static/magic/src/data/format
 tags/parley-0.53/root/static/magic/src/data/provider
 tags/parley-0.53/root/static/magic/src/debug
 tags/parley-0.53/root/static/magic/src/dnd
 tags/parley-0.53/root/static/magic/src/event tags/parley-0.53/ro!
 ot/static/magic/src/flash/flash6 tags/parley-0.53/root/static/magic/src/fx
 tags/parley-0.53/root/static/magic/src/graphics
 tags/parley-0.53/root/static/magic/src/graphics/color
 tags/parley-0.53/root/static/magic/src/html
 tags/parley-0.53/root/static/magic/src/html/images
 tags/parley-0.53/root/static/magic/src/i18n
 tags/parley-0.53/root/static/magic/src/io
 tags/parley-0.53/root/static/magic/src/lang
 tags/parley-0.53/root/static/magic/src/lfx
 tags/parley-0.53/root/static/magic/src/logging
 tags/parley-0.53/root/static/magic/src/math
 tags/parley-0.53/root/static/magic/src/reflect
 tags/parley-0.53/root/static/magic/src/rpc
 tags/parley-0.53/root/static/magic/src/selection
 tags/parley-0.53/root/static/magic/src/storage
 tags/parley-0.53/root/static/magic/src/string
 tags/parley-0.53/root/static/magic/src/text
 tags/parley-0.53/root/static/magic/src/undo
 tags/parley-0.53/root/static/magic/src/uri
 tags/parley-0.53/root/static/magic/src/uuid
 tags/parley-0.53/root/static/magic/src/valida! te
 tags/parley-0.53/root/static/magic/src/widget tags/parley-0! .53/root
Message-ID: <200810081142.m98BgqI8029453@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-08 13:42:12 +0200 (Wed, 08 Oct 2008)
New Revision: 952

Added:
   tags/parley-0.53/root/static/magic/src/bootstrap2.js
   tags/parley-0.53/root/static/magic/src/compat/
   tags/parley-0.53/root/static/magic/src/compat/0.2.2.js
   tags/parley-0.53/root/static/magic/src/data/Attribute.js
   tags/parley-0.53/root/static/magic/src/data/Item.js
   tags/parley-0.53/root/static/magic/src/data/Kind.js
   tags/parley-0.53/root/static/magic/src/data/Observable.js
   tags/parley-0.53/root/static/magic/src/data/ResultSet.js
   tags/parley-0.53/root/static/magic/src/data/Type.js
   tags/parley-0.53/root/static/magic/src/data/Value.js
   tags/parley-0.53/root/static/magic/src/data/__package__.js
   tags/parley-0.53/root/static/magic/src/data/format/
   tags/parley-0.53/root/static/magic/src/data/format/Csv.js
   tags/parley-0.53/root/static/magic/src/data/format/Json.js
   tags/parley-0.53/root/static/magic/src/data/provider/
   tags/parley-0.53/root/static/magic/src/data/provider/Base.js
   tags/parley-0.53/root/static/magic/src/data/provider/Delicious.js
   tags/parley-0.53/root/static/magic/src/data/provider/FlatFile.js
   tags/parley-0.53/root/static/magic/src/data/provider/JotSpot.js
   tags/parley-0.53/root/static/magic/src/data/provider/MySql.js
   tags/parley-0.53/root/static/magic/src/data/to_do.txt
   tags/parley-0.53/root/static/magic/src/doc.js
   tags/parley-0.53/root/static/magic/src/fx/
   tags/parley-0.53/root/static/magic/src/fx/__package__.js
   tags/parley-0.53/root/static/magic/src/fx/html.js
   tags/parley-0.53/root/static/magic/src/fx/svg.js
   tags/parley-0.53/root/static/magic/src/html/extras.js
   tags/parley-0.53/root/static/magic/src/html/images/shadowTR..png
   tags/parley-0.53/root/static/magic/src/io/ShortBusIO.js
   tags/parley-0.53/root/static/magic/src/io/ShortBusInit.html
   tags/parley-0.53/root/static/magic/src/io/cookies.js
   tags/parley-0.53/root/static/magic/src/lang/Lang.js
   tags/parley-0.53/root/static/magic/src/math/Math.js
   tags/parley-0.53/root/static/magic/src/reflect/
   tags/parley-0.53/root/static/magic/src/reflect/__package__.js
   tags/parley-0.53/root/static/magic/src/reflect/reflection.js
   tags/parley-0.53/root/static/magic/src/storage/dashboard.js
   tags/parley-0.53/root/static/magic/src/text/Builder.js
   tags/parley-0.53/root/static/magic/src/text/String.js
   tags/parley-0.53/root/static/magic/src/text/Text.js
   tags/parley-0.53/root/static/magic/src/widget/AccordionPane.js
   tags/parley-0.53/root/static/magic/src/widget/Button2.js
   tags/parley-0.53/root/static/magic/src/widget/CiviCrmDatePicker.js
   tags/parley-0.53/root/static/magic/src/widget/ContextMenu.js
   tags/parley-0.53/root/static/magic/src/widget/DropdownButton.js
   tags/parley-0.53/root/static/magic/src/widget/Menu.js
   tags/parley-0.53/root/static/magic/src/widget/MenuItem.js
   tags/parley-0.53/root/static/magic/src/widget/PopUpButton.js
   tags/parley-0.53/root/static/magic/src/widget/SimpleDropdownButtons.js
   tags/parley-0.53/root/static/magic/src/widget/html/AccordionPane.js
   tags/parley-0.53/root/static/magic/src/widget/html/Button2.js
   tags/parley-0.53/root/static/magic/src/widget/html/Checkbox.js
   tags/parley-0.53/root/static/magic/src/widget/html/ComboBox.js
   tags/parley-0.53/root/static/magic/src/widget/html/ContentPane.js
   tags/parley-0.53/root/static/magic/src/widget/html/ContextMenu.js
   tags/parley-0.53/root/static/magic/src/widget/html/DatePicker.js
   tags/parley-0.53/root/static/magic/src/widget/html/DebugConsole.js
   tags/parley-0.53/root/static/magic/src/widget/html/DocPane.js
   tags/parley-0.53/root/static/magic/src/widget/html/DropdownButton.js
   tags/parley-0.53/root/static/magic/src/widget/html/GoogleMap.js
   tags/parley-0.53/root/static/magic/src/widget/html/LinkPane.js
   tags/parley-0.53/root/static/magic/src/widget/html/Menu.js
   tags/parley-0.53/root/static/magic/src/widget/html/MenuItem.js
   tags/parley-0.53/root/static/magic/src/widget/html/MonthlyCalendar.js
   tags/parley-0.53/root/static/magic/src/widget/html/Show.js
   tags/parley-0.53/root/static/magic/src/widget/html/ShowAction.js
   tags/parley-0.53/root/static/magic/src/widget/html/ShowSlide.js
   tags/parley-0.53/root/static/magic/src/widget/html/Slider.js
   tags/parley-0.53/root/static/magic/src/widget/html/SortableTable.js
   tags/parley-0.53/root/static/magic/src/widget/html/Spinner.js
   tags/parley-0.53/root/static/magic/src/widget/html/TaskBar.js
   tags/parley-0.53/root/static/magic/src/widget/html/TimePicker.js
   tags/parley-0.53/root/static/magic/src/widget/html/TitlePane.js
   tags/parley-0.53/root/static/magic/src/widget/html/Tooltip.js
   tags/parley-0.53/root/static/magic/src/widget/html/YahooMap.js
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCheckBox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDialog.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFisheyeList.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenu2.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizeHandle.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderVertical.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSplitContainer.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.html
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlToolbar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css
   tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/buttons/-.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check_disabled_off.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check_disabled_on.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check_hover_off.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check_hover_on.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check_off.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check_on.gif
   tags/parley-0.53/root/static/magic/src/xml/domUtil.js
   tags/parley-0.53/root/static/magic/src/xml/htmlUtil.js
   tags/parley-0.53/root/static/magic/src/xml/svgUtil.js
Removed:
   tags/parley-0.53/root/css/common.css
   tags/parley-0.53/root/css/layout23.css
   tags/parley-0.53/root/css/layout27.css
   tags/parley-0.53/root/css/layout33.css
   tags/parley-0.53/root/static/magic/src-0.4.2/
   tags/parley-0.53/root/static/magic/src/DeferredList.js
   tags/parley-0.53/root/static/magic/src/a11y.js
   tags/parley-0.53/root/static/magic/src/browser_debug_xd.js
   tags/parley-0.53/root/static/magic/src/cal/
   tags/parley-0.53/root/static/magic/src/charting/
   tags/parley-0.53/root/static/magic/src/collections/Store.js
   tags/parley-0.53/root/static/magic/src/data/CsvStore.js
   tags/parley-0.53/root/static/magic/src/data/OpmlStore.js
   tags/parley-0.53/root/static/magic/src/data/RdfStore.js
   tags/parley-0.53/root/static/magic/src/data/YahooStore.js
   tags/parley-0.53/root/static/magic/src/data/core/
   tags/parley-0.53/root/static/magic/src/data/old/
   tags/parley-0.53/root/static/magic/src/date/
   tags/parley-0.53/root/static/magic/src/debug/console.js
   tags/parley-0.53/root/static/magic/src/dnd/HtmlDragCopy.js
   tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDropV3.js
   tags/parley-0.53/root/static/magic/src/docs.js
   tags/parley-0.53/root/static/magic/src/event/common.js
   tags/parley-0.53/root/static/magic/src/gfx/
   tags/parley-0.53/root/static/magic/src/html/color.js
   tags/parley-0.53/root/static/magic/src/html/common.js
   tags/parley-0.53/root/static/magic/src/html/display.js
   tags/parley-0.53/root/static/magic/src/html/iframe.js
   tags/parley-0.53/root/static/magic/src/html/metrics.js
   tags/parley-0.53/root/static/magic/src/html/selection.js
   tags/parley-0.53/root/static/magic/src/html/style.js
   tags/parley-0.53/root/static/magic/src/html/util.js
   tags/parley-0.53/root/static/magic/src/i18n/calendar/
   tags/parley-0.53/root/static/magic/src/i18n/currency.js
   tags/parley-0.53/root/static/magic/src/i18n/currency/
   tags/parley-0.53/root/static/magic/src/i18n/number.js
   tags/parley-0.53/root/static/magic/src/io/XhrIframeProxy.js
   tags/parley-0.53/root/static/magic/src/io/cometd.js
   tags/parley-0.53/root/static/magic/src/io/common.js
   tags/parley-0.53/root/static/magic/src/io/xip_client.html
   tags/parley-0.53/root/static/magic/src/io/xip_server.html
   tags/parley-0.53/root/static/magic/src/lang/timing/
   tags/parley-0.53/root/static/magic/src/lfx/rounded.js
   tags/parley-0.53/root/static/magic/src/lfx/shadow.js
   tags/parley-0.53/root/static/magic/src/logging/ConsoleLogger.js
   tags/parley-0.53/root/static/magic/src/namespaces/
   tags/parley-0.53/root/static/magic/src/ns.js
   tags/parley-0.53/root/static/magic/src/storage/java/
   tags/parley-0.53/root/static/magic/src/uri/cache.js
   tags/parley-0.53/root/static/magic/src/validate/creditCard.js
   tags/parley-0.53/root/static/magic/src/widget/Clock.js
   tags/parley-0.53/root/static/magic/src/widget/CurrencyTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/DateTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/DropdownTimePicker.js
   tags/parley-0.53/root/static/magic/src/widget/Editor2Plugin/
   tags/parley-0.53/root/static/magic/src/widget/FilteringTable.js
   tags/parley-0.53/root/static/magic/src/widget/Form.js
   tags/parley-0.53/root/static/magic/src/widget/IntegerTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/InternetTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/PageContainer.js
   tags/parley-0.53/root/static/magic/src/widget/PopupContainer.js
   tags/parley-0.53/root/static/magic/src/widget/ProgressBar.js
   tags/parley-0.53/root/static/magic/src/widget/RadioGroup.js
   tags/parley-0.53/root/static/magic/src/widget/RealNumberTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/RegexpTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/RemoteTabController.js
   tags/parley-0.53/root/static/magic/src/widget/Repeater.js
   tags/parley-0.53/root/static/magic/src/widget/Slider.js
   tags/parley-0.53/root/static/magic/src/widget/Textbox.js
   tags/parley-0.53/root/static/magic/src/widget/Toaster.js
   tags/parley-0.53/root/static/magic/src/widget/TreeBasicControllerV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeCommon.js
   tags/parley-0.53/root/static/magic/src/widget/TreeContextMenuV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeDemo.js
   tags/parley-0.53/root/static/magic/src/widget/TreeDeselectOnDblselect.js
   tags/parley-0.53/root/static/magic/src/widget/TreeDisableWrapExtension.js
   tags/parley-0.53/root/static/magic/src/widget/TreeDndControllerV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeDocIconExtension.js
   tags/parley-0.53/root/static/magic/src/widget/TreeEditor.js
   tags/parley-0.53/root/static/magic/src/widget/TreeEmphasizeOnSelect.js
   tags/parley-0.53/root/static/magic/src/widget/TreeExpandToNodeOnSelect.js
   tags/parley-0.53/root/static/magic/src/widget/TreeExtension.js
   tags/parley-0.53/root/static/magic/src/widget/TreeLinkExtension.js
   tags/parley-0.53/root/static/magic/src/widget/TreeLoadingControllerV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeNodeV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeRpcControllerV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeSelectorV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeTimeoutIterator.js
   tags/parley-0.53/root/static/magic/src/widget/TreeToggleOnSelect.js
   tags/parley-0.53/root/static/magic/src/widget/TreeV3.js
   tags/parley-0.53/root/static/magic/src/widget/TreeWithNode.js
   tags/parley-0.53/root/static/magic/src/widget/UsTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/ValidationTextbox.js
   tags/parley-0.53/root/static/magic/src/widget/html/layout.js
   tags/parley-0.53/root/static/magic/src/widget/html/loader.js
   tags/parley-0.53/root/static/magic/src/widget/nls/
   tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.css
   tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.html
   tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/CheckboxA11y.html
   tags/parley-0.53/root/static/magic/src/widget/templates/CiviCrmDatePicker.html
   tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/ComboButtonTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.css
   tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Dialog.html
   tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.css
   tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.html
   tags/parley-0.53/root/static/magic/src/widget/templates/DropDownButtonTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Editor2/
   tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.html
   tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbarOneline.html
   tags/parley-0.53/root/static/magic/src/widget/templates/FisheyeList.css
   tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.css
   tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.html
   tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.css
   tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Menu2.css
   tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.html
   tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.html
   tags/parley-0.53/root/static/magic/src/widget/templates/RemoteTabControl.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.html
   tags/parley-0.53/root/static/magic/src/widget/templates/ResizeHandle.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Show.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Show.html
   tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.html
   tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.css
   tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Slider.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Slider.html
   tags/parley-0.53/root/static/magic/src/widget/templates/SliderHorizontal.html
   tags/parley-0.53/root/static/magic/src/widget/templates/SliderVertical.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.html
   tags/parley-0.53/root/static/magic/src/widget/templates/SplitContainer.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.html
   tags/parley-0.53/root/static/magic/src/widget/templates/TabContainerA11y.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TaskBar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TaskBarItemTemplate.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Textbox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.html
   tags/parley-0.53/root/static/magic/src/widget/templates/Toaster.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Toolbar.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TooltipTemplate.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TreeDisableWrap.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TreeDocIcon.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TreeEditor.css
   tags/parley-0.53/root/static/magic/src/widget/templates/TreeV3.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Validate.css
   tags/parley-0.53/root/static/magic/src/widget/templates/ValidationTextbox.html
   tags/parley-0.53/root/static/magic/src/widget/templates/buttons/sep.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/check.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/TreeV3/
   tags/parley-0.53/root/static/magic/src/widget/templates/images/bar.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/clock.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/dpMonthBg2.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/dpYearBg.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/h-bar.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-bg-progress-vert.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_down_arrow.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_left_arrow.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_right_arrow.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_up_arrow.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaAccordionOff.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaAccordionSelected.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaBarBg.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaMenuBg.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/submenu_disabled.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/timeIcon.gif
   tags/parley-0.53/root/static/magic/src/xml/XslTransform.js
Modified:
   /
   tags/parley-0.53/Makefile.PL
   tags/parley-0.53/db/parley.psql
   tags/parley-0.53/db/patch_0.09_to_0.10.psql
   tags/parley-0.53/lib/Parley.pm
   tags/parley-0.53/lib/Parley/Controller/Post.pm
   tags/parley-0.53/lib/Parley/Controller/Root.pm
   tags/parley-0.53/lib/Parley/Controller/Thread.pm
   tags/parley-0.53/lib/Parley/Controller/User.pm
   tags/parley-0.53/lib/Parley/Controller/User/SignUp.pm
   tags/parley-0.53/lib/Parley/Schema/EmailQueue.pm
   tags/parley-0.53/lib/Parley/Schema/Post.pm
   tags/parley-0.53/lib/Parley/Schema/Preference.pm
   tags/parley-0.53/lib/Parley/Schema/Thread.pm
   tags/parley-0.53/lib/Parley/Schema/ThreadView.pm
   tags/parley-0.53/lib/Template/Plugin/ForumCode.pm
   tags/parley-0.53/parley.yml
   tags/parley-0.53/root/base/forum/list
   tags/parley-0.53/root/base/forum/view
   tags/parley-0.53/root/base/menu/left/main
   tags/parley-0.53/root/base/menu/statusbar
   tags/parley-0.53/root/base/my/preferences
   tags/parley-0.53/root/base/thread/add
   tags/parley-0.53/root/base/thread/reply
   tags/parley-0.53/root/css/default.css
   tags/parley-0.53/root/static/magic/dojo.js
   tags/parley-0.53/root/static/magic/iframe_history.html
   tags/parley-0.53/root/static/magic/src/AdapterRegistry.js
   tags/parley-0.53/root/static/magic/src/Deferred.js
   tags/parley-0.53/root/static/magic/src/animation.js
   tags/parley-0.53/root/static/magic/src/animation/Animation.js
   tags/parley-0.53/root/static/magic/src/animation/AnimationEvent.js
   tags/parley-0.53/root/static/magic/src/animation/AnimationSequence.js
   tags/parley-0.53/root/static/magic/src/animation/Timer.js
   tags/parley-0.53/root/static/magic/src/animation/__package__.js
   tags/parley-0.53/root/static/magic/src/behavior.js
   tags/parley-0.53/root/static/magic/src/bootstrap1.js
   tags/parley-0.53/root/static/magic/src/browser_debug.js
   tags/parley-0.53/root/static/magic/src/collections/ArrayList.js
   tags/parley-0.53/root/static/magic/src/collections/BinaryTree.js
   tags/parley-0.53/root/static/magic/src/collections/Collections.js
   tags/parley-0.53/root/static/magic/src/collections/Dictionary.js
   tags/parley-0.53/root/static/magic/src/collections/Graph.js
   tags/parley-0.53/root/static/magic/src/collections/Queue.js
   tags/parley-0.53/root/static/magic/src/collections/Set.js
   tags/parley-0.53/root/static/magic/src/collections/SkipList.js
   tags/parley-0.53/root/static/magic/src/collections/SortedList.js
   tags/parley-0.53/root/static/magic/src/collections/Stack.js
   tags/parley-0.53/root/static/magic/src/collections/__package__.js
   tags/parley-0.53/root/static/magic/src/crypto.js
   tags/parley-0.53/root/static/magic/src/crypto/Blowfish.js
   tags/parley-0.53/root/static/magic/src/crypto/MD5.js
   tags/parley-0.53/root/static/magic/src/crypto/Rijndael.js
   tags/parley-0.53/root/static/magic/src/crypto/SHA1.js
   tags/parley-0.53/root/static/magic/src/crypto/SHA256.js
   tags/parley-0.53/root/static/magic/src/crypto/__package__.js
   tags/parley-0.53/root/static/magic/src/data.js
   tags/parley-0.53/root/static/magic/src/date.js
   tags/parley-0.53/root/static/magic/src/debug.js
   tags/parley-0.53/root/static/magic/src/debug/Firebug.js
   tags/parley-0.53/root/static/magic/src/debug/deep.html
   tags/parley-0.53/root/static/magic/src/dnd/DragAndDrop.js
   tags/parley-0.53/root/static/magic/src/dnd/HtmlDragAndDrop.js
   tags/parley-0.53/root/static/magic/src/dnd/HtmlDragManager.js
   tags/parley-0.53/root/static/magic/src/dnd/HtmlDragMove.js
   tags/parley-0.53/root/static/magic/src/dnd/Sortable.js
   tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDrop.js
   tags/parley-0.53/root/static/magic/src/dnd/__package__.js
   tags/parley-0.53/root/static/magic/src/dom.js
   tags/parley-0.53/root/static/magic/src/event.js
   tags/parley-0.53/root/static/magic/src/event/__package__.js
   tags/parley-0.53/root/static/magic/src/event/browser.js
   tags/parley-0.53/root/static/magic/src/event/topic.js
   tags/parley-0.53/root/static/magic/src/experimental.js
   tags/parley-0.53/root/static/magic/src/flash.js
   tags/parley-0.53/root/static/magic/src/flash/flash6/DojoExternalInterface.as
   tags/parley-0.53/root/static/magic/src/graphics/Colorspace.js
   tags/parley-0.53/root/static/magic/src/graphics/__package__.js
   tags/parley-0.53/root/static/magic/src/graphics/color.js
   tags/parley-0.53/root/static/magic/src/graphics/color/hsl.js
   tags/parley-0.53/root/static/magic/src/graphics/color/hsv.js
   tags/parley-0.53/root/static/magic/src/hostenv_adobesvg.js
   tags/parley-0.53/root/static/magic/src/hostenv_browser.js
   tags/parley-0.53/root/static/magic/src/hostenv_dashboard.js
   tags/parley-0.53/root/static/magic/src/hostenv_jsc.js
   tags/parley-0.53/root/static/magic/src/hostenv_rhino.js
   tags/parley-0.53/root/static/magic/src/hostenv_spidermonkey.js
   tags/parley-0.53/root/static/magic/src/hostenv_svg.js
   tags/parley-0.53/root/static/magic/src/hostenv_wsh.js
   tags/parley-0.53/root/static/magic/src/html.js
   tags/parley-0.53/root/static/magic/src/html/__package__.js
   tags/parley-0.53/root/static/magic/src/html/layout.js
   tags/parley-0.53/root/static/magic/src/html/shadow.js
   tags/parley-0.53/root/static/magic/src/i18n/common.js
   tags/parley-0.53/root/static/magic/src/iCalendar.js
   tags/parley-0.53/root/static/magic/src/io.js
   tags/parley-0.53/root/static/magic/src/io/BrowserIO.js
   tags/parley-0.53/root/static/magic/src/io/IframeIO.js
   tags/parley-0.53/root/static/magic/src/io/RepubsubIO.js
   tags/parley-0.53/root/static/magic/src/io/RhinoIO.js
   tags/parley-0.53/root/static/magic/src/io/ScriptSrcIO.js
   tags/parley-0.53/root/static/magic/src/io/__package__.js
   tags/parley-0.53/root/static/magic/src/io/cookie.js
   tags/parley-0.53/root/static/magic/src/json.js
   tags/parley-0.53/root/static/magic/src/lang.js
   tags/parley-0.53/root/static/magic/src/lang/__package__.js
   tags/parley-0.53/root/static/magic/src/lang/array.js
   tags/parley-0.53/root/static/magic/src/lang/assert.js
   tags/parley-0.53/root/static/magic/src/lang/common.js
   tags/parley-0.53/root/static/magic/src/lang/declare.js
   tags/parley-0.53/root/static/magic/src/lang/extras.js
   tags/parley-0.53/root/static/magic/src/lang/func.js
   tags/parley-0.53/root/static/magic/src/lang/repr.js
   tags/parley-0.53/root/static/magic/src/lang/type.js
   tags/parley-0.53/root/static/magic/src/lfx/Animation.js
   tags/parley-0.53/root/static/magic/src/lfx/__package__.js
   tags/parley-0.53/root/static/magic/src/lfx/extras.js
   tags/parley-0.53/root/static/magic/src/lfx/html.js
   tags/parley-0.53/root/static/magic/src/lfx/toggle.js
   tags/parley-0.53/root/static/magic/src/loader.js
   tags/parley-0.53/root/static/magic/src/loader_xd.js
   tags/parley-0.53/root/static/magic/src/logging/Logger.js
   tags/parley-0.53/root/static/magic/src/logging/__package__.js
   tags/parley-0.53/root/static/magic/src/math.js
   tags/parley-0.53/root/static/magic/src/math/__package__.js
   tags/parley-0.53/root/static/magic/src/math/curves.js
   tags/parley-0.53/root/static/magic/src/math/matrix.js
   tags/parley-0.53/root/static/magic/src/math/points.js
   tags/parley-0.53/root/static/magic/src/profile.js
   tags/parley-0.53/root/static/magic/src/regexp.js
   tags/parley-0.53/root/static/magic/src/rpc/Deferred.js
   tags/parley-0.53/root/static/magic/src/rpc/JotService.js
   tags/parley-0.53/root/static/magic/src/rpc/JsonService.js
   tags/parley-0.53/root/static/magic/src/rpc/RpcService.js
   tags/parley-0.53/root/static/magic/src/rpc/YahooService.js
   tags/parley-0.53/root/static/magic/src/rpc/__package__.js
   tags/parley-0.53/root/static/magic/src/rpc/yahoo.smd
   tags/parley-0.53/root/static/magic/src/selection/Selection.js
   tags/parley-0.53/root/static/magic/src/storage.js
   tags/parley-0.53/root/static/magic/src/storage/Storage.as
   tags/parley-0.53/root/static/magic/src/storage/__package__.js
   tags/parley-0.53/root/static/magic/src/storage/browser.js
   tags/parley-0.53/root/static/magic/src/string.js
   tags/parley-0.53/root/static/magic/src/string/Builder.js
   tags/parley-0.53/root/static/magic/src/string/__package__.js
   tags/parley-0.53/root/static/magic/src/string/common.js
   tags/parley-0.53/root/static/magic/src/string/extras.js
   tags/parley-0.53/root/static/magic/src/style.js
   tags/parley-0.53/root/static/magic/src/svg.js
   tags/parley-0.53/root/static/magic/src/text/__package__.js
   tags/parley-0.53/root/static/magic/src/text/textDirectory.js
   tags/parley-0.53/root/static/magic/src/undo/Manager.js
   tags/parley-0.53/root/static/magic/src/undo/__package__.js
   tags/parley-0.53/root/static/magic/src/undo/browser.js
   tags/parley-0.53/root/static/magic/src/uri/Uri.js
   tags/parley-0.53/root/static/magic/src/uri/__package__.js
   tags/parley-0.53/root/static/magic/src/uuid/LightweightGenerator.js
   tags/parley-0.53/root/static/magic/src/uuid/NameBasedGenerator.js
   tags/parley-0.53/root/static/magic/src/uuid/NilGenerator.js
   tags/parley-0.53/root/static/magic/src/uuid/RandomGenerator.js
   tags/parley-0.53/root/static/magic/src/uuid/TimeBasedGenerator.js
   tags/parley-0.53/root/static/magic/src/uuid/Uuid.js
   tags/parley-0.53/root/static/magic/src/uuid/__package__.js
   tags/parley-0.53/root/static/magic/src/validate.js
   tags/parley-0.53/root/static/magic/src/validate/__package__.js
   tags/parley-0.53/root/static/magic/src/validate/check.js
   tags/parley-0.53/root/static/magic/src/validate/common.js
   tags/parley-0.53/root/static/magic/src/validate/datetime.js
   tags/parley-0.53/root/static/magic/src/validate/de.js
   tags/parley-0.53/root/static/magic/src/validate/jp.js
   tags/parley-0.53/root/static/magic/src/validate/us.js
   tags/parley-0.53/root/static/magic/src/validate/web.js
   tags/parley-0.53/root/static/magic/src/widget/AccordionContainer.js
   tags/parley-0.53/root/static/magic/src/widget/AnimatedPng.js
   tags/parley-0.53/root/static/magic/src/widget/Button.js
   tags/parley-0.53/root/static/magic/src/widget/Chart.js
   tags/parley-0.53/root/static/magic/src/widget/Checkbox.js
   tags/parley-0.53/root/static/magic/src/widget/ColorPalette.js
   tags/parley-0.53/root/static/magic/src/widget/ComboBox.js
   tags/parley-0.53/root/static/magic/src/widget/ContentPane.js
   tags/parley-0.53/root/static/magic/src/widget/DatePicker.js
   tags/parley-0.53/root/static/magic/src/widget/DebugConsole.js
   tags/parley-0.53/root/static/magic/src/widget/Dialog.js
   tags/parley-0.53/root/static/magic/src/widget/DocPane.js
   tags/parley-0.53/root/static/magic/src/widget/DomWidget.js
   tags/parley-0.53/root/static/magic/src/widget/DropdownContainer.js
   tags/parley-0.53/root/static/magic/src/widget/DropdownDatePicker.js
   tags/parley-0.53/root/static/magic/src/widget/Editor.js
   tags/parley-0.53/root/static/magic/src/widget/Editor2.js
   tags/parley-0.53/root/static/magic/src/widget/Editor2Toolbar.js
   tags/parley-0.53/root/static/magic/src/widget/FisheyeList.js
   tags/parley-0.53/root/static/magic/src/widget/FloatingPane.js
   tags/parley-0.53/root/static/magic/src/widget/GoogleMap.js
   tags/parley-0.53/root/static/magic/src/widget/HtmlWidget.js
   tags/parley-0.53/root/static/magic/src/widget/InlineEditBox.js
   tags/parley-0.53/root/static/magic/src/widget/LayoutContainer.js
   tags/parley-0.53/root/static/magic/src/widget/LinkPane.js
   tags/parley-0.53/root/static/magic/src/widget/Manager.js
   tags/parley-0.53/root/static/magic/src/widget/Menu2.js
   tags/parley-0.53/root/static/magic/src/widget/MonthlyCalendar.js
   tags/parley-0.53/root/static/magic/src/widget/Parse.js
   tags/parley-0.53/root/static/magic/src/widget/ResizableTextarea.js
   tags/parley-0.53/root/static/magic/src/widget/ResizeHandle.js
   tags/parley-0.53/root/static/magic/src/widget/RichText.js
   tags/parley-0.53/root/static/magic/src/widget/Rounded.js
   tags/parley-0.53/root/static/magic/src/widget/Select.js
   tags/parley-0.53/root/static/magic/src/widget/Show.js
   tags/parley-0.53/root/static/magic/src/widget/ShowAction.js
   tags/parley-0.53/root/static/magic/src/widget/ShowSlide.js
   tags/parley-0.53/root/static/magic/src/widget/SlideShow.js
   tags/parley-0.53/root/static/magic/src/widget/SortableTable.js
   tags/parley-0.53/root/static/magic/src/widget/Spinner.js
   tags/parley-0.53/root/static/magic/src/widget/SplitContainer.js
   tags/parley-0.53/root/static/magic/src/widget/SvgButton.js
   tags/parley-0.53/root/static/magic/src/widget/SvgWidget.js
   tags/parley-0.53/root/static/magic/src/widget/SwtWidget.js
   tags/parley-0.53/root/static/magic/src/widget/TabContainer.js
   tags/parley-0.53/root/static/magic/src/widget/TaskBar.js
   tags/parley-0.53/root/static/magic/src/widget/TimePicker.js
   tags/parley-0.53/root/static/magic/src/widget/TitlePane.js
   tags/parley-0.53/root/static/magic/src/widget/Toggler.js
   tags/parley-0.53/root/static/magic/src/widget/Toolbar.js
   tags/parley-0.53/root/static/magic/src/widget/Tooltip.js
   tags/parley-0.53/root/static/magic/src/widget/Tree.js
   tags/parley-0.53/root/static/magic/src/widget/TreeBasicController.js
   tags/parley-0.53/root/static/magic/src/widget/TreeContextMenu.js
   tags/parley-0.53/root/static/magic/src/widget/TreeControllerExtension.js
   tags/parley-0.53/root/static/magic/src/widget/TreeLoadingController.js
   tags/parley-0.53/root/static/magic/src/widget/TreeNode.js
   tags/parley-0.53/root/static/magic/src/widget/TreeRPCController.js
   tags/parley-0.53/root/static/magic/src/widget/TreeSelector.js
   tags/parley-0.53/root/static/magic/src/widget/Widget.js
   tags/parley-0.53/root/static/magic/src/widget/Wizard.js
   tags/parley-0.53/root/static/magic/src/widget/YahooMap.js
   tags/parley-0.53/root/static/magic/src/widget/__package__.js
   tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoContainer.js
   tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoItem.js
   tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoNavigator.js
   tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoPane.js
   tags/parley-0.53/root/static/magic/src/widget/demoEngine/SourcePane.js
   tags/parley-0.53/root/static/magic/src/widget/demoEngine/__package__.js
   tags/parley-0.53/root/static/magic/src/widget/html/stabile.js
   tags/parley-0.53/root/static/magic/src/widget/svg/Chart.js
   tags/parley-0.53/root/static/magic/src/widget/templates/PopUpButton.css
   tags/parley-0.53/root/static/magic/src/widget/templates/Wizard.html
   tags/parley-0.53/root/static/magic/src/widget/templates/images/Tree/Tree.css
   tags/parley-0.53/root/static/magic/src/widget/templates/images/decrementMonth.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveBL.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveBR.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveTL.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveTR.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/incrementMonth.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-bg-vert.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-bg.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-button-horz.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-button-vert.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-button.png
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaActive-c.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaActive-l.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaActive-r.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaButton-c.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaButton-l.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaButton-r.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaDisabled-c.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaDisabled-l.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaDisabled-r.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaPressed-c.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaPressed-l.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaPressed-r.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/submenu_off.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/images/submenu_on.gif
   tags/parley-0.53/root/static/magic/src/widget/templates/richtextframe.html
   tags/parley-0.53/root/static/magic/src/widget/validate.js
   tags/parley-0.53/root/static/magic/src/widget/vml/Chart.js
   tags/parley-0.53/root/static/magic/src/xml/Parse.js
   tags/parley-0.53/root/static/magic/src/xml/__package__.js
   tags/parley-0.53/script/parley_fastcgi.pl
   tags/parley-0.53/script/parley_server.pl
   tags/parley-0.53/script/time_string_sample.pl
Log:



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8203
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8204
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: tags/parley-0.53/Makefile.PL
===================================================================
--- tags/parley-0.53/Makefile.PL	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/Makefile.PL	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,7 +1,14 @@
+#!/usr/bin/env perl
+# vim: ts=8 sts=4 et sw=4 sr sta
+use strict;
+use warnings;
 use inc::Module::Install;
 
-name 'Parley';
-all_from 'lib/Parley.pm';
+name            ('Parley');
+author          ('Chisel Wright<chiselwright at users.berlios.de>');
+abstract        ('Message board / forum application');
+license         ('perl');
+version         ('1.0.2');
 
 requires 'Catalyst' => '5.7001';
 requires 'Catalyst::Action::RenderView';
@@ -39,5 +46,5 @@
 catalyst;
 
 install_script glob('script/*.pl');
-auto_install;
+#auto_install;
 WriteAll;

Modified: tags/parley-0.53/db/parley.psql
===================================================================
--- tags/parley-0.53/db/parley.psql	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/db/parley.psql	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +1,4 @@
--- Phorum schema
+-- Parley schema
 
 -- to get your user and database:
 --  createuser -A -d parley
@@ -12,7 +12,7 @@
 
 -- we have authentication
 CREATE TABLE authentication (
-    authentication_id       SERIAL          not null        primary key,
+    id                      SERIAL          not null        primary key,
     username                text            not null,
     password                text            not null,
     authenticated           boolean         NOT NULL        default False,
@@ -23,7 +23,7 @@
 
 -- a table of acceptable TZ strings
 CREATE TABLE preference_time_string (
-    preference_time_string_id       SERIAL      primary key,
+    id                              SERIAL      primary key,
     time_string                     text        not null,
     sample                          text        not null,
     comment                         text
@@ -31,7 +31,7 @@
 -- some TZ strings
 INSERT INTO preference_time_string (time_string, sample) VALUES ('%A %d %B %Y at %R', 'Thursday 13 July 2006 at 18:15');
 INSERT INTO preference_time_string (time_string, sample) VALUES ('%F %T', '2006-07-13 18:15:00');
-INSERT INTO preference_time_string (time_string, sample, comment) VALUES ('%c','Thu 13 Jul 2006 18:15:00 BST','locale\'s date and time'); 
+INSERT INTO preference_time_string (time_string, sample, comment) VALUES ('%c','Thu 13 Jul 2006 18:15:00 BST','locale''s date and time'); 
 INSERT INTO preference_time_string (time_string, sample) VALUES ('%A at %R', 'Thursday at 18:15');
 INSERT INTO preference_time_string (time_string, sample) VALUES ('%a, %d %b; %R', 'Thu, 13 Jul; 18:15');
 INSERT INTO preference_time_string (time_string, sample) VALUES ('%a, %d %b; %R', 'Thu, 13 Jul; 18:15');
@@ -40,7 +40,7 @@
 
 
 CREATE TABLE preference (
-    preference_id   SERIAL      primary key,
+    id             SERIAL      primary key,
 
     timezone        text        not null
             default 'UTC',
@@ -52,41 +52,44 @@
 );
 
 CREATE TABLE person (
-    person_id       SERIAL      primary key,
+    id                  SERIAL      primary key,
     
-    first_name      text        not null,
-    last_name       text        not null,
-    email           text        not null,
+    first_name          text        not null,
+    last_name           text        not null,
+    email               text        not null,
     
-    forum_name      text        not null,
+    forum_name          text        not null,
 
-    preference      integer
-                    references preference,
+    preference_id       integer
+                        references preference(id),
 
-    authentication  integer
-                    references authentication,
+    authentication_id   integer
+                        references authentication(id),
 
+    suspended           boolean     not null
+                        default False,
+
     UNIQUE(forum_name),
     UNIQUE(email)
 );
 
 CREATE TABLE registration_authentication (
-    registration_authentication_id  text  primary key,
-    recipient       integer     not null
-                    references person,
+    id              text  primary key,
+    recipient_id    integer     not null
+                    references person(id),
     expires         date
 );
 
 -- new table used during forgotten password process
 CREATE TABLE password_reset (
-    password_reset_id       text        primary key,
-    recipient               integer     not null
-                            references person,
+    id                      text        primary key,
+    recipient_id            integer     not null
+                            references person(id),
     expires                 timestamp
 );
 
 CREATE TABLE forum (
-    forum_id        SERIAL      primary key,
+    id              SERIAL      primary key,
     name            text        not null,
     description     text,
 
@@ -98,16 +101,16 @@
 );
 
 CREATE TABLE thread (
-    thread_id       SERIAL      primary key,
-    forum           integer     not null
-                    references forum,
+    id              SERIAL      primary key,
+    forum_id        integer     not null
+                    references forum(id),
 
     subject         text        not null,
     
     created         timestamp with time zone
                     default CURRENT_TIMESTAMP,
-    creator         integer     not null
-                    references person,
+    creator_id      integer     not null
+                    references person(id),
     post_count      integer     not null    default 0,
     view_count      integer     not null    default 0,
 
@@ -118,9 +121,9 @@
 );
 
 CREATE TABLE post (
-    post_id         SERIAL      primary key,
-    thread          integer     not null
-                    references thread,
+    id              SERIAL      primary key,
+    thread_id       integer     not null
+                    references thread(id),
 
     subject         text,
     message         text        not null,
@@ -135,28 +138,28 @@
 );
 
 -- add ReplyTo information for post
-ALTER TABLE post ADD COLUMN reply_to
-    integer references post
+ALTER TABLE post ADD COLUMN reply_to_id
+    integer references post(id)
 ;
 -- deal with quoted replies
 ALTER TABLE post
-ADD COLUMN quoted_post
-integer REFERENCES post;
+ADD COLUMN quoted_post_id
+integer REFERENCES post(id);
 
 ALTER TABLE post
 ADD COLUMN quoted_text text;
 
 -- add LastPost information
-ALTER TABLE thread ADD COLUMN last_post
-    integer references post
+ALTER TABLE thread ADD COLUMN last_post_id
+    integer references post(id)
 ;
-ALTER TABLE forum ADD COLUMN last_post
-    integer references post
+ALTER TABLE forum ADD COLUMN last_post_id
+    integer references post(id)
 ;
 
 -- person posting information
-ALTER TABLE person ADD COLUMN last_post
-    integer references post
+ALTER TABLE person ADD COLUMN last_post_id
+    integer references post(id)
 ;
 ALTER TABLE person ADD COLUMN post_count
     integer NOT NULL default 0
@@ -171,9 +174,9 @@
 
 -- when a user last viewed a thread
 CREATE TABLE thread_view (
-    thread_view_id      SERIAL      not null        primary key,
-    person              integer     not null        references person,
-    thread              integer     not null        references thread,
+    id                  SERIAL      not null        primary key,
+    person_id           integer     not null        references person(id),
+    thread_id           integer     not null        references thread(id),
     timestamp           timestamp with time zone    not null
                         default CURRENT_TIMESTAMP,
 
@@ -181,7 +184,7 @@
     last_notified       timestamp with time zone
                         default NULL,
 
-    unique(person, thread)
+    unique(person_id, thread_id)
 );
 
 -- overall it's better to queue outgoing emails, and have a separate process
@@ -223,26 +226,82 @@
 
 -- #0 authentication
 INSERT INTO authentication
-(authentication_id, username, password, authenticated)
+(id, username, password, authenticated)
 VALUES
 (0, 'topdog', md5('k1tt3n'), true);
 
 -- #0 preference
 INSERT INTO preference
-(preference_id, timezone)
+(id, timezone)
 VALUES
 (0, 'UTC');
 
 -- #0 person info
 INSERT INTO person
-(person_id,first_name, last_name, email, forum_name, authentication, preference)
+(id,first_name, last_name, email, forum_name, authentication_id, preference_id)
 VALUES
 (0, 'Top','Dog','topdog at herlpacker.co.uk','TopDog', 0, 0);
 
-INSERT INTO forum (forum_id, name, description) VALUES (0, 'Off-Topic', 'General off-topic discussion');
+
+-- #1 authentication
+INSERT INTO authentication
+(id, username, password, authenticated)
+VALUES
+(1, 'norm', md5('k1tt3n'), true);
+-- #1 preference
+INSERT INTO preference
+(id, timezone)
+VALUES
+(1, 'UTC');
+-- #1 person info
+INSERT INTO person
+(id,first_name, last_name, email, forum_name, authentication_id, preference_id)
+VALUES
+(1, 'Norman','Normal','norman.normal at herlpacker.co.uk','Norman', 1, 1);
+-- fix PK sequences
+SELECT setval('authentication_id_seq',  1);
+SELECT setval('preference_id_seq',      1);
+SELECT setval('person_id_seq',          1);
+
+INSERT INTO forum (id, name, description) VALUES (0, 'Off-Topic', 'General off-topic discussion');
 INSERT INTO forum (name, description) VALUES ('Suggestions', 'Things you think should be added');
 INSERT INTO forum (name, description) VALUES ('Bugs', 'If you find anything broken, report it here');
 
+-- some roles
+INSERT INTO role (idx, name, description) VALUES (
+    0,
+    'site_moderator',
+    'Site Moderator'
+);
+INSERT INTO role (idx, name, description) VALUES (
+    50,
+    'suspend_account',
+    'Suspend Account'
+);
+INSERT INTO role (idx, name, description) VALUES (
+    100,
+    'ip_ban_posting',
+    'Restrict Posting by IP'
+);
+INSERT INTO role (idx, name, description) VALUES (
+    100,
+    'ip_ban_signup',
+    'Restrict Sign-Up by IP'
+);
+INSERT INTO role (idx, name, description) VALUES (
+    100,
+    'ip_ban_login',
+    'Restrict Login by IP'
+);
+
+-- make topdog a site_moderator
+INSERT INTO user_roles
+    (authentication_id, role_id)
+VALUES (
+    0,
+    (SELECT id FROM role WHERE name='site_moderator')
+);
+
 -- commit our schema
 COMMIT;
 

Modified: tags/parley-0.53/db/patch_0.09_to_0.10.psql
===================================================================
--- tags/parley-0.53/db/patch_0.09_to_0.10.psql	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/db/patch_0.09_to_0.10.psql	2008-10-08 11:42:12 UTC (rev 952)
@@ -32,11 +32,7 @@
                         default CURRENT_TIMESTAMP,
 
     recipient           integer     not null        references person,
-    cc                  integer                     references person,
-    bcc                 integer                     references person,
 
-    sender              text        not null,
-
     subject             text        not null,
     text_content        text        not null,
     html_content        text,

Modified: tags/parley-0.53/lib/Parley/Controller/Post.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Controller/Post.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Controller/Post.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -2,6 +2,8 @@
 
 use strict;
 use warnings;
+
+use Parley::Version;  our $VERSION = $Parley::VERSION;
 use base 'Catalyst::Controller';
 use DateTime;
 
@@ -93,7 +95,7 @@
 
     # if we don't have a post param, then return with an error
     unless (defined $c->_current_post) {
-        $c->stash->{error}{message} = q{Incomplete URL};
+        $c->stash->{error}{message} = $c->localize(q{Incomplete URL});
         return;
     }
 
@@ -122,7 +124,25 @@
     return;
 }
 
+sub preview : Local {
+    my ($self, $c) = @_;
+    my $tt_forum = Template::Plugin::ForumCode->new();
+    my $msg_source = $c->request->param('msg_source');
 
+    my $json = to_json(
+        {
+            'formatted' =>
+                $tt_forum->forumcode(
+                    $msg_source
+                )
+        }
+    );
+
+    $c->response->body( $json );
+    return;
+}
+
+
 1;
 __END__
 
@@ -144,7 +164,7 @@
 
 =head1 AUTHOR
 
-Chisel Wright C<< <chisel at herlpacker.co.uk> >>
+Chisel Wright C<< <chiselwright at users.berlios.de> >>
 
 =head1 LICENSE
 

Modified: tags/parley-0.53/lib/Parley/Controller/Root.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Controller/Root.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Controller/Root.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,15 +1,39 @@
 package Parley::Controller::Root;
-
+# vim: ts=8 sts=4 et sw=4 sr sta
 use strict;
 use warnings;
+
+use Parley::Version;  our $VERSION = $Parley::VERSION;
 use base 'Catalyst::Controller';
 
+use DateTime;
+use List::MoreUtils qw(uniq);
+
+use Parley::App::Terms qw( :terms );
+use Parley::App::Error qw( :methods );
+
 #
 # Sets the actions in this controller to be registered with no prefix
 # so they function identically to actions created in MyApp.pm
 #
 __PACKAGE__->config->{namespace} = '';
 
+sub begin :Private {
+    my ($self, $c) = @_;
+
+    # deal with access banned by IP
+    my $ip = $c->request->address;
+    my $access_banned =
+        $c->model('ParleyDB::IpBan')->is_access_banned($ip);
+    if ($access_banned) {
+        $c->stash->{template} = 'user/access_ip_banned';
+        return;
+    }
+
+    return 1;
+}
+
+
 # pre-populate values in the stash if we're given "appropriate" information:
 # - _authed_user
 # - _current_post
@@ -34,23 +58,50 @@
     if ( $c->user and not defined $c->_authed_user ) {
         $c->log->info('Fetching user information for ' . $c->user->id);
 
-        # get the person info for the username
-        my $row = $c->model('ParleyDB')->resultset('Person')->find(
-            {
-                'authentication.username'   => $c->user->username(),
-            },
-            {
-                join => 'authentication',
-            },
+    ##################################################
+    # do we have a request for a chosen language?
+    ##################################################
+    if (defined $c->request->param('lang')) {
+        $c->response->cookies->{ $cookie_name } = {
+            value       => $c->request->param('lang'),
+            expires     => '+14d',
+        };
+        # redirect back to the page they were on
+        $c->response->redirect(
+            $c->request->referer()
         );
-        $c->_authed_user( $row );
+        return;
+    }
 
-        #####################################################################
-        # cater for database upgrades, and make sure the user has preferences
-        #####################################################################
-        #Parley::App::Helper->user_preference_check($c);
+    # preserve cookies
+    if ($c->request->cookie($cookie_name)) {
+        $c->response->cookies->{ $cookie_name } = {
+            value       => $c->request->cookie($cookie_name)->value,
+            expires     => '+14d',
+        };
+
+        # push cookie saved languages onto list of i18n languages the user accepts
+        my (@languages);
+        # fetch cookie language prefs (if any)
+        push @languages,
+            split(
+                /\s+/,
+                $c->request->cookie($cookie_name)->value
+            )
+        ;
+        # get current list of accepted languages
+        push @languages, @{$c->languages};
+        # make the list have unique entries
+        @languages = uniq @languages;
+        # set new list of accepted languages
+        $c->languages(
+            \@languages
+        );
     }
 
+    # get a list of (all/available) forums
+    $c->stash->{available_forums} =
+        $c->model('ParleyDB::Forum')->available_list();
 
     ##################################################
     # do we have a post id in the URL?
@@ -58,7 +109,9 @@
     if (defined $c->request->param('post')) {
         # make sure the paramter looks sane
         if (not $c->request->param('post') =~ m{\A\d+\z}) {
-            $c->stash->{error}{message} = 'non-integer post id passed: ['
+            $c->stash->{error}{message} =
+                  $c->localize('non-integer post id passed')
+                . ': ['
                 . $c->request->param('post')
                 . ']';
             return;
@@ -66,10 +119,8 @@
 
         # get the matching post
         $c->_current_post(
-            $c->model('ParleyDB')->resultset('Post')->find(
-                {
-                    post_id  => $c->request->param('post')
-                }
+            $c->model('ParleyDB::Post')->record_from_id(
+                $c->request->param('post')
             )
         );
 
@@ -89,7 +140,9 @@
     elsif (defined $c->request->param('thread')) {
         # make sure the paramter looks sane
         if (not $c->request->param('thread') =~ m{\A\d+\z}) {
-            $c->stash->{error}{message} = 'non-integer thread id passed: ['
+            $c->stash->{error}{message} =
+                  $c->localize('non-integer thread id passed')
+                . ': ['
                 . $c->request->param('thread')
                 . ']';
             return;
@@ -97,10 +150,8 @@
 
         # get the matching thread
         $c->_current_thread(
-            $c->model('ParleyDB')->resultset('Thread')->find(
-                {
-                    thread_id  => $c->request->param('thread'),
-                }
+            $c->model('ParleyDB::Thread')->record_from_id(
+                $c->request->param('thread')
             )
         );
 
@@ -115,7 +166,9 @@
     elsif (defined $c->request->param('forum')) {
         # make sure the paramter looks sane
         if (not $c->request->param('forum') =~ m{\A\d+\z}) {
-            $c->stash->{error}{message} = 'non-integer forum id passed: ['
+            $c->stash->{error}{message} =
+                  $c->localize('non-integer forum id passed')
+                . ': ['
                 . $c->request->param('forum')
                 . ']';
             return;
@@ -123,10 +176,8 @@
 
         # get the matching forum
         $c->_current_forum(
-            $c->model('ParleyDB')->resultset('Forum')->find(
-                {
-                    forum_id  => $c->request->param('forum'),
-                }
+            $c->model('ParleyDB::Forum')->record_from_id(
+                $c->request->param('forum')
             )
         );
     }
@@ -178,9 +229,13 @@
     my ( $self, $c ) = @_;
 
     $c->response->status(404);
-    $c->response->body( '404 Not Found' );
+    $c->response->body( $c->localize('404 Not Found') );
 }
 
+sub access_denied :Local {
+    my ($self, $c) = @_;
+    parley_die($c,$c->localize('Unauthorized!'));
+}
 
 # deal with the end of the phase
 sub render : ActionClass('RenderView') {
@@ -191,6 +246,11 @@
         $c->stash->{template} = 'error/simple';
         $c->log->error( $c->stash->{error}{message} );
     }
+
+    if (has_died($c)) {
+        $c->stash->{template} = 'error/simple';
+        $c->log->error( @{ $c->stash->{view}{error}{messages} } );
+    }
 }
 
 sub end : Private {
@@ -198,7 +258,13 @@
     $c->forward('render');
 
     # fill in any forms
-    $c->fillform( );
+    $c->fillform(
+        {
+            # combine two hashrefs so we only make one method call
+            %{ $c->request->parameters || {} },
+            %{ $c->stash->{formdata}   || {} },
+        }
+    );
     $c->fillform( $c->stash->{formdata} );
 }
 
@@ -244,7 +310,7 @@
 
 =head1 AUTHOR
 
-Chisel Wright C<< <chisel at herlpacker.co.uk> >>
+Chisel Wright C<< <chiselwright at users.berlios.de> >>
 
 =head1 LICENSE
 

Modified: tags/parley-0.53/lib/Parley/Controller/Thread.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Controller/Thread.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Controller/Thread.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -2,6 +2,8 @@
 
 use strict;
 use warnings;
+
+use Parley::Version;  our $VERSION = $Parley::VERSION;
 use base 'Catalyst::Controller';
 use Data::SpreadPagination;
 
@@ -39,11 +41,20 @@
     my ($self, $c) = @_;
 
     # make sure we're logged in
-    $c->login_if_required(q{You must be logged in before you can add a new topic.});
+    $c->login_if_required($c->localize(q{LOGIN NEW TOPIC}));
 
     # make sure we're authenticated
     # XXX
 
+    # deal with posting banned by IP
+    my $ip = $c->request->address;
+    my $posting_banned =
+        $c->model('ParleyDB::IpBan')->is_posting_banned($ip);
+    if ($posting_banned) {
+        $c->stash->{template} = 'user/posting_ip_banned';
+        return;
+    }
+
     # if we have a form POST ...
     if (defined $c->request->method() and $c->request->method() eq 'POST') {
         $self->_add_new_thread($c);
@@ -59,7 +70,7 @@
     my ($self, $c) = @_;
 
     # make sure we're logged in
-    $c->login_if_required(q{You must be logged in before you can use the thread continuation function});
+    $c->login_if_required($c->localize(q{LOGIN THREAD CONTINUE}));
 
     # get the most recent post the user has seen
     my $last_viewed_post = $c->model('ParleyDB')->resultset('Thread')->last_post_viewed_in_thread(
@@ -146,7 +157,7 @@
     my ($self, $c) = @_;
 
     # make sure we're logged in
-    $c->login_if_required(q{You must be logged in before you can add a reply.});
+    $c->login_if_required($c->localize(q{LOGIN ADD REPLY}));
 
     # make sure we're authenticated
     # XXX
@@ -173,13 +184,11 @@
             and $c->request->method() eq 'POST'
             and defined $c->request->param('post_reply')
     ) {
-        $c->log->debug('calling: _add_new_reply($c)');
         $self->_add_new_reply($c);
     }
     # other wise we continue merrily on our way, and simply display the
     # thread/reply page
     else {
-        $c->log->debug('allowing fall-through to view in reply()');
         # thread/reply template shown automagically
     }
 }
@@ -200,12 +209,21 @@
     ##################################################
     $c->stash->{post_list} = $c->model('ParleyDB')->resultset('Post')->search(
         {
-            thread => $c->_current_thread->id(),
+            'me.thread_id' => $c->_current_thread->id(),
         },
         {
-            order_by    => 'created ASC',
+            order_by    => [\'me.created ASC'],
             rows        => $c->config->{posts_per_page},
             page        => $c->stash->{current_page},
+
+            prefetch => [
+                { thread => {'forum'=>'last_post'} },
+                { creator => 'authentication' },
+                #{ reply_to => 'creator' },
+                #{ quoted_post => 'creator' },
+                'reply_to',
+                'quoted_post',
+            ],
         }
     );
 
@@ -220,8 +238,6 @@
     # some updates for logged in users
     ##################################################
     if ($c->_authed_user) {
-        $c->log->debug('thread view by authed user');
-
         # update thread_view for user
         $self->_update_thread_view($c);
 
@@ -237,7 +253,8 @@
         $self->_thread_watch_count($c);
 
         # setup the pager
-        $self->_thread_view_pager($c);
+        #$self->_thread_view_pager($c);
+        $self->_prepare_pager($c, $c->stash->{post_list});
     }
 
     1; # return 'true'
@@ -254,20 +271,26 @@
     }
 
     # need to be logged in to watch threads
-    $c->login_if_required($c, q{You must be logged in before you can watch a topic.});
+    $c->login_if_required($c->localize(q{LOGIN WATCH TOPIC}));
 
     # get the ThreadView so we can update it
     my $thread_view = $c->model('ParleyDB')->resultset('ThreadView')->find(
         {
-            person  => $c->_authed_user()->id(),
-            thread  => $c->_current_thread()->id(),
+            person_id  => $c->_authed_user()->id(),
+            thread_id  => $c->_current_thread()->id(),
+        },
+        {
+            prefetch => [
+                'person',
+                { 'thread' => [qw/ forum creator last_post/] },
+            ],
         }
     );
 
     # if we couldn't find a thread view, then something odd is happening -
     # logged in users should always have a thread_view entry
     if (not defined $thread_view) {
-        $c->stash->{error}{message} = q{Failed to watch requested thread};
+        $c->stash->{error}{message} = $c->localize(q{THREAD WATCH FAILED});
         $c->log->error(q{User doesn't have a thread_view entry});
         return;
     }
@@ -307,6 +330,74 @@
     }
 }
 
+sub watches : Local {
+    my ($self, $c) = @_;
+
+    # make sure we're logged in
+    $c->login_if_required($c->localize(q{LOGIN VIEW WATCHES}));
+
+    # watched threads
+    my $watches = $c->model('ParleyDB')->resultset('ThreadView')->search(
+        {
+            person_id   => $c->_authed_user()->id(),
+            watched     => 1,
+        },
+        {
+            order_by    => [\'last_post.created DESC'],
+            join        => {
+                'thread' => 'last_post',
+            },
+
+            prefetch => [
+                { person   => 'authentication' },
+                { 'thread' => [
+                    'forum',
+                    #'creator',
+                    { creator   => 'authentication' },
+                    { 'last_post' => 'creator' },
+                  ]
+                },
+            ],
+        }
+    );
+    $c->stash->{thread_watches} = $watches;
+
+    # if we've got a list of threads to stop watching ...
+    if (my @thread_ids = $c->request->param('stop_watching')) {
+        foreach my $thread_id ( @thread_ids ) {
+            # get the ThreadView so we can update it
+            my $thread_view = $c->model('ParleyDB')->resultset('ThreadView')->find(
+                {
+                    person_id  => $c->_authed_user()->id(),
+                    thread_id  => $thread_id,
+                },
+                {
+                    prefetch => [
+                        'person',
+                        { 'thread' => [qw/ forum creator last_post/] },
+                    ],
+                }
+            );
+
+            # if we couldn't find a thread view, then something odd is happening -
+            # logged in users should always have a thread_view entry
+            if (not defined $thread_view) {
+                $c->stash->{error}{message} = $c->localize(q{THREAD WATCH FAILED});
+                $c->log->error(q{User doesn't have a thread_view entry});
+                return;
+            }
+
+            # we have a thread_view entry for the user, so update it
+
+            # update the watched status
+            $thread_view->watched( 0 );
+            $thread_view->update();
+        }
+    }
+
+    return;
+}
+
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 # Controller (Private/Helper) Methods
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -322,16 +413,18 @@
 
     # deal with missing/invalid fields
     if ($c->form->has_missing()) {
-        $c->stash->{view}{error}{message} = q{You must fill in all the required fields};
+        $c->stash->{view}{error}{message} = $c->localize(q{DFV FILL REQUIRED});
         foreach my $f ( $c->form->missing ) {
             push @{ $c->stash->{view}{error}{messages} }, $f;
         }
+        return;
     }
     elsif ($c->form->has_invalid()) {
-        $c->stash->{view}{error}{message} = q{One or more fields are invalid};
+        $c->stash->{view}{error}{message} = $c->localize(q{DFV FIELDS INVALID});
         foreach my $f ( $c->form->invalid ) {
             push @{ $c->stash->{view}{error}{messages} }, $f;
         }
+        return;
     }
 
     # otherwise, the form data is ok ...
@@ -377,13 +470,13 @@
 
     # deal with missing/invalid fields
     if ($c->form->has_missing()) {
-        $c->stash->{view}{error}{message} = q{You must fill in all the required fields};
+        $c->stash->{view}{error}{message} = $c->localize(q{DFV FILL REQUIRED});
         foreach my $f ( $c->form->missing ) {
             push @{ $c->stash->{view}{error}{messages} }, $f;
         }
     }
     elsif ($c->form->has_invalid()) {
-        $c->stash->{view}{error}{message} = q{One or more fields are invalid};
+        $c->stash->{view}{error}{message} = $c->localize(q{DFV FIELDS INVALID});
         foreach my $f ( $c->form->invalid ) {
             push @{ $c->stash->{view}{error}{messages} }, $f;
         }
@@ -406,16 +499,16 @@
             $c->log->error( $@ );
             return;
         }
+        # set the current thread
+        $c->_current_thread( $new_thread );
+
+        # view the "next post" in the new thread
+        $c->detach('next_post');
     }
 
     # getting here means we validated the form, and added required data for the
     # new thread
 
-    # set the current thread
-    $c->_current_thread( $new_thread );
-
-    # view the "next post" in the new thread
-    $c->detach('next_post');
 }
 
 sub _get_thread_reply_post {
@@ -430,7 +523,7 @@
         # get the specific post we're responding to
         $posts = $c->model('ParleyDB')->resultset('Post')->search(
             {
-                post_id     => $c->_current_post()->id(),
+                'me.id'     => $c->_current_post()->id(),
             },
             {
                 rows        => 1,
@@ -441,22 +534,22 @@
         # get the first post in the thread
         $posts = $c->model('ParleyDB')->resultset('Post')->search(
             {
-                thread      => $c->_current_thread()->id(),
+                'thread_id' => $c->_current_thread()->id(),
             },
             {
-                order_by    => 'created ASC',
+                order_by    => [\'created ASC'],
                 rows        => 1,
             }
         );
     }
     else {
-        $c->stash->{error}{message} = q{No information for thread or post to reply to};
+        $c->stash->{error}{message} = $c->localize(q{THREAD NO INFORMATION});
         return;
     }
 
     # if we don't have one post, something really odd happened
     if (1 != $posts->count()) {
-        $c->stash->{error}{message} = q{I don't know how you managed to reply to a thread with no posts};
+        $c->stash->{error}{message} = $c->localize(q{THREAD NO POSTS});
         return;
     }
 
@@ -512,7 +605,6 @@
     eval {
         $c->model('ParleyDB')->schema->txn_do(
             sub {
-                $c->log->info( q{Increasing view count} );
                 $c->_current_thread->view_count(
                     $c->_current_thread->view_count + 1
                 );
@@ -531,24 +623,23 @@
     }
 }
 
-sub _thread_view_pager {
-    my ($self, $c) = @_;
+sub _prepare_pager {
+    my ($self, $c, $list) = @_;
 
-    $c->stash->{page} = $c->stash->{post_list}->pager();
+    $c->stash->{page} = $list->pager();
 
-    # TODO - find a better way to do this if possible
-    # set up Data::SpreadPagination
     my $pagination = Data::SpreadPagination->new(
         {
             totalEntries        => $c->stash->{page}->total_entries(),
-            entriesPerPage      => $c->config->{posts_per_page},
-            currentPage         => $c->stash->{current_page},
+            entriesPerPage      => $c->stash->{page}->entries_per_page(),
+            currentPage         => $c->stash->{page}->current_page(),
             maxPages            => 4,
         }
     );
     $c->stash->{page_range_spread} = $pagination->pages_in_spread();
 }
 
+
 sub _thread_watch_count {
     my ($self, $c) = @_;
 
@@ -556,8 +647,8 @@
     $c->stash->{watcher_count} =
         $c->model('ParleyDB')->resultset('ThreadView')->count(
             {
-                thread  => $c->_current_thread()->id(),
-                watched => 1,
+                'thread_id' => $c->_current_thread()->id(),
+                watched     => 1,
             }
         )
     ;
@@ -577,8 +668,8 @@
                 my $forum = $thread->forum;
 
                 # set the last_post for both forum and thread
-                $forum-> last_post($new_post->post_id());
-                $thread->last_post($new_post->post_id());
+                $forum-> last_post_id($new_post->id());
+                $thread->last_post_id($new_post->id());
                 $forum ->update();
                 $thread->update();
             }
@@ -604,7 +695,7 @@
         # increase the post count for the user
         $person->post_count( $person->post_count() + 1 );
         # make a note of their last post
-        $person->last_post( $post->id() );
+        $person->last_post_id( $post->id() );
         # push the changes back tot the db
         $person->update();
     };
@@ -632,23 +723,27 @@
 
     # get the timestamp of the last post
     $last_post_timestamp = $last_post->created();
-    $c->log->debug( qq{\$last_post_timestamp = $last_post_timestamp} );
 
     # make a note of when the user last viewed this thread, if a record doesn't already exist
     my $thread_view =
         $c->model('ParleyDB')->resultset('ThreadView')->find_or_create(
             {
-                person      => $c->_authed_user()->id(),
-                thread      => $c->_current_thread()->id(),
+                person_id   => $c->_authed_user()->id(),
+                thread_id   => $c->_current_thread()->id(),
                 timestamp   => $last_post_timestamp,
             },
+            {
+                prefetch => [
+                    'person',
+                    { 'thread' => [qw/ forum creator last_post/] },
+                ],
+            }
         )
     ;
 
     # set the timestamp the time of the last post on the page (unless the
     # existing time is later)
     if ($thread_view->timestamp() < $last_post_timestamp) {
-        $c->log->debug('thread view time is less than last_post time');
         $thread_view->timestamp( $last_post_timestamp );
     }
 
@@ -686,11 +781,12 @@
     # create a new post in the current thread
     $new_post = $c->model('ParleyDB')->resultset('Post')->create(
         {
-            thread      => $c->_current_thread()->id(),
+            'thread_id' => $c->_current_thread()->id(),
             subject     => $c->form->valid->{thread_subject},
             message     => $c->form->valid->{thread_message},
-            creator     => $c->_authed_user->id(),
+            creator_id  => $c->_authed_user->id(),
             ip_addr     => $c->request->address(),
+            ip_addr     => $c->request->address(),
         }
     );
 
@@ -698,19 +794,19 @@
     # post (i.e. quoted reply, not just reply-to-thread)
     if (defined $c->_current_post()) {
         # mark what the new post is in reply-to
-        $new_post->reply_to( $c->_current_post()->id() );
+        $new_post->reply_to_id( $c->_current_post()->id() );
     }
 
     # do we have a quoted post? if we do we need to store the
     # (potentially ammended) quoted text, and the actual post being
     # quoted (so we can get author, date, etc)
     if (defined $c->request->param('have_quoted_post')) {
-        $new_post->quoted_post( $c->_current_post()->id() );
-        $new_post->quoted_text( $c->req->param('quote_message') );
+        $new_post->quoted_post_id( $c->_current_post()->id() );
+        $new_post->quoted_text   ( $c->req->param('quote_message') );
     }
 
     # the thread's last post is the one we just created
-    $c->_current_thread()->last_post( $new_post->id );
+    $c->_current_thread()->last_post_id( $new_post->id );
 
     # we've got one post in our new thread
     $self->_increase_post_count($c, $c->_current_thread());
@@ -756,31 +852,31 @@
 
 sub _txn_add_new_thread {
     my ($self, $c) = @_;
-    $c->log->info( q{_txn_add_new_thread} );
     
     my ($new_thread, $new_post);
 
     # create a new thread
     $new_thread = $c->model('ParleyDB')->resultset('Thread')->create(
         {
-            forum       => $c->_current_forum->id(),
+            forum_id    => $c->_current_forum->id(),
             subject     => $c->form->valid->{thread_subject},
-            creator     => $c->_authed_user->id(),
+            creator_id  => $c->_authed_user->id(),
         }
     );
 
     # create a new post in the new thread
     $new_post = $c->model('ParleyDB')->resultset('Post')->create(
         {
-            thread      => $new_thread->id(),
+            thread_id   => $new_thread->id(),
             subject     => $c->form->valid->{thread_subject},
             message     => $c->form->valid->{thread_message},
-            creator     => $c->_authed_user->id(),
+            creator_id  => $c->_authed_user->id(),
+            ip_addr     => $c->request->address(),
         }
     );
 
     # the thread's last post is the one we just created
-    $new_thread->last_post( $new_post->id );
+    $new_thread->last_post_id( $new_post->id );
 
     # we've got one post in our new thread
     $new_thread->post_count( 1 );

Modified: tags/parley-0.53/lib/Parley/Controller/User/SignUp.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Controller/User/SignUp.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Controller/User/SignUp.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -2,6 +2,8 @@
 
 use strict;
 use warnings;
+
+use Parley::Version;  our $VERSION = $Parley::VERSION;
 use base 'Catalyst::Controller';
 
 use List::MoreUtils qw{ uniq };
@@ -11,8 +13,7 @@
 use Time::Piece;
 use Time::Seconds;
 
-#use Data::FormValidator 4.02;
-#use Data::FormValidator::Constraints qw(:closures);
+use Parley::App::DFV qw( :constraints );
 
 # used by DFV
 sub _dfv_constraint_confirm_equal {
@@ -51,7 +52,7 @@
 my %dfv_profile_for = (
     'signup' => {
         required => [ qw(
-                username password confirm_password email confirm_email
+                new_username new_password confirm_password email confirm_email
                 first_name last_name forum_name
         ) ],
 
@@ -96,19 +97,35 @@
 # Controller Actions
 # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
+sub begin :Private {
+    my ($self, $c) = @_;
+
+    # deal with logins banned by IP
+    my $ip = $c->request->address;
+    my $signup_banned =
+        $c->model('ParleyDB::IpBan')->is_signup_banned($ip);
+    if ($signup_banned) {
+        $c->stash->{template} = 'user/signup_ip_banned';
+        return;
+    }
+
+    return 1;
+}
+
 sub authenticate : Path('/user/authenticate') {
     my ($self, $c, $auth_id) = @_;
 
     # we should have an auth-id in the url
     if (not defined $auth_id) {
-        $c->stash->{error}{message} = q{Incomplete authentication URL};
+        $c->stash->{error}{message}
+            = $c->localize(q{Incomplete authentication URL});
         return;
     }
 
     # fetch the info from the database
     my $regauth = $c->model('ParleyDB')->resultset('RegistrationAuthentication')->find(
         {
-            registration_authentication_id => $auth_id,
+            id => $auth_id,
         }
     );
 
@@ -128,7 +145,7 @@
     # get the person matching the ID
     $c->stash->{signup_user} = $c->model('ParleyDB')->resultset('Person')->find(
         {
-            person_id => $regauth->recipient->person_id(),
+            id => $regauth->recipient_id,
         }
     );
 
@@ -182,16 +199,19 @@
     $valid_results = $c->form->valid;
 
     # is the requested username already in use?
-    if ($self->_username_exists($c, $valid_results->{username})) {
-        push @messages, q{The username you have chosen is already in use. Please try a different one.};
+    if ($self->_username_exists($c, $valid_results->{new_username})) {
+        push @messages, $c->localize(q{USERNAME IN USE});
     }
     # is the requested email address already in use?
     if ($self->_email_exists($c, $valid_results->{email})) {
-        push @messages, q{The email address you have chosen is already in use.<br />Please try a different one, or use the <a href="user/password/forgotten">Forgotten Password</a> page.};
+        push @messages, $c->localize(
+            q{EMAIL IN USE ([_1])},
+            q{user/password/forgotten}
+        );
     }
     # is the requested forum name already in use?
     if ($self->_forumname_exists($c, $valid_results->{forum_name})) {
-        push @messages, q{The forum name you have chosen is already in use. Please try a different one.};
+        push @messages, $c->localize(q{FORUMNAME IN USE});
     }
 
     # if we DON'T have any messages, then there were no errors, so we can try
@@ -229,9 +249,9 @@
     # create an invitation
     $invitation = $c->model('ParleyDB')->resultset('RegistrationAuthentication')->create(
         {
-            'registration_authentication_id'	=> $random,
-            'recipient'				=> $person->person_id,
-            'expires'				=> Time::Piece->new(time + $LIFETIME)->datetime,
+            'id'	    => $random,
+            'recipient_id'  => $person->id,
+            'expires'       => Time::Piece->new(time + $LIFETIME)->datetime,
         }
     );
 
@@ -276,7 +296,10 @@
             person      => $person,
             headers => {
                 from    => $c->application_email_address(),
-                subject => qq{Activate your @{[$c->config->{name}]} registration},
+                subject => $c->localize(
+                    q{Activate Your [_1] Registration},
+                    $c->config->{name}
+                ),
             },
             template_data => {
                 regauth => $invitation,
@@ -298,13 +321,15 @@
 
     # deal with missing/invalid fields
     if ($c->form->has_missing()) {
-        $c->stash->{view}{error}{message} = q{You must fill in all the required fields};
+        $c->stash->{view}{error}{message}
+            = $c->localize(q{DFV FILL REQUIRED});
         foreach my $f ( $c->form->missing ) {
             push @{ $c->stash->{view}{error}{messages} }, $f;
         }
     }
     elsif ($c->form->has_invalid()) {
-        $c->stash->{view}{error}{message} = q{One or more fields are invalid};
+        $c->stash->{view}{error}{message}
+            = $c->localize(q{DFV FIELDS INVALID});
         foreach my $f ( $c->form->invalid ) {
             push @{ $c->stash->{view}{error}{messages} }, $f;
         }
@@ -346,19 +371,19 @@
     # add authentication record
     $new_auth = $c->model('ParleyDB')->resultset('Authentication')->create(
         {
-            username => $c->form->valid->{username},
-            password => md5_hex( $c->form->valid->{password} ),
+            username => $c->form->valid->{new_username},
+            password => md5_hex( $c->form->valid->{new_password} ),
         }
     );
 
     # add new person
     $new_person = $c->model('ParleyDB')->resultset('Person')->create(
         {
-            first_name      => $valid_results->{first_name},
-            last_name       => $valid_results->{last_name},
-            forum_name      => $valid_results->{forum_name},
-            email           => $valid_results->{email},
-            authentication  => $new_auth->id(),
+            first_name          => $valid_results->{first_name},
+            last_name           => $valid_results->{last_name},
+            forum_name          => $valid_results->{forum_name},
+            email               => $valid_results->{email},
+            authentication_id   => $new_auth->id(),
         }
     );
 

Modified: tags/parley-0.53/lib/Parley/Controller/User.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Controller/User.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Controller/User.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,26 +1,42 @@
 package Parley::Controller::User;
-
+# vim: ts=8 sts=4 et sw=4 sr sta
 use strict;
 use warnings;
+
+use Parley::Version;  our $VERSION = $Parley::VERSION;
 use base 'Catalyst::Controller';
 
+use JSON;
+
 # deal with user login requests on user/login
 sub login : Path('/user/login') {
     my ( $self, $c ) = @_;
 
     # default form message
-    $c->stash->{'message'} = 'Please enter your username and password';
+    $c->stash->{'message'} = $c->localize(q{PASSWORD ENTER DETAILS});
     # if we have a custom message to use ..
     $c->stash->{'login_message'} = delete( $c->session->{login_message} );
     # make sure we use the correct template - we sometimes detach() here
     $c->stash->{template} = 'user/login';
 
+
+    # deal with logins banned by IP
+    my $ip = $c->request->address;
+    my $login_banned =
+        $c->model('ParleyDB::IpBan')->is_login_banned($ip);
+    if ($login_banned) {
+        $c->stash->{template} = 'user/login_ip_banned';
+        return;
+    }
+
     # if we have a username, try to log the user in
     if ( $c->request->param('username') ) {
         # try to log the user in
-        my $login_status = $c->login(
-            $c->request->param('username'),
-            $c->request->param('password'),
+        my $login_status = $c->authenticate(
+            {
+                username => $c->request->param('username'),
+                password => $c->request->param('password'),
+            }
         );
 
         # if we have a user we're logged in
@@ -63,7 +79,7 @@
         # otherwise we failed to login, try again!
         else {
             $c->stash->{'message'}
-                = 'Unable to authenticate the login details supplied';
+                = $c->localize(q{AUTHENTICATION FAILED});
         }
     }
 }
@@ -71,6 +87,12 @@
 sub logout : Path('/user/logout') {
     my ($self, $c) = @_;
 
+#    # if no-one logged in, send them to the main page as a punishment
+#    if (not exists $c->session->{authed_user}) {
+#        $c->response->redirect( $c->uri_for($c->config()->{default_uri}) );
+#        return;
+#    }
+
     # session logout, and remove information we've stashed
     $c->logout;
     delete $c->session->{'authed_user'};
@@ -126,7 +148,7 @@
 
 =head1 AUTHOR
 
-Chisel Wright C<< <chisel at herlpacker.co.uk> >>
+Chisel Wright C<< <chiselwright at users.berlios.de> >>
 
 =head1 LICENSE
 

Modified: tags/parley-0.53/lib/Parley/Schema/EmailQueue.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Schema/EmailQueue.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Schema/EmailQueue.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -5,6 +5,8 @@
 use strict;
 use warnings;
 
+use Parley::Version;  our $VERSION = $Parley::VERSION;
+
 use base 'DBIx::Class';
 
 __PACKAGE__->load_components("PK::Auto", "Core");
@@ -27,49 +29,56 @@
   {
     data_type => "text",
     default_value => undef,
+    is_nullable => 1,
+    size => undef,
+  },
+  "subject" => {
+    data_type => "text",
+    default_value => undef,
     is_nullable => 0,
     size => undef,
   },
-  "html_content",
-  {
+  "html_content" => {
     data_type => "text",
     default_value => undef,
     is_nullable => 1,
     size => undef,
   },
-  "email_queue_id",
-  {
-    data_type => "integer",
-    default_value => "nextval('email_queue_email_queue_id_seq'::regclass)",
-    is_nullable => 0,
-    size => 4,
-  },
-  "attempted_delivery",
-  {
+  "attempted_delivery" => {
     data_type => "boolean",
     default_value => "false",
     is_nullable => 0,
     size => 1,
   },
-  "text_content",
-  {
+  "text_content" => {
     data_type => "text",
     default_value => undef,
     is_nullable => 0,
     size => undef,
   },
-  "queued",
-  {
+  "queued" => {
     data_type => "timestamp with time zone",
     default_value => "now()",
     is_nullable => 0,
     size => 8,
   },
 );
-__PACKAGE__->set_primary_key("email_queue_id");
-__PACKAGE__->belongs_to("recipient", "Person", { person_id => "recipient" });
+__PACKAGE__->set_primary_key("id");
+__PACKAGE__->belongs_to(
+    "recipient" =>  "Person",
+    { 'foreign.id' => 'self.recipient_id' }
+);
+__PACKAGE__->belongs_to(
+    "cc" => "Person",
+    { 'foreign.id' => 'self.cc_id' },
+    { join_type => 'left' },
+);
+__PACKAGE__->belongs_to(
+    "bcc" =>  "Person",
+    { 'foreign.id' => 'self.bcc_id' },
+    { join_type => 'left' },
+);
 __PACKAGE__->belongs_to("cc", "Person", { person_id => "recipient" });
 __PACKAGE__->belongs_to("bcc", "Person", { person_id => "recipient" });
 
 1;
-

Modified: tags/parley-0.53/lib/Parley/Schema/Post.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Schema/Post.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Schema/Post.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -6,60 +6,75 @@
 use warnings;
 use Data::Dump qw(pp);
 
+use Parley::Version;  our $VERSION = $Parley::VERSION;
+
+use DateTime;
 use DateTime::Format::Pg;
 use Text::Context::EitherSide;
 use Text::Search::SQL;
 
+use Parley::App::DateTime qw( :interval );
+
 use base 'DBIx::Class';
 
-__PACKAGE__->load_components("ResultSetManager", "PK::Auto", "Core");
+__PACKAGE__->load_components("PK::Auto", "Core");
 __PACKAGE__->table("post");
 __PACKAGE__->add_columns(
-  "creator",
-  { data_type => "integer", default_value => undef, is_nullable => 0, size => 4 },
-  "subject",
-  {
+  "id" => {
+    data_type => "integer",
+    #default_value => "nextval('post_post_id_seq'::regclass)",
+    is_nullable => 0,
+    size => 4,
+  },
+  "creator_id" => {
+    data_type => "integer",
+    default_value => undef,
+    is_nullable => 0,
+    size => 4
+  },
+  "subject" => {
     data_type => "text",
     default_value => undef,
     is_nullable => 1,
     size => undef,
   },
-  "quoted_post",
-  { data_type => "integer", default_value => undef, is_nullable => 1, size => 4 },
-  "message",
-  {
+  "quoted_post_id" => {
+    data_type => "integer",
+    default_value => undef,
+    is_nullable => 1,
+    size => 4
+  },
+  "message" => {
     data_type => "text",
     default_value => undef,
     is_nullable => 0,
     size => undef,
   },
-  "quoted_text",
-  {
+  "quoted_text" => {
     data_type => "text",
     default_value => undef,
     is_nullable => 1,
     size => undef,
   },
-  "created",
-  {
+  "created" => {
     data_type => "timestamp with time zone",
     default_value => "now()",
     is_nullable => 1,
     size => 8,
   },
-  "thread",
-  { data_type => "integer", default_value => undef, is_nullable => 0, size => 4 },
-  "reply_to",
-  { data_type => "integer", default_value => undef, is_nullable => 1, size => 4 },
-  "post_id",
-  {
+  "thread_id" => {
     data_type => "integer",
-    default_value => "nextval('post_post_id_seq'::regclass)",
+    default_value => undef,
     is_nullable => 0,
-    size => 4,
+    size => 4
   },
-  "edited",
-  {
+  "reply_to_id" => {
+    data_type => "integer",
+    default_value => undef,
+    is_nullable => 1,
+    size => 4
+  },
+  "edited" => {
     data_type => "timestamp with time zone",
     default_value => undef,
     is_nullable => 1,
@@ -73,24 +88,53 @@
     size => 8,
   },
 );
-__PACKAGE__->set_primary_key("post_id");
-__PACKAGE__->has_many("threads", "Thread", { "foreign.last_post" => "self.post_id" });
-__PACKAGE__->has_many("forums", "Forum", { "foreign.last_post" => "self.post_id" });
-__PACKAGE__->belongs_to("creator", "Person", { person_id => "creator" });
-__PACKAGE__->belongs_to("reply_to", "Post", { post_id => "reply_to" });
+
+__PACKAGE__->set_primary_key("id");
+__PACKAGE__->resultset_class('Parley::ResultSet::Post');
+
 __PACKAGE__->has_many(
-  "post_reply_toes",
-  "Post",
-  { "foreign.reply_to" => "self.post_id" },
+    "threads" => "Thread",
+    { "foreign.last_post_id" => "self.id" }
 );
-__PACKAGE__->belongs_to("thread", "Thread", { thread_id => "thread" });
-__PACKAGE__->belongs_to("quoted_post", "Post", { post_id => "quoted_post" });
 __PACKAGE__->has_many(
-  "post_quoted_posts",
-  "Post",
-  { "foreign.quoted_post" => "self.post_id" },
+    "forums" => "Forum",
+    { "foreign.last_post_id" => "self.id" }
 );
-__PACKAGE__->has_many("people", "Person", { "foreign.last_post" => "self.post_id" });
+__PACKAGE__->belongs_to(
+    "creator" => "Person",
+    { 'foreign.id' => "self.creator_id" },
+    { join_type => 'left' }
+);
+__PACKAGE__->belongs_to(
+    "reply_to" => "Post",
+    { 'foreign.id' => "self.reply_to_id" },
+    { join_type => 'left' },
+);
+__PACKAGE__->has_many(
+  "post_reply_toes" => "Post",
+  { "foreign.reply_to_id" => "self.id" },
+);
+__PACKAGE__->belongs_to(
+    "thread" => "Thread",
+    { 'foreign.id' => "self.thread_id" },
+);
+__PACKAGE__->belongs_to(
+    "quoted_post" => "Post",
+    { 'foreign.id' => "self.quoted_post_id" },
+    { join_type => 'left' },
+);
+__PACKAGE__->has_many(
+  "post_quoted_posts" => "Post",
+  { "foreign.quoted_post" => "self.id" },
+);
+__PACKAGE__->has_many(
+    "people" => "Person",
+    { "foreign.last_post" => "self.id" },
+);
+__PACKAGE__->belongs_to(
+    "admin_editor" => "Person",
+    { 'foreign.id' => "self.admin_editor_id" },
+);
 
 
 
@@ -106,8 +150,11 @@
 
 # we used to use ->slice() but it sopped working on page #2 (!!)
 # this may be slower [not benchmarked] but it works
-sub last_post_in_list : ResultSet {
-    my ($self, $post_list) = @_;
+# accessor to use in search results to return context matches
+sub match_context {
+    my $self = shift;
+    my $search_terms = shift;
+    my ($tss, $terms);
     my ($current_post);
 
     while (my $tmp = $post_list->next()) {
@@ -131,53 +178,26 @@
     # if for some reason there are no matches, just return the post we were passed
     $next_post = $self->search(
         {
-            created => { '>' => DateTime::Format::Pg->format_datetime($post->created()) },
-            thread  => $post->thread()->id(),
-        },
-        {
-            rows    => 1,
+            search_term     => $search_terms,
         }
     );
+    $tss->parse();
+    $terms = $tss->get_chunks();
+    warn pp($terms);
+    warn pp($self->message());
 
-    if (defined $next_post->first()) {
-        return $next_post->first();
-    }
-
-    return $post;
+    my $context = Text::Context::EitherSide->new( $self->message(), context => 3 );
+    return $context->as_string( @{ $terms } );
 }
 
+sub interval_ago {
+    my $self = shift;
+    my ($now, $duration, $longest_duration);
 
-sub page_containing_post : ResultSet {
-    my ($self, $post, $posts_per_page) = @_;
-
-    my $position_in_thread = $self->thread_position($post);
-
-    # work out what page the Nth post is on
-    my $page_number = int(($position_in_thread - 1) / $posts_per_page) + 1;
-
-    return $page_number;
-}
-
-
-sub thread_position : ResultSet {
-    my ($self, $post) = @_;
-
-    if (not defined $post) {
-        warn('$post id undefined in call to Parley::Model::ParleyDB::Post->thread_position()');
-        return;
-    }
-
-    # explicitly 'deflate' the creation time, as DBIx::Class (<=v0.06003) doesn't deflate on search()
-    my $position = $self->count(
-        {
-            thread  => $post->thread()->id(),
-            created => {
-                '<='   => DateTime::Format::Pg->format_datetime($post->created())
-            },
-        }
+    my $interval_string = interval_ago_string(
+        $self->created()
     );
-
-    return $position;
+    return $interval_string;
 }
 
 # accessor to use in search results to return context matches
@@ -207,4 +227,3 @@
 1;
 __END__
 vim: ts=8 sts=4 et sw=4 sr sta
-

Modified: tags/parley-0.53/lib/Parley/Schema/Preference.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Schema/Preference.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Schema/Preference.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -5,28 +5,28 @@
 use strict;
 use warnings;
 
+use Parley::Version;  our $VERSION = $Parley::VERSION;
+
 use base 'DBIx::Class';
 
 __PACKAGE__->load_components("PK::Auto", "Core");
 __PACKAGE__->table("preference");
 __PACKAGE__->add_columns(
-  "timezone",
-  {
-    data_type => "text",
-    default_value => "'UTC'::text",
+  "id" => {
+    data_type => "integer",
+    #default_value => "nextval('preference_preference_id_seq'::regclass)",
     is_nullable => 0,
-    size => undef,
+    size => 4,
   },
 
-  "preference_id",
-  {
-    data_type => "integer",
-    default_value => "nextval('preference_preference_id_seq'::regclass)",
+  "timezone" => {
+    data_type => "text",
+    default_value => "UTC",
     is_nullable => 0,
-    size => 4,
+    size => undef,
   },
 
-  'time_format' => {
+  'time_format_id' => {
     data_type => 'integer',
     size => 4,
   },
@@ -49,15 +49,18 @@
     size => 1,
   },
 );
-__PACKAGE__->set_primary_key("preference_id");
+__PACKAGE__->set_primary_key("id");
 __PACKAGE__->has_many(
   "people",
   "Person",
-  { "foreign.preference" => "self.preference_id" },
+  { "foreign.id" => "self.preference_id" },
 );
 
-__PACKAGE__->belongs_to("time_format", "PreferenceTimeString", { preference_time_string_id => "time_format" });
+__PACKAGE__->belongs_to(
+    "time_format" => "PreferenceTimeString",
+    { 'foreign.id' => 'self.time_format_id' },
+    { join_type => 'left' },
+);
 
 
 1;
-

Modified: tags/parley-0.53/lib/Parley/Schema/Thread.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Schema/Thread.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Schema/Thread.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -5,74 +5,104 @@
 use strict;
 use warnings;
 
+use Parley::Version;  our $VERSION = $Parley::VERSION;
+use DateTime::Format::Pg;
+
 use base 'DBIx::Class';
 
-__PACKAGE__->load_components('ResultSetManager', "PK::Auto", "Core");
+__PACKAGE__->load_components("PK::Auto", "Core");
 __PACKAGE__->table("thread");
 __PACKAGE__->add_columns(
-  "thread_id",
-  {
+  "id" => {
     data_type => "integer",
-    default_value => "nextval('thread_thread_id_seq'::regclass)",
+    #default_value => "nextval('thread_thread_id_seq'::regclass)",
     is_nullable => 0,
     size => 4,
   },
-  "locked",
-  {
+  "locked" => {
     data_type => "boolean",
     default_value => "false",
     is_nullable => 0,
     size => 1,
   },
-  "creator",
-  { data_type => "integer", default_value => undef, is_nullable => 0, size => 4 },
-  "subject",
-  {
+  "creator_id" => {
+    data_type => "integer",
+    default_value => undef,
+    is_nullable => 0,
+    size => 4
+  },
+  "subject" => {
     data_type => "text",
     default_value => undef,
     is_nullable => 0,
     size => undef,
   },
-  "active",
-  {
+  "active" => {
     data_type => "boolean",
     default_value => "true",
     is_nullable => 0,
     size => 1,
   },
-  "forum",
-  { data_type => "integer", default_value => undef, is_nullable => 0, size => 4 },
-  "created",
-  {
+  "forum_id", {
+    data_type => "integer",
+    default_value => undef,
+    is_nullable => 0,
+    size => 4
+  },
+  "created" => {
     data_type => "timestamp with time zone",
     default_value => "now()",
     is_nullable => 1,
     size => 8,
   },
-  "last_post",
-  { data_type => "integer", default_value => undef, is_nullable => 1, size => 4 },
-  "sticky",
-  {
+  "last_post_id" => {
+    data_type => "integer",
+    default_value => undef,
+    is_nullable => 1,
+    size => 4
+  },
+  "sticky" => {
     data_type => "boolean",
     default_value => "false",
     is_nullable => 0,
     size => 1,
   },
-  "post_count",
-  { data_type => "integer", default_value => 0, is_nullable => 0, size => 4 },
-  "view_count",
-  { data_type => "integer", default_value => 0, is_nullable => 0, size => 4 },
+  "post_count" => {
+    data_type => "integer",
+    default_value => 0,
+    is_nullable => 0,
+    size => 4
+  },
+  "view_count" => {
+    data_type => "integer",
+    default_value => 0,
+    is_nullable => 0,
+    size => 4
+  },
 );
-__PACKAGE__->set_primary_key("thread_id");
-__PACKAGE__->belongs_to("creator", "Person", { person_id => "creator" });
-__PACKAGE__->belongs_to("last_post", "Post", { post_id => "last_post" });
-__PACKAGE__->belongs_to("forum", "Forum", { forum_id => "forum" });
-__PACKAGE__->has_many("posts", "Post", { "foreign.thread" => "self.thread_id" });
+__PACKAGE__->set_primary_key("id");
+__PACKAGE__->resultset_class('Parley::ResultSet::Thread');
+
+__PACKAGE__->belongs_to(
+    "creator" => "Person",
+    { 'foreign.id' => 'self.creator_id' }
+);
+__PACKAGE__->belongs_to(
+    "last_post" => "Post",
+    { 'foreign.id' => 'self.last_post_id' },
+);
+__PACKAGE__->belongs_to(
+    "forum" =>  "Forum",
+    { 'foreign.id' => 'self.forum_id' }
+);
 __PACKAGE__->has_many(
-  "thread_views",
-  "ThreadView",
-  { "foreign.thread" => "self.thread_id" },
+    "posts" => "Post",
+    { "foreign.thread_id" => "self.id" },
 );
+__PACKAGE__->has_many(
+  "thread_views" => "ThreadView",
+  { "foreign.thread_id" => "self.id" },
+);
 
 __PACKAGE__->has_many(
     'forum_moderators',
@@ -90,89 +120,8 @@
     });
 }
 
-# This is slightly complicated; the way we find the last post a user has seen
-# in a thread is:
-#
-# - If there is a thread_view entry for person-thread then find the last post
-#    made on or before that time
-# - If there is no thread_view entry, then the user has never seen the thread
-#   before, in which case the last post viewed is considered to be the
-#   first post in the thread
-sub last_post_viewed_in_thread :ResultSet {
-    my ($self, $person, $thread) = @_;
-    my ($last_viewed, $last_post) = @_;
 
-    my $schema = $self->result_source()->schema();
-
-    # we need to be careful that we haven't deleted/hidden the post that
-    # matches the exact timestamp of last_viewed for a thread - this is why we
-    # use <= and not ==, since we can just return the latest undeleted post
-
-    # get the entry (if any) for person-thread from the thread_view table
-    $last_viewed = $schema->resultset('ThreadView')->find(
-        {
-            person  => $person->id(),
-            thread  => $thread->id(),
-        }
-    );
-
-    # if we don't have a $last_viewed, then return the thread's first post
-    if (not defined $last_viewed) {
-        warn "thread has never been viewed - returning first post in thread";
-
-        # get all the posts in the thread, oldest first
-        my $posts_in_thread = $schema->resultset('Post')->search(
-            {
-                thread  => $thread->id(),
-            },
-            {
-                rows        => 1,
-                order_by    => 'created ASC',
-            }
-        );
-
-        # set the first post
-        $last_post = $posts_in_thread->first();
-    }
-
-    # otherwise, find the most recent post made on or before the timestamp in
-    # $last_viewed
-    else {
-        warn q{looking for a post on or before } . $last_viewed->timestamp();
-
-        # get a list of posts created on or before our last-post time, newest
-        # first
-        my $list_of_posts = $schema->resultset('Post')->search(
-            {
-                created => {
-                    '<=',
-                    DateTime::Format::Pg->format_datetime(
-                        $last_viewed->timestamp()
-                    )
-                },
-                thread  => $thread->id(),
-            },
-            {
-                rows        => 1,
-                order_by    => 'created DESC',
-            }
-        );
-
-        # the most recent post is the first (and only) post in our list
-        $last_post = $list_of_posts->first();
-    }
-
-    # we should now have a Post object in $last_post
-    if (not defined $last_post) {
-        warn q{$last_post is undefined in last_post_viewed_in_thread()};
-        return;
-    }
-
-    # return the last post ..
-    return $last_post;
-}
-
-sub _last_post_viewed_in_thread :ResultSet {
+sub PROBABLY_DEAD_last_post_viewed_in_thread :ResultSet {
     my ($self, $person, $thread) = @_;
     my ($last_viewed, $last_post);
 
@@ -185,8 +134,8 @@
     # get the "last_viewed" value from thread_view
     $last_viewed = $schema->resultset('ThreadView')->search(
         {
-            person  => $person->id(),
-            thread  => $thread->id(),
+            person_id  => $person->id(),
+            thread_id  => $thread->id(),
         },
         {
             rows => 1,
@@ -200,11 +149,11 @@
 
         $last_post = $schema->resultset('Post')->search(
             {
-                thread  => $thread->id(),
+                thread_id  => $thread->id(),
             },
             {
                 rows        => 1,
-                order_by    => 'created ASC',
+                order_by    => [\'created ASC'],
             }
         );
 
@@ -225,11 +174,11 @@
                 '<=', 
                 DateTime::Format::Pg->format_datetime($last_viewed->timestamp())
             },
-            thread  => $thread->id(),
+            thread_id  => $thread->id(),
         },
         {
             rows        => 1,
-            order_by    => 'created DESC',
+            order_by    => [\'created DESC'],
         }
     );
 

Modified: tags/parley-0.53/lib/Parley/Schema/ThreadView.pm
===================================================================
--- tags/parley-0.53/lib/Parley/Schema/ThreadView.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley/Schema/ThreadView.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -5,12 +5,23 @@
 use strict;
 use warnings;
 
+use Parley::Version;  our $VERSION = $Parley::VERSION;
+
 use base 'DBIx::Class';
 use DateTime::Format::Pg;
 
-__PACKAGE__->load_components('ResultSetManager', "PK::Auto", "Core");
+use Parley::App::DateTime qw( :interval );
+
+__PACKAGE__->load_components("PK::Auto", "Core");
 __PACKAGE__->table("thread_view");
 __PACKAGE__->add_columns(
+  "id" => {
+    data_type => "integer",
+    #default_value => "nextval('thread_view_thread_view_id_seq'::regclass)",
+    is_nullable => 0,
+    size => 4,
+  },
+
   "watched" => {
     data_type => "boolean",
     default_value => "false",
@@ -18,13 +29,6 @@
     size => 1,
   },
 
-  "thread_view_id" => {
-    data_type => "integer",
-    default_value => "nextval('thread_view_thread_view_id_seq'::regclass)",
-    is_nullable => 0,
-    size => 4,
-  },
-
   "last_notified" => {
     data_type => "timestamp with time zone",
     default_value => undef,
@@ -32,7 +36,7 @@
     size => 8,
   },
 
-  "thread" => {
+  "thread_id" => {
     data_type => "integer",
     default_value => undef,
     is_nullable => 0,
@@ -44,17 +48,27 @@
     is_nullable => 0,
     size => 8,
   },
-  "person" => {
+  "person_id" => {
     data_type => "integer",
     default_value => undef,
     is_nullable => 0,
     size => 4
   },
 );
-__PACKAGE__->set_primary_key("thread_view_id");
-__PACKAGE__->add_unique_constraint("thread_view_person_key", ["person", "thread"]);
-__PACKAGE__->belongs_to("thread", "Thread", { thread_id => "thread" });
-__PACKAGE__->belongs_to("person", "Person", { person_id => "person" });
+__PACKAGE__->set_primary_key("id");
+__PACKAGE__->resultset_class('Parley::ResultSet::ThreadView');
+__PACKAGE__->add_unique_constraint(
+    'thread_view_person_key',
+    ['person_id', 'thread_id']
+);
+__PACKAGE__->belongs_to(
+    "thread" => "Thread",
+    { 'foreign.id' => 'self.thread_id' },
+);
+__PACKAGE__->belongs_to(
+    "person" => "Person",
+    { 'foreign.id' => 'self.person_id' }
+);
 
 
 
@@ -67,26 +81,15 @@
 }
 
 
-sub watching_thread : ResultSet {
-    my ($self, $thread, $person) = @_;
 
-    if (not defined $thread) {
-        warn 'undefined value passed as $thread in watching_thread()';
-        return;
-    }
-    if (not defined $person) {
-        warn 'undefined value passed as $person in watching_thread()';
-        return;
-    }
+sub interval_ago {
+    my $self = shift;
+    my ($now, $duration, $longest_duration);
 
-    my $thread_view = $self->find(
-        {
-            person  => $person->id(),
-            thread  => $thread->id(),
-        }
+    my $interval_string = interval_ago_string(
+        $self->timestamp()
     );
-
-    return $thread_view->watched();
+    return $interval_string;
 }
 
 sub notification_list : ResultSet {
@@ -140,4 +143,3 @@
 }
 
 1;
-

Modified: tags/parley-0.53/lib/Parley.pm
===================================================================
--- tags/parley-0.53/lib/Parley.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Parley.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,12 +1,12 @@
 package Parley;
-
+# vim: ts=8 sts=4 et sw=4 sr sta
 use strict;
 use warnings;
 
+use Parley::Version;  our $VERSION = $Parley::VERSION;
+
 use Catalyst::Runtime '5.70';
 use Catalyst qw/
-    -Debug
-    Dumper
     StackTrace
 
     ConfigLoader
@@ -22,20 +22,94 @@
     Session::State::Cookie
 
     Authentication
-    Authentication::Store::DBIC
-    Authentication::Credential::Password
+    Authorization::Roles
+    Authorization::ACL
+
+    I18N
 /;
 
 use Parley::App::Communication::Email qw( :email );
 
 our $VERSION = '0.53';
 
-__PACKAGE__->config( version => $VERSION );
 __PACKAGE__->setup;
 
 # only show certain log levels in output
 __PACKAGE__->log (Catalyst::Log->new( @{__PACKAGE__->config->{log_levels}} ));
 
+
+# ---- START: ACL RULES ----
+
+#
+# /site
+#
+##__PACKAGE__->deny_access_unless(
+##    '/site/ip_bans',
+##    [$_]
+##)
+##for qw/ip_ban_posting site_moderator/;
+__PACKAGE__->deny_access_unless(
+    '/site/fmodSaveHandler',
+    [qw/site_moderator/]
+);
+__PACKAGE__->deny_access_unless(
+    '/site/ip_bans',
+    sub {
+        my $c = shift;
+        $c->check_any_user_role(
+            qw/site_moderator ip_ban_posting ip_ban_signup ip_ban_login/
+        )
+    }
+);
+__PACKAGE__->deny_access_unless(
+    '/site/ip_info',
+    sub {
+        my $c = shift;
+        $c->check_any_user_role(
+            qw/site_moderator ip_ban_posting ip_ban_signup ip_ban_login/
+        )
+    }
+);
+__PACKAGE__->deny_access_unless(
+    '/site/roleSaveHandler',
+    [qw/site_moderator/]
+);
+__PACKAGE__->deny_access_unless(
+    '/site/saveBanHandler',
+    sub {
+        my $c = shift;
+        $c->check_any_user_role(
+            qw/site_moderator ip_ban_posting ip_ban_signup ip_ban_login/
+        )
+    }
+);
+__PACKAGE__->deny_access_unless(
+    '/site/services',
+    [qw/site_moderator/]
+);
+__PACKAGE__->deny_access_unless(
+    '/site/user',
+    [qw/site_moderator/]
+);
+__PACKAGE__->deny_access_unless(
+    '/site/users',
+    [qw/site_moderator/]
+);
+__PACKAGE__->deny_access_unless(
+    '/site/users_autocomplete',
+    [qw/site_moderator/]
+);
+
+#__PACKAGE__->deny_access_unless(
+#    '/site/users',
+#    [qw/site_moderator/]
+#);
+
+
+# ---- END:   ACL RULES ----
+
+
+
 # I'm sure there's a (better) way to do this by overriding set()/get() in Class::Accessor
 {
     sub set_get {
@@ -121,16 +195,93 @@
 
 =head1 NAME
 
-Parley - Catalyst based application
+Parley - Message board / forum application
 
 =head1 SYNOPSIS
 
-    script/parley_server.pl
+To run a B<test/development> server:
 
+  script/parley_server.pl
+
+To run under FastCGI:
+
+  cp config/parley /etc/apache2/sites-available
+  a2ensite parley
+  /etc/init.d/apache2 restart
+
+Also see: L<Catalyst::Manual::Cookbook/Deployment>
+
+Start the email engine:
+
+  script/parley_email_engine.pl
+
 =head1 DESCRIPTION
 
-Catalyst driven forum application
+Parley is a forum/message-board application. It's raison d'etre is to try
+to fill a void in the perl application space.
 
+=head1 FEATURES
+
+=over 4
+
+=item Multiple forums
+
+Have numerous forums to separate areas of discussion.
+
+=item Paging for long threads
+
+Save the scroll-wheel on your mouse.
+
+=item Sign-Up with email/URL based authentication
+
+Sign-Up and Authentication runs without moderator intervention.
+
+=item User preferences
+
+Time-zone; time format; user avatar; notifications
+
+=item Non-plaintext passwords stored in database
+
+There's nothing worse than letting someone with database
+access read your favourite password.
+
+=item Password reset / Lost password
+
+People forget. This way they can reset their password without
+needing human help.
+
+=item L<ForumCode|Template::Plugin::ForumCode>
+
+BBCode-esque markup in posts.
+
+=item Terms & Conditions
+
+If you add new T&Cs, all users will be required to agree to them
+next time they log-in. No more hidden, unnoticed T&C updates.
+
+Users can view historical T&Cs.
+
+=back
+
+=head1 SEE ALSO
+
+L<Catalyst>,
+L<http://developer.berlios.de/projects/parley/>
+
+=head1 AUTHOR
+
+Chisel Wright C<< <chiselwright at users.berlios.de> >>
+
+=head1 LICENSE
+
+This library is free software, you can redistribute it and/or modify
+it under the same terms as Perl itself.
+
+=head1 TECHNICAL STUFF
+
+General users don't need to read beyond this point. The following information
+describes the top-level interface for the C<Parley> module.
+
 =head1 METHODS
 
 =head2 application_email_address($c)
@@ -238,19 +389,6 @@
 
 =back
 
-=head1 SEE ALSO
-
-L<Parley::Controller::Root>, L<Catalyst::Plugin::Email>, L<Catalyst>
-
-=head1 AUTHOR
-
-Chisel Wright C<< <chisel at herlpacker.co.uk> >>
-
-=head1 LICENSE
-
-This library is free software, you can redistribute it and/or modify
-it under the same terms as Perl itself.
-
 =cut
 
 vim: ts=8 sts=4 et sw=4 sr sta

Modified: tags/parley-0.53/lib/Template/Plugin/ForumCode.pm
===================================================================
--- tags/parley-0.53/lib/Template/Plugin/ForumCode.pm	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/lib/Template/Plugin/ForumCode.pm	2008-10-08 11:42:12 UTC (rev 952)
@@ -31,6 +31,11 @@
 sub forumcode {
     my ($self, $text) = @_;
 
+    # if we don't have any text, we don't have to do any work
+    if (not defined $text) {
+        return q{};
+    }
+
     # first of all ESCAPE EVERYTHING!
     $text = Template::Plugin::HTML->escape($text);
 
@@ -43,6 +48,8 @@
     $self->_lists           ( \$text );
     $self->_url_links       ( \$text );
     $self->_images          ( \$text );
+    $self->_styled_block    ( \$text );
+    $self->_quoted_block    ( \$text );
     
     return $text;
 }
@@ -103,6 +110,15 @@
         \[/url\]        # close the URL tag
     }
     {<a href="$2">$1</a>}xmsg;
+    # bbcode / explosm style urls
+    $$textref =~ s{
+        \[URL=&quot;    # opening url tag
+        (.+?)           # the url
+        &quot;\]        # close-opening tag
+        (.+?)           # link name/text/label
+        \[/URL]         # closing tag
+    }
+    {<a href="$1">$2</a>}ximsg;
 }
 
 sub _images {
@@ -116,7 +132,8 @@
         (.+?)
         \[/img\]
     }
-    {<img src="$2"$1 />}xmsg;
+    {<img src="$2"$1 />}ximsg;
+    # bbcode / explosm style images
 }
 
 sub _colouring {
@@ -197,6 +214,37 @@
     return $text;
 }
 
+sub _styled_block {
+    my ($self, $textref) = @_;
+
+    $$textref =~ s{
+        \[(code|pre|quote)\]
+        (.+?)
+        \[/\1\]
+    }
+    {<div class="forumcode_$1">$2</div>}xmsg;
+}
+
+# this deals with the extended case of [quote] where we have the quoting=
+# attribute
+sub _quoted_block {
+    my ($self, $textref) = @_;
+
+    $$textref =~ s{
+        \[
+            (quote)
+            \s+
+            quoting=
+            &quot;
+            (.+?)
+            &quot;
+        \]
+        (.+?)
+        \[/\1\]
+    }
+    {<div class="forumcode_$1"><div class="forumcode_quoting">Quoting $2:</div>$3</div>}xmsg;
+}
+
 1;
 __END__
 vim: ts=8 sts=4 et sw=4 sr sta
@@ -209,6 +257,8 @@
 
 =head1 SYNOPSIS
 
+Standard usage in a Template Toolkit file:
+
   # load the TT module
   [% USE ForumCode %]
 
@@ -216,6 +266,13 @@
   [% ForumCode.forumcode('[b]bold[/u] [u]underlined[/u] [i]italic[/i]') %]
   [% ForumCode.forumcode('**bold** __underlined__') %]
 
+Usage in a perl module:
+
+  use Template::Plugin::ForumCode;
+
+  my $tt_forum  = Template::Plugin::ForumCode->new();
+  my $formatted = $tt_forum->forumcode($text);
+
 =head1 DESCRIPTION
 
 This module implements ForumCode, a simple markup language inspired by the

Modified: tags/parley-0.53/parley.yml
===================================================================
--- tags/parley-0.53/parley.yml	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/parley.yml	2008-10-08 11:42:12 UTC (rev 952)
@@ -3,7 +3,6 @@
 name:         Parley
 default_uri:  /forum/list
 posts_per_page: 10
-search_results_per_page: 25
 replies_have_own_subject: 0
 
 alerts:
@@ -19,14 +18,8 @@
     - 'error'
     - 'fatal'
 
-Model::ParleyDB:
-    schema_class: 'Parley::Schema'
-    connect_info:   
-        - 'dbi:Pg:dbname=parley;host=localhost'
-        - 'parley'
-        - ''
-        - AutoCommit: 1
 
+
 # emails; perldoc Catalyst::Plugin::Email
 # this passes options as an array :(
 email:
@@ -60,13 +53,6 @@
     EVAL_PERL:      '0'
     PRE_PROCESS:    'header'
     POST_PROCESS:   'footer'
-    POST_CHOMP:     '1'
-    PRE_CHOMP:      '0'
     # comment out the following line to enable Template::Timer output in your
     # template source
     CONTEXT:        ''
-
-static:
-    ignore_extensions:
-        - asp
-        - php

Modified: tags/parley-0.53/root/base/forum/list
===================================================================
--- tags/parley-0.53/root/base/forum/list	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/forum/list	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +1,4 @@
-<h1>Forum List</h1>
+<h1>[%l('Forum List')%]</h1>
 
 <table>
     <tr>

Modified: tags/parley-0.53/root/base/forum/view
===================================================================
--- tags/parley-0.53/root/base/forum/view	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/forum/view	2008-10-08 11:42:12 UTC (rev 952)
@@ -26,22 +26,14 @@
     [%- END %]
     </td>
 
-    <td>
-    <a href="thread/view?thread=[% thread.id %]" class="topic_link">[% ForumCode.escape(thread.subject) %]</a>
-    <br />
-    <span class="forum_mini_pager">
-        [%- IF authed_user || mini_pager %]
-        [
-            [%- IF authed_user %]
-            <a href="thread/next_post?thread=[% thread.id %]">Continue</a>
-            [%- END %]
-        ]
-        [%- END %]
+<div style="float:right; font-size: 85%;">
+    <span class="yui-button yui-link-button">
+        <span class="first-child">
+            <a href="[%c.uri_for('/thread/add',{'forum'=>current_forum.id})%]">[%l('Create New Thread')%]</a>
+        </span>
     </span>
-    <span class="topic_creator">created by
-        <span class="post_creator">[% thread.creator.forum_name %]</span>
-    </span>
-    </td>
+</div>
+[% PROCESS shared/pager_advanced %]
 
     <td>
      [% nicedate(thread.last_post.created) %]
@@ -83,6 +75,8 @@
     </tr>
   [% END %]
 </table>
+
+[% PROCESS shared/pager_advanced %]
 [% ELSE %]
   No active threads in this forum
 [% END %]

Modified: tags/parley-0.53/root/base/menu/left/main
===================================================================
--- tags/parley-0.53/root/base/menu/left/main	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/menu/left/main	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,22 +1,5 @@
-<p>
-    <!-- General Stuff -->
-    <a href="thread/recent">Recent Threads</a>
-</p>
 
-<p>
-    <!-- My -->
+<!-- My -->
 
-    <!-- Preferences -->
-    <a href="my/preferences">Preferences</a>
-</p>
-
-<p>
-    <!-- Admin -->
-    <a href="admin">Admin</a>
-</p>
-
-<p>
-    <!-- Searching -->
-    <a href="javascript:;" onclick="search_dialog.show(); return false;">Search</a>
-    [% INCLUDE shared/search_dialog %]
-</p>
+<!-- Preferences -->
+<a href="my/preferences">Preferences</a>

Modified: tags/parley-0.53/root/base/menu/statusbar
===================================================================
--- tags/parley-0.53/root/base/menu/statusbar	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/menu/statusbar	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,5 +1,19 @@
 <!-- status bar : start -->
 
+<style type="text/css">
+</style>
+
+<script type="text/javascript">
+	function showLoginBox(start){
+        var popUp = dojo.lfx.explode(start, 'loginbox', 250, function(n) {
+            /* there's a timing issue here I think as the focus() only works if we have an alert() before it */
+            var something = dojo.byId('username');
+            something.focus();
+        });
+        popUp.play();
+	}
+</script>
+
 <table width="100%">
         <tr>
                 <td width="60%" class="left">
@@ -25,7 +39,27 @@
                         ]</i>
                         [% ELSE %]
             <i>[
-            <a href="javascript:;" onclick="login_dialog.show(); return false;">Login</a>
+
+            <!-- loginbox -->
+            <div id="loginbox">
+                <form action="user/login" method="post" name="login_form" class="loginbox">
+                    <fieldset>
+                        <label for="username"><b>Username:</b></label>
+                        <input type="text" id="username" name="username" style="width: 15em;" class="input_text" />
+                        <br />
+                        <label for="password"><b>Password:</b></label>
+                        <input type="password" id="password" name="password" style="width: 15em;" class="input_text" />
+                        <br />
+                        <button type="submit" value="log in" class="input_button" style="margin-left: 170px;"/>log in</button>
+
+                        <p>
+                        <a href="user/password/forgotten">Forgotten Password</a>
+                        </p>
+                    </fieldset>
+                </form>
+            </div>
+            <a href="javascript:;" onclick="showLoginBox(this)">Login</a>
+            <!-- loginbox -->
             |
             <a href="user/signup">Signup</a>
             ]</i>
@@ -39,6 +73,22 @@
         </tr>
 </table>
 
-[% INCLUDE shared/login_dialog %]
+<!-- status bar : end -->
 
-<!-- status bar : end -->
+<!--
+<script type="text/javascript">
+var dlg0, dlg1, dlg2, dlg3;
+function init(e) {
+	dlg1 = dojo.widget.byId("dialog1");
+	var timer = document.getElementById("timer1");
+	dlg1.setTimerNode(timer);
+	var btn = document.getElementById("hider1");
+	dlg1.setCloseControl(btn);
+}
+dojo.addOnLoad(init);
+</script>
+
+<div dojoType="dialog" id="dialog1" bgColor="red" bgOpacity="0.1" toggle="fade" toggleDuration="250" lifetime="5000">
+	Disappearing in <span id="timer1">3</span>... <a id="hider1" href="#">[X]</a>
+</div>
+-->

Modified: tags/parley-0.53/root/base/my/preferences
===================================================================
--- tags/parley-0.53/root/base/my/preferences	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/my/preferences	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +1,4 @@
-<h1>Your preferences</h1>
+<h1>[%l('Your Preferences')%]</h1>
 
 [% IF view.error.message %]
     [% view.error.message %]

Modified: tags/parley-0.53/root/base/thread/add
===================================================================
--- tags/parley-0.53/root/base/thread/add	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/thread/add	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +1,9 @@
-<h1>Start A New Topic</h1>
+<div style="margin-top:10px;"></div>
+<div class="thread_header">
+    <a href="forum/view?forum=[% current_forum.id %]">[% current_forum.name %]</a>
+    &nbsp;:&nbsp;
+    [%l('Start A New Topic')%]
+</div>
 
 [% IF view.error.message %]
     [% view.error.message %]
@@ -9,24 +14,35 @@
     </ul>
 [% END %]
 
-
 <form action="thread/add?forum=[% current_forum.id %]" method="POST" name="new_thread">
+    <table class="thread_add" border="0">
+        <tr>
+            <td class="thread_add_topic"> [%l('Topic')%] </td>
+            <td>
+            <input type="text" name="thread_subject" size="60" class="input_text" />
+            </td>
+        </tr>
 
-<table>
+        <tr>
+            <td class="thread_add_message"> [%l('Message')%] </td>
+            <td>
+                <textarea name="thread_message" id="thread_message" cols="60" rows="20" class="input_text" /></textarea>
+            </td>
+        </tr>
 
-  <tr>
-    <td> Topic </td>
-    <td>
-      <input type="text" name="thread_subject" size="60" class="input_text" />
-    </td>
-  </tr>
+        <tr>
+            <td>&nbsp;</td>
+            <td colspan="1" style="text-align: left;">
+                <span class="yui-button yui-link-button" style="margin-right:50px;margin-left:50px;">
+                    <span class="first-child">
+                        <a href="[%c.uri_for('/forum/view',{'forum'=>current_forum.id})%]">[%l('Cancel')%]</a>
+                    </span>
+                </span>
 
-  <tr>
-    <td> Message </td>
-    <td>
-      <textarea name="thread_message" cols="60" rows="20" class="input_text" /></textarea>
-    </td>
-  </tr>
+                <input type="button" value="[%l('Preview')%]" name="preview_reply" class="" id="message_preview" />
+                <input type="submit" value="[%l('Post New Topic')%]" name="post_reply" class="" />
+            </td>
+        </tr>
 
   <tr>
     <td colspan="2" style="text-align: center;">
@@ -49,4 +65,15 @@
   </tr>
 </table>
 
-</form>
+<!-- message preview majick -->
+<script type="text/javascript" src="[%c.uri_for('/static/MessagePreview-min.js')%]"></script>
+<script type="text/javascript">
+    var MessagePreview = new ParleyMessagePreview();
+
+    MessagePreview.config.label_preview = '[%l('Preview')%]';
+    MessagePreview.config.label_edit    = '[%l('Edit')%]';
+    MessagePreview.config.post_url      = "[%c.uri_for('/post/preview')%]";
+
+    MessagePreview.init();
+</script>
+<!-- (end) message preview majick -->

Modified: tags/parley-0.53/root/base/thread/reply
===================================================================
--- tags/parley-0.53/root/base/thread/reply	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/base/thread/reply	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,6 +1,11 @@
-<!--
-<h1>Reply to: [% current_thread.subject %]</h1>
--->
+<div style="margin-top:10px;"></div>
+<div class="thread_header">
+    <a href="forum/view?forum=[% current_forum.id %]">[% ForumCode.escape(current_forum.name) %]</a>
+    &nbsp;:&nbsp;
+    [%l('Replying To')%]
+    &nbsp;:&nbsp;
+    [% ForumCode.escape(current_thread.subject) %]
+</div>
 
 [%# different action depending on whether we're adding to a thread or replying to a specific post %]
 [% IF current_post %]
@@ -10,27 +15,23 @@
 [% END %]
 
 <!-- The post we're replying to -->
-<table>
-  <tr>
-    <td class="post_subject">
-      [% responding_to_post.subject %]
-    </td>
-    <td class="post_creator">
-      [% responding_to_post.creator.forum_name %]
-    </td>
-    <td class="post_created">
-      [% nicedate(responding_to_post.created) %]
-    </td>
-  </tr>
-  
-  <tr>
-    <td colspan="3" class="reply_post_message">
-      [% FILTER html_line_break %][% HTML.escape(responding_to_post.message) %][% END %]
-    </td>
-  </tr>
-</table>
-    
-<p>Please enter your reply in the form below:</p>
+<div class="yui-gf" style="margin-top:10px;margin-bottom:10px;">
+	<div class="yui-u first">
+        <div style="text-align:right; vertical-align: top;">
+            <p class="post_creator">
+            [% responding_to_post.creator.forum_name %]
+            </p>
+            <p class="post_created">
+            [% nicedate(responding_to_post.created) %]
+            </p>
+        </div>
+	</div>
+	<div class="yui-u">
+        <div class="reply_post_message innerpost">
+            [% FILTER html_line_break %][% ForumCode.forumcode(responding_to_post.message) %][% END %]
+        </div>
+	</div>
+</div>
 
 [% IF messages %]
 <p>
@@ -42,38 +43,51 @@
 </p>
 [% END %]
 
+<p style="padding:10px;">[%l('ENTER REPLY')%]:</p>
 
-<table>
-  [% IF c.config.replies_have_own_subject %]
-  <tr>
-    <td> Topic </td>
-    <td>
-      <input type="text" name="thread_subject" size="60" class="input_text" value="[% current_thread.subject %]" />
-    </td>
-  </tr>
-  [% END %]
+<!-- replies may have their own subject line -->
+[% IF c.config.replies_have_own_subject %]
+<div class="yui-gf" style="margin-top:10px;margin-bottom:10px;">
+	<div class="yui-u first">
+        <div style="text-align:right; vertical-align: top;">
+            [%l('Topic')%]:
+        </div>
+	</div>
+	<div class="yui-u">
+        <input type="text" name="thread_subject" size="60" class="input_text" value="[% current_thread.subject %]" />
+	</div>
+</div>
+[% END %]
 
-  [% IF quote_post %]
+<!-- possibly quoting an existing post -->
+[% IF quote_post %]
   <input type="hidden" name="have_quoted_post" value="1" />
   <input type="hidden" name="__post" value="[% quote_post.id %]" />
-  <tr>
-  <td>&nbsp;</td>
-  <td>
-    <span class="post_creator">
-      [% quote_post.creator.forum_name %] said:
-    </span>
-    <br />
-    <textarea name="quote_message" cols="60" rows="10" class="quoted_reply_textarea" />[% quote_post.message %]</textarea>
-  </td>
-  </tr>
-  [% END %]
+<div class="yui-gf" style="margin-top:10px;margin-bottom:10px;">
+	<div class="yui-u first">
+        &nbsp;
+	</div>
+	<div class="yui-u">
+        <span class="post_creator">
+            [% quote_post.creator.forum_name %] [%l('said')%]:
+        </span>
+        <br />
+        <textarea name="quote_message" cols="60" rows="10" class="quoted_reply_textarea" />[% quote_post.message %]</textarea>
+	</div>
+</div>
+[% END %]
 
-  <tr>
-    <td> Message </td>
-    <td>
-      <textarea name="thread_message" cols="60" rows="20" class="input_text" /></textarea>
-    </td>
-  </tr>
+<!-- the reply area -->
+<div class="yui-gf" style="margin-top:10px;margin-bottom:10px;">
+	<div class="yui-u first">
+        <div style="text-align:right; vertical-align: top;">
+            [%l('Message')%]:
+        </div>
+	</div>
+	<div class="yui-u">
+        <textarea name="thread_message" id="thread_message" cols="60" rows="20" class="input_text" /></textarea>
+	</div>
+</div>
 
   [% IF moderator %]
   <tr>

Deleted: tags/parley-0.53/root/css/common.css
===================================================================
--- tags/parley-0.53/root/css/common.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/css/common.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,353 +0,0 @@
-/* link styling */
-a.nav, a.nav:visited, a.nav:link, a.nav:active {
-    background:         #ccc;
-    border:             solid black 1px;
-    border-style:       outset;
-    display:            block;
-    font-size:          0.8em;
-    font-weight:        bold;
-    list-style-image:   none;
-    list-style-type:    none;
-    margin-left:        20px;
-    margin-top:         0px;
-    padding-bottom:     0.2em;
-    padding-left:       0.5em;
-    padding-top:        0.2em;
-    text-decoration:    none;
-    width:              120px;
-}
-
-h1 {
-    font-size: 1.1em;
-    font-weight: bold;
-}
-h2 {
-    font-size: 1em;
-    font-weight: bold;
-}
-
-a.nav:hover {
-    background:         #000;
-    color:              #fff;
-}
-
-a, a:link, a:visited, a:active {
-    background:         transparent;
-    color:              blue;
-    text-decoration:    none;
-}
-
-/*table {
-    margin-left:        50px;
-    margin-bottom:      20px;
-    border:             1px solid black;
-}*/
-
-th {
-    text-align:         left;
-    font-weight:        bold;
-}
-
-td {
-    border:             1px solid #888;
-    padding:            3px;
-}
-
-/* start : dojo menu styling */
-.dojoMenuBar2 {
-    border-top:1px solid #d4d4d4;
-}
-.dojoPopupMenu2 td {
-    border: none;
-}
-/* end : dojo menu styling */
-
-.dojoTabPaneWrapper {
-  padding : 10px 10px 10px 10px;
-}
-
-/* dojo dialog styling - initially taken from dojo demo */
-.dojoDialog {
-    background : #eee;
-    border : 1px solid #999;
-    -moz-border-radius : 5px;
-    padding : 4px;
-}
-
-/* login dialog styling */
-#login_dialog form {  /* set width in form, not fieldset (still takes up more room w/ fieldset width */
-    margin: 0;
-    padding: 0;
-    min-width: 400px;
-    max-width: 600px;
-}
-#login_dialog form fieldset {
-    / * clear: both; note that this clear causes inputs to break to left in ie5.x mac, commented out */
-    border-color: #000;
-    border-width: 1px;
-    border-style: solid;
-    padding: 10px;        /* padding in fieldset support spotty in IE */
-    margin: 0;
-}
-#login_dialog form label { 
-    display: block;  /* block float the labels to left column, set a width */
-    float: left; 
-    width: 150px; 
-    padding: 0; 
-    margin: 5px 0 0; /* set top margin same as form input - textarea etc. elements */
-    text-align: right; 
-    font-weight: bold;
-    margin-bottom : 0;
-}
-#login_dialog form input, form textarea {
-    /* display: inline; inline display must not be set or will hide submit buttons in IE 5x mac */
-    width:auto;      /* set width of form elements to auto-size, otherwise watch for wrap on resize */
-    margin:5px 0 0 10px; /* set margin on left of form elements rather than right of
-                              label aligns textarea better in IE */
-}
-#login_dialog form p {
-    font-size: 0.8em;
-}
-
-/* style classes */
-
-.right_align {
-    text-align: right;
-    /*background: #f00;*/
-}
-
-
-.forum_link {
-    font-weight:    bold;
-}
-.forum_description {
-    font-size:      0.8em;
-}
-
-.topic_link {
-    font-weight:    bold;
-}
-.topic_creator {
-    display:        block;
-    font-size:      0.8em;
-    /*text-align:     right;*/
-    float: right;
-}
-.forum_mini_pager {
-    display:        block;
-    font-size:      0.8em;
-    /*text-align:     right;*/
-    float: left;
-}
-.topic_last_post {
-    font-size:      0.8em;
-}
-
-.post_subject {
-    font-weight:    bold;
-}
-
-.post_creator {
-    font-weight:    bold;
-    font-style:     italic;
-    font-size:      0.9em;
-}
-
-.post_created {
-    text-align:     right;
-    font-size:      0.8em;
-}
-
-.reply_post_message {
-    width: 100%;
-    background-color: rgb(251,215,194);
-    border: 2px inset #fff;
-}
-
-.post_message {
-    width: 100%;
-    background-color: rgb(251,215,194);
-    border: 2px inset #fff;
-    display: block;
-}
-
-.innerpost {
-    overflow:       auto;
-}
-
-.in_response_to {
-    margin-left:    20px;
-    font-weight:    bold;
-    font-style:     italic;
-    font-size:      0.8em;
-}
-
-.quoted_message {
-        border:         solid black 1pt;
-        background:     #ccc;
-        /*font-family:    "courier new", courier, fixed;*/
-        color:          #000;
-        margin-left:    20px;
-        margin-right:   0px;
-        margin-top:     0px;
-        margin-bottom:  0px;
-        padding:        2px;
-        font-size:      0.9em;
-
-        display: block;
-        overflow: auto;
-}
-
-
-.no_table_border table {
-    border: none;
-}
-.no_table_border td {
-    border: none;
-}
-
-.thread_watch {
-    font-size:          x-small;
-}
-.pager_advanced {
-    font-size:          x-small;
-}
-
-.thread_header {
-    font-weight:        bold;
-    background:         #666;
-    padding:            4px;
-}
-
-.thread_watches {
-    margin-left:        50px;
-    margin-right:       50px;
-    width:              500px;
-}
-
-.search_results {
-    margin-left:        50px;
-    margin-right:       50px;
-    width:              500px;
-}
-
-.user_profile {
-    margin-left:        50px;
-    margin-right:       50px;
-    width:              500px;
-}
-
-.prefs_notification {
-    margin-left:        50px;
-    margin-right:       50px;
-    width:              500px;
-}
-
-.user_profile_key {
-    font-weight:        bold;
-    text-align:         right;
-    vertical-align:     top;
-}
-
-td.user_profile_key {
-    width:              120px;
-}
-
-.user_profile_value {
-    font-weight:        none;
-    text-align:         left;
-    vertical-align:     top;
-}
-
-.thread_posts {
-    margin-left:        50px;
-    margin-right:       50px;
-    width:              600px;
-}
-
-.thread_info {
-    margin:             0px;
-    width:              100%;
-    border:             none;
-    padding:            0px;
-}
-
-.thread_info td {
-    border:             none;
-    padding:            0px;
-}
-
-.post {
-    padding-top:        5px;
-    vertical-align:     top;
-}
-
-.post_edited_alert {
-    font-weight:    bold;
-    font-style:     italic;
-    font-size:      0.8em;
-}
-
-.user_post_info {
-    background:         #ccc;
-    font-size:          85%;
-    margin-left:        auto;
-    margin-right:       auto;
-    text-align:         center;
-    vertical-align:     top;
-    width:              100px;
-}
-
-.quote {
-    background-color:   #F9FBFF;
-    border:             1px solid #333;
-    font-size:          95%;
-    margin:             0 0 2px 4px;
-    padding:            6px;
-    width:              85%;
-}
-
-.post_info {
-    font-size:          80%;
-    line-height:        1.1em;
-    margin-top:         10px;
-    margin-bottom:      2px;
-    text-align:         right;
-}
-
-a.button:visited, a.button:link, a.button:active, .button, a.button {
-    border:             2px solid;
-    border-color:       #FC9 #630 #330 #F96;
-    padding:            2px 7px 2px 7px;
-    font:               bold 0.9em verdana,sans-serif;
-    color:              #000;
-    background:         #ccc;
-    text-decoration:    none;
-    margin:             2px;
-}
-
-
-
-
-
-form input, form textarea {
-    /* display: inline; inline display must not be set or will hide submit buttons in IE 5x mac */
-    width:auto;      /* set width of form elements to auto-size, otherwise watch for wrap on resize */
-    margin:5px 0 0 10px; /* set margin on left of form elements rather than right of
-                              label aligns textarea better in IE */
-}
-
-form input#reset {
-    margin-left:0px; /* set margin-left back to zero on reset button (set above) */
-}
-
-form label { 
-    display: block;  /* block float the labels to left column, set a width */
-    float: left;
-    width: 150px;
-    padding: 0;
-    margin: 5px 0 0; /* set top margin same as form input - textarea etc. elements */
-    text-align: right;
-    font-weight: bold;
-}
-

Modified: tags/parley-0.53/root/css/default.css
===================================================================
--- tags/parley-0.53/root/css/default.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/css/default.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -369,639 +369,170 @@
 }
 
 
-a.button:visited, a.button:link, a.button:active, .button, a.button {
-    border:             2px solid;
-    border-color:       #FC9 #630 #330 #F96;
-    padding:            2px 7px 2px 7px;
-    font:               bold 0.8em verdana,sans-serif;
-    color:              #000;
-    background:         #ccc;
-    text-decoration:    none;
-    margin:             0;
-}
 
-
-/* login dialog styling */
-#login_dialog form {  /* set width in form, not fieldset (still takes up more room w/ fieldset width */
-    margin: 0;
-    padding: 0;
-    min-width: 400px;
-    max-width: 600px;
+form {  /* set width in form, not fieldset (still takes up more room w/ fieldset width */
+  margin: 0;
+  padding: 0;
+  min-width: 500px;
+  max-width: 600px;
+  width: 560px; 
 }
-#login_dialog form fieldset {
-    / * clear: both; note that this clear causes inputs to break to left in ie5.x mac, commented out */
-    border-color: #000;
-    border-width: 1px;
-    border-style: solid;
-    padding: 10px;        /* padding in fieldset support spotty in IE */
-    margin: 0;
-}
-#login_dialog form label { 
-    display: block;  /* block float the labels to left column, set a width */
-    float: left; 
-    width: 150px; 
-    padding: 0; 
-    margin: 5px 0 0; /* set top margin same as form input - textarea etc. elements */
-    text-align: right; 
-    font-weight: bold;
-    margin-bottom : 0;
-}
-#login_dialog form input, form textarea {
-    /* display: inline; inline display must not be set or will hide submit buttons in IE 5x mac */
-    width:auto;      /* set width of form elements to auto-size, otherwise watch for wrap on resize */
-    margin:5px 0 0 10px; /* set margin on left of form elements rather than right of
-                              label aligns textarea better in IE */
-}
-#login_dialog form p {
-    font-size: 0.8em;
-}
 
- 
-
-/* search dialog styling */
-#search_dialog form {  /* set width in form, not fieldset (still takes up more room w/ fieldset width */
-    margin: 0;
-    padding: 0;
-    min-width: 400px;
-    max-width: 600px;
+form fieldset {
+  / * clear: both; note that this clear causes inputs to break to left in ie5.x mac, commented out */
+  border-color: #000;
+  border-width: 1px;
+  border-style: solid;
+  padding: 10px;        /* padding in fieldset support spotty in IE */
+  margin: 0;
 }
-#search_dialog form fieldset {
-    / * clear: both; note that this clear causes inputs to break to left in ie5.x mac, commented out */
-    border-color: #000;
-    border-width: 1px;
-    border-style: solid;
-    padding: 10px;        /* padding in fieldset support spotty in IE */
-    margin: 0;
-}
-#search_dialog form label { 
-    display: block;  /* block float the labels to left column, set a width */
-    float: left; 
-    width: 150px; 
-    padding: 0; 
-    margin: 5px 0 0; /* set top margin same as form input - textarea etc. elements */
-    text-align: right; 
-    font-weight: bold;
-    margin-bottom : 0;
-}
-#search_dialog form input, form textarea {
-    /* display: inline; inline display must not be set or will hide submit buttons in IE 5x mac */
-    width:auto;      /* set width of form elements to auto-size, otherwise watch for wrap on resize */
-    margin:5px 0 0 10px; /* set margin on left of form elements rather than right of
-                              label aligns textarea better in IE */
-}
-#search_dialog form p {
-    font-size: 0.8em;
-}
 
-
-
-
-/* dojo dialog styling - initially taken from dojo demo */
-.dojoDialog {
-    background : #eee;
-    border : 1px solid #999;
-    -moz-border-radius : 5px;
-    padding : 4px;
+form fieldset legend {
+	font-size:1.1em; /* bump up legend font size, not too large or it'll overwrite border on left */
+                       /* be careful with padding, it'll shift the nice offset on top of border  */
 }
 
-form {
-    margin-bottom : 0;
+form label { 
+	display: block;  /* block float the labels to left column, set a width */
+	float: left; 
+	width: 150px; 
+	padding: 0; 
+	margin: 5px 0 0; /* set top margin same as form input - textarea etc. elements */
+	text-align: right; 
+    font-weight: bold;
 }
 
-
-
-/* Borrowed from ModelMayhem */
-body {
-font-family:Trebuchet, Verdana, Lucida Grande, Sapir Sans, Tahoma, Sans-Serif;
-font-size:80%;
-/*background-color:#E7E7E7;*/
-color:#000;
-letter-spacing:2%;
-line-height:1.3em;
-margin:0;
-padding:0;
+form fieldset label:first-letter { /* use first-letter pseudo-class to underline accesskey, note that */
+	text-decoration:none;    /* Firefox 1.07 WIN and Explorer 5.2 Mac don't support first-letter */
+                                    /* pseudo-class on legend elements, but do support it on label elements */
+                                    /* we instead underline first letter on each label element and accesskey */
+                                    /* each input. doing only legends would  lessens cognitive load */
+                                   /* opera breaks after first letter underlined legends but not labels */
 }
 
-#pic_wrapper {
-margin-bottom:6px;
+form input, form textarea {
+	/* display: inline; inline display must not be set or will hide submit buttons in IE 5x mac */
+	width:auto;      /* set width of form elements to auto-size, otherwise watch for wrap on resize */
+	margin:5px 0 0 10px; /* set margin on left of form elements rather than right of
+                              label aligns textarea better in IE */
 }
 
-.forum_title {
-font-size:110%;
-font-weight:700;
+form input#reset {
+	margin-left:0px; /* set margin-left back to zero on reset button (set above) */
 }
 
+textarea { overflow: auto; }
 
-.ribbon {
-background-color:#F9FBFF;
-padding: 3px;
-border:1px solid #EBEEF2;
-
+form small {
+	display: block;
+	margin: 0 0 5px 160px; /* instructions/comments left margin set to align w/ right column inputs */
+	padding: 1px 3px;
+	font-size: 88%;
 }
 
-.g1 {
-border-bottom:1px solid red;
-}
+form .required{font-weight:bold;} /* uses class instead of div, more efficient */
 
-.g2 {
-border-bottom:1px solid blue;
+form br {
+	clear:left; /* setting clear on inputs didn't work consistently, so brs added for degrade */
 }
 
-.light {
-color:#666;
-}
 
-.small {
-font-size:85%;
-line-height:1.1em;
+#Xloginbox {
+    border: 1px solid #ccc;
+    width: 250px;
+    float: right;
+    background-color: #f8f8f8;
+    padding: 5px;
+    margin-top: 1.5em;
+    margin-right: 3em;
+    font-size:      0.8em;
 }
 
-#navbox,#navbox a {
-height:20px;
-background-color:#000;
-text-align:center;
-font-weight:700;
-color:#FFF;
-font-size:105%;
-margin:0;
-}
+#loginbox {
+    position : absolute;
+    left : 200px;
+    top : 100px;
+    display : none;
 
-.searchhead {
-width:120px;
-text-align:right;
-font-weight:700;
-font-size:90%;
-background-color:#E1E4EA;
+    border: 1px solid #000;
+    width: 250px;
+    font-size:      0.8em;
+    background-color: #f8f8f8;
+    background-color: #ccc;
+    padding: 5px;
 }
 
-.linkbar {
-background-color:#F5F5F5;
-border:1px solid #E5E4E4;
-padding: 4px;
-margin-bottom: 8px;
+#searchbox {
+    border: 1px solid #ccc;
+    /*width: 400px;*/
+    float: right;
+    background-color: #f8f8f8;
+    padding: 5px;
+    /*
+    margin-top: 1.5em;
+    margin-right: 13em;
+    */
+    font-size:      0.8em;
+    position: relative;
+    top: -10px;
 }
 
-.linkbar2 {
-width: 90%;
-background-color:#F5F5F5;
-border:1px solid #9CA0AD;
-padding: 4px;
-margin-bottom: 8px;
-}
 
-#searchtable {
-background-color:#F5F5F5;
-}
 
-#searchtable td {
-padding:3px;
+form.searchbox {
+    min-width: 0px;
+    max-width: 35em;
 }
 
-.menubox {
-background-color:#F9FBFF;
-border:1px solid #9CA0AD;
-clear:both;
-width:150px;
-white-space:nowrap;
-vertical-align:middle;
-margin:2px 0;
-padding:2px;
+form.searchbox fieldset label {
+    margin-left: 0;
+    padding-top: 8px;
+    padding-right: 5px;
+    margin: 0;
+    width: auto;
+    text-align: left;
 }
-
-.mycoms {
-border-bottom:1px solid #333333;
+form.searchbox fieldset input {
+    margin: 0;
+    width: 20em;
 }
-
-.menubox2 {
-background-color:#F9FBFF;
-border:1px solid red;
-clear:both;
-width:150px;
-white-space:nowrap;
-vertical-align:middle;
-margin:2px 0;
-padding:2px;
+form.searchbox fieldset button {
+    margin-left: auto;
+    margin-right: auto;
+    display: inline;
 }
 
-.headerbar {
-background-color:#666;
-color:#FFF;
-padding:4px;
-}
 
-.thepagenums {
-font-size:92%;
+form.loginbox {
+    min-width: 0px;
+    max-width: 250px;
 }
-
-.thepagenums b {
-font-style:normal;
-font-weight:700;
-font-size:120%;
-padding:2px;
+form.loginbox fieldset label, form.loginbox fieldset input{  /* set width in form, not fieldset (still takes up more room w/ fieldset width */
+    padding: 0px;
+    margin: 5px 0 0 10px;
+    width: 8em;
 }
 
-.thepagenums a {
-font-weight:400;
-margin:0;
-padding:3px 2px;
+form fieldset p {
+    text-align: left;
 }
 
-.googlead {
-background-color:#333;
-width:728px;
-margin:4px auto;
+form fieldset button {
+	margin:5px 0 0 10px;
+    margin-left: auto;
+    margin-right: auto;
+    display: block;
 }
 
-.forumtop {
-background-color:#999;
-border: none;
-padding: 0;
-margin: 0;
-border-bottom:1px solid #9CA0AD;
-}
 
-.forumtop2 {
-background-color:#333;
-color:#FFF;
-font-size:85%;
-padding:2px;
+a.button:visited, a.button:link, a.button:active, .button, a.button {
+    border:             2px solid;
+    border-color:       #FC9 #630 #330 #F96;
+    padding:            2px 7px 2px 7px;
+    font:               bold 0.8em verdana,sans-serif;
+    color:              #000;
+    background:         #ccc;
+    text-decoration:    none;
+    margin:             0;
 }
 
-.postwrap {
-margin: 0;
-padding: 0;
-border-bottom:1px dashed #9CA0AD;
-background-color: transparent;
-}
-
-.postbit {
-margin: 0;
-padding: 0;
-padding:6px 0 8px 9px;
-}
-
-.post {
-border: none;
-margin: 0;
-padding: 0;
-padding:10px 6px 8px 8px;
-}
-
-.labelpicpage {
-width: 150px;
-font-size: 90%;
-font-weight: bold;
-background-color:#EBEEF2;
-text-align: right;
-}
-
-.post_b {
-background-color:#f9f9fb;
-border-bottom:1px solid #999;
-padding:2px;
-}
-
-.quote {
-width:90%;
-border:1px solid #333;
-font-size:95%;
-background-color:#F9FBFF;
-margin:0 0 2px 14px;
-padding:6px;
-}
-
-.last_post {
-font-family:Tahoma, Sans-Serif;
-font-size:95%;
-color:#7C879D;
-text-align:justify;
-}
-
-.caption {
-margin-bottom:14px;
-margin-left:auto;
-margin-right:auto;
-width:400px;
-font-weight:700;
-text-align:center;
-padding:0 9px 6px 24px;
-}
-
-textarea,.bginput {
-font:10pt verdana, geneva, lucida, 'lucida grande', arial, helvetica, sans-serif;
-}
-
-img.leftie {
-border:none;
-margin-right:9px;
-margin-bottom:6px;
-}
-
-.logobar {
-background:#FFF;
-width:800px;
-margin-left:auto;
-margin-right:auto;
-padding:0;
-}
-
-table.navbarwrap {
-width:800px;
-font-weight:700;
-background:#000;
-margin-left:auto;
-border-top:1px solid #000;
-border-bottom:1px solid #000;
-margin-right:auto;
-}
-
-table.navbar {
-margin:0;
-}
-
-.lineit {
-color:#000;
-border-right:1px solid #666;
-}
-
-.lineit a {
-color:#333;
-display:block;
-position:relative;
-text-decoration:none;
-padding:2px 10px;
-}
-
-.lineit a:hover {
-background-color:#292B2C;
-}
-
-table.maintable {
-width:100%;
-background-color:#FFF;
-margin-left:auto;
-margin-right:auto;
-padding:15px 24px 16px;
-border: none;
-}
-
-td, th, tr {
-    border: none;
-    margin: none;
-    padding: none;
-}
-
-.footerbox {
-width:100%;
-color:#333;
-background-color:#F4F4F5;
-font-size:90%;
-text-align:right;
-border-top:1px solid #ccc;
-margin-botom:16px;
-margin-left:auto;
-margin-right:auto;
-padding:5px;
-}
-
-.footerbox a:990000 {
-color:#FFF;
-}
-
-hr {
-border-top:1px solid #ddd;
-color:#fff;
-background-color:#fff;
-height:1px;
-width:90%;
-margin-top:22px;
-margin-bottom:12px;
-}
-
-#bg_wrap {
-width:800px;
-margin-left:auto;
-margin-right:auto;
-padding:0;
-}
-
-.head {
-background:url(/images/head.gif) #F4F4F5 repeat-x;
-border:1px solid #CCC;
-clear:both;
-color:#333;
-font-weight:700;
-text-align:left;
-white-space:nowrap;
-margin:16px 2px 4px 0;
-padding:2px 5px;
-}
-
-.head_thin {
-background:url(/images/head.gif) #F4F4F5 repeat-x;
-border:1px solid #CCC;
-clear:both;
-color:#333;
-font-weight:700;
-text-align:left;
-white-space:nowrap;
-margin:4px 2px 4px 0;
-padding:2px 5px 2px 0;
-}
-
-.dotline {
-border:1px dashed #CCC;
-clear:both;
-text-align:left;
-white-space:nowrap;
-margin:4px 2px 4px 0;
-padding:2px 5px 2px 0;
-}
-
-.head_top {
-background:url(/images/head.gif) #F4F4F5 repeat-x;
-border:1px solid #CCC;
-clear:both;
-color:#333;
-font-weight:700;
-text-align:left;
-white-space:nowrap;
-margin:0 2px 4px 0;
-padding:2px 5px;
-}
-
-.head_forums {
-background:url(/images/head.gif) #F4F4F5 repeat-x;
-border:1px solid #CCC;
-clear:both;
-font-size:90%;
-color:#666;
-font-weight:700;
-text-align:center;
-white-space:nowrap;
-margin:0 0 4px;
-padding:1px 5px 1px 2px;
-}
-
-.big_image {
-border:1px solid #CCC;
-background-color:#fff;
-padding:5px;
-}
-
-form {
-margin:0;
-padding:0;
-}
-
-ul {
-margin:2px 0 0 15px;
-padding:0;
-}
-
-.number {
-border-right:1px solid #666;
-padding:0 4px;
-}
-
-.numbers {
-line-height:1.1em;
-margin-top:5px;
-margin-bottom:3px;
-}
-
-.number_no {
-font-weight:700;
-color:#000;
-background-color:#F0F1F4;
-border-right:1px solid #666;
-padding:0 4px;
-}
-
-.number_wrap {
-background-color:#fff;
-border-top:1px solid #666;
-border-bottom:1px solid #666;
-border-left:1px solid #666;
-}
-
-.alert {
-width:90%;
-color:red;
-text-align:center;
-font-size:100%;
-border:3px solid red;
-margin-botom:16px;
-margin-left:auto;
-margin-right:auto;
-padding:5px;
-}
-
-.mm_input {
-width:100px;
-border:1px solid #999;
-background:#333;
-color:#fff;
-font-size:9px;
-}
-
-.mm_button {
-font-size:9px;
-}
-
-.dots {
-color:#000;
-background:#F5F5F5;
-border:2px dotted orange;
-margin-left:auto;
-margin-right:auto;
-margin-bottom:5px;
-padding:5px;
-}
-
-.dots2 {
-color:#000;
-background:#E1E4EA;
-border-bottom:2px dashed #ccc;
-margin:0 auto 5px;
-padding:10px;
-}
-
-.foo {
-color:#599CB3;
-}
-
-#tab {
-margin-top:0.5em;
-width:100%;
-margin-bottom:0;
-}
-
-#tab a {
-text-align:center;
-border:0;
-text-decoration:none;
-padding:0.5em 0.5em 0;
-}
-
-#tab .button {
-background:#F5F5F5;
-color:#000;
-}
-
-#tab .active {
-background:#E1E4EA;
-color:#000;
-font-weight:700;
-border-bottom:2px solid #E1E4EA;
-}
-
-a:link,a:visited,a:active {
-color:#22229C;
-}
-
-a:hover,.red {
-color:#C00;
-}
-
-h1,.big {
-font-size:110%;
-font-weight:700;
-color:#900;
-margin:0;
-padding:0;
-}
-
-h2 {
-font-size: 120%;
-font-weight: bold;
-color:#666666;
-margin-bottom:4px;
-}
-
-.g3,.g4 {
-color:green;
-}
-
-.light a:link,.light a:visited,.light a:active,.light a:hover {
-color:#ccc;
-}
-
-.headerbar a:link,.headerbar a:visited,.headerbar a:active,.headerbar a:hover {
-color:#FFF;
-text-decoration:none;
-}
-
-.navbar a:link,.navbar a:visited,.navbar a:active {
-color:#fff;
-}
-
-.navbar a:hover,.numbers a:link,.numbers a:visited,.numbers a:active,.numbers a:hover {
-text-decoration:none;
-}
-
-.footerbox a:visited,.footerbox a:link {
-color:#900;
-}
-/* Borrowed from ModelMayhem (end) */
-

Deleted: tags/parley-0.53/root/css/layout23.css
===================================================================
--- tags/parley-0.53/root/css/layout23.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/css/layout23.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,67 +0,0 @@
-html,body{
-    margin:             0;
-    padding:            0;
-}
-body{
-    font:               76% tahoma,verdana,arial,sans-serif;
-}
-p{
-    margin:             0 10px 10px
-}
-/* NOT USED
-a{
-    display:            block;
-    color:              #981793;
-    padding:            10px;
-}
-    */
-div#header h1{
-    height:             80px;
-    line-height:        80px;
-    margin:             0;
-    padding-left:       10px;
-    background:         #EEE;
-    color:              #79B30B;
-}
-div#content p{
-    line-height:        1.4;
-}
-div#navigation{
-    background:         #B9CAFF;
-    background:         #FFF;
-}
-div#extra{
-    background:         #FF8539;
-    background:         #FFF;
-}
-div#footer{
-    background:         #AAA;
-    color:              #FFF;
-}
-div#footer p{
-    margin:             0;
-    padding:            5px 10px;
-    text-align:         right;
-}
-
-div#wrapper{
-    float:              left;
-    width:              100%;
-    margin-left:        -200px;
-}
-div#content{
-    margin-left:        200px;
-}
-div#navigation{
-    float:              right;
-    width:              200px;
-}
-div#extra{
-    float:              right;
-    clear:              right;
-    width:              200px;
-}
-div#footer{
-    clear:              both;
-    width:              100%
-}

Deleted: tags/parley-0.53/root/css/layout27.css
===================================================================
--- tags/parley-0.53/root/css/layout27.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/css/layout27.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,15 +0,0 @@
-html,body{margin:0;padding:0}
-body{font: 76% arial,sans-serif}
-p{margin:0 10px 10px}
-/*a{display:block;color: #981793;padding:10px}*/
-div#header h1{height:80px;line-height:80px;margin:0;
-  padding-left:10px;background: #EEE;color: #79B30B}
-div#content p{line-height:1.4}
-div#navigation{background:transparent}
-div#extra{background:transparent}
-div#footer{background: #333;color: #FFF}
-div#footer p{margin:0;padding:5px 10px}
-
-div#navigation{float:left;width:50%}
-div#extra{float:left;width:49.9%}
-div#footer{clear:left;width:100%}

Deleted: tags/parley-0.53/root/css/layout33.css
===================================================================
--- tags/parley-0.53/root/css/layout33.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/css/layout33.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,18 +0,0 @@
-html,body{margin:0;padding:0}
-body{font: 76% arial,sans-serif;text-align:center}
-p{margin:0 10px 10px}
-a{display:block;color: #981793;padding:10px}
-div#header h1{height:80px;line-height:80px;margin:0;
-  padding-left:10px;background: #EEE;color: #79B30B}
-div#container{text-align:left}
-div#content p{line-height:1.4}
-div#navigation{background:#B9CAFF}
-div#extra{background:#FF8539}
-div#footer{background: #333;color: #FFF}
-div#footer p{margin:0;padding:5px 10px}
-
-div#container{width:700px;margin:0 auto}
-div#content{float:left;width:500px}
-div#navigation{float:right;width:200px}
-div#extra{float:right;clear:right;width:200px}
-div#footer{clear:both;width:100%}

Modified: tags/parley-0.53/root/static/magic/dojo.js
===================================================================
--- tags/parley-0.53/root/static/magic/dojo.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/dojo.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -19,36 +19,28 @@
 
 if(typeof dojo=="undefined"){
 var dj_global=this;
-var dj_currentContext=this;
 function dj_undef(_1,_2){
-return (typeof (_2||dj_currentContext)[_1]=="undefined");
+if(_2==null){
+_2=dj_global;
 }
-if(dj_undef("djConfig",this)){
+return (typeof _2[_1]=="undefined");
+}
+if(dj_undef("djConfig")){
 var djConfig={};
 }
-if(dj_undef("dojo",this)){
+if(dj_undef("dojo")){
 var dojo={};
 }
-dojo.global=function(){
-return dj_currentContext;
-};
-dojo.locale=djConfig.locale;
-dojo.version={major:0,minor:4,patch:3,flag:"",revision:Number("$Rev: 8617 $".match(/[0-9]+/)[0]),toString:function(){
+dojo.version={major:0,minor:3,patch:1,flag:"",revision:Number("$Rev: 4342 $".match(/[0-9]+/)[0]),toString:function(){
 with(dojo.version){
 return major+"."+minor+"."+patch+flag+" ("+revision+")";
 }
 }};
 dojo.evalProp=function(_3,_4,_5){
-if((!_4)||(!_3)){
-return undefined;
-}
-if(!dj_undef(_3,_4)){
-return _4[_3];
-}
-return (_5?(_4[_3]={}):undefined);
+return (_4&&!dj_undef(_3,_4)?_4[_3]:(_5?(_4[_3]={}):undefined));
 };
 dojo.parseObjPath=function(_6,_7,_8){
-var _9=(_7||dojo.global());
+var _9=(_7!=null?_7:dj_global);
 var _a=_6.split(".");
 var _b=_a.pop();
 for(var i=0,l=_a.length;i<l&&_9;i++){
@@ -56,44 +48,40 @@
 }
 return {obj:_9,prop:_b};
 };
-dojo.evalObjPath=function(_e,_f){
-if(typeof _e!="string"){
-return dojo.global();
+dojo.evalObjPath=function(_d,_e){
+if(typeof _d!="string"){
+return dj_global;
 }
-if(_e.indexOf(".")==-1){
-return dojo.evalProp(_e,dojo.global(),_f);
+if(_d.indexOf(".")==-1){
+return dojo.evalProp(_d,dj_global,_e);
 }
-var ref=dojo.parseObjPath(_e,dojo.global(),_f);
-if(ref){
-return dojo.evalProp(ref.prop,ref.obj,_f);
+var _f=dojo.parseObjPath(_d,dj_global,_e);
+if(_f){
+return dojo.evalProp(_f.prop,_f.obj,_e);
 }
 return null;
 };
-dojo.errorToString=function(_11){
-if(!dj_undef("message",_11)){
-return _11.message;
+dojo.errorToString=function(_10){
+if(!dj_undef("message",_10)){
+return _10.message;
 }else{
-if(!dj_undef("description",_11)){
-return _11.description;
+if(!dj_undef("description",_10)){
+return _10.description;
 }else{
-return _11;
+return _10;
 }
 }
 };
-dojo.raise=function(_12,_13){
-if(_13){
-_12=_12+": "+dojo.errorToString(_13);
-}else{
-_12=dojo.errorToString(_12);
+dojo.raise=function(_11,_12){
+if(_12){
+_11=_11+": "+dojo.errorToString(_12);
 }
 try{
-if(djConfig.isDebug){
-dojo.hostenv.println("FATAL exception raised: "+_12);
+dojo.hostenv.println("FATAL: "+_11);
 }
-}
 catch(e){
 }
-throw _13||Error(_12);
+throw Error(_11);
 };
 dojo.debug=function(){
 };
@@ -104,44 +92,53 @@
 },stop:function(){
 },dump:function(){
 }};
-function dj_eval(_15){
-return dj_global.eval?dj_global.eval(_15):eval(_15);
+function dj_eval(_14){
+return dj_global.eval?dj_global.eval(_14):eval(_14);
 }
-dojo.unimplemented=function(_16,_17){
-var _18="'"+_16+"' not implemented";
-if(_17!=null){
-_18+=" "+_17;
+dojo.unimplemented=function(_15,_16){
+var _17="'"+_15+"' not implemented";
+if(_16!=null){
+_17+=" "+_16;
 }
-dojo.raise(_18);
+dojo.raise(_17);
 };
-dojo.deprecated=function(_19,_1a,_1b){
-var _1c="DEPRECATED: "+_19;
+dojo.deprecated=function(_18,_19,_1a){
+var _1b="DEPRECATED: "+_18;
+if(_19){
+_1b+=" "+_19;
+}
 if(_1a){
-_1c+=" "+_1a;
+_1b+=" -- will be removed in version: "+_1a;
 }
-if(_1b){
-_1c+=" -- will be removed in version: "+_1b;
+dojo.debug(_1b);
+};
+dojo.inherits=function(_1c,_1d){
+if(typeof _1d!="function"){
+dojo.raise("dojo.inherits: superclass argument ["+_1d+"] must be a function (subclass: ["+_1c+"']");
 }
-dojo.debug(_1c);
+_1c.prototype=new _1d();
+_1c.prototype.constructor=_1c;
+_1c.superclass=_1d.prototype;
+_1c["super"]=_1d.prototype;
 };
 dojo.render=(function(){
-function vscaffold(_1d,_1e){
-var tmp={capable:false,support:{builtin:false,plugin:false},prefixes:_1d};
-for(var i=0;i<_1e.length;i++){
-tmp[_1e[i]]=false;
+function vscaffold(_1e,_1f){
+var tmp={capable:false,support:{builtin:false,plugin:false},prefixes:_1e};
+for(var _21 in _1f){
+tmp[_21]=false;
 }
 return tmp;
 }
 return {name:"",ver:dojo.version,os:{win:false,linux:false,osx:false},html:vscaffold(["html"],["ie","opera","khtml","safari","moz"]),svg:vscaffold(["svg"],["corel","adobe","batik"]),vml:vscaffold(["vml"],["ie"]),swf:vscaffold(["Swf","Flash","Mm"],["mm"]),swt:vscaffold(["Swt"],["ibm"])};
 })();
 dojo.hostenv=(function(){
-var _21={isDebug:false,allowQueryConfig:false,baseScriptUri:"",baseRelativePath:"",libraryScriptUri:"",iePreventClobber:false,ieClobberMinimal:true,preventBackButtonFix:true,delayMozLoadingFix:false,searchIds:[],parseWidgets:true};
+var _22={isDebug:false,allowQueryConfig:false,baseScriptUri:"",baseRelativePath:"",libraryScriptUri:"",iePreventClobber:false,ieClobberMinimal:true,preventBackButtonFix:true,searchIds:[],parseWidgets:true};
 if(typeof djConfig=="undefined"){
-djConfig=_21;
+djConfig=_22;
 }else{
-for(var _22 in _21){
-if(typeof djConfig[_22]=="undefined"){
-djConfig[_22]=_21[_22];
+for(var _23 in _22){
+if(typeof djConfig[_23]=="undefined"){
+djConfig[_23]=_22[_23];
 }
 }
 }
@@ -161,29 +158,27 @@
 if(!uri){
 dojo.raise("Nothing returned by getLibraryScriptUri(): "+uri);
 }
-var _25=uri.lastIndexOf("/");
+var _26=uri.lastIndexOf("/");
 djConfig.baseScriptUri=djConfig.baseRelativePath;
 return djConfig.baseScriptUri;
 };
 (function(){
-var _26={pkgFileName:"__package__",loading_modules_:{},loaded_modules_:{},addedToLoadingCount:[],removedFromLoadingCount:[],inFlightCount:0,modulePrefixes_:{dojo:{name:"dojo",value:"src"}},setModulePrefix:function(_27,_28){
-this.modulePrefixes_[_27]={name:_27,value:_28};
-},moduleHasPrefix:function(_29){
+var _27={pkgFileName:"__package__",loading_modules_:{},loaded_modules_:{},addedToLoadingCount:[],removedFromLoadingCount:[],inFlightCount:0,modulePrefixes_:{dojo:{name:"dojo",value:"src"}},setModulePrefix:function(_28,_29){
+this.modulePrefixes_[_28]={name:_28,value:_29};
+},getModulePrefix:function(_2a){
 var mp=this.modulePrefixes_;
-return Boolean(mp[_29]&&mp[_29].value);
-},getModulePrefix:function(_2b){
-if(this.moduleHasPrefix(_2b)){
-return this.modulePrefixes_[_2b].value;
+if((mp[_2a])&&(mp[_2a]["name"])){
+return mp[_2a].value;
 }
-return _2b;
+return _2a;
 },getTextStack:[],loadUriStack:[],loadedUris:[],post_load_:false,modulesLoadedListeners:[],unloadListeners:[],loadNotifying:false};
-for(var _2c in _26){
-dojo.hostenv[_2c]=_26[_2c];
+for(var _2c in _27){
+dojo.hostenv[_2c]=_27[_2c];
 }
 })();
 dojo.hostenv.loadPath=function(_2d,_2e,cb){
 var uri;
-if(_2d.charAt(0)=="/"||_2d.match(/^\w+:/)){
+if((_2d.charAt(0)=="/")||(_2d.match(/^\w+:/))){
 uri=_2d;
 }else{
 uri=this.getBaseScriptUri()+_2d;
@@ -192,7 +187,7 @@
 uri+="?"+String(djConfig.cacheBust).replace(/\W+/g,"");
 }
 try{
-return !_2e?this.loadUri(uri,cb):this.loadUriAndCheck(uri,_2e,cb);
+return ((!_2e)?this.loadUri(uri,cb):this.loadUriAndCheck(uri,_2e,cb));
 }
 catch(e){
 dojo.debug(e);
@@ -201,11 +196,11 @@
 };
 dojo.hostenv.loadUri=function(uri,cb){
 if(this.loadedUris[uri]){
-return true;
+return 1;
 }
 var _33=this.getText(uri,null,true);
-if(!_33){
-return false;
+if(_33==null){
+return 0;
 }
 this.loadedUris[uri]=true;
 if(cb){
@@ -215,7 +210,7 @@
 if(cb){
 cb(_34);
 }
-return true;
+return 1;
 };
 dojo.hostenv.loadUriAndCheck=function(uri,_36,cb){
 var ok=true;
@@ -225,7 +220,7 @@
 catch(e){
 dojo.debug("failed loading ",uri," with error: ",e);
 }
-return Boolean(ok&&this.findModule(_36,false));
+return ((ok)&&(this.findModule(_36,false)))?true:false;
 };
 dojo.loaded=function(){
 };
@@ -280,7 +275,7 @@
 if(this.post_load_){
 return;
 }
-if(this.loadUriStack.length==0&&this.getTextStack.length==0){
+if((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){
 if(this.inFlightCount>0){
 dojo.debug("files still in flight!");
 return;
@@ -289,7 +284,7 @@
 }
 };
 dojo.hostenv.callLoaded=function(){
-if(typeof setTimeout=="object"||(djConfig["useXDomain"]&&dojo.render.html.opera)){
+if(typeof setTimeout=="object"){
 setTimeout("dojo.hostenv.loaded();",0);
 }else{
 dojo.hostenv.loaded();
@@ -297,18 +292,14 @@
 };
 dojo.hostenv.getModuleSymbols=function(_42){
 var _43=_42.split(".");
-for(var i=_43.length;i>0;i--){
+for(var i=_43.length-1;i>0;i--){
 var _45=_43.slice(0,i).join(".");
-if((i==1)&&!this.moduleHasPrefix(_45)){
-_43[0]="../"+_43[0];
-}else{
 var _46=this.getModulePrefix(_45);
 if(_46!=_45){
 _43.splice(0,i,_46);
 break;
 }
 }
-}
 return _43;
 };
 dojo.hostenv._global_omit_module_check=false;
@@ -326,51 +317,49 @@
 }
 this.loading_modules_[_47]=1;
 var _4b=_47.replace(/\./g,"/")+".js";
-var _4c=_47.split(".");
-var _4d=this.getModuleSymbols(_47);
-var _4e=((_4d[0].charAt(0)!="/")&&!_4d[0].match(/^\w+:/));
-var _4f=_4d[_4d.length-1];
-var ok;
-if(_4f=="*"){
-_47=_4c.slice(0,-1).join(".");
-while(_4d.length){
-_4d.pop();
-_4d.push(this.pkgFileName);
-_4b=_4d.join("/")+".js";
-if(_4e&&_4b.charAt(0)=="/"){
+var _4c=this.getModuleSymbols(_47);
+var _4d=((_4c[0].charAt(0)!="/")&&(!_4c[0].match(/^\w+:/)));
+var _4e=_4c[_4c.length-1];
+var _4f=_47.split(".");
+if(_4e=="*"){
+_47=(_4f.slice(0,-1)).join(".");
+while(_4c.length){
+_4c.pop();
+_4c.push(this.pkgFileName);
+_4b=_4c.join("/")+".js";
+if(_4d&&(_4b.charAt(0)=="/")){
 _4b=_4b.slice(1);
 }
-ok=this.loadPath(_4b,!_49?_47:null);
+ok=this.loadPath(_4b,((!_49)?_47:null));
 if(ok){
 break;
 }
-_4d.pop();
+_4c.pop();
 }
 }else{
-_4b=_4d.join("/")+".js";
-_47=_4c.join(".");
-var _51=!_49?_47:null;
-ok=this.loadPath(_4b,_51);
-if(!ok&&!_48){
-_4d.pop();
-while(_4d.length){
-_4b=_4d.join("/")+".js";
-ok=this.loadPath(_4b,_51);
+_4b=_4c.join("/")+".js";
+_47=_4f.join(".");
+var ok=this.loadPath(_4b,((!_49)?_47:null));
+if((!ok)&&(!_48)){
+_4c.pop();
+while(_4c.length){
+_4b=_4c.join("/")+".js";
+ok=this.loadPath(_4b,((!_49)?_47:null));
 if(ok){
 break;
 }
-_4d.pop();
-_4b=_4d.join("/")+"/"+this.pkgFileName+".js";
-if(_4e&&_4b.charAt(0)=="/"){
+_4c.pop();
+_4b=_4c.join("/")+"/"+this.pkgFileName+".js";
+if(_4d&&(_4b.charAt(0)=="/")){
 _4b=_4b.slice(1);
 }
-ok=this.loadPath(_4b,_51);
+ok=this.loadPath(_4b,((!_49)?_47:null));
 if(ok){
 break;
 }
 }
 }
-if(!ok&&!_49){
+if((!ok)&&(!_49)){
 dojo.raise("Could not load '"+_47+"'; last tried '"+_4b+"'");
 }
 }
@@ -382,235 +371,84 @@
 }
 return _4a;
 };
-dojo.hostenv.startPackage=function(_52){
-var _53=String(_52);
-var _54=_53;
-var _55=_52.split(/\./);
-if(_55[_55.length-1]=="*"){
-_55.pop();
-_54=_55.join(".");
+dojo.hostenv.startPackage=function(_51){
+var _52=dojo.evalObjPath((_51.split(".").slice(0,-1)).join("."));
+this.loaded_modules_[(new String(_51)).toLowerCase()]=_52;
+var _53=_51.split(/\./);
+if(_53[_53.length-1]=="*"){
+_53.pop();
 }
-var _56=dojo.evalObjPath(_54,true);
-this.loaded_modules_[_53]=_56;
-this.loaded_modules_[_54]=_56;
-return _56;
+return dojo.evalObjPath(_53.join("."),true);
 };
-dojo.hostenv.findModule=function(_57,_58){
-var lmn=String(_57);
+dojo.hostenv.findModule=function(_54,_55){
+var lmn=(new String(_54)).toLowerCase();
 if(this.loaded_modules_[lmn]){
 return this.loaded_modules_[lmn];
 }
-if(_58){
-dojo.raise("no loaded module named '"+_57+"'");
+var _57=dojo.evalObjPath(_54);
+if((_54)&&(typeof _57!="undefined")&&(_57)){
+this.loaded_modules_[lmn]=_57;
+return _57;
 }
+if(_55){
+dojo.raise("no loaded module named '"+_54+"'");
+}
 return null;
 };
-dojo.kwCompoundRequire=function(_5a){
-var _5b=_5a["common"]||[];
-var _5c=_5a[dojo.hostenv.name_]?_5b.concat(_5a[dojo.hostenv.name_]||[]):_5b.concat(_5a["default"]||[]);
-for(var x=0;x<_5c.length;x++){
-var _5e=_5c[x];
-if(_5e.constructor==Array){
-dojo.hostenv.loadModule.apply(dojo.hostenv,_5e);
+dojo.kwCompoundRequire=function(_58){
+var _59=_58["common"]||[];
+var _5a=(_58[dojo.hostenv.name_])?_59.concat(_58[dojo.hostenv.name_]||[]):_59.concat(_58["default"]||[]);
+for(var x=0;x<_5a.length;x++){
+var _5c=_5a[x];
+if(_5c.constructor==Array){
+dojo.hostenv.loadModule.apply(dojo.hostenv,_5c);
 }else{
-dojo.hostenv.loadModule(_5e);
+dojo.hostenv.loadModule(_5c);
 }
 }
 };
-dojo.require=function(_5f){
+dojo.require=function(){
 dojo.hostenv.loadModule.apply(dojo.hostenv,arguments);
 };
-dojo.requireIf=function(_60,_61){
-var _62=arguments[0];
-if((_62===true)||(_62=="common")||(_62&&dojo.render[_62].capable)){
-var _63=[];
+dojo.requireIf=function(){
+if((arguments[0]===true)||(arguments[0]=="common")||(arguments[0]&&dojo.render[arguments[0]].capable)){
+var _5d=[];
 for(var i=1;i<arguments.length;i++){
-_63.push(arguments[i]);
+_5d.push(arguments[i]);
 }
-dojo.require.apply(dojo,_63);
+dojo.require.apply(dojo,_5d);
 }
 };
 dojo.requireAfterIf=dojo.requireIf;
-dojo.provide=function(_65){
+dojo.provide=function(){
 return dojo.hostenv.startPackage.apply(dojo.hostenv,arguments);
 };
-dojo.registerModulePath=function(_66,_67){
-return dojo.hostenv.setModulePrefix(_66,_67);
+dojo.setModulePrefix=function(_5f,_60){
+return dojo.hostenv.setModulePrefix(_5f,_60);
 };
-if(djConfig["modulePaths"]){
-for(var param in djConfig["modulePaths"]){
-dojo.registerModulePath(param,djConfig["modulePaths"][param]);
-}
-}
-dojo.setModulePrefix=function(_68,_69){
-dojo.deprecated("dojo.setModulePrefix(\""+_68+"\", \""+_69+"\")","replaced by dojo.registerModulePath","0.5");
-return dojo.registerModulePath(_68,_69);
-};
-dojo.exists=function(obj,_6b){
-var p=_6b.split(".");
+dojo.exists=function(obj,_62){
+var p=_62.split(".");
 for(var i=0;i<p.length;i++){
-if(!obj[p[i]]){
+if(!(obj[p[i]])){
 return false;
 }
 obj=obj[p[i]];
 }
 return true;
 };
-dojo.hostenv.normalizeLocale=function(_6e){
-var _6f=_6e?_6e.toLowerCase():dojo.locale;
-if(_6f=="root"){
-_6f="ROOT";
 }
-return _6f;
-};
-dojo.hostenv.searchLocalePath=function(_70,_71,_72){
-_70=dojo.hostenv.normalizeLocale(_70);
-var _73=_70.split("-");
-var _74=[];
-for(var i=_73.length;i>0;i--){
-_74.push(_73.slice(0,i).join("-"));
+if(typeof window=="undefined"){
+dojo.raise("no window object");
 }
-_74.push(false);
-if(_71){
-_74.reverse();
-}
-for(var j=_74.length-1;j>=0;j--){
-var loc=_74[j]||"ROOT";
-var _78=_72(loc);
-if(_78){
-break;
-}
-}
-};
-dojo.hostenv.localesGenerated;
-dojo.hostenv.registerNlsPrefix=function(){
-dojo.registerModulePath("nls","nls");
-};
-dojo.hostenv.preloadLocalizations=function(){
-if(dojo.hostenv.localesGenerated){
-dojo.hostenv.registerNlsPrefix();
-function preload(_79){
-_79=dojo.hostenv.normalizeLocale(_79);
-dojo.hostenv.searchLocalePath(_79,true,function(loc){
-for(var i=0;i<dojo.hostenv.localesGenerated.length;i++){
-if(dojo.hostenv.localesGenerated[i]==loc){
-dojo["require"]("nls.dojo_"+loc);
-return true;
-}
-}
-return false;
-});
-}
-preload();
-var _7c=djConfig.extraLocale||[];
-for(var i=0;i<_7c.length;i++){
-preload(_7c[i]);
-}
-}
-dojo.hostenv.preloadLocalizations=function(){
-};
-};
-dojo.requireLocalization=function(_7e,_7f,_80,_81){
-dojo.hostenv.preloadLocalizations();
-var _82=dojo.hostenv.normalizeLocale(_80);
-var _83=[_7e,"nls",_7f].join(".");
-var _84="";
-if(_81){
-var _85=_81.split(",");
-for(var i=0;i<_85.length;i++){
-if(_82.indexOf(_85[i])==0){
-if(_85[i].length>_84.length){
-_84=_85[i];
-}
-}
-}
-if(!_84){
-_84="ROOT";
-}
-}
-var _87=_81?_84:_82;
-var _88=dojo.hostenv.findModule(_83);
-var _89=null;
-if(_88){
-if(djConfig.localizationComplete&&_88._built){
-return;
-}
-var _8a=_87.replace("-","_");
-var _8b=_83+"."+_8a;
-_89=dojo.hostenv.findModule(_8b);
-}
-if(!_89){
-_88=dojo.hostenv.startPackage(_83);
-var _8c=dojo.hostenv.getModuleSymbols(_7e);
-var _8d=_8c.concat("nls").join("/");
-var _8e;
-dojo.hostenv.searchLocalePath(_87,_81,function(loc){
-var _90=loc.replace("-","_");
-var _91=_83+"."+_90;
-var _92=false;
-if(!dojo.hostenv.findModule(_91)){
-dojo.hostenv.startPackage(_91);
-var _93=[_8d];
-if(loc!="ROOT"){
-_93.push(loc);
-}
-_93.push(_7f);
-var _94=_93.join("/")+".js";
-_92=dojo.hostenv.loadPath(_94,null,function(_95){
-var _96=function(){
-};
-_96.prototype=_8e;
-_88[_90]=new _96();
-for(var j in _95){
-_88[_90][j]=_95[j];
-}
-});
-}else{
-_92=true;
-}
-if(_92&&_88[_90]){
-_8e=_88[_90];
-}else{
-_88[_90]=_8e;
-}
-if(_81){
-return true;
-}
-});
-}
-if(_81&&_82!=_84){
-_88[_82.replace("-","_")]=_88[_84.replace("-","_")];
-}
-};
 (function(){
-var _98=djConfig.extraLocale;
-if(_98){
-if(!_98 instanceof Array){
-_98=[_98];
-}
-var req=dojo.requireLocalization;
-dojo.requireLocalization=function(m,b,_9c,_9d){
-req(m,b,_9c,_9d);
-if(_9c){
-return;
-}
-for(var i=0;i<_98.length;i++){
-req(m,b,_98[i],_9d);
-}
-};
-}
-})();
-}
-if(typeof window!="undefined"){
-(function(){
 if(djConfig.allowQueryConfig){
-var _9f=document.location.toString();
-var _a0=_9f.split("?",2);
-if(_a0.length>1){
-var _a1=_a0[1];
-var _a2=_a1.split("&");
-for(var x in _a2){
-var sp=_a2[x].split("=");
+var _65=document.location.toString();
+var _66=_65.split("?",2);
+if(_66.length>1){
+var _67=_66[1];
+var _68=_67.split("&");
+for(var x in _68){
+var sp=_68[x].split("=");
 if((sp[0].length>9)&&(sp[0].substr(0,9)=="djConfig.")){
 var opt=sp[0].substr(9);
 try{
@@ -624,27 +462,27 @@
 }
 }
 if(((djConfig["baseScriptUri"]=="")||(djConfig["baseRelativePath"]==""))&&(document&&document.getElementsByTagName)){
-var _a6=document.getElementsByTagName("script");
-var _a7=/(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
-for(var i=0;i<_a6.length;i++){
-var src=_a6[i].getAttribute("src");
+var _6c=document.getElementsByTagName("script");
+var _6d=/(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
+for(var i=0;i<_6c.length;i++){
+var src=_6c[i].getAttribute("src");
 if(!src){
 continue;
 }
-var m=src.match(_a7);
+var m=src.match(_6d);
 if(m){
-var _ab=src.substring(0,m.index);
+var _71=src.substring(0,m.index);
 if(src.indexOf("bootstrap1")>-1){
-_ab+="../";
+_71+="../";
 }
 if(!this["djConfig"]){
 djConfig={};
 }
 if(djConfig["baseScriptUri"]==""){
-djConfig["baseScriptUri"]=_ab;
+djConfig["baseScriptUri"]=_71;
 }
 if(djConfig["baseRelativePath"]==""){
-djConfig["baseRelativePath"]=_ab;
+djConfig["baseRelativePath"]=_71;
 }
 break;
 }
@@ -653,8 +491,8 @@
 var dr=dojo.render;
 var drh=dojo.render.html;
 var drs=dojo.render.svg;
-var dua=(drh.UA=navigator.userAgent);
-var dav=(drh.AV=navigator.appVersion);
+var dua=drh.UA=navigator.userAgent;
+var dav=drh.AV=navigator.appVersion;
 var t=true;
 var f=false;
 drh.capable=t;
@@ -666,150 +504,111 @@
 drh.opera=dua.indexOf("Opera")>=0;
 drh.khtml=(dav.indexOf("Konqueror")>=0)||(dav.indexOf("Safari")>=0);
 drh.safari=dav.indexOf("Safari")>=0;
-var _b3=dua.indexOf("Gecko");
-drh.mozilla=drh.moz=(_b3>=0)&&(!drh.khtml);
+var _79=dua.indexOf("Gecko");
+drh.mozilla=drh.moz=(_79>=0)&&(!drh.khtml);
 if(drh.mozilla){
-drh.geckoVersion=dua.substring(_b3+6,_b3+14);
+drh.geckoVersion=dua.substring(_79+6,_79+14);
 }
 drh.ie=(document.all)&&(!drh.opera);
 drh.ie50=drh.ie&&dav.indexOf("MSIE 5.0")>=0;
 drh.ie55=drh.ie&&dav.indexOf("MSIE 5.5")>=0;
 drh.ie60=drh.ie&&dav.indexOf("MSIE 6.0")>=0;
 drh.ie70=drh.ie&&dav.indexOf("MSIE 7.0")>=0;
-var cm=document["compatMode"];
-drh.quirks=(cm=="BackCompat")||(cm=="QuirksMode")||drh.ie55||drh.ie50;
-dojo.locale=dojo.locale||(drh.ie?navigator.userLanguage:navigator.language).toLowerCase();
+dojo.locale=(drh.ie?navigator.userLanguage:navigator.language).toLowerCase();
 dr.vml.capable=drh.ie;
 drs.capable=f;
 drs.support.plugin=f;
 drs.support.builtin=f;
-var _b5=window["document"];
-var tdi=_b5["implementation"];
-if((tdi)&&(tdi["hasFeature"])&&(tdi.hasFeature("org.w3c.dom.svg","1.0"))){
+if(document.implementation&&document.implementation.hasFeature&&document.implementation.hasFeature("org.w3c.dom.svg","1.0")){
 drs.capable=t;
 drs.support.builtin=t;
 drs.support.plugin=f;
 }
-if(drh.safari){
-var tmp=dua.split("AppleWebKit/")[1];
-var ver=parseFloat(tmp.split(" ")[0]);
-if(ver>=420){
-drs.capable=t;
-drs.support.builtin=t;
-drs.support.plugin=f;
-}
-}else{
-}
 })();
 dojo.hostenv.startPackage("dojo.hostenv");
 dojo.render.name=dojo.hostenv.name_="browser";
 dojo.hostenv.searchIds=[];
 dojo.hostenv._XMLHTTP_PROGIDS=["Msxml2.XMLHTTP","Microsoft.XMLHTTP","Msxml2.XMLHTTP.4.0"];
 dojo.hostenv.getXmlhttpObject=function(){
-var _b9=null;
-var _ba=null;
+var _7a=null;
+var _7b=null;
 try{
-_b9=new XMLHttpRequest();
+_7a=new XMLHttpRequest();
 }
 catch(e){
 }
-if(!_b9){
+if(!_7a){
 for(var i=0;i<3;++i){
-var _bc=dojo.hostenv._XMLHTTP_PROGIDS[i];
+var _7d=dojo.hostenv._XMLHTTP_PROGIDS[i];
 try{
-_b9=new ActiveXObject(_bc);
+_7a=new ActiveXObject(_7d);
 }
 catch(e){
-_ba=e;
+_7b=e;
 }
-if(_b9){
-dojo.hostenv._XMLHTTP_PROGIDS=[_bc];
+if(_7a){
+dojo.hostenv._XMLHTTP_PROGIDS=[_7d];
 break;
 }
 }
 }
-if(!_b9){
-return dojo.raise("XMLHTTP not available",_ba);
+if(!_7a){
+return dojo.raise("XMLHTTP not available",_7b);
 }
-return _b9;
+return _7a;
 };
-dojo.hostenv._blockAsync=false;
-dojo.hostenv.getText=function(uri,_be,_bf){
-if(!_be){
-this._blockAsync=true;
+dojo.hostenv.getText=function(uri,_7f,_80){
+var _81=this.getXmlhttpObject();
+if(_7f){
+_81.onreadystatechange=function(){
+if(4==_81.readyState){
+if((!_81["status"])||((200<=_81.status)&&(300>_81.status))){
+_7f(_81.responseText);
 }
-var _c0=this.getXmlhttpObject();
-function isDocumentOk(_c1){
-var _c2=_c1["status"];
-return Boolean((!_c2)||((200<=_c2)&&(300>_c2))||(_c2==304));
 }
-if(_be){
-var _c3=this,_c4=null,gbl=dojo.global();
-var xhr=dojo.evalObjPath("dojo.io.XMLHTTPTransport");
-_c0.onreadystatechange=function(){
-if(_c4){
-gbl.clearTimeout(_c4);
-_c4=null;
-}
-if(_c3._blockAsync||(xhr&&xhr._blockAsync)){
-_c4=gbl.setTimeout(function(){
-_c0.onreadystatechange.apply(this);
-},10);
-}else{
-if(4==_c0.readyState){
-if(isDocumentOk(_c0)){
-_be(_c0.responseText);
-}
-}
-}
 };
 }
-_c0.open("GET",uri,_be?true:false);
+_81.open("GET",uri,_7f?true:false);
 try{
-_c0.send(null);
-if(_be){
+_81.send(null);
+if(_7f){
 return null;
 }
-if(!isDocumentOk(_c0)){
-var err=Error("Unable to load "+uri+" status:"+_c0.status);
-err.status=_c0.status;
-err.responseText=_c0.responseText;
-throw err;
+if((_81["status"])&&((200>_81.status)||(300<=_81.status))){
+throw Error("Unable to load "+uri+" status:"+_81.status);
 }
 }
 catch(e){
-this._blockAsync=false;
-if((_bf)&&(!_be)){
+if((_80)&&(!_7f)){
 return null;
 }else{
 throw e;
 }
 }
-this._blockAsync=false;
-return _c0.responseText;
+return _81.responseText;
 };
 dojo.hostenv.defaultDebugContainerId="dojoDebug";
 dojo.hostenv._println_buffer=[];
 dojo.hostenv._println_safe=false;
-dojo.hostenv.println=function(_c8){
+dojo.hostenv.println=function(_82){
 if(!dojo.hostenv._println_safe){
-dojo.hostenv._println_buffer.push(_c8);
+dojo.hostenv._println_buffer.push(_82);
 }else{
 try{
-var _c9=document.getElementById(djConfig.debugContainerId?djConfig.debugContainerId:dojo.hostenv.defaultDebugContainerId);
-if(!_c9){
-_c9=dojo.body();
+var _83=document.getElementById(djConfig.debugContainerId?djConfig.debugContainerId:dojo.hostenv.defaultDebugContainerId);
+if(!_83){
+_83=document.getElementsByTagName("body")[0]||document.body;
 }
 var div=document.createElement("div");
-div.appendChild(document.createTextNode(_c8));
-_c9.appendChild(div);
+div.appendChild(document.createTextNode(_82));
+_83.appendChild(div);
 }
 catch(e){
 try{
-document.write("<div>"+_c8+"</div>");
+document.write("<div>"+_82+"</div>");
 }
 catch(e2){
-window.status=_c8;
+window.status=_82;
 }
 }
 }
@@ -820,97 +619,59 @@
 dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
 }
 });
-function dj_addNodeEvtHdlr(_cb,_cc,fp){
-var _ce=_cb["on"+_cc]||function(){
+function dj_addNodeEvtHdlr(_85,_86,fp,_88){
+var _89=_85["on"+_86]||function(){
 };
-_cb["on"+_cc]=function(){
-fp.apply(_cb,arguments);
-_ce.apply(_cb,arguments);
+_85["on"+_86]=function(){
+fp.apply(_85,arguments);
+_89.apply(_85,arguments);
 };
 return true;
 }
-dojo.hostenv._djInitFired=false;
-function dj_load_init(e){
-dojo.hostenv._djInitFired=true;
-var _d0=(e&&e.type)?e.type.toLowerCase():"load";
-if(arguments.callee.initialized||(_d0!="domcontentloaded"&&_d0!="load")){
+dj_addNodeEvtHdlr(window,"load",function(){
+if(arguments.callee.initialized){
 return;
 }
 arguments.callee.initialized=true;
-if(typeof (_timer)!="undefined"){
-clearInterval(_timer);
-delete _timer;
-}
-var _d1=function(){
+var _8a=function(){
 if(dojo.render.html.ie){
 dojo.hostenv.makeWidgets();
 }
 };
 if(dojo.hostenv.inFlightCount==0){
-_d1();
+_8a();
 dojo.hostenv.modulesLoaded();
 }else{
-dojo.hostenv.modulesLoadedListeners.unshift(_d1);
+dojo.addOnLoad(_8a);
 }
-}
-if(document.addEventListener){
-if(dojo.render.html.opera||(dojo.render.html.moz&&(djConfig["enableMozDomContentLoaded"]===true))){
-document.addEventListener("DOMContentLoaded",dj_load_init,null);
-}
-window.addEventListener("load",dj_load_init,null);
-}
-if(dojo.render.html.ie&&dojo.render.os.win){
-document.attachEvent("onreadystatechange",function(e){
-if(document.readyState=="complete"){
-dj_load_init();
-}
 });
-}
-if(/(WebKit|khtml)/i.test(navigator.userAgent)){
-var _timer=setInterval(function(){
-if(/loaded|complete/.test(document.readyState)){
-dj_load_init();
-}
-},10);
-}
-if(dojo.render.html.ie){
-dj_addNodeEvtHdlr(window,"beforeunload",function(){
-dojo.hostenv._unloading=true;
-window.setTimeout(function(){
-dojo.hostenv._unloading=false;
-},0);
-});
-}
 dj_addNodeEvtHdlr(window,"unload",function(){
 dojo.hostenv.unloaded();
-if((!dojo.render.html.ie)||(dojo.render.html.ie&&dojo.hostenv._unloading)){
-dojo.hostenv.unloaded();
-}
 });
 dojo.hostenv.makeWidgets=function(){
-var _d3=[];
+var _8b=[];
 if(djConfig.searchIds&&djConfig.searchIds.length>0){
-_d3=_d3.concat(djConfig.searchIds);
+_8b=_8b.concat(djConfig.searchIds);
 }
 if(dojo.hostenv.searchIds&&dojo.hostenv.searchIds.length>0){
-_d3=_d3.concat(dojo.hostenv.searchIds);
+_8b=_8b.concat(dojo.hostenv.searchIds);
 }
-if((djConfig.parseWidgets)||(_d3.length>0)){
+if((djConfig.parseWidgets)||(_8b.length>0)){
 if(dojo.evalObjPath("dojo.widget.Parse")){
-var _d4=new dojo.xml.Parse();
-if(_d3.length>0){
-for(var x=0;x<_d3.length;x++){
-var _d6=document.getElementById(_d3[x]);
-if(!_d6){
+var _8c=new dojo.xml.Parse();
+if(_8b.length>0){
+for(var x=0;x<_8b.length;x++){
+var _8e=document.getElementById(_8b[x]);
+if(!_8e){
 continue;
 }
-var _d7=_d4.parseElement(_d6,null,true);
-dojo.widget.getParser().createComponents(_d7);
+var _8f=_8c.parseElement(_8e,null,true);
+dojo.widget.getParser().createComponents(_8f);
 }
 }else{
 if(djConfig.parseWidgets){
-var _d7=_d4.parseElement(dojo.body(),null,true);
-dojo.widget.getParser().createComponents(_d7);
+var _8f=_8c.parseElement(document.getElementsByTagName("body")[0]||document.body,null,true);
+dojo.widget.getParser().createComponents(_8f);
 }
 }
 }
@@ -923,89 +684,119 @@
 });
 try{
 if(dojo.render.html.ie){
-document.namespaces.add("v","urn:schemas-microsoft-com:vml");
-document.createStyleSheet().addRule("v\\:*","behavior:url(#default#VML)");
+document.write("<style>v:*{ behavior:url(#default#VML); }</style>");
+document.write("<xml:namespace ns=\"urn:schemas-microsoft-com:vml\" prefix=\"v\"/>");
 }
 }
 catch(e){
 }
 dojo.hostenv.writeIncludes=function(){
 };
-if(!dj_undef("document",this)){
-dj_currentDocument=this.document;
-}
-dojo.doc=function(){
-return dj_currentDocument;
-};
-dojo.body=function(){
-return dojo.doc().body||dojo.doc().getElementsByTagName("body")[0];
-};
 dojo.byId=function(id,doc){
-if((id)&&((typeof id=="string")||(id instanceof String))){
+if(id&&(typeof id=="string"||id instanceof String)){
 if(!doc){
-doc=dj_currentDocument;
+doc=document;
 }
-var ele=doc.getElementById(id);
-if(ele&&(ele.id!=id)&&doc.all){
-ele=null;
-eles=doc.all[id];
-if(eles){
-if(eles.length){
-for(var i=0;i<eles.length;i++){
-if(eles[i].id==id){
-ele=eles[i];
-break;
+return doc.getElementById(id);
 }
+return id;
+};
+(function(){
+if(typeof dj_usingBootstrap!="undefined"){
+return;
 }
+var _92=false;
+var _93=false;
+var _94=false;
+if((typeof this["load"]=="function")&&((typeof this["Packages"]=="function")||(typeof this["Packages"]=="object"))){
+_92=true;
 }else{
-ele=eles;
+if(typeof this["load"]=="function"){
+_93=true;
+}else{
+if(window.widget){
+_94=true;
 }
 }
 }
-return ele;
+var _95=[];
+if((this["djConfig"])&&((djConfig["isDebug"])||(djConfig["debugAtAllCosts"]))){
+_95.push("debug.js");
 }
-return id;
-};
-dojo.setContext=function(_dc,_dd){
-dj_currentContext=_dc;
-dj_currentDocument=_dd;
-};
-dojo._fireCallback=function(_de,_df,_e0){
-if((_df)&&((typeof _de=="string")||(_de instanceof String))){
-_de=_df[_de];
+if((this["djConfig"])&&(djConfig["debugAtAllCosts"])&&(!_92)&&(!_94)){
+_95.push("browser_debug.js");
 }
-return (_df?_de.apply(_df,_e0||[]):_de());
-};
-dojo.withGlobal=function(_e1,_e2,_e3,_e4){
-var _e5;
-var _e6=dj_currentContext;
-var _e7=dj_currentDocument;
-try{
-dojo.setContext(_e1,_e1.document);
-_e5=dojo._fireCallback(_e2,_e3,_e4);
+if((this["djConfig"])&&(djConfig["compat"])){
+_95.push("compat/"+djConfig["compat"]+".js");
 }
-finally{
-dojo.setContext(_e6,_e7);
+var _96=djConfig["baseScriptUri"];
+if((this["djConfig"])&&(djConfig["baseLoaderUri"])){
+_96=djConfig["baseLoaderUri"];
 }
-return _e5;
-};
-dojo.withDoc=function(_e8,_e9,_ea,_eb){
-var _ec;
-var _ed=dj_currentDocument;
+for(var x=0;x<_95.length;x++){
+var _98=_96+"src/"+_95[x];
+if(_92||_93){
+load(_98);
+}else{
 try{
-dj_currentDocument=_e8;
-_ec=dojo._fireCallback(_e9,_ea,_eb);
+document.write("<scr"+"ipt type='text/javascript' src='"+_98+"'></scr"+"ipt>");
 }
-finally{
-dj_currentDocument=_ed;
+catch(e){
+var _99=document.createElement("script");
+_99.src=_98;
+document.getElementsByTagName("head")[0].appendChild(_99);
 }
-return _ec;
+}
+}
+})();
+dojo.fallback_locale="en";
+dojo.normalizeLocale=function(_9a){
+return _9a?_9a.toLowerCase():dojo.locale;
 };
+dojo.requireLocalization=function(_9b,_9c,_9d){
+dojo.debug("EXPERIMENTAL: dojo.requireLocalization");
+var _9e=dojo.hostenv.getModuleSymbols(_9b);
+var _9f=_9e.concat("nls").join("/");
+_9d=dojo.normalizeLocale(_9d);
+var _a0=_9d.split("-");
+var _a1=[];
+for(var i=_a0.length;i>0;i--){
+_a1.push(_a0.slice(0,i).join("-"));
 }
-dojo.requireIf((djConfig["isDebug"]||djConfig["debugAtAllCosts"]),"dojo.debug");
-dojo.requireIf(djConfig["debugAtAllCosts"]&&!window.widget&&!djConfig["useXDomain"],"dojo.browser_debug");
-dojo.requireIf(djConfig["debugAtAllCosts"]&&!window.widget&&djConfig["useXDomain"],"dojo.browser_debug_xd");
+if(_a1[_a1.length-1]!=dojo.fallback_locale){
+_a1.push(dojo.fallback_locale);
+}
+var _a3=[_9b,"_nls",_9c].join(".");
+var _a4=dojo.hostenv.startPackage(_a3);
+dojo.hostenv.loaded_modules_[_a3]=_a4;
+var _a5=false;
+for(var i=_a1.length-1;i>=0;i--){
+var loc=_a1[i];
+var pkg=[_a3,loc].join(".");
+var _a8=false;
+if(!dojo.hostenv.findModule(pkg)){
+dojo.hostenv.loaded_modules_[pkg]=null;
+var _a9=[_9f,loc,_9c].join("/")+".js";
+_a8=dojo.hostenv.loadPath(_a9,null,function(_aa){
+_a4[loc]=_aa;
+if(_a5){
+for(var x in _a5){
+if(!_a4[loc][x]){
+_a4[loc][x]=_a5[x];
+}
+}
+}
+});
+}else{
+_a8=true;
+}
+if(_a8&&_a4[loc]){
+_a5=_a4[loc];
+}
+}
+};
 dojo.provide("dojo.string.common");
+dojo.require("dojo.string");
 dojo.string.trim=function(str,wh){
 if(!str.replace){
 return str;
@@ -1022,12 +813,12 @@
 dojo.string.trimEnd=function(str){
 return dojo.string.trim(str,-1);
 };
-dojo.string.repeat=function(str,_f4,_f5){
+dojo.string.repeat=function(str,_b2,_b3){
 var out="";
-for(var i=0;i<_f4;i++){
+for(var i=0;i<_b2;i++){
 out+=str;
-if(_f5&&i<_f4-1){
-out+=_f5;
+if(_b3&&i<_b2-1){
+out+=_b3;
 }
 }
 return out;
@@ -1056,205 +847,164 @@
 return dojo.string.pad(str,len,c,-1);
 };
 dojo.provide("dojo.string");
+dojo.require("dojo.string.common");
 dojo.provide("dojo.lang.common");
-dojo.lang.inherits=function(_103,_104){
-if(!dojo.lang.isFunction(_104)){
-dojo.raise("dojo.inherits: superclass argument ["+_104+"] must be a function (subclass: ["+_103+"']");
+dojo.require("dojo.lang");
+dojo.lang._mixin=function(obj,_c2){
+var _c3={};
+for(var x in _c2){
+if(typeof _c3[x]=="undefined"||_c3[x]!=_c2[x]){
+obj[x]=_c2[x];
 }
-_103.prototype=new _104();
-_103.prototype.constructor=_103;
-_103.superclass=_104.prototype;
-_103["super"]=_104.prototype;
-};
-dojo.lang._mixin=function(obj,_106){
-var tobj={};
-for(var x in _106){
-if((typeof tobj[x]=="undefined")||(tobj[x]!=_106[x])){
-obj[x]=_106[x];
 }
+if(dojo.render.html.ie&&dojo.lang.isFunction(_c2["toString"])&&_c2["toString"]!=obj["toString"]){
+obj.toString=_c2.toString;
 }
-if(dojo.render.html.ie&&(typeof (_106["toString"])=="function")&&(_106["toString"]!=obj["toString"])&&(_106["toString"]!=tobj["toString"])){
-obj.toString=_106.toString;
-}
 return obj;
 };
-dojo.lang.mixin=function(obj,_10a){
+dojo.lang.mixin=function(obj,_c6){
 for(var i=1,l=arguments.length;i<l;i++){
 dojo.lang._mixin(obj,arguments[i]);
 }
 return obj;
 };
-dojo.lang.extend=function(_10d,_10e){
+dojo.lang.extend=function(_c8,_c9){
 for(var i=1,l=arguments.length;i<l;i++){
-dojo.lang._mixin(_10d.prototype,arguments[i]);
+dojo.lang._mixin(_c8.prototype,arguments[i]);
 }
-return _10d;
+return _c8;
 };
-dojo.inherits=dojo.lang.inherits;
-dojo.mixin=dojo.lang.mixin;
-dojo.extend=dojo.lang.extend;
-dojo.lang.find=function(_111,_112,_113,_114){
-if(!dojo.lang.isArrayLike(_111)&&dojo.lang.isArrayLike(_112)){
-dojo.deprecated("dojo.lang.find(value, array)","use dojo.lang.find(array, value) instead","0.5");
-var temp=_111;
-_111=_112;
-_112=temp;
+dojo.lang.find=function(arr,val,_cd,_ce){
+if(!dojo.lang.isArrayLike(arr)&&dojo.lang.isArrayLike(val)){
+var a=arr;
+arr=val;
+val=a;
 }
-var _116=dojo.lang.isString(_111);
-if(_116){
-_111=_111.split("");
+var _d0=dojo.lang.isString(arr);
+if(_d0){
+arr=arr.split("");
 }
-if(_114){
-var step=-1;
-var i=_111.length-1;
+if(_ce){
+var _d1=-1;
+var i=arr.length-1;
 var end=-1;
 }else{
-var step=1;
+var _d1=1;
 var i=0;
-var end=_111.length;
+var end=arr.length;
 }
-if(_113){
+if(_cd){
 while(i!=end){
-if(_111[i]===_112){
+if(arr[i]===val){
 return i;
 }
-i+=step;
+i+=_d1;
 }
 }else{
 while(i!=end){
-if(_111[i]==_112){
+if(arr[i]==val){
 return i;
 }
-i+=step;
+i+=_d1;
 }
 }
 return -1;
 };
 dojo.lang.indexOf=dojo.lang.find;
-dojo.lang.findLast=function(_11a,_11b,_11c){
-return dojo.lang.find(_11a,_11b,_11c,true);
+dojo.lang.findLast=function(arr,val,_d6){
+return dojo.lang.find(arr,val,_d6,true);
 };
 dojo.lang.lastIndexOf=dojo.lang.findLast;
-dojo.lang.inArray=function(_11d,_11e){
-return dojo.lang.find(_11d,_11e)>-1;
+dojo.lang.inArray=function(arr,val){
+return dojo.lang.find(arr,val)>-1;
 };
-dojo.lang.isObject=function(it){
-if(typeof it=="undefined"){
+dojo.lang.isObject=function(wh){
+if(typeof wh=="undefined"){
 return false;
 }
-return (typeof it=="object"||it===null||dojo.lang.isArray(it)||dojo.lang.isFunction(it));
+return (typeof wh=="object"||wh===null||dojo.lang.isArray(wh)||dojo.lang.isFunction(wh));
 };
-dojo.lang.isArray=function(it){
-return (it&&it instanceof Array||typeof it=="array");
+dojo.lang.isArray=function(wh){
+return (wh instanceof Array||typeof wh=="array");
 };
-dojo.lang.isArrayLike=function(it){
-if((!it)||(dojo.lang.isUndefined(it))){
+dojo.lang.isArrayLike=function(wh){
+if(dojo.lang.isString(wh)){
 return false;
 }
-if(dojo.lang.isString(it)){
+if(dojo.lang.isFunction(wh)){
 return false;
 }
-if(dojo.lang.isFunction(it)){
-return false;
-}
-if(dojo.lang.isArray(it)){
+if(dojo.lang.isArray(wh)){
 return true;
 }
-if((it.tagName)&&(it.tagName.toLowerCase()=="form")){
-return false;
-}
-if(dojo.lang.isNumber(it.length)&&isFinite(it.length)){
+if(typeof wh!="undefined"&&wh&&dojo.lang.isNumber(wh.length)&&isFinite(wh.length)){
 return true;
 }
 return false;
 };
-dojo.lang.isFunction=function(it){
-return (it instanceof Function||typeof it=="function");
-};
-(function(){
-if((dojo.render.html.capable)&&(dojo.render.html["safari"])){
-dojo.lang.isFunction=function(it){
-if((typeof (it)=="function")&&(it=="[object NodeList]")){
+dojo.lang.isFunction=function(wh){
+if(!wh){
 return false;
 }
-return (it instanceof Function||typeof it=="function");
+return (wh instanceof Function||typeof wh=="function");
 };
-}
-})();
-dojo.lang.isString=function(it){
-return (typeof it=="string"||it instanceof String);
+dojo.lang.isString=function(wh){
+return (wh instanceof String||typeof wh=="string");
 };
-dojo.lang.isAlien=function(it){
-if(!it){
+dojo.lang.isAlien=function(wh){
+if(!wh){
 return false;
 }
-return !dojo.lang.isFunction(it)&&/\{\s*\[native code\]\s*\}/.test(String(it));
+return !dojo.lang.isFunction()&&/\{\s*\[native code\]\s*\}/.test(String(wh));
 };
-dojo.lang.isBoolean=function(it){
-return (it instanceof Boolean||typeof it=="boolean");
+dojo.lang.isBoolean=function(wh){
+return (wh instanceof Boolean||typeof wh=="boolean");
 };
-dojo.lang.isNumber=function(it){
-return (it instanceof Number||typeof it=="number");
+dojo.lang.isNumber=function(wh){
+return (wh instanceof Number||typeof wh=="number");
 };
-dojo.lang.isUndefined=function(it){
-return ((typeof (it)=="undefined")&&(it==undefined));
+dojo.lang.isUndefined=function(wh){
+return ((wh==undefined)&&(typeof wh=="undefined"));
 };
 dojo.provide("dojo.lang.extras");
-dojo.lang.setTimeout=function(func,_12a){
-var _12b=window,_12c=2;
-if(!dojo.lang.isFunction(func)){
-_12b=func;
-func=_12a;
-_12a=arguments[2];
-_12c++;
+dojo.require("dojo.lang.common");
+dojo.lang.setTimeout=function(_e2,_e3){
+var _e4=window,argsStart=2;
+if(!dojo.lang.isFunction(_e2)){
+_e4=_e2;
+_e2=_e3;
+_e3=arguments[2];
+argsStart++;
 }
-if(dojo.lang.isString(func)){
-func=_12b[func];
+if(dojo.lang.isString(_e2)){
+_e2=_e4[_e2];
 }
-var args=[];
-for(var i=_12c;i<arguments.length;i++){
-args.push(arguments[i]);
+var _e5=[];
+for(var i=argsStart;i<arguments.length;i++){
+_e5.push(arguments[i]);
 }
-return dojo.global().setTimeout(function(){
-func.apply(_12b,args);
-},_12a);
+return setTimeout(function(){
+_e2.apply(_e4,_e5);
+},_e3);
 };
-dojo.lang.clearTimeout=function(_12f){
-dojo.global().clearTimeout(_12f);
-};
-dojo.lang.getNameInObj=function(ns,item){
+dojo.lang.getNameInObj=function(ns,_e8){
 if(!ns){
 ns=dj_global;
 }
 for(var x in ns){
-if(ns[x]===item){
+if(ns[x]===_e8){
 return new String(x);
 }
 }
 return null;
 };
-dojo.lang.shallowCopy=function(obj,deep){
-var i,ret;
-if(obj===null){
-return null;
+dojo.lang.shallowCopy=function(obj){
+var ret={},key;
+for(key in obj){
+if(dojo.lang.isUndefined(ret[key])){
+ret[key]=obj[key];
 }
-if(dojo.lang.isObject(obj)){
-ret=new obj.constructor();
-for(i in obj){
-if(dojo.lang.isUndefined(ret[i])){
-ret[i]=deep?dojo.lang.shallowCopy(obj[i],deep):obj[i];
 }
-}
-}else{
-if(dojo.lang.isArray(obj)){
-ret=[];
-for(i=0;i<obj.length;i++){
-ret[i]=deep?dojo.lang.shallowCopy(obj[i],deep):obj[i];
-}
-}else{
-ret=obj;
-}
-}
 return ret;
 };
 dojo.lang.firstValued=function(){
@@ -1265,90 +1015,79 @@
 }
 return undefined;
 };
-dojo.lang.getObjPathValue=function(_138,_139,_13a){
-with(dojo.parseObjPath(_138,_139,_13a)){
-return dojo.evalProp(prop,obj,_13a);
+dojo.lang.getObjPathValue=function(_ed,_ee,_ef){
+with(dojo.parseObjPath(_ed,_ee,_ef)){
+return dojo.evalProp(prop,obj,_ef);
 }
 };
-dojo.lang.setObjPathValue=function(_13b,_13c,_13d,_13e){
-dojo.deprecated("dojo.lang.setObjPathValue","use dojo.parseObjPath and the '=' operator","0.6");
+dojo.lang.setObjPathValue=function(_f0,_f1,_f2,_f3){
 if(arguments.length<4){
-_13e=true;
+_f3=true;
 }
-with(dojo.parseObjPath(_13b,_13d,_13e)){
-if(obj&&(_13e||(prop in obj))){
-obj[prop]=_13c;
+with(dojo.parseObjPath(_f0,_f2,_f3)){
+if(obj&&(_f3||(prop in obj))){
+obj[prop]=_f1;
 }
 }
 };
-dojo.provide("dojo.io.common");
+dojo.provide("dojo.io.IO");
+dojo.require("dojo.string");
+dojo.require("dojo.lang.extras");
 dojo.io.transports=[];
 dojo.io.hdlrFuncNames=["load","error","timeout"];
-dojo.io.Request=function(url,_140,_141,_142){
+dojo.io.Request=function(url,_f5,_f6,_f7){
 if((arguments.length==1)&&(arguments[0].constructor==Object)){
 this.fromKwArgs(arguments[0]);
 }else{
 this.url=url;
-if(_140){
-this.mimetype=_140;
+if(_f5){
+this.mimetype=_f5;
 }
-if(_141){
-this.transport=_141;
+if(_f6){
+this.transport=_f6;
 }
 if(arguments.length>=4){
-this.changeUrl=_142;
+this.changeUrl=_f7;
 }
 }
 };
-dojo.lang.extend(dojo.io.Request,{url:"",mimetype:"text/plain",method:"GET",content:undefined,transport:undefined,changeUrl:undefined,formNode:undefined,sync:false,bindSuccess:false,useCache:false,preventCache:false,jsonFilter:function(_143){
-if((this.mimetype=="text/json-comment-filtered")||(this.mimetype=="application/json-comment-filtered")){
-var _144=_143.indexOf("/*");
-var _145=_143.lastIndexOf("*/");
-if((_144==-1)||(_145==-1)){
-dojo.debug("your JSON wasn't comment filtered!");
-return "";
-}
-return _143.substring(_144+2,_145);
-}
-dojo.debug("please consider using a mimetype of text/json-comment-filtered to avoid potential security issues with JSON endpoints");
-return _143;
-},load:function(type,data,_148,_149){
-},error:function(type,_14b,_14c,_14d){
-},timeout:function(type,_14f,_150,_151){
-},handle:function(type,data,_154,_155){
+dojo.lang.extend(dojo.io.Request,{url:"",mimetype:"text/plain",method:"GET",content:undefined,transport:undefined,changeUrl:undefined,formNode:undefined,sync:false,bindSuccess:false,useCache:false,preventCache:false,load:function(_f8,_f9,evt){
+},error:function(_fb,_fc){
+},timeout:function(_fd){
+},handle:function(){
 },timeoutSeconds:0,abort:function(){
-},fromKwArgs:function(_156){
-if(_156["url"]){
-_156.url=_156.url.toString();
+},fromKwArgs:function(_fe){
+if(_fe["url"]){
+_fe.url=_fe.url.toString();
 }
-if(_156["formNode"]){
-_156.formNode=dojo.byId(_156.formNode);
+if(_fe["formNode"]){
+_fe.formNode=dojo.byId(_fe.formNode);
 }
-if(!_156["method"]&&_156["formNode"]&&_156["formNode"].method){
-_156.method=_156["formNode"].method;
+if(!_fe["method"]&&_fe["formNode"]&&_fe["formNode"].method){
+_fe.method=_fe["formNode"].method;
 }
-if(!_156["handle"]&&_156["handler"]){
-_156.handle=_156.handler;
+if(!_fe["handle"]&&_fe["handler"]){
+_fe.handle=_fe.handler;
 }
-if(!_156["load"]&&_156["loaded"]){
-_156.load=_156.loaded;
+if(!_fe["load"]&&_fe["loaded"]){
+_fe.load=_fe.loaded;
 }
-if(!_156["changeUrl"]&&_156["changeURL"]){
-_156.changeUrl=_156.changeURL;
+if(!_fe["changeUrl"]&&_fe["changeURL"]){
+_fe.changeUrl=_fe.changeURL;
 }
-_156.encoding=dojo.lang.firstValued(_156["encoding"],djConfig["bindEncoding"],"");
-_156.sendTransport=dojo.lang.firstValued(_156["sendTransport"],djConfig["ioSendTransport"],false);
-var _157=dojo.lang.isFunction;
+_fe.encoding=dojo.lang.firstValued(_fe["encoding"],djConfig["bindEncoding"],"");
+_fe.sendTransport=dojo.lang.firstValued(_fe["sendTransport"],djConfig["ioSendTransport"],false);
+var _ff=dojo.lang.isFunction;
 for(var x=0;x<dojo.io.hdlrFuncNames.length;x++){
 var fn=dojo.io.hdlrFuncNames[x];
-if(_156[fn]&&_157(_156[fn])){
+if(_ff(_fe[fn])){
 continue;
 }
-if(_156["handle"]&&_157(_156["handle"])){
-_156[fn]=_156.handle;
+if(_ff(_fe["handle"])){
+_fe[fn]=_fe.handle;
 }
 }
-dojo.lang.mixin(this,_156);
+dojo.lang.mixin(this,_fe);
 }});
 dojo.io.Error=function(msg,type,num){
 this.message=msg;
@@ -1359,79 +1098,62 @@
 this.push(name);
 this[name]=dojo.io[name];
 };
-dojo.io.bind=function(_15e){
-if(!(_15e instanceof dojo.io.Request)){
+dojo.io.bind=function(_106){
+if(!(_106 instanceof dojo.io.Request)){
 try{
-_15e=new dojo.io.Request(_15e);
+_106=new dojo.io.Request(_106);
 }
 catch(e){
 dojo.debug(e);
 }
 }
-var _15f="";
-if(_15e["transport"]){
-_15f=_15e["transport"];
-if(!this[_15f]){
-dojo.io.sendBindError(_15e,"No dojo.io.bind() transport with name '"+_15e["transport"]+"'.");
-return _15e;
+var _107="";
+if(_106["transport"]){
+_107=_106["transport"];
+if(!this[_107]){
+return _106;
 }
-if(!this[_15f].canHandle(_15e)){
-dojo.io.sendBindError(_15e,"dojo.io.bind() transport with name '"+_15e["transport"]+"' cannot handle this type of request.");
-return _15e;
-}
 }else{
 for(var x=0;x<dojo.io.transports.length;x++){
 var tmp=dojo.io.transports[x];
-if((this[tmp])&&(this[tmp].canHandle(_15e))){
-_15f=tmp;
-break;
+if((this[tmp])&&(this[tmp].canHandle(_106))){
+_107=tmp;
 }
 }
-if(_15f==""){
-dojo.io.sendBindError(_15e,"None of the loaded transports for dojo.io.bind()"+" can handle the request.");
-return _15e;
+if(_107==""){
+return _106;
 }
 }
-this[_15f].bind(_15e);
-_15e.bindSuccess=true;
-return _15e;
+this[_107].bind(_106);
+_106.bindSuccess=true;
+return _106;
 };
-dojo.io.sendBindError=function(_162,_163){
-if((typeof _162.error=="function"||typeof _162.handle=="function")&&(typeof setTimeout=="function"||typeof setTimeout=="object")){
-var _164=new dojo.io.Error(_163);
-setTimeout(function(){
-_162[(typeof _162.error=="function")?"error":"handle"]("error",_164,null,_162);
-},50);
-}else{
-dojo.raise(_163);
-}
-};
-dojo.io.queueBind=function(_165){
-if(!(_165 instanceof dojo.io.Request)){
+dojo.io.queueBind=function(_10a){
+if(!(_10a instanceof dojo.io.Request)){
 try{
-_165=new dojo.io.Request(_165);
+_10a=new dojo.io.Request(_10a);
 }
 catch(e){
 dojo.debug(e);
 }
 }
-var _166=_165.load;
-_165.load=function(){
+var _10b=_10a.load;
+_10a.load=function(){
 dojo.io._queueBindInFlight=false;
-var ret=_166.apply(this,arguments);
+var ret=_10b.apply(this,arguments);
 dojo.io._dispatchNextQueueBind();
 return ret;
 };
-var _168=_165.error;
-_165.error=function(){
+var _10d=_10a.error;
+_10a.error=function(){
 dojo.io._queueBindInFlight=false;
-var ret=_168.apply(this,arguments);
+var ret=_10d.apply(this,arguments);
 dojo.io._dispatchNextQueueBind();
 return ret;
 };
-dojo.io._bindQueue.push(_165);
+dojo.io._bindQueue.push(_10a);
 dojo.io._dispatchNextQueueBind();
-return _165;
+return _10a;
 };
 dojo.io._dispatchNextQueueBind=function(){
 if(!dojo.io._queueBindInFlight){
@@ -1445,48 +1167,48 @@
 };
 dojo.io._bindQueue=[];
 dojo.io._queueBindInFlight=false;
-dojo.io.argsFromMap=function(map,_16b,last){
-var enc=/utf/i.test(_16b||"")?encodeURIComponent:dojo.string.encodeAscii;
-var _16e=[];
-var _16f=new Object();
+dojo.io.argsFromMap=function(map,_110,last){
+var enc=/utf/i.test(_110||"")?encodeURIComponent:dojo.string.encodeAscii;
+var _113=[];
+var _114=new Object();
 for(var name in map){
-var _171=function(elt){
+var _116=function(elt){
 var val=enc(name)+"="+enc(elt);
-_16e[(last==name)?"push":"unshift"](val);
+_113[(last==name)?"push":"unshift"](val);
 };
-if(!_16f[name]){
-var _174=map[name];
-if(dojo.lang.isArray(_174)){
-dojo.lang.forEach(_174,_171);
+if(!_114[name]){
+var _119=map[name];
+if(dojo.lang.isArray(_119)){
+dojo.lang.forEach(_119,_116);
 }else{
-_171(_174);
+_116(_119);
 }
 }
 }
-return _16e.join("&");
+return _113.join("&");
 };
-dojo.io.setIFrameSrc=function(_175,src,_177){
+dojo.io.setIFrameSrc=function(_11a,src,_11c){
 try{
 var r=dojo.render.html;
-if(!_177){
+if(!_11c){
 if(r.safari){
-_175.location=src;
+_11a.location=src;
 }else{
-frames[_175.name].location=src;
+frames[_11a.name].location=src;
 }
 }else{
 var idoc;
 if(r.ie){
-idoc=_175.contentWindow.document;
+idoc=_11a.contentWindow.document;
 }else{
 if(r.safari){
-idoc=_175.document;
+idoc=_11a.document;
 }else{
-idoc=_175.contentWindow;
+idoc=_11a.contentWindow;
 }
 }
 if(!idoc){
-_175.location=src;
+_11a.location=src;
 return;
 }else{
 idoc.location.replace(src);
@@ -1499,150 +1221,133 @@
 }
 };
 dojo.provide("dojo.lang.array");
-dojo.lang.mixin(dojo.lang,{has:function(obj,name){
+dojo.require("dojo.lang.common");
+dojo.lang.has=function(obj,name){
 try{
-return typeof obj[name]!="undefined";
+return (typeof obj[name]!="undefined");
 }
 catch(e){
 return false;
 }
-},isEmpty:function(obj){
+};
+dojo.lang.isEmpty=function(obj){
 if(dojo.lang.isObject(obj)){
 var tmp={};
-var _17e=0;
+var _123=0;
 for(var x in obj){
 if(obj[x]&&(!tmp[x])){
-_17e++;
+_123++;
 break;
 }
 }
-return _17e==0;
+return (_123==0);
 }else{
 if(dojo.lang.isArrayLike(obj)||dojo.lang.isString(obj)){
 return obj.length==0;
 }
 }
-},map:function(arr,obj,_182){
-var _183=dojo.lang.isString(arr);
-if(_183){
+};
+dojo.lang.map=function(arr,obj,_127){
+var _128=dojo.lang.isString(arr);
+if(_128){
 arr=arr.split("");
 }
-if(dojo.lang.isFunction(obj)&&(!_182)){
-_182=obj;
+if(dojo.lang.isFunction(obj)&&(!_127)){
+_127=obj;
 obj=dj_global;
 }else{
-if(dojo.lang.isFunction(obj)&&_182){
-var _184=obj;
-obj=_182;
-_182=_184;
+if(dojo.lang.isFunction(obj)&&_127){
+var _129=obj;
+obj=_127;
+_127=_129;
 }
 }
 if(Array.map){
-var _185=Array.map(arr,_182,obj);
+var _12a=Array.map(arr,_127,obj);
 }else{
-var _185=[];
+var _12a=[];
 for(var i=0;i<arr.length;++i){
-_185.push(_182.call(obj,arr[i]));
+_12a.push(_127.call(obj,arr[i]));
 }
 }
-if(_183){
-return _185.join("");
+if(_128){
+return _12a.join("");
 }else{
-return _185;
+return _12a;
 }
-},reduce:function(arr,_188,obj,_18a){
-var _18b=_188;
-if(arguments.length==2){
-_18a=_188;
-_18b=arr[0];
-arr=arr.slice(1);
-}else{
-if(arguments.length==3){
-if(dojo.lang.isFunction(obj)){
-_18a=obj;
-obj=null;
+};
+dojo.lang.forEach=function(_12c,_12d,_12e){
+if(dojo.lang.isString(_12c)){
+_12c=_12c.split("");
 }
-}else{
-if(dojo.lang.isFunction(obj)){
-var tmp=_18a;
-_18a=obj;
-obj=tmp;
-}
-}
-}
-var ob=obj||dj_global;
-dojo.lang.map(arr,function(val){
-_18b=_18a.call(ob,_18b,val);
-});
-return _18b;
-},forEach:function(_18f,_190,_191){
-if(dojo.lang.isString(_18f)){
-_18f=_18f.split("");
-}
 if(Array.forEach){
-Array.forEach(_18f,_190,_191);
+Array.forEach(_12c,_12d,_12e);
 }else{
-if(!_191){
-_191=dj_global;
+if(!_12e){
+_12e=dj_global;
 }
-for(var i=0,l=_18f.length;i<l;i++){
-_190.call(_191,_18f[i],i,_18f);
+for(var i=0,l=_12c.length;i<l;i++){
+_12d.call(_12e,_12c[i],i,_12c);
 }
 }
-},_everyOrSome:function(_194,arr,_196,_197){
+};
+dojo.lang._everyOrSome=function(_130,arr,_132,_133){
 if(dojo.lang.isString(arr)){
 arr=arr.split("");
 }
 if(Array.every){
-return Array[_194?"every":"some"](arr,_196,_197);
+return Array[(_130)?"every":"some"](arr,_132,_133);
 }else{
-if(!_197){
-_197=dj_global;
+if(!_133){
+_133=dj_global;
 }
 for(var i=0,l=arr.length;i<l;i++){
-var _19a=_196.call(_197,arr[i],i,arr);
-if(_194&&!_19a){
+var _135=_132.call(_133,arr[i],i,arr);
+if((_130)&&(!_135)){
 return false;
 }else{
-if((!_194)&&(_19a)){
+if((!_130)&&(_135)){
 return true;
 }
 }
 }
-return Boolean(_194);
+return (_130)?true:false;
 }
-},every:function(arr,_19c,_19d){
-return this._everyOrSome(true,arr,_19c,_19d);
-},some:function(arr,_19f,_1a0){
-return this._everyOrSome(false,arr,_19f,_1a0);
-},filter:function(arr,_1a2,_1a3){
-var _1a4=dojo.lang.isString(arr);
-if(_1a4){
+};
+dojo.lang.every=function(arr,_137,_138){
+return this._everyOrSome(true,arr,_137,_138);
+};
+dojo.lang.some=function(arr,_13a,_13b){
+return this._everyOrSome(false,arr,_13a,_13b);
+};
+dojo.lang.filter=function(arr,_13d,_13e){
+var _13f=dojo.lang.isString(arr);
+if(_13f){
 arr=arr.split("");
 }
-var _1a5;
 if(Array.filter){
-_1a5=Array.filter(arr,_1a2,_1a3);
+var _140=Array.filter(arr,_13d,_13e);
 }else{
-if(!_1a3){
+if(!_13e){
 if(arguments.length>=3){
 dojo.raise("thisObject doesn't exist!");
 }
-_1a3=dj_global;
+_13e=dj_global;
 }
-_1a5=[];
+var _140=[];
 for(var i=0;i<arr.length;i++){
-if(_1a2.call(_1a3,arr[i],i,arr)){
-_1a5.push(arr[i]);
+if(_13d.call(_13e,arr[i],i,arr)){
+_140.push(arr[i]);
 }
 }
 }
-if(_1a4){
-return _1a5.join("");
+if(_13f){
+return _140.join("");
 }else{
-return _1a5;
+return _140;
 }
-},unnest:function(){
+};
+dojo.lang.unnest=function(){
 var out=[];
 for(var i=0;i<arguments.length;i++){
 if(dojo.lang.isArrayLike(arguments[i])){
@@ -1653,92 +1358,85 @@
 }
 }
 return out;
-},toArray:function(_1aa,_1ab){
-var _1ac=[];
-for(var i=_1ab||0;i<_1aa.length;i++){
-_1ac.push(_1aa[i]);
+};
+dojo.lang.toArray=function(_145,_146){
+var _147=[];
+for(var i=_146||0;i<_145.length;i++){
+_147.push(_145[i]);
 }
-return _1ac;
-}});
+return _147;
+};
 dojo.provide("dojo.lang.func");
-dojo.lang.hitch=function(_1ae,_1af){
-var args=[];
-for(var x=2;x<arguments.length;x++){
-args.push(arguments[x]);
+dojo.require("dojo.lang.common");
+dojo.lang.hitch=function(_149,_14a){
+if(dojo.lang.isString(_14a)){
+var fcn=_149[_14a];
+}else{
+var fcn=_14a;
 }
-var fcn=(dojo.lang.isString(_1af)?_1ae[_1af]:_1af)||function(){
-};
 return function(){
-var ta=args.concat([]);
-for(var x=0;x<arguments.length;x++){
-ta.push(arguments[x]);
-}
-return fcn.apply(_1ae,ta);
+return fcn.apply(_149,arguments);
 };
 };
 dojo.lang.anonCtr=0;
 dojo.lang.anon={};
-dojo.lang.nameAnonFunc=function(_1b5,_1b6,_1b7){
-var nso=(_1b6||dojo.lang.anon);
-if((_1b7)||((dj_global["djConfig"])&&(djConfig["slowAnonFuncLookups"]==true))){
+dojo.lang.nameAnonFunc=function(_14c,_14d,_14e){
+var nso=(_14d||dojo.lang.anon);
+if((_14e)||((dj_global["djConfig"])&&(djConfig["slowAnonFuncLookups"]==true))){
 for(var x in nso){
-try{
-if(nso[x]===_1b5){
+if(nso[x]===_14c){
 return x;
 }
 }
-catch(e){
 }
-}
-}
 var ret="__"+dojo.lang.anonCtr++;
 while(typeof nso[ret]!="undefined"){
 ret="__"+dojo.lang.anonCtr++;
 }
-nso[ret]=_1b5;
+nso[ret]=_14c;
 return ret;
 };
-dojo.lang.forward=function(_1bb){
+dojo.lang.forward=function(_152){
 return function(){
-return this[_1bb].apply(this,arguments);
+return this[_152].apply(this,arguments);
 };
 };
-dojo.lang.curry=function(_1bc,func){
-var _1be=[];
-_1bc=_1bc||dj_global;
+dojo.lang.curry=function(ns,func){
+var _155=[];
+ns=ns||dj_global;
 if(dojo.lang.isString(func)){
-func=_1bc[func];
+func=ns[func];
 }
 for(var x=2;x<arguments.length;x++){
-_1be.push(arguments[x]);
+_155.push(arguments[x]);
 }
-var _1c0=(func["__preJoinArity"]||func.length)-_1be.length;
-function gather(_1c1,_1c2,_1c3){
-var _1c4=_1c3;
-var _1c5=_1c2.slice(0);
-for(var x=0;x<_1c1.length;x++){
-_1c5.push(_1c1[x]);
+var _157=(func["__preJoinArity"]||func.length)-_155.length;
+function gather(_158,_159,_15a){
+var _15b=_15a;
+var _15c=_159.slice(0);
+for(var x=0;x<_158.length;x++){
+_15c.push(_158[x]);
 }
-_1c3=_1c3-_1c1.length;
-if(_1c3<=0){
-var res=func.apply(_1bc,_1c5);
-_1c3=_1c4;
+_15a=_15a-_158.length;
+if(_15a<=0){
+var res=func.apply(ns,_15c);
+_15a=_15b;
 return res;
 }else{
 return function(){
-return gather(arguments,_1c5,_1c3);
+return gather(arguments,_15c,_15a);
 };
 }
 }
-return gather([],_1be,_1c0);
+return gather([],_155,_157);
 };
-dojo.lang.curryArguments=function(_1c8,func,args,_1cb){
-var _1cc=[];
-var x=_1cb||0;
-for(x=_1cb;x<args.length;x++){
-_1cc.push(args[x]);
+dojo.lang.curryArguments=function(ns,func,args,_162){
+var _163=[];
+var x=_162||0;
+for(x=_162;x<args.length;x++){
+_163.push(args[x]);
 }
-return dojo.lang.curry.apply(dojo.lang,[_1c8,func].concat(_1cc));
+return dojo.lang.curry.apply(dojo.lang,[ns,func].concat(_163));
 };
 dojo.lang.tryThese=function(){
 for(var x=0;x<arguments.length;x++){
@@ -1755,42 +1453,52 @@
 }
 }
 };
-dojo.lang.delayThese=function(farr,cb,_1d2,_1d3){
+dojo.lang.delayThese=function(farr,cb,_169,_16a){
 if(!farr.length){
-if(typeof _1d3=="function"){
-_1d3();
+if(typeof _16a=="function"){
+_16a();
 }
 return;
 }
-if((typeof _1d2=="undefined")&&(typeof cb=="number")){
-_1d2=cb;
+if((typeof _169=="undefined")&&(typeof cb=="number")){
+_169=cb;
 cb=function(){
 };
 }else{
 if(!cb){
 cb=function(){
 };
-if(!_1d2){
-_1d2=0;
+if(!_169){
+_169=0;
 }
 }
 }
 setTimeout(function(){
 (farr.shift())();
 cb();
-dojo.lang.delayThese(farr,cb,_1d2,_1d3);
-},_1d2);
+dojo.lang.delayThese(farr,cb,_169,_16a);
+},_169);
 };
 dojo.provide("dojo.string.extras");
-dojo.string.substituteParams=function(_1d4,hash){
+dojo.require("dojo.string.common");
+dojo.require("dojo.lang");
+dojo.string.substituteParams=function(_16b,hash){
 var map=(typeof hash=="object")?hash:dojo.lang.toArray(arguments,1);
-return _1d4.replace(/\%\{(\w+)\}/g,function(_1d7,key){
-if(typeof (map[key])!="undefined"&&map[key]!=null){
-return map[key];
-}
-dojo.raise("Substitution not found: "+key);
+return _16b.replace(/\%\{(\w+)\}/g,function(_16e,key){
+return map[key]||dojo.raise("Substitution not found: "+key);
 });
 };
+dojo.string.paramString=function(str,_171,_172){
+dojo.deprecated("dojo.string.paramString","use dojo.string.substituteParams instead","0.4");
+for(var name in _171){
+var re=new RegExp("\\%\\{"+name+"\\}","g");
+str=str.replace(re,_171[name]);
+}
+if(_172){
+str=str.replace(/%\{([^\}\s]+)\}/g,"");
+}
+return str;
+};
 dojo.string.capitalize=function(str){
 if(!dojo.lang.isString(str)){
 return "";
@@ -1798,11 +1506,11 @@
 if(arguments.length==0){
 str=this;
 }
-var _1da=str.split(" ");
-for(var i=0;i<_1da.length;i++){
-_1da[i]=_1da[i].charAt(0).toUpperCase()+_1da[i].substring(1);
+var _176=str.split(" ");
+for(var i=0;i<_176.length;i++){
+_176[i]=_176[i].charAt(0).toUpperCase()+_176[i].substring(1);
 }
-return _1da.join(" ");
+return _176.join(" ");
 };
 dojo.string.isBlank=function(str){
 if(!dojo.lang.isString(str)){
@@ -1815,15 +1523,15 @@
 return str;
 }
 var ret="";
-var _1df=escape(str);
-var _1e0,re=/%u([0-9A-F]{4})/i;
-while((_1e0=_1df.match(re))){
-var num=Number("0x"+_1e0[1]);
-var _1e3=escape("&#"+num+";");
-ret+=_1df.substring(0,_1e0.index)+_1e3;
-_1df=_1df.substring(_1e0.index+_1e0[0].length);
+var _17b=escape(str);
+var _17c,re=/%u([0-9A-F]{4})/i;
+while((_17c=_17b.match(re))){
+var num=Number("0x"+_17c[1]);
+var _17e=escape("&#"+num+";");
+ret+=_17b.substring(0,_17c.index)+_17e;
+_17b=_17b.substring(_17c.index+_17c[0].length);
 }
-ret+=_1df.replace(/\+/g,"%2B");
+ret+=_17b.replace(/\+/g,"%2B");
 return ret;
 };
 dojo.string.escape=function(type,str){
@@ -1848,9 +1556,9 @@
 return str;
 }
 };
-dojo.string.escapeXml=function(str,_1e8){
+dojo.string.escapeXml=function(str,_183){
 str=str.replace(/&/gm,"&amp;").replace(/</gm,"&lt;").replace(/>/gm,"&gt;").replace(/"/gm,"&quot;");
-if(!_1e8){
+if(!_183){
 str=str.replace(/'/gm,"&#39;");
 }
 return str;
@@ -1870,11 +1578,12 @@
 dojo.string.summary=function(str,len){
 if(!len||str.length<=len){
 return str;
-}
+}else{
 return str.substring(0,len).replace(/\.+$/,"")+"...";
+}
 };
-dojo.string.endsWith=function(str,end,_1f1){
-if(_1f1){
+dojo.string.endsWith=function(str,end,_18c){
+if(_18c){
 str=str.toLowerCase();
 end=end.toLowerCase();
 }
@@ -1891,12 +1600,12 @@
 }
 return false;
 };
-dojo.string.startsWith=function(str,_1f5,_1f6){
-if(_1f6){
+dojo.string.startsWith=function(str,_190,_191){
+if(_191){
 str=str.toLowerCase();
-_1f5=_1f5.toLowerCase();
+_190=_190.toLowerCase();
 }
-return str.indexOf(_1f5)==0;
+return str.indexOf(_190)==0;
 };
 dojo.string.startsWithAny=function(str){
 for(var i=1;i<arguments.length;i++){
@@ -1914,36 +1623,38 @@
 }
 return false;
 };
-dojo.string.normalizeNewlines=function(text,_1fc){
-if(_1fc=="\n"){
+dojo.string.normalizeNewlines=function(text,_197){
+if(_197=="\n"){
 text=text.replace(/\r\n/g,"\n");
 text=text.replace(/\r/g,"\n");
 }else{
-if(_1fc=="\r"){
+if(_197=="\r"){
 text=text.replace(/\r\n/g,"\r");
 text=text.replace(/\n/g,"\r");
 }else{
-text=text.replace(/([^\r])\n/g,"$1\r\n").replace(/\r([^\n])/g,"\r\n$1");
+text=text.replace(/([^\r])\n/g,"$1\r\n");
+text=text.replace(/\r([^\n])/g,"\r\n$1");
 }
 }
 return text;
 };
-dojo.string.splitEscaped=function(str,_1fe){
-var _1ff=[];
-for(var i=0,_201=0;i<str.length;i++){
+dojo.string.splitEscaped=function(str,_199){
+var _19a=[];
+for(var i=0,prevcomma=0;i<str.length;i++){
 if(str.charAt(i)=="\\"){
 i++;
 continue;
 }
-if(str.charAt(i)==_1fe){
-_1ff.push(str.substring(_201,i));
-_201=i+1;
+if(str.charAt(i)==_199){
+_19a.push(str.substring(prevcomma,i));
+prevcomma=i+1;
 }
 }
-_1ff.push(str.substr(_201));
-return _1ff;
+_19a.push(str.substr(prevcomma));
+return _19a;
 };
 dojo.provide("dojo.dom");
+dojo.require("dojo.lang.array");
 dojo.dom.ELEMENT_NODE=1;
 dojo.dom.ATTRIBUTE_NODE=2;
 dojo.dom.TEXT_NODE=3;
@@ -1959,164 +1670,174 @@
 dojo.dom.dojoml="http://www.dojotoolkit.org/2004/dojoml";
 dojo.dom.xmlns={svg:"http://www.w3.org/2000/svg",smil:"http://www.w3.org/2001/SMIL20/",mml:"http://www.w3.org/1998/Math/MathML",cml:"http://www.xml-cml.org",xlink:"http://www.w3.org/1999/xlink",xhtml:"http://www.w3.org/1999/xhtml",xul:"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",xbl:"http://www.mozilla.org/xbl",fo:"http://www.w3.org/1999/XSL/Format",xsl:"http://www.w3.org/1999/XSL/Transform",xslt:"http://www.w3.org/1999/XSL/Transform",xi:"http://www.w3.org/2001/XInclude",xforms:"http://www.w3.org/2002/01/xforms",saxon:"http://icl.com/saxon",xalan:"http://xml.apache.org/xslt",xsd:"http://www.w3.org/2001/XMLSchema",dt:"http://www.w3.org/2001/XMLSchema-datatypes",xsi:"http://www.w3.org/2001/XMLSchema-instance",rdf:"http://www.w3.org/1999/02/22-rdf-syntax-ns#",rdfs:"http://www.w3.org/2000/01/rdf-schema#",dc:"http://purl.org/dc/elements/1.1/",dcq:"http://purl.org/dc/qualifiers/1.0","soap-env":"http://schemas.xmlsoap.org/soap/envelope/",wsdl:"http://schemas.xml!
 soap.org/wsdl/",AdobeExtensions:"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"};
 dojo.dom.isNode=function(wh){
-if(typeof Element=="function"){
+if(typeof Element=="object"){
 try{
 return wh instanceof Element;
 }
-catch(e){
+catch(E){
 }
 }else{
 return wh&&!isNaN(wh.nodeType);
 }
 };
+dojo.dom.getTagName=function(node){
+dojo.deprecated("dojo.dom.getTagName","use node.tagName instead","0.4");
+var _19e=node.tagName;
+if(_19e.substr(0,5).toLowerCase()!="dojo:"){
+if(_19e.substr(0,4).toLowerCase()=="dojo"){
+return "dojo:"+_19e.substring(4).toLowerCase();
+}
+var djt=node.getAttribute("dojoType")||node.getAttribute("dojotype");
+if(djt){
+return "dojo:"+djt.toLowerCase();
+}
+if((node.getAttributeNS)&&(node.getAttributeNS(this.dojoml,"type"))){
+return "dojo:"+node.getAttributeNS(this.dojoml,"type").toLowerCase();
+}
+try{
+djt=node.getAttribute("dojo:type");
+}
+catch(e){
+}
+if(djt){
+return "dojo:"+djt.toLowerCase();
+}
+if((!dj_global["djConfig"])||(!djConfig["ignoreClassNames"])){
+var _1a0=node.className||node.getAttribute("class");
+if((_1a0)&&(_1a0.indexOf)&&(_1a0.indexOf("dojo-")!=-1)){
+var _1a1=_1a0.split(" ");
+for(var x=0;x<_1a1.length;x++){
+if((_1a1[x].length>5)&&(_1a1[x].indexOf("dojo-")>=0)){
+return "dojo:"+_1a1[x].substr(5).toLowerCase();
+}
+}
+}
+}
+}
+return _19e.toLowerCase();
+};
 dojo.dom.getUniqueId=function(){
-var _203=dojo.doc();
 do{
 var id="dj_unique_"+(++arguments.callee._idIncrement);
-}while(_203.getElementById(id));
+}while(document.getElementById(id));
 return id;
 };
 dojo.dom.getUniqueId._idIncrement=0;
-dojo.dom.firstElement=dojo.dom.getFirstChildElement=function(_205,_206){
-var node=_205.firstChild;
+dojo.dom.firstElement=dojo.dom.getFirstChildElement=function(_1a4,_1a5){
+var node=_1a4.firstChild;
 while(node&&node.nodeType!=dojo.dom.ELEMENT_NODE){
 node=node.nextSibling;
 }
-if(_206&&node&&node.tagName&&node.tagName.toLowerCase()!=_206.toLowerCase()){
-node=dojo.dom.nextElement(node,_206);
+if(_1a5&&node&&node.tagName&&node.tagName.toLowerCase()!=_1a5.toLowerCase()){
+node=dojo.dom.nextElement(node,_1a5);
 }
 return node;
 };
-dojo.dom.lastElement=dojo.dom.getLastChildElement=function(_208,_209){
-var node=_208.lastChild;
+dojo.dom.lastElement=dojo.dom.getLastChildElement=function(_1a7,_1a8){
+var node=_1a7.lastChild;
 while(node&&node.nodeType!=dojo.dom.ELEMENT_NODE){
 node=node.previousSibling;
 }
-if(_209&&node&&node.tagName&&node.tagName.toLowerCase()!=_209.toLowerCase()){
-node=dojo.dom.prevElement(node,_209);
+if(_1a8&&node&&node.tagName&&node.tagName.toLowerCase()!=_1a8.toLowerCase()){
+node=dojo.dom.prevElement(node,_1a8);
 }
 return node;
 };
-dojo.dom.nextElement=dojo.dom.getNextSiblingElement=function(node,_20c){
+dojo.dom.nextElement=dojo.dom.getNextSiblingElement=function(node,_1ab){
 if(!node){
 return null;
 }
 do{
 node=node.nextSibling;
 }while(node&&node.nodeType!=dojo.dom.ELEMENT_NODE);
-if(node&&_20c&&_20c.toLowerCase()!=node.tagName.toLowerCase()){
-return dojo.dom.nextElement(node,_20c);
+if(node&&_1ab&&_1ab.toLowerCase()!=node.tagName.toLowerCase()){
+return dojo.dom.nextElement(node,_1ab);
 }
 return node;
 };
-dojo.dom.prevElement=dojo.dom.getPreviousSiblingElement=function(node,_20e){
+dojo.dom.prevElement=dojo.dom.getPreviousSiblingElement=function(node,_1ad){
 if(!node){
 return null;
 }
-if(_20e){
-_20e=_20e.toLowerCase();
+if(_1ad){
+_1ad=_1ad.toLowerCase();
 }
 do{
 node=node.previousSibling;
 }while(node&&node.nodeType!=dojo.dom.ELEMENT_NODE);
-if(node&&_20e&&_20e.toLowerCase()!=node.tagName.toLowerCase()){
-return dojo.dom.prevElement(node,_20e);
+if(node&&_1ad&&_1ad.toLowerCase()!=node.tagName.toLowerCase()){
+return dojo.dom.prevElement(node,_1ad);
 }
 return node;
 };
-dojo.dom.moveChildren=function(_20f,_210,trim){
-var _212=0;
+dojo.dom.moveChildren=function(_1ae,_1af,trim){
+var _1b1=0;
 if(trim){
-while(_20f.hasChildNodes()&&_20f.firstChild.nodeType==dojo.dom.TEXT_NODE){
-_20f.removeChild(_20f.firstChild);
+while(_1ae.hasChildNodes()&&_1ae.firstChild.nodeType==dojo.dom.TEXT_NODE){
+_1ae.removeChild(_1ae.firstChild);
 }
-while(_20f.hasChildNodes()&&_20f.lastChild.nodeType==dojo.dom.TEXT_NODE){
-_20f.removeChild(_20f.lastChild);
+while(_1ae.hasChildNodes()&&_1ae.lastChild.nodeType==dojo.dom.TEXT_NODE){
+_1ae.removeChild(_1ae.lastChild);
 }
 }
-while(_20f.hasChildNodes()){
-_210.appendChild(_20f.firstChild);
-_212++;
+while(_1ae.hasChildNodes()){
+_1af.appendChild(_1ae.firstChild);
+_1b1++;
 }
-return _212;
+return _1b1;
 };
-dojo.dom.copyChildren=function(_213,_214,trim){
-var _216=_213.cloneNode(true);
-return this.moveChildren(_216,_214,trim);
+dojo.dom.copyChildren=function(_1b2,_1b3,trim){
+var _1b5=_1b2.cloneNode(true);
+return this.moveChildren(_1b5,_1b3,trim);
 };
-dojo.dom.replaceChildren=function(node,_218){
-var _219=[];
-if(dojo.render.html.ie){
-for(var i=0;i<node.childNodes.length;i++){
-_219.push(node.childNodes[i]);
-}
-}
-dojo.dom.removeChildren(node);
-node.appendChild(_218);
-for(var i=0;i<_219.length;i++){
-dojo.dom.destroyNode(_219[i]);
-}
-};
 dojo.dom.removeChildren=function(node){
-var _21c=node.childNodes.length;
+var _1b7=node.childNodes.length;
 while(node.hasChildNodes()){
-dojo.dom.removeNode(node.firstChild);
+node.removeChild(node.firstChild);
 }
-return _21c;
+return _1b7;
 };
-dojo.dom.replaceNode=function(node,_21e){
-return node.parentNode.replaceChild(_21e,node);
+dojo.dom.replaceChildren=function(node,_1b9){
+dojo.dom.removeChildren(node);
+node.appendChild(_1b9);
 };
-dojo.dom.destroyNode=function(node){
-if(node.parentNode){
-node=dojo.dom.removeNode(node);
-}
-if(node.nodeType!=3){
-if(dojo.evalObjPath("dojo.event.browser.clean",false)){
-dojo.event.browser.clean(node);
-}
-if(dojo.render.html.ie){
-node.outerHTML="";
-}
-}
-};
 dojo.dom.removeNode=function(node){
 if(node&&node.parentNode){
 return node.parentNode.removeChild(node);
 }
 };
-dojo.dom.getAncestors=function(node,_222,_223){
-var _224=[];
-var _225=(_222&&(_222 instanceof Function||typeof _222=="function"));
+dojo.dom.getAncestors=function(node,_1bc,_1bd){
+var _1be=[];
+var _1bf=dojo.lang.isFunction(_1bc);
 while(node){
-if(!_225||_222(node)){
-_224.push(node);
+if(!_1bf||_1bc(node)){
+_1be.push(node);
 }
-if(_223&&_224.length>0){
-return _224[0];
+if(_1bd&&_1be.length>0){
+return _1be[0];
 }
 node=node.parentNode;
 }
-if(_223){
+if(_1bd){
 return null;
 }
-return _224;
+return _1be;
 };
-dojo.dom.getAncestorsByTag=function(node,tag,_228){
+dojo.dom.getAncestorsByTag=function(node,tag,_1c2){
 tag=tag.toLowerCase();
 return dojo.dom.getAncestors(node,function(el){
 return ((el.tagName)&&(el.tagName.toLowerCase()==tag));
-},_228);
+},_1c2);
 };
 dojo.dom.getFirstAncestorByTag=function(node,tag){
 return dojo.dom.getAncestorsByTag(node,tag,true);
 };
-dojo.dom.isDescendantOf=function(node,_22d,_22e){
-if(_22e&&node){
+dojo.dom.isDescendantOf=function(node,_1c7,_1c8){
+if(_1c8&&node){
 node=node.parentNode;
 }
 while(node){
-if(node==_22d){
+if(node==_1c7){
 return true;
 }
 node=node.parentNode;
@@ -2138,12 +1859,11 @@
 };
 dojo.dom.createDocument=function(){
 var doc=null;
-var _231=dojo.doc();
 if(!dj_undef("ActiveXObject")){
-var _232=["MSXML2","Microsoft","MSXML","MSXML3"];
-for(var i=0;i<_232.length;i++){
+var _1cb=["MSXML2","Microsoft","MSXML","MSXML3"];
+for(var i=0;i<_1cb.length;i++){
 try{
-doc=new ActiveXObject(_232[i]+".XMLDOM");
+doc=new ActiveXObject(_1cb[i]+".XMLDOM");
 }
 catch(e){
 }
@@ -2152,40 +1872,39 @@
 }
 }
 }else{
-if((_231.implementation)&&(_231.implementation.createDocument)){
-doc=_231.implementation.createDocument("","",null);
+if((document.implementation)&&(document.implementation.createDocument)){
+doc=document.implementation.createDocument("","",null);
 }
 }
 return doc;
 };
-dojo.dom.createDocumentFromText=function(str,_235){
-if(!_235){
-_235="text/xml";
+dojo.dom.createDocumentFromText=function(str,_1ce){
+if(!_1ce){
+_1ce="text/xml";
 }
 if(!dj_undef("DOMParser")){
-var _236=new DOMParser();
-return _236.parseFromString(str,_235);
+var _1cf=new DOMParser();
+return _1cf.parseFromString(str,_1ce);
 }else{
 if(!dj_undef("ActiveXObject")){
-var _237=dojo.dom.createDocument();
-if(_237){
-_237.async=false;
-_237.loadXML(str);
-return _237;
+var _1d0=dojo.dom.createDocument();
+if(_1d0){
+_1d0.async=false;
+_1d0.loadXML(str);
+return _1d0;
 }else{
 dojo.debug("toXml didn't work?");
 }
 }else{
-var _238=dojo.doc();
-if(_238.createElement){
-var tmp=_238.createElement("xml");
+if(document.createElement){
+var tmp=document.createElement("xml");
 tmp.innerHTML=str;
-if(_238.implementation&&_238.implementation.createDocument){
-var _23a=_238.implementation.createDocument("foo","",null);
+if(document.implementation&&document.implementation.createDocument){
+var _1d2=document.implementation.createDocument("foo","",null);
 for(var i=0;i<tmp.childNodes.length;i++){
-_23a.importNode(tmp.childNodes.item(i),true);
+_1d2.importNode(tmp.childNodes.item(i),true);
 }
-return _23a;
+return _1d2;
 }
 return ((tmp.document)&&(tmp.document.firstChild?tmp.document.firstChild:tmp));
 }
@@ -2193,39 +1912,39 @@
 }
 return null;
 };
-dojo.dom.prependChild=function(node,_23d){
-if(_23d.firstChild){
-_23d.insertBefore(node,_23d.firstChild);
+dojo.dom.prependChild=function(node,_1d5){
+if(_1d5.firstChild){
+_1d5.insertBefore(node,_1d5.firstChild);
 }else{
-_23d.appendChild(node);
+_1d5.appendChild(node);
 }
 return true;
 };
-dojo.dom.insertBefore=function(node,ref,_240){
-if((_240!=true)&&(node===ref||node.nextSibling===ref)){
+dojo.dom.insertBefore=function(node,ref,_1d8){
+if(_1d8!=true&&(node===ref||node.nextSibling===ref)){
 return false;
 }
-var _241=ref.parentNode;
-_241.insertBefore(node,ref);
+var _1d9=ref.parentNode;
+_1d9.insertBefore(node,ref);
 return true;
 };
-dojo.dom.insertAfter=function(node,ref,_244){
+dojo.dom.insertAfter=function(node,ref,_1dc){
 var pn=ref.parentNode;
 if(ref==pn.lastChild){
-if((_244!=true)&&(node===ref)){
+if((_1dc!=true)&&(node===ref)){
 return false;
 }
 pn.appendChild(node);
 }else{
-return this.insertBefore(node,ref.nextSibling,_244);
+return this.insertBefore(node,ref.nextSibling,_1dc);
 }
 return true;
 };
-dojo.dom.insertAtPosition=function(node,ref,_248){
-if((!node)||(!ref)||(!_248)){
+dojo.dom.insertAtPosition=function(node,ref,_1e0){
+if((!node)||(!ref)||(!_1e0)){
 return false;
 }
-switch(_248.toLowerCase()){
+switch(_1e0.toLowerCase()){
 case "before":
 return dojo.dom.insertBefore(node,ref);
 case "after":
@@ -2243,78 +1962,71 @@
 return true;
 }
 };
-dojo.dom.insertAtIndex=function(node,_24a,_24b){
-var _24c=_24a.childNodes;
-if(!_24c.length||_24c.length==_24b){
-_24a.appendChild(node);
+dojo.dom.insertAtIndex=function(node,_1e2,_1e3){
+var _1e4=_1e2.childNodes;
+if(!_1e4.length){
+_1e2.appendChild(node);
 return true;
 }
-if(_24b==0){
-return dojo.dom.prependChild(node,_24a);
+var _1e5=null;
+for(var i=0;i<_1e4.length;i++){
+var _1e7=_1e4.item(i)["getAttribute"]?parseInt(_1e4.item(i).getAttribute("dojoinsertionindex")):-1;
+if(_1e7<_1e3){
+_1e5=_1e4.item(i);
 }
-return dojo.dom.insertAfter(node,_24c[_24b-1]);
+}
+if(_1e5){
+return dojo.dom.insertAfter(node,_1e5);
+}else{
+return dojo.dom.insertBefore(node,_1e4.item(0));
+}
 };
 dojo.dom.textContent=function(node,text){
-if(arguments.length>1){
-var _24f=dojo.doc();
-dojo.dom.replaceChildren(node,_24f.createTextNode(text));
+if(text){
+dojo.dom.replaceChildren(node,document.createTextNode(text));
 return text;
 }else{
-if(node.textContent!=undefined){
-return node.textContent;
-}
-var _250="";
+var _1ea="";
 if(node==null){
-return _250;
+return _1ea;
 }
 for(var i=0;i<node.childNodes.length;i++){
 switch(node.childNodes[i].nodeType){
 case 1:
 case 5:
-_250+=dojo.dom.textContent(node.childNodes[i]);
+_1ea+=dojo.dom.textContent(node.childNodes[i]);
 break;
 case 3:
 case 2:
 case 4:
-_250+=node.childNodes[i].nodeValue;
+_1ea+=node.childNodes[i].nodeValue;
 break;
 default:
 break;
 }
 }
-return _250;
+return _1ea;
 }
 };
+dojo.dom.collectionToArray=function(_1ec){
+dojo.deprecated("dojo.dom.collectionToArray","use dojo.lang.toArray instead","0.4");
+return dojo.lang.toArray(_1ec);
+};
 dojo.dom.hasParent=function(node){
-return Boolean(node&&node.parentNode&&dojo.dom.isNode(node.parentNode));
+return node&&node.parentNode&&dojo.dom.isNode(node.parentNode);
 };
 dojo.dom.isTag=function(node){
 if(node&&node.tagName){
-for(var i=1;i<arguments.length;i++){
-if(node.tagName==String(arguments[i])){
-return String(arguments[i]);
+var arr=dojo.lang.toArray(arguments,1);
+return arr[dojo.lang.find(node.tagName,arr)]||"";
 }
-}
-}
 return "";
 };
-dojo.dom.setAttributeNS=function(elem,_256,_257,_258){
-if(elem==null||((elem==undefined)&&(typeof elem=="undefined"))){
-dojo.raise("No element given to dojo.dom.setAttributeNS");
-}
-if(!((elem.setAttributeNS==undefined)&&(typeof elem.setAttributeNS=="undefined"))){
-elem.setAttributeNS(_256,_257,_258);
-}else{
-var _259=elem.ownerDocument;
-var _25a=_259.createNode(2,_257,_256);
-_25a.nodeValue=_258;
-elem.setAttributeNode(_25a);
-}
-};
 dojo.provide("dojo.undo.browser");
+dojo.require("dojo.io");
 try{
 if((!djConfig["preventBackButtonFix"])&&(!dojo.hostenv.post_load_)){
-document.write("<iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='"+(djConfig["dojoIframeHistoryUrl"]||dojo.hostenv.getBaseScriptUri()+"iframe_history.html")+"'></iframe>");
+document.write("<iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='"+(dojo.hostenv.getBaseScriptUri()+"iframe_history.html")+"'></iframe>");
 }
 }
 catch(e){
@@ -2322,45 +2034,35 @@
 if(dojo.render.html.opera){
 dojo.debug("Opera is not supported with dojo.undo.browser, so back/forward detection will not work.");
 }
-dojo.undo.browser={initialHref:(!dj_undef("window"))?window.location.href:"",initialHash:(!dj_undef("window"))?window.location.hash:"",moveForward:false,historyStack:[],forwardStack:[],historyIframe:null,bookmarkAnchor:null,locationTimer:null,setInitialState:function(args){
-this.initialState=this._createState(this.initialHref,args,this.initialHash);
+dojo.undo.browser={initialHref:window.location.href,initialHash:window.location.hash,moveForward:false,historyStack:[],forwardStack:[],historyIframe:null,bookmarkAnchor:null,locationTimer:null,setInitialState:function(args){
+this.initialState={"url":this.initialHref,"kwArgs":args,"urlHash":this.initialHash};
 },addToHistory:function(args){
-this.forwardStack=[];
 var hash=null;
-var url=null;
 if(!this.historyIframe){
-if(djConfig["useXDomain"]&&!djConfig["dojoIframeHistoryUrl"]){
-dojo.debug("dojo.undo.browser: When using cross-domain Dojo builds,"+" please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl"+" to the path on your domain to iframe_history.html");
-}
 this.historyIframe=window.frames["djhistory"];
 }
 if(!this.bookmarkAnchor){
 this.bookmarkAnchor=document.createElement("a");
-dojo.body().appendChild(this.bookmarkAnchor);
+(document.body||document.getElementsByTagName("body")[0]).appendChild(this.bookmarkAnchor);
 this.bookmarkAnchor.style.display="none";
 }
-if(args["changeUrl"]){
-hash="#"+((args["changeUrl"]!==true)?args["changeUrl"]:(new Date()).getTime());
-if(this.historyStack.length==0&&this.initialState.urlHash==hash){
-this.initialState=this._createState(url,args,hash);
-return;
-}else{
-if(this.historyStack.length>0&&this.historyStack[this.historyStack.length-1].urlHash==hash){
-this.historyStack[this.historyStack.length-1]=this._createState(url,args,hash);
-return;
+if((!args["changeUrl"])||(dojo.render.html.ie)){
+var url=dojo.hostenv.getBaseScriptUri()+"iframe_history.html?"+(new Date()).getTime();
+this.moveForward=true;
+dojo.io.setIFrameSrc(this.historyIframe,url,false);
 }
-}
+if(args["changeUrl"]){
 this.changingUrl=true;
+hash="#"+((args["changeUrl"]!==true)?args["changeUrl"]:(new Date()).getTime());
 setTimeout("window.location.href = '"+hash+"'; dojo.undo.browser.changingUrl = false;",1);
 this.bookmarkAnchor.href=hash;
 if(dojo.render.html.ie){
-url=this._loadIframeHistory();
-var _25f=args["back"]||args["backButton"]||args["handle"];
-var tcb=function(_261){
+var _1f4=args["back"]||args["backButton"]||args["handle"];
+var tcb=function(_1f6){
 if(window.location.hash!=""){
 setTimeout("window.location.href = '"+hash+"';",1);
 }
-_25f.apply(this,[_261]);
+_1f4.apply(this,[_1f6]);
 };
 if(args["back"]){
 args.back=tcb;
@@ -2373,13 +2075,14 @@
 }
 }
 }
-var _262=args["forward"]||args["forwardButton"]||args["handle"];
-var tfw=function(_264){
+this.forwardStack=[];
+var _1f7=args["forward"]||args["forwardButton"]||args["handle"];
+var tfw=function(_1f9){
 if(window.location.hash!=""){
 window.location.href=hash;
 }
-if(_262){
-_262.apply(this,[_264]);
+if(_1f7){
+_1f7.apply(this,[_1f9]);
 }
 };
 if(args["forward"]){
@@ -2400,10 +2103,8 @@
 }
 }
 }
-}else{
-url=this._loadIframeHistory();
 }
-this.historyStack.push(this._createState(url,args,hash));
+this.historyStack.push({"url":url,"kwArgs":args,"urlHash":hash});
 },checkLocation:function(){
 if(!this.changingUrl){
 var hsl=this.historyStack.length;
@@ -2424,10 +2125,10 @@
 }
 }
 }
-},iframeLoaded:function(evt,_267){
+},iframeLoaded:function(evt,_1fc){
 if(!dojo.render.html.opera){
-var _268=this._getUrlQuery(_267.href);
-if(_268==null){
+var _1fd=this._getUrlQuery(_1fc.href);
+if(_1fd==null){
 if(this.historyStack.length==1){
 this.handleBackButton();
 }
@@ -2437,17 +2138,17 @@
 this.moveForward=false;
 return;
 }
-if(this.historyStack.length>=2&&_268==this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
+if(this.historyStack.length>=2&&_1fd==this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
 this.handleBackButton();
 }else{
-if(this.forwardStack.length>0&&_268==this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
+if(this.forwardStack.length>0&&_1fd==this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
 this.handleForwardButton();
 }
 }
 }
 },handleBackButton:function(){
-var _269=this.historyStack.pop();
-if(!_269){
+var _1fe=this.historyStack.pop();
+if(!_1fe){
 return;
 }
 var last=this.historyStack[this.historyStack.length-1];
@@ -2467,7 +2168,7 @@
 }
 }
 }
-this.forwardStack.push(_269);
+this.forwardStack.push(_1fe);
 },handleForwardButton:function(){
 var last=this.forwardStack.pop();
 if(!last){
@@ -2485,70 +2186,75 @@
 }
 }
 this.historyStack.push(last);
-},_createState:function(url,args,hash){
-return {"url":url,"kwArgs":args,"urlHash":hash};
 },_getUrlQuery:function(url){
-var _270=url.split("?");
-if(_270.length<2){
+var _202=url.split("?");
+if(_202.length<2){
 return null;
 }else{
-return _270[1];
+return _202[1];
 }
-},_loadIframeHistory:function(){
-var url=(djConfig["dojoIframeHistoryUrl"]||dojo.hostenv.getBaseScriptUri()+"iframe_history.html")+"?"+(new Date()).getTime();
-this.moveForward=true;
-dojo.io.setIFrameSrc(this.historyIframe,url,false);
-return url;
 }};
 dojo.provide("dojo.io.BrowserIO");
-if(!dj_undef("window")){
+dojo.require("dojo.io");
+dojo.require("dojo.lang.array");
+dojo.require("dojo.lang.func");
+dojo.require("dojo.string.extras");
+dojo.require("dojo.dom");
+dojo.require("dojo.undo.browser");
 dojo.io.checkChildrenForFile=function(node){
-var _273=false;
-var _274=node.getElementsByTagName("input");
-dojo.lang.forEach(_274,function(_275){
-if(_273){
+var _204=false;
+var _205=node.getElementsByTagName("input");
+dojo.lang.forEach(_205,function(_206){
+if(_204){
 return;
 }
-if(_275.getAttribute("type")=="file"){
-_273=true;
+if(_206.getAttribute("type")=="file"){
+_204=true;
 }
 });
-return _273;
+return _204;
 };
-dojo.io.formHasFile=function(_276){
-return dojo.io.checkChildrenForFile(_276);
+dojo.io.formHasFile=function(_207){
+return dojo.io.checkChildrenForFile(_207);
 };
-dojo.io.updateNode=function(node,_278){
+dojo.io.updateNode=function(node,_209){
 node=dojo.byId(node);
-var args=_278;
-if(dojo.lang.isString(_278)){
-args={url:_278};
+var args=_209;
+if(dojo.lang.isString(_209)){
+args={url:_209};
 }
 args.mimetype="text/html";
 args.load=function(t,d,e){
 while(node.firstChild){
-dojo.dom.destroyNode(node.firstChild);
+if(dojo["event"]){
+try{
+dojo.event.browser.clean(node.firstChild);
 }
+catch(e){
+}
+}
+node.removeChild(node.firstChild);
+}
 node.innerHTML=d;
 };
 dojo.io.bind(args);
 };
 dojo.io.formFilter=function(node){
 var type=(node.type||"").toLowerCase();
-return !node.disabled&&node.name&&!dojo.lang.inArray(["file","submit","image","reset","button"],type);
+return !node.disabled&&node.name&&!dojo.lang.inArray(type,["file","submit","image","reset","button"]);
 };
-dojo.io.encodeForm=function(_27f,_280,_281){
-if((!_27f)||(!_27f.tagName)||(!_27f.tagName.toLowerCase()=="form")){
+dojo.io.encodeForm=function(_210,_211,_212){
+if((!_210)||(!_210.tagName)||(!_210.tagName.toLowerCase()=="form")){
 dojo.raise("Attempted to encode a non-form element.");
 }
-if(!_281){
-_281=dojo.io.formFilter;
+if(!_212){
+_212=dojo.io.formFilter;
 }
-var enc=/utf/i.test(_280||"")?encodeURIComponent:dojo.string.encodeAscii;
-var _283=[];
-for(var i=0;i<_27f.elements.length;i++){
-var elm=_27f.elements[i];
-if(!elm||elm.tagName.toLowerCase()=="fieldset"||!_281(elm)){
+var enc=/utf/i.test(_211||"")?encodeURIComponent:dojo.string.encodeAscii;
+var _214=[];
+for(var i=0;i<_210.elements.length;i++){
+var elm=_210.elements[i];
+if(!elm||elm.tagName.toLowerCase()=="fieldset"||!_212(elm)){
 continue;
 }
 var name=enc(elm.name);
@@ -2556,30 +2262,30 @@
 if(type=="select-multiple"){
 for(var j=0;j<elm.options.length;j++){
 if(elm.options[j].selected){
-_283.push(name+"="+enc(elm.options[j].value));
+_214.push(name+"="+enc(elm.options[j].value));
 }
 }
 }else{
-if(dojo.lang.inArray(["radio","checkbox"],type)){
+if(dojo.lang.inArray(type,["radio","checkbox"])){
 if(elm.checked){
-_283.push(name+"="+enc(elm.value));
+_214.push(name+"="+enc(elm.value));
 }
 }else{
-_283.push(name+"="+enc(elm.value));
+_214.push(name+"="+enc(elm.value));
 }
 }
 }
-var _289=_27f.getElementsByTagName("input");
-for(var i=0;i<_289.length;i++){
-var _28a=_289[i];
-if(_28a.type.toLowerCase()=="image"&&_28a.form==_27f&&_281(_28a)){
-var name=enc(_28a.name);
-_283.push(name+"="+enc(_28a.value));
-_283.push(name+".x=0");
-_283.push(name+".y=0");
+var _21a=_210.getElementsByTagName("input");
+for(var i=0;i<_21a.length;i++){
+var _21b=_21a[i];
+if(_21b.type.toLowerCase()=="image"&&_21b.form==_210&&_212(_21b)){
+var name=enc(_21b.name);
+_214.push(name+"="+enc(_21b.value));
+_214.push(name+".x=0");
+_214.push(name+".y=0");
 }
 }
-return _283.join("&")+"&";
+return _214.join("&")+"&";
 };
 dojo.io.FormBind=function(args){
 this.bindArgs={};
@@ -2609,15 +2315,15 @@
 this.connect(form,"onsubmit","submit");
 for(var i=0;i<form.elements.length;i++){
 var node=form.elements[i];
-if(node&&node.type&&dojo.lang.inArray(["submit","button"],node.type.toLowerCase())){
+if(node&&node.type&&dojo.lang.inArray(node.type.toLowerCase(),["submit","button"])){
 this.connect(node,"onclick","click");
 }
 }
-var _290=form.getElementsByTagName("input");
-for(var i=0;i<_290.length;i++){
-var _291=_290[i];
-if(_291.type.toLowerCase()=="image"&&_291.form==form){
-this.connect(_291,"onclick","click");
+var _221=form.getElementsByTagName("input");
+for(var i=0;i<_221.length;i++){
+var _222=_221[i];
+if(_222.type.toLowerCase()=="image"&&_222.form==form){
+this.connect(_222,"onclick","click");
 }
 }
 },onSubmit:function(form){
@@ -2635,26 +2341,26 @@
 this.clickedButton=node;
 },formFilter:function(node){
 var type=(node.type||"").toLowerCase();
-var _298=false;
+var _229=false;
 if(node.disabled||!node.name){
-_298=false;
+_229=false;
 }else{
-if(dojo.lang.inArray(["submit","button","image"],type)){
+if(dojo.lang.inArray(type,["submit","button","image"])){
 if(!this.clickedButton){
 this.clickedButton=node;
 }
-_298=node==this.clickedButton;
+_229=node==this.clickedButton;
 }else{
-_298=!dojo.lang.inArray(["file","submit","reset","button"],type);
+_229=!dojo.lang.inArray(type,["file","submit","reset","button"]);
 }
 }
-return _298;
-},connect:function(_299,_29a,_29b){
+return _229;
+},connect:function(_22a,_22b,_22c){
 if(dojo.evalObjPath("dojo.event.connect")){
-dojo.event.connect(_299,_29a,this,_29b);
+dojo.event.connect(_22a,_22b,this,_22c);
 }else{
-var fcn=dojo.lang.hitch(this,_29b);
-_299[_29a]=function(e){
+var fcn=dojo.lang.hitch(this,_22c);
+_22a[_22b]=function(e){
 if(!e){
 e=window.event;
 }
@@ -2671,40 +2377,40 @@
 }
 }});
 dojo.io.XMLHTTPTransport=new function(){
-var _29e=this;
-var _29f={};
+var _22f=this;
+var _230={};
 this.useCache=false;
 this.preventCache=false;
-function getCacheKey(url,_2a1,_2a2){
-return url+"|"+_2a1+"|"+_2a2.toLowerCase();
+function getCacheKey(url,_232,_233){
+return url+"|"+_232+"|"+_233.toLowerCase();
 }
-function addToCache(url,_2a4,_2a5,http){
-_29f[getCacheKey(url,_2a4,_2a5)]=http;
+function addToCache(url,_235,_236,http){
+_230[getCacheKey(url,_235,_236)]=http;
 }
-function getFromCache(url,_2a8,_2a9){
-return _29f[getCacheKey(url,_2a8,_2a9)];
+function getFromCache(url,_239,_23a){
+return _230[getCacheKey(url,_239,_23a)];
 }
 this.clearCache=function(){
-_29f={};
+_230={};
 };
-function doLoad(_2aa,http,url,_2ad,_2ae){
-if(((http.status>=200)&&(http.status<300))||(http.status==304)||(http.status==1223)||(location.protocol=="file:"&&(http.status==0||http.status==undefined))||(location.protocol=="chrome:"&&(http.status==0||http.status==undefined))){
+function doLoad(_23b,http,url,_23e,_23f){
+if(((http.status>=200)&&(http.status<300))||(http.status==304)||(location.protocol=="file:"&&(http.status==0||http.status==undefined))||(location.protocol=="chrome:"&&(http.status==0||http.status==undefined))){
 var ret;
-if(_2aa.method.toLowerCase()=="head"){
-var _2b0=http.getAllResponseHeaders();
+if(_23b.method.toLowerCase()=="head"){
+var _241=http.getAllResponseHeaders();
 ret={};
 ret.toString=function(){
-return _2b0;
+return _241;
 };
-var _2b1=_2b0.split(/[\r\n]+/g);
-for(var i=0;i<_2b1.length;i++){
-var pair=_2b1[i].match(/^([^:]+)\s*:\s*(.+)$/i);
+var _242=_241.split(/[\r\n]+/g);
+for(var i=0;i<_242.length;i++){
+var pair=_242[i].match(/^([^:]+)\s*:\s*(.+)$/i);
 if(pair){
 ret[pair[1]]=pair[2];
 }
 }
 }else{
-if(_2aa.mimetype=="text/javascript"){
+if(_23b.mimetype=="text/javascript"){
 try{
 ret=dj_eval(http.responseText);
 }
@@ -2714,9 +2420,9 @@
 ret=null;
 }
 }else{
-if(_2aa.mimetype.substr(0,9)=="text/json"||_2aa.mimetype.substr(0,16)=="application/json"){
+if(_23b.mimetype=="text/json"){
 try{
-ret=dj_eval("("+_2aa.jsonFilter(http.responseText)+")");
+ret=dj_eval("("+http.responseText+")");
 }
 catch(e){
 dojo.debug(e);
@@ -2724,7 +2430,7 @@
 ret=false;
 }
 }else{
-if((_2aa.mimetype=="application/xml")||(_2aa.mimetype=="text/xml")){
+if((_23b.mimetype=="application/xml")||(_23b.mimetype=="text/xml")){
 ret=http.responseXML;
 if(!ret||typeof ret=="string"||!http.getResponseHeader("Content-Type")){
 ret=dojo.dom.createDocumentFromText(http.responseText);
@@ -2735,22 +2441,22 @@
 }
 }
 }
-if(_2ae){
-addToCache(url,_2ad,_2aa.method,http);
+if(_23f){
+addToCache(url,_23e,_23b.method,http);
 }
-_2aa[(typeof _2aa.load=="function")?"load":"handle"]("load",ret,http,_2aa);
+_23b[(typeof _23b.load=="function")?"load":"handle"]("load",ret,http,_23b);
 }else{
-var _2b4=new dojo.io.Error("XMLHttpTransport Error: "+http.status+" "+http.statusText);
-_2aa[(typeof _2aa.error=="function")?"error":"handle"]("error",_2b4,http,_2aa);
+var _245=new dojo.io.Error("XMLHttpTransport Error: "+http.status+" "+http.statusText);
+_23b[(typeof _23b.error=="function")?"error":"handle"]("error",_245,http,_23b);
 }
 }
-function setHeaders(http,_2b6){
-if(_2b6["headers"]){
-for(var _2b7 in _2b6["headers"]){
-if(_2b7.toLowerCase()=="content-type"&&!_2b6["contentType"]){
-_2b6["contentType"]=_2b6["headers"][_2b7];
+function setHeaders(http,_247){
+if(_247["headers"]){
+for(var _248 in _247["headers"]){
+if(_248.toLowerCase()=="content-type"&&!_247["contentType"]){
+_247["contentType"]=_247["headers"][_248];
 }else{
-http.setRequestHeader(_2b7,_2b6["headers"][_2b7]);
+http.setRequestHeader(_248,_247["headers"][_248]);
 }
 }
 }
@@ -2759,16 +2465,14 @@
 this.inFlightTimer=null;
 this.startWatchingInFlight=function(){
 if(!this.inFlightTimer){
-this.inFlightTimer=setTimeout("dojo.io.XMLHTTPTransport.watchInFlight();",10);
+this.inFlightTimer=setInterval("dojo.io.XMLHTTPTransport.watchInFlight();",10);
 }
 };
 this.watchInFlight=function(){
 var now=null;
-if(!dojo.hostenv._blockAsync&&!_29e._blockAsync){
 for(var x=this.inFlight.length-1;x>=0;x--){
-try{
 var tif=this.inFlight[x];
-if(!tif||tif.http._aborted||!tif.http.readyState){
+if(!tif){
 this.inFlight.splice(x,1);
 continue;
 }
@@ -2790,93 +2494,79 @@
 }
 }
 }
-catch(e){
-try{
-var _2bb=new dojo.io.Error("XMLHttpTransport.watchInFlight Error: "+e);
-tif.req[(typeof tif.req.error=="function")?"error":"handle"]("error",_2bb,tif.http,tif.req);
-}
-catch(e2){
-dojo.debug("XMLHttpTransport error callback failed: "+e2);
-}
-}
-}
-}
-clearTimeout(this.inFlightTimer);
 if(this.inFlight.length==0){
+clearInterval(this.inFlightTimer);
 this.inFlightTimer=null;
-return;
 }
-this.inFlightTimer=setTimeout("dojo.io.XMLHTTPTransport.watchInFlight();",10);
 };
-var _2bc=dojo.hostenv.getXmlhttpObject()?true:false;
-this.canHandle=function(_2bd){
-var mlc=_2bd["mimetype"].toLowerCase()||"";
-return _2bc&&((dojo.lang.inArray(["text/plain","text/html","application/xml","text/xml","text/javascript"],mlc))||(mlc.substr(0,9)=="text/json"||mlc.substr(0,16)=="application/json"))&&!(_2bd["formNode"]&&dojo.io.formHasFile(_2bd["formNode"]));
+var _24c=dojo.hostenv.getXmlhttpObject()?true:false;
+this.canHandle=function(_24d){
+return _24c&&dojo.lang.inArray((_24d["mimetype"].toLowerCase()||""),["text/plain","text/html","application/xml","text/xml","text/javascript","text/json"])&&!(_24d["formNode"]&&dojo.io.formHasFile(_24d["formNode"]));
 };
 this.multipartBoundary="45309FFF-BD65-4d50-99C9-36986896A96F";
-this.bind=function(_2bf){
-if(!_2bf["url"]){
-if(!_2bf["formNode"]&&(_2bf["backButton"]||_2bf["back"]||_2bf["changeUrl"]||_2bf["watchForURL"])&&(!djConfig.preventBackButtonFix)){
+this.bind=function(_24e){
+if(!_24e["url"]){
+if(!_24e["formNode"]&&(_24e["backButton"]||_24e["back"]||_24e["changeUrl"]||_24e["watchForURL"])&&(!djConfig.preventBackButtonFix)){
 dojo.deprecated("Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request","Use dojo.undo.browser.addToHistory() instead.","0.4");
-dojo.undo.browser.addToHistory(_2bf);
+dojo.undo.browser.addToHistory(_24e);
 return true;
 }
 }
-var url=_2bf.url;
-var _2c1="";
-if(_2bf["formNode"]){
-var ta=_2bf.formNode.getAttribute("action");
-if((ta)&&(!_2bf["url"])){
+var url=_24e.url;
+var _250="";
+if(_24e["formNode"]){
+var ta=_24e.formNode.getAttribute("action");
+if((ta)&&(!_24e["url"])){
 url=ta;
 }
-var tp=_2bf.formNode.getAttribute("method");
-if((tp)&&(!_2bf["method"])){
-_2bf.method=tp;
+var tp=_24e.formNode.getAttribute("method");
+if((tp)&&(!_24e["method"])){
+_24e.method=tp;
 }
-_2c1+=dojo.io.encodeForm(_2bf.formNode,_2bf.encoding,_2bf["formFilter"]);
+_250+=dojo.io.encodeForm(_24e.formNode,_24e.encoding,_24e["formFilter"]);
 }
 if(url.indexOf("#")>-1){
 dojo.debug("Warning: dojo.io.bind: stripping hash values from url:",url);
 url=url.split("#")[0];
 }
-if(_2bf["file"]){
-_2bf.method="post";
+if(_24e["file"]){
+_24e.method="post";
 }
-if(!_2bf["method"]){
-_2bf.method="get";
+if(!_24e["method"]){
+_24e.method="get";
 }
-if(_2bf.method.toLowerCase()=="get"){
-_2bf.multipart=false;
+if(_24e.method.toLowerCase()=="get"){
+_24e.multipart=false;
 }else{
-if(_2bf["file"]){
-_2bf.multipart=true;
+if(_24e["file"]){
+_24e.multipart=true;
 }else{
-if(!_2bf["multipart"]){
-_2bf.multipart=false;
+if(!_24e["multipart"]){
+_24e.multipart=false;
 }
 }
 }
-if(_2bf["backButton"]||_2bf["back"]||_2bf["changeUrl"]){
-dojo.undo.browser.addToHistory(_2bf);
+if(_24e["backButton"]||_24e["back"]||_24e["changeUrl"]){
+dojo.undo.browser.addToHistory(_24e);
 }
-var _2c4=_2bf["content"]||{};
-if(_2bf.sendTransport){
-_2c4["dojo.transport"]="xmlhttp";
+var _253=_24e["content"]||{};
+if(_24e.sendTransport){
+_253["dojo.transport"]="xmlhttp";
 }
 do{
-if(_2bf.postContent){
-_2c1=_2bf.postContent;
+if(_24e.postContent){
+_250=_24e.postContent;
 break;
 }
-if(_2c4){
-_2c1+=dojo.io.argsFromMap(_2c4,_2bf.encoding);
+if(_253){
+_250+=dojo.io.argsFromMap(_253,_24e.encoding);
 }
-if(_2bf.method.toLowerCase()=="get"||!_2bf.multipart){
+if(_24e.method.toLowerCase()=="get"||!_24e.multipart){
 break;
 }
 var t=[];
-if(_2c1.length){
-var q=_2c1.split("&");
+if(_250.length){
+var q=_250.split("&");
 for(var i=0;i<q.length;++i){
 if(q[i].length){
 var p=q[i].split("=");
@@ -2884,71 +2574,61 @@
 }
 }
 }
-if(_2bf.file){
-if(dojo.lang.isArray(_2bf.file)){
-for(var i=0;i<_2bf.file.length;++i){
-var o=_2bf.file[i];
+if(_24e.file){
+if(dojo.lang.isArray(_24e.file)){
+for(var i=0;i<_24e.file.length;++i){
+var o=_24e.file[i];
 t.push("--"+this.multipartBoundary,"Content-Disposition: form-data; name=\""+o.name+"\"; filename=\""+("fileName" in o?o.fileName:o.name)+"\"","Content-Type: "+("contentType" in o?o.contentType:"application/octet-stream"),"",o.content);
 }
 }else{
-var o=_2bf.file;
+var o=_24e.file;
 t.push("--"+this.multipartBoundary,"Content-Disposition: form-data; name=\""+o.name+"\"; filename=\""+("fileName" in o?o.fileName:o.name)+"\"","Content-Type: "+("contentType" in o?o.contentType:"application/octet-stream"),"",o.content);
 }
 }
 if(t.length){
 t.push("--"+this.multipartBoundary+"--","");
-_2c1=t.join("\r\n");
+_250=t.join("\r\n");
 }
 }while(false);
-var _2ca=_2bf["sync"]?false:true;
-var _2cb=_2bf["preventCache"]||(this.preventCache==true&&_2bf["preventCache"]!=false);
-var _2cc=_2bf["useCache"]==true||(this.useCache==true&&_2bf["useCache"]!=false);
-if(!_2cb&&_2cc){
-var _2cd=getFromCache(url,_2c1,_2bf.method);
-if(_2cd){
-doLoad(_2bf,_2cd,url,_2c1,false);
+var _259=_24e["sync"]?false:true;
+var _25a=_24e["preventCache"]||(this.preventCache==true&&_24e["preventCache"]!=false);
+var _25b=_24e["useCache"]==true||(this.useCache==true&&_24e["useCache"]!=false);
+if(!_25a&&_25b){
+var _25c=getFromCache(url,_250,_24e.method);
+if(_25c){
+doLoad(_24e,_25c,url,_250,false);
 return;
 }
 }
-var http=dojo.hostenv.getXmlhttpObject(_2bf);
-var _2cf=false;
-if(_2ca){
-var _2d0=this.inFlight.push({"req":_2bf,"http":http,"url":url,"query":_2c1,"useCache":_2cc,"startTime":_2bf.timeoutSeconds?(new Date()).getTime():0});
+var http=dojo.hostenv.getXmlhttpObject(_24e);
+var _25e=false;
+if(_259){
+var _25f=this.inFlight.push({"req":_24e,"http":http,"url":url,"query":_250,"useCache":_25b,"startTime":_24e.timeoutSeconds?(new Date()).getTime():0});
 this.startWatchingInFlight();
-}else{
-_29e._blockAsync=true;
 }
-if(_2bf.method.toLowerCase()=="post"){
-if(!_2bf.user){
-http.open("POST",url,_2ca);
-}else{
-http.open("POST",url,_2ca,_2bf.user,_2bf.password);
-}
-setHeaders(http,_2bf);
-http.setRequestHeader("Content-Type",_2bf.multipart?("multipart/form-data; boundary="+this.multipartBoundary):(_2bf.contentType||"application/x-www-form-urlencoded"));
+if(_24e.method.toLowerCase()=="post"){
+http.open("POST",url,_259);
+setHeaders(http,_24e);
+http.setRequestHeader("Content-Type",_24e.multipart?("multipart/form-data; boundary="+this.multipartBoundary):(_24e.contentType||"application/x-www-form-urlencoded"));
 try{
-http.send(_2c1);
+http.send(_250);
 }
 catch(e){
 if(typeof http.abort=="function"){
 http.abort();
 }
-doLoad(_2bf,{status:404},url,_2c1,_2cc);
+doLoad(_24e,{status:404},url,_250,_25b);
 }
 }else{
-var _2d1=url;
-if(_2c1!=""){
-_2d1+=(_2d1.indexOf("?")>-1?"&":"?")+_2c1;
+var _260=url;
+if(_250!=""){
+_260+=(_260.indexOf("?")>-1?"&":"?")+_250;
 }
-if(_2cb){
-_2d1+=(dojo.string.endsWithAny(_2d1,"?","&")?"":(_2d1.indexOf("?")>-1?"&":"?"))+"dojo.preventCache="+new Date().valueOf();
+if(_25a){
+_260+=(dojo.string.endsWithAny(_260,"?","&")?"":(_260.indexOf("?")>-1?"&":"?"))+"dojo.preventCache="+new Date().valueOf();
 }
-if(!_2bf.user){
-http.open(_2bf.method.toUpperCase(),_2d1,_2ca);
-}else{
-http.open(_2bf.method.toUpperCase(),_2d1,_2ca,_2bf.user,_2bf.password);
-}
-setHeaders(http,_2bf);
+http.open(_24e.method.toUpperCase(),_260,_259);
+setHeaders(http,_24e);
 try{
 http.send(null);
 }
@@ -2956,125 +2636,28 @@
 if(typeof http.abort=="function"){
 http.abort();
 }
-doLoad(_2bf,{status:404},url,_2c1,_2cc);
+doLoad(_24e,{status:404},url,_250,_25b);
 }
 }
-if(!_2ca){
-doLoad(_2bf,http,url,_2c1,_2cc);
-_29e._blockAsync=false;
+if(!_259){
+doLoad(_24e,http,url,_250,_25b);
 }
-_2bf.abort=function(){
-try{
-http._aborted=true;
-}
-catch(e){
-}
+_24e.abort=function(){
 return http.abort();
 };
 return;
 };
 dojo.io.transports.addTransport("XMLHTTPTransport");
 };
-}
-dojo.provide("dojo.io.cookie");
-dojo.io.cookie.setCookie=function(name,_2d3,days,path,_2d6,_2d7){
-var _2d8=-1;
-if((typeof days=="number")&&(days>=0)){
-var d=new Date();
-d.setTime(d.getTime()+(days*24*60*60*1000));
-_2d8=d.toGMTString();
-}
-_2d3=escape(_2d3);
-document.cookie=name+"="+_2d3+";"+(_2d8!=-1?" expires="+_2d8+";":"")+(path?"path="+path:"")+(_2d6?"; domain="+_2d6:"")+(_2d7?"; secure":"");
-};
-dojo.io.cookie.set=dojo.io.cookie.setCookie;
-dojo.io.cookie.getCookie=function(name){
-var idx=document.cookie.lastIndexOf(name+"=");
-if(idx==-1){
-return null;
-}
-var _2dc=document.cookie.substring(idx+name.length+1);
-var end=_2dc.indexOf(";");
-if(end==-1){
-end=_2dc.length;
-}
-_2dc=_2dc.substring(0,end);
-_2dc=unescape(_2dc);
-return _2dc;
-};
-dojo.io.cookie.get=dojo.io.cookie.getCookie;
-dojo.io.cookie.deleteCookie=function(name){
-dojo.io.cookie.setCookie(name,"-",0);
-};
-dojo.io.cookie.setObjectCookie=function(name,obj,days,path,_2e3,_2e4,_2e5){
-if(arguments.length==5){
-_2e5=_2e3;
-_2e3=null;
-_2e4=null;
-}
-var _2e6=[],_2e7,_2e8="";
-if(!_2e5){
-_2e7=dojo.io.cookie.getObjectCookie(name);
-}
-if(days>=0){
-if(!_2e7){
-_2e7={};
-}
-for(var prop in obj){
-if(obj[prop]==null){
-delete _2e7[prop];
-}else{
-if((typeof obj[prop]=="string")||(typeof obj[prop]=="number")){
-_2e7[prop]=obj[prop];
-}
-}
-}
-prop=null;
-for(var prop in _2e7){
-_2e6.push(escape(prop)+"="+escape(_2e7[prop]));
-}
-_2e8=_2e6.join("&");
-}
-dojo.io.cookie.setCookie(name,_2e8,days,path,_2e3,_2e4);
-};
-dojo.io.cookie.getObjectCookie=function(name){
-var _2eb=null,_2ec=dojo.io.cookie.getCookie(name);
-if(_2ec){
-_2eb={};
-var _2ed=_2ec.split("&");
-for(var i=0;i<_2ed.length;i++){
-var pair=_2ed[i].split("=");
-var _2f0=pair[1];
-if(isNaN(_2f0)){
-_2f0=unescape(pair[1]);
-}
-_2eb[unescape(pair[0])]=_2f0;
-}
-}
-return _2eb;
-};
-dojo.io.cookie.isSupported=function(){
-if(typeof navigator.cookieEnabled!="boolean"){
-dojo.io.cookie.setCookie("__TestingYourBrowserForCookieSupport__","CookiesAllowed",90,null);
-var _2f1=dojo.io.cookie.getCookie("__TestingYourBrowserForCookieSupport__");
-navigator.cookieEnabled=(_2f1=="CookiesAllowed");
-if(navigator.cookieEnabled){
-this.deleteCookie("__TestingYourBrowserForCookieSupport__");
-}
-}
-return navigator.cookieEnabled;
-};
-if(!dojo.io.cookies){
-dojo.io.cookies=dojo.io.cookie;
-}
-dojo.kwCompoundRequire({common:["dojo.io.common"],rhino:["dojo.io.RhinoIO"],browser:["dojo.io.BrowserIO","dojo.io.cookie"],dashboard:["dojo.io.BrowserIO","dojo.io.cookie"]});
-dojo.provide("dojo.io.*");
-dojo.provide("dojo.event.common");
+dojo.provide("dojo.event");
+dojo.require("dojo.lang.array");
+dojo.require("dojo.lang.extras");
+dojo.require("dojo.lang.func");
 dojo.event=new function(){
-this._canTimeout=dojo.lang.isFunction(dj_global["setTimeout"])||dojo.lang.isAlien(dj_global["setTimeout"]);
-function interpolateArgs(args,_2f3){
+this.canTimeout=dojo.lang.isFunction(dj_global["setTimeout"])||dojo.lang.isAlien(dj_global["setTimeout"]);
+function interpolateArgs(args,_262){
 var dl=dojo.lang;
-var ao={srcObj:dj_global,srcFunc:null,adviceObj:dj_global,adviceFunc:null,aroundObj:null,aroundFunc:null,adviceType:(args.length>2)?args[0]:"after",precedence:"last",once:false,delay:null,rate:0,adviceMsg:false,maxCalls:-1};
+var ao={srcObj:dj_global,srcFunc:null,adviceObj:dj_global,adviceFunc:null,aroundObj:null,aroundFunc:null,adviceType:(args.length>2)?args[0]:"after",precedence:"last",once:false,delay:null,rate:0,adviceMsg:false};
 switch(args.length){
 case 0:
 return;
@@ -3099,14 +2682,14 @@
 ao.adviceType="after";
 ao.srcObj=args[0];
 ao.srcFunc=args[1];
-var _2f6=dl.nameAnonFunc(args[2],ao.adviceObj,_2f3);
-ao.adviceFunc=_2f6;
+var _265=dl.nameAnonFunc(args[2],ao.adviceObj,_262);
+ao.adviceFunc=_265;
 }else{
 if((dl.isFunction(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))){
 ao.adviceType="after";
 ao.srcObj=dj_global;
-var _2f6=dl.nameAnonFunc(args[0],ao.srcObj,_2f3);
-ao.srcFunc=_2f6;
+var _265=dl.nameAnonFunc(args[0],ao.srcObj,_262);
+ao.srcFunc=_265;
 ao.adviceObj=args[1];
 ao.adviceFunc=args[2];
 }
@@ -3132,17 +2715,17 @@
 if((dl.isString(args[0]))&&(dl.isFunction(args[1]))&&(dl.isObject(args[2]))){
 ao.adviceType=args[0];
 ao.srcObj=dj_global;
-var _2f6=dl.nameAnonFunc(args[1],dj_global,_2f3);
-ao.srcFunc=_2f6;
+var _265=dl.nameAnonFunc(args[1],dj_global,_262);
+ao.srcFunc=_265;
 ao.adviceObj=args[2];
 ao.adviceFunc=args[3];
 }else{
 if((dl.isString(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))&&(dl.isFunction(args[3]))){
 ao.srcObj=args[1];
 ao.srcFunc=args[2];
-var _2f6=dl.nameAnonFunc(args[3],dj_global,_2f3);
+var _265=dl.nameAnonFunc(args[3],dj_global,_262);
 ao.adviceObj=dj_global;
-ao.adviceFunc=_2f6;
+ao.adviceFunc=_265;
 }else{
 if(dl.isObject(args[1])){
 ao.srcObj=args[1];
@@ -3186,12 +2769,11 @@
 ao.delay=args[8];
 ao.rate=args[9];
 ao.adviceMsg=args[10];
-ao.maxCalls=(!isNaN(parseInt(args[11])))?args[11]:-1;
 break;
 }
 if(dl.isFunction(ao.aroundFunc)){
-var _2f6=dl.nameAnonFunc(ao.aroundFunc,ao.aroundObj,_2f3);
-ao.aroundFunc=_2f6;
+var _265=dl.nameAnonFunc(ao.aroundFunc,ao.aroundObj,_262);
+ao.aroundFunc=_265;
 }
 if(dl.isFunction(ao.srcFunc)){
 ao.srcFunc=dl.getNameInObj(ao.srcObj,ao.srcFunc);
@@ -3208,10 +2790,6 @@
 if(!ao.adviceObj){
 dojo.raise("bad adviceObj for adviceFunc: "+ao.adviceFunc);
 }
-if(!ao.adviceFunc){
-dojo.debug("bad adviceFunc for srcFunc: "+ao.srcFunc);
-dojo.debugShallow(ao);
-}
 return ao;
 }
 this.connect=function(){
@@ -3220,25 +2798,18 @@
 }else{
 var ao=interpolateArgs(arguments,true);
 }
-if(dojo.lang.isString(ao.srcFunc)&&(ao.srcFunc.toLowerCase()=="onkey")){
-if(dojo.render.html.ie){
-ao.srcFunc="onkeydown";
-this.connect(ao);
-}
-ao.srcFunc="onkeypress";
-}
 if(dojo.lang.isArray(ao.srcObj)&&ao.srcObj!=""){
-var _2f8={};
+var _267={};
 for(var x in ao){
-_2f8[x]=ao[x];
+_267[x]=ao[x];
 }
 var mjps=[];
 dojo.lang.forEach(ao.srcObj,function(src){
 if((dojo.render.html.capable)&&(dojo.lang.isString(src))){
 src=dojo.byId(src);
 }
-_2f8.srcObj=src;
-mjps.push(dojo.event.connect.call(dojo.event,_2f8));
+_267.srcObj=src;
+mjps.push(dojo.event.connect.call(dojo.event,_267));
 });
 return mjps;
 }
@@ -3250,20 +2821,20 @@
 return mjp;
 };
 this.log=function(a1,a2){
-var _300;
+var _26f;
 if((arguments.length==1)&&(typeof a1=="object")){
-_300=a1;
+_26f=a1;
 }else{
-_300={srcObj:a1,srcFunc:a2};
+_26f={srcObj:a1,srcFunc:a2};
 }
-_300.adviceFunc=function(){
-var _301=[];
+_26f.adviceFunc=function(){
+var _270=[];
 for(var x=0;x<arguments.length;x++){
-_301.push(arguments[x]);
+_270.push(arguments[x]);
 }
-dojo.debug("("+_300.srcObj+")."+_300.srcFunc,":",_301.join(", "));
+dojo.debug("("+_26f.srcObj+")."+_26f.srcFunc,":",_270.join(", "));
 };
-this.kwConnect(_300);
+this.kwConnect(_26f);
 };
 this.connectBefore=function(){
 var args=["before"];
@@ -3284,60 +2855,37 @@
 ao.once=true;
 return this.connect(ao);
 };
-this.connectRunOnce=function(){
-var ao=interpolateArgs(arguments,true);
-ao.maxCalls=1;
-return this.connect(ao);
-};
-this._kwConnectImpl=function(_309,_30a){
-var fn=(_30a)?"disconnect":"connect";
-if(typeof _309["srcFunc"]=="function"){
-_309.srcObj=_309["srcObj"]||dj_global;
-var _30c=dojo.lang.nameAnonFunc(_309.srcFunc,_309.srcObj,true);
-_309.srcFunc=_30c;
+this._kwConnectImpl=function(_277,_278){
+var fn=(_278)?"disconnect":"connect";
+if(typeof _277["srcFunc"]=="function"){
+_277.srcObj=_277["srcObj"]||dj_global;
+var _27a=dojo.lang.nameAnonFunc(_277.srcFunc,_277.srcObj,true);
+_277.srcFunc=_27a;
 }
-if(typeof _309["adviceFunc"]=="function"){
-_309.adviceObj=_309["adviceObj"]||dj_global;
-var _30c=dojo.lang.nameAnonFunc(_309.adviceFunc,_309.adviceObj,true);
-_309.adviceFunc=_30c;
+if(typeof _277["adviceFunc"]=="function"){
+_277.adviceObj=_277["adviceObj"]||dj_global;
+var _27a=dojo.lang.nameAnonFunc(_277.adviceFunc,_277.adviceObj,true);
+_277.adviceFunc=_27a;
 }
-_309.srcObj=_309["srcObj"]||dj_global;
-_309.adviceObj=_309["adviceObj"]||_309["targetObj"]||dj_global;
-_309.adviceFunc=_309["adviceFunc"]||_309["targetFunc"];
-return dojo.event[fn](_309);
+return dojo.event[fn]((_277["type"]||_277["adviceType"]||"after"),_277["srcObj"]||dj_global,_277["srcFunc"],_277["adviceObj"]||_277["targetObj"]||dj_global,_277["adviceFunc"]||_277["targetFunc"],_277["aroundObj"],_277["aroundFunc"],_277["once"],_277["delay"],_277["rate"],_277["adviceMsg"]||false);
 };
-this.kwConnect=function(_30d){
-return this._kwConnectImpl(_30d,false);
+this.kwConnect=function(_27b){
+return this._kwConnectImpl(_27b,false);
 };
 this.disconnect=function(){
-if(arguments.length==1){
-var ao=arguments[0];
-}else{
 var ao=interpolateArgs(arguments,true);
-}
 if(!ao.adviceFunc){
 return;
 }
-if(dojo.lang.isString(ao.srcFunc)&&(ao.srcFunc.toLowerCase()=="onkey")){
-if(dojo.render.html.ie){
-ao.srcFunc="onkeydown";
-this.disconnect(ao);
-}
-ao.srcFunc="onkeypress";
-}
-if(!ao.srcObj[ao.srcFunc]){
-return null;
-}
-var mjp=dojo.event.MethodJoinPoint.getForMethod(ao.srcObj,ao.srcFunc,true);
-mjp.removeAdvice(ao.adviceObj,ao.adviceFunc,ao.adviceType,ao.once);
-return mjp;
+var mjp=dojo.event.MethodJoinPoint.getForMethod(ao.srcObj,ao.srcFunc);
+return mjp.removeAdvice(ao.adviceObj,ao.adviceFunc,ao.adviceType,ao.once);
 };
-this.kwDisconnect=function(_310){
-return this._kwConnectImpl(_310,true);
+this.kwDisconnect=function(_27e){
+return this._kwConnectImpl(_27e,true);
 };
 };
-dojo.event.MethodInvocation=function(_311,obj,args){
-this.jp_=_311;
+dojo.event.MethodInvocation=function(_27f,obj,args){
+this.jp_=_27f;
 this.object=obj;
 this.args=[];
 for(var x=0;x<args.length;x++){
@@ -3356,50 +2904,46 @@
 return mobj[meth].call(mobj,this);
 }
 };
-dojo.event.MethodJoinPoint=function(obj,_319){
+dojo.event.MethodJoinPoint=function(obj,_287){
 this.object=obj||dj_global;
-this.methodname=_319;
-this.methodfunc=this.object[_319];
-this.squelch=false;
+this.methodname=_287;
+this.methodfunc=this.object[_287];
+this.before=[];
+this.after=[];
+this.around=[];
 };
-dojo.event.MethodJoinPoint.getForMethod=function(obj,_31b){
+dojo.event.MethodJoinPoint.getForMethod=function(obj,_289){
 if(!obj){
 obj=dj_global;
 }
-var ofn=obj[_31b];
-if(!ofn){
-ofn=obj[_31b]=function(){
+if(!obj[_289]){
+obj[_289]=function(){
 };
-if(!obj[_31b]){
-dojo.raise("Cannot set do-nothing method on that object "+_31b);
+if(!obj[_289]){
+dojo.raise("Cannot set do-nothing method on that object "+_289);
 }
 }else{
-if((typeof ofn!="function")&&(!dojo.lang.isFunction(ofn))&&(!dojo.lang.isAlien(ofn))){
+if((!dojo.lang.isFunction(obj[_289]))&&(!dojo.lang.isAlien(obj[_289]))){
 return null;
 }
 }
-var _31d=_31b+"$joinpoint";
-var _31e=_31b+"$joinpoint$method";
-var _31f=obj[_31d];
-if(!_31f){
-var _320=false;
+var _28a=_289+"$joinpoint";
+var _28b=_289+"$joinpoint$method";
+var _28c=obj[_28a];
+if(!_28c){
+var _28d=false;
 if(dojo.event["browser"]){
 if((obj["attachEvent"])||(obj["nodeType"])||(obj["addEventListener"])){
-_320=true;
-dojo.event.browser.addClobberNodeAttrs(obj,[_31d,_31e,_31b]);
+_28d=true;
+dojo.event.browser.addClobberNodeAttrs(obj,[_28a,_28b,_289]);
 }
 }
-var _321=ofn.length;
-obj[_31e]=ofn;
-_31f=obj[_31d]=new dojo.event.MethodJoinPoint(obj,_31e);
-if(!_320){
-obj[_31b]=function(){
-return _31f.run.apply(_31f,arguments);
-};
-}else{
-obj[_31b]=function(){
+var _28e=obj[_289].length;
+obj[_28b]=obj[_289];
+_28c=obj[_28a]=new dojo.event.MethodJoinPoint(obj,_28b);
+obj[_289]=function(){
 var args=[];
-if(!arguments.length){
+if((_28d)&&(!arguments.length)){
 var evt=null;
 try{
 if(obj.ownerDocument){
@@ -3408,14 +2952,10 @@
 if(obj.documentElement){
 evt=obj.documentElement.ownerDocument.parentWindow.event;
 }else{
-if(obj.event){
-evt=obj.event;
-}else{
 evt=window.event;
 }
 }
 }
-}
 catch(e){
 evt=window.event;
 }
@@ -3424,21 +2964,20 @@
 }
 }else{
 for(var x=0;x<arguments.length;x++){
-if((x==0)&&(dojo.event.browser.isEvent(arguments[x]))){
+if((x==0)&&(_28d)&&(dojo.event.browser.isEvent(arguments[x]))){
 args.push(dojo.event.browser.fixEvent(arguments[x],this));
 }else{
 args.push(arguments[x]);
 }
 }
 }
-return _31f.run.apply(_31f,args);
+return _28c.run.apply(_28c,args);
 };
+obj[_289].__preJoinArity=_28e;
 }
-obj[_31b].__preJoinArity=_321;
-}
-return _31f;
+return _28c;
 };
-dojo.lang.extend(dojo.event.MethodJoinPoint,{squelch:false,unintercept:function(){
+dojo.lang.extend(dojo.event.MethodJoinPoint,{unintercept:function(){
 this.object[this.methodname]=this.methodfunc;
 this.before=[];
 this.after=[];
@@ -3446,43 +2985,36 @@
 },disconnect:dojo.lang.forward("unintercept"),run:function(){
 var obj=this.object||dj_global;
 var args=arguments;
-var _327=[];
+var _294=[];
 for(var x=0;x<args.length;x++){
-_327[x]=args[x];
+_294[x]=args[x];
 }
-var _329=function(marr){
+var _296=function(marr){
 if(!marr){
 dojo.debug("Null argument to unrollAdvice()");
 return;
 }
-var _32b=marr[0]||dj_global;
-var _32c=marr[1];
-if(!_32b[_32c]){
-dojo.raise("function \""+_32c+"\" does not exist on \""+_32b+"\"");
+var _298=marr[0]||dj_global;
+var _299=marr[1];
+if(!_298[_299]){
+dojo.raise("function \""+_299+"\" does not exist on \""+_298+"\"");
 }
-var _32d=marr[2]||dj_global;
-var _32e=marr[3];
+var _29a=marr[2]||dj_global;
+var _29b=marr[3];
 var msg=marr[6];
-var _330=marr[7];
-if(_330>-1){
-if(_330==0){
-return;
-}
-marr[7]--;
-}
-var _331;
+var _29d;
 var to={args:[],jp_:this,object:obj,proceed:function(){
-return _32b[_32c].apply(_32b,to.args);
+return _298[_299].apply(_298,to.args);
 }};
-to.args=_327;
-var _333=parseInt(marr[4]);
-var _334=((!isNaN(_333))&&(marr[4]!==null)&&(typeof marr[4]!="undefined"));
+to.args=_294;
+var _29f=parseInt(marr[4]);
+var _2a0=((!isNaN(_29f))&&(marr[4]!==null)&&(typeof marr[4]!="undefined"));
 if(marr[5]){
 var rate=parseInt(marr[5]);
 var cur=new Date();
-var _337=false;
+var _2a3=false;
 if((marr["last"])&&((cur-marr.last)<=rate)){
-if(dojo.event._canTimeout){
+if(dojo.event.canTimeout){
 if(marr["delayTimer"]){
 clearTimeout(marr.delayTimer);
 }
@@ -3490,7 +3022,7 @@
 var mcpy=dojo.lang.shallowCopy(marr);
 marr.delayTimer=setTimeout(function(){
 mcpy[5]=0;
-_329(mcpy);
+_296(mcpy);
 },tod);
 }
 return;
@@ -3498,109 +3030,86 @@
 marr.last=cur;
 }
 }
-if(_32e){
-_32d[_32e].call(_32d,to);
+if(_29b){
+_29a[_29b].call(_29a,to);
 }else{
-if((_334)&&((dojo.render.html)||(dojo.render.svg))){
+if((_2a0)&&((dojo.render.html)||(dojo.render.svg))){
 dj_global["setTimeout"](function(){
 if(msg){
-_32b[_32c].call(_32b,to);
+_298[_299].call(_298,to);
 }else{
-_32b[_32c].apply(_32b,args);
+_298[_299].apply(_298,args);
 }
-},_333);
+},_29f);
 }else{
 if(msg){
-_32b[_32c].call(_32b,to);
+_298[_299].call(_298,to);
 }else{
-_32b[_32c].apply(_32b,args);
+_298[_299].apply(_298,args);
 }
 }
 }
 };
-var _33a=function(){
-if(this.squelch){
-try{
-return _329.apply(this,arguments);
+if(this.before.length>0){
+dojo.lang.forEach(this.before,_296);
 }
-catch(e){
-dojo.debug(e);
-}
-}else{
-return _329.apply(this,arguments);
-}
-};
-if((this["before"])&&(this.before.length>0)){
-dojo.lang.forEach(this.before.concat(new Array()),_33a);
-}
-var _33b;
-try{
-if((this["around"])&&(this.around.length>0)){
+var _2a6;
+if(this.around.length>0){
 var mi=new dojo.event.MethodInvocation(this,obj,args);
-_33b=mi.proceed();
+_2a6=mi.proceed();
 }else{
 if(this.methodfunc){
-_33b=this.object[this.methodname].apply(this.object,args);
+_2a6=this.object[this.methodname].apply(this.object,args);
 }
 }
+if(this.after.length>0){
+dojo.lang.forEach(this.after,_296);
 }
-catch(e){
-if(!this.squelch){
-dojo.debug(e,"when calling",this.methodname,"on",this.object,"with arguments",args);
-dojo.raise(e);
-}
-}
-if((this["after"])&&(this.after.length>0)){
-dojo.lang.forEach(this.after.concat(new Array()),_33a);
-}
-return (this.methodfunc)?_33b:null;
+return (this.methodfunc)?_2a6:null;
 },getArr:function(kind){
-var type="after";
+var arr=this.after;
 if((typeof kind=="string")&&(kind.indexOf("before")!=-1)){
-type="before";
+arr=this.before;
 }else{
 if(kind=="around"){
-type="around";
+arr=this.around;
 }
 }
-if(!this[type]){
-this[type]=[];
-}
-return this[type];
+return arr;
 },kwAddAdvice:function(args){
-this.addAdvice(args["adviceObj"],args["adviceFunc"],args["aroundObj"],args["aroundFunc"],args["adviceType"],args["precedence"],args["once"],args["delay"],args["rate"],args["adviceMsg"],args["maxCalls"]);
-},addAdvice:function(_340,_341,_342,_343,_344,_345,once,_347,rate,_349,_34a){
-var arr=this.getArr(_344);
+this.addAdvice(args["adviceObj"],args["adviceFunc"],args["aroundObj"],args["aroundFunc"],args["adviceType"],args["precedence"],args["once"],args["delay"],args["rate"],args["adviceMsg"]);
+},addAdvice:function(_2ab,_2ac,_2ad,_2ae,_2af,_2b0,once,_2b2,rate,_2b4){
+var arr=this.getArr(_2af);
 if(!arr){
 dojo.raise("bad this: "+this);
 }
-var ao=[_340,_341,_342,_343,_347,rate,_349,_34a];
+var ao=[_2ab,_2ac,_2ad,_2ae,_2b2,rate,_2b4];
 if(once){
-if(this.hasAdvice(_340,_341,_344,arr)>=0){
+if(this.hasAdvice(_2ab,_2ac,_2af,arr)>=0){
 return;
 }
 }
-if(_345=="first"){
+if(_2b0=="first"){
 arr.unshift(ao);
 }else{
 arr.push(ao);
 }
-},hasAdvice:function(_34d,_34e,_34f,arr){
+},hasAdvice:function(_2b7,_2b8,_2b9,arr){
 if(!arr){
-arr=this.getArr(_34f);
+arr=this.getArr(_2b9);
 }
 var ind=-1;
 for(var x=0;x<arr.length;x++){
-var aao=(typeof _34e=="object")?(new String(_34e)).toString():_34e;
+var aao=(typeof _2b8=="object")?(new String(_2b8)).toString():_2b8;
 var a1o=(typeof arr[x][1]=="object")?(new String(arr[x][1])).toString():arr[x][1];
-if((arr[x][0]==_34d)&&(a1o==aao)){
+if((arr[x][0]==_2b7)&&(a1o==aao)){
 ind=x;
 }
 }
 return ind;
-},removeAdvice:function(_355,_356,_357,once){
-var arr=this.getArr(_357);
-var ind=this.hasAdvice(_355,_356,_357,arr);
+},removeAdvice:function(_2bf,_2c0,_2c1,once){
+var arr=this.getArr(_2c1);
+var ind=this.hasAdvice(_2bf,_2c0,_2c1,arr);
 if(ind==-1){
 return false;
 }
@@ -3609,76 +3118,72 @@
 if(once){
 break;
 }
-ind=this.hasAdvice(_355,_356,_357,arr);
+ind=this.hasAdvice(_2bf,_2c0,_2c1,arr);
 }
 return true;
 }});
+dojo.require("dojo.event");
 dojo.provide("dojo.event.topic");
 dojo.event.topic=new function(){
 this.topics={};
-this.getTopic=function(_35b){
-if(!this.topics[_35b]){
-this.topics[_35b]=new this.TopicImpl(_35b);
+this.getTopic=function(_2c5){
+if(!this.topics[_2c5]){
+this.topics[_2c5]=new this.TopicImpl(_2c5);
 }
-return this.topics[_35b];
+return this.topics[_2c5];
 };
-this.registerPublisher=function(_35c,obj,_35e){
-var _35c=this.getTopic(_35c);
-_35c.registerPublisher(obj,_35e);
+this.registerPublisher=function(_2c6,obj,_2c8){
+var _2c6=this.getTopic(_2c6);
+_2c6.registerPublisher(obj,_2c8);
 };
-this.subscribe=function(_35f,obj,_361){
-var _35f=this.getTopic(_35f);
-_35f.subscribe(obj,_361);
+this.subscribe=function(_2c9,obj,_2cb){
+var _2c9=this.getTopic(_2c9);
+_2c9.subscribe(obj,_2cb);
 };
-this.unsubscribe=function(_362,obj,_364){
-var _362=this.getTopic(_362);
-_362.unsubscribe(obj,_364);
+this.unsubscribe=function(_2cc,obj,_2ce){
+var _2cc=this.getTopic(_2cc);
+_2cc.unsubscribe(obj,_2ce);
 };
-this.destroy=function(_365){
-this.getTopic(_365).destroy();
-delete this.topics[_365];
+this.destroy=function(_2cf){
+this.getTopic(_2cf).destroy();
+delete this.topics[_2cf];
 };
-this.publishApply=function(_366,args){
-var _366=this.getTopic(_366);
-_366.sendMessage.apply(_366,args);
+this.publishApply=function(_2d0,args){
+var _2d0=this.getTopic(_2d0);
+_2d0.sendMessage.apply(_2d0,args);
 };
-this.publish=function(_368,_369){
-var _368=this.getTopic(_368);
+this.publish=function(_2d2,_2d3){
+var _2d2=this.getTopic(_2d2);
 var args=[];
 for(var x=1;x<arguments.length;x++){
 args.push(arguments[x]);
 }
-_368.sendMessage.apply(_368,args);
+_2d2.sendMessage.apply(_2d2,args);
 };
 };
-dojo.event.topic.TopicImpl=function(_36c){
-this.topicName=_36c;
-this.subscribe=function(_36d,_36e){
-var tf=_36e||_36d;
-var to=(!_36e)?dj_global:_36d;
-return dojo.event.kwConnect({srcObj:this,srcFunc:"sendMessage",adviceObj:to,adviceFunc:tf});
+dojo.event.topic.TopicImpl=function(_2d6){
+this.topicName=_2d6;
+this.subscribe=function(_2d7,_2d8){
+var tf=_2d8||_2d7;
+var to=(!_2d8)?dj_global:_2d7;
+dojo.event.kwConnect({srcObj:this,srcFunc:"sendMessage",adviceObj:to,adviceFunc:tf});
 };
-this.unsubscribe=function(_371,_372){
-var tf=(!_372)?_371:_372;
-var to=(!_372)?null:_371;
-return dojo.event.kwDisconnect({srcObj:this,srcFunc:"sendMessage",adviceObj:to,adviceFunc:tf});
+this.unsubscribe=function(_2db,_2dc){
+var tf=(!_2dc)?_2db:_2dc;
+var to=(!_2dc)?null:_2db;
+dojo.event.kwDisconnect({srcObj:this,srcFunc:"sendMessage",adviceObj:to,adviceFunc:tf});
 };
-this._getJoinPoint=function(){
-return dojo.event.MethodJoinPoint.getForMethod(this,"sendMessage");
-};
-this.setSquelch=function(_375){
-this._getJoinPoint().squelch=_375;
-};
 this.destroy=function(){
-this._getJoinPoint().disconnect();
+dojo.event.MethodJoinPoint.getForMethod(this,"sendMessage").disconnect();
 };
-this.registerPublisher=function(_376,_377){
-dojo.event.connect(_376,_377,this,"sendMessage");
+this.registerPublisher=function(_2df,_2e0){
+dojo.event.connect(_2df,_2e0,this,"sendMessage");
 };
-this.sendMessage=function(_378){
+this.sendMessage=function(_2e1){
 };
 };
 dojo.provide("dojo.event.browser");
+dojo.require("dojo.event");
 dojo._ie_clobber=new function(){
 this.clobberNodes=[];
 function nukeProp(node,prop){
@@ -3698,12 +3203,12 @@
 catch(e){
 }
 }
-this.clobber=function(_37b){
+this.clobber=function(_2e4){
 var na;
 var tna;
-if(_37b){
-tna=_37b.all||_37b.getElementsByTagName("*");
-na=[_37b];
+if(_2e4){
+tna=_2e4.all||_2e4.getElementsByTagName("*");
+na=[_2e4];
 for(var x=0;x<tna.length;x++){
 if(tna[x]["__doClobber__"]){
 na.push(tna[x]);
@@ -3718,11 +3223,10 @@
 na=(this.clobberNodes.length)?this.clobberNodes:document.all;
 }
 tna=null;
-var _37f={};
+var _2e8={};
 for(var i=na.length-1;i>=0;i=i-1){
 var el=na[i];
-try{
-if(el&&el["__clobberAttrs__"]){
+if(el["__clobberAttrs__"]){
 for(var j=0;j<el.__clobberAttrs__.length;j++){
 nukeProp(el,el.__clobberAttrs__[j]);
 }
@@ -3730,9 +3234,6 @@
 nukeProp(el,"__doClobber__");
 }
 }
-catch(e){
-}
-}
 na=null;
 };
 };
@@ -3746,15 +3247,6 @@
 }
 catch(e){
 }
-if(dojo.widget){
-for(var name in dojo.widget._templateCache){
-if(dojo.widget._templateCache[name].node){
-dojo.dom.destroyNode(dojo.widget._templateCache[name].node);
-dojo.widget._templateCache[name].node=null;
-delete dojo.widget._templateCache[name].node;
-}
-}
-}
 try{
 window.onload=null;
 }
@@ -3769,25 +3261,7 @@
 });
 }
 dojo.event.browser=new function(){
-var _384=0;
-this.normalizedEventName=function(_385){
-switch(_385){
-case "CheckboxStateChange":
-case "DOMAttrModified":
-case "DOMMenuItemActive":
-case "DOMMenuItemInactive":
-case "DOMMouseScroll":
-case "DOMNodeInserted":
-case "DOMNodeRemoved":
-case "RadioStateChange":
-return _385;
-break;
-default:
-var lcn=_385.toLowerCase();
-return (lcn.indexOf("on")==0)?lcn.substr(2):lcn;
-break;
-}
-};
+var _2ec=0;
 this.clean=function(node){
 if(dojo.render.html.ie){
 dojo._ie_clobber.clobber(node);
@@ -3803,320 +3277,112 @@
 node.__clobberAttrs__=[];
 }
 };
-this.addClobberNodeAttrs=function(node,_38a){
+this.addClobberNodeAttrs=function(node,_2f0){
 if(!dojo.render.html.ie){
 return;
 }
 this.addClobberNode(node);
-for(var x=0;x<_38a.length;x++){
-node.__clobberAttrs__.push(_38a[x]);
+for(var x=0;x<_2f0.length;x++){
+node.__clobberAttrs__.push(_2f0[x]);
 }
 };
-this.removeListener=function(node,_38d,fp,_38f){
-if(!_38f){
-var _38f=false;
+this.removeListener=function(node,_2f3,fp,_2f5){
+if(!_2f5){
+var _2f5=false;
 }
-_38d=dojo.event.browser.normalizedEventName(_38d);
-if(_38d=="key"){
-if(dojo.render.html.ie){
-this.removeListener(node,"onkeydown",fp,_38f);
+_2f3=_2f3.toLowerCase();
+if(_2f3.substr(0,2)=="on"){
+_2f3=_2f3.substr(2);
 }
-_38d="keypress";
-}
 if(node.removeEventListener){
-node.removeEventListener(_38d,fp,_38f);
+node.removeEventListener(_2f3,fp,_2f5);
 }
 };
-this.addListener=function(node,_391,fp,_393,_394){
+this.addListener=function(node,_2f7,fp,_2f9,_2fa){
 if(!node){
 return;
 }
-if(!_393){
-var _393=false;
+if(!_2f9){
+var _2f9=false;
 }
-_391=dojo.event.browser.normalizedEventName(_391);
-if(_391=="key"){
-if(dojo.render.html.ie){
-this.addListener(node,"onkeydown",fp,_393,_394);
+_2f7=_2f7.toLowerCase();
+if(_2f7.substr(0,2)!="on"){
+_2f7="on"+_2f7;
 }
-_391="keypress";
-}
-if(!_394){
-var _395=function(evt){
+if(!_2fa){
+var _2fb=function(evt){
 if(!evt){
 evt=window.event;
 }
 var ret=fp(dojo.event.browser.fixEvent(evt,this));
-if(_393){
+if(_2f9){
 dojo.event.browser.stopEvent(evt);
 }
 return ret;
 };
 }else{
-_395=fp;
+_2fb=fp;
 }
 if(node.addEventListener){
-node.addEventListener(_391,_395,_393);
-return _395;
+node.addEventListener(_2f7.substr(2),_2fb,_2f9);
+return _2fb;
 }else{
-_391="on"+_391;
-if(typeof node[_391]=="function"){
-var _398=node[_391];
-node[_391]=function(e){
-_398(e);
-return _395(e);
+if(typeof node[_2f7]=="function"){
+var _2fe=node[_2f7];
+node[_2f7]=function(e){
+_2fe(e);
+return _2fb(e);
 };
 }else{
-node[_391]=_395;
+node[_2f7]=_2fb;
 }
 if(dojo.render.html.ie){
-this.addClobberNodeAttrs(node,[_391]);
+this.addClobberNodeAttrs(node,[_2f7]);
 }
-return _395;
+return _2fb;
 }
 };
 this.isEvent=function(obj){
-return (typeof obj!="undefined")&&(obj)&&(typeof Event!="undefined")&&(obj.eventPhase);
+return (typeof obj!="undefined")&&(typeof Event!="undefined")&&(obj.eventPhase);
 };
 this.currentEvent=null;
-this.callListener=function(_39b,_39c){
-if(typeof _39b!="function"){
-dojo.raise("listener not a function: "+_39b);
+this.callListener=function(_301,_302){
+if(typeof _301!="function"){
+dojo.raise("listener not a function: "+_301);
 }
-dojo.event.browser.currentEvent.currentTarget=_39c;
-return _39b.call(_39c,dojo.event.browser.currentEvent);
+dojo.event.browser.currentEvent.currentTarget=_302;
+return _301.call(_302,dojo.event.browser.currentEvent);
 };
-this._stopPropagation=function(){
+this.stopPropagation=function(){
 dojo.event.browser.currentEvent.cancelBubble=true;
 };
-this._preventDefault=function(){
+this.preventDefault=function(){
 dojo.event.browser.currentEvent.returnValue=false;
 };
-this.keys={KEY_BACKSPACE:8,KEY_TAB:9,KEY_CLEAR:12,KEY_ENTER:13,KEY_SHIFT:16,KEY_CTRL:17,KEY_ALT:18,KEY_PAUSE:19,KEY_CAPS_LOCK:20,KEY_ESCAPE:27,KEY_SPACE:32,KEY_PAGE_UP:33,KEY_PAGE_DOWN:34,KEY_END:35,KEY_HOME:36,KEY_LEFT_ARROW:37,KEY_UP_ARROW:38,KEY_RIGHT_ARROW:39,KEY_DOWN_ARROW:40,KEY_INSERT:45,KEY_DELETE:46,KEY_HELP:47,KEY_LEFT_WINDOW:91,KEY_RIGHT_WINDOW:92,KEY_SELECT:93,KEY_NUMPAD_0:96,KEY_NUMPAD_1:97,KEY_NUMPAD_2:98,KEY_NUMPAD_3:99,KEY_NUMPAD_4:100,KEY_NUMPAD_5:101,KEY_NUMPAD_6:102,KEY_NUMPAD_7:103,KEY_NUMPAD_8:104,KEY_NUMPAD_9:105,KEY_NUMPAD_MULTIPLY:106,KEY_NUMPAD_PLUS:107,KEY_NUMPAD_ENTER:108,KEY_NUMPAD_MINUS:109,KEY_NUMPAD_PERIOD:110,KEY_NUMPAD_DIVIDE:111,KEY_F1:112,KEY_F2:113,KEY_F3:114,KEY_F4:115,KEY_F5:116,KEY_F6:117,KEY_F7:118,KEY_F8:119,KEY_F9:120,KEY_F10:121,KEY_F11:122,KEY_F12:123,KEY_F13:124,KEY_F14:125,KEY_F15:126,KEY_NUM_LOCK:144,KEY_SCROLL_LOCK:145};
+this.keys={KEY_BACKSPACE:8,KEY_TAB:9,KEY_ENTER:13,KEY_SHIFT:16,KEY_CTRL:17,KEY_ALT:18,KEY_PAUSE:19,KEY_CAPS_LOCK:20,KEY_ESCAPE:27,KEY_SPACE:32,KEY_PAGE_UP:33,KEY_PAGE_DOWN:34,KEY_END:35,KEY_HOME:36,KEY_LEFT_ARROW:37,KEY_UP_ARROW:38,KEY_RIGHT_ARROW:39,KEY_DOWN_ARROW:40,KEY_INSERT:45,KEY_DELETE:46,KEY_LEFT_WINDOW:91,KEY_RIGHT_WINDOW:92,KEY_SELECT:93,KEY_F1:112,KEY_F2:113,KEY_F3:114,KEY_F4:115,KEY_F5:116,KEY_F6:117,KEY_F7:118,KEY_F8:119,KEY_F9:120,KEY_F10:121,KEY_F11:122,KEY_F12:123,KEY_NUM_LOCK:144,KEY_SCROLL_LOCK:145};
 this.revKeys=[];
 for(var key in this.keys){
 this.revKeys[this.keys[key]]=key;
 }
-this.fixEvent=function(evt,_39f){
-if(!evt){
-if(window["event"]){
-evt=window.event;
+this.fixEvent=function(evt,_305){
+if((!evt)&&(window["event"])){
+var evt=window.event;
 }
-}
 if((evt["type"])&&(evt["type"].indexOf("key")==0)){
 evt.keys=this.revKeys;
 for(var key in this.keys){
 evt[key]=this.keys[key];
 }
-if(evt["type"]=="keydown"&&dojo.render.html.ie){
-switch(evt.keyCode){
-case evt.KEY_SHIFT:
-case evt.KEY_CTRL:
-case evt.KEY_ALT:
-case evt.KEY_CAPS_LOCK:
-case evt.KEY_LEFT_WINDOW:
-case evt.KEY_RIGHT_WINDOW:
-case evt.KEY_SELECT:
-case evt.KEY_NUM_LOCK:
-case evt.KEY_SCROLL_LOCK:
-case evt.KEY_NUMPAD_0:
-case evt.KEY_NUMPAD_1:
-case evt.KEY_NUMPAD_2:
-case evt.KEY_NUMPAD_3:
-case evt.KEY_NUMPAD_4:
-case evt.KEY_NUMPAD_5:
-case evt.KEY_NUMPAD_6:
-case evt.KEY_NUMPAD_7:
-case evt.KEY_NUMPAD_8:
-case evt.KEY_NUMPAD_9:
-case evt.KEY_NUMPAD_PERIOD:
-break;
-case evt.KEY_NUMPAD_MULTIPLY:
-case evt.KEY_NUMPAD_PLUS:
-case evt.KEY_NUMPAD_ENTER:
-case evt.KEY_NUMPAD_MINUS:
-case evt.KEY_NUMPAD_DIVIDE:
-break;
-case evt.KEY_PAUSE:
-case evt.KEY_TAB:
-case evt.KEY_BACKSPACE:
-case evt.KEY_ENTER:
-case evt.KEY_ESCAPE:
-case evt.KEY_PAGE_UP:
-case evt.KEY_PAGE_DOWN:
-case evt.KEY_END:
-case evt.KEY_HOME:
-case evt.KEY_LEFT_ARROW:
-case evt.KEY_UP_ARROW:
-case evt.KEY_RIGHT_ARROW:
-case evt.KEY_DOWN_ARROW:
-case evt.KEY_INSERT:
-case evt.KEY_DELETE:
-case evt.KEY_F1:
-case evt.KEY_F2:
-case evt.KEY_F3:
-case evt.KEY_F4:
-case evt.KEY_F5:
-case evt.KEY_F6:
-case evt.KEY_F7:
-case evt.KEY_F8:
-case evt.KEY_F9:
-case evt.KEY_F10:
-case evt.KEY_F11:
-case evt.KEY_F12:
-case evt.KEY_F12:
-case evt.KEY_F13:
-case evt.KEY_F14:
-case evt.KEY_F15:
-case evt.KEY_CLEAR:
-case evt.KEY_HELP:
-evt.key=evt.keyCode;
-break;
-default:
-if(evt.ctrlKey||evt.altKey){
-var _3a1=evt.keyCode;
-if(_3a1>=65&&_3a1<=90&&evt.shiftKey==false){
-_3a1+=32;
+if((dojo.render.html.ie)&&(evt["type"]=="keypress")){
+evt.charCode=evt.keyCode;
 }
-if(_3a1>=1&&_3a1<=26&&evt.ctrlKey){
-_3a1+=96;
 }
-evt.key=String.fromCharCode(_3a1);
-}
-}
-}else{
-if(evt["type"]=="keypress"){
-if(dojo.render.html.opera){
-if(evt.which==0){
-evt.key=evt.keyCode;
-}else{
-if(evt.which>0){
-switch(evt.which){
-case evt.KEY_SHIFT:
-case evt.KEY_CTRL:
-case evt.KEY_ALT:
-case evt.KEY_CAPS_LOCK:
-case evt.KEY_NUM_LOCK:
-case evt.KEY_SCROLL_LOCK:
-break;
-case evt.KEY_PAUSE:
-case evt.KEY_TAB:
-case evt.KEY_BACKSPACE:
-case evt.KEY_ENTER:
-case evt.KEY_ESCAPE:
-evt.key=evt.which;
-break;
-default:
-var _3a1=evt.which;
-if((evt.ctrlKey||evt.altKey||evt.metaKey)&&(evt.which>=65&&evt.which<=90&&evt.shiftKey==false)){
-_3a1+=32;
-}
-evt.key=String.fromCharCode(_3a1);
-}
-}
-}
-}else{
 if(dojo.render.html.ie){
-if(!evt.ctrlKey&&!evt.altKey&&evt.keyCode>=evt.KEY_SPACE){
-evt.key=String.fromCharCode(evt.keyCode);
-}
-}else{
-if(dojo.render.html.safari){
-switch(evt.keyCode){
-case 25:
-evt.key=evt.KEY_TAB;
-evt.shift=true;
-break;
-case 63232:
-evt.key=evt.KEY_UP_ARROW;
-break;
-case 63233:
-evt.key=evt.KEY_DOWN_ARROW;
-break;
-case 63234:
-evt.key=evt.KEY_LEFT_ARROW;
-break;
-case 63235:
-evt.key=evt.KEY_RIGHT_ARROW;
-break;
-case 63236:
-evt.key=evt.KEY_F1;
-break;
-case 63237:
-evt.key=evt.KEY_F2;
-break;
-case 63238:
-evt.key=evt.KEY_F3;
-break;
-case 63239:
-evt.key=evt.KEY_F4;
-break;
-case 63240:
-evt.key=evt.KEY_F5;
-break;
-case 63241:
-evt.key=evt.KEY_F6;
-break;
-case 63242:
-evt.key=evt.KEY_F7;
-break;
-case 63243:
-evt.key=evt.KEY_F8;
-break;
-case 63244:
-evt.key=evt.KEY_F9;
-break;
-case 63245:
-evt.key=evt.KEY_F10;
-break;
-case 63246:
-evt.key=evt.KEY_F11;
-break;
-case 63247:
-evt.key=evt.KEY_F12;
-break;
-case 63250:
-evt.key=evt.KEY_PAUSE;
-break;
-case 63272:
-evt.key=evt.KEY_DELETE;
-break;
-case 63273:
-evt.key=evt.KEY_HOME;
-break;
-case 63275:
-evt.key=evt.KEY_END;
-break;
-case 63276:
-evt.key=evt.KEY_PAGE_UP;
-break;
-case 63277:
-evt.key=evt.KEY_PAGE_DOWN;
-break;
-case 63302:
-evt.key=evt.KEY_INSERT;
-break;
-case 63248:
-case 63249:
-case 63289:
-break;
-default:
-evt.key=evt.charCode>=evt.KEY_SPACE?String.fromCharCode(evt.charCode):evt.keyCode;
-}
-}else{
-evt.key=evt.charCode>0?String.fromCharCode(evt.charCode):evt.keyCode;
-}
-}
-}
-}
-}
-}
-if(dojo.render.html.ie){
 if(!evt.target){
 evt.target=evt.srcElement;
 }
 if(!evt.currentTarget){
-evt.currentTarget=(_39f?_39f:evt.srcElement);
+evt.currentTarget=(_305?_305:evt.srcElement);
 }
 if(!evt.layerX){
 evt.layerX=evt.offsetX;
@@ -4124,13 +3390,12 @@
 if(!evt.layerY){
 evt.layerY=evt.offsetY;
 }
-var doc=(evt.srcElement&&evt.srcElement.ownerDocument)?evt.srcElement.ownerDocument:document;
-var _3a3=((dojo.render.html.ie55)||(doc["compatMode"]=="BackCompat"))?doc.body:doc.documentElement;
+var _307=((dojo.render.html.ie55)||(document["compatMode"]=="BackCompat"))?document.body:document.documentElement;
 if(!evt.pageX){
-evt.pageX=evt.clientX+(_3a3.scrollLeft||0);
+evt.pageX=evt.clientX+(_307.scrollLeft||0);
 }
 if(!evt.pageY){
-evt.pageY=evt.clientY+(_3a3.scrollTop||0);
+evt.pageY=evt.clientY+(_307.scrollTop||0);
 }
 if(evt.type=="mouseover"){
 evt.relatedTarget=evt.fromElement;
@@ -4140,163 +3405,30 @@
 }
 this.currentEvent=evt;
 evt.callListener=this.callListener;
-evt.stopPropagation=this._stopPropagation;
-evt.preventDefault=this._preventDefault;
+evt.stopPropagation=this.stopPropagation;
+evt.preventDefault=this.preventDefault;
 }
 return evt;
 };
-this.stopEvent=function(evt){
+this.stopEvent=function(ev){
 if(window.event){
-evt.cancelBubble=true;
-evt.returnValue=false;
+ev.returnValue=false;
+ev.cancelBubble=true;
 }else{
-evt.preventDefault();
-evt.stopPropagation();
+ev.preventDefault();
+ev.stopPropagation();
 }
 };
 };
-dojo.kwCompoundRequire({common:["dojo.event.common","dojo.event.topic"],browser:["dojo.event.browser"],dashboard:["dojo.event.browser"]});
+dojo.kwCompoundRequire({common:["dojo.event","dojo.event.topic"],browser:["dojo.event.browser"],dashboard:["dojo.event.browser"]});
 dojo.provide("dojo.event.*");
-dojo.provide("dojo.gfx.color");
-dojo.gfx.color.Color=function(r,g,b,a){
-if(dojo.lang.isArray(r)){
-this.r=r[0];
-this.g=r[1];
-this.b=r[2];
-this.a=r[3]||1;
-}else{
-if(dojo.lang.isString(r)){
-var rgb=dojo.gfx.color.extractRGB(r);
-this.r=rgb[0];
-this.g=rgb[1];
-this.b=rgb[2];
-this.a=g||1;
-}else{
-if(r instanceof dojo.gfx.color.Color){
-this.r=r.r;
-this.b=r.b;
-this.g=r.g;
-this.a=r.a;
-}else{
-this.r=r;
-this.g=g;
-this.b=b;
-this.a=a;
-}
-}
-}
-};
-dojo.gfx.color.Color.fromArray=function(arr){
-return new dojo.gfx.color.Color(arr[0],arr[1],arr[2],arr[3]);
-};
-dojo.extend(dojo.gfx.color.Color,{toRgb:function(_3ab){
-if(_3ab){
-return this.toRgba();
-}else{
-return [this.r,this.g,this.b];
-}
-},toRgba:function(){
-return [this.r,this.g,this.b,this.a];
-},toHex:function(){
-return dojo.gfx.color.rgb2hex(this.toRgb());
-},toCss:function(){
-return "rgb("+this.toRgb().join()+")";
-},toString:function(){
-return this.toHex();
-},blend:function(_3ac,_3ad){
-var rgb=null;
-if(dojo.lang.isArray(_3ac)){
-rgb=_3ac;
-}else{
-if(_3ac instanceof dojo.gfx.color.Color){
-rgb=_3ac.toRgb();
-}else{
-rgb=new dojo.gfx.color.Color(_3ac).toRgb();
-}
-}
-return dojo.gfx.color.blend(this.toRgb(),rgb,_3ad);
-}});
-dojo.gfx.color.named={white:[255,255,255],black:[0,0,0],red:[255,0,0],green:[0,255,0],lime:[0,255,0],blue:[0,0,255],navy:[0,0,128],gray:[128,128,128],silver:[192,192,192]};
-dojo.gfx.color.blend=function(a,b,_3b1){
-if(typeof a=="string"){
-return dojo.gfx.color.blendHex(a,b,_3b1);
-}
-if(!_3b1){
-_3b1=0;
-}
-_3b1=Math.min(Math.max(-1,_3b1),1);
-_3b1=((_3b1+1)/2);
-var c=[];
-for(var x=0;x<3;x++){
-c[x]=parseInt(b[x]+((a[x]-b[x])*_3b1));
-}
-return c;
-};
-dojo.gfx.color.blendHex=function(a,b,_3b6){
-return dojo.gfx.color.rgb2hex(dojo.gfx.color.blend(dojo.gfx.color.hex2rgb(a),dojo.gfx.color.hex2rgb(b),_3b6));
-};
-dojo.gfx.color.extractRGB=function(_3b7){
-var hex="0123456789abcdef";
-_3b7=_3b7.toLowerCase();
-if(_3b7.indexOf("rgb")==0){
-var _3b9=_3b7.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
-var ret=_3b9.splice(1,3);
-return ret;
-}else{
-var _3bb=dojo.gfx.color.hex2rgb(_3b7);
-if(_3bb){
-return _3bb;
-}else{
-return dojo.gfx.color.named[_3b7]||[255,255,255];
-}
-}
-};
-dojo.gfx.color.hex2rgb=function(hex){
-var _3bd="0123456789ABCDEF";
-var rgb=new Array(3);
-if(hex.indexOf("#")==0){
-hex=hex.substring(1);
-}
-hex=hex.toUpperCase();
-if(hex.replace(new RegExp("["+_3bd+"]","g"),"")!=""){
-return null;
-}
-if(hex.length==3){
-rgb[0]=hex.charAt(0)+hex.charAt(0);
-rgb[1]=hex.charAt(1)+hex.charAt(1);
-rgb[2]=hex.charAt(2)+hex.charAt(2);
-}else{
-rgb[0]=hex.substring(0,2);
-rgb[1]=hex.substring(2,4);
-rgb[2]=hex.substring(4);
-}
-for(var i=0;i<rgb.length;i++){
-rgb[i]=_3bd.indexOf(rgb[i].charAt(0))*16+_3bd.indexOf(rgb[i].charAt(1));
-}
-return rgb;
-};
-dojo.gfx.color.rgb2hex=function(r,g,b){
-if(dojo.lang.isArray(r)){
-g=r[1]||0;
-b=r[2]||0;
-r=r[0]||0;
-}
-var ret=dojo.lang.map([r,g,b],function(x){
-x=new Number(x);
-var s=x.toString(16);
-while(s.length<2){
-s="0"+s;
-}
-return s;
-});
-ret.unshift("#");
-return ret.join("");
-};
 dojo.provide("dojo.lfx.Animation");
-dojo.lfx.Line=function(_3c6,end){
-this.start=_3c6;
+dojo.provide("dojo.lfx.Line");
+dojo.require("dojo.lang.func");
+dojo.lfx.Line=function(_309,end){
+this.start=_309;
 this.end=end;
-if(dojo.lang.isArray(_3c6)){
+if(dojo.lang.isArray(_309)){
 var diff=[];
 dojo.lang.forEach(this.start,function(s,i){
 diff[i]=this.end[i]-s;
@@ -4309,21 +3441,12 @@
 return res;
 };
 }else{
-var diff=end-_3c6;
+var diff=end-_309;
 this.getValue=function(n){
 return (diff*n)+this.start;
 };
 }
 };
-if((dojo.render.html.khtml)&&(!dojo.render.html.safari)){
-dojo.lfx.easeDefault=function(n){
-return (parseFloat("0.5")+((Math.sin((n+parseFloat("1.5"))*Math.PI))/2));
-};
-}else{
-dojo.lfx.easeDefault=function(n){
-return (0.5+((Math.sin((n+1.5)*Math.PI))/2));
-};
-}
 dojo.lfx.easeIn=function(n){
 return Math.pow(n,3);
 };
@@ -4335,76 +3458,61 @@
 };
 dojo.lfx.IAnimation=function(){
 };
-dojo.lang.extend(dojo.lfx.IAnimation,{curve:null,duration:1000,easing:null,repeatCount:0,rate:10,handler:null,beforeBegin:null,onBegin:null,onAnimate:null,onEnd:null,onPlay:null,onPause:null,onStop:null,play:null,pause:null,stop:null,connect:function(evt,_3d6,_3d7){
-if(!_3d7){
-_3d7=_3d6;
-_3d6=this;
-}
-_3d7=dojo.lang.hitch(_3d6,_3d7);
-var _3d8=this[evt]||function(){
-};
-this[evt]=function(){
-var ret=_3d8.apply(this,arguments);
-_3d7.apply(this,arguments);
-return ret;
-};
-return this;
-},fire:function(evt,args){
+dojo.lang.extend(dojo.lfx.IAnimation,{curve:null,duration:1000,easing:null,repeatCount:0,rate:25,handler:null,beforeBegin:null,onBegin:null,onAnimate:null,onEnd:null,onPlay:null,onPause:null,onStop:null,play:null,pause:null,stop:null,fire:function(evt,args){
 if(this[evt]){
 this[evt].apply(this,(args||[]));
 }
-return this;
-},repeat:function(_3dc){
-this.repeatCount=_3dc;
-return this;
 },_active:false,_paused:false});
-dojo.lfx.Animation=function(_3dd,_3de,_3df,_3e0,_3e1,rate){
+dojo.lfx.Animation=function(_318,_319,_31a,_31b,_31c,rate){
 dojo.lfx.IAnimation.call(this);
-if(dojo.lang.isNumber(_3dd)||(!_3dd&&_3de.getValue)){
-rate=_3e1;
-_3e1=_3e0;
-_3e0=_3df;
-_3df=_3de;
-_3de=_3dd;
-_3dd=null;
+if(dojo.lang.isNumber(_318)||(!_318&&_319.getValue)){
+rate=_31c;
+_31c=_31b;
+_31b=_31a;
+_31a=_319;
+_319=_318;
+_318=null;
 }else{
-if(_3dd.getValue||dojo.lang.isArray(_3dd)){
-rate=_3e0;
-_3e1=_3df;
-_3e0=_3de;
-_3df=_3dd;
-_3de=null;
-_3dd=null;
+if(_318.getValue||dojo.lang.isArray(_318)){
+rate=_31b;
+_31c=_31a;
+_31b=_319;
+_31a=_318;
+_319=null;
+_318=null;
 }
 }
-if(dojo.lang.isArray(_3df)){
-this.curve=new dojo.lfx.Line(_3df[0],_3df[1]);
+if(dojo.lang.isArray(_31a)){
+this.curve=new dojo.lfx.Line(_31a[0],_31a[1]);
 }else{
-this.curve=_3df;
+this.curve=_31a;
 }
-if(_3de!=null&&_3de>0){
-this.duration=_3de;
+if(_319!=null&&_319>0){
+this.duration=_319;
 }
-if(_3e1){
-this.repeatCount=_3e1;
+if(_31c){
+this.repeatCount=_31c;
 }
 if(rate){
 this.rate=rate;
 }
-if(_3dd){
-dojo.lang.forEach(["handler","beforeBegin","onBegin","onEnd","onPlay","onStop","onAnimate"],function(item){
-if(_3dd[item]){
-this.connect(item,_3dd[item]);
+if(_318){
+this.handler=_318.handler;
+this.beforeBegin=_318.beforeBegin;
+this.onBegin=_318.onBegin;
+this.onEnd=_318.onEnd;
+this.onPlay=_318.onPlay;
+this.onPause=_318.onPause;
+this.onStop=_318.onStop;
+this.onAnimate=_318.onAnimate;
 }
-},this);
+if(_31b&&dojo.lang.isFunction(_31b)){
+this.easing=_31b;
 }
-if(_3e0&&dojo.lang.isFunction(_3e0)){
-this.easing=_3e0;
-}
 };
 dojo.inherits(dojo.lfx.Animation,dojo.lfx.IAnimation);
-dojo.lang.extend(dojo.lfx.Animation,{_startTime:null,_endTime:null,_timer:null,_percent:0,_startRepeatCount:0,play:function(_3e4,_3e5){
-if(_3e5){
+dojo.lang.extend(dojo.lfx.Animation,{_startTime:null,_endTime:null,_timer:null,_percent:0,_startRepeatCount:0,play:function(_31e,_31f){
+if(_31f){
 clearTimeout(this._timer);
 this._active=false;
 this._paused=false;
@@ -4416,10 +3524,10 @@
 }
 this.fire("handler",["beforeBegin"]);
 this.fire("beforeBegin");
-if(_3e4>0){
+if(_31e>0){
 setTimeout(dojo.lang.hitch(this,function(){
-this.play(null,_3e5);
-}),_3e4);
+this.play(null,_31f);
+}),_31e);
 return this;
 }
 this._startTime=new Date().valueOf();
@@ -4430,16 +3538,16 @@
 this._active=true;
 this._paused=false;
 var step=this._percent/100;
-var _3e7=this.curve.getValue(step);
+var _321=this.curve.getValue(step);
 if(this._percent==0){
 if(!this._startRepeatCount){
 this._startRepeatCount=this.repeatCount;
 }
-this.fire("handler",["begin",_3e7]);
-this.fire("onBegin",[_3e7]);
+this.fire("handler",["begin",_321]);
+this.fire("onBegin",[_321]);
 }
-this.fire("handler",["play",_3e7]);
-this.fire("onPlay",[_3e7]);
+this.fire("handler",["play",_321]);
+this.fire("onPlay",[_321]);
 this._cycle();
 return this;
 },pause:function(){
@@ -4448,28 +3556,27 @@
 return this;
 }
 this._paused=true;
-var _3e8=this.curve.getValue(this._percent/100);
-this.fire("handler",["pause",_3e8]);
-this.fire("onPause",[_3e8]);
+var _322=this.curve.getValue(this._percent/100);
+this.fire("handler",["pause",_322]);
+this.fire("onPause",[_322]);
 return this;
-},gotoPercent:function(pct,_3ea){
+},gotoPercent:function(pct,_324){
 clearTimeout(this._timer);
 this._active=true;
 this._paused=true;
 this._percent=pct;
-if(_3ea){
+if(_324){
 this.play();
 }
-return this;
-},stop:function(_3eb){
+},stop:function(_325){
 clearTimeout(this._timer);
 var step=this._percent/100;
-if(_3eb){
+if(_325){
 step=1;
 }
-var _3ed=this.curve.getValue(step);
-this.fire("handler",["stop",_3ed]);
-this.fire("onStop",[_3ed]);
+var _327=this.curve.getValue(step);
+this.fire("handler",["stop",_327]);
+this.fire("onStop",[_327]);
 this._active=false;
 this._paused=false;
 return this;
@@ -4479,7 +3586,6 @@
 }else{
 return "stopped";
 }
-return this;
 },_cycle:function(){
 clearTimeout(this._timer);
 if(this._active){
@@ -4494,9 +3600,9 @@
 if((this.easing)&&(dojo.lang.isFunction(this.easing))){
 step=this.easing(step);
 }
-var _3f0=this.curve.getValue(step);
-this.fire("handler",["animate",_3f0]);
-this.fire("onAnimate",[_3f0]);
+var _32a=this.curve.getValue(step);
+this.fire("handler",["animate",_32a]);
+this.fire("onAnimate",[_32a]);
 if(step<1){
 this._timer=setTimeout(dojo.lang.hitch(this,"_cycle"),this.rate);
 }else{
@@ -4520,44 +3626,50 @@
 }
 return this;
 }});
-dojo.lfx.Combine=function(_3f1){
+dojo.lfx.Combine=function(){
 dojo.lfx.IAnimation.call(this);
 this._anims=[];
 this._animsEnded=0;
-var _3f2=arguments;
-if(_3f2.length==1&&(dojo.lang.isArray(_3f2[0])||dojo.lang.isArrayLike(_3f2[0]))){
-_3f2=_3f2[0];
+var _32b=arguments;
+if(_32b.length==1&&(dojo.lang.isArray(_32b[0])||dojo.lang.isArrayLike(_32b[0]))){
+_32b=_32b[0];
 }
-dojo.lang.forEach(_3f2,function(anim){
-this._anims.push(anim);
-anim.connect("onEnd",dojo.lang.hitch(this,"_onAnimsEnded"));
-},this);
+var _32c=this;
+dojo.lang.forEach(_32b,function(anim){
+_32c._anims.push(anim);
+var _32e=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
 };
+anim.onEnd=function(){
+_32e();
+_32c._onAnimsEnded();
+};
+});
+};
 dojo.inherits(dojo.lfx.Combine,dojo.lfx.IAnimation);
-dojo.lang.extend(dojo.lfx.Combine,{_animsEnded:0,play:function(_3f4,_3f5){
+dojo.lang.extend(dojo.lfx.Combine,{_animsEnded:0,play:function(_32f,_330){
 if(!this._anims.length){
 return this;
 }
 this.fire("beforeBegin");
-if(_3f4>0){
+if(_32f>0){
 setTimeout(dojo.lang.hitch(this,function(){
-this.play(null,_3f5);
-}),_3f4);
+this.play(null,_330);
+}),_32f);
 return this;
 }
-if(_3f5||this._anims[0].percent==0){
+if(_330||this._anims[0].percent==0){
 this.fire("onBegin");
 }
 this.fire("onPlay");
-this._animsCall("play",null,_3f5);
+this._animsCall("play",null,_330);
 return this;
 },pause:function(){
 this.fire("onPause");
 this._animsCall("pause");
 return this;
-},stop:function(_3f6){
+},stop:function(_331){
 this.fire("onStop");
-this._animsCall("stop",_3f6);
+this._animsCall("stop",_331);
 return this;
 },_onAnimsEnded:function(){
 this._animsEnded++;
@@ -4565,62 +3677,68 @@
 this.fire("onEnd");
 }
 return this;
-},_animsCall:function(_3f7){
+},_animsCall:function(_332){
 var args=[];
 if(arguments.length>1){
 for(var i=1;i<arguments.length;i++){
 args.push(arguments[i]);
 }
 }
-var _3fa=this;
+var _335=this;
 dojo.lang.forEach(this._anims,function(anim){
-anim[_3f7](args);
-},_3fa);
+anim[_332](args);
+},_335);
 return this;
 }});
-dojo.lfx.Chain=function(_3fc){
+dojo.lfx.Chain=function(){
 dojo.lfx.IAnimation.call(this);
 this._anims=[];
 this._currAnim=-1;
-var _3fd=arguments;
-if(_3fd.length==1&&(dojo.lang.isArray(_3fd[0])||dojo.lang.isArrayLike(_3fd[0]))){
-_3fd=_3fd[0];
+var _337=arguments;
+if(_337.length==1&&(dojo.lang.isArray(_337[0])||dojo.lang.isArrayLike(_337[0]))){
+_337=_337[0];
 }
-var _3fe=this;
-dojo.lang.forEach(_3fd,function(anim,i,_401){
-this._anims.push(anim);
-if(i<_401.length-1){
-anim.connect("onEnd",dojo.lang.hitch(this,"_playNext"));
+var _338=this;
+dojo.lang.forEach(_337,function(anim,i,_33b){
+_338._anims.push(anim);
+var _33c=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+if(i<_33b.length-1){
+anim.onEnd=function(){
+_33c();
+_338._playNext();
+};
 }else{
-anim.connect("onEnd",dojo.lang.hitch(this,function(){
-this.fire("onEnd");
-}));
+anim.onEnd=function(){
+_33c();
+_338.fire("onEnd");
+};
 }
-},this);
+},_338);
 };
 dojo.inherits(dojo.lfx.Chain,dojo.lfx.IAnimation);
-dojo.lang.extend(dojo.lfx.Chain,{_currAnim:-1,play:function(_402,_403){
+dojo.lang.extend(dojo.lfx.Chain,{_currAnim:-1,play:function(_33d,_33e){
 if(!this._anims.length){
 return this;
 }
-if(_403||!this._anims[this._currAnim]){
+if(_33e||!this._anims[this._currAnim]){
 this._currAnim=0;
 }
-var _404=this._anims[this._currAnim];
+var _33f=this._anims[this._currAnim];
 this.fire("beforeBegin");
-if(_402>0){
+if(_33d>0){
 setTimeout(dojo.lang.hitch(this,function(){
-this.play(null,_403);
-}),_402);
+this.play(null,_33e);
+}),_33d);
 return this;
 }
-if(_404){
+if(_33f){
 if(this._currAnim==0){
 this.fire("handler",["begin",this._currAnim]);
 this.fire("onBegin",[this._currAnim]);
 }
 this.fire("onPlay",[this._currAnim]);
-_404.play(null,_403);
+_33f.play(null,_33e);
 }
 return this;
 },pause:function(){
@@ -4636,9 +3754,9 @@
 if(this._currAnim==-1){
 this._currAnim=0;
 }
-var _405=this._anims[this._currAnim];
-if(_405){
-if(!_405._active||_405._paused){
+var _340=this._anims[this._currAnim];
+if(_340){
+if(!_340._active||_340._paused){
 this.play();
 }else{
 this.pause();
@@ -4646,12 +3764,12 @@
 }
 return this;
 },stop:function(){
-var _406=this._anims[this._currAnim];
-if(_406){
-_406.stop();
+var _341=this._anims[this._currAnim];
+if(_341){
+_341.stop();
 this.fire("onStop",[this._currAnim]);
 }
-return _406;
+return _341;
 },_playNext:function(){
 if(this._currAnim==-1||this._anims.length==0){
 return this;
@@ -4662,233 +3780,185 @@
 }
 return this;
 }});
-dojo.lfx.combine=function(_407){
-var _408=arguments;
+dojo.lfx.combine=function(){
+var _342=arguments;
 if(dojo.lang.isArray(arguments[0])){
-_408=arguments[0];
+_342=arguments[0];
 }
-if(_408.length==1){
-return _408[0];
-}
-return new dojo.lfx.Combine(_408);
+return new dojo.lfx.Combine(_342);
 };
-dojo.lfx.chain=function(_409){
-var _40a=arguments;
+dojo.lfx.chain=function(){
+var _343=arguments;
 if(dojo.lang.isArray(arguments[0])){
-_40a=arguments[0];
+_343=arguments[0];
 }
-if(_40a.length==1){
-return _40a[0];
-}
-return new dojo.lfx.Chain(_40a);
+return new dojo.lfx.Chain(_343);
 };
-dojo.provide("dojo.html.common");
-dojo.lang.mixin(dojo.html,dojo.dom);
-dojo.html.body=function(){
-dojo.deprecated("dojo.html.body() moved to dojo.body()","0.5");
-return dojo.body();
-};
-dojo.html.getEventTarget=function(evt){
-if(!evt){
-evt=dojo.global().event||{};
-}
-var t=(evt.srcElement?evt.srcElement:(evt.target?evt.target:null));
-while((t)&&(t.nodeType!=1)){
-t=t.parentNode;
-}
-return t;
-};
-dojo.html.getViewport=function(){
-var _40d=dojo.global();
-var _40e=dojo.doc();
-var w=0;
-var h=0;
-if(dojo.render.html.mozilla){
-w=_40e.documentElement.clientWidth;
-h=_40d.innerHeight;
+dojo.provide("dojo.graphics.color");
+dojo.require("dojo.lang.array");
+dojo.graphics.color.Color=function(r,g,b,a){
+if(dojo.lang.isArray(r)){
+this.r=r[0];
+this.g=r[1];
+this.b=r[2];
+this.a=r[3]||1;
 }else{
-if(!dojo.render.html.opera&&_40d.innerWidth){
-w=_40d.innerWidth;
-h=_40d.innerHeight;
+if(dojo.lang.isString(r)){
+var rgb=dojo.graphics.color.extractRGB(r);
+this.r=rgb[0];
+this.g=rgb[1];
+this.b=rgb[2];
+this.a=g||1;
 }else{
-if(!dojo.render.html.opera&&dojo.exists(_40e,"documentElement.clientWidth")){
-var w2=_40e.documentElement.clientWidth;
-if(!w||w2&&w2<w){
-w=w2;
-}
-h=_40e.documentElement.clientHeight;
+if(r instanceof dojo.graphics.color.Color){
+this.r=r.r;
+this.b=r.b;
+this.g=r.g;
+this.a=r.a;
 }else{
-if(dojo.body().clientWidth){
-w=dojo.body().clientWidth;
-h=dojo.body().clientHeight;
+this.r=r;
+this.g=g;
+this.b=b;
+this.a=a;
 }
 }
 }
-}
-return {width:w,height:h};
 };
-dojo.html.getScroll=function(){
-var _412=dojo.global();
-var _413=dojo.doc();
-var top=_412.pageYOffset||_413.documentElement.scrollTop||dojo.body().scrollTop||0;
-var left=_412.pageXOffset||_413.documentElement.scrollLeft||dojo.body().scrollLeft||0;
-return {top:top,left:left,offset:{x:left,y:top}};
+dojo.graphics.color.Color.fromArray=function(arr){
+return new dojo.graphics.color.Color(arr[0],arr[1],arr[2],arr[3]);
 };
-dojo.html.getParentByType=function(node,type){
-var _418=dojo.doc();
-var _419=dojo.byId(node);
-type=type.toLowerCase();
-while((_419)&&(_419.nodeName.toLowerCase()!=type)){
-if(_419==(_418["body"]||_418["documentElement"])){
-return null;
+dojo.lang.extend(dojo.graphics.color.Color,{toRgb:function(_34a){
+if(_34a){
+return this.toRgba();
+}else{
+return [this.r,this.g,this.b];
 }
-_419=_419.parentNode;
+},toRgba:function(){
+return [this.r,this.g,this.b,this.a];
+},toHex:function(){
+return dojo.graphics.color.rgb2hex(this.toRgb());
+},toCss:function(){
+return "rgb("+this.toRgb().join()+")";
+},toString:function(){
+return this.toHex();
+},blend:function(_34b,_34c){
+return dojo.graphics.color.blend(this.toRgb(),new dojo.graphics.color.Color(_34b).toRgb(),_34c);
+}});
+dojo.graphics.color.named={white:[255,255,255],black:[0,0,0],red:[255,0,0],green:[0,255,0],blue:[0,0,255],navy:[0,0,128],gray:[128,128,128],silver:[192,192,192]};
+dojo.graphics.color.blend=function(a,b,_34f){
+if(typeof a=="string"){
+return dojo.graphics.color.blendHex(a,b,_34f);
 }
-return _419;
-};
-dojo.html.getAttribute=function(node,attr){
-node=dojo.byId(node);
-if((!node)||(!node.getAttribute)){
-return null;
-}
-var ta=typeof attr=="string"?attr:new String(attr);
-var v=node.getAttribute(ta.toUpperCase());
-if((v)&&(typeof v=="string")&&(v!="")){
-return v;
-}
-if(v&&v.value){
-return v.value;
-}
-if((node.getAttributeNode)&&(node.getAttributeNode(ta))){
-return (node.getAttributeNode(ta)).value;
+if(!_34f){
+_34f=0;
 }else{
-if(node.getAttribute(ta)){
-return node.getAttribute(ta);
+if(_34f>1){
+_34f=1;
 }else{
-if(node.getAttribute(ta.toLowerCase())){
-return node.getAttribute(ta.toLowerCase());
+if(_34f<-1){
+_34f=-1;
 }
 }
 }
-return null;
+var c=new Array(3);
+for(var i=0;i<3;i++){
+var half=Math.abs(a[i]-b[i])/2;
+c[i]=Math.floor(Math.min(a[i],b[i])+half+(half*_34f));
+}
+return c;
 };
-dojo.html.hasAttribute=function(node,attr){
-return dojo.html.getAttribute(dojo.byId(node),attr)?true:false;
+dojo.graphics.color.blendHex=function(a,b,_355){
+return dojo.graphics.color.rgb2hex(dojo.graphics.color.blend(dojo.graphics.color.hex2rgb(a),dojo.graphics.color.hex2rgb(b),_355));
 };
-dojo.html.getCursorPosition=function(e){
-e=e||dojo.global().event;
-var _421={x:0,y:0};
-if(e.pageX||e.pageY){
-_421.x=e.pageX;
-_421.y=e.pageY;
+dojo.graphics.color.extractRGB=function(_356){
+var hex="0123456789abcdef";
+_356=_356.toLowerCase();
+if(_356.indexOf("rgb")==0){
+var _358=_356.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
+var ret=_358.splice(1,3);
+return ret;
 }else{
-var de=dojo.doc().documentElement;
-var db=dojo.body();
-_421.x=e.clientX+((de||db)["scrollLeft"])-((de||db)["clientLeft"]);
-_421.y=e.clientY+((de||db)["scrollTop"])-((de||db)["clientTop"]);
+var _35a=dojo.graphics.color.hex2rgb(_356);
+if(_35a){
+return _35a;
+}else{
+return dojo.graphics.color.named[_356]||[255,255,255];
 }
-return _421;
+}
 };
-dojo.html.isTag=function(node){
-node=dojo.byId(node);
-if(node&&node.tagName){
-for(var i=1;i<arguments.length;i++){
-if(node.tagName.toLowerCase()==String(arguments[i]).toLowerCase()){
-return String(arguments[i]).toLowerCase();
+dojo.graphics.color.hex2rgb=function(hex){
+var _35c="0123456789ABCDEF";
+var rgb=new Array(3);
+if(hex.indexOf("#")==0){
+hex=hex.substring(1);
 }
+hex=hex.toUpperCase();
+if(hex.replace(new RegExp("["+_35c+"]","g"),"")!=""){
+return null;
 }
+if(hex.length==3){
+rgb[0]=hex.charAt(0)+hex.charAt(0);
+rgb[1]=hex.charAt(1)+hex.charAt(1);
+rgb[2]=hex.charAt(2)+hex.charAt(2);
+}else{
+rgb[0]=hex.substring(0,2);
+rgb[1]=hex.substring(2,4);
+rgb[2]=hex.substring(4);
 }
-return "";
-};
-if(dojo.render.html.ie&&!dojo.render.html.ie70){
-if(window.location.href.substr(0,6).toLowerCase()!="https:"){
-(function(){
-var _426=dojo.doc().createElement("script");
-_426.src="javascript:'dojo.html.createExternalElement=function(doc, tag){ return doc.createElement(tag); }'";
-dojo.doc().getElementsByTagName("head")[0].appendChild(_426);
-})();
+for(var i=0;i<rgb.length;i++){
+rgb[i]=_35c.indexOf(rgb[i].charAt(0))*16+_35c.indexOf(rgb[i].charAt(1));
 }
-}else{
-dojo.html.createExternalElement=function(doc,tag){
-return doc.createElement(tag);
+return rgb;
 };
+dojo.graphics.color.rgb2hex=function(r,g,b){
+if(dojo.lang.isArray(r)){
+g=r[1]||0;
+b=r[2]||0;
+r=r[0]||0;
 }
-dojo.html._callDeprecated=function(_429,_42a,args,_42c,_42d){
-dojo.deprecated("dojo.html."+_429,"replaced by dojo.html."+_42a+"("+(_42c?"node, {"+_42c+": "+_42c+"}":"")+")"+(_42d?"."+_42d:""),"0.5");
-var _42e=[];
-if(_42c){
-var _42f={};
-_42f[_42c]=args[1];
-_42e.push(args[0]);
-_42e.push(_42f);
-}else{
-_42e=args;
+var ret=dojo.lang.map([r,g,b],function(x){
+x=new Number(x);
+var s=x.toString(16);
+while(s.length<2){
+s="0"+s;
 }
-var ret=dojo.html[_42a].apply(dojo.html,args);
-if(_42d){
-return ret[_42d];
-}else{
-return ret;
-}
+return s;
+});
+ret.unshift("#");
+return ret.join("");
 };
-dojo.html.getViewportWidth=function(){
-return dojo.html._callDeprecated("getViewportWidth","getViewport",arguments,null,"width");
-};
-dojo.html.getViewportHeight=function(){
-return dojo.html._callDeprecated("getViewportHeight","getViewport",arguments,null,"height");
-};
-dojo.html.getViewportSize=function(){
-return dojo.html._callDeprecated("getViewportSize","getViewport",arguments);
-};
-dojo.html.getScrollTop=function(){
-return dojo.html._callDeprecated("getScrollTop","getScroll",arguments,null,"top");
-};
-dojo.html.getScrollLeft=function(){
-return dojo.html._callDeprecated("getScrollLeft","getScroll",arguments,null,"left");
-};
-dojo.html.getScrollOffset=function(){
-return dojo.html._callDeprecated("getScrollOffset","getScroll",arguments,null,"offset");
-};
 dojo.provide("dojo.uri.Uri");
 dojo.uri=new function(){
+this.joinPath=function(){
+var arr=[];
+for(var i=0;i<arguments.length;i++){
+arr.push(arguments[i]);
+}
+return arr.join("/").replace(/\/{2,}/g,"/").replace(/((https*|ftps*):)/i,"$1/");
+};
 this.dojoUri=function(uri){
 return new dojo.uri.Uri(dojo.hostenv.getBaseScriptUri(),uri);
 };
-this.moduleUri=function(_432,uri){
-var loc=dojo.hostenv.getModuleSymbols(_432).join("/");
-if(!loc){
-return null;
-}
-if(loc.lastIndexOf("/")!=loc.length-1){
-loc+="/";
-}
-var _435=loc.indexOf(":");
-var _436=loc.indexOf("/");
-if(loc.charAt(0)!="/"&&(_435==-1||_435>_436)){
-loc=dojo.hostenv.getBaseScriptUri()+loc;
-}
-return new dojo.uri.Uri(loc,uri);
-};
 this.Uri=function(){
 var uri=arguments[0];
 for(var i=1;i<arguments.length;i++){
 if(!arguments[i]){
 continue;
 }
-var _439=new dojo.uri.Uri(arguments[i].toString());
-var _43a=new dojo.uri.Uri(uri.toString());
-if((_439.path=="")&&(_439.scheme==null)&&(_439.authority==null)&&(_439.query==null)){
-if(_439.fragment!=null){
-_43a.fragment=_439.fragment;
+var _36a=new dojo.uri.Uri(arguments[i].toString());
+var _36b=new dojo.uri.Uri(uri.toString());
+if(_36a.path==""&&_36a.scheme==null&&_36a.authority==null&&_36a.query==null){
+if(_36a.fragment!=null){
+_36b.fragment=_36a.fragment;
 }
-_439=_43a;
+_36a=_36b;
 }else{
-if(_439.scheme==null){
-_439.scheme=_43a.scheme;
-if(_439.authority==null){
-_439.authority=_43a.authority;
-if(_439.path.charAt(0)!="/"){
-var path=_43a.path.substring(0,_43a.path.lastIndexOf("/")+1)+_439.path;
+if(_36a.scheme==null){
+_36a.scheme=_36b.scheme;
+if(_36a.authority==null){
+_36a.authority=_36b.authority;
+if(_36a.path.charAt(0)!="/"){
+var path=_36b.path.substring(0,_36b.path.lastIndexOf("/")+1)+_36a.path;
 var segs=path.split("/");
 for(var j=0;j<segs.length;j++){
 if(segs[j]=="."){
@@ -4910,37 +3980,37 @@
 }
 }
 }
-_439.path=segs.join("/");
+_36a.path=segs.join("/");
 }
 }
 }
 }
 uri="";
-if(_439.scheme!=null){
-uri+=_439.scheme+":";
+if(_36a.scheme!=null){
+uri+=_36a.scheme+":";
 }
-if(_439.authority!=null){
-uri+="//"+_439.authority;
+if(_36a.authority!=null){
+uri+="//"+_36a.authority;
 }
-uri+=_439.path;
-if(_439.query!=null){
-uri+="?"+_439.query;
+uri+=_36a.path;
+if(_36a.query!=null){
+uri+="?"+_36a.query;
 }
-if(_439.fragment!=null){
-uri+="#"+_439.fragment;
+if(_36a.fragment!=null){
+uri+="#"+_36a.fragment;
 }
 }
 this.uri=uri.toString();
-var _43e="^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
-var r=this.uri.match(new RegExp(_43e));
+var _36f="^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
+var r=this.uri.match(new RegExp(_36f));
 this.scheme=r[2]||(r[1]?"":null);
 this.authority=r[4]||(r[3]?"":null);
 this.path=r[5];
 this.query=r[7]||(r[6]?"":null);
 this.fragment=r[9]||(r[8]?"":null);
 if(this.authority!=null){
-_43e="^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$";
-r=this.authority.match(new RegExp(_43e));
+_36f="^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$";
+r=this.authority.match(new RegExp(_36f));
 this.user=r[3]||null;
 this.password=r[4]||null;
 this.host=r[5];
@@ -4951,546 +4021,480 @@
 };
 };
 };
-dojo.provide("dojo.html.style");
-dojo.html.getClass=function(node){
-node=dojo.byId(node);
-if(!node){
-return "";
+dojo.provide("dojo.style");
+dojo.require("dojo.graphics.color");
+dojo.require("dojo.uri.Uri");
+dojo.require("dojo.lang.common");
+(function(){
+var h=dojo.render.html;
+var ds=dojo.style;
+var db=document["body"]||document["documentElement"];
+ds.boxSizing={MARGIN_BOX:"margin-box",BORDER_BOX:"border-box",PADDING_BOX:"padding-box",CONTENT_BOX:"content-box"};
+var bs=ds.boxSizing;
+ds.getBoxSizing=function(node){
+if((h.ie)||(h.opera)){
+var cm=document["compatMode"];
+if((cm=="BackCompat")||(cm=="QuirksMode")){
+return bs.BORDER_BOX;
+}else{
+return bs.CONTENT_BOX;
 }
-var cs="";
-if(node.className){
-cs=node.className;
 }else{
-if(dojo.html.hasAttribute(node,"class")){
-cs=dojo.html.getAttribute(node,"class");
+if(arguments.length==0){
+node=document.documentElement;
 }
+var _377=ds.getStyle(node,"-moz-box-sizing");
+if(!_377){
+_377=ds.getStyle(node,"box-sizing");
 }
-return cs.replace(/^\s+|\s+$/g,"");
+return (_377?_377:bs.CONTENT_BOX);
+}
 };
-dojo.html.getClasses=function(node){
-var c=dojo.html.getClass(node);
-return (c=="")?[]:c.split(/\s+/g);
+ds.isBorderBox=function(node){
+return (ds.getBoxSizing(node)==bs.BORDER_BOX);
 };
-dojo.html.hasClass=function(node,_445){
-return (new RegExp("(^|\\s+)"+_445+"(\\s+|$)")).test(dojo.html.getClass(node));
-};
-dojo.html.prependClass=function(node,_447){
-_447+=" "+dojo.html.getClass(node);
-return dojo.html.setClass(node,_447);
-};
-dojo.html.addClass=function(node,_449){
-if(dojo.html.hasClass(node,_449)){
-return false;
+ds.getUnitValue=function(node,_37a,_37b){
+var s=ds.getComputedStyle(node,_37a);
+if((!s)||((s=="auto")&&(_37b))){
+return {value:0,units:"px"};
 }
-_449=(dojo.html.getClass(node)+" "+_449).replace(/^\s+|\s+$/g,"");
-return dojo.html.setClass(node,_449);
-};
-dojo.html.setClass=function(node,_44b){
-node=dojo.byId(node);
-var cs=new String(_44b);
-try{
-if(typeof node.className=="string"){
-node.className=cs;
-}else{
-if(node.setAttribute){
-node.setAttribute("class",_44b);
-node.className=cs;
-}else{
-return false;
+if(dojo.lang.isUndefined(s)){
+return ds.getUnitValue.bad;
 }
+var _37d=s.match(/(\-?[\d.]+)([a-z%]*)/i);
+if(!_37d){
+return ds.getUnitValue.bad;
 }
-}
-catch(e){
-dojo.debug("dojo.html.setClass() failed",e);
-}
-return true;
+return {value:Number(_37d[1]),units:_37d[2].toLowerCase()};
 };
-dojo.html.removeClass=function(node,_44e,_44f){
-try{
-if(!_44f){
-var _450=dojo.html.getClass(node).replace(new RegExp("(^|\\s+)"+_44e+"(\\s+|$)"),"$1$2");
-}else{
-var _450=dojo.html.getClass(node).replace(_44e,"");
+ds.getUnitValue.bad={value:NaN,units:""};
+ds.getPixelValue=function(node,_37f,_380){
+var _381=ds.getUnitValue(node,_37f,_380);
+if(isNaN(_381.value)){
+return 0;
 }
-dojo.html.setClass(node,_450);
+if((_381.value)&&(_381.units!="px")){
+return NaN;
 }
-catch(e){
-dojo.debug("dojo.html.removeClass() failed",e);
-}
-return true;
+return _381.value;
 };
-dojo.html.replaceClass=function(node,_452,_453){
-dojo.html.removeClass(node,_453);
-dojo.html.addClass(node,_452);
+ds.getNumericStyle=function(){
+dojo.deprecated("dojo.(style|html).getNumericStyle","in favor of dojo.(style|html).getPixelValue","0.4");
+return ds.getPixelValue.apply(this,arguments);
 };
-dojo.html.classMatchType={ContainsAll:0,ContainsAny:1,IsOnly:2};
-dojo.html.getElementsByClass=function(_454,_455,_456,_457,_458){
-_458=false;
-var _459=dojo.doc();
-_455=dojo.byId(_455)||_459;
-var _45a=_454.split(/\s+/g);
-var _45b=[];
-if(_457!=1&&_457!=2){
-_457=0;
+ds.setPositivePixelValue=function(node,_383,_384){
+if(isNaN(_384)){
+return false;
 }
-var _45c=new RegExp("(\\s|^)(("+_45a.join(")|(")+"))(\\s|$)");
-var _45d=_45a.join(" ").length;
-var _45e=[];
-if(!_458&&_459.evaluate){
-var _45f=".//"+(_456||"*")+"[contains(";
-if(_457!=dojo.html.classMatchType.ContainsAny){
-_45f+="concat(' ', at class,' '), ' "+_45a.join(" ') and contains(concat(' ', at class,' '), ' ")+" ')";
-if(_457==2){
-_45f+=" and string-length(@class)="+_45d+"]";
-}else{
-_45f+="]";
-}
-}else{
-_45f+="concat(' ', at class,' '), ' "+_45a.join(" ') or contains(concat(' ', at class,' '), ' ")+" ')]";
-}
-var _460=_459.evaluate(_45f,_455,null,XPathResult.ANY_TYPE,null);
-var _461=_460.iterateNext();
-while(_461){
-try{
-_45e.push(_461);
-_461=_460.iterateNext();
-}
-catch(e){
-break;
-}
-}
-return _45e;
-}else{
-if(!_456){
-_456="*";
-}
-_45e=_455.getElementsByTagName(_456);
-var node,i=0;
-outer:
-while(node=_45e[i++]){
-var _464=dojo.html.getClasses(node);
-if(_464.length==0){
-continue outer;
-}
-var _465=0;
-for(var j=0;j<_464.length;j++){
-if(_45c.test(_464[j])){
-if(_457==dojo.html.classMatchType.ContainsAny){
-_45b.push(node);
-continue outer;
-}else{
-_465++;
-}
-}else{
-if(_457==dojo.html.classMatchType.IsOnly){
-continue outer;
-}
-}
-}
-if(_465==_45a.length){
-if((_457==dojo.html.classMatchType.IsOnly)&&(_465==_464.length)){
-_45b.push(node);
-}else{
-if(_457==dojo.html.classMatchType.ContainsAll){
-_45b.push(node);
-}
-}
-}
-}
-return _45b;
-}
+node.style[_383]=Math.max(0,_384)+"px";
+return true;
 };
-dojo.html.getElementsByClassName=dojo.html.getElementsByClass;
-dojo.html.toCamelCase=function(_467){
-var arr=_467.split("-"),cc=arr[0];
-for(var i=1;i<arr.length;i++){
-cc+=arr[i].charAt(0).toUpperCase()+arr[i].substring(1);
+ds._sumPixelValues=function(node,_386,_387){
+var _388=0;
+for(var x=0;x<_386.length;x++){
+_388+=ds.getPixelValue(node,_386[x],_387);
 }
-return cc;
+return _388;
 };
-dojo.html.toSelectorCase=function(_46b){
-return _46b.replace(/([A-Z])/g,"-$1").toLowerCase();
+ds.isPositionAbsolute=function(node){
+return (ds.getComputedStyle(node,"position")=="absolute");
 };
-if(dojo.render.html.ie){
-dojo.html.getComputedStyle=function(node,_46d,_46e){
+ds.getBorderExtent=function(node,side){
+return (ds.getStyle(node,"border-"+side+"-style")=="none"?0:ds.getPixelValue(node,"border-"+side+"-width"));
+};
+ds.getMarginWidth=function(node){
+return ds._sumPixelValues(node,["margin-left","margin-right"],ds.isPositionAbsolute(node));
+};
+ds.getBorderWidth=function(node){
+return ds.getBorderExtent(node,"left")+ds.getBorderExtent(node,"right");
+};
+ds.getPaddingWidth=function(node){
+return ds._sumPixelValues(node,["padding-left","padding-right"],true);
+};
+ds.getPadBorderWidth=function(node){
+return ds.getPaddingWidth(node)+ds.getBorderWidth(node);
+};
+ds.getContentBoxWidth=function(node){
 node=dojo.byId(node);
-if(!node||!node.currentStyle){
-return _46e;
-}
-return node.currentStyle[dojo.html.toCamelCase(_46d)];
+return node.offsetWidth-ds.getPadBorderWidth(node);
 };
-dojo.html.getComputedStyles=function(node){
-return node.currentStyle;
+ds.getBorderBoxWidth=function(node){
+node=dojo.byId(node);
+return node.offsetWidth;
 };
-}else{
-dojo.html.getComputedStyle=function(node,_471,_472){
+ds.getMarginBoxWidth=function(node){
+return ds.getInnerWidth(node)+ds.getMarginWidth(node);
+};
+ds.setContentBoxWidth=function(node,_395){
 node=dojo.byId(node);
-if(!node||!node.style){
-return _472;
+if(ds.isBorderBox(node)){
+_395+=ds.getPadBorderWidth(node);
 }
-var s=document.defaultView.getComputedStyle(node,null);
-return (s&&s[dojo.html.toCamelCase(_471)])||"";
+return ds.setPositivePixelValue(node,"width",_395);
 };
-dojo.html.getComputedStyles=function(node){
-return document.defaultView.getComputedStyle(node,null);
-};
+ds.setMarginBoxWidth=function(node,_397){
+node=dojo.byId(node);
+if(!ds.isBorderBox(node)){
+_397-=ds.getPadBorderWidth(node);
 }
-dojo.html.getStyleProperty=function(node,_476){
+_397-=ds.getMarginWidth(node);
+return ds.setPositivePixelValue(node,"width",_397);
+};
+ds.getContentWidth=ds.getContentBoxWidth;
+ds.getInnerWidth=ds.getBorderBoxWidth;
+ds.getOuterWidth=ds.getMarginBoxWidth;
+ds.setContentWidth=ds.setContentBoxWidth;
+ds.setOuterWidth=ds.setMarginBoxWidth;
+ds.getMarginHeight=function(node){
+return ds._sumPixelValues(node,["margin-top","margin-bottom"],ds.isPositionAbsolute(node));
+};
+ds.getBorderHeight=function(node){
+return ds.getBorderExtent(node,"top")+ds.getBorderExtent(node,"bottom");
+};
+ds.getPaddingHeight=function(node){
+return ds._sumPixelValues(node,["padding-top","padding-bottom"],true);
+};
+ds.getPadBorderHeight=function(node){
+return ds.getPaddingHeight(node)+ds.getBorderHeight(node);
+};
+ds.getContentBoxHeight=function(node){
 node=dojo.byId(node);
-return (node&&node.style?node.style[dojo.html.toCamelCase(_476)]:undefined);
+return node.offsetHeight-ds.getPadBorderHeight(node);
 };
-dojo.html.getStyle=function(node,_478){
-var _479=dojo.html.getStyleProperty(node,_478);
-return (_479?_479:dojo.html.getComputedStyle(node,_478));
+ds.getBorderBoxHeight=function(node){
+node=dojo.byId(node);
+return node.offsetHeight;
 };
-dojo.html.setStyle=function(node,_47b,_47c){
+ds.getMarginBoxHeight=function(node){
+return ds.getInnerHeight(node)+ds.getMarginHeight(node);
+};
+ds.setContentBoxHeight=function(node,_3a0){
 node=dojo.byId(node);
-if(node&&node.style){
-var _47d=dojo.html.toCamelCase(_47b);
-node.style[_47d]=_47c;
+if(ds.isBorderBox(node)){
+_3a0+=ds.getPadBorderHeight(node);
 }
+return ds.setPositivePixelValue(node,"height",_3a0);
 };
-dojo.html.setStyleText=function(_47e,text){
-try{
-_47e.style.cssText=text;
+ds.setMarginBoxHeight=function(node,_3a2){
+node=dojo.byId(node);
+if(!ds.isBorderBox(node)){
+_3a2-=ds.getPadBorderHeight(node);
 }
-catch(e){
-_47e.setAttribute("style",text);
-}
+_3a2-=ds.getMarginHeight(node);
+return ds.setPositivePixelValue(node,"height",_3a2);
 };
-dojo.html.copyStyle=function(_480,_481){
-if(!_481.style.cssText){
-_480.setAttribute("style",_481.getAttribute("style"));
+ds.getContentHeight=ds.getContentBoxHeight;
+ds.getInnerHeight=ds.getBorderBoxHeight;
+ds.getOuterHeight=ds.getMarginBoxHeight;
+ds.setContentHeight=ds.setContentBoxHeight;
+ds.setOuterHeight=ds.setMarginBoxHeight;
+ds.getAbsolutePosition=ds.abs=function(node,_3a4){
+node=dojo.byId(node);
+var ret=[];
+ret.x=ret.y=0;
+var st=dojo.html.getScrollTop();
+var sl=dojo.html.getScrollLeft();
+if(h.ie){
+with(node.getBoundingClientRect()){
+ret.x=left-2;
+ret.y=top-2;
+}
 }else{
-_480.style.cssText=_481.style.cssText;
+if(document.getBoxObjectFor){
+var bo=document.getBoxObjectFor(node);
+ret.x=bo.x-ds.sumAncestorProperties(node,"scrollLeft");
+ret.y=bo.y-ds.sumAncestorProperties(node,"scrollTop");
+}else{
+if(node["offsetParent"]){
+var _3a9;
+if((h.safari)&&(node.style.getPropertyValue("position")=="absolute")&&(node.parentNode==db)){
+_3a9=db;
+}else{
+_3a9=db.parentNode;
 }
-dojo.html.addClass(_480,dojo.html.getClass(_481));
-};
-dojo.html.getUnitValue=function(node,_483,_484){
-var s=dojo.html.getComputedStyle(node,_483);
-if((!s)||((s=="auto")&&(_484))){
-return {value:0,units:"px"};
+if(node.parentNode!=db){
+var nd=node;
+if(window.opera){
+nd=db;
 }
-var _486=s.match(/(\-?[\d.]+)([a-z%]*)/i);
-if(!_486){
-return dojo.html.getUnitValue.bad;
+ret.x-=ds.sumAncestorProperties(nd,"scrollLeft");
+ret.y-=ds.sumAncestorProperties(nd,"scrollTop");
 }
-return {value:Number(_486[1]),units:_486[2].toLowerCase()};
+do{
+var n=node["offsetLeft"];
+ret.x+=isNaN(n)?0:n;
+var m=node["offsetTop"];
+ret.y+=isNaN(m)?0:m;
+node=node.offsetParent;
+}while((node!=_3a9)&&(node!=null));
+}else{
+if(node["x"]&&node["y"]){
+ret.x+=isNaN(node.x)?0:node.x;
+ret.y+=isNaN(node.y)?0:node.y;
+}
+}
+}
+}
+if(_3a4){
+ret.y+=st;
+ret.x+=sl;
+}
+ret[0]=ret.x;
+ret[1]=ret.y;
+return ret;
 };
-dojo.html.getUnitValue.bad={value:NaN,units:""};
-if(dojo.render.html.ie){
-dojo.html.toPixelValue=function(_487,_488){
-if(!_488){
+ds.sumAncestorProperties=function(node,prop){
+node=dojo.byId(node);
+if(!node){
 return 0;
 }
-if(_488.slice(-2)=="px"){
-return parseFloat(_488);
+var _3af=0;
+while(node){
+var val=node[prop];
+if(val){
+_3af+=val-0;
+if(node==document.body){
+break;
 }
-var _489=0;
-with(_487){
-var _48a=style.left;
-var _48b=runtimeStyle.left;
-runtimeStyle.left=currentStyle.left;
-try{
-style.left=_488||0;
-_489=style.pixelLeft;
-style.left=_48a;
-runtimeStyle.left=_48b;
 }
-catch(e){
+node=node.parentNode;
 }
-}
-return _489;
+return _3af;
 };
-}else{
-dojo.html.toPixelValue=function(_48c,_48d){
-return (_48d&&(_48d.slice(-2)=="px")?parseFloat(_48d):0);
+ds.getTotalOffset=function(node,type,_3b3){
+return ds.abs(node,_3b3)[(type=="top")?"y":"x"];
 };
-}
-dojo.html.getPixelValue=function(node,_48f,_490){
-return dojo.html.toPixelValue(node,dojo.html.getComputedStyle(node,_48f));
+ds.getAbsoluteX=ds.totalOffsetLeft=function(node,_3b5){
+return ds.getTotalOffset(node,"left",_3b5);
 };
-dojo.html.setPositivePixelValue=function(node,_492,_493){
-if(isNaN(_493)){
-return false;
-}
-node.style[_492]=Math.max(0,_493)+"px";
-return true;
+ds.getAbsoluteY=ds.totalOffsetTop=function(node,_3b7){
+return ds.getTotalOffset(node,"top",_3b7);
 };
-dojo.html.styleSheet=null;
-dojo.html.insertCssRule=function(_494,_495,_496){
-if(!dojo.html.styleSheet){
+ds.styleSheet=null;
+ds.insertCssRule=function(_3b8,_3b9,_3ba){
+if(!ds.styleSheet){
 if(document.createStyleSheet){
-dojo.html.styleSheet=document.createStyleSheet();
+ds.styleSheet=document.createStyleSheet();
 }else{
 if(document.styleSheets[0]){
-dojo.html.styleSheet=document.styleSheets[0];
+ds.styleSheet=document.styleSheets[0];
 }else{
 return null;
 }
 }
 }
 if(arguments.length<3){
-if(dojo.html.styleSheet.cssRules){
-_496=dojo.html.styleSheet.cssRules.length;
+if(ds.styleSheet.cssRules){
+_3ba=ds.styleSheet.cssRules.length;
 }else{
-if(dojo.html.styleSheet.rules){
-_496=dojo.html.styleSheet.rules.length;
+if(ds.styleSheet.rules){
+_3ba=ds.styleSheet.rules.length;
 }else{
 return null;
 }
 }
 }
-if(dojo.html.styleSheet.insertRule){
-var rule=_494+" { "+_495+" }";
-return dojo.html.styleSheet.insertRule(rule,_496);
+if(ds.styleSheet.insertRule){
+var rule=_3b8+" { "+_3b9+" }";
+return ds.styleSheet.insertRule(rule,_3ba);
 }else{
-if(dojo.html.styleSheet.addRule){
-return dojo.html.styleSheet.addRule(_494,_495,_496);
+if(ds.styleSheet.addRule){
+return ds.styleSheet.addRule(_3b8,_3b9,_3ba);
 }else{
 return null;
 }
 }
 };
-dojo.html.removeCssRule=function(_498){
-if(!dojo.html.styleSheet){
+ds.removeCssRule=function(_3bc){
+if(!ds.styleSheet){
 dojo.debug("no stylesheet defined for removing rules");
 return false;
 }
-if(dojo.render.html.ie){
-if(!_498){
-_498=dojo.html.styleSheet.rules.length;
-dojo.html.styleSheet.removeRule(_498);
+if(h.ie){
+if(!_3bc){
+_3bc=ds.styleSheet.rules.length;
+ds.styleSheet.removeRule(_3bc);
 }
 }else{
 if(document.styleSheets[0]){
-if(!_498){
-_498=dojo.html.styleSheet.cssRules.length;
+if(!_3bc){
+_3bc=ds.styleSheet.cssRules.length;
 }
-dojo.html.styleSheet.deleteRule(_498);
+ds.styleSheet.deleteRule(_3bc);
 }
 }
 return true;
 };
-dojo.html._insertedCssFiles=[];
-dojo.html.insertCssFile=function(URI,doc,_49b,_49c){
+ds.insertCssFile=function(URI,doc,_3bf){
 if(!URI){
 return;
 }
 if(!doc){
 doc=document;
 }
-var _49d=dojo.hostenv.getText(URI,false,_49c);
-if(_49d===null){
+var _3c0=dojo.hostenv.getText(URI);
+_3c0=ds.fixPathsInCssText(_3c0,URI);
+if(_3bf){
+var _3c1=doc.getElementsByTagName("style");
+var _3c2="";
+for(var i=0;i<_3c1.length;i++){
+_3c2=(_3c1[i].styleSheet&&_3c1[i].styleSheet.cssText)?_3c1[i].styleSheet.cssText:_3c1[i].innerHTML;
+if(_3c0==_3c2){
 return;
 }
-_49d=dojo.html.fixPathsInCssText(_49d,URI);
-if(_49b){
-var idx=-1,node,ent=dojo.html._insertedCssFiles;
-for(var i=0;i<ent.length;i++){
-if((ent[i].doc==doc)&&(ent[i].cssText==_49d)){
-idx=i;
-node=ent[i].nodeRef;
-break;
 }
 }
-if(node){
-var _4a2=doc.getElementsByTagName("style");
-for(var i=0;i<_4a2.length;i++){
-if(_4a2[i]==node){
-return;
+var _3c4=ds.insertCssText(_3c0);
+if(_3c4&&djConfig.isDebug){
+_3c4.setAttribute("dbgHref",URI);
 }
-}
-dojo.html._insertedCssFiles.shift(idx,1);
-}
-}
-var _4a3=dojo.html.insertCssText(_49d,doc);
-dojo.html._insertedCssFiles.push({"doc":doc,"cssText":_49d,"nodeRef":_4a3});
-if(_4a3&&djConfig.isDebug){
-_4a3.setAttribute("dbgHref",URI);
-}
-return _4a3;
+return _3c4;
 };
-dojo.html.insertCssText=function(_4a4,doc,URI){
-if(!_4a4){
+ds.insertCssText=function(_3c5,doc,URI){
+if(!_3c5){
 return;
 }
 if(!doc){
 doc=document;
 }
 if(URI){
-_4a4=dojo.html.fixPathsInCssText(_4a4,URI);
+_3c5=ds.fixPathsInCssText(_3c5,URI);
 }
-var _4a7=doc.createElement("style");
-_4a7.setAttribute("type","text/css");
+var _3c8=doc.createElement("style");
+_3c8.setAttribute("type","text/css");
 var head=doc.getElementsByTagName("head")[0];
 if(!head){
 dojo.debug("No head tag in document, aborting styles");
 return;
 }else{
-head.appendChild(_4a7);
+head.appendChild(_3c8);
 }
-if(_4a7.styleSheet){
-var _4a9=function(){
-try{
-_4a7.styleSheet.cssText=_4a4;
-}
-catch(e){
-dojo.debug(e);
-}
-};
-if(_4a7.styleSheet.disabled){
-setTimeout(_4a9,10);
+if(_3c8.styleSheet){
+_3c8.styleSheet.cssText=_3c5;
 }else{
-_4a9();
+var _3ca=doc.createTextNode(_3c5);
+_3c8.appendChild(_3ca);
 }
-}else{
-var _4aa=doc.createTextNode(_4a4);
-_4a7.appendChild(_4aa);
-}
-return _4a7;
+return _3c8;
 };
-dojo.html.fixPathsInCssText=function(_4ab,URI){
-if(!_4ab||!URI){
+ds.fixPathsInCssText=function(_3cb,URI){
+if(!_3cb||!URI){
 return;
 }
-var _4ad,str="",url="",_4b0="[\\t\\s\\w\\(\\)\\/\\.\\\\'\"-:#=&?~]+";
-var _4b1=new RegExp("url\\(\\s*("+_4b0+")\\s*\\)");
-var _4b2=/(file|https?|ftps?):\/\//;
-regexTrim=new RegExp("^[\\s]*(['\"]?)("+_4b0+")\\1[\\s]*?$");
-if(dojo.render.html.ie55||dojo.render.html.ie60){
-var _4b3=new RegExp("AlphaImageLoader\\((.*)src=['\"]("+_4b0+")['\"]");
-while(_4ad=_4b3.exec(_4ab)){
-url=_4ad[2].replace(regexTrim,"$2");
-if(!_4b2.exec(url)){
-url=(new dojo.uri.Uri(URI,url).toString());
+var pos=0;
+var str="";
+var url="";
+while(pos!=-1){
+pos=0;
+url="";
+pos=_3cb.indexOf("url(",pos);
+if(pos<0){
+break;
 }
-str+=_4ab.substring(0,_4ad.index)+"AlphaImageLoader("+_4ad[1]+"src='"+url+"'";
-_4ab=_4ab.substr(_4ad.index+_4ad[0].length);
-}
-_4ab=str+_4ab;
-str="";
-}
-while(_4ad=_4b1.exec(_4ab)){
-url=_4ad[1].replace(regexTrim,"$2");
-if(!_4b2.exec(url)){
+str+=_3cb.slice(0,pos+4);
+_3cb=_3cb.substring(pos+4,_3cb.length);
+url+=_3cb.match(/^[\t\s\w()\/.\\'"-:#=&?]*\)/)[0];
+_3cb=_3cb.substring(url.length-1,_3cb.length);
+url=url.replace(/^[\s\t]*(['"]?)([\w()\/.\\'"-:#=&?]*)\1[\s\t]*?\)/,"$2");
+if(url.search(/(file|https?|ftps?):\/\//)==-1){
 url=(new dojo.uri.Uri(URI,url).toString());
 }
-str+=_4ab.substring(0,_4ad.index)+"url("+url+")";
-_4ab=_4ab.substr(_4ad.index+_4ad[0].length);
+str+=url;
 }
-return str+_4ab;
+return str+_3cb;
 };
-dojo.html.setActiveStyleSheet=function(_4b4){
-var i=0,a,els=dojo.doc().getElementsByTagName("link");
-while(a=els[i++]){
-if(a.getAttribute("rel").indexOf("style")!=-1&&a.getAttribute("title")){
-a.disabled=true;
-if(a.getAttribute("title")==_4b4){
-a.disabled=false;
+ds.getBackgroundColor=function(node){
+node=dojo.byId(node);
+var _3d1;
+do{
+_3d1=ds.getStyle(node,"background-color");
+if(_3d1.toLowerCase()=="rgba(0, 0, 0, 0)"){
+_3d1="transparent";
 }
+if(node==document.getElementsByTagName("body")[0]){
+node=null;
+break;
 }
+node=node.parentNode;
+}while(node&&dojo.lang.inArray(_3d1,["transparent",""]));
+if(_3d1=="transparent"){
+_3d1=[255,255,255,0];
+}else{
+_3d1=dojo.graphics.color.extractRGB(_3d1);
 }
+return _3d1;
 };
-dojo.html.getActiveStyleSheet=function(){
-var i=0,a,els=dojo.doc().getElementsByTagName("link");
-while(a=els[i++]){
-if(a.getAttribute("rel").indexOf("style")!=-1&&a.getAttribute("title")&&!a.disabled){
-return a.getAttribute("title");
+ds.getComputedStyle=function(node,_3d3,_3d4){
+node=dojo.byId(node);
+var _3d3=ds.toSelectorCase(_3d3);
+var _3d5=ds.toCamelCase(_3d3);
+if(!node||!node.style){
+return _3d4;
+}else{
+if(document.defaultView){
+try{
+var cs=document.defaultView.getComputedStyle(node,"");
+if(cs){
+return cs.getPropertyValue(_3d3);
 }
 }
-return null;
-};
-dojo.html.getPreferredStyleSheet=function(){
-var i=0,a,els=dojo.doc().getElementsByTagName("link");
-while(a=els[i++]){
-if(a.getAttribute("rel").indexOf("style")!=-1&&a.getAttribute("rel").indexOf("alt")==-1&&a.getAttribute("title")){
-return a.getAttribute("title");
+catch(e){
+if(node.style.getPropertyValue){
+return node.style.getPropertyValue(_3d3);
+}else{
+return _3d4;
 }
 }
-return null;
-};
-dojo.html.applyBrowserClass=function(node){
-var drh=dojo.render.html;
-var _4c0={dj_ie:drh.ie,dj_ie55:drh.ie55,dj_ie6:drh.ie60,dj_ie7:drh.ie70,dj_iequirks:drh.ie&&drh.quirks,dj_opera:drh.opera,dj_opera8:drh.opera&&(Math.floor(dojo.render.version)==8),dj_opera9:drh.opera&&(Math.floor(dojo.render.version)==9),dj_khtml:drh.khtml,dj_safari:drh.safari,dj_gecko:drh.mozilla};
-for(var p in _4c0){
-if(_4c0[p]){
-dojo.html.addClass(node,p);
+}else{
+if(node.currentStyle){
+return node.currentStyle[_3d5];
 }
 }
+}
+if(node.style.getPropertyValue){
+return node.style.getPropertyValue(_3d3);
+}else{
+return _3d4;
+}
 };
-dojo.provide("dojo.html.display");
-dojo.html._toggle=function(node,_4c3,_4c4){
+ds.getStyleProperty=function(node,_3d8){
 node=dojo.byId(node);
-_4c4(node,!_4c3(node));
-return _4c3(node);
+return (node&&node.style?node.style[ds.toCamelCase(_3d8)]:undefined);
 };
-dojo.html.show=function(node){
-node=dojo.byId(node);
-if(dojo.html.getStyleProperty(node,"display")=="none"){
-dojo.html.setStyle(node,"display",(node.dojoDisplayCache||""));
-node.dojoDisplayCache=undefined;
-}
+ds.getStyle=function(node,_3da){
+var _3db=ds.getStyleProperty(node,_3da);
+return (_3db?_3db:ds.getComputedStyle(node,_3da));
 };
-dojo.html.hide=function(node){
+ds.setStyle=function(node,_3dd,_3de){
 node=dojo.byId(node);
-if(typeof node["dojoDisplayCache"]=="undefined"){
-var d=dojo.html.getStyleProperty(node,"display");
-if(d!="none"){
-node.dojoDisplayCache=d;
+if(node&&node.style){
+var _3df=ds.toCamelCase(_3dd);
+node.style[_3df]=_3de;
 }
-}
-dojo.html.setStyle(node,"display","none");
 };
-dojo.html.setShowing=function(node,_4c9){
-dojo.html[(_4c9?"show":"hide")](node);
-};
-dojo.html.isShowing=function(node){
-return (dojo.html.getStyleProperty(node,"display")!="none");
-};
-dojo.html.toggleShowing=function(node){
-return dojo.html._toggle(node,dojo.html.isShowing,dojo.html.setShowing);
-};
-dojo.html.displayMap={tr:"",td:"",th:"",img:"inline",span:"inline",input:"inline",button:"inline"};
-dojo.html.suggestDisplayByTagName=function(node){
-node=dojo.byId(node);
-if(node&&node.tagName){
-var tag=node.tagName.toLowerCase();
-return (tag in dojo.html.displayMap?dojo.html.displayMap[tag]:"block");
+ds.toCamelCase=function(_3e0){
+var arr=_3e0.split("-"),cc=arr[0];
+for(var i=1;i<arr.length;i++){
+cc+=arr[i].charAt(0).toUpperCase()+arr[i].substring(1);
 }
+return cc;
 };
-dojo.html.setDisplay=function(node,_4cf){
-dojo.html.setStyle(node,"display",((_4cf instanceof String||typeof _4cf=="string")?_4cf:(_4cf?dojo.html.suggestDisplayByTagName(node):"none")));
+ds.toSelectorCase=function(_3e3){
+return _3e3.replace(/([A-Z])/g,"-$1").toLowerCase();
 };
-dojo.html.isDisplayed=function(node){
-return (dojo.html.getComputedStyle(node,"display")!="none");
-};
-dojo.html.toggleDisplay=function(node){
-return dojo.html._toggle(node,dojo.html.isDisplayed,dojo.html.setDisplay);
-};
-dojo.html.setVisibility=function(node,_4d3){
-dojo.html.setStyle(node,"visibility",((_4d3 instanceof String||typeof _4d3=="string")?_4d3:(_4d3?"visible":"hidden")));
-};
-dojo.html.isVisible=function(node){
-return (dojo.html.getComputedStyle(node,"visibility")!="hidden");
-};
-dojo.html.toggleVisibility=function(node){
-return dojo.html._toggle(node,dojo.html.isVisible,dojo.html.setVisibility);
-};
-dojo.html.setOpacity=function(node,_4d7,_4d8){
+ds.setOpacity=function setOpacity(node,_3e5,_3e6){
 node=dojo.byId(node);
-var h=dojo.render.html;
-if(!_4d8){
-if(_4d7>=1){
+if(!_3e6){
+if(_3e5>=1){
 if(h.ie){
-dojo.html.clearOpacity(node);
+ds.clearOpacity(node);
 return;
 }else{
-_4d7=0.999999;
+_3e5=0.999999;
 }
 }else{
-if(_4d7<0){
-_4d7=0;
+if(_3e5<0){
+_3e5=0;
 }
 }
 }
@@ -5498,28 +4502,36 @@
 if(node.nodeName.toLowerCase()=="tr"){
 var tds=node.getElementsByTagName("td");
 for(var x=0;x<tds.length;x++){
-tds[x].style.filter="Alpha(Opacity="+_4d7*100+")";
+tds[x].style.filter="Alpha(Opacity="+_3e5*100+")";
 }
 }
-node.style.filter="Alpha(Opacity="+_4d7*100+")";
+node.style.filter="Alpha(Opacity="+_3e5*100+")";
 }else{
 if(h.moz){
-node.style.opacity=_4d7;
-node.style.MozOpacity=_4d7;
+node.style.opacity=_3e5;
+node.style.MozOpacity=_3e5;
 }else{
 if(h.safari){
-node.style.opacity=_4d7;
-node.style.KhtmlOpacity=_4d7;
+node.style.opacity=_3e5;
+node.style.KhtmlOpacity=_3e5;
 }else{
-node.style.opacity=_4d7;
+node.style.opacity=_3e5;
 }
 }
 }
 };
-dojo.html.clearOpacity=function(node){
+ds.getOpacity=function getOpacity(node){
 node=dojo.byId(node);
+if(h.ie){
+var opac=(node.filters&&node.filters.alpha&&typeof node.filters.alpha.opacity=="number"?node.filters.alpha.opacity:100)/100;
+}else{
+var opac=node.style.opacity||node.style.MozOpacity||node.style.KhtmlOpacity||1;
+}
+return opac>=0.999999?1:Number(opac);
+};
+ds.clearOpacity=function clearOpacity(node){
+node=dojo.byId(node);
 var ns=node.style;
-var h=dojo.render.html;
 if(h.ie){
 try{
 if(node.filters&&node.filters.alpha){
@@ -5542,497 +4554,642 @@
 }
 }
 };
-dojo.html.getOpacity=function(node){
-node=dojo.byId(node);
-var h=dojo.render.html;
-if(h.ie){
-var opac=(node.filters&&node.filters.alpha&&typeof node.filters.alpha.opacity=="number"?node.filters.alpha.opacity:100)/100;
+ds.setStyleAttributes=function(node,_3ee){
+var _3ef={"opacity":dojo.style.setOpacity,"content-height":dojo.style.setContentHeight,"content-width":dojo.style.setContentWidth,"outer-height":dojo.style.setOuterHeight,"outer-width":dojo.style.setOuterWidth};
+var _3f0=_3ee.replace(/(;)?\s*$/,"").split(";");
+for(var i=0;i<_3f0.length;i++){
+var _3f2=_3f0[i].split(":");
+var name=_3f2[0].replace(/\s*$/,"").replace(/^\s*/,"").toLowerCase();
+var _3f4=_3f2[1].replace(/\s*$/,"").replace(/^\s*/,"");
+if(dojo.lang.has(_3ef,name)){
+_3ef[name](node,_3f4);
 }else{
-var opac=node.style.opacity||node.style.MozOpacity||node.style.KhtmlOpacity||1;
+node.style[dojo.style.toCamelCase(name)]=_3f4;
 }
-return opac>=0.999999?1:Number(opac);
+}
 };
-dojo.provide("dojo.html.color");
-dojo.html.getBackgroundColor=function(node){
+ds._toggle=function(node,_3f6,_3f7){
 node=dojo.byId(node);
-var _4e3;
-do{
-_4e3=dojo.html.getStyle(node,"background-color");
-if(_4e3.toLowerCase()=="rgba(0, 0, 0, 0)"){
-_4e3="transparent";
+_3f7(node,!_3f6(node));
+return _3f6(node);
+};
+ds.show=function(node){
+node=dojo.byId(node);
+if(ds.getStyleProperty(node,"display")=="none"){
+ds.setStyle(node,"display",(node.dojoDisplayCache||""));
+node.dojoDisplayCache=undefined;
 }
-if(node==document.getElementsByTagName("body")[0]){
-node=null;
-break;
+};
+ds.hide=function(node){
+node=dojo.byId(node);
+if(typeof node["dojoDisplayCache"]=="undefined"){
+var d=ds.getStyleProperty(node,"display");
+if(d!="none"){
+node.dojoDisplayCache=d;
 }
-node=node.parentNode;
-}while(node&&dojo.lang.inArray(["transparent",""],_4e3));
-if(_4e3=="transparent"){
-_4e3=[255,255,255,0];
-}else{
-_4e3=dojo.gfx.color.extractRGB(_4e3);
 }
-return _4e3;
+ds.setStyle(node,"display","none");
 };
-dojo.provide("dojo.html.layout");
-dojo.html.sumAncestorProperties=function(node,prop){
+ds.setShowing=function(node,_3fc){
+ds[(_3fc?"show":"hide")](node);
+};
+ds.isShowing=function(node){
+return (ds.getStyleProperty(node,"display")!="none");
+};
+ds.toggleShowing=function(node){
+return ds._toggle(node,ds.isShowing,ds.setShowing);
+};
+ds.displayMap={tr:"",td:"",th:"",img:"inline",span:"inline",input:"inline",button:"inline"};
+ds.suggestDisplayByTagName=function(node){
 node=dojo.byId(node);
-if(!node){
-return 0;
+if(node&&node.tagName){
+var tag=node.tagName.toLowerCase();
+return (tag in ds.displayMap?ds.displayMap[tag]:"block");
 }
-var _4e6=0;
-while(node){
-if(dojo.html.getComputedStyle(node,"position")=="fixed"){
-return 0;
+};
+ds.setDisplay=function(node,_402){
+ds.setStyle(node,"display",(dojo.lang.isString(_402)?_402:(_402?ds.suggestDisplayByTagName(node):"none")));
+};
+ds.isDisplayed=function(node){
+return (ds.getComputedStyle(node,"display")!="none");
+};
+ds.toggleDisplay=function(node){
+return ds._toggle(node,ds.isDisplayed,ds.setDisplay);
+};
+ds.setVisibility=function(node,_406){
+ds.setStyle(node,"visibility",(dojo.lang.isString(_406)?_406:(_406?"visible":"hidden")));
+};
+ds.isVisible=function(node){
+return (ds.getComputedStyle(node,"visibility")!="hidden");
+};
+ds.toggleVisibility=function(node){
+return ds._toggle(node,ds.isVisible,ds.setVisibility);
+};
+ds.toCoordinateArray=function(_409,_40a){
+if(dojo.lang.isArray(_409)){
+while(_409.length<4){
+_409.push(0);
 }
-var val=node[prop];
-if(val){
-_4e6+=val-0;
-if(node==dojo.body()){
-break;
+while(_409.length>4){
+_409.pop();
 }
+var ret=_409;
+}else{
+var node=dojo.byId(_409);
+var pos=ds.getAbsolutePosition(node,_40a);
+var ret=[pos.x,pos.y,ds.getBorderBoxWidth(node),ds.getBorderBoxHeight(node)];
 }
-node=node.parentNode;
-}
-return _4e6;
+ret.x=ret[0];
+ret.y=ret[1];
+ret.w=ret[2];
+ret.h=ret[3];
+return ret;
 };
-dojo.html.setStyleAttributes=function(node,_4e9){
-node=dojo.byId(node);
-var _4ea=_4e9.replace(/(;)?\s*$/,"").split(";");
-for(var i=0;i<_4ea.length;i++){
-var _4ec=_4ea[i].split(":");
-var name=_4ec[0].replace(/\s*$/,"").replace(/^\s*/,"").toLowerCase();
-var _4ee=_4ec[1].replace(/\s*$/,"").replace(/^\s*/,"");
-switch(name){
-case "opacity":
-dojo.html.setOpacity(node,_4ee);
-break;
-case "content-height":
-dojo.html.setContentBox(node,{height:_4ee});
-break;
-case "content-width":
-dojo.html.setContentBox(node,{width:_4ee});
-break;
-case "outer-height":
-dojo.html.setMarginBox(node,{height:_4ee});
-break;
-case "outer-width":
-dojo.html.setMarginBox(node,{width:_4ee});
-break;
-default:
-node.style[dojo.html.toCamelCase(name)]=_4ee;
+})();
+dojo.provide("dojo.html");
+dojo.require("dojo.lang.func");
+dojo.require("dojo.dom");
+dojo.require("dojo.style");
+dojo.require("dojo.string");
+dojo.lang.mixin(dojo.html,dojo.dom);
+dojo.lang.mixin(dojo.html,dojo.style);
+dojo.html.clearSelection=function(){
+try{
+if(window["getSelection"]){
+if(dojo.render.html.safari){
+window.getSelection().collapse();
+}else{
+window.getSelection().removeAllRanges();
 }
+}else{
+if(document.selection){
+if(document.selection.empty){
+document.selection.empty();
+}else{
+if(document.selection.clear){
+document.selection.clear();
 }
-};
-dojo.html.boxSizing={MARGIN_BOX:"margin-box",BORDER_BOX:"border-box",PADDING_BOX:"padding-box",CONTENT_BOX:"content-box"};
-dojo.html.getAbsolutePosition=dojo.html.abs=function(node,_4f0,_4f1){
-node=dojo.byId(node,node.ownerDocument);
-var ret={x:0,y:0};
-var bs=dojo.html.boxSizing;
-if(!_4f1){
-_4f1=bs.CONTENT_BOX;
 }
-var _4f4=2;
-var _4f5;
-switch(_4f1){
-case bs.MARGIN_BOX:
-_4f5=3;
-break;
-case bs.BORDER_BOX:
-_4f5=2;
-break;
-case bs.PADDING_BOX:
-default:
-_4f5=1;
-break;
-case bs.CONTENT_BOX:
-_4f5=0;
-break;
 }
-var h=dojo.render.html;
-var db=document["body"]||document["documentElement"];
-if(h.ie){
-with(node.getBoundingClientRect()){
-ret.x=left-2;
-ret.y=top-2;
 }
-}else{
-if(document.getBoxObjectFor){
-_4f4=1;
-try{
-var bo=document.getBoxObjectFor(node);
-ret.x=bo.x-dojo.html.sumAncestorProperties(node,"scrollLeft");
-ret.y=bo.y-dojo.html.sumAncestorProperties(node,"scrollTop");
+return true;
 }
 catch(e){
+dojo.debug(e);
+return false;
 }
+};
+dojo.html.disableSelection=function(_40e){
+_40e=dojo.byId(_40e)||document.body;
+var h=dojo.render.html;
+if(h.mozilla){
+_40e.style.MozUserSelect="none";
 }else{
-if(node["offsetParent"]){
-var _4f9;
-if((h.safari)&&(node.style.getPropertyValue("position")=="absolute")&&(node.parentNode==db)){
-_4f9=db;
+if(h.safari){
+_40e.style.KhtmlUserSelect="none";
 }else{
-_4f9=db.parentNode;
+if(h.ie){
+_40e.unselectable="on";
+}else{
+return false;
 }
-if(node.parentNode!=db){
-var nd=node;
-if(dojo.render.html.opera){
-nd=db;
 }
-ret.x-=dojo.html.sumAncestorProperties(nd,"scrollLeft");
-ret.y-=dojo.html.sumAncestorProperties(nd,"scrollTop");
 }
-var _4fb=node;
-do{
-var n=_4fb["offsetLeft"];
-if(!h.opera||n>0){
-ret.x+=isNaN(n)?0:n;
-}
-var m=_4fb["offsetTop"];
-ret.y+=isNaN(m)?0:m;
-_4fb=_4fb.offsetParent;
-}while((_4fb!=_4f9)&&(_4fb!=null));
+return true;
+};
+dojo.html.enableSelection=function(_410){
+_410=dojo.byId(_410)||document.body;
+var h=dojo.render.html;
+if(h.mozilla){
+_410.style.MozUserSelect="";
 }else{
-if(node["x"]&&node["y"]){
-ret.x+=isNaN(node.x)?0:node.x;
-ret.y+=isNaN(node.y)?0:node.y;
+if(h.safari){
+_410.style.KhtmlUserSelect="";
+}else{
+if(h.ie){
+_410.unselectable="off";
+}else{
+return false;
 }
 }
 }
+return true;
+};
+dojo.html.selectElement=function(_412){
+_412=dojo.byId(_412);
+if(document.selection&&document.body.createTextRange){
+var _413=document.body.createTextRange();
+_413.moveToElementText(_412);
+_413.select();
+}else{
+if(window["getSelection"]){
+var _414=window.getSelection();
+if(_414["selectAllChildren"]){
+_414.selectAllChildren(_412);
 }
-if(_4f0){
-var _4fe=dojo.html.getScroll();
-ret.y+=_4fe.top;
-ret.x+=_4fe.left;
 }
-var _4ff=[dojo.html.getPaddingExtent,dojo.html.getBorderExtent,dojo.html.getMarginExtent];
-if(_4f4>_4f5){
-for(var i=_4f5;i<_4f4;++i){
-ret.y+=_4ff[i](node,"top");
-ret.x+=_4ff[i](node,"left");
 }
+};
+dojo.html.selectInputText=function(_415){
+_415=dojo.byId(_415);
+if(document.selection&&document.body.createTextRange){
+var _416=_415.createTextRange();
+_416.moveStart("character",0);
+_416.moveEnd("character",_415.value.length);
+_416.select();
 }else{
-if(_4f4<_4f5){
-for(var i=_4f5;i>_4f4;--i){
-ret.y-=_4ff[i-1](node,"top");
-ret.x-=_4ff[i-1](node,"left");
+if(window["getSelection"]){
+var _417=window.getSelection();
+_415.setSelectionRange(0,_415.value.length);
 }
 }
+_415.focus();
+};
+dojo.html.isSelectionCollapsed=function(){
+if(document["selection"]){
+return document.selection.createRange().text=="";
+}else{
+if(window["getSelection"]){
+var _418=window.getSelection();
+if(dojo.lang.isString(_418)){
+return _418=="";
+}else{
+return _418.isCollapsed;
 }
-ret.top=ret.y;
-ret.left=ret.x;
-return ret;
+}
+}
 };
-dojo.html.isPositionAbsolute=function(node){
-return (dojo.html.getComputedStyle(node,"position")=="absolute");
+dojo.html.getEventTarget=function(evt){
+if(!evt){
+evt=window.event||{};
+}
+var t=(evt.srcElement?evt.srcElement:(evt.target?evt.target:null));
+while((t)&&(t.nodeType!=1)){
+t=t.parentNode;
+}
+return t;
 };
-dojo.html._sumPixelValues=function(node,_503,_504){
-var _505=0;
-for(var x=0;x<_503.length;x++){
-_505+=dojo.html.getPixelValue(node,_503[x],_504);
+dojo.html.getDocumentWidth=function(){
+dojo.deprecated("dojo.html.getDocument*","replaced by dojo.html.getViewport*","0.4");
+return dojo.html.getViewportWidth();
+};
+dojo.html.getDocumentHeight=function(){
+dojo.deprecated("dojo.html.getDocument*","replaced by dojo.html.getViewport*","0.4");
+return dojo.html.getViewportHeight();
+};
+dojo.html.getDocumentSize=function(){
+dojo.deprecated("dojo.html.getDocument*","replaced of dojo.html.getViewport*","0.4");
+return dojo.html.getViewportSize();
+};
+dojo.html.getViewportWidth=function(){
+var w=0;
+if(window.innerWidth){
+w=window.innerWidth;
 }
-return _505;
+if(dojo.exists(document,"documentElement.clientWidth")){
+var w2=document.documentElement.clientWidth;
+if(!w||w2&&w2<w){
+w=w2;
+}
+return w;
+}
+if(document.body){
+return document.body.clientWidth;
+}
+return 0;
 };
-dojo.html.getMargin=function(node){
-return {width:dojo.html._sumPixelValues(node,["margin-left","margin-right"],(dojo.html.getComputedStyle(node,"position")=="absolute")),height:dojo.html._sumPixelValues(node,["margin-top","margin-bottom"],(dojo.html.getComputedStyle(node,"position")=="absolute"))};
+dojo.html.getViewportHeight=function(){
+if(window.innerHeight){
+return window.innerHeight;
+}
+if(dojo.exists(document,"documentElement.clientHeight")){
+return document.documentElement.clientHeight;
+}
+if(document.body){
+return document.body.clientHeight;
+}
+return 0;
 };
-dojo.html.getBorder=function(node){
-return {width:dojo.html.getBorderExtent(node,"left")+dojo.html.getBorderExtent(node,"right"),height:dojo.html.getBorderExtent(node,"top")+dojo.html.getBorderExtent(node,"bottom")};
+dojo.html.getViewportSize=function(){
+var ret=[dojo.html.getViewportWidth(),dojo.html.getViewportHeight()];
+ret.w=ret[0];
+ret.h=ret[1];
+return ret;
 };
-dojo.html.getBorderExtent=function(node,side){
-return (dojo.html.getStyle(node,"border-"+side+"-style")=="none"?0:dojo.html.getPixelValue(node,"border-"+side+"-width"));
+dojo.html.getScrollTop=function(){
+return window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;
 };
-dojo.html.getMarginExtent=function(node,side){
-return dojo.html._sumPixelValues(node,["margin-"+side],dojo.html.isPositionAbsolute(node));
+dojo.html.getScrollLeft=function(){
+return window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;
 };
-dojo.html.getPaddingExtent=function(node,side){
-return dojo.html._sumPixelValues(node,["padding-"+side],true);
+dojo.html.getScrollOffset=function(){
+var off=[dojo.html.getScrollLeft(),dojo.html.getScrollTop()];
+off.x=off[0];
+off.y=off[1];
+return off;
 };
-dojo.html.getPadding=function(node){
-return {width:dojo.html._sumPixelValues(node,["padding-left","padding-right"],true),height:dojo.html._sumPixelValues(node,["padding-top","padding-bottom"],true)};
+dojo.html.getParentOfType=function(node,type){
+dojo.deprecated("dojo.html.getParentOfType","replaced by dojo.html.getParentByType*","0.4");
+return dojo.html.getParentByType(node,type);
 };
-dojo.html.getPadBorder=function(node){
-var pad=dojo.html.getPadding(node);
-var _512=dojo.html.getBorder(node);
-return {width:pad.width+_512.width,height:pad.height+_512.height};
+dojo.html.getParentByType=function(node,type){
+var _423=dojo.byId(node);
+type=type.toLowerCase();
+while((_423)&&(_423.nodeName.toLowerCase()!=type)){
+if(_423==(document["body"]||document["documentElement"])){
+return null;
+}
+_423=_423.parentNode;
+}
+return _423;
 };
-dojo.html.getBoxSizing=function(node){
-var h=dojo.render.html;
-var bs=dojo.html.boxSizing;
-if(((h.ie)||(h.opera))&&node.nodeName.toLowerCase()!="img"){
-var cm=document["compatMode"];
-if((cm=="BackCompat")||(cm=="QuirksMode")){
-return bs.BORDER_BOX;
-}else{
-return bs.CONTENT_BOX;
+dojo.html.getAttribute=function(node,attr){
+node=dojo.byId(node);
+if((!node)||(!node.getAttribute)){
+return null;
 }
-}else{
-if(arguments.length==0){
-node=document.documentElement;
+var ta=typeof attr=="string"?attr:new String(attr);
+var v=node.getAttribute(ta.toUpperCase());
+if((v)&&(typeof v=="string")&&(v!="")){
+return v;
 }
-var _517;
-if(!h.ie){
-_517=dojo.html.getStyle(node,"-moz-box-sizing");
-if(!_517){
-_517=dojo.html.getStyle(node,"box-sizing");
+if(v&&v.value){
+return v.value;
 }
+if((node.getAttributeNode)&&(node.getAttributeNode(ta))){
+return (node.getAttributeNode(ta)).value;
+}else{
+if(node.getAttribute(ta)){
+return node.getAttribute(ta);
+}else{
+if(node.getAttribute(ta.toLowerCase())){
+return node.getAttribute(ta.toLowerCase());
 }
-return (_517?_517:bs.CONTENT_BOX);
 }
+}
+return null;
 };
-dojo.html.isBorderBox=function(node){
-return (dojo.html.getBoxSizing(node)==dojo.html.boxSizing.BORDER_BOX);
-};
-dojo.html.getBorderBox=function(node){
+dojo.html.hasAttribute=function(node,attr){
 node=dojo.byId(node);
-return {width:node.offsetWidth,height:node.offsetHeight};
+return dojo.html.getAttribute(node,attr)?true:false;
 };
-dojo.html.getPaddingBox=function(node){
-var box=dojo.html.getBorderBox(node);
-var _51c=dojo.html.getBorder(node);
-return {width:box.width-_51c.width,height:box.height-_51c.height};
-};
-dojo.html.getContentBox=function(node){
+dojo.html.getClass=function(node){
 node=dojo.byId(node);
-var _51e=dojo.html.getPadBorder(node);
-return {width:node.offsetWidth-_51e.width,height:node.offsetHeight-_51e.height};
-};
-dojo.html.setContentBox=function(node,args){
-node=dojo.byId(node);
-var _521=0;
-var _522=0;
-var isbb=dojo.html.isBorderBox(node);
-var _524=(isbb?dojo.html.getPadBorder(node):{width:0,height:0});
-var ret={};
-if(typeof args.width!="undefined"){
-_521=args.width+_524.width;
-ret.width=dojo.html.setPositivePixelValue(node,"width",_521);
+if(!node){
+return "";
 }
-if(typeof args.height!="undefined"){
-_522=args.height+_524.height;
-ret.height=dojo.html.setPositivePixelValue(node,"height",_522);
+var cs="";
+if(node.className){
+cs=node.className;
+}else{
+if(dojo.html.hasAttribute(node,"class")){
+cs=dojo.html.getAttribute(node,"class");
 }
-return ret;
+}
+return dojo.string.trim(cs);
 };
-dojo.html.getMarginBox=function(node){
-var _527=dojo.html.getBorderBox(node);
-var _528=dojo.html.getMargin(node);
-return {width:_527.width+_528.width,height:_527.height+_528.height};
+dojo.html.getClasses=function(node){
+var c=dojo.html.getClass(node);
+return (c=="")?[]:c.split(/\s+/g);
 };
-dojo.html.setMarginBox=function(node,args){
+dojo.html.hasClass=function(node,_42f){
+return dojo.lang.inArray(dojo.html.getClasses(node),_42f);
+};
+dojo.html.prependClass=function(node,_431){
+_431+=" "+dojo.html.getClass(node);
+return dojo.html.setClass(node,_431);
+};
+dojo.html.addClass=function(node,_433){
+if(dojo.html.hasClass(node,_433)){
+return false;
+}
+_433=dojo.string.trim(dojo.html.getClass(node)+" "+_433);
+return dojo.html.setClass(node,_433);
+};
+dojo.html.setClass=function(node,_435){
 node=dojo.byId(node);
-var _52b=0;
-var _52c=0;
-var isbb=dojo.html.isBorderBox(node);
-var _52e=(!isbb?dojo.html.getPadBorder(node):{width:0,height:0});
-var _52f=dojo.html.getMargin(node);
-var ret={};
-if(typeof args.width!="undefined"){
-_52b=args.width-_52e.width;
-_52b-=_52f.width;
-ret.width=dojo.html.setPositivePixelValue(node,"width",_52b);
+var cs=new String(_435);
+try{
+if(typeof node.className=="string"){
+node.className=cs;
+}else{
+if(node.setAttribute){
+node.setAttribute("class",_435);
+node.className=cs;
+}else{
+return false;
 }
-if(typeof args.height!="undefined"){
-_52c=args.height-_52e.height;
-_52c-=_52f.height;
-ret.height=dojo.html.setPositivePixelValue(node,"height",_52c);
 }
-return ret;
+}
+catch(e){
+dojo.debug("dojo.html.setClass() failed",e);
+}
+return true;
 };
-dojo.html.getElementBox=function(node,type){
-var bs=dojo.html.boxSizing;
-switch(type){
-case bs.MARGIN_BOX:
-return dojo.html.getMarginBox(node);
-case bs.BORDER_BOX:
-return dojo.html.getBorderBox(node);
-case bs.PADDING_BOX:
-return dojo.html.getPaddingBox(node);
-case bs.CONTENT_BOX:
-default:
-return dojo.html.getContentBox(node);
+dojo.html.removeClass=function(node,_438,_439){
+var _438=dojo.string.trim(new String(_438));
+try{
+var cs=dojo.html.getClasses(node);
+var nca=[];
+if(_439){
+for(var i=0;i<cs.length;i++){
+if(cs[i].indexOf(_438)==-1){
+nca.push(cs[i]);
 }
+}
+}else{
+for(var i=0;i<cs.length;i++){
+if(cs[i]!=_438){
+nca.push(cs[i]);
+}
+}
+}
+dojo.html.setClass(node,nca.join(" "));
+}
+catch(e){
+dojo.debug("dojo.html.removeClass() failed",e);
+}
+return true;
 };
-dojo.html.toCoordinateObject=dojo.html.toCoordinateArray=function(_534,_535,_536){
-if(_534 instanceof Array||typeof _534=="array"){
-dojo.deprecated("dojo.html.toCoordinateArray","use dojo.html.toCoordinateObject({left: , top: , width: , height: }) instead","0.5");
-while(_534.length<4){
-_534.push(0);
+dojo.html.replaceClass=function(node,_43e,_43f){
+dojo.html.removeClass(node,_43f);
+dojo.html.addClass(node,_43e);
+};
+dojo.html.classMatchType={ContainsAll:0,ContainsAny:1,IsOnly:2};
+dojo.html.getElementsByClass=function(_440,_441,_442,_443,_444){
+_441=dojo.byId(_441)||document;
+var _445=_440.split(/\s+/g);
+var _446=[];
+if(_443!=1&&_443!=2){
+_443=0;
 }
-while(_534.length>4){
-_534.pop();
+var _447=new RegExp("(\\s|^)(("+_445.join(")|(")+"))(\\s|$)");
+var _448=[];
+if(!_444&&document.evaluate){
+var _449="//"+(_442||"*")+"[contains(";
+if(_443!=dojo.html.classMatchType.ContainsAny){
+_449+="concat(' ', at class,' '), ' "+_445.join(" ') and contains(concat(' ', at class,' '), ' ")+" ')]";
+}else{
+_449+="concat(' ', at class,' '), ' "+_445.join(" ')) or contains(concat(' ', at class,' '), ' ")+" ')]";
 }
-var ret={left:_534[0],top:_534[1],width:_534[2],height:_534[3]};
+var _44a=document.evaluate(_449,_441,null,XPathResult.ANY_TYPE,null);
+var _44b=_44a.iterateNext();
+while(_44b){
+try{
+_448.push(_44b);
+_44b=_44a.iterateNext();
+}
+catch(e){
+break;
+}
+}
+return _448;
 }else{
-if(!_534.nodeType&&!(_534 instanceof String||typeof _534=="string")&&("width" in _534||"height" in _534||"left" in _534||"x" in _534||"top" in _534||"y" in _534)){
-var ret={left:_534.left||_534.x||0,top:_534.top||_534.y||0,width:_534.width||0,height:_534.height||0};
+if(!_442){
+_442="*";
+}
+_448=_441.getElementsByTagName(_442);
+var node,i=0;
+outer:
+while(node=_448[i++]){
+var _44d=dojo.html.getClasses(node);
+if(_44d.length==0){
+continue outer;
+}
+var _44e=0;
+for(var j=0;j<_44d.length;j++){
+if(_447.test(_44d[j])){
+if(_443==dojo.html.classMatchType.ContainsAny){
+_446.push(node);
+continue outer;
 }else{
-var node=dojo.byId(_534);
-var pos=dojo.html.abs(node,_535,_536);
-var _53a=dojo.html.getMarginBox(node);
-var ret={left:pos.left,top:pos.top,width:_53a.width,height:_53a.height};
+_44e++;
 }
+}else{
+if(_443==dojo.html.classMatchType.IsOnly){
+continue outer;
 }
-ret.x=ret.left;
-ret.y=ret.top;
-return ret;
+}
+}
+if(_44e==_445.length){
+if((_443==dojo.html.classMatchType.IsOnly)&&(_44e==_44d.length)){
+_446.push(node);
+}else{
+if(_443==dojo.html.classMatchType.ContainsAll){
+_446.push(node);
+}
+}
+}
+}
+return _446;
+}
 };
-dojo.html.setMarginBoxWidth=dojo.html.setOuterWidth=function(node,_53c){
-return dojo.html._callDeprecated("setMarginBoxWidth","setMarginBox",arguments,"width");
+dojo.html.getElementsByClassName=dojo.html.getElementsByClass;
+dojo.html.getCursorPosition=function(e){
+e=e||window.event;
+var _451={x:0,y:0};
+if(e.pageX||e.pageY){
+_451.x=e.pageX;
+_451.y=e.pageY;
+}else{
+var de=document.documentElement;
+var db=document.body;
+_451.x=e.clientX+((de||db)["scrollLeft"])-((de||db)["clientLeft"]);
+_451.y=e.clientY+((de||db)["scrollTop"])-((de||db)["clientTop"]);
+}
+return _451;
 };
-dojo.html.setMarginBoxHeight=dojo.html.setOuterHeight=function(){
-return dojo.html._callDeprecated("setMarginBoxHeight","setMarginBox",arguments,"height");
+dojo.html.overElement=function(_454,e){
+_454=dojo.byId(_454);
+var _456=dojo.html.getCursorPosition(e);
+with(dojo.html){
+var top=getAbsoluteY(_454,true);
+var _458=top+getInnerHeight(_454);
+var left=getAbsoluteX(_454,true);
+var _45a=left+getInnerWidth(_454);
+}
+return (_456.x>=left&&_456.x<=_45a&&_456.y>=top&&_456.y<=_458);
 };
-dojo.html.getMarginBoxWidth=dojo.html.getOuterWidth=function(){
-return dojo.html._callDeprecated("getMarginBoxWidth","getMarginBox",arguments,null,"width");
+dojo.html.setActiveStyleSheet=function(_45b){
+var i=0,a,els=document.getElementsByTagName("link");
+while(a=els[i++]){
+if(a.getAttribute("rel").indexOf("style")!=-1&&a.getAttribute("title")){
+a.disabled=true;
+if(a.getAttribute("title")==_45b){
+a.disabled=false;
+}
+}
+}
 };
-dojo.html.getMarginBoxHeight=dojo.html.getOuterHeight=function(){
-return dojo.html._callDeprecated("getMarginBoxHeight","getMarginBox",arguments,null,"height");
+dojo.html.getActiveStyleSheet=function(){
+var i=0,a,els=document.getElementsByTagName("link");
+while(a=els[i++]){
+if(a.getAttribute("rel").indexOf("style")!=-1&&a.getAttribute("title")&&!a.disabled){
+return a.getAttribute("title");
+}
+}
+return null;
 };
-dojo.html.getTotalOffset=function(node,type,_53f){
-return dojo.html._callDeprecated("getTotalOffset","getAbsolutePosition",arguments,null,type);
+dojo.html.getPreferredStyleSheet=function(){
+var i=0,a,els=document.getElementsByTagName("link");
+while(a=els[i++]){
+if(a.getAttribute("rel").indexOf("style")!=-1&&a.getAttribute("rel").indexOf("alt")==-1&&a.getAttribute("title")){
+return a.getAttribute("title");
+}
+}
+return null;
 };
-dojo.html.getAbsoluteX=function(node,_541){
-return dojo.html._callDeprecated("getAbsoluteX","getAbsolutePosition",arguments,null,"x");
+dojo.html.body=function(){
+return document.body||document.getElementsByTagName("body")[0];
 };
-dojo.html.getAbsoluteY=function(node,_543){
-return dojo.html._callDeprecated("getAbsoluteY","getAbsolutePosition",arguments,null,"y");
+dojo.html.isTag=function(node){
+node=dojo.byId(node);
+if(node&&node.tagName){
+var arr=dojo.lang.map(dojo.lang.toArray(arguments,1),function(a){
+return String(a).toLowerCase();
+});
+return arr[dojo.lang.find(node.tagName.toLowerCase(),arr)]||"";
+}
+return "";
 };
-dojo.html.totalOffsetLeft=function(node,_545){
-return dojo.html._callDeprecated("totalOffsetLeft","getAbsolutePosition",arguments,null,"left");
+dojo.html.copyStyle=function(_462,_463){
+if(dojo.lang.isUndefined(_463.style.cssText)){
+_462.setAttribute("style",_463.getAttribute("style"));
+}else{
+_462.style.cssText=_463.style.cssText;
+}
+dojo.html.addClass(_462,dojo.html.getClass(_463));
 };
-dojo.html.totalOffsetTop=function(node,_547){
-return dojo.html._callDeprecated("totalOffsetTop","getAbsolutePosition",arguments,null,"top");
+dojo.html._callExtrasDeprecated=function(_464,args){
+var _466="dojo.html.extras";
+dojo.deprecated("dojo.html."+_464,"moved to "+_466,"0.4");
+dojo["require"](_466);
+return dojo.html[_464].apply(dojo.html,args);
 };
-dojo.html.getMarginWidth=function(node){
-return dojo.html._callDeprecated("getMarginWidth","getMargin",arguments,null,"width");
+dojo.html.createNodesFromText=function(){
+return dojo.html._callExtrasDeprecated("createNodesFromText",arguments);
 };
-dojo.html.getMarginHeight=function(node){
-return dojo.html._callDeprecated("getMarginHeight","getMargin",arguments,null,"height");
+dojo.html.gravity=function(){
+return dojo.html._callExtrasDeprecated("gravity",arguments);
 };
-dojo.html.getBorderWidth=function(node){
-return dojo.html._callDeprecated("getBorderWidth","getBorder",arguments,null,"width");
+dojo.html.placeOnScreen=function(){
+return dojo.html._callExtrasDeprecated("placeOnScreen",arguments);
 };
-dojo.html.getBorderHeight=function(node){
-return dojo.html._callDeprecated("getBorderHeight","getBorder",arguments,null,"height");
+dojo.html.placeOnScreenPoint=function(){
+return dojo.html._callExtrasDeprecated("placeOnScreenPoint",arguments);
 };
-dojo.html.getPaddingWidth=function(node){
-return dojo.html._callDeprecated("getPaddingWidth","getPadding",arguments,null,"width");
+dojo.html.renderedTextContent=function(){
+return dojo.html._callExtrasDeprecated("renderedTextContent",arguments);
 };
-dojo.html.getPaddingHeight=function(node){
-return dojo.html._callDeprecated("getPaddingHeight","getPadding",arguments,null,"height");
+dojo.html.BackgroundIframe=function(){
+return dojo.html._callExtrasDeprecated("BackgroundIframe",arguments);
 };
-dojo.html.getPadBorderWidth=function(node){
-return dojo.html._callDeprecated("getPadBorderWidth","getPadBorder",arguments,null,"width");
-};
-dojo.html.getPadBorderHeight=function(node){
-return dojo.html._callDeprecated("getPadBorderHeight","getPadBorder",arguments,null,"height");
-};
-dojo.html.getBorderBoxWidth=dojo.html.getInnerWidth=function(){
-return dojo.html._callDeprecated("getBorderBoxWidth","getBorderBox",arguments,null,"width");
-};
-dojo.html.getBorderBoxHeight=dojo.html.getInnerHeight=function(){
-return dojo.html._callDeprecated("getBorderBoxHeight","getBorderBox",arguments,null,"height");
-};
-dojo.html.getContentBoxWidth=dojo.html.getContentWidth=function(){
-return dojo.html._callDeprecated("getContentBoxWidth","getContentBox",arguments,null,"width");
-};
-dojo.html.getContentBoxHeight=dojo.html.getContentHeight=function(){
-return dojo.html._callDeprecated("getContentBoxHeight","getContentBox",arguments,null,"height");
-};
-dojo.html.setContentBoxWidth=dojo.html.setContentWidth=function(node,_551){
-return dojo.html._callDeprecated("setContentBoxWidth","setContentBox",arguments,"width");
-};
-dojo.html.setContentBoxHeight=dojo.html.setContentHeight=function(node,_553){
-return dojo.html._callDeprecated("setContentBoxHeight","setContentBox",arguments,"height");
-};
 dojo.provide("dojo.lfx.html");
-dojo.lfx.html._byId=function(_554){
-if(!_554){
+dojo.require("dojo.lfx.Animation");
+dojo.require("dojo.html");
+dojo.lfx.html._byId=function(_467){
+if(!_467){
 return [];
 }
-if(dojo.lang.isArrayLike(_554)){
-if(!_554.alreadyChecked){
+if(dojo.lang.isArray(_467)){
+if(!_467.alreadyChecked){
 var n=[];
-dojo.lang.forEach(_554,function(node){
+dojo.lang.forEach(_467,function(node){
 n.push(dojo.byId(node));
 });
 n.alreadyChecked=true;
 return n;
 }else{
-return _554;
+return _467;
 }
 }else{
 var n=[];
-n.push(dojo.byId(_554));
+n.push(dojo.byId(_467));
 n.alreadyChecked=true;
 return n;
 }
 };
-dojo.lfx.html.propertyAnimation=function(_557,_558,_559,_55a,_55b){
-_557=dojo.lfx.html._byId(_557);
-var _55c={"propertyMap":_558,"nodes":_557,"duration":_559,"easing":_55a||dojo.lfx.easeDefault};
-var _55d=function(args){
-if(args.nodes.length==1){
-var pm=args.propertyMap;
-if(!dojo.lang.isArray(args.propertyMap)){
-var parr=[];
-for(var _561 in pm){
-pm[_561].property=_561;
-parr.push(pm[_561]);
-}
-pm=args.propertyMap=parr;
-}
-dojo.lang.forEach(pm,function(prop){
-if(dj_undef("start",prop)){
+dojo.lfx.html.propertyAnimation=function(_46a,_46b,_46c,_46d){
+_46a=dojo.lfx.html._byId(_46a);
+if(_46a.length==1){
+dojo.lang.forEach(_46b,function(prop){
+if(typeof prop["start"]=="undefined"){
 if(prop.property!="opacity"){
-prop.start=parseInt(dojo.html.getComputedStyle(args.nodes[0],prop.property));
+prop.start=parseInt(dojo.style.getComputedStyle(_46a[0],prop.property));
 }else{
-prop.start=dojo.html.getOpacity(args.nodes[0]);
+prop.start=dojo.style.getOpacity(_46a[0]);
 }
 }
 });
 }
+var _46f=function(_470){
+var _471=new Array(_470.length);
+for(var i=0;i<_470.length;i++){
+_471[i]=Math.round(_470[i]);
+}
+return _471;
 };
-var _563=function(_564){
-var _565=[];
-dojo.lang.forEach(_564,function(c){
-_565.push(Math.round(c));
-});
-return _565;
-};
-var _567=function(n,_569){
+var _473=function(n,_475){
 n=dojo.byId(n);
 if(!n||!n.style){
 return;
 }
-for(var s in _569){
-try{
+for(var s in _475){
 if(s=="opacity"){
-dojo.html.setOpacity(n,_569[s]);
+dojo.style.setOpacity(n,_475[s]);
 }else{
-n.style[s]=_569[s];
+n.style[s]=_475[s];
 }
 }
-catch(e){
-dojo.debug(e);
-}
-}
 };
-var _56b=function(_56c){
-this._properties=_56c;
-this.diffs=new Array(_56c.length);
-dojo.lang.forEach(_56c,function(prop,i){
-if(dojo.lang.isFunction(prop.start)){
-prop.start=prop.start(prop,i);
-}
-if(dojo.lang.isFunction(prop.end)){
-prop.end=prop.end(prop,i);
-}
+var _477=function(_478){
+this._properties=_478;
+this.diffs=new Array(_478.length);
+dojo.lang.forEach(_478,function(prop,i){
 if(dojo.lang.isArray(prop.start)){
 this.diffs[i]=null;
 }else{
-if(prop.start instanceof dojo.gfx.color.Color){
+if(prop.start instanceof dojo.graphics.color.Color){
 prop.startRgb=prop.start.toRgb();
 prop.endRgb=prop.end.toRgb();
 }else{
@@ -6043,397 +5200,392 @@
 this.getValue=function(n){
 var ret={};
 dojo.lang.forEach(this._properties,function(prop,i){
-var _573=null;
+var _47f=null;
 if(dojo.lang.isArray(prop.start)){
 }else{
-if(prop.start instanceof dojo.gfx.color.Color){
-_573=(prop.units||"rgb")+"(";
+if(prop.start instanceof dojo.graphics.color.Color){
+_47f=(prop.units||"rgb")+"(";
 for(var j=0;j<prop.startRgb.length;j++){
-_573+=Math.round(((prop.endRgb[j]-prop.startRgb[j])*n)+prop.startRgb[j])+(j<prop.startRgb.length-1?",":"");
+_47f+=Math.round(((prop.endRgb[j]-prop.startRgb[j])*n)+prop.startRgb[j])+(j<prop.startRgb.length-1?",":"");
 }
-_573+=")";
+_47f+=")";
 }else{
-_573=((this.diffs[i])*n)+prop.start+(prop.property!="opacity"?prop.units||"px":"");
+_47f=((this.diffs[i])*n)+prop.start+(prop.property!="opacity"?prop.units||"px":"");
 }
 }
-ret[dojo.html.toCamelCase(prop.property)]=_573;
+ret[dojo.style.toCamelCase(prop.property)]=_47f;
 },this);
 return ret;
 };
 };
-var anim=new dojo.lfx.Animation({beforeBegin:function(){
-_55d(_55c);
-anim.curve=new _56b(_55c.propertyMap);
-},onAnimate:function(_576){
-dojo.lang.forEach(_55c.nodes,function(node){
-_567(node,_576);
+var anim=new dojo.lfx.Animation({onAnimate:function(_482){
+dojo.lang.forEach(_46a,function(node){
+_473(node,_482);
 });
-}},_55c.duration,null,_55c.easing);
-if(_55b){
-for(var x in _55b){
-if(dojo.lang.isFunction(_55b[x])){
-anim.connect(x,anim,_55b[x]);
-}
-}
-}
+}},_46c,new _477(_46b),_46d);
 return anim;
 };
-dojo.lfx.html._makeFadeable=function(_579){
-var _57a=function(node){
+dojo.lfx.html._makeFadeable=function(_484){
+var _485=function(node){
 if(dojo.render.html.ie){
-if((node.style.zoom.length==0)&&(dojo.html.getStyle(node,"zoom")=="normal")){
+if((node.style.zoom.length==0)&&(dojo.style.getStyle(node,"zoom")=="normal")){
 node.style.zoom="1";
 }
-if((node.style.width.length==0)&&(dojo.html.getStyle(node,"width")=="auto")){
+if((node.style.width.length==0)&&(dojo.style.getStyle(node,"width")=="auto")){
 node.style.width="auto";
 }
 }
 };
-if(dojo.lang.isArrayLike(_579)){
-dojo.lang.forEach(_579,_57a);
+if(dojo.lang.isArrayLike(_484)){
+dojo.lang.forEach(_484,_485);
 }else{
-_57a(_579);
+_485(_484);
 }
 };
-dojo.lfx.html.fade=function(_57c,_57d,_57e,_57f,_580){
-_57c=dojo.lfx.html._byId(_57c);
-var _581={property:"opacity"};
-if(!dj_undef("start",_57d)){
-_581.start=_57d.start;
-}else{
-_581.start=function(){
-return dojo.html.getOpacity(_57c[0]);
+dojo.lfx.html.fadeIn=function(_487,_488,_489,_48a){
+_487=dojo.lfx.html._byId(_487);
+dojo.lfx.html._makeFadeable(_487);
+var anim=dojo.lfx.propertyAnimation(_487,[{property:"opacity",start:dojo.style.getOpacity(_487[0]),end:1}],_488,_489);
+if(_48a){
+var _48c=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
 };
+anim.onEnd=function(){
+_48c();
+_48a(_487,anim);
+};
 }
-if(!dj_undef("end",_57d)){
-_581.end=_57d.end;
-}else{
-dojo.raise("dojo.lfx.html.fade needs an end value");
-}
-var anim=dojo.lfx.propertyAnimation(_57c,[_581],_57e,_57f);
-anim.connect("beforeBegin",function(){
-dojo.lfx.html._makeFadeable(_57c);
-});
-if(_580){
-anim.connect("onEnd",function(){
-_580(_57c,anim);
-});
-}
 return anim;
 };
-dojo.lfx.html.fadeIn=function(_583,_584,_585,_586){
-return dojo.lfx.html.fade(_583,{end:1},_584,_585,_586);
+dojo.lfx.html.fadeOut=function(_48d,_48e,_48f,_490){
+_48d=dojo.lfx.html._byId(_48d);
+dojo.lfx.html._makeFadeable(_48d);
+var anim=dojo.lfx.propertyAnimation(_48d,[{property:"opacity",start:dojo.style.getOpacity(_48d[0]),end:0}],_48e,_48f);
+if(_490){
+var _492=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
 };
-dojo.lfx.html.fadeOut=function(_587,_588,_589,_58a){
-return dojo.lfx.html.fade(_587,{end:0},_588,_589,_58a);
+anim.onEnd=function(){
+_492();
+_490(_48d,anim);
 };
-dojo.lfx.html.fadeShow=function(_58b,_58c,_58d,_58e){
-_58b=dojo.lfx.html._byId(_58b);
-dojo.lang.forEach(_58b,function(node){
-dojo.html.setOpacity(node,0);
-});
-var anim=dojo.lfx.html.fadeIn(_58b,_58c,_58d,_58e);
-anim.connect("beforeBegin",function(){
-if(dojo.lang.isArrayLike(_58b)){
-dojo.lang.forEach(_58b,dojo.html.show);
+}
+return anim;
+};
+dojo.lfx.html.fadeShow=function(_493,_494,_495,_496){
+var anim=dojo.lfx.html.fadeIn(_493,_494,_495,_496);
+var _498=(anim["beforeBegin"])?dojo.lang.hitch(anim,"beforeBegin"):function(){
+};
+anim.beforeBegin=function(){
+_498();
+if(dojo.lang.isArrayLike(_493)){
+dojo.lang.forEach(_493,dojo.style.show);
 }else{
-dojo.html.show(_58b);
+dojo.style.show(_493);
 }
-});
+};
 return anim;
 };
-dojo.lfx.html.fadeHide=function(_591,_592,_593,_594){
-var anim=dojo.lfx.html.fadeOut(_591,_592,_593,function(){
-if(dojo.lang.isArrayLike(_591)){
-dojo.lang.forEach(_591,dojo.html.hide);
+dojo.lfx.html.fadeHide=function(_499,_49a,_49b,_49c){
+var anim=dojo.lfx.html.fadeOut(_499,_49a,_49b,function(){
+if(dojo.lang.isArrayLike(_499)){
+dojo.lang.forEach(_499,dojo.style.hide);
 }else{
-dojo.html.hide(_591);
+dojo.style.hide(_499);
 }
-if(_594){
-_594(_591,anim);
+if(_49c){
+_49c(_499,anim);
 }
 });
 return anim;
 };
-dojo.lfx.html.wipeIn=function(_596,_597,_598,_599){
-_596=dojo.lfx.html._byId(_596);
-var _59a=[];
-dojo.lang.forEach(_596,function(node){
-var _59c={};
-var _59d,_59e,_59f;
-with(node.style){
-_59d=top;
-_59e=left;
-_59f=position;
-top="-9999px";
-left="-9999px";
-position="absolute";
-display="";
+dojo.lfx.html.wipeIn=function(_49e,_49f,_4a0,_4a1){
+_49e=dojo.lfx.html._byId(_49e);
+var _4a2=[];
+dojo.lang.forEach(_49e,function(node){
+var _4a4=dojo.style.getStyle(node,"overflow");
+if(_4a4=="visible"){
+node.style.overflow="hidden";
 }
-var _5a0=dojo.html.getBorderBox(node).height;
-with(node.style){
-top=_59d;
-left=_59e;
-position=_59f;
-display="none";
+node.style.height="0px";
+dojo.style.show(node);
+var anim=dojo.lfx.propertyAnimation(node,[{property:"height",start:0,end:node.scrollHeight}],_49f,_4a0);
+var _4a6=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4a6();
+node.style.overflow=_4a4;
+node.style.height="auto";
+if(_4a1){
+_4a1(node,anim);
 }
-var anim=dojo.lfx.propertyAnimation(node,{"height":{start:1,end:function(){
-return _5a0;
-}}},_597,_598);
-anim.connect("beforeBegin",function(){
-_59c.overflow=node.style.overflow;
-_59c.height=node.style.height;
-with(node.style){
-overflow="hidden";
-height="1px";
-}
-dojo.html.show(node);
+};
+_4a2.push(anim);
 });
-anim.connect("onEnd",function(){
-with(node.style){
-overflow=_59c.overflow;
-height=_59c.height;
+if(_49e.length>1){
+return dojo.lfx.combine(_4a2);
+}else{
+return _4a2[0];
 }
-if(_599){
-_599(node,anim);
+};
+dojo.lfx.html.wipeOut=function(_4a7,_4a8,_4a9,_4aa){
+_4a7=dojo.lfx.html._byId(_4a7);
+var _4ab=[];
+dojo.lang.forEach(_4a7,function(node){
+var _4ad=dojo.style.getStyle(node,"overflow");
+if(_4ad=="visible"){
+node.style.overflow="hidden";
 }
-});
-_59a.push(anim);
-});
-return dojo.lfx.combine(_59a);
+dojo.style.show(node);
+var anim=dojo.lfx.propertyAnimation(node,[{property:"height",start:dojo.style.getContentBoxHeight(node),end:0}],_4a8,_4a9);
+var _4af=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
 };
-dojo.lfx.html.wipeOut=function(_5a2,_5a3,_5a4,_5a5){
-_5a2=dojo.lfx.html._byId(_5a2);
-var _5a6=[];
-dojo.lang.forEach(_5a2,function(node){
-var _5a8={};
-var anim=dojo.lfx.propertyAnimation(node,{"height":{start:function(){
-return dojo.html.getContentBox(node).height;
-},end:1}},_5a3,_5a4,{"beforeBegin":function(){
-_5a8.overflow=node.style.overflow;
-_5a8.height=node.style.height;
-with(node.style){
-overflow="hidden";
+anim.onEnd=function(){
+_4af();
+dojo.style.hide(node);
+node.style.overflow=_4ad;
+if(_4aa){
+_4aa(node,anim);
 }
-dojo.html.show(node);
-},"onEnd":function(){
-dojo.html.hide(node);
-with(node.style){
-overflow=_5a8.overflow;
-height=_5a8.height;
-}
-if(_5a5){
-_5a5(node,anim);
-}
-}});
-_5a6.push(anim);
-});
-return dojo.lfx.combine(_5a6);
 };
-dojo.lfx.html.slideTo=function(_5aa,_5ab,_5ac,_5ad,_5ae){
-_5aa=dojo.lfx.html._byId(_5aa);
-var _5af=[];
-var _5b0=dojo.html.getComputedStyle;
-if(dojo.lang.isArray(_5ab)){
-dojo.deprecated("dojo.lfx.html.slideTo(node, array)","use dojo.lfx.html.slideTo(node, {top: value, left: value});","0.5");
-_5ab={top:_5ab[0],left:_5ab[1]};
+_4ab.push(anim);
+});
+if(_4a7.length>1){
+return dojo.lfx.combine(_4ab);
+}else{
+return _4ab[0];
 }
-dojo.lang.forEach(_5aa,function(node){
+};
+dojo.lfx.html.slideTo=function(_4b0,_4b1,_4b2,_4b3,_4b4){
+_4b0=dojo.lfx.html._byId(_4b0);
+var _4b5=[];
+dojo.lang.forEach(_4b0,function(node){
 var top=null;
 var left=null;
 var init=(function(){
-var _5b5=node;
+var _4ba=node;
 return function(){
-var pos=_5b0(_5b5,"position");
-top=(pos=="absolute"?node.offsetTop:parseInt(_5b0(node,"top"))||0);
-left=(pos=="absolute"?node.offsetLeft:parseInt(_5b0(node,"left"))||0);
-if(!dojo.lang.inArray(["absolute","relative"],pos)){
-var ret=dojo.html.abs(_5b5,true);
-dojo.html.setStyleAttributes(_5b5,"position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
+top=_4ba.offsetTop;
+left=_4ba.offsetLeft;
+if(!dojo.style.isPositionAbsolute(_4ba)){
+var ret=dojo.style.abs(_4ba,true);
+dojo.style.setStyleAttributes(_4ba,"position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
 top=ret.y;
 left=ret.x;
 }
 };
 })();
 init();
-var anim=dojo.lfx.propertyAnimation(node,{"top":{start:top,end:(_5ab.top||0)},"left":{start:left,end:(_5ab.left||0)}},_5ac,_5ad,{"beforeBegin":init});
-if(_5ae){
-anim.connect("onEnd",function(){
-_5ae(_5aa,anim);
-});
+var anim=dojo.lfx.propertyAnimation(node,[{property:"top",start:top,end:_4b1[0]},{property:"left",start:left,end:_4b1[1]}],_4b2,_4b3);
+var _4bd=(anim["beforeBegin"])?dojo.lang.hitch(anim,"beforeBegin"):function(){
+};
+anim.beforeBegin=function(){
+_4bd();
+init();
+};
+if(_4b4){
+var _4be=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4be();
+_4b4(_4b0,anim);
+};
 }
-_5af.push(anim);
+_4b5.push(anim);
 });
-return dojo.lfx.combine(_5af);
-};
-dojo.lfx.html.slideBy=function(_5b9,_5ba,_5bb,_5bc,_5bd){
-_5b9=dojo.lfx.html._byId(_5b9);
-var _5be=[];
-var _5bf=dojo.html.getComputedStyle;
-if(dojo.lang.isArray(_5ba)){
-dojo.deprecated("dojo.lfx.html.slideBy(node, array)","use dojo.lfx.html.slideBy(node, {top: value, left: value});","0.5");
-_5ba={top:_5ba[0],left:_5ba[1]};
+if(_4b0.length>1){
+return dojo.lfx.combine(_4b5);
+}else{
+return _4b5[0];
 }
-dojo.lang.forEach(_5b9,function(node){
+};
+dojo.lfx.html.slideBy=function(_4bf,_4c0,_4c1,_4c2,_4c3){
+_4bf=dojo.lfx.html._byId(_4bf);
+var _4c4=[];
+dojo.lang.forEach(_4bf,function(node){
 var top=null;
 var left=null;
 var init=(function(){
-var _5c4=node;
+var _4c9=node;
 return function(){
-var pos=_5bf(_5c4,"position");
-top=(pos=="absolute"?node.offsetTop:parseInt(_5bf(node,"top"))||0);
-left=(pos=="absolute"?node.offsetLeft:parseInt(_5bf(node,"left"))||0);
-if(!dojo.lang.inArray(["absolute","relative"],pos)){
-var ret=dojo.html.abs(_5c4,true);
-dojo.html.setStyleAttributes(_5c4,"position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
+top=node.offsetTop;
+left=node.offsetLeft;
+if(!dojo.style.isPositionAbsolute(_4c9)){
+var ret=dojo.style.abs(_4c9);
+dojo.style.setStyleAttributes(_4c9,"position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
 top=ret.y;
 left=ret.x;
 }
 };
 })();
 init();
-var anim=dojo.lfx.propertyAnimation(node,{"top":{start:top,end:top+(_5ba.top||0)},"left":{start:left,end:left+(_5ba.left||0)}},_5bb,_5bc).connect("beforeBegin",init);
-if(_5bd){
-anim.connect("onEnd",function(){
-_5bd(_5b9,anim);
-});
+var anim=dojo.lfx.propertyAnimation(node,[{property:"top",start:top,end:top+_4c0[0]},{property:"left",start:left,end:left+_4c0[1]}],_4c1,_4c2);
+var _4cc=(anim["beforeBegin"])?dojo.lang.hitch(anim,"beforeBegin"):function(){
+};
+anim.beforeBegin=function(){
+_4cc();
+init();
+};
+if(_4c3){
+var _4cd=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4cd();
+_4c3(_4bf,anim);
+};
 }
-_5be.push(anim);
+_4c4.push(anim);
 });
-return dojo.lfx.combine(_5be);
-};
-dojo.lfx.html.explode=function(_5c8,_5c9,_5ca,_5cb,_5cc){
-var h=dojo.html;
-_5c8=dojo.byId(_5c8);
-_5c9=dojo.byId(_5c9);
-var _5ce=h.toCoordinateObject(_5c8,true);
-var _5cf=document.createElement("div");
-h.copyStyle(_5cf,_5c9);
-if(_5c9.explodeClassName){
-_5cf.className=_5c9.explodeClassName;
+if(_4bf.length>1){
+return dojo.lfx.combine(_4c4);
+}else{
+return _4c4[0];
 }
-with(_5cf.style){
+};
+dojo.lfx.html.explode=function(_4ce,_4cf,_4d0,_4d1,_4d2){
+_4ce=dojo.byId(_4ce);
+_4cf=dojo.byId(_4cf);
+var _4d3=dojo.style.toCoordinateArray(_4ce,true);
+var _4d4=document.createElement("div");
+dojo.html.copyStyle(_4d4,_4cf);
+with(_4d4.style){
 position="absolute";
 display="none";
-var _5d0=h.getStyle(_5c8,"background-color");
-backgroundColor=_5d0?_5d0.toLowerCase():"transparent";
-backgroundColor=(backgroundColor=="transparent")?"rgb(221, 221, 221)":backgroundColor;
 }
-dojo.body().appendChild(_5cf);
-with(_5c9.style){
+document.body.appendChild(_4d4);
+with(_4cf.style){
 visibility="hidden";
 display="block";
 }
-var _5d1=h.toCoordinateObject(_5c9,true);
-with(_5c9.style){
+var _4d5=dojo.style.toCoordinateArray(_4cf,true);
+with(_4cf.style){
 display="none";
 visibility="visible";
 }
-var _5d2={opacity:{start:0.5,end:1}};
-dojo.lang.forEach(["height","width","top","left"],function(type){
-_5d2[type]={start:_5ce[type],end:_5d1[type]};
-});
-var anim=new dojo.lfx.propertyAnimation(_5cf,_5d2,_5ca,_5cb,{"beforeBegin":function(){
-h.setDisplay(_5cf,"block");
-},"onEnd":function(){
-h.setDisplay(_5c9,"block");
-_5cf.parentNode.removeChild(_5cf);
-}});
-if(_5cc){
-anim.connect("onEnd",function(){
-_5cc(_5c9,anim);
-});
+var anim=new dojo.lfx.propertyAnimation(_4d4,[{property:"height",start:_4d3[3],end:_4d5[3]},{property:"width",start:_4d3[2],end:_4d5[2]},{property:"top",start:_4d3[1],end:_4d5[1]},{property:"left",start:_4d3[0],end:_4d5[0]},{property:"opacity",start:0.3,end:1}],_4d0,_4d1);
+anim.beforeBegin=function(){
+dojo.style.setDisplay(_4d4,"block");
+};
+anim.onEnd=function(){
+dojo.style.setDisplay(_4cf,"block");
+_4d4.parentNode.removeChild(_4d4);
+};
+if(_4d2){
+var _4d7=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4d7();
+_4d2(_4cf,anim);
+};
 }
 return anim;
 };
-dojo.lfx.html.implode=function(_5d5,end,_5d7,_5d8,_5d9){
-var h=dojo.html;
-_5d5=dojo.byId(_5d5);
+dojo.lfx.html.implode=function(_4d8,end,_4da,_4db,_4dc){
+_4d8=dojo.byId(_4d8);
 end=dojo.byId(end);
-var _5db=dojo.html.toCoordinateObject(_5d5,true);
-var _5dc=dojo.html.toCoordinateObject(end,true);
-var _5dd=document.createElement("div");
-dojo.html.copyStyle(_5dd,_5d5);
-if(_5d5.explodeClassName){
-_5dd.className=_5d5.explodeClassName;
-}
-dojo.html.setOpacity(_5dd,0.3);
-with(_5dd.style){
+var _4dd=dojo.style.toCoordinateArray(_4d8,true);
+var _4de=dojo.style.toCoordinateArray(end,true);
+var _4df=document.createElement("div");
+dojo.html.copyStyle(_4df,_4d8);
+dojo.style.setOpacity(_4df,0.3);
+with(_4df.style){
 position="absolute";
 display="none";
-backgroundColor=h.getStyle(_5d5,"background-color").toLowerCase();
 }
-dojo.body().appendChild(_5dd);
-var _5de={opacity:{start:1,end:0.5}};
-dojo.lang.forEach(["height","width","top","left"],function(type){
-_5de[type]={start:_5db[type],end:_5dc[type]};
-});
-var anim=new dojo.lfx.propertyAnimation(_5dd,_5de,_5d7,_5d8,{"beforeBegin":function(){
-dojo.html.hide(_5d5);
-dojo.html.show(_5dd);
-},"onEnd":function(){
-_5dd.parentNode.removeChild(_5dd);
-}});
-if(_5d9){
-anim.connect("onEnd",function(){
-_5d9(_5d5,anim);
-});
+document.body.appendChild(_4df);
+var anim=new dojo.lfx.propertyAnimation(_4df,[{property:"height",start:_4dd[3],end:_4de[3]},{property:"width",start:_4dd[2],end:_4de[2]},{property:"top",start:_4dd[1],end:_4de[1]},{property:"left",start:_4dd[0],end:_4de[0]},{property:"opacity",start:1,end:0.3}],_4da,_4db);
+anim.beforeBegin=function(){
+dojo.style.hide(_4d8);
+dojo.style.show(_4df);
+};
+anim.onEnd=function(){
+_4df.parentNode.removeChild(_4df);
+};
+if(_4dc){
+var _4e1=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4e1();
+_4dc(_4d8,anim);
+};
 }
 return anim;
 };
-dojo.lfx.html.highlight=function(_5e1,_5e2,_5e3,_5e4,_5e5){
-_5e1=dojo.lfx.html._byId(_5e1);
-var _5e6=[];
-dojo.lang.forEach(_5e1,function(node){
-var _5e8=dojo.html.getBackgroundColor(node);
-var bg=dojo.html.getStyle(node,"background-color").toLowerCase();
-var _5ea=dojo.html.getStyle(node,"background-image");
-var _5eb=(bg=="transparent"||bg=="rgba(0, 0, 0, 0)");
-while(_5e8.length>3){
-_5e8.pop();
+dojo.lfx.html.highlight=function(_4e2,_4e3,_4e4,_4e5,_4e6){
+_4e2=dojo.lfx.html._byId(_4e2);
+var _4e7=[];
+dojo.lang.forEach(_4e2,function(node){
+var _4e9=dojo.style.getBackgroundColor(node);
+var bg=dojo.style.getStyle(node,"background-color").toLowerCase();
+var _4eb=dojo.style.getStyle(node,"background-image");
+var _4ec=(bg=="transparent"||bg=="rgba(0, 0, 0, 0)");
+while(_4e9.length>3){
+_4e9.pop();
 }
-var rgb=new dojo.gfx.color.Color(_5e2);
-var _5ed=new dojo.gfx.color.Color(_5e8);
-var anim=dojo.lfx.propertyAnimation(node,{"background-color":{start:rgb,end:_5ed}},_5e3,_5e4,{"beforeBegin":function(){
-if(_5ea){
+var rgb=new dojo.graphics.color.Color(_4e3);
+var _4ee=new dojo.graphics.color.Color(_4e9);
+var anim=dojo.lfx.propertyAnimation(node,[{property:"background-color",start:rgb,end:_4ee}],_4e4,_4e5);
+var _4f0=(anim["beforeBegin"])?dojo.lang.hitch(anim,"beforeBegin"):function(){
+};
+anim.beforeBegin=function(){
+_4f0();
+if(_4eb){
 node.style.backgroundImage="none";
 }
 node.style.backgroundColor="rgb("+rgb.toRgb().join(",")+")";
-},"onEnd":function(){
-if(_5ea){
-node.style.backgroundImage=_5ea;
+};
+var _4f1=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4f1();
+if(_4eb){
+node.style.backgroundImage=_4eb;
 }
-if(_5eb){
+if(_4ec){
 node.style.backgroundColor="transparent";
 }
-if(_5e5){
-_5e5(node,anim);
+if(_4e6){
+_4e6(node,anim);
 }
-}});
-_5e6.push(anim);
+};
+_4e7.push(anim);
 });
-return dojo.lfx.combine(_5e6);
+if(_4e2.length>1){
+return dojo.lfx.combine(_4e7);
+}else{
+return _4e7[0];
+}
 };
-dojo.lfx.html.unhighlight=function(_5ef,_5f0,_5f1,_5f2,_5f3){
-_5ef=dojo.lfx.html._byId(_5ef);
-var _5f4=[];
-dojo.lang.forEach(_5ef,function(node){
-var _5f6=new dojo.gfx.color.Color(dojo.html.getBackgroundColor(node));
-var rgb=new dojo.gfx.color.Color(_5f0);
-var _5f8=dojo.html.getStyle(node,"background-image");
-var anim=dojo.lfx.propertyAnimation(node,{"background-color":{start:_5f6,end:rgb}},_5f1,_5f2,{"beforeBegin":function(){
-if(_5f8){
+dojo.lfx.html.unhighlight=function(_4f2,_4f3,_4f4,_4f5,_4f6){
+_4f2=dojo.lfx.html._byId(_4f2);
+var _4f7=[];
+dojo.lang.forEach(_4f2,function(node){
+var _4f9=new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node));
+var rgb=new dojo.graphics.color.Color(_4f3);
+var _4fb=dojo.style.getStyle(node,"background-image");
+var anim=dojo.lfx.propertyAnimation(node,[{property:"background-color",start:_4f9,end:rgb}],_4f4,_4f5);
+var _4fd=(anim["beforeBegin"])?dojo.lang.hitch(anim,"beforeBegin"):function(){
+};
+anim.beforeBegin=function(){
+_4fd();
+if(_4fb){
 node.style.backgroundImage="none";
 }
-node.style.backgroundColor="rgb("+_5f6.toRgb().join(",")+")";
-},"onEnd":function(){
-if(_5f3){
-_5f3(node,anim);
+node.style.backgroundColor="rgb("+_4f9.toRgb().join(",")+")";
+};
+var _4fe=(anim["onEnd"])?dojo.lang.hitch(anim,"onEnd"):function(){
+};
+anim.onEnd=function(){
+_4fe();
+if(_4f6){
+_4f6(node,anim);
 }
-}});
-_5f4.push(anim);
+};
+_4f7.push(anim);
 });
-return dojo.lfx.combine(_5f4);
+if(_4f2.length>1){
+return dojo.lfx.combine(_4f7);
+}else{
+return _4f7[0];
+}
 };
 dojo.lang.mixin(dojo.lfx,dojo.lfx.html);
 dojo.kwCompoundRequire({browser:["dojo.lfx.html"],dashboard:["dojo.lfx.html"]});

Modified: tags/parley-0.53/root/static/magic/iframe_history.html
===================================================================
--- tags/parley-0.53/root/static/magic/iframe_history.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/iframe_history.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -10,9 +10,14 @@
 	var noInit = false;
 	var domain = "";
 	// document.domain = "localhost";
-	
-	function defineParams(sparams){
-		if(sparams){
+	function init(){
+		// parse the query string if there is one to try to get args that
+		// we can act on
+		var sparams = document.location.search;
+		if(sparams.length >= 0){
+			if(sparams.charAt(0) == "?"){
+				sparams = sparams.substring(1);
+			}
 			var ss = (sparams.indexOf("&amp;") >= 0) ? "&amp;" : "&";
 			sparams = sparams.split(ss);
 			for(var x=0; x<sparams.length; x++){
@@ -22,46 +27,12 @@
 				}
 			}
 		}
-	}
-	
-	function init(){
-		// parse the query string if there is one to try to get params that
-		// we can act on. Also allow params to be in a fragment identifier.
-		var query = null;
-		var frag = null;
-		var url = document.location.href;
-		var hashIndex = url.indexOf("#");
-		
-		//Extract fragment identifier
-		if(hashIndex != -1){
-			frag = url.substring(hashIndex + 1, url.length);
-			url = url.substring(0, hashIndex);
-		}
 
-		//Extract querystring
-		var parts = url.split("?");
-		if(parts.length == 2){
-			query = parts[1];
-		}
-
-		defineParams(query);
-		defineParams(frag);
-
 		if(noInit){ return; }
 		if(domain.length > 0){
 			document.domain = domain;
 		}
-		var hasParentDojo = false;
-		try{
-			hasParentDojo = window.parent != window && window.parent["dojo"];
-		}catch(e){
-			alert("Initializing iframe_history.html failed. If you are using a cross-domain Dojo build,"
-				+ " please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl"
-				+ " to the path on your domain to iframe_history.html");
-			throw e;
-		}
-
-		if(hasParentDojo){
+		if((window.parent != window)&&(window.parent["dojo"])){
 			//Set the page title so IE history shows up with a somewhat correct name.
 			document.title = window.parent.document.title;
 			
@@ -71,7 +42,6 @@
 				pdj.undo.browser.iframeLoaded(null, window.location);
 			}
 		}
-
 	}
 	// -->
 	</script>

Modified: tags/parley-0.53/root/static/magic/src/AdapterRegistry.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/AdapterRegistry.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/AdapterRegistry.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,37 +8,65 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.AdapterRegistry");
 dojo.require("dojo.lang.func");
-dojo.AdapterRegistry = function (returnWrappers) {
-	this.pairs = [];
-	this.returnWrappers = returnWrappers || false;
-};
-dojo.lang.extend(dojo.AdapterRegistry, {register:function (name, check, wrap, directReturn, override) {
-	var type = (override) ? "unshift" : "push";
-	this.pairs[type]([name, check, wrap, directReturn]);
-}, match:function () {
-	for (var i = 0; i < this.pairs.length; i++) {
-		var pair = this.pairs[i];
-		if (pair[1].apply(this, arguments)) {
-			if ((pair[3]) || (this.returnWrappers)) {
-				return pair[2];
-			} else {
-				return pair[2].apply(this, arguments);
-			}
-		}
-	}
-	throw new Error("No match found");
-}, unregister:function (name) {
-	for (var i = 0; i < this.pairs.length; i++) {
-		var pair = this.pairs[i];
-		if (pair[0] == name) {
-			this.pairs.splice(i, 1);
-			return true;
-		}
-	}
-	return false;
-}});
 
+dojo.AdapterRegistry = function(){
+    /***
+        A registry to facilitate adaptation.
+
+        Pairs is an array of [name, check, wrap] triples
+        
+        All check/wrap functions in this registry should be of the same arity.
+    ***/
+    this.pairs = [];
+}
+
+dojo.lang.extend(dojo.AdapterRegistry, {
+    register: function (name, check, wrap, /* optional */ override){
+        /***
+			The check function should return true if the given arguments are
+			appropriate for the wrap function.
+
+			If override is given and true, the check function will be given
+			highest priority.  Otherwise, it will be the lowest priority
+			adapter.
+        ***/
+
+        if (override) {
+            this.pairs.unshift([name, check, wrap]);
+        } else {
+            this.pairs.push([name, check, wrap]);
+        }
+    },
+
+    match: function (/* ... */) {
+        /***
+			Find an adapter for the given arguments.
+
+			If no suitable adapter is found, throws NotFound.
+        ***/
+        for(var i = 0; i < this.pairs.length; i++){
+            var pair = this.pairs[i];
+            if(pair[1].apply(this, arguments)){
+                return pair[2].apply(this, arguments);
+            }
+        }
+		throw new Error("No match found");
+        // dojo.raise("No match found");
+    },
+
+    unregister: function (name) {
+        /***
+			Remove a named adapter from the registry
+        ***/
+        for(var i = 0; i < this.pairs.length; i++){
+            var pair = this.pairs[i];
+            if(pair[0] == name){
+                this.pairs.splice(i, 1);
+                return true;
+            }
+        }
+        return false;
+    }
+});

Modified: tags/parley-0.53/root/static/magic/src/Deferred.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/Deferred.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/Deferred.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,11 +8,100 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.Deferred");
+dojo.require("dojo.lang.func");
 
+dojo.Deferred = function(/* optional */ canceller){
+	/*
+	NOTE: this namespace and documentation are imported wholesale 
+		from MochiKit
 
-dojo.provide("dojo.Deferred");
-dojo.require("dojo.lang.func");
-dojo.Deferred = function (canceller) {
+	Encapsulates a sequence of callbacks in response to a value that
+	may not yet be available.  This is modeled after the Deferred class
+	from Twisted <http://twistedmatrix.com>.
+
+	Why do we want this?  JavaScript has no threads, and even if it did,
+	threads are hard.  Deferreds are a way of abstracting non-blocking
+	events, such as the final response to an XMLHttpRequest.
+
+	The sequence of callbacks is internally represented as a list
+	of 2-tuples containing the callback/errback pair.  For example,
+	the following call sequence::
+
+		var d = new Deferred();
+		d.addCallback(myCallback);
+		d.addErrback(myErrback);
+		d.addBoth(myBoth);
+		d.addCallbacks(myCallback, myErrback);
+
+	is translated into a Deferred with the following internal
+	representation::
+
+		[
+			[myCallback, null],
+			[null, myErrback],
+			[myBoth, myBoth],
+			[myCallback, myErrback]
+		]
+
+	The Deferred also keeps track of its current status (fired).
+	Its status may be one of three things:
+
+		-1: no value yet (initial condition)
+		0: success
+		1: error
+
+	A Deferred will be in the error state if one of the following
+	three conditions are met:
+
+		1. The result given to callback or errback is "instanceof" Error
+		2. The previous callback or errback raised an exception while
+		   executing
+		3. The previous callback or errback returned a value "instanceof"
+			Error
+
+	Otherwise, the Deferred will be in the success state.  The state of
+	the Deferred determines the next element in the callback sequence to
+	run.
+
+	When a callback or errback occurs with the example deferred chain,
+	something equivalent to the following will happen (imagine that
+	exceptions are caught and returned)::
+
+		// d.callback(result) or d.errback(result)
+		if(!(result instanceof Error)){
+			result = myCallback(result);
+		}
+		if(result instanceof Error){
+			result = myErrback(result);
+		}
+		result = myBoth(result);
+		if(result instanceof Error){
+			result = myErrback(result);
+		}else{
+			result = myCallback(result);
+		}
+
+	The result is then stored away in case another step is added to the
+	callback sequence.	Since the Deferred already has a value available,
+	any new callbacks added will be called immediately.
+
+	There are two other "advanced" details about this implementation that
+	are useful:
+
+	Callbacks are allowed to return Deferred instances themselves, so you
+	can build complicated sequences of events with ease.
+
+	The creator of the Deferred may specify a canceller.  The canceller
+	is a function that will be called if Deferred.cancel is called before
+	the Deferred fires.	 You can use this to implement clean aborting of
+	an XMLHttpRequest, etc.	 Note that cancel will fire the deferred with
+	a CancelledError (unless your canceller returns another kind of
+	error), so the errbacks should be prepared to handle that error for
+	cancellable Deferreds.
+
+	*/
+	
 	this.chain = [];
 	this.id = this._nextId();
 	this.fired = -1;
@@ -21,145 +110,200 @@
 	this.canceller = canceller;
 	this.silentlyCancelled = false;
 };
-dojo.lang.extend(dojo.Deferred, {getFunctionFromArgs:function () {
-	var a = arguments;
-	if ((a[0]) && (!a[1])) {
-		if (dojo.lang.isFunction(a[0])) {
-			return a[0];
-		} else {
-			if (dojo.lang.isString(a[0])) {
+
+dojo.lang.extend(dojo.Deferred, {
+	getFunctionFromArgs: function(){
+		var a = arguments;
+		if((a[0])&&(!a[1])){
+			if(dojo.lang.isFunction(a[0])){
+				return a[0];
+			}else if(dojo.lang.isString(a[0])){
 				return dj_global[a[0]];
 			}
-		}
-	} else {
-		if ((a[0]) && (a[1])) {
+		}else if((a[0])&&(a[1])){
 			return dojo.lang.hitch(a[0], a[1]);
 		}
-	}
-	return null;
-}, makeCalled:function () {
-	var deferred = new dojo.Deferred();
-	deferred.callback();
-	return deferred;
-}, repr:function () {
-	var state;
-	if (this.fired == -1) {
-		state = "unfired";
-	} else {
-		if (this.fired == 0) {
-			state = "success";
+		return null;
+	},
+
+	repr: function(){
+		var state;
+		if(this.fired == -1){
+			state = 'unfired';
+		}else if(this.fired == 0){
+			state = 'success';
 		} else {
-			state = "error";
+			state = 'error';
 		}
-	}
-	return "Deferred(" + this.id + ", " + state + ")";
-}, toString:dojo.lang.forward("repr"), _nextId:(function () {
-	var n = 1;
-	return function () {
-		return n++;
-	};
-})(), cancel:function () {
-	if (this.fired == -1) {
-		if (this.canceller) {
-			this.canceller(this);
-		} else {
-			this.silentlyCancelled = true;
-		}
-		if (this.fired == -1) {
-			this.errback(new Error(this.repr()));
-		}
-	} else {
-		if ((this.fired == 0) && (this.results[0] instanceof dojo.Deferred)) {
+		return 'Deferred(' + this.id + ', ' + state + ')';
+	},
+
+	toString: dojo.lang.forward("repr"),
+
+	_nextId: (function(){
+		var n = 1;
+		return function(){ return n++; };
+	})(),
+
+	cancel: function(){
+		/***
+		Cancels a Deferred that has not yet received a value, or is
+		waiting on another Deferred as its value.
+
+		If a canceller is defined, the canceller is called. If the
+		canceller did not return an error, or there was no canceller,
+		then the errback chain is started with CancelledError.
+		***/
+		if(this.fired == -1){
+			if (this.canceller){
+				this.canceller(this);
+			}else{
+				this.silentlyCancelled = true;
+			}
+			if(this.fired == -1){
+				this.errback(new Error(this.repr()));
+			}
+		}else if(	(this.fired == 0)&&
+					(this.results[0] instanceof dojo.Deferred)){
 			this.results[0].cancel();
 		}
-	}
-}, _pause:function () {
-	this.paused++;
-}, _unpause:function () {
-	this.paused--;
-	if ((this.paused == 0) && (this.fired >= 0)) {
-		this._fire();
-	}
-}, _continue:function (res) {
-	this._resback(res);
-	this._unpause();
-}, _resback:function (res) {
-	this.fired = ((res instanceof Error) ? 1 : 0);
-	this.results[this.fired] = res;
-	this._fire();
-}, _check:function () {
-	if (this.fired != -1) {
-		if (!this.silentlyCancelled) {
-			dojo.raise("already called!");
+	},
+			
+
+	_pause: function(){
+		// Used internally to signal that it's waiting on another Deferred
+		this.paused++;
+	},
+
+	_unpause: function(){
+		// Used internally to signal that it's no longer waiting on
+		// another Deferred.
+		this.paused--;
+		if ((this.paused == 0) && (this.fired >= 0)) {
+			this._fire();
 		}
-		this.silentlyCancelled = false;
-		return;
-	}
-}, callback:function (res) {
-	this._check();
-	this._resback(res);
-}, errback:function (res) {
-	this._check();
-	if (!(res instanceof Error)) {
-		res = new Error(res);
-	}
-	this._resback(res);
-}, addBoth:function (cb, cbfn) {
-	var enclosed = this.getFunctionFromArgs(cb, cbfn);
-	if (arguments.length > 2) {
-		enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
-	}
-	return this.addCallbacks(enclosed, enclosed);
-}, addCallback:function (cb, cbfn) {
-	var enclosed = this.getFunctionFromArgs(cb, cbfn);
-	if (arguments.length > 2) {
-		enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
-	}
-	return this.addCallbacks(enclosed, null);
-}, addErrback:function (cb, cbfn) {
-	var enclosed = this.getFunctionFromArgs(cb, cbfn);
-	if (arguments.length > 2) {
-		enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
-	}
-	return this.addCallbacks(null, enclosed);
-	return this.addCallbacks(null, cbfn);
-}, addCallbacks:function (cb, eb) {
-	this.chain.push([cb, eb]);
-	if (this.fired >= 0) {
+	},
+
+	_continue: function(res){
+		// Used internally when a dependent deferred fires.
+		this._resback(res);
+		this._unpause();
+	},
+
+	_resback: function(res){
+		// The primitive that means either callback or errback
+		this.fired = ((res instanceof Error) ? 1 : 0);
+		this.results[this.fired] = res;
 		this._fire();
-	}
-	return this;
-}, _fire:function () {
-	var chain = this.chain;
-	var fired = this.fired;
-	var res = this.results[fired];
-	var self = this;
-	var cb = null;
-	while (chain.length > 0 && this.paused == 0) {
-		var pair = chain.shift();
-		var f = pair[fired];
-		if (f == null) {
-			continue;
+	},
+
+	_check: function(){
+		if(this.fired != -1){
+			if(!this.silentlyCancelled){
+				dojo.raise("already called!");
+			}
+			this.silentlyCancelled = false;
+			return;
 		}
-		try {
-			res = f(res);
-			fired = ((res instanceof Error) ? 1 : 0);
-			if (res instanceof dojo.Deferred) {
-				cb = function (res) {
-					self._continue(res);
-				};
-				this._pause();
+	},
+
+	callback: function(res){
+		/*
+		Begin the callback sequence with a non-error value.
+		
+		callback or errback should only be called once on a given
+		Deferred.
+		*/
+		this._check();
+		this._resback(res);
+	},
+
+	errback: function(res){
+		// Begin the callback sequence with an error result.
+		this._check();
+		if(!(res instanceof Error)){
+			res = new Error(res);
+		}
+		this._resback(res);
+	},
+
+	addBoth: function(cb, cbfn){
+		/*
+		Add the same function as both a callback and an errback as the
+		next element on the callback sequence.	This is useful for code
+		that you want to guarantee to run, e.g. a finalizer.
+		*/
+		var enclosed = this.getFunctionFromArgs(cb, cbfn);
+		if(arguments.length > 2){
+			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
+		}
+		return this.addCallbacks(enclosed, enclosed);
+	},
+
+	addCallback: function(cb, cbfn){
+		// Add a single callback to the end of the callback sequence.
+		var enclosed = this.getFunctionFromArgs(cb, cbfn);
+		if(arguments.length > 2){
+			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
+		}
+		return this.addCallbacks(enclosed, null);
+	},
+
+	addErrback: function(cb, cbfn){
+		// Add a single callback to the end of the callback sequence.
+		var enclosed = this.getFunctionFromArgs(cb, cbfn);
+		if(arguments.length > 2){
+			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
+		}
+		return this.addCallbacks(null, enclosed);
+		return this.addCallbacks(null, cbfn);
+	},
+
+	addCallbacks: function (cb, eb) {
+		// Add separate callback and errback to the end of the callback
+		// sequence.
+		this.chain.push([cb, eb])
+		if (this.fired >= 0) {
+			this._fire();
+		}
+		return this;
+	},
+
+	_fire: function(){
+		// Used internally to exhaust the callback sequence when a result
+		// is available.
+		var chain = this.chain;
+		var fired = this.fired;
+		var res = this.results[fired];
+		var self = this;
+		var cb = null;
+		while (chain.length > 0 && this.paused == 0) {
+			// Array
+			var pair = chain.shift();
+			var f = pair[fired];
+			if (f == null) {
+				continue;
 			}
+			try {
+				res = f(res);
+				fired = ((res instanceof Error) ? 1 : 0);
+				if(res instanceof dojo.Deferred) {
+					cb = function(res){
+						self._continue(res);
+					}
+					this._pause();
+				}
+			}catch(err){
+				fired = 1;
+				res = err;
+			}
 		}
-		catch (err) {
-			fired = 1;
-			res = err;
+		this.fired = fired;
+		this.results[fired] = res;
+		if((cb)&&(this.paused)){
+			// this is for "tail recursion" in case the dependent
+			// deferred is already fired
+			res.addBoth(cb);
 		}
 	}
-	this.fired = fired;
-	this.results[fired] = res;
-	if ((cb) && (this.paused)) {
-		res.addBoth(cb);
-	}
-}});
-
+});

Deleted: tags/parley-0.53/root/static/magic/src/DeferredList.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/DeferredList.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/DeferredList.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,77 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.require("dojo.Deferred");
-dojo.provide("dojo.DeferredList");
-dojo.DeferredList = function (list, fireOnOneCallback, fireOnOneErrback, consumeErrors, canceller) {
-	this.list = list;
-	this.resultList = new Array(this.list.length);
-	this.chain = [];
-	this.id = this._nextId();
-	this.fired = -1;
-	this.paused = 0;
-	this.results = [null, null];
-	this.canceller = canceller;
-	this.silentlyCancelled = false;
-	if (this.list.length === 0 && !fireOnOneCallback) {
-		this.callback(this.resultList);
-	}
-	this.finishedCount = 0;
-	this.fireOnOneCallback = fireOnOneCallback;
-	this.fireOnOneErrback = fireOnOneErrback;
-	this.consumeErrors = consumeErrors;
-	var index = 0;
-	var _this = this;
-	dojo.lang.forEach(this.list, function (d) {
-		var _index = index;
-		d.addCallback(function (r) {
-			_this._cbDeferred(_index, true, r);
-		});
-		d.addErrback(function (r) {
-			_this._cbDeferred(_index, false, r);
-		});
-		index++;
-	});
-};
-dojo.inherits(dojo.DeferredList, dojo.Deferred);
-dojo.lang.extend(dojo.DeferredList, {_cbDeferred:function (index, succeeded, result) {
-	this.resultList[index] = [succeeded, result];
-	this.finishedCount += 1;
-	if (this.fired !== 0) {
-		if (succeeded && this.fireOnOneCallback) {
-			this.callback([index, result]);
-		} else {
-			if (!succeeded && this.fireOnOneErrback) {
-				this.errback(result);
-			} else {
-				if (this.finishedCount == this.list.length) {
-					this.callback(this.resultList);
-				}
-			}
-		}
-	}
-	if (!succeeded && this.consumeErrors) {
-		result = null;
-	}
-	return result;
-}, gatherResults:function (deferredList) {
-	var d = new dojo.DeferredList(deferredList, false, true, false);
-	d.addCallback(function (results) {
-		var ret = [];
-		for (var i = 0; i < results.length; i++) {
-			ret.push(results[i][1]);
-		}
-		return ret;
-	});
-	return d;
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/a11y.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/a11y.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/a11y.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,54 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.a11y");
-dojo.require("dojo.uri.*");
-dojo.require("dojo.html.common");
-dojo.a11y = {imgPath:dojo.uri.moduleUri("dojo.widget", "templates/images"), doAccessibleCheck:true, accessible:null, checkAccessible:function () {
-	if (this.accessible === null) {
-		this.accessible = false;
-		if (this.doAccessibleCheck == true) {
-			this.accessible = this.testAccessible();
-		}
-	}
-	return this.accessible;
-}, testAccessible:function () {
-	this.accessible = false;
-	if (dojo.render.html.ie || dojo.render.html.mozilla) {
-		var div = document.createElement("div");
-		div.style.backgroundImage = "url(\"" + this.imgPath + "/tab_close.gif\")";
-		dojo.body().appendChild(div);
-		var bkImg = null;
-		if (window.getComputedStyle) {
-			var cStyle = getComputedStyle(div, "");
-			bkImg = cStyle.getPropertyValue("background-image");
-		} else {
-			bkImg = div.currentStyle.backgroundImage;
-		}
-		var bUseImgElem = false;
-		if (bkImg != null && (bkImg == "none" || bkImg == "url(invalid-url:)")) {
-			this.accessible = true;
-		}
-		dojo.body().removeChild(div);
-	}
-	return this.accessible;
-}, setCheckAccessible:function (bTest) {
-	this.doAccessibleCheck = bTest;
-}, setAccessibleMode:function () {
-	if (this.accessible === null) {
-		if (this.checkAccessible()) {
-			dojo.render.html.prefixes.unshift("a11y");
-		}
-	}
-	return this.accessible;
-}};
-

Modified: tags/parley-0.53/root/static/magic/src/animation/Animation.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/animation/Animation.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/animation/Animation.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,173 +8,210 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.animation.Animation");
 dojo.require("dojo.animation.AnimationEvent");
+
 dojo.require("dojo.lang.func");
 dojo.require("dojo.math");
 dojo.require("dojo.math.curves");
-dojo.deprecated("dojo.animation.Animation is slated for removal in 0.5; use dojo.lfx.* instead.", "0.5");
-dojo.animation.Animation = function (curve, duration, accel, repeatCount, rate) {
-	if (dojo.lang.isArray(curve)) {
+
+/*
+Animation package based off of Dan Pupius' work on Animations:
+http://pupius.co.uk/js/Toolkit.Drawing.js
+*/
+
+dojo.animation.Animation = function(/*dojo.math.curves.Line*/ curve, /*int*/ duration, /*Decimal?*/ accel, /*int?*/ repeatCount, /*int?*/ rate) {
+	// public properties
+	if(dojo.lang.isArray(curve)) {
+		// curve: Array
+		// id: i
 		curve = new dojo.math.curves.Line(curve[0], curve[1]);
 	}
 	this.curve = curve;
 	this.duration = duration;
 	this.repeatCount = repeatCount || 0;
 	this.rate = rate || 25;
-	if (accel) {
-		if (dojo.lang.isFunction(accel.getValue)) {
+	if(accel) {
+		// accel: Decimal
+		// id: j
+		if(dojo.lang.isFunction(accel.getValue)) {
+			// accel: dojo.math.curves.CatmullRom
+			// id: k
 			this.accel = accel;
 		} else {
-			var i = 0.35 * accel + 0.5;
+			var i = 0.35*accel+0.5;	// 0.15 <= i <= 0.85
 			this.accel = new dojo.math.curves.CatmullRom([[0], [i], [1]], 0.45);
 		}
 	}
-};
-dojo.lang.extend(dojo.animation.Animation, {curve:null, duration:0, repeatCount:0, accel:null, onBegin:null, onAnimate:null, onEnd:null, onPlay:null, onPause:null, onStop:null, handler:null, _animSequence:null, _startTime:null, _endTime:null, _lastFrame:null, _timer:null, _percent:0, _active:false, _paused:false, _startRepeatCount:0, play:function (gotoStart) {
-	if (gotoStart) {
-		clearTimeout(this._timer);
-		this._active = false;
-		this._paused = false;
-		this._percent = 0;
-	} else {
-		if (this._active && !this._paused) {
+}
+
+dojo.lang.extend(dojo.animation.Animation, {
+	// public properties
+	curve: null,
+	duration: 0,
+	repeatCount: 0,
+	accel: null,
+
+	// events
+	onBegin: null,
+	onAnimate: null,
+	onEnd: null,
+	onPlay: null,
+	onPause: null,
+	onStop: null,
+	handler: null,
+
+	// "private" properties
+	_animSequence: null,
+	_startTime: null,
+	_endTime: null,
+	_lastFrame: null,
+	_timer: null,
+	_percent: 0,
+	_active: false,
+	_paused: false,
+	_startRepeatCount: 0,
+
+	// public methods
+	play: function(gotoStart) {
+		if( gotoStart ) {
+			clearTimeout(this._timer);
+			this._active = false;
+			this._paused = false;
+			this._percent = 0;
+		} else if( this._active && !this._paused ) {
 			return;
 		}
-	}
-	this._startTime = new Date().valueOf();
-	if (this._paused) {
-		this._startTime -= (this.duration * this._percent / 100);
-	}
-	this._endTime = this._startTime + this.duration;
-	this._lastFrame = this._startTime;
-	var e = new dojo.animation.AnimationEvent(this, null, this.curve.getValue(this._percent), this._startTime, this._startTime, this._endTime, this.duration, this._percent, 0);
-	this._active = true;
-	this._paused = false;
-	if (this._percent == 0) {
-		if (!this._startRepeatCount) {
-			this._startRepeatCount = this.repeatCount;
+
+		this._startTime = new Date().valueOf();
+		if( this._paused ) {
+			this._startTime -= (this.duration * this._percent / 100);
 		}
-		e.type = "begin";
-		if (typeof this.handler == "function") {
-			this.handler(e);
+		this._endTime = this._startTime + this.duration;
+		this._lastFrame = this._startTime;
+
+		var e = new dojo.animation.AnimationEvent(this, null, this.curve.getValue(this._percent),
+			this._startTime, this._startTime, this._endTime, this.duration, this._percent, 0);
+
+		this._active = true;
+		this._paused = false;
+
+		if( this._percent == 0 ) {
+			if(!this._startRepeatCount) {
+				this._startRepeatCount = this.repeatCount;
+			}
+			e.type = "begin";
+			if(typeof this.handler == "function") { this.handler(e); }
+			if(typeof this.onBegin == "function") { this.onBegin(e); }
 		}
-		if (typeof this.onBegin == "function") {
-			this.onBegin(e);
+
+		e.type = "play";
+		if(typeof this.handler == "function") { this.handler(e); }
+		if(typeof this.onPlay == "function") { this.onPlay(e); }
+
+		if(this._animSequence) { this._animSequence._setCurrent(this); }
+
+		this._cycle();
+	},
+
+	pause: function() {
+		clearTimeout(this._timer);
+		if( !this._active ) { return; }
+		this._paused = true;
+		var e = new dojo.animation.AnimationEvent(this, "pause", this.curve.getValue(this._percent),
+			this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent, 0);
+		if(typeof this.handler == "function") { this.handler(e); }
+		if(typeof this.onPause == "function") { this.onPause(e); }
+	},
+
+	playPause: function() {
+		if( !this._active || this._paused ) {
+			this.play();
+		} else {
+			this.pause();
 		}
-	}
-	e.type = "play";
-	if (typeof this.handler == "function") {
-		this.handler(e);
-	}
-	if (typeof this.onPlay == "function") {
-		this.onPlay(e);
-	}
-	if (this._animSequence) {
-		this._animSequence._setCurrent(this);
-	}
-	this._cycle();
-}, pause:function () {
-	clearTimeout(this._timer);
-	if (!this._active) {
-		return;
-	}
-	this._paused = true;
-	var e = new dojo.animation.AnimationEvent(this, "pause", this.curve.getValue(this._percent), this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent, 0);
-	if (typeof this.handler == "function") {
-		this.handler(e);
-	}
-	if (typeof this.onPause == "function") {
-		this.onPause(e);
-	}
-}, playPause:function () {
-	if (!this._active || this._paused) {
-		this.play();
-	} else {
-		this.pause();
-	}
-}, gotoPercent:function (pct, andPlay) {
-	clearTimeout(this._timer);
-	this._active = true;
-	this._paused = true;
-	this._percent = pct;
-	if (andPlay) {
-		this.play();
-	}
-}, stop:function (gotoEnd) {
-	clearTimeout(this._timer);
-	var step = this._percent / 100;
-	if (gotoEnd) {
-		step = 1;
-	}
-	var e = new dojo.animation.AnimationEvent(this, "stop", this.curve.getValue(step), this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent);
-	if (typeof this.handler == "function") {
-		this.handler(e);
-	}
-	if (typeof this.onStop == "function") {
-		this.onStop(e);
-	}
-	this._active = false;
-	this._paused = false;
-}, status:function () {
-	if (this._active) {
-		return this._paused ? "paused" : "playing";
-	} else {
-		return "stopped";
-	}
-}, _cycle:function () {
-	clearTimeout(this._timer);
-	if (this._active) {
-		var curr = new Date().valueOf();
-		var step = (curr - this._startTime) / (this._endTime - this._startTime);
-		var fps = 1000 / (curr - this._lastFrame);
-		this._lastFrame = curr;
-		if (step >= 1) {
+	},
+
+	gotoPercent: function(pct, andPlay) {
+		clearTimeout(this._timer);
+		this._active = true;
+		this._paused = true;
+		this._percent = pct;
+		if( andPlay ) { this.play(); }
+	},
+
+	stop: function(gotoEnd) {
+		clearTimeout(this._timer);
+		var step = this._percent / 100;
+		if( gotoEnd ) {
 			step = 1;
-			this._percent = 100;
+		}
+		var e = new dojo.animation.AnimationEvent(this, "stop", this.curve.getValue(step),
+			this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent);
+		if(typeof this.handler == "function") { this.handler(e); }
+		if(typeof this.onStop == "function") { this.onStop(e); }
+		this._active = false;
+		this._paused = false;
+	},
+
+	status: function() {
+		if( this._active ) {
+			return this._paused ? "paused" : "playing";
 		} else {
-			this._percent = step * 100;
+			return "stopped";
 		}
-		if (this.accel && this.accel.getValue) {
-			step = this.accel.getValue(step);
-		}
-		var e = new dojo.animation.AnimationEvent(this, "animate", this.curve.getValue(step), this._startTime, curr, this._endTime, this.duration, this._percent, Math.round(fps));
-		if (typeof this.handler == "function") {
-			this.handler(e);
-		}
-		if (typeof this.onAnimate == "function") {
-			this.onAnimate(e);
-		}
-		if (step < 1) {
-			this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
-		} else {
-			e.type = "end";
-			this._active = false;
-			if (typeof this.handler == "function") {
-				this.handler(e);
+	},
+
+	// "private" methods
+	_cycle: function() {
+		clearTimeout(this._timer);
+		if( this._active ) {
+			var curr = new Date().valueOf();
+			var step = (curr - this._startTime) / (this._endTime - this._startTime);
+			var fps = 1000 / (curr - this._lastFrame);
+			this._lastFrame = curr;
+
+			if( step >= 1 ) {
+				step = 1;
+				this._percent = 100;
+			} else {
+				this._percent = step * 100;
 			}
-			if (typeof this.onEnd == "function") {
-				this.onEnd(e);
+			
+			// Perform accelleration
+			if(this.accel && this.accel.getValue) {
+				step = this.accel.getValue(step);
 			}
-			if (this.repeatCount > 0) {
-				this.repeatCount--;
-				this.play(true);
+
+			var e = new dojo.animation.AnimationEvent(this, "animate", this.curve.getValue(step),
+				this._startTime, curr, this._endTime, this.duration, this._percent, Math.round(fps));
+
+			if(typeof this.handler == "function") { this.handler(e); }
+			if(typeof this.onAnimate == "function") { this.onAnimate(e); }
+
+			if( step < 1 ) {
+				this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
 			} else {
-				if (this.repeatCount == -1) {
+				e.type = "end";
+				this._active = false;
+				if(typeof this.handler == "function") { this.handler(e); }
+				if(typeof this.onEnd == "function") { this.onEnd(e); }
+
+				if( this.repeatCount > 0 ) {
+					this.repeatCount--;
 					this.play(true);
+				} else if( this.repeatCount == -1 ) {
+					this.play(true);
 				} else {
-					if (this._startRepeatCount) {
+					if(this._startRepeatCount) {
 						this.repeatCount = this._startRepeatCount;
 						this._startRepeatCount = 0;
 					}
-					if (this._animSequence) {
+					if( this._animSequence ) {
 						this._animSequence._playNext();
 					}
 				}
 			}
 		}
 	}
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/animation/AnimationEvent.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/animation/AnimationEvent.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/animation/AnimationEvent.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,30 +8,33 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.animation.AnimationEvent");
 
+dojo.require("dojo.lang");
 
-dojo.provide("dojo.animation.AnimationEvent");
-dojo.require("dojo.lang.common");
-dojo.deprecated("dojo.animation.AnimationEvent is slated for removal in 0.5; use dojo.lfx.* instead.", "0.5");
-dojo.animation.AnimationEvent = function (animation, type, coords, startTime, currentTime, endTime, duration, percent, fps) {
-	this.type = type;
-	this.animation = animation;
+dojo.animation.AnimationEvent = function(anim, type, coords, sTime, cTime, eTime, dur, pct, fps) {
+	this.type = type; // "animate", "begin", "end", "play", "pause", "stop"
+	this.animation = anim;
+
 	this.coords = coords;
 	this.x = coords[0];
 	this.y = coords[1];
 	this.z = coords[2];
-	this.startTime = startTime;
-	this.currentTime = currentTime;
-	this.endTime = endTime;
-	this.duration = duration;
-	this.percent = percent;
+
+	this.startTime = sTime;
+	this.currentTime = cTime;
+	this.endTime = eTime;
+
+	this.duration = dur;
+	this.percent = pct;
 	this.fps = fps;
 };
-dojo.extend(dojo.animation.AnimationEvent, {coordsAsInts:function () {
-	var cints = new Array(this.coords.length);
-	for (var i = 0; i < this.coords.length; i++) {
-		cints[i] = Math.round(this.coords[i]);
+dojo.lang.extend(dojo.animation.AnimationEvent, {
+	coordsAsInts: function() {
+		var cints = new Array(this.coords.length);
+		for(var i = 0; i < this.coords.length; i++) {
+			cints[i] = Math.round(this.coords[i]);
+		}
+		return cints;
 	}
-	return cints;
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/animation/AnimationSequence.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/animation/AnimationSequence.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/animation/AnimationSequence.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,121 +8,129 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.animation.AnimationSequence");
 dojo.require("dojo.animation.AnimationEvent");
 dojo.require("dojo.animation.Animation");
-dojo.deprecated("dojo.animation.AnimationSequence is slated for removal in 0.5; use dojo.lfx.* instead.", "0.5");
-dojo.animation.AnimationSequence = function (repeatCount) {
+
+dojo.animation.AnimationSequence = function(repeatCount){
 	this._anims = [];
 	this.repeatCount = repeatCount || 0;
-};
-dojo.lang.extend(dojo.animation.AnimationSequence, {repeatCount:0, _anims:[], _currAnim:-1, onBegin:null, onEnd:null, onNext:null, handler:null, add:function () {
-	for (var i = 0; i < arguments.length; i++) {
-		this._anims.push(arguments[i]);
-		arguments[i]._animSequence = this;
-	}
-}, remove:function (anim) {
-	for (var i = 0; i < this._anims.length; i++) {
-		if (this._anims[i] == anim) {
+}
+
+dojo.lang.extend(dojo.animation.AnimationSequence, {
+	repeateCount: 0,
+
+	_anims: [],
+	_currAnim: -1,
+
+	onBegin: null,
+	onEnd: null,
+	onNext: null,
+	handler: null,
+
+	add: function() {
+		for(var i = 0; i < arguments.length; i++) {
+			this._anims.push(arguments[i]);
+			arguments[i]._animSequence = this;
+		}
+	},
+
+	remove: function(anim) {
+		for(var i = 0; i < this._anims.length; i++) {
+			if( this._anims[i] == anim ) {
+				this._anims[i]._animSequence = null;
+				this._anims.splice(i, 1);
+				break;
+			}
+		}
+	},
+
+	removeAll: function() {
+		for(var i = 0; i < this._anims.length; i++) {
 			this._anims[i]._animSequence = null;
-			this._anims.splice(i, 1);
-			break;
 		}
-	}
-}, removeAll:function () {
-	for (var i = 0; i < this._anims.length; i++) {
-		this._anims[i]._animSequence = null;
-	}
-	this._anims = [];
-	this._currAnim = -1;
-}, clear:function () {
-	this.removeAll();
-}, play:function (gotoStart) {
-	if (this._anims.length == 0) {
-		return;
-	}
-	if (gotoStart || !this._anims[this._currAnim]) {
-		this._currAnim = 0;
-	}
-	if (this._anims[this._currAnim]) {
-		if (this._currAnim == 0) {
-			var e = {type:"begin", animation:this._anims[this._currAnim]};
-			if (typeof this.handler == "function") {
-				this.handler(e);
+		this._anims = [];
+		this._currAnim = -1;
+	},
+
+	clear: function() {
+		this.removeAll();
+	},
+
+	play: function(gotoStart) {
+		if( this._anims.length == 0 ) { return; }
+		if( gotoStart || !this._anims[this._currAnim] ) {
+			this._currAnim = 0;
+		}
+		if( this._anims[this._currAnim] ) {
+			if( this._currAnim == 0 ) {
+				var e = {type: "begin", animation: this._anims[this._currAnim]};
+				if(typeof this.handler == "function") { this.handler(e); }
+				if(typeof this.onBegin == "function") { this.onBegin(e); }
 			}
-			if (typeof this.onBegin == "function") {
-				this.onBegin(e);
-			}
+			this._anims[this._currAnim].play(gotoStart);
 		}
-		this._anims[this._currAnim].play(gotoStart);
-	}
-}, pause:function () {
-	if (this._anims[this._currAnim]) {
-		this._anims[this._currAnim].pause();
-	}
-}, playPause:function () {
-	if (this._anims.length == 0) {
-		return;
-	}
-	if (this._currAnim == -1) {
-		this._currAnim = 0;
-	}
-	if (this._anims[this._currAnim]) {
-		this._anims[this._currAnim].playPause();
-	}
-}, stop:function () {
-	if (this._anims[this._currAnim]) {
-		this._anims[this._currAnim].stop();
-	}
-}, status:function () {
-	if (this._anims[this._currAnim]) {
-		return this._anims[this._currAnim].status();
-	} else {
-		return "stopped";
-	}
-}, _setCurrent:function (anim) {
-	for (var i = 0; i < this._anims.length; i++) {
-		if (this._anims[i] == anim) {
-			this._currAnim = i;
-			break;
+	},
+
+	pause: function() {
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].pause();
 		}
-	}
-}, _playNext:function () {
-	if (this._currAnim == -1 || this._anims.length == 0) {
-		return;
-	}
-	this._currAnim++;
-	if (this._anims[this._currAnim]) {
-		var e = {type:"next", animation:this._anims[this._currAnim]};
-		if (typeof this.handler == "function") {
-			this.handler(e);
+	},
+
+	playPause: function() {
+		if( this._anims.length == 0 ) { return; }
+		if( this._currAnim == -1 ) { this._currAnim = 0; }
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].playPause();
 		}
-		if (typeof this.onNext == "function") {
-			this.onNext(e);
+	},
+
+	stop: function() {
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].stop();
 		}
-		this._anims[this._currAnim].play(true);
-	} else {
-		var e = {type:"end", animation:this._anims[this._anims.length - 1]};
-		if (typeof this.handler == "function") {
-			this.handler(e);
+	},
+
+	status: function() {
+		if( this._anims[this._currAnim] ) {
+			return this._anims[this._currAnim].status();
+		} else {
+			return "stopped";
 		}
-		if (typeof this.onEnd == "function") {
-			this.onEnd(e);
+	},
+
+	_setCurrent: function(anim) {
+		for(var i = 0; i < this._anims.length; i++) {
+			if( this._anims[i] == anim ) {
+				this._currAnim = i;
+				break;
+			}
 		}
-		if (this.repeatCount > 0) {
-			this._currAnim = 0;
-			this.repeatCount--;
+	},
+
+	_playNext: function() {
+		if( this._currAnim == -1 || this._anims.length == 0 ) { return; }
+		this._currAnim++;
+		if( this._anims[this._currAnim] ) {
+			var e = {type: "next", animation: this._anims[this._currAnim]};
+			if(typeof this.handler == "function") { this.handler(e); }
+			if(typeof this.onNext == "function") { this.onNext(e); }
 			this._anims[this._currAnim].play(true);
 		} else {
-			if (this.repeatCount == -1) {
+			var e = {type: "end", animation: this._anims[this._anims.length-1]};
+			if(typeof this.handler == "function") { this.handler(e); }
+			if(typeof this.onEnd == "function") { this.onEnd(e); }
+			if(this.repeatCount > 0) {
 				this._currAnim = 0;
+				this.repeatCount--;
 				this._anims[this._currAnim].play(true);
+			} else if(this.repeatCount == -1) {
+				this._currAnim = 0;
+				this._anims[this._currAnim].play(true);
 			} else {
 				this._currAnim = -1;
 			}
 		}
 	}
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/animation/Timer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/animation/Timer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/animation/Timer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,10 +8,32 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.animation.Timer");
+dojo.require("dojo.lang.func");
 
+dojo.animation.Timer = function(intvl){
+	var timer = null;
+	this.isRunning = false;
+	this.interval = intvl;
 
-dojo.provide("dojo.animation.Timer");
-dojo.require("dojo.lang.timing.Timer");
-dojo.deprecated("dojo.animation.Timer is now dojo.lang.timing.Timer", "0.5");
-dojo.animation.Timer = dojo.lang.timing.Timer;
+	this.onTick = function(){};
+	this.onStart = null;
+	this.onStop = null;
 
+	this.setInterval = function(ms){
+		if (this.isRunning) window.clearInterval(timer);
+		this.interval = ms;
+		if (this.isRunning) timer = window.setInterval(dojo.lang.hitch(this, "onTick"), this.interval);
+	};
+
+	this.start = function(){
+		if (typeof this.onStart == "function") this.onStart();
+		this.isRunning = true;
+		timer = window.setInterval(this.onTick, this.interval);
+	};
+	this.stop = function(){
+		if (typeof this.onStop == "function") this.onStop();
+		this.isRunning = false;
+		window.clearInterval(timer);
+	};
+};

Modified: tags/parley-0.53/root/static/magic/src/animation/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/animation/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/animation/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,11 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.animation.AnimationEvent", "dojo.animation.Animation", "dojo.animation.AnimationSequence"]});
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.animation.AnimationEvent",
+		"dojo.animation.Animation",
+		"dojo.animation.AnimationSequence"
+	]
+});
 dojo.provide("dojo.animation.*");
-dojo.deprecated("dojo.Animation.* is slated for removal in 0.5; use dojo.lfx.* instead.", "0.5");
-

Modified: tags/parley-0.53/root/static/magic/src/animation.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/animation.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/animation.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,5 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.animation");
 dojo.require("dojo.animation.Animation");
-dojo.deprecated("dojo.animation is slated for removal in 0.5; use dojo.lfx instead.", "0.5");
-

Modified: tags/parley-0.53/root/static/magic/src/behavior.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/behavior.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/behavior.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,70 +8,163 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.behavior");
 dojo.require("dojo.event.*");
+
 dojo.require("dojo.experimental");
 dojo.experimental("dojo.behavior");
-dojo.behavior = new function () {
-	function arrIn(obj, name) {
-		if (!obj[name]) {
-			obj[name] = [];
-		}
+
+dojo.behavior = new function(){
+	function arrIn(obj, name){
+		if(!obj[name]){ obj[name] = []; }
 		return obj[name];
 	}
-	function forIn(obj, scope, func) {
+
+	function forIn(obj, scope, func){
 		var tmpObj = {};
-		for (var x in obj) {
-			if (typeof tmpObj[x] == "undefined") {
-				if (!func) {
+		for(var x in obj){
+			if(typeof tmpObj[x] == "undefined"){
+				if(!func){
 					scope(obj[x], x);
-				} else {
+				}else{
 					func.call(scope, obj[x], x);
 				}
 			}
 		}
 	}
+
+	// FIXME: need a better test so we don't exclude nightly Safari's!
 	this.behaviors = {};
-	this.add = function (behaviorObj) {
+	this.add = function(behaviorObj){
+		/*	behavior objects are specified in the following format:
+		 *
+		 *	{ 
+		 *	 	"#id": {
+		 *			"found": function(element){
+		 *				// ...
+		 *			},
+		 *
+		 *			"onblah": {targetObj: foo, targetFunc: "bar"},
+		 *
+		 *			"onblarg": "/foo/bar/baz/blarg",
+		 *
+		 *			"onevent": function(evt){
+		 *			},
+		 *
+		 *			"onotherevent: function(evt){
+		 *				// ...
+		 *			}
+		 *		},
+		 *
+		 *		"#id2": {
+		 *			// ...
+		 *		},
+		 *
+		 *		"#id3": function(element){
+		 *			// ...
+		 *		},
+		 *
+		 *		// publish the match on a topic
+		 *		"#id4": "/found/topic/name",
+		 *
+		 *		// match all direct descendants
+		 *		"#id4 > *": function(element){
+		 *			// ...
+		 *		},
+		 *
+		 *		// match the first child node that's an element
+		 *		"#id4 > @firstElement": { ... },
+		 *
+		 *		// match the last child node that's an element
+		 *		"#id4 > @lastElement":  { ... },
+		 *
+		 *		// all elements of type tagname
+		 *		"tagname": {
+		 *			// ...
+		 *		},
+		 *
+		 *		// maps to roughly:
+		 *		//	dojo.lang.forEach(body.getElementsByTagName("tagname1"), function(node){
+		 *		//		dojo.lang.forEach(node.getElementsByTagName("tagname2"), function(node2){
+		 *		//			dojo.lang.forEach(node2.getElementsByTagName("tagname3", function(node3){
+		 *		//				// apply rules
+		 *		//			});
+		 *		//		});
+		 *		//	});
+		 *		"tagname1 tagname2 tagname3": {
+		 *			// ...
+		 *		},
+		 *
+		 *		".classname": {
+		 *			// ...
+		 *		},
+		 *
+		 *		"tagname.classname": {
+		 *			// ...
+		 *		},
+		 *	}
+		 *
+		 *	The "found" method is a generalized handler that's called as soon
+		 *	as the node matches the selector. Rules for values that follow also
+		 *	apply to the "found" key.
+		 *	
+		 *	The "on*" handlers are attached with dojo.event.connect(). If the
+		 *	value is not a function but is rather an object, it's assumed to be
+		 *	the "other half" of a dojo.event.kwConnect() argument object. It
+		 *	may contain any/all properties of such a connection modifier save
+		 *	for the sourceObj and sourceFunc properties which are filled in by
+		 *	the system automatically. If a string is instead encountered, the
+		 *	node publishes the specified event on the topic contained in the
+		 *	string value.
+		 *
+		 *	If the value corresponding to the ID key is a function and not a
+		 *	list, it's treated as though it was the value of "found".
+		 *
+		 */
+
 		var tmpObj = {};
-		forIn(behaviorObj, this, function (behavior, name) {
+		forIn(behaviorObj, this, function(behavior, name){
 			var tBehavior = arrIn(this.behaviors, name);
-			if ((dojo.lang.isString(behavior)) || (dojo.lang.isFunction(behavior))) {
-				behavior = {found:behavior};
+			if((dojo.lang.isString(behavior))||(dojo.lang.isFunction(behavior))){
+				behavior = { found: behavior };
 			}
-			forIn(behavior, function (rule, ruleName) {
+			forIn(behavior, function(rule, ruleName){
 				arrIn(tBehavior, ruleName).push(rule);
 			});
 		});
-	};
-	this.apply = function () {
+	}
+
+	this.apply = function(){
 		dojo.profile.start("dojo.behavior.apply");
 		var r = dojo.render.html;
+		// note, we apply one way for fast queries and one way for slow
+		// iteration. So be it.
 		var safariGoodEnough = (!r.safari);
-		if (r.safari) {
+		if(r.safari){
+			// Anything over release #420 should work the fast way
 			var uas = r.UA.split("AppleWebKit/")[1];
-			if (parseInt(uas.match(/[0-9.]{3,}/)) >= 420) {
+			if(parseInt(uas.match(/[0-9.]{3,}/)) >= 420){
 				safariGoodEnough = true;
 			}
 		}
-		if ((dj_undef("behaviorFastParse", djConfig) ? (safariGoodEnough) : djConfig["behaviorFastParse"])) {
+		if((dj_undef("behaviorFastParse", djConfig) ? (safariGoodEnough) : djConfig["behaviorFastParse"])){
 			this.applyFast();
-		} else {
+		}else{
 			this.applySlow();
 		}
 		dojo.profile.end("dojo.behavior.apply");
-	};
+	}
+
 	this.matchCache = {};
-	this.elementsById = function (id, handleRemoved) {
+
+	this.elementsById = function(id, handleRemoved){
 		var removed = [];
 		var added = [];
 		arrIn(this.matchCache, id);
-		if (handleRemoved) {
+		if(handleRemoved){
 			var nodes = this.matchCache[id];
-			for (var x = 0; x < nodes.length; x++) {
-				if (nodes[x].id != "") {
+			for(var x=0; x<nodes.length; x++){
+				if(nodes[x].id != ""){
 					removed.push(nodes[x]);
 					nodes.splice(x, 1);
 					x--;
@@ -79,64 +172,69 @@
 			}
 		}
 		var tElem = dojo.byId(id);
-		while (tElem) {
-			if (!tElem["idcached"]) {
+		while(tElem){
+			if(!tElem["idcached"]){
 				added.push(tElem);
 			}
 			tElem.id = "";
 			tElem = dojo.byId(id);
 		}
 		this.matchCache[id] = this.matchCache[id].concat(added);
-		dojo.lang.forEach(this.matchCache[id], function (node) {
+		dojo.lang.forEach(this.matchCache[id], function(node){
 			node.id = id;
 			node.idcached = true;
 		});
-		return {"removed":removed, "added":added, "match":this.matchCache[id]};
-	};
-	this.applyToNode = function (node, action, ruleSetName) {
-		if (typeof action == "string") {
+		return { "removed": removed, "added": added, "match": this.matchCache[id] };
+	}
+
+	this.applyToNode = function(node, action, ruleSetName){
+		if(typeof action == "string"){
 			dojo.event.topic.registerPublisher(action, node, ruleSetName);
-		} else {
-			if (typeof action == "function") {
-				if (ruleSetName == "found") {
-					action(node);
-				} else {
-					dojo.event.connect(node, ruleSetName, action);
-				}
-			} else {
-				action.srcObj = node;
-				action.srcFunc = ruleSetName;
-				dojo.event.kwConnect(action);
+		}else if(typeof action == "function"){
+			if(ruleSetName == "found"){
+				action(node);
+			}else{
+				dojo.event.connect(node, ruleSetName, action);
 			}
+		}else{
+			action.srcObj = node;
+			action.srcFunc = ruleSetName;
+			dojo.event.kwConnect(action);
 		}
-	};
-	this.applyFast = function () {
+	}
+
+	this.applyFast = function(){
 		dojo.profile.start("dojo.behavior.applyFast");
-		forIn(this.behaviors, function (tBehavior, id) {
+		// fast DOM queries...wheeee!
+		forIn(this.behaviors, function(tBehavior, id){
 			var elems = dojo.behavior.elementsById(id);
-			dojo.lang.forEach(elems.added, function (elem) {
-				forIn(tBehavior, function (ruleSet, ruleSetName) {
-					if (dojo.lang.isArray(ruleSet)) {
-						dojo.lang.forEach(ruleSet, function (action) {
-							dojo.behavior.applyToNode(elem, action, ruleSetName);
-						});
-					}
-				});
-			});
+			dojo.lang.forEach(elems.added, 
+				function(elem){
+					forIn(tBehavior, function(ruleSet, ruleSetName){
+						if(dojo.lang.isArray(ruleSet)){
+							dojo.lang.forEach(ruleSet, function(action){
+								dojo.behavior.applyToNode(elem, action, ruleSetName);
+							});
+						}
+					});
+				}
+			);
 		});
 		dojo.profile.end("dojo.behavior.applyFast");
-	};
-	this.applySlow = function () {
+	}
+	
+	this.applySlow = function(){
+		// iterate. Ugg.
 		dojo.profile.start("dojo.behavior.applySlow");
 		var all = document.getElementsByTagName("*");
 		var allLen = all.length;
-		for (var x = 0; x < allLen; x++) {
+		for(var x=0; x<allLen; x++){
 			var elem = all[x];
-			if ((elem.id) && (!elem["behaviorAdded"]) && (this.behaviors[elem.id])) {
+			if((elem.id)&&(!elem["behaviorAdded"])&&(this.behaviors[elem.id])){
 				elem["behaviorAdded"] = true;
-				forIn(this.behaviors[elem.id], function (ruleSet, ruleSetName) {
-					if (dojo.lang.isArray(ruleSet)) {
-						dojo.lang.forEach(ruleSet, function (action) {
+				forIn(this.behaviors[elem.id], function(ruleSet, ruleSetName){
+					if(dojo.lang.isArray(ruleSet)){
+						dojo.lang.forEach(ruleSet, function(action){
 							dojo.behavior.applyToNode(elem, action, ruleSetName);
 						});
 					}
@@ -144,7 +242,7 @@
 			}
 		}
 		dojo.profile.end("dojo.behavior.applySlow");
-	};
-};
+	}
+}
+
 dojo.addOnLoad(dojo.behavior, "apply");
-

Modified: tags/parley-0.53/root/static/magic/src/bootstrap1.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/bootstrap1.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/bootstrap1.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,160 +1,339 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
+/**
+* @file bootstrap1.js
+*
+* summary: First file that is loaded that 'bootstraps' the entire dojo library suite.
+* note:  Must run before hostenv_*.js file.
+*
+* @author  Copyright 2004 Mark D. Anderson (mda at discerning.com)
+* TODOC: should the copyright be changed to Dojo Foundation?
+* @license Licensed under the Academic Free License 2.1 http://www.opensource.org/licenses/afl-2.1.php
+*
+* $Id: bootstrap1.js 4342 2006-06-11 23:03:30Z alex $
+*/
 
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
+// TODOC: HOW TO DOC THE BELOW?
+// @global: djConfig
+// summary:  
+//		Application code can set the global 'djConfig' prior to loading
+//		the library to override certain global settings for how dojo works.  
+// description:  The variables that can be set are as follows:
+//			- isDebug: false
+//			- allowQueryConfig: false
+//			- baseScriptUri: ""
+//			- baseRelativePath: ""
+//			- libraryScriptUri: ""
+//			- iePreventClobber: false
+//			- ieClobberMinimal: true
+//			- preventBackButtonFix: true
+//			- searchIds: []
+//			- parseWidgets: true
+// TODOC: HOW TO DOC THESE VARIABLES?
+// TODOC: IS THIS A COMPLETE LIST?
+// note:
+//		'djConfig' does not exist under 'dojo.*' so that it can be set before the 
+//		'dojo' variable exists.  
+// note:
+//		Setting any of these variables *after* the library has loaded does nothing at all. 
+// TODOC: is this still true?  Release notes for 0.3 indicated they could be set after load.
+//
 
-		http://dojotoolkit.org/community/licensing.shtml
-*/
 
 
+//TODOC:  HOW TO DOC THIS?
+// @global: dj_global
+// summary: 
+//		an alias for the top-level global object in the host environment
+//		(e.g., the window object in a browser).
+// description:  
+//		Refer to 'dj_global' rather than referring to window to ensure your
+//		code runs correctly in contexts other than web browsers (eg: Rhino on a server).
+var dj_global = this;
 
-var dj_global = this;
-var dj_currentContext = this;
-function dj_undef(name, object) {
-	return (typeof (object || dj_currentContext)[name] == "undefined");
+
+
+function dj_undef(/*String*/ name, /*Object?*/ object){
+	//summary: Returns true if 'name' is defined on 'object' (or globally if 'object' is null).
+	//description: Note that 'defined' and 'exists' are not the same concept.
+	if(object==null){ object = dj_global; }
+	// exception if object is not an Object
+	return (typeof object[name] == "undefined");	// Boolean
 }
-if (dj_undef("djConfig", this)) {
-	var djConfig = {};
+
+
+// make sure djConfig is defined
+if(dj_undef("djConfig")){ 
+	var djConfig = {}; 
 }
-if (dj_undef("dojo", this)) {
-	var dojo = {};
+
+
+//TODOC:  HOW TO DOC THIS?
+// dojo is the root variable of (almost all) our public symbols -- make sure it is defined.
+if(dj_undef("dojo")){ 
+	var dojo = {}; 
 }
-dojo.global = function () {
-	return dj_currentContext;
-};
-dojo.locale = djConfig.locale;
-dojo.version = {major:0, minor:4, patch:3, flag:"", revision:Number("$Rev: 8617 $".match(/[0-9]+/)[0]), toString:function () {
-	with (dojo.version) {
-		return major + "." + minor + "." + patch + flag + " (" + revision + ")";
+
+//TODOC:  HOW TO DOC THIS?
+dojo.version = {
+	// summary: version number of this instance of dojo.
+	major: 0, minor: 3, patch: 1, flag: "",
+	revision: Number("$Rev: 4342 $".match(/[0-9]+/)[0]),
+	toString: function(){
+		with(dojo.version){
+			return major + "." + minor + "." + patch + flag + " (" + revision + ")";	// String
+		}
 	}
-}};
-dojo.evalProp = function (name, object, create) {
-	if ((!object) || (!name)) {
-		return undefined;
-	}
-	if (!dj_undef(name, object)) {
-		return object[name];
-	}
-	return (create ? (object[name] = {}) : undefined);
-};
-dojo.parseObjPath = function (path, context, create) {
-	var object = (context || dojo.global());
-	var names = path.split(".");
+}
+
+dojo.evalProp = function(/*String*/ name, /*Object*/ object, /*Boolean?*/ create){
+	// summary: Returns 'object[name]'.  If not defined and 'create' is true, will return a new Object.
+	// description: 
+	//		Returns null if 'object[name]' is not defined and 'create' is not true.
+	// 		Note: 'defined' and 'exists' are not the same concept.	
+	return (object && !dj_undef(name, object) ? object[name] : (create ? (object[name]={}) : undefined));	// mixed
+}
+
+
+dojo.parseObjPath = function(/*String*/ path, /*Object?*/ context, /*Boolean?*/ create){
+	// summary: Parse string path to an object, and return corresponding object reference and property name.
+	// description: 
+	//		Returns an object with two properties, 'obj' and 'prop'.  
+	//		'obj[prop]' is the reference indicated by 'path'.
+	// path: Path to an object, in the form "A.B.C".
+	// context: Object to use as root of path.  Defaults to 'dj_global'.
+	// create: If true, Objects will be created at any point along the 'path' that is undefined.
+	var object = (context != null ? context : dj_global);
+	var names = path.split('.');
 	var prop = names.pop();
-	for (var i = 0, l = names.length; i < l && object; i++) {
+	for (var i=0,l=names.length;i<l && object;i++){
 		object = dojo.evalProp(names[i], object, create);
 	}
-	return {obj:object, prop:prop};
-};
-dojo.evalObjPath = function (path, create) {
-	if (typeof path != "string") {
-		return dojo.global();
+	return {obj: object, prop: prop};	// Object: {obj: Object, prop: String}
+}
+
+
+dojo.evalObjPath = function(/*String*/ path, /*Boolean?*/ create){
+	// summary: Return the value of object at 'path' in the global scope, without using 'eval()'.
+	// path: Path to an object, in the form "A.B.C".
+	// create: If true, Objects will be created at any point along the 'path' that is undefined.
+	if(typeof path != "string"){ 
+		return dj_global; 
 	}
-	if (path.indexOf(".") == -1) {
-		return dojo.evalProp(path, dojo.global(), create);
+	// fast path for no periods
+	if(path.indexOf('.') == -1){
+		return dojo.evalProp(path, dj_global, create);		// mixed
 	}
-	var ref = dojo.parseObjPath(path, dojo.global(), create);
-	if (ref) {
-		return dojo.evalProp(ref.prop, ref.obj, create);
+
+	//MOW: old 'with' syntax was confusing and would throw an error if parseObjPath returned null.
+	var ref = dojo.parseObjPath(path, dj_global, create);
+	if(ref){
+		return dojo.evalProp(ref.prop, ref.obj, create);	// mixed
 	}
 	return null;
-};
-dojo.errorToString = function (exception) {
-	if (!dj_undef("message", exception)) {
-		return exception.message;
-	} else {
-		if (!dj_undef("description", exception)) {
-			return exception.description;
-		} else {
-			return exception;
-		}
+}
+
+// ****************************************************************
+// global public utils
+// TODOC: DO WE WANT TO NOTE THAT THESE ARE GLOBAL PUBLIC UTILS?
+// ****************************************************************
+
+dojo.errorToString = function(/*Error*/ exception){
+	// summary: Return an exception's 'message', 'description' or text.
+
+	// TODO: overriding Error.prototype.toString won't accomplish this?
+ 	// 		... since natively generated Error objects do not always reflect such things?
+	if(!dj_undef("message", exception)){
+		return exception.message;		// String
+	}else if(!dj_undef("description", exception)){
+		return exception.description;	// String
+	}else{
+		return exception;				// Error
 	}
-};
-dojo.raise = function (message, exception) {
-	if (exception) {
-		message = message + ": " + dojo.errorToString(exception);
-	} else {
-		message = dojo.errorToString(message);
+}
+
+
+dojo.raise = function(/*String*/ message, /*Error?*/ exception){
+	// summary: Throw an error message, appending text of 'exception' if provided.
+	// note: Also prints a message to the user using 'dojo.hostenv.println'.
+	if(exception){
+		message = message + ": "+dojo.errorToString(exception);
 	}
-	try {
-		if (djConfig.isDebug) {
-			dojo.hostenv.println("FATAL exception raised: " + message);
-		}
-	}
-	catch (e) {
-	}
-	throw exception || Error(message);
-};
-dojo.debug = function () {
-};
-dojo.debugShallow = function (obj) {
-};
-dojo.profile = {start:function () {
-}, end:function () {
-}, stop:function () {
-}, dump:function () {
-}};
-function dj_eval(scriptFragment) {
-	return dj_global.eval ? dj_global.eval(scriptFragment) : eval(scriptFragment);
+
+	// print the message to the user if hostenv.println is defined
+	try {	dojo.hostenv.println("FATAL: "+message); } catch (e) {}
+
+	throw Error(message);
 }
-dojo.unimplemented = function (funcname, extra) {
+
+//Stub functions so things don't break.
+//TODOC:  HOW TO DOC THESE?
+dojo.debug = function(){}
+dojo.debugShallow = function(obj){}
+dojo.profile = { start: function(){}, end: function(){}, stop: function(){}, dump: function(){} };
+
+
+function dj_eval(/*String*/ scriptFragment){ 
+	// summary: Perform an evaluation in the global scope.  Use this rather than calling 'eval()' directly.
+	// description: Placed in a separate function to minimize size of trapped evaluation context.
+	// note:
+	//	 - JSC eval() takes an optional second argument which can be 'unsafe'.
+	//	 - Mozilla/SpiderMonkey eval() takes an optional second argument which is the
+	//  	 scope object for new symbols.
+	return dj_global.eval ? dj_global.eval(scriptFragment) : eval(scriptFragment); 	// mixed
+}
+
+
+
+dojo.unimplemented = function(/*String*/ funcname, /*String?*/ extra){
+	// summary: Throw an exception because some function is not implemented.
+	// extra: Text to append to the exception message.
 	var message = "'" + funcname + "' not implemented";
-	if (extra != null) {
-		message += " " + extra;
-	}
+	if (extra != null) { message += " " + extra; }
 	dojo.raise(message);
-};
-dojo.deprecated = function (behaviour, extra, removal) {
+}
+
+
+dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
+	// summary: Log a debug message to indicate that a behavior has been deprecated.
+	// extra: Text to append to the message.
+	// removal: Text to indicate when in the future the behavior will be removed.
 	var message = "DEPRECATED: " + behaviour;
-	if (extra) {
-		message += " " + extra;
+	if(extra){ message += " " + extra; }
+	if(removal){ message += " -- will be removed in version: " + removal; }
+	dojo.debug(message);
+}
+
+
+
+dojo.inherits = function(/*Function*/ subclass, /*Function*/ superclass){
+	// summary: Set up inheritance between two classes.
+	if(typeof superclass != 'function'){ 
+		dojo.raise("dojo.inherits: superclass argument ["+superclass+"] must be a function (subclass: [" + subclass + "']");
 	}
-	if (removal) {
-		message += " -- will be removed in version: " + removal;
-	}
-	dojo.debug(message);
-};
-dojo.render = (function () {
-	function vscaffold(prefs, names) {
-		var tmp = {capable:false, support:{builtin:false, plugin:false}, prefixes:prefs};
-		for (var i = 0; i < names.length; i++) {
-			tmp[names[i]] = false;
+	subclass.prototype = new superclass();
+	subclass.prototype.constructor = subclass;
+	subclass.superclass = superclass.prototype;
+	// DEPRICATED: super is a reserved word, use 'superclass'
+	subclass['super'] = superclass.prototype;
+}
+
+dojo.render = (function(){
+	//TODOC: HOW TO DOC THIS?
+	// summary: Details rendering support, OS and browser of the current environment.
+	// TODOC: is this something many folks will interact with?  If so, we should doc the structure created...
+	function vscaffold(prefs, names){
+		var tmp = {
+			capable: false,
+			support: {
+				builtin: false,
+				plugin: false
+			},
+			prefixes: prefs
+		};
+		for(var prop in names){
+			tmp[prop] = false;
 		}
 		return tmp;
 	}
-	return {name:"", ver:dojo.version, os:{win:false, linux:false, osx:false}, html:vscaffold(["html"], ["ie", "opera", "khtml", "safari", "moz"]), svg:vscaffold(["svg"], ["corel", "adobe", "batik"]), vml:vscaffold(["vml"], ["ie"]), swf:vscaffold(["Swf", "Flash", "Mm"], ["mm"]), swt:vscaffold(["Swt"], ["ibm"])};
+
+	return {
+		name: "",
+		ver: dojo.version,
+		os: { win: false, linux: false, osx: false },
+		html: vscaffold(["html"], ["ie", "opera", "khtml", "safari", "moz"]),
+		svg: vscaffold(["svg"], ["corel", "adobe", "batik"]),
+		vml: vscaffold(["vml"], ["ie"]),
+		swf: vscaffold(["Swf", "Flash", "Mm"], ["mm"]),
+		swt: vscaffold(["Swt"], ["ibm"])
+	};
 })();
-dojo.hostenv = (function () {
-	var config = {isDebug:false, allowQueryConfig:false, baseScriptUri:"", baseRelativePath:"", libraryScriptUri:"", iePreventClobber:false, ieClobberMinimal:true, preventBackButtonFix:true, delayMozLoadingFix:false, searchIds:[], parseWidgets:true};
-	if (typeof djConfig == "undefined") {
-		djConfig = config;
-	} else {
+
+// ****************************************************************
+// dojo.hostenv methods that must be defined in hostenv_*.js
+// ****************************************************************
+
+/**
+ * The interface definining the interaction with the EcmaScript host environment.
+*/
+
+/*
+ * None of these methods should ever be called directly by library users.
+ * Instead public methods such as loadModule should be called instead.
+ */
+dojo.hostenv = (function(){
+	// TODOC:  HOW TO DOC THIS?
+	// summary: Provides encapsulation of behavior that changes across different 'host environments' 
+	//			(different browsers, server via Rhino, etc).
+	// description: None of these methods should ever be called directly by library users.
+	//				Use public methods such as 'loadModule' instead.
+	
+	// default configuration options
+	var config = {
+		isDebug: false,
+		allowQueryConfig: false,
+		baseScriptUri: "",
+		baseRelativePath: "",
+		libraryScriptUri: "",
+		iePreventClobber: false,
+		ieClobberMinimal: true,
+		preventBackButtonFix: true,
+		searchIds: [],
+		parseWidgets: true
+	};
+
+	if (typeof djConfig == "undefined") { djConfig = config; }
+	else {
 		for (var option in config) {
 			if (typeof djConfig[option] == "undefined") {
 				djConfig[option] = config[option];
 			}
 		}
 	}
-	return {name_:"(unset)", version_:"(unset)", getName:function () {
-		return this.name_;
-	}, getVersion:function () {
-		return this.version_;
-	}, getText:function (uri) {
-		dojo.unimplemented("getText", "uri=" + uri);
-	}};
+
+	return {
+		name_: '(unset)',
+		version_: '(unset)',
+
+
+		getName: function(){ 
+			// sumary: Return the name of the host environment.
+			return this.name_; 	// String
+		},
+
+
+		getVersion: function(){ 
+			// summary: Return the version of the hostenv.
+			return this.version_; // String
+		},
+
+		getText: function(/*String*/ uri){
+			// summary:	Read the plain/text contents at the specified 'uri'.
+			// description: 
+			//			If 'getText()' is not implemented, then it is necessary to override 
+			//			'loadUri()' with an implementation that doesn't rely on it.
+
+			dojo.unimplemented('getText', "uri=" + uri);
+		}
+	};
 })();
-dojo.hostenv.getBaseScriptUri = function () {
-	if (djConfig.baseScriptUri.length) {
+
+
+dojo.hostenv.getBaseScriptUri = function(){
+	// summary: Return the base script uri that other scripts are found relative to.
+	// TODOC: HUH?  This comment means nothing to me.  What other scripts? Is this the path to other dojo libraries?
+	//		MAYBE:  Return the base uri to scripts in the dojo library.	 ???
+	// return: Empty string or a path ending in '/'.
+	if(djConfig.baseScriptUri.length){ 
 		return djConfig.baseScriptUri;
 	}
-	var uri = new String(djConfig.libraryScriptUri || djConfig.baseRelativePath);
-	if (!uri) {
-		dojo.raise("Nothing returned by getLibraryScriptUri(): " + uri);
-	}
-	var lastslash = uri.lastIndexOf("/");
+
+	// MOW: Why not:
+	//			uri = djConfig.libraryScriptUri || djConfig.baseRelativePath
+	//		??? Why 'new String(...)'
+	var uri = new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);
+	if (!uri) { dojo.raise("Nothing returned by getLibraryScriptUri(): " + uri); }
+
+	// MOW: uri seems to not be actually used.  Seems to be hard-coding to djConfig.baseRelativePath... ???
+	var lastslash = uri.lastIndexOf('/');		// MOW ???
 	djConfig.baseScriptUri = djConfig.baseRelativePath;
-	return djConfig.baseScriptUri;
-};
-
+	return djConfig.baseScriptUri;	// String
+}

Added: tags/parley-0.53/root/static/magic/src/bootstrap2.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/bootstrap2.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/bootstrap2.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,174 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+//Semicolon is for when this file is integrated with a custom build on one line
+//with some other file's contents. Sometimes that makes things not get defined
+//properly, particularly with the using the closure below to do all the work.
+;(function(){
+	//Don't do this work if dojo.js has already done it.
+	if(typeof dj_usingBootstrap != "undefined"){
+		return;
+	}
+
+	var isRhino = false;
+	var isSpidermonkey = false;
+	var isDashboard = false;
+	if((typeof this["load"] == "function")&&((typeof this["Packages"] == "function")||(typeof this["Packages"] == "object"))){
+		isRhino = true;
+	}else if(typeof this["load"] == "function"){
+		isSpidermonkey  = true;
+	}else if(window.widget){
+		isDashboard = true;
+	}
+
+	var tmps = [];
+	if((this["djConfig"])&&((djConfig["isDebug"])||(djConfig["debugAtAllCosts"]))){
+		tmps.push("debug.js");
+	}
+
+	if((this["djConfig"])&&(djConfig["debugAtAllCosts"])&&(!isRhino)&&(!isDashboard)){
+		tmps.push("browser_debug.js");
+	}
+
+	//Support compatibility packages. Right now this only allows setting one
+	//compatibility package. Might need to revisit later down the line to support
+	//more than one.
+	if((this["djConfig"])&&(djConfig["compat"])){
+		tmps.push("compat/" + djConfig["compat"] + ".js");
+	}
+
+	var loaderRoot = djConfig["baseScriptUri"];
+	if((this["djConfig"])&&(djConfig["baseLoaderUri"])){
+		loaderRoot = djConfig["baseLoaderUri"];
+	}
+
+	for(var x=0; x < tmps.length; x++){
+		var spath = loaderRoot+"src/"+tmps[x];
+		if(isRhino||isSpidermonkey){
+			load(spath);
+		} else {
+			try {
+				document.write("<scr"+"ipt type='text/javascript' src='"+spath+"'></scr"+"ipt>");
+			} catch (e) {
+				var script = document.createElement("script");
+				script.src = spath;
+				document.getElementsByTagName("head")[0].appendChild(script);
+			}
+		}
+	}
+})();
+
+// Localization routines
+
+/**
+ * The locale to look for string bundles if none are defined for your locale.  Translations for all strings
+ * should be provided in this locale.
+ */
+//TODO: this really belongs in translation metadata, not in code
+dojo.fallback_locale = 'en';
+
+/**
+ * Returns canonical form of locale, as used by Dojo.  All variants are case-insensitive and are separated by '-'
+ * as specified in RFC 3066
+ */
+dojo.normalizeLocale = function(locale) {
+	return locale ? locale.toLowerCase() : dojo.locale;
+};
+
+/**
+ * requireLocalization() is for loading translated bundles provided within a package in the namespace.
+ * Contents are typically strings, but may be any name/value pair, represented in JSON format.
+ * A bundle is structured in a program as follows:
+ *
+ * <package>/
+ *  nls/
+ *   de/
+ *    mybundle.js
+ *   de-at/
+ *    mybundle.js
+ *   en/
+ *    mybundle.js
+ *   en-us/
+ *    mybundle.js
+ *   en-gb/
+ *    mybundle.js
+ *   es/
+ *    mybundle.js
+ *  ...etc
+ *
+ * where package is part of the namespace as used by dojo.require().  Each directory is named for a
+ * locale as specified by RFC 3066, (http://www.ietf.org/rfc/rfc3066.txt), normalized in lowercase.
+ *
+ * For a given locale, string bundles will be loaded for that locale and all general locales above it, as well
+ * as a system-specified fallback.  For example, "de_at" will also load "de" and "en".  Lookups will traverse
+ * the locales in this order.  A build step can preload the bundles to avoid data redundancy and extra network hits.
+ *
+ * @param modulename package in which the bundle is found
+ * @param bundlename bundle name, typically the filename without the '.js' suffix
+ * @param locale the locale to load (optional)  By default, the browser's user locale as defined
+ *	in dojo.locale
+ */
+dojo.requireLocalization = function(modulename, bundlename, locale /*optional*/){
+
+	dojo.debug("EXPERIMENTAL: dojo.requireLocalization"); //dojo.experimental
+
+	var syms = dojo.hostenv.getModuleSymbols(modulename);
+	var modpath = syms.concat("nls").join("/");
+
+	locale = dojo.normalizeLocale(locale);
+
+	var elements = locale.split('-');
+	var searchlist = [];
+	for(var i = elements.length; i > 0; i--){
+		searchlist.push(elements.slice(0, i).join('-'));
+	}
+	if(searchlist[searchlist.length-1] != dojo.fallback_locale){
+		searchlist.push(dojo.fallback_locale);
+	}
+
+	var bundlepackage = [modulename, "_nls", bundlename].join(".");
+	var bundle = dojo.hostenv.startPackage(bundlepackage);
+	dojo.hostenv.loaded_modules_[bundlepackage] = bundle;
+	
+	var inherit = false;
+	for(var i = searchlist.length - 1; i >= 0; i--){
+		var loc = searchlist[i];
+		var pkg = [bundlepackage, loc].join(".");
+		var loaded = false;
+		if(!dojo.hostenv.findModule(pkg)){
+			// Mark loaded whether it's found or not, so that further load attempts will not be made
+			dojo.hostenv.loaded_modules_[pkg] = null;
+
+			var filespec = [modpath, loc, bundlename].join("/") + '.js';
+			loaded = dojo.hostenv.loadPath(filespec, null, function(hash) {
+ 				bundle[loc] = hash;
+ 				if(inherit){
+					// Use mixins approach to copy string references from inherit bundle, but skip overrides.
+					for(var x in inherit){
+						if(!bundle[loc][x]){
+							bundle[loc][x] = inherit[x];
+						}
+					}
+ 				}
+/*
+				// Use prototype to point to other bundle, then copy in result from loadPath
+				bundle[loc] = new function(){};
+				if(inherit){ bundle[loc].prototype = inherit; }
+				for(var i in hash){ bundle[loc][i] = hash[i]; }
+*/
+			});
+		}else{
+			loaded = true;
+		}
+		if(loaded && bundle[loc]){
+			inherit = bundle[loc];
+		}
+	}
+};

Modified: tags/parley-0.53/root/static/magic/src/browser_debug.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/browser_debug.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/browser_debug.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,128 +8,155 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.browser_debug");
 dojo.hostenv.loadedUris.push("../src/bootstrap1.js");
 dojo.hostenv.loadedUris.push("../src/loader.js");
 dojo.hostenv.loadedUris.push("../src/hostenv_browser.js");
-dojo.hostenv._loadedUrisListStart = dojo.hostenv.loadedUris.length;
-function removeComments(contents) {
+dojo.hostenv.loadedUris.push("../src/bootstrap2.js");
+
+function removeComments(contents){
 	contents = new String((!contents) ? "" : contents);
-	contents = contents.replace(/^(.*?)\/\/(.*)$/mg, "$1");
-	contents = contents.replace(/(\n)/mg, "__DOJONEWLINE");
-	contents = contents.replace(/\/\*(.*?)\*\//g, "");
-	return contents.replace(/__DOJONEWLINE/mg, "\n");
+	// clobber all comments
+	contents = contents.replace( /^(.*?)\/\/(.*)$/mg , "$1");
+	contents = contents.replace( /(\n)/mg , "__DOJONEWLINE");
+	contents = contents.replace( /\/\*(.*?)\*\//g , "");
+	return contents.replace( /__DOJONEWLINE/mg , "\n");
 }
-dojo.hostenv.getRequiresAndProvides = function (contents) {
-	if (!contents) {
-		return [];
-	}
+
+dojo.hostenv.getRequiresAndProvides = function(contents){
+	// FIXME: should probably memoize this!
+	if(!contents){ return []; }
+	
+
+	// check to see if we need to load anything else first. Ugg.
 	var deps = [];
 	var tmp;
 	RegExp.lastIndex = 0;
-	var testExp = /dojo.(hostenv.loadModule|hostenv.require|require|requireIf|kwCompoundRequire|hostenv.conditionalLoadModule|hostenv.startPackage|provide)\([\w\W]*?\)/mg;
-	while ((tmp = testExp.exec(contents)) != null) {
+	var testExp = /dojo.(hostenv.loadModule|hosetnv.require|require|requireIf|kwCompoundRequire|hostenv.conditionalLoadModule|hostenv.startPackage|provide)\([\w\W]*?\)/mg;
+	while((tmp = testExp.exec(contents)) != null){
 		deps.push(tmp[0]);
 	}
 	return deps;
-};
-dojo.hostenv.getDelayRequiresAndProvides = function (contents) {
-	if (!contents) {
-		return [];
-	}
+}
+
+dojo.hostenv.getDelayRequiresAndProvides = function(contents){
+	// FIXME: should probably memoize this!
+	if(!contents){ return []; }
+
+	// check to see if we need to load anything else first. Ugg.
 	var deps = [];
 	var tmp;
 	RegExp.lastIndex = 0;
 	var testExp = /dojo.(requireAfterIf)\([\w\W]*?\)/mg;
-	while ((tmp = testExp.exec(contents)) != null) {
+	while((tmp = testExp.exec(contents)) != null){
 		deps.push(tmp[0]);
 	}
 	return deps;
-};
-dojo.clobberLastObject = function (objpath) {
-	if (objpath.indexOf(".") == -1) {
-		if (!dj_undef(objpath, dj_global)) {
+}
+
+/*
+dojo.getNonExistantDescendants = function(objpath){
+	var ret = [];
+	// fast path for no periods
+	if(typeof objpath != "string"){ return dj_global; }
+	if(objpath.indexOf('.') == -1){
+		if(dj_undef(objpath, dj_global)){
+			ret.push[objpath];
+		}
+		return ret;
+	}
+
+	var syms = objpath.split(/\./);
+	var obj = dj_global;
+	for(var i=0;i<syms.length;++i){
+		if(dj_undef(syms[i], obj)){
+			for(var j=i; j<syms.length; j++){
+				ret.push(syms.slice(0, j+1).join("."));
+			}
+			break;
+		}
+	}
+	return ret;
+}
+*/
+
+dojo.clobberLastObject = function(objpath){
+	if(objpath.indexOf('.') == -1){
+		if(!dj_undef(objpath, dj_global)){
 			delete dj_global[objpath];
 		}
 		return true;
 	}
+
 	var syms = objpath.split(/\./);
 	var base = dojo.evalObjPath(syms.slice(0, -1).join("."), false);
-	var child = syms[syms.length - 1];
-	if (!dj_undef(child, base)) {
+	var child = syms[syms.length-1];
+	if(!dj_undef(child, base)){
+		// alert(objpath);
 		delete base[child];
 		return true;
 	}
 	return false;
-};
+}
+
 var removals = [];
-function zip(arr) {
+
+function zip(arr){
 	var ret = [];
 	var seen = {};
-	for (var x = 0; x < arr.length; x++) {
-		if (!seen[arr[x]]) {
+	for(var x=0; x<arr.length; x++){
+		if(!seen[arr[x]]){
 			ret.push(arr[x]);
 			seen[arr[x]] = true;
 		}
 	}
 	return ret;
 }
+
+// over-write dj_eval to prevent actual loading of subsequent files
 var old_dj_eval = dj_eval;
-dj_eval = function () {
-	return true;
-};
+dj_eval = function(){ return true; }
 dojo.hostenv.oldLoadUri = dojo.hostenv.loadUri;
-dojo.hostenv.loadUri = function (uri, cb) {
-	if (dojo.hostenv.loadedUris[uri]) {
-		return true;
+dojo.hostenv.loadUri = function(uri){
+	if(dojo.hostenv.loadedUris[uri]){
+		return true; // fixes endless recursion opera trac 471
 	}
-	try {
+	try{
 		var text = this.getText(uri, null, true);
-		if (!text) {
-			return false;
-		}
-		if (cb) {
-			var expr = old_dj_eval("(" + text + ")");
-			cb(expr);
-		} else {
-			var requires = dojo.hostenv.getRequiresAndProvides(text);
-			eval(requires.join(";"));
-			dojo.hostenv.loadedUris.push(uri);
-			dojo.hostenv.loadedUris[uri] = true;
-			var delayRequires = dojo.hostenv.getDelayRequiresAndProvides(text);
-			eval(delayRequires.join(";"));
-		}
-	}
-	catch (e) {
+		var requires = dojo.hostenv.getRequiresAndProvides(text);
+		eval(requires.join(";"));
+		dojo.hostenv.loadedUris.push(uri);
+		dojo.hostenv.loadedUris[uri] = true;
+		var delayRequires = dojo.hostenv.getDelayRequiresAndProvides(text);
+		eval(delayRequires.join(";"));
+	}catch(e){ 
 		alert(e);
 	}
 	return true;
-};
-dojo.hostenv._writtenIncludes = {};
-dojo.hostenv.writeIncludes = function (willCallAgain) {
-	for (var x = removals.length - 1; x >= 0; x--) {
+}
+
+dojo.hostenv.writeIncludes = function(){
+	for(var x=removals.length-1; x>=0; x--){
 		dojo.clobberLastObject(removals[x]);
 	}
 	var depList = [];
-	var seen = dojo.hostenv._writtenIncludes;
-	for (var x = 0; x < dojo.hostenv.loadedUris.length; x++) {
+	var seen = {};
+	for(var x=0; x<dojo.hostenv.loadedUris.length; x++){
 		var curi = dojo.hostenv.loadedUris[x];
-		if (!seen[curi]) {
+		// dojo.debug(curi);
+		if(!seen[curi]){
 			seen[curi] = true;
 			depList.push(curi);
 		}
 	}
+
 	dojo.hostenv._global_omit_module_check = true;
-	for (var x = dojo.hostenv._loadedUrisListStart; x < depList.length; x++) {
-		document.write("<script type='text/javascript' src='" + depList[x] + "'></script>");
+	for(var x=4; x<depList.length; x++){
+		document.write("<script type='text/javascript' src='"+depList[x]+"'></script>");
 	}
 	document.write("<script type='text/javascript'>dojo.hostenv._global_omit_module_check = false;</script>");
-	dojo.hostenv._loadedUrisListStart = 0;
-	if (!willCallAgain) {
-		dj_eval = old_dj_eval;
-		dojo.hostenv.loadUri = dojo.hostenv.oldLoadUri;
-	}
-};
 
+	// turn off debugAtAllCosts, so that dojo.require() calls inside of ContentPane hrefs
+	// work correctly
+	dj_eval = old_dj_eval;
+	dojo.hostenv.loadUri = dojo.hostenv.oldLoadUri;
+}

Deleted: tags/parley-0.53/root/static/magic/src/browser_debug_xd.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/browser_debug_xd.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/browser_debug_xd.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,38 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.browser_debug_xd");
-dojo.nonDebugProvide = dojo.provide;
-dojo.provide = function (resourceName) {
-	var dbgQueue = dojo.hostenv["xdDebugQueue"];
-	if (dbgQueue && dbgQueue.length > 0 && resourceName == dbgQueue["currentResourceName"]) {
-		window.setTimeout("dojo.hostenv.xdDebugFileLoaded('" + resourceName + "')", 1);
-	}
-	dojo.nonDebugProvide.apply(dojo, arguments);
-};
-dojo.hostenv.xdDebugFileLoaded = function (resourceName) {
-	var dbgQueue = this.xdDebugQueue;
-	if (resourceName && resourceName == dbgQueue.currentResourceName) {
-		dbgQueue.shift();
-	}
-	if (dbgQueue.length == 0) {
-		dbgQueue.currentResourceName = null;
-		this.xdNotifyLoaded();
-	} else {
-		dbgQueue.currentResourceName = dbgQueue[0].resourceName;
-		var element = document.createElement("script");
-		element.type = "text/javascript";
-		element.src = dbgQueue[0].resourcePath;
-		document.getElementsByTagName("head")[0].appendChild(element);
-	}
-};
-

Modified: tags/parley-0.53/root/static/magic/src/collections/ArrayList.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/ArrayList.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/ArrayList.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,107 +8,139 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.ArrayList");
 dojo.require("dojo.collections.Collections");
-dojo.collections.ArrayList = function (arr) {
-	var items = [];
-	if (arr) {
-		items = items.concat(arr);
-	}
-	this.count = items.length;
-	this.add = function (obj) {
+
+dojo.collections.ArrayList=function(/* array? */arr){
+	//	summary
+	//	Returns a new object of type dojo.collections.ArrayList
+	var items=[];
+	if(arr) items=items.concat(arr);
+	this.count=items.length;
+	this.add=function(/* object */obj){
+		//	summary
+		//	Add an element to the collection.
 		items.push(obj);
-		this.count = items.length;
+		this.count=items.length;
 	};
-	this.addRange = function (a) {
-		if (a.getIterator) {
-			var e = a.getIterator();
-			while (!e.atEnd()) {
+	this.addRange=function(/* array */a){
+		//	summary
+		//	Add a range of objects to the ArrayList
+		if(a.getIterator){
+			var e=a.getIterator();
+			while(!e.atEnd()){
 				this.add(e.get());
 			}
-			this.count = items.length;
-		} else {
-			for (var i = 0; i < a.length; i++) {
+			this.count=items.length;
+		}else{
+			for(var i=0; i<a.length; i++){
 				items.push(a[i]);
 			}
-			this.count = items.length;
+			this.count=items.length;
 		}
 	};
-	this.clear = function () {
+	this.clear=function(){
+		//	summary
+		//	Clear all elements out of the collection, and reset the count.
 		items.splice(0, items.length);
-		this.count = 0;
+		this.count=0;
 	};
-	this.clone = function () {
-		return new dojo.collections.ArrayList(items);
+	this.clone=function(){
+		//	summary
+		//	Clone the array list
+		return new dojo.collections.ArrayList(items);	//	dojo.collections.ArrayList
 	};
-	this.contains = function (obj) {
-		for (var i = 0; i < items.length; i++) {
-			if (items[i] == obj) {
-				return true;
+	this.contains=function(/* object */obj){
+		//	summary
+		//	Check to see if the passed object is a member in the ArrayList
+		for(var i=0; i < items.length; i++){
+			if(items[i] == obj) {
+				return true;	//	bool
 			}
 		}
-		return false;
+		return false;	//	bool
 	};
-	this.forEach = function (fn, scope) {
-		var s = scope || dj_global;
-		if (Array.forEach) {
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
 			Array.forEach(items, fn, s);
-		} else {
-			for (var i = 0; i < items.length; i++) {
+		}else{
+			for(var i=0; i<items.length; i++){
 				fn.call(s, items[i], i, items);
 			}
 		}
 	};
-	this.getIterator = function () {
-		return new dojo.collections.Iterator(items);
+	this.getIterator=function(){
+		//	summary
+		//	Get an Iterator for this object
+		return new dojo.collections.Iterator(items);	//	dojo.collections.Iterator
 	};
-	this.indexOf = function (obj) {
-		for (var i = 0; i < items.length; i++) {
-			if (items[i] == obj) {
-				return i;
+	this.indexOf=function(/* object */obj){
+		//	summary
+		//	Return the numeric index of the passed object; will return -1 if not found.
+		for(var i=0; i < items.length; i++){
+			if(items[i] == obj) {
+				return i;	//	int
 			}
 		}
-		return -1;
+		return -1;	// int
 	};
-	this.insert = function (i, obj) {
-		items.splice(i, 0, obj);
-		this.count = items.length;
+	this.insert=function(/* int */ i, /* object */ obj){
+		//	summary
+		//	Insert the passed object at index i
+		items.splice(i,0,obj);
+		this.count=items.length;
 	};
-	this.item = function (i) {
-		return items[i];
+	this.item=function(/* int */ i){
+		//	summary
+		//	return the element at index i
+		return items[i];	//	object
 	};
-	this.remove = function (obj) {
-		var i = this.indexOf(obj);
-		if (i >= 0) {
-			items.splice(i, 1);
+	this.remove=function(/* object */obj){
+		//	summary
+		//	Look for the passed object, and if found, remove it from the internal array.
+		var i=this.indexOf(obj);
+		if(i >=0) {
+			items.splice(i,1);
 		}
-		this.count = items.length;
+		this.count=items.length;
 	};
-	this.removeAt = function (i) {
-		items.splice(i, 1);
-		this.count = items.length;
+	this.removeAt=function(/* int */ i){
+		//	summary
+		//	return an array with function applied to all elements
+		items.splice(i,1);
+		this.count=items.length;
 	};
-	this.reverse = function () {
+	this.reverse=function(){
+		//	summary
+		//	Reverse the internal array
 		items.reverse();
 	};
-	this.sort = function (fn) {
-		if (fn) {
+	this.sort=function(/* function? */ fn){
+		//	summary
+		//	sort the internal array
+		if(fn){
 			items.sort(fn);
-		} else {
+		}else{
 			items.sort();
 		}
 	};
-	this.setByIndex = function (i, obj) {
-		items[i] = obj;
-		this.count = items.length;
+	this.setByIndex=function(/* int */ i, /* object */ obj){
+		//	summary
+		//	Set an element in the array by the passed index.
+		items[i]=obj;
+		this.count=items.length;
 	};
-	this.toArray = function () {
+	this.toArray=function(){
+		//	summary
+		//	Return a new array with all of the items of the internal array concatenated.
 		return [].concat(items);
+	}
+	this.toString=function(/* string */ delim){
+		//	summary
+		//	implementation of toString, follows [].toString();
+		return items.join((delim||","));
 	};
-	this.toString = function (delim) {
-		return items.join((delim || ","));
-	};
 };
-

Modified: tags/parley-0.53/root/static/magic/src/collections/BinaryTree.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/BinaryTree.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/BinaryTree.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,250 +8,196 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.BinaryTree");
 dojo.require("dojo.collections.Collections");
 dojo.require("dojo.experimental");
+
 dojo.experimental("dojo.collections.BinaryTree");
-dojo.collections.BinaryTree = function (data) {
-	function node(data, rnode, lnode) {
-		this.value = data || null;
-		this.right = rnode || null;
-		this.left = lnode || null;
-		this.clone = function () {
-			var c = new node();
-			if (this.value.value) {
-				c.value = this.value.clone();
-			} else {
-				c.value = this.value;
-			}
-			if (this.left) {
-				c.left = this.left.clone();
-			}
-			if (this.right) {
-				c.right = this.right.clone();
-			}
-		};
-		this.compare = function (n) {
-			if (this.value > n.value) {
-				return 1;
-			}
-			if (this.value < n.value) {
-				return -1;
-			}
+
+dojo.collections.BinaryTree=function(data){
+	function node(data, rnode, lnode){
+		this.value=data||null;
+		this.right=rnode||null;
+		this.left=lnode||null;
+		this.clone=function(){
+			var c=new node();
+			if (this.value.value) c.value=this.value.clone();
+			else c.value=this.value;
+			if (this.left) c.left=this.left.clone();
+			if (this.right) c.right=this.right.clone();
+		}
+		this.compare=function(n){
+			if (this.value > n.value) return 1;
+			if (this.value < n.value) return -1;
 			return 0;
-		};
-		this.compareData = function (d) {
-			if (this.value > d) {
-				return 1;
-			}
-			if (this.value < d) {
-				return -1;
-			}
+		}
+		this.compareData=function(d){
+			if (this.value > d) return 1;
+			if (this.value < d) return -1;
 			return 0;
-		};
+		}
 	}
-	function inorderTraversalBuildup(current, a) {
-		if (current) {
+
+	function inorderTraversalBuildup(current, a){
+		if (current){
 			inorderTraversalBuildup(current.left, a);
 			a.add(current);
 			inorderTraversalBuildup(current.right, a);
 		}
 	}
-	function preorderTraversal(current, sep) {
-		var s = "";
-		if (current) {
-			s = current.value.toString() + sep;
+
+	function preorderTraversal(current, sep){
+		var s="";
+		if (current){
+			s=current.value.toString() + sep;
 			s += preorderTraversal(current.left, sep);
 			s += preorderTraversal(current.right, sep);
 		}
 		return s;
 	}
-	function inorderTraversal(current, sep) {
-		var s = "";
-		if (current) {
-			s = inorderTraversal(current.left, sep);
+	function inorderTraversal(current, sep){
+		var s="";
+		if (current){
+			s=inorderTraversal(current.left, sep);
 			s += current.value.toString() + sep;
 			s += inorderTraversal(current.right, sep);
 		}
 		return s;
 	}
-	function postorderTraversal(current, sep) {
-		var s = "";
-		if (current) {
-			s = postorderTraversal(current.left, sep);
+	function postorderTraversal(current, sep){
+		var s="";
+		if (current){
+			s=postorderTraversal(current.left, sep);
 			s += postorderTraversal(current.right, sep);
 			s += current.value.toString() + sep;
 		}
 		return s;
 	}
-	function searchHelper(current, data) {
-		if (!current) {
-			return null;
-		}
-		var i = current.compareData(data);
-		if (i == 0) {
-			return current;
-		}
-		if (i > 0) {
-			return searchHelper(current.left, data);
-		} else {
-			return searchHelper(current.right, data);
-		}
+	
+	function searchHelper(current, data){
+		if (!current) return null;
+		var i=current.compareData(data);
+		if (i==0) return current;
+		if (i>0) return searchHelper(current.left, data);
+		else return searchHelper(current.right, data);
 	}
-	this.add = function (data) {
-		var n = new node(data);
+
+	this.add=function(data){
+		var n=new node(data);
 		var i;
-		var current = root;
-		var parent = null;
-		while (current) {
-			i = current.compare(n);
-			if (i == 0) {
-				return;
-			}
-			parent = current;
-			if (i > 0) {
-				current = current.left;
-			} else {
-				current = current.right;
-			}
+		var current=root;
+		var parent=null;
+		while (current){
+			i=current.compare(n);
+			if (i == 0) return;
+			parent=current;
+			if (i > 0) current=current.left;
+			else current=current.right;
 		}
 		this.count++;
-		if (!parent) {
-			root = n;
-		} else {
-			i = parent.compare(n);
-			if (i > 0) {
-				parent.left = n;
-			} else {
-				parent.right = n;
-			}
+		if (!parent) root=n;
+		else {
+			i=parent.compare(n);
+			if (i > 0) parent.left=n;
+			else parent.right=n;
 		}
 	};
-	this.clear = function () {
-		root = null;
-		this.count = 0;
+	this.clear=function(){
+		root=null;
+		this.count=0;
 	};
-	this.clone = function () {
-		var c = new dojo.collections.BinaryTree();
-		c.root = root.clone();
-		c.count = this.count;
+	this.clone=function(){
+		var c=new dojo.collections.BinaryTree();
+		c.root=root.clone();
+		c.count=this.count;
 		return c;
 	};
-	this.contains = function (data) {
+	this.contains=function(data){
 		return this.search(data) != null;
 	};
-	this.deleteData = function (data) {
-		var current = root;
-		var parent = null;
-		var i = current.compareData(data);
-		while (i != 0 && current != null) {
-			if (i > 0) {
-				parent = current;
-				current = current.left;
-			} else {
-				if (i < 0) {
-					parent = current;
-					current = current.right;
-				}
+	this.deleteData=function(data){
+		var current=root;
+		var parent=null;
+		var i=current.compareData(data);
+		while (i != 0 && current != null){
+			if (i > 0){
+				parent=current;
+				current=current.left;
+			} else if (i < 0) {
+				parent=current;
+				current=current.right;
 			}
-			i = current.compareData(data);
+			i=current.compareData(data);
 		}
-		if (!current) {
-			return;
-		}
+		if (!current) return;
 		this.count--;
 		if (!current.right) {
-			if (!parent) {
-				root = current.left;
-			} else {
-				i = parent.compare(current);
-				if (i > 0) {
-					parent.left = current.left;
-				} else {
-					if (i < 0) {
-						parent.right = current.left;
-					}
-				}
+			if (!parent) root=current.left;
+			else {
+				i=parent.compare(current);
+				if (i > 0) parent.left=current.left;
+				else if (i < 0) parent.right=current.left;
 			}
+		} else if (!current.right.left){
+			if (!parent) root=current.right;
+			else {
+				i=parent.compare(current);
+				if (i > 0) parent.left=current.right;
+				else if (i < 0) parent.right=current.right;
+			}
 		} else {
-			if (!current.right.left) {
-				if (!parent) {
-					root = current.right;
-				} else {
-					i = parent.compare(current);
-					if (i > 0) {
-						parent.left = current.right;
-					} else {
-						if (i < 0) {
-							parent.right = current.right;
-						}
-					}
-				}
-			} else {
-				var leftmost = current.right.left;
-				var lmParent = current.right;
-				while (leftmost.left != null) {
-					lmParent = leftmost;
-					leftmost = leftmost.left;
-				}
-				lmParent.left = leftmost.right;
-				leftmost.left = current.left;
-				leftmost.right = current.right;
-				if (!parent) {
-					root = leftmost;
-				} else {
-					i = parent.compare(current);
-					if (i > 0) {
-						parent.left = leftmost;
-					} else {
-						if (i < 0) {
-							parent.right = leftmost;
-						}
-					}
-				}
+			var leftmost=current.right.left;
+			var lmParent=current.right;
+			while (leftmost.left != null){
+				lmParent=leftmost;
+				leftmost=leftmost.left;
 			}
+			lmParent.left=leftmost.right;
+			leftmost.left=current.left;
+			leftmost.right=current.right;
+			if (!parent) root=leftmost;
+			else {
+				i=parent.compare(current);
+				if (i > 0) parent.left=leftmost;
+				else if (i < 0) parent.right=leftmost;
+			}
 		}
 	};
-	this.getIterator = function () {
-		var a = [];
+	this.getIterator=function(){
+		var a=[];
 		inorderTraversalBuildup(root, a);
 		return new dojo.collections.Iterator(a);
 	};
-	this.search = function (data) {
+	this.search=function(data){
 		return searchHelper(root, data);
 	};
-	this.toString = function (order, sep) {
-		if (!order) {
-			var order = dojo.collections.BinaryTree.TraversalMethods.Inorder;
-		}
-		if (!sep) {
-			var sep = " ";
-		}
-		var s = "";
-		switch (order) {
-		  case dojo.collections.BinaryTree.TraversalMethods.Preorder:
-			s = preorderTraversal(root, sep);
-			break;
-		  case dojo.collections.BinaryTree.TraversalMethods.Inorder:
-			s = inorderTraversal(root, sep);
-			break;
-		  case dojo.collections.BinaryTree.TraversalMethods.Postorder:
-			s = postorderTraversal(root, sep);
-			break;
-		}
-		if (s.length == 0) {
-			return "";
-		} else {
-			return s.substring(0, s.length - sep.length);
-		}
+	this.toString=function(order, sep){
+		if (!order) var order=dojo.collections.BinaryTree.TraversalMethods.Inorder;
+		if (!sep) var sep=" ";
+		var s="";
+		switch (order){
+			case dojo.collections.BinaryTree.TraversalMethods.Preorder:
+				s=preorderTraversal(root, sep);
+				break;
+			case dojo.collections.BinaryTree.TraversalMethods.Inorder:
+				s=inorderTraversal(root, sep);
+				break;
+			case dojo.collections.BinaryTree.TraversalMethods.Postorder:
+				s=postorderTraversal(root, sep);
+				break;
+		};
+		if (s.length == 0) return "";
+		else return s.substring(0, s.length - sep.length);
 	};
-	this.count = 0;
-	var root = this.root = null;
+
+	this.count=0;
+	var root=this.root=null;
 	if (data) {
 		this.add(data);
 	}
+}
+dojo.collections.BinaryTree.TraversalMethods={
+	Preorder : 0,
+	Inorder : 1,
+	Postorder : 2
 };
-dojo.collections.BinaryTree.TraversalMethods = {Preorder:1, Inorder:2, Postorder:3};
-

Modified: tags/parley-0.53/root/static/magic/src/collections/Collections.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Collections.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Collections.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,85 +8,118 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.collections.Collections");
 
-
-dojo.provide("dojo.collections.Collections");
-dojo.collections.DictionaryEntry = function (k, v) {
-	this.key = k;
-	this.value = v;
-	this.valueOf = function () {
-		return this.value;
+dojo.collections={Collections:true};
+dojo.collections.DictionaryEntry=function(/* string */k, /* object */v){
+	//	summary
+	//	return an object of type dojo.collections.DictionaryEntry
+	this.key=k;
+	this.value=v;
+	this.valueOf=function(){ 
+		return this.value; 	//	object
 	};
-	this.toString = function () {
-		return String(this.value);
+	this.toString=function(){ 
+		return String(this.value);	//	string 
 	};
-};
-dojo.collections.Iterator = function (arr) {
-	var a = arr;
-	var position = 0;
-	this.element = a[position] || null;
-	this.atEnd = function () {
-		return (position >= a.length);
+}
+
+/*	Iterators
+ *	The collections.Iterators (Iterator and DictionaryIterator) are built to
+ *	work with the Collections included in this namespace.  However, they *can*
+ *	be used with arrays and objects, respectively, should one choose to do so.
+ */
+dojo.collections.Iterator=function(/* array */arr){
+	//	summary
+	//	return an object of type dojo.collections.Iterator
+	var a=arr;
+	var position=0;
+	this.element=a[position]||null;
+	this.atEnd=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		return (position>=a.length);	//	bool
 	};
-	this.get = function () {
-		if (this.atEnd()) {
-			return null;
+	this.get=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		if(this.atEnd()){
+			return null;		//	object
 		}
-		this.element = a[position++];
-		return this.element;
+		this.element=a[position++];
+		return this.element;	//	object
 	};
-	this.map = function (fn, scope) {
-		var s = scope || dj_global;
-		if (Array.map) {
-			return Array.map(a, fn, s);
-		} else {
-			var arr = [];
-			for (var i = 0; i < a.length; i++) {
-				arr.push(fn.call(s, a[i]));
+	this.map=function(/* function */fn, /* object? */scope){
+		//	summary
+		//	Functional iteration with optional scope.
+		var s=scope||dj_global;
+		if(Array.map){
+			return Array.map(a,fn,s);	//	array
+		}else{
+			var arr=[];
+			for(var i=0; i<a.length; i++){
+				arr.push(fn.call(s,a[i]));
 			}
-			return arr;
+			return arr;		//	array
 		}
 	};
-	this.reset = function () {
-		position = 0;
-		this.element = a[position];
+	this.reset=function(){
+		//	summary
+		//	reset the internal cursor.
+		position=0;
+		this.element=a[position];
 	};
-};
-dojo.collections.DictionaryIterator = function (obj) {
-	var a = [];
-	var testObject = {};
-	for (var p in obj) {
-		if (!testObject[p]) {
-			a.push(obj[p]);
+}
+
+/*	Notes:
+ *	The DictionaryIterator no longer supports a key and value property;
+ *	the reality is that you can use this to iterate over a JS object
+ *	being used as a hashtable.
+ */
+dojo.collections.DictionaryIterator=function(/* object */obj){
+	//	summary
+	//	return an object of type dojo.collections.DictionaryIterator
+	var a=[];	//	Create an indexing array
+	var testObject={};
+	for(var p in obj){
+		if(!testObject[p]){
+			a.push(obj[p]);	//	fill it up
 		}
 	}
-	var position = 0;
-	this.element = a[position] || null;
-	this.atEnd = function () {
-		return (position >= a.length);
+	var position=0;
+	this.element=a[position]||null;
+	this.atEnd=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		return (position>=a.length);	//	bool
 	};
-	this.get = function () {
-		if (this.atEnd()) {
-			return null;
+	this.get=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		if(this.atEnd()){
+			return null;		//	object
 		}
-		this.element = a[position++];
-		return this.element;
+		this.element=a[position++];
+		return this.element;	//	object
 	};
-	this.map = function (fn, scope) {
-		var s = scope || dj_global;
-		if (Array.map) {
-			return Array.map(a, fn, s);
-		} else {
-			var arr = [];
-			for (var i = 0; i < a.length; i++) {
-				arr.push(fn.call(s, a[i]));
+	this.map=function(/* function */fn, /* object? */scope){
+		//	summary
+		//	Functional iteration with optional scope.
+		var s=scope||dj_global;
+		if(Array.map){
+			return Array.map(a,fn,s);	//	array
+		}else{
+			var arr=[];
+			for(var i=0; i<a.length; i++){
+				arr.push(fn.call(s,a[i]));
 			}
-			return arr;
+			return arr;		//	array
 		}
 	};
-	this.reset = function () {
-		position = 0;
-		this.element = a[position];
+	this.reset=function() { 
+		//	summary
+		//	reset the internal cursor.
+		position=0; 
+		this.element=a[position];
 	};
 };
-

Modified: tags/parley-0.53/root/static/magic/src/collections/Dictionary.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Dictionary.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Dictionary.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,94 +8,122 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.collections.Dictionary");
+dojo.require("dojo.collections.Collections");
 
+dojo.collections.Dictionary=function(/* dojo.collections.Dictionary? */dictionary){
+	//	summary
+	//	Returns an object of type dojo.collections.Dictionary
+	var items={};
+	this.count=0;
 
-dojo.provide("dojo.collections.Dictionary");
-dojo.require("dojo.collections.Collections");
-dojo.collections.Dictionary = function (dictionary) {
-	var items = {};
-	this.count = 0;
-	var testObject = {};
-	this.add = function (k, v) {
-		var b = (k in items);
-		items[k] = new dojo.collections.DictionaryEntry(k, v);
-		if (!b) {
+	//	comparator for property addition and access.
+	var testObject={};
+
+	this.add=function(/* string */k, /* object */v){
+		//	summary
+		//	Add a new item to the Dictionary.
+		var b=(k in items);
+		items[k]=new dojo.collections.DictionaryEntry(k,v);
+		if(!b){
 			this.count++;
 		}
 	};
-	this.clear = function () {
-		items = {};
-		this.count = 0;
+	this.clear=function(){
+		//	summary
+		//	Clears the internal dictionary.
+		items={};
+		this.count=0;
 	};
-	this.clone = function () {
-		return new dojo.collections.Dictionary(this);
+	this.clone=function(){
+		//	summary
+		//	Returns a new instance of dojo.collections.Dictionary; note the the dictionary is a clone but items might not be.
+		return new dojo.collections.Dictionary(this);	//	dojo.collections.Dictionary
 	};
-	this.contains = this.containsKey = function (k) {
-		if (testObject[k]) {
-			return false;
+	this.contains=this.containsKey=function(/* string */k){
+		//	summary
+		//	Check to see if the dictionary has an entry at key "k".
+		if(testObject[k]){
+			return false;			// bool
 		}
-		return (items[k] != null);
+		return (items[k]!=null);	//	bool
 	};
-	this.containsValue = function (v) {
-		var e = this.getIterator();
-		while (e.get()) {
-			if (e.element.value == v) {
-				return true;
+	this.containsValue=function(/* object */v){
+		//	summary
+		//	Check to see if the dictionary has an entry with value "v".
+		var e=this.getIterator();
+		while(e.get()){
+			if(e.element.value==v){
+				return true;	//	bool
 			}
 		}
-		return false;
+		return false;	//	bool
 	};
-	this.entry = function (k) {
-		return items[k];
+	this.entry=function(/* string */k){
+		//	summary
+		//	Accessor method; similar to dojo.collections.Dictionary.item but returns the actual Entry object.
+		return items[k];	//	dojo.collections.DictionaryEntry
 	};
-	this.forEach = function (fn, scope) {
-		var a = [];
-		for (var p in items) {
-			if (!testObject[p]) {
-				a.push(items[p]);
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var a=[];	//	Create an indexing array
+		for(var p in items) {
+			if(!testObject[p]){
+				a.push(items[p]);	//	fill it up
 			}
 		}
-		var s = scope || dj_global;
-		if (Array.forEach) {
+		var s=scope||dj_global;
+		if(Array.forEach){
 			Array.forEach(a, fn, s);
-		} else {
-			for (var i = 0; i < a.length; i++) {
+		}else{
+			for(var i=0; i<a.length; i++){
 				fn.call(s, a[i], i, a);
 			}
 		}
 	};
-	this.getKeyList = function () {
-		return (this.getIterator()).map(function (entry) {
-			return entry.key;
-		});
+	this.getKeyList=function(){
+		//	summary
+		//	Returns an array of the keys in the dictionary.
+		return (this.getIterator()).map(function(entry){ 
+			return entry.key; 
+		});	//	array
 	};
-	this.getValueList = function () {
-		return (this.getIterator()).map(function (entry) {
-			return entry.value;
-		});
+	this.getValueList=function(){
+		//	summary
+		//	Returns an array of the values in the dictionary.
+		return (this.getIterator()).map(function(entry){ 
+			return entry.value; 
+		});	//	array
 	};
-	this.item = function (k) {
-		if (k in items) {
-			return items[k].valueOf();
+	this.item=function(/* string */k){
+		//	summary
+		//	Accessor method.
+		if(k in items){
+			return items[k].valueOf();	//	object
 		}
-		return undefined;
+		return undefined;	//	object
 	};
-	this.getIterator = function () {
-		return new dojo.collections.DictionaryIterator(items);
+	this.getIterator=function(){
+		//	summary
+		//	Gets a dojo.collections.DictionaryIterator for iteration purposes.
+		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
 	};
-	this.remove = function (k) {
-		if (k in items && !testObject[k]) {
+	this.remove=function(/* string */k){
+		//	summary
+		//	Removes the item at k from the internal collection.
+		if(k in items && !testObject[k]){
 			delete items[k];
 			this.count--;
-			return true;
+			return true;	//	bool
 		}
-		return false;
+		return false;	//	bool
 	};
-	if (dictionary) {
-		var e = dictionary.getIterator();
-		while (e.get()) {
-			this.add(e.element.key, e.element.value);
+
+	if (dictionary){
+		var e=dictionary.getIterator();
+		while(e.get()) {
+			 this.add(e.element.key, e.element.value);
 		}
 	}
 };
-

Modified: tags/parley-0.53/root/static/magic/src/collections/Graph.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Graph.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Graph.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,144 +8,146 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.Graph");
 dojo.require("dojo.collections.Collections");
+
 dojo.experimental("dojo.collections.Graph");
-dojo.collections.Graph = function (nodes) {
+
+dojo.collections.Graph=function(nodes){
 	function node(key, data, neighbors) {
-		this.key = key;
-		this.data = data;
-		this.neighbors = neighbors || new adjacencyList();
-		this.addDirected = function () {
-			if (arguments[0].constructor == edgeToNeighbor) {
+		this.key=key;
+		this.data=data;
+		this.neighbors=neighbors||new adjacencyList();
+		this.addDirected=function(){
+			if (arguments[0].constructor==edgeToNeighbor){
 				this.neighbors.add(arguments[0]);
-			} else {
-				var n = arguments[0];
-				var cost = arguments[1] || 0;
+			}else{
+				var n=arguments[0];
+				var cost=arguments[1]||0;
 				this.neighbors.add(new edgeToNeighbor(n, cost));
 			}
-		};
+		}
 	}
-	function nodeList() {
-		var d = new dojo.collections.Dictionary();
-		function nodelistiterator() {
-			var o = [];
-			var e = d.getIterator();
-			while (e.get()) {
-				o[o.length] = e.element;
+	function nodeList(){
+		var d=new dojo.collections.Dictionary();
+		function nodelistiterator(){
+			var o=[] ;	//	Create an indexing array
+			var e=d.getIterator();
+			while(e.get()){
+				o[o.length]=e.element;
 			}
-			var position = 0;
-			this.element = o[position] || null;
-			this.atEnd = function () {
-				return (position >= o.length);
-			};
-			this.get = function () {
-				if (this.atEnd()) {
-					return null;
+
+			var position=0;
+			this.element=o[position]||null;
+			this.atEnd=function(){
+				return (position>=o.length);
+			}
+			this.get=function(){
+				if(this.atEnd()){
+					return null;		//	object
 				}
-				this.element = o[position++];
-				return this.element;
+				this.element=o[position++];
+				return this.element;	//	object
 			};
-			this.map = function (fn, scope) {
-				var s = scope || dj_global;
-				if (Array.map) {
-					return Array.map(o, fn, s);
-				} else {
-					var arr = [];
-					for (var i = 0; i < o.length; i++) {
-						arr.push(fn.call(s, o[i]));
+			this.map=function(/* function */fn, /* object? */scope){
+				var s=scope||dj_global;
+				if(Array.map){
+					return Array.map(o,fn,s);	//	array
+				}else{
+					var arr=[];
+					for(var i=0; i<o.length; i++){
+						arr.push(fn.call(s,o[i]));
 					}
-					return arr;
+					return arr;		//	array
 				}
 			};
-			this.reset = function () {
-				position = 0;
-				this.element = o[position];
+			this.reset=function(){
+				position=0;
+				this.element=o[position];
 			};
 		}
-		this.add = function (node) {
+		
+		this.add=function(node){
 			d.add(node.key, node);
 		};
-		this.clear = function () {
+		this.clear=function(){
 			d.clear();
 		};
-		this.containsKey = function (key) {
+		this.containsKey=function(key){
 			return d.containsKey(key);
 		};
-		this.getIterator = function () {
+		this.getIterator=function(){
 			return new nodelistiterator(this);
 		};
-		this.item = function (key) {
+		this.item=function(key){
 			return d.item(key);
 		};
-		this.remove = function (node) {
+		this.remove=function(node){
 			d.remove(node.key);
 		};
 	}
-	function edgeToNeighbor(node, cost) {
-		this.neighbor = node;
-		this.cost = cost;
+	function edgeToNeighbor(node, cost){
+		this.neighbor=node;
+		this.cost=cost;
 	}
-	function adjacencyList() {
-		var d = [];
-		this.add = function (o) {
+	function adjacencyList(){
+		var d=[];
+		this.add=function(o){
 			d.push(o);
 		};
-		this.item = function (i) {
+		this.item=function(i){
 			return d[i];
 		};
-		this.getIterator = function () {
+		this.getIterator=function(){
 			return new dojo.collections.Iterator([].concat(d));
 		};
 	}
-	this.nodes = nodes || new nodeList();
-	this.count = this.nodes.count;
-	this.clear = function () {
+
+	this.nodes=nodes||new nodeList();
+	this.count=this.nodes.count;
+	this.clear=function(){
 		this.nodes.clear();
-		this.count = 0;
+		this.count=0;
 	};
-	this.addNode = function () {
-		var n = arguments[0];
-		if (arguments.length > 1) {
-			n = new node(arguments[0], arguments[1]);
+	this.addNode=function(){
+		var n=arguments[0];
+		if(arguments.length > 1){
+			n=new node(arguments[0],arguments[1]);
 		}
-		if (!this.nodes.containsKey(n.key)) {
+		if(!this.nodes.containsKey(n.key)){
 			this.nodes.add(n);
 			this.count++;
 		}
 	};
-	this.addDirectedEdge = function (uKey, vKey, cost) {
-		var uNode, vNode;
-		if (uKey.constructor != node) {
-			uNode = this.nodes.item(uKey);
-			vNode = this.nodes.item(vKey);
-		} else {
-			uNode = uKey;
-			vNode = vKey;
+	this.addDirectedEdge=function(uKey, vKey, cost){
+		var uNode,vNode;
+		if(uKey.constructor!= node){
+			uNode=this.nodes.item(uKey);
+			vNode=this.nodes.item(vKey);
+		}else{
+			uNode=uKey;
+			vNode=vKey;
 		}
-		var c = cost || 0;
-		uNode.addDirected(vNode, c);
+		var c=cost||0;
+		uNode.addDirected(vNode,c);
 	};
-	this.addUndirectedEdge = function (uKey, vKey, cost) {
+	this.addUndirectedEdge=function(uKey, vKey, cost){
 		var uNode, vNode;
-		if (uKey.constructor != node) {
-			uNode = this.nodes.item(uKey);
-			vNode = this.nodes.item(vKey);
-		} else {
-			uNode = uKey;
-			vNode = vKey;
+		if(uKey.constructor!=node){
+			uNode=this.nodes.item(uKey);
+			vNode=this.nodes.item(vKey);
+		}else{
+			uNode=uKey;
+			vNode=vKey;
 		}
-		var c = cost || 0;
-		uNode.addDirected(vNode, c);
-		vNode.addDirected(uNode, c);
+		var c=cost||0;
+		uNode.addDirected(vNode,c);
+		vNode.addDirected(uNode,c);
 	};
-	this.contains = function (n) {
+	this.contains=function(n){
 		return this.nodes.containsKey(n.key);
 	};
-	this.containsKey = function (k) {
+	this.containsKey=function(k){
 		return this.nodes.containsKey(k);
 	};
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/collections/Queue.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Queue.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Queue.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,60 +8,80 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.Queue");
 dojo.require("dojo.collections.Collections");
-dojo.collections.Queue = function (arr) {
-	var q = [];
-	if (arr) {
-		q = q.concat(arr);
+
+dojo.collections.Queue=function(/* array? */arr){
+	//	summary
+	//	return an object of type dojo.collections.Queue
+	var q=[];
+	if (arr){
+		q=q.concat(arr);
 	}
-	this.count = q.length;
-	this.clear = function () {
-		q = [];
-		this.count = q.length;
+	this.count=q.length;
+	this.clear=function(){
+		//	summary
+		//	clears the internal collection
+		q=[];
+		this.count=q.length;
 	};
-	this.clone = function () {
-		return new dojo.collections.Queue(q);
+	this.clone=function(){
+		//	summary
+		//	creates a new Queue based on this one
+		return new dojo.collections.Queue(q);	//	dojo.collections.Queue
 	};
-	this.contains = function (o) {
-		for (var i = 0; i < q.length; i++) {
-			if (q[i] == o) {
-				return true;
+	this.contains=function(/* object */ o){
+		//	summary
+		//	Check to see if the passed object is an element in this queue
+		for(var i=0; i<q.length; i++){
+			if (q[i]==o){
+				return true;	//	bool
 			}
 		}
-		return false;
+		return false;	//	bool
 	};
-	this.copyTo = function (arr, i) {
-		arr.splice(i, 0, q);
+	this.copyTo=function(/* array */ arr, /* int */ i){
+		//	summary
+		//	Copy the contents of this queue into the passed array at index i.
+		arr.splice(i,0,q);
 	};
-	this.dequeue = function () {
-		var r = q.shift();
-		this.count = q.length;
-		return r;
+	this.dequeue=function(){
+		//	summary
+		//	shift the first element off the queue and return it
+		var r=q.shift();
+		this.count=q.length;
+		return r;	//	object
 	};
-	this.enqueue = function (o) {
-		this.count = q.push(o);
+	this.enqueue=function(/* object */ o){
+		//	summary
+		//	put the passed object at the end of the queue
+		this.count=q.push(o);
 	};
-	this.forEach = function (fn, scope) {
-		var s = scope || dj_global;
-		if (Array.forEach) {
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
 			Array.forEach(q, fn, s);
-		} else {
-			for (var i = 0; i < q.length; i++) {
+		}else{
+			for(var i=0; i<q.length; i++){
 				fn.call(s, q[i], i, q);
 			}
 		}
 	};
-	this.getIterator = function () {
-		return new dojo.collections.Iterator(q);
+	this.getIterator=function(){
+		//	summary
+		//	get an Iterator based on this queue.
+		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
 	};
-	this.peek = function () {
+	this.peek=function(){
+		//	summary
+		//	get the next element in the queue without altering the queue.
 		return q[0];
 	};
-	this.toArray = function () {
+	this.toArray=function(){
+		//	summary
+		//	return an array based on the internal array of the queue.
 		return [].concat(q);
 	};
 };
-

Modified: tags/parley-0.53/root/static/magic/src/collections/Set.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Set.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Set.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,107 +8,77 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.Set");
 dojo.require("dojo.collections.Collections");
 dojo.require("dojo.collections.ArrayList");
-dojo.collections.Set = new function () {
-	this.union = function (setA, setB) {
-		if (setA.constructor == Array) {
-			var setA = new dojo.collections.ArrayList(setA);
-		}
-		if (setB.constructor == Array) {
-			var setB = new dojo.collections.ArrayList(setB);
-		}
-		if (!setA.toArray || !setB.toArray) {
-			dojo.raise("Set operations can only be performed on array-based collections.");
-		}
+
+//	straight up sets are based on arrays or array-based collections.
+dojo.collections.Set = new function(){
+	this.union = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
 		var result = new dojo.collections.ArrayList(setA.toArray());
 		var e = setB.getIterator();
-		while (!e.atEnd()) {
-			var item = e.get();
-			if (!result.contains(item)) {
+		while(!e.atEnd()){
+			var item=e.get();
+			if(!result.contains(item)){
 				result.add(item);
 			}
 		}
 		return result;
 	};
-	this.intersection = function (setA, setB) {
-		if (setA.constructor == Array) {
-			var setA = new dojo.collections.ArrayList(setA);
-		}
-		if (setB.constructor == Array) {
-			var setB = new dojo.collections.ArrayList(setB);
-		}
-		if (!setA.toArray || !setB.toArray) {
-			dojo.raise("Set operations can only be performed on array-based collections.");
-		}
+	this.intersection = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
 		var result = new dojo.collections.ArrayList();
 		var e = setB.getIterator();
-		while (!e.atEnd()) {
-			var item = e.get();
-			if (setA.contains(item)) {
+		while(!e.atEnd()){
+			var item=e.get();
+			if(setA.contains(item)){
 				result.add(item);
 			}
 		}
 		return result;
 	};
-	this.difference = function (setA, setB) {
-		if (setA.constructor == Array) {
-			var setA = new dojo.collections.ArrayList(setA);
-		}
-		if (setB.constructor == Array) {
-			var setB = new dojo.collections.ArrayList(setB);
-		}
-		if (!setA.toArray || !setB.toArray) {
-			dojo.raise("Set operations can only be performed on array-based collections.");
-		}
+	//	returns everything in setA that is not in setB.
+	this.difference = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
 		var result = new dojo.collections.ArrayList();
-		var e = setA.getIterator();
-		while (!e.atEnd()) {
-			var item = e.get();
-			if (!setB.contains(item)) {
+		var e=setA.getIterator();
+		while(!e.atEnd()){
+			var item=e.get();
+			if(!setB.contains(item)){
 				result.add(item);
 			}
 		}
 		return result;
 	};
-	this.isSubSet = function (setA, setB) {
-		if (setA.constructor == Array) {
-			var setA = new dojo.collections.ArrayList(setA);
-		}
-		if (setB.constructor == Array) {
-			var setB = new dojo.collections.ArrayList(setB);
-		}
-		if (!setA.toArray || !setB.toArray) {
-			dojo.raise("Set operations can only be performed on array-based collections.");
-		}
+	this.isSubSet = function(setA, setB) {
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
 		var e = setA.getIterator();
-		while (!e.atEnd()) {
-			if (!setB.contains(e.get())) {
+		while(!e.atEnd()){
+			if(!setB.contains(e.get())){
 				return false;
 			}
 		}
 		return true;
 	};
-	this.isSuperSet = function (setA, setB) {
-		if (setA.constructor == Array) {
-			var setA = new dojo.collections.ArrayList(setA);
-		}
-		if (setB.constructor == Array) {
-			var setB = new dojo.collections.ArrayList(setB);
-		}
-		if (!setA.toArray || !setB.toArray) {
-			dojo.raise("Set operations can only be performed on array-based collections.");
-		}
+	this.isSuperSet = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise("Set operations can only be performed on array-based collections.");
 		var e = setB.getIterator();
-		while (!e.atEnd()) {
-			if (!setA.contains(e.get())) {
+		while(!e.atEnd()){
+			if(!setA.contains(e.get())){
 				return false;
 			}
 		}
 		return true;
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/collections/SkipList.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/SkipList.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/SkipList.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,162 +8,139 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.SkipList");
 dojo.require("dojo.collections.Collections");
 dojo.require("dojo.experimental");
+
 dojo.experimental("dojo.collections.SkipList");
-dojo.collections.SkipList = function () {
-	function node(height, val) {
+
+dojo.collections.SkipList = function(){
+	function node(height, val){
 		this.value = val;
 		this.height = height;
 		this.nodes = new nodeList(height);
-		this.compare = function (val) {
-			if (this.value > val) {
-				return 1;
-			}
-			if (this.value < val) {
-				return -1;
-			}
+		this.compare = function(val){
+			if (this.value > val) return 1;
+			if (this.value < val) return -1;
 			return 0;
-		};
-		this.incrementHeight = function () {
+		}
+		this.incrementHeight = function(){
 			this.nodes.incrementHeight();
 			this.height++;
 		};
-		this.decrementHeight = function () {
+		this.decrementHeight = function(){
 			this.nodes.decrementHeight();
 			this.height--;
 		};
 	}
-	function nodeList(height) {
+	function nodeList(height){
 		var arr = [];
 		this.height = height;
-		for (var i = 0; i < height; i++) {
-			arr[i] = null;
-		}
-		this.item = function (i) {
+		for (var i = 0; i < height; i++) arr[i] = null;
+		this.item = function(i){
 			return arr[i];
 		};
-		this.incrementHeight = function () {
+		this.incrementHeight = function(){
 			this.height++;
 			arr[this.height] = null;
 		};
-		this.decrementHeight = function () {
+		this.decrementHeight = function(){
 			arr.splice(arr.length - 1, 1);
 			this.height--;
 		};
 	}
-	function iterator(list) {
-		this.element = list.head;
-		this.atEnd = function () {
-			return (this.element == null);
+	function iterator(list){
+		this.current = list.head;
+		this.atEnd = false;
+		this.moveNext = function(){
+			if (this.atEnd) return !this.atEnd;
+			this.current = this.current.nodes[0];
+			this.atEnd = (this.current == null);
+			return !this.atEnd;
 		};
-		this.get = function () {
-			if (this.atEnd()) {
-				return null;
-			}
-			this.element = this.element.nodes[0];
-			return this.element;
+		this.reset = function(){
+			this.current = null;
 		};
-		this.reset = function () {
-			this.element = list.head;
-		};
 	}
-	function chooseRandomHeight(max) {
+
+	function chooseRandomHeight(max){
 		var level = 1;
-		while (Math.random() < PROB && level < max) {
-			level++;
-		}
+		while (Math.random() < PROB && level < max) level++;
 		return level;
 	}
+
 	var PROB = 0.5;
 	var comparisons = 0;
+
 	this.head = new node(1);
 	this.count = 0;
-	this.add = function (val) {
+	this.add = function(val){
 		var updates = [];
 		var current = this.head;
-		for (var i = this.head.height; i >= 0; i--) {
-			if (!(current.nodes[i] != null && current.nodes[i].compare(val) < 0)) {
-				comparisons++;
-			}
-			while (current.nodes[i] != null && current.nodes[i].compare(val) < 0) {
+		for (var i = this.head.height; i >= 0; i--){
+			if (!(current.nodes[i] != null && current.nodes[i].compare(val) < 0)) comparisons++;
+			while (current.nodes[i] != null && current.nodes[i].compare(val) < 0){
 				current = current.nodes[i];
 				comparisons++;
 			}
 			updates[i] = current;
 		}
-		if (current.nodes[0] != null && current.nodes[0].compare(val) == 0) {
-			return;
-		}
+		if (current.nodes[0] != null && current.nodes[0].compare(val) == 0) return;
 		var n = new node(val, chooseRandomHeight(this.head.height + 1));
 		this.count++;
-		if (n.height > this.head.height) {
+		if (n.height > this.head.height){
 			this.head.incrementHeight();
 			this.head.nodes[this.head.height - 1] = n;
 		}
-		for (i = 0; i < n.height; i++) {
+		for (i = 0; i < n.height; i++){
 			if (i < updates.length) {
 				n.nodes[i] = updates[i].nodes[i];
 				updates[i].nodes[i] = n;
 			}
 		}
 	};
-	this.contains = function (val) {
+	
+	this.contains = function(val){
 		var current = this.head;
 		var i;
 		for (i = this.head.height - 1; i >= 0; i--) {
 			while (current.item(i) != null) {
 				comparisons++;
 				var result = current.nodes[i].compare(val);
-				if (result == 0) {
-					return true;
-				} else {
-					if (result < 0) {
-						current = current.nodes[i];
-					} else {
-						break;
-					}
-				}
+				if (result == 0) return true;
+				else if (result < 0) current = current.nodes[i];
+				else break;
 			}
 		}
 		return false;
 	};
-	this.getIterator = function () {
+	this.getIterator = function(){
 		return new iterator(this);
 	};
-	this.remove = function (val) {
+
+	this.remove = function(val){
 		var updates = [];
 		var current = this.head;
-		for (var i = this.head.height - 1; i >= 0; i--) {
-			if (!(current.nodes[i] != null && current.nodes[i].compare(val) < 0)) {
-				comparisons++;
-			}
+		for (var i = this.head.height - 1; i >= 0; i--){
+			if (!(current.nodes[i] != null && current.nodes[i].compare(val) < 0)) comparisons++;
 			while (current.nodes[i] != null && current.nodes[i].compare(val) < 0) {
 				current = current.nodes[i];
 				comparisons++;
 			}
 			updates[i] = current;
 		}
+		
 		current = current.nodes[0];
-		if (current != null && current.compare(val) == 0) {
+		if (current != null && current.compare(val) == 0){
 			this.count--;
-			for (var i = 0; i < this.head.height; i++) {
-				if (updates[i].nodes[i] != current) {
-					break;
-				} else {
-					updates[i].nodes[i] = current.nodes[i];
-				}
+			for (var i = 0; i < this.head.height; i++){
+				if (updates[i].nodes[i] != current) break;
+				else updates[i].nodes[i] = current.nodes[i];
 			}
-			if (this.head.nodes[this.head.height - 1] == null) {
-				this.head.decrementHeight();
-			}
+			if (this.head.nodes[this.head.height - 1] == null) this.head.decrementHeight();
 		}
 	};
-	this.resetComparisons = function () {
-		comparisons = 0;
+	this.resetComparisons = function(){ 
+		comparisons = 0; 
 	};
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/collections/SortedList.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/SortedList.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/SortedList.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,164 +8,204 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.SortedList");
 dojo.require("dojo.collections.Collections");
-dojo.collections.SortedList = function (dictionary) {
-	var _this = this;
-	var items = {};
-	var q = [];
-	var sorter = function (a, b) {
-		if (a.key > b.key) {
-			return 1;
-		}
-		if (a.key < b.key) {
-			return -1;
-		}
+
+dojo.collections.SortedList=function(/* object? */ dictionary){
+	//	summary
+	//	creates a collection that acts like a dictionary but is also internally sorted.
+	//	Note that the act of adding any elements forces an internal resort, making this object potentially slow.
+	var _this=this;
+	var items={};
+	var q=[];
+	var sorter=function(a,b){
+		if (a.key > b.key) return 1;
+		if (a.key < b.key) return -1;
 		return 0;
 	};
-	var build = function () {
-		q = [];
-		var e = _this.getIterator();
-		while (!e.atEnd()) {
+	var build=function(){
+		q=[];
+		var e=_this.getIterator();
+		while (!e.atEnd()){
 			q.push(e.get());
 		}
 		q.sort(sorter);
 	};
-	var testObject = {};
-	this.count = q.length;
-	this.add = function (k, v) {
+	var testObject={};
+
+	this.count=q.length;
+	this.add=function(/* string */ k,/* object */v){
+		//	summary
+		//	add the passed value to the dictionary at location k
 		if (!items[k]) {
-			items[k] = new dojo.collections.DictionaryEntry(k, v);
-			this.count = q.push(items[k]);
+			items[k]=new dojo.collections.DictionaryEntry(k,v);
+			this.count=q.push(items[k]);
 			q.sort(sorter);
 		}
 	};
-	this.clear = function () {
-		items = {};
-		q = [];
-		this.count = q.length;
+	this.clear=function(){
+		//	summary
+		//	clear the internal collections
+		items={};
+		q=[];
+		this.count=q.length;
 	};
-	this.clone = function () {
-		return new dojo.collections.SortedList(this);
+	this.clone=function(){
+		//	summary
+		//	create a clone of this sorted list
+		return new dojo.collections.SortedList(this);	//	dojo.collections.SortedList
 	};
-	this.contains = this.containsKey = function (k) {
-		if (testObject[k]) {
-			return false;
+	this.contains=this.containsKey=function(/* string */ k){
+		//	summary
+		//	Check to see if the list has a location k
+		if(testObject[k]){
+			return false;			//	bool
 		}
-		return (items[k] != null);
+		return (items[k]!=null);	//	bool
 	};
-	this.containsValue = function (o) {
-		var e = this.getIterator();
-		while (!e.atEnd()) {
-			var item = e.get();
-			if (item.value == o) {
-				return true;
+	this.containsValue=function(/* object */ o){
+		//	summary
+		//	Check to see if this list contains the passed object
+		var e=this.getIterator();
+		while (!e.atEnd()){
+			var item=e.get();
+			if(item.value==o){ 
+				return true;	//	bool
 			}
 		}
-		return false;
+		return false;	//	bool
 	};
-	this.copyTo = function (arr, i) {
-		var e = this.getIterator();
-		var idx = i;
-		while (!e.atEnd()) {
-			arr.splice(idx, 0, e.get());
+	this.copyTo=function(/* array */ arr, /* int */ i){
+		//	summary
+		//	copy the contents of the list into array arr at index i
+		var e=this.getIterator();
+		var idx=i;
+		while(!e.atEnd()){
+			arr.splice(idx,0,e.get());
 			idx++;
 		}
 	};
-	this.entry = function (k) {
-		return items[k];
+	this.entry=function(/* string */ k){
+		//	summary
+		//	return the object at location k
+		return items[k];	//	dojo.collections.DictionaryEntry
 	};
-	this.forEach = function (fn, scope) {
-		var s = scope || dj_global;
-		if (Array.forEach) {
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
 			Array.forEach(q, fn, s);
-		} else {
-			for (var i = 0; i < q.length; i++) {
+		}else{
+			for(var i=0; i<q.length; i++){
 				fn.call(s, q[i], i, q);
 			}
 		}
 	};
-	this.getByIndex = function (i) {
-		return q[i].valueOf();
+	this.getByIndex=function(/* int */ i){
+		//	summary
+		//	return the item at index i
+		return q[i].valueOf();	//	object
 	};
-	this.getIterator = function () {
-		return new dojo.collections.DictionaryIterator(items);
+	this.getIterator=function(){
+		//	summary
+		//	get an iterator for this object
+		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
 	};
-	this.getKey = function (i) {
+	this.getKey=function(/* int */ i){
+		//	summary
+		//	return the key of the item at index i
 		return q[i].key;
 	};
-	this.getKeyList = function () {
-		var arr = [];
-		var e = this.getIterator();
-		while (!e.atEnd()) {
+	this.getKeyList=function(){
+		//	summary
+		//	return an array of the keys set in this list
+		var arr=[];
+		var e=this.getIterator();
+		while (!e.atEnd()){
 			arr.push(e.get().key);
 		}
-		return arr;
+		return arr;	//	array
 	};
-	this.getValueList = function () {
-		var arr = [];
-		var e = this.getIterator();
-		while (!e.atEnd()) {
+	this.getValueList=function(){
+		//	summary
+		//	return an array of values in this list
+		var arr=[];
+		var e=this.getIterator();
+		while (!e.atEnd()){
 			arr.push(e.get().value);
 		}
-		return arr;
+		return arr;	//	array
 	};
-	this.indexOfKey = function (k) {
-		for (var i = 0; i < q.length; i++) {
-			if (q[i].key == k) {
-				return i;
+	this.indexOfKey=function(/* string */ k){
+		//	summary
+		//	return the index of the passed key.
+		for (var i=0; i<q.length; i++){
+			if (q[i].key==k){
+				return i;	//	int
 			}
 		}
-		return -1;
+		return -1;	//	int
 	};
-	this.indexOfValue = function (o) {
-		for (var i = 0; i < q.length; i++) {
-			if (q[i].value == o) {
-				return i;
+	this.indexOfValue=function(/* object */ o){
+		//	summary
+		//	return the first index of object o
+		for (var i=0; i<q.length; i++){
+			if (q[i].value==o){
+				return i;	//	int
 			}
 		}
-		return -1;
+		return -1;	//	int
 	};
-	this.item = function (k) {
-		if (k in items && !testObject[k]) {
-			return items[k].valueOf();
+	this.item=function(/* string */ k){
+		// 	summary
+		//	return the value of the object at location k.
+		if(k in items && !testObject[k]){
+			return items[k].valueOf();	//	object
 		}
-		return undefined;
+		return undefined;	//	object
 	};
-	this.remove = function (k) {
+	this.remove=function(/* string */k){
+		// 	summary
+		//	remove the item at location k and rebuild the internal collections.
 		delete items[k];
 		build();
-		this.count = q.length;
+		this.count=q.length;
 	};
-	this.removeAt = function (i) {
+	this.removeAt=function(/* int */ i){
+		//	summary
+		//	remove the item at index i, and rebuild the internal collections.
 		delete items[q[i].key];
 		build();
-		this.count = q.length;
+		this.count=q.length;
 	};
-	this.replace = function (k, v) {
-		if (!items[k]) {
-			this.add(k, v);
-			return false;
-		} else {
-			items[k] = new dojo.collections.DictionaryEntry(k, v);
+	this.replace=function(/* string */ k, /* object */ v){
+		//	summary
+		//	Replace an existing item if it's there, and add a new one if not.
+		if (!items[k]){
+			//	we're adding a new object, return false
+			this.add(k,v);
+			return false; // bool
+		}else{
+			//	we're replacing an object, return true
+			items[k]=new dojo.collections.DictionaryEntry(k,v);
 			q.sort(sorter);
-			return true;
+			return true; // bool
 		}
 	};
-	this.setByIndex = function (i, o) {
-		items[q[i].key].value = o;
+	this.setByIndex=function(/* int */ i, /* object */ o){
+		//	summary
+		//	set an item by index
+		items[q[i].key].value=o;
 		build();
-		this.count = q.length;
+		this.count=q.length;
 	};
-	if (dictionary) {
-		var e = dictionary.getIterator();
-		while (!e.atEnd()) {
-			var item = e.get();
-			q[q.length] = items[item.key] = new dojo.collections.DictionaryEntry(item.key, item.value);
+	if (dictionary){
+		var e=dictionary.getIterator();
+		while (!e.atEnd()){
+			var item=e.get();
+			q[q.length]=items[item.key]=new dojo.collections.DictionaryEntry(item.key,item.value);
 		}
 		q.sort(sorter);
 	}
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/collections/Stack.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Stack.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Stack.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,60 +8,78 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.collections.Stack");
 dojo.require("dojo.collections.Collections");
-dojo.collections.Stack = function (arr) {
-	var q = [];
-	if (arr) {
-		q = q.concat(arr);
-	}
-	this.count = q.length;
-	this.clear = function () {
-		q = [];
-		this.count = q.length;
+
+dojo.collections.Stack=function(/* array? */arr){
+	//	summary
+	//	returns an object of type dojo.collections.Stack
+	var q=[];
+	if (arr) q=q.concat(arr);
+	this.count=q.length;
+	this.clear=function(){
+		//	summary
+		//	Clear the internal array and reset the count
+		q=[];
+		this.count=q.length;
 	};
-	this.clone = function () {
+	this.clone=function(){
+		//	summary
+		//	Create and return a clone of this Stack
 		return new dojo.collections.Stack(q);
 	};
-	this.contains = function (o) {
-		for (var i = 0; i < q.length; i++) {
-			if (q[i] == o) {
-				return true;
+	this.contains=function(/* object */o){
+		//	summary
+		//	check to see if the stack contains object o
+		for (var i=0; i<q.length; i++){
+			if (q[i] == o){
+				return true;	//	bool
 			}
 		}
-		return false;
+		return false;	//	bool
 	};
-	this.copyTo = function (arr, i) {
-		arr.splice(i, 0, q);
+	this.copyTo=function(/* array */ arr, /* int */ i){
+		//	summary
+		//	copy the stack into array arr at index i
+		arr.splice(i,0,q);
 	};
-	this.forEach = function (fn, scope) {
-		var s = scope || dj_global;
-		if (Array.forEach) {
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
 			Array.forEach(q, fn, s);
-		} else {
-			for (var i = 0; i < q.length; i++) {
+		}else{
+			for(var i=0; i<q.length; i++){
 				fn.call(s, q[i], i, q);
 			}
 		}
 	};
-	this.getIterator = function () {
-		return new dojo.collections.Iterator(q);
+	this.getIterator=function(){
+		//	summary
+		//	get an iterator for this collection
+		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
 	};
-	this.peek = function () {
-		return q[(q.length - 1)];
+	this.peek=function(){
+		//	summary
+		//	Return the next item without altering the stack itself.
+		return q[(q.length-1)];	//	object
 	};
-	this.pop = function () {
-		var r = q.pop();
-		this.count = q.length;
-		return r;
+	this.pop=function(){
+		//	summary
+		//	pop and return the next item on the stack
+		var r=q.pop();
+		this.count=q.length;
+		return r;	//	object
 	};
-	this.push = function (o) {
-		this.count = q.push(o);
+	this.push=function(/* object */ o){
+		//	summary
+		//	Push object o onto the stack
+		this.count=q.push(o);
 	};
-	this.toArray = function () {
-		return [].concat(q);
+	this.toArray=function(){
+		//	summary
+		//	create and return an array based on the internal collection
+		return [].concat(q);	//	array
 	};
-};
-
+}

Deleted: tags/parley-0.53/root/static/magic/src/collections/Store.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/Store.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/Store.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,293 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.collections.Store");
-dojo.require("dojo.lang.common");
-dojo.collections.Store = function (jsonArray) {
-	var data = [];
-	var items = {};
-	this.keyField = "Id";
-	this.get = function () {
-		return data;
-	};
-	this.getByKey = function (key) {
-		return items[key];
-	};
-	this.getByIndex = function (idx) {
-		return data[idx];
-	};
-	this.getIndexOf = function (key) {
-		for (var i = 0; i < data.length; i++) {
-			if (data[i].key == key) {
-				return i;
-			}
-		}
-		return -1;
-	};
-	this.getData = function () {
-		var arr = [];
-		for (var i = 0; i < data.length; i++) {
-			arr.push(data[i].src);
-		}
-		return arr;
-	};
-	this.getDataByKey = function (key) {
-		if (items[key] != null) {
-			return items[key].src;
-		}
-		return null;
-	};
-	this.getIndexOfData = function (obj) {
-		for (var i = 0; i < data.length; i++) {
-			if (data[i].src == obj) {
-				return i;
-			}
-		}
-		return -1;
-	};
-	this.getDataByIndex = function (idx) {
-		if (data[idx]) {
-			return data[idx].src;
-		}
-		return null;
-	};
-	this.update = function (obj, fieldPath, val, bDontFire) {
-		var parts = fieldPath.split("."), i = 0, o = obj, field;
-		if (parts.length > 1) {
-			field = parts.pop();
-			do {
-				if (parts[i].indexOf("()") > -1) {
-					var temp = parts[i++].split("()")[0];
-					if (!o[temp]) {
-						dojo.raise("dojo.collections.Store.getField(obj, '" + field + "'): '" + temp + "' is not a property of the passed object.");
-					} else {
-						o = o[temp]();
-					}
-				} else {
-					o = o[parts[i++]];
-				}
-			} while (i < parts.length && o != null);
-		} else {
-			field = parts[0];
-		}
-		obj[field] = val;
-		if (!bDontFire) {
-			this.onUpdateField(obj, fieldPath, val);
-		}
-	};
-	this.forEach = function (fn) {
-		if (Array.forEach) {
-			Array.forEach(data, fn, this);
-		} else {
-			for (var i = 0; i < data.length; i++) {
-				fn.call(this, data[i]);
-			}
-		}
-	};
-	this.forEachData = function (fn) {
-		if (Array.forEach) {
-			Array.forEach(this.getData(), fn, this);
-		} else {
-			var a = this.getData();
-			for (var i = 0; i < a.length; i++) {
-				fn.call(this, a[i]);
-			}
-		}
-	};
-	this.setData = function (arr, bDontFire) {
-		data = [];
-		for (var i = 0; i < arr.length; i++) {
-			var o = {key:arr[i][this.keyField], src:arr[i]};
-			data.push(o);
-			items[o.key] = o;
-		}
-		if (!bDontFire) {
-			this.onSetData();
-		}
-	};
-	this.clearData = function (bDontFire) {
-		data = [];
-		items = {};
-		if (!bDontFire) {
-			this.onClearData();
-		}
-	};
-	this.addData = function (obj, key, bDontFire) {
-		var k = key || obj[this.keyField];
-		if (items[k] != null) {
-			var o = items[k];
-			o.src = obj;
-		} else {
-			var o = {key:k, src:obj};
-			data.push(o);
-			items[o.key] = o;
-		}
-		if (!bDontFire) {
-			this.onAddData(o);
-		}
-	};
-	this.addDataRange = function (arr, bDontFire) {
-		var objects = [];
-		for (var i = 0; i < arr.length; i++) {
-			var k = arr[i][this.keyField];
-			if (items[k] != null) {
-				var o = items[k];
-				o.src = arr[i];
-			} else {
-				var o = {key:k, src:arr[i]};
-				data.push(o);
-				items[k] = o;
-			}
-			objects.push(o);
-		}
-		if (!bDontFire) {
-			this.onAddDataRange(objects);
-		}
-	};
-	this.addDataByIndex = function (obj, idx, key, bDontFire) {
-		var k = key || obj[this.keyField];
-		if (items[k] != null) {
-			var i = this.getIndexOf(k);
-			var o = data.splice(i, 1);
-			o.src = obj;
-		} else {
-			var o = {key:k, src:obj};
-			items[k] = o;
-		}
-		data.splice(idx, 0, o);
-		if (!bDontFire) {
-			this.onAddData(o);
-		}
-	};
-	this.addDataRangeByIndex = function (arr, idx, bDontFire) {
-		var objects = [];
-		for (var i = 0; i < arr.length; i++) {
-			var k = arr[i][this.keyField];
-			if (items[k] != null) {
-				var j = this.getIndexOf(k);
-				var o = data.splice(j, 1);
-				o.src = arr[i];
-			} else {
-				var o = {key:k, src:arr[i]};
-				items[k] = o;
-			}
-			objects.push(o);
-		}
-		data.splice(idx, 0, objects);
-		if (!bDontFire) {
-			this.onAddDataRange(objects);
-		}
-	};
-	this.removeData = function (obj, bDontFire) {
-		var idx = -1;
-		var o = null;
-		for (var i = 0; i < data.length; i++) {
-			if (data[i].src == obj) {
-				idx = i;
-				o = data[i];
-				break;
-			}
-		}
-		if (!bDontFire) {
-			this.onRemoveData(o);
-		}
-		if (idx > -1) {
-			data.splice(idx, 1);
-			delete items[o.key];
-		}
-	};
-	this.removeDataRange = function (idx, range, bDontFire) {
-		var ret = data.splice(idx, range);
-		for (var i = 0; i < ret.length; i++) {
-			delete items[ret[i].key];
-		}
-		if (!bDontFire) {
-			this.onRemoveDataRange(ret);
-		}
-		return ret;
-	};
-	this.removeDataByKey = function (key, bDontFire) {
-		this.removeData(this.getDataByKey(key), bDontFire);
-	};
-	this.removeDataByIndex = function (idx, bDontFire) {
-		this.removeData(this.getDataByIndex(idx), bDontFire);
-	};
-	if (jsonArray && jsonArray.length && jsonArray[0]) {
-		this.setData(jsonArray, true);
-	}
-};
-dojo.extend(dojo.collections.Store, {getField:function (obj, field) {
-	var parts = field.split("."), i = 0, o = obj;
-	do {
-		if (parts[i].indexOf("()") > -1) {
-			var temp = parts[i++].split("()")[0];
-			if (!o[temp]) {
-				dojo.raise("dojo.collections.Store.getField(obj, '" + field + "'): '" + temp + "' is not a property of the passed object.");
-			} else {
-				o = o[temp]();
-			}
-		} else {
-			o = o[parts[i++]];
-		}
-	} while (i < parts.length && o != null);
-	if (i < parts.length) {
-		dojo.raise("dojo.collections.Store.getField(obj, '" + field + "'): '" + field + "' is not a property of the passed object.");
-	}
-	return o;
-}, getFromHtml:function (meta, body, fnMod) {
-	var rows = body.rows;
-	var ctor = function (row) {
-		var obj = {};
-		for (var i = 0; i < meta.length; i++) {
-			var o = obj;
-			var data = row.cells[i].innerHTML;
-			var p = meta[i].getField();
-			if (p.indexOf(".") > -1) {
-				p = p.split(".");
-				while (p.length > 1) {
-					var pr = p.shift();
-					o[pr] = {};
-					o = o[pr];
-				}
-				p = p[0];
-			}
-			var type = meta[i].getType();
-			if (type == String) {
-				o[p] = data;
-			} else {
-				if (data) {
-					o[p] = new type(data);
-				} else {
-					o[p] = new type();
-				}
-			}
-		}
-		return obj;
-	};
-	var arr = [];
-	for (var i = 0; i < rows.length; i++) {
-		var o = ctor(rows[i]);
-		if (fnMod) {
-			fnMod(o, rows[i]);
-		}
-		arr.push(o);
-	}
-	return arr;
-}, onSetData:function () {
-}, onClearData:function () {
-}, onAddData:function (obj) {
-}, onAddDataRange:function (arr) {
-}, onRemoveData:function (obj) {
-}, onRemoveDataRange:function (arr) {
-}, onUpdateField:function (obj, field, val) {
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/collections/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/collections/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/collections/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,15 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.collections.Collections", "dojo.collections.SortedList", "dojo.collections.Dictionary", "dojo.collections.Queue", "dojo.collections.ArrayList", "dojo.collections.Stack", "dojo.collections.Set"]});
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.collections.Collections",
+		"dojo.collections.SortedList", 
+		"dojo.collections.Dictionary", 
+		"dojo.collections.Queue", 
+		"dojo.collections.ArrayList", 
+		"dojo.collections.Stack",
+		"dojo.collections.Set"
+	]
+});
 dojo.provide("dojo.collections.*");
-

Added: tags/parley-0.53/root/static/magic/src/compat/0.2.2.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/compat/0.2.2.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/compat/0.2.2.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,75 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+/*
+Compatibility package to get 0.2.2 functionality in later Dojo releases.
+*/
+
+//**********************************
+//From bootstrap1.js
+dj_throw = dj_rethrow = function(m, e){
+	dojo.deprecated("dj_throw and dj_rethrow", "use dojo.raise instead", "0.4");
+	dojo.raise(m, e);
+}
+
+dj_debug = dojo.debug;
+dj_unimplemented = dojo.unimplemented;
+dj_deprecated = dojo.deprecated;
+
+dj_inherits = function(subclass, superclass){
+	dojo.deprecated("dj_inherits", "use dojo.inherits instead", "0.4");
+	dojo.inherits(subclass, superclass);
+}
+
+/**
+* Set the base script uri.
+*/
+// In JScript .NET, see interface System._AppDomain implemented by
+// System.AppDomain.CurrentDomain. Members include AppendPrivatePath,
+// RelativeSearchPath, BaseDirectory.
+dojo.hostenv.setBaseScriptUri = function(uri){ djConfig.baseScriptUri = uri }
+
+//**********************************
+//From the old bootstrap2.js
+dojo.hostenv.moduleLoaded = function(){
+	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
+}
+
+dojo.hostenv.require = dojo.hostenv.loadModule;
+dojo.requireAfter = dojo.require;
+dojo.conditionalRequire = dojo.requireIf;
+
+dojo.requireAll = function() {
+	for(var i = 0; i < arguments.length; i++) { dojo.require(arguments[i]); }
+}
+
+dojo.hostenv.conditionalLoadModule = function(){
+	dojo.kwCompoundRequire.apply(dojo, arguments);
+}
+
+dojo.hostenv.provide = dojo.hostenv.startPackage;
+
+//**********************************
+//From hostenv_browser.js
+dojo.hostenv.byId = dojo.byId;
+
+dojo.hostenv.byIdArray = dojo.byIdArray = function(){
+	var ids = [];
+	for(var i = 0; i < arguments.length; i++){
+		if((arguments[i] instanceof Array)||(typeof arguments[i] == "array")){
+			for(var j = 0; j < arguments[i].length; j++){
+				ids = ids.concat(dojo.hostenv.byIdArray(arguments[i][j]));
+			}
+		}else{
+			ids.push(dojo.hostenv.byId(arguments[i]));
+		}
+	}
+	return ids;
+}

Modified: tags/parley-0.53/root/static/magic/src/crypto/Blowfish.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto/Blowfish.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto/Blowfish.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,377 +8,541 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.require("dojo.crypto");
 dojo.provide("dojo.crypto.Blowfish");
-dojo.crypto.Blowfish = new function () {
-	var POW2 = Math.pow(2, 2);
-	var POW3 = Math.pow(2, 3);
-	var POW4 = Math.pow(2, 4);
-	var POW8 = Math.pow(2, 8);
-	var POW16 = Math.pow(2, 16);
-	var POW24 = Math.pow(2, 24);
-	var iv = null;
-	var boxes = {p:[608135816, 2242054355, 320440878, 57701188, 2752067618, 698298832, 137296536, 3964562569, 1160258022, 953160567, 3193202383, 887688300, 3232508343, 3380367581, 1065670069, 3041331479, 2450970073, 2306472731], s0:[3509652390, 2564797868, 805139163, 3491422135, 3101798381, 1780907670, 3128725573, 4046225305, 614570311, 3012652279, 134345442, 2240740374, 1667834072, 1901547113, 2757295779, 4103290238, 227898511, 1921955416, 1904987480, 2182433518, 2069144605, 3260701109, 2620446009, 720527379, 3318853667, 677414384, 3393288472, 3101374703, 2390351024, 1614419982, 1822297739, 2954791486, 3608508353, 3174124327, 2024746970, 1432378464, 3864339955, 2857741204, 1464375394, 1676153920, 1439316330, 715854006, 3033291828, 289532110, 2706671279, 2087905683, 3018724369, 1668267050, 732546397, 1947742710, 3462151702, 2609353502, 2950085171, 1814351708, 2050118529, 680887927, 999245976, 1800124847, 3300911131, 1713906067, 1641548236, 4213287313, 1216130144, 1575780402, 4!
 018429277, 3917837745, 3693486850, 3949271944, 596196993, 3549867205, 258830323, 2213823033, 772490370, 2760122372, 1774776394, 2652871518, 566650946, 4142492826, 1728879713, 2882767088, 1783734482, 3629395816, 2517608232, 2874225571, 1861159788, 326777828, 3124490320, 2130389656, 2716951837, 967770486, 1724537150, 2185432712, 2364442137, 1164943284, 2105845187, 998989502, 3765401048, 2244026483, 1075463327, 1455516326, 1322494562, 910128902, 469688178, 1117454909, 936433444, 3490320968, 3675253459, 1240580251, 122909385, 2157517691, 634681816, 4142456567, 3825094682, 3061402683, 2540495037, 79693498, 3249098678, 1084186820, 1583128258, 426386531, 1761308591, 1047286709, 322548459, 995290223, 1845252383, 2603652396, 3431023940, 2942221577, 3202600964, 3727903485, 1712269319, 422464435, 3234572375, 1170764815, 3523960633, 3117677531, 1434042557, 442511882, 3600875718, 1076654713, 1738483198, 4213154764, 2393238008, 3677496056, 1014306527, 4251020053, 793779912, 2902807211, 8!
 42905082, 4246964064, 1395751752, 1040244610, 2656851899, 3396!
 308128, 
445077038, 3742853595, 3577915638, 679411651, 2892444358, 2354009459, 1767581616, 3150600392, 3791627101, 3102740896, 284835224, 4246832056, 1258075500, 768725851, 2589189241, 3069724005, 3532540348, 1274779536, 3789419226, 2764799539, 1660621633, 3471099624, 4011903706, 913787905, 3497959166, 737222580, 2514213453, 2928710040, 3937242737, 1804850592, 3499020752, 2949064160, 2386320175, 2390070455, 2415321851, 4061277028, 2290661394, 2416832540, 1336762016, 1754252060, 3520065937, 3014181293, 791618072, 3188594551, 3933548030, 2332172193, 3852520463, 3043980520, 413987798, 3465142937, 3030929376, 4245938359, 2093235073, 3534596313, 375366246, 2157278981, 2479649556, 555357303, 3870105701, 2008414854, 3344188149, 4221384143, 3956125452, 2067696032, 3594591187, 2921233993, 2428461, 544322398, 577241275, 1471733935, 610547355, 4027169054, 1432588573, 1507829418, 2025931657, 3646575487, 545086370, 48609733, 2200306550, 1653985193, 298326376, 1316178497, 3007786442, 2064951626, 4!
 58293330, 2589141269, 3591329599, 3164325604, 727753846, 2179363840, 146436021, 1461446943, 4069977195, 705550613, 3059967265, 3887724982, 4281599278, 3313849956, 1404054877, 2845806497, 146425753, 1854211946], s1:[1266315497, 3048417604, 3681880366, 3289982499, 2909710000, 1235738493, 2632868024, 2414719590, 3970600049, 1771706367, 1449415276, 3266420449, 422970021, 1963543593, 2690192192, 3826793022, 1062508698, 1531092325, 1804592342, 2583117782, 2714934279, 4024971509, 1294809318, 4028980673, 1289560198, 2221992742, 1669523910, 35572830, 157838143, 1052438473, 1016535060, 1802137761, 1753167236, 1386275462, 3080475397, 2857371447, 1040679964, 2145300060, 2390574316, 1461121720, 2956646967, 4031777805, 4028374788, 33600511, 2920084762, 1018524850, 629373528, 3691585981, 3515945977, 2091462646, 2486323059, 586499841, 988145025, 935516892, 3367335476, 2599673255, 2839830854, 265290510, 3972581182, 2759138881, 3795373465, 1005194799, 847297441, 406762289, 1314163512, 133259!
 0856, 1866599683, 4127851711, 750260880, 613907577, 1450815602!
 , 316562
0655, 3734664991, 3650291728, 3012275730, 3704569646, 1427272223, 778793252, 1343938022, 2676280711, 2052605720, 1946737175, 3164576444, 3914038668, 3967478842, 3682934266, 1661551462, 3294938066, 4011595847, 840292616, 3712170807, 616741398, 312560963, 711312465, 1351876610, 322626781, 1910503582, 271666773, 2175563734, 1594956187, 70604529, 3617834859, 1007753275, 1495573769, 4069517037, 2549218298, 2663038764, 504708206, 2263041392, 3941167025, 2249088522, 1514023603, 1998579484, 1312622330, 694541497, 2582060303, 2151582166, 1382467621, 776784248, 2618340202, 3323268794, 2497899128, 2784771155, 503983604, 4076293799, 907881277, 423175695, 432175456, 1378068232, 4145222326, 3954048622, 3938656102, 3820766613, 2793130115, 2977904593, 26017576, 3274890735, 3194772133, 1700274565, 1756076034, 4006520079, 3677328699, 720338349, 1533947780, 354530856, 688349552, 3973924725, 1637815568, 332179504, 3949051286, 53804574, 2852348879, 3044236432, 1282449977, 3583942155, 3416972820,!
  4006381244, 1617046695, 2628476075, 3002303598, 1686838959, 431878346, 2686675385, 1700445008, 1080580658, 1009431731, 832498133, 3223435511, 2605976345, 2271191193, 2516031870, 1648197032, 4164389018, 2548247927, 300782431, 375919233, 238389289, 3353747414, 2531188641, 2019080857, 1475708069, 455242339, 2609103871, 448939670, 3451063019, 1395535956, 2413381860, 1841049896, 1491858159, 885456874, 4264095073, 4001119347, 1565136089, 3898914787, 1108368660, 540939232, 1173283510, 2745871338, 3681308437, 4207628240, 3343053890, 4016749493, 1699691293, 1103962373, 3625875870, 2256883143, 3830138730, 1031889488, 3479347698, 1535977030, 4236805024, 3251091107, 2132092099, 1774941330, 1199868427, 1452454533, 157007616, 2904115357, 342012276, 595725824, 1480756522, 206960106, 497939518, 591360097, 863170706, 2375253569, 3596610801, 1814182875, 2094937945, 3421402208, 1082520231, 3463918190, 2785509508, 435703966, 3908032597, 1641649973, 2842273706, 3305899714, 1510255612, 21482564!
 76, 2655287854, 3276092548, 4258621189, 236887753, 3681803219,!
  2740410
37, 1734335097, 3815195456, 3317970021, 1899903192, 1026095262, 4050517792, 356393447, 2410691914, 3873677099, 3682840055], s2:[3913112168, 2491498743, 4132185628, 2489919796, 1091903735, 1979897079, 3170134830, 3567386728, 3557303409, 857797738, 1136121015, 1342202287, 507115054, 2535736646, 337727348, 3213592640, 1301675037, 2528481711, 1895095763, 1721773893, 3216771564, 62756741, 2142006736, 835421444, 2531993523, 1442658625, 3659876326, 2882144922, 676362277, 1392781812, 170690266, 3921047035, 1759253602, 3611846912, 1745797284, 664899054, 1329594018, 3901205900, 3045908486, 2062866102, 2865634940, 3543621612, 3464012697, 1080764994, 553557557, 3656615353, 3996768171, 991055499, 499776247, 1265440854, 648242737, 3940784050, 980351604, 3713745714, 1749149687, 3396870395, 4211799374, 3640570775, 1161844396, 3125318951, 1431517754, 545492359, 4268468663, 3499529547, 1437099964, 2702547544, 3433638243, 2581715763, 2787789398, 1060185593, 1593081372, 2418618748, 4260947970, !
 69676912, 2159744348, 86519011, 2512459080, 3838209314, 1220612927, 3339683548, 133810670, 1090789135, 1078426020, 1569222167, 845107691, 3583754449, 4072456591, 1091646820, 628848692, 1613405280, 3757631651, 526609435, 236106946, 48312990, 2942717905, 3402727701, 1797494240, 859738849, 992217954, 4005476642, 2243076622, 3870952857, 3732016268, 765654824, 3490871365, 2511836413, 1685915746, 3888969200, 1414112111, 2273134842, 3281911079, 4080962846, 172450625, 2569994100, 980381355, 4109958455, 2819808352, 2716589560, 2568741196, 3681446669, 3329971472, 1835478071, 660984891, 3704678404, 4045999559, 3422617507, 3040415634, 1762651403, 1719377915, 3470491036, 2693910283, 3642056355, 3138596744, 1364962596, 2073328063, 1983633131, 926494387, 3423689081, 2150032023, 4096667949, 1749200295, 3328846651, 309677260, 2016342300, 1779581495, 3079819751, 111262694, 1274766160, 443224088, 298511866, 1025883608, 3806446537, 1145181785, 168956806, 3641502830, 3584813610, 1689216846, 366!
 6258015, 3200248200, 1692713982, 2646376535, 4042768518, 16185!
 08792, 1
610833997, 3523052358, 4130873264, 2001055236, 3610705100, 2202168115, 4028541809, 2961195399, 1006657119, 2006996926, 3186142756, 1430667929, 3210227297, 1314452623, 4074634658, 4101304120, 2273951170, 1399257539, 3367210612, 3027628629, 1190975929, 2062231137, 2333990788, 2221543033, 2438960610, 1181637006, 548689776, 2362791313, 3372408396, 3104550113, 3145860560, 296247880, 1970579870, 3078560182, 3769228297, 1714227617, 3291629107, 3898220290, 166772364, 1251581989, 493813264, 448347421, 195405023, 2709975567, 677966185, 3703036547, 1463355134, 2715995803, 1338867538, 1343315457, 2802222074, 2684532164, 233230375, 2599980071, 2000651841, 3277868038, 1638401717, 4028070440, 3237316320, 6314154, 819756386, 300326615, 590932579, 1405279636, 3267499572, 3150704214, 2428286686, 3959192993, 3461946742, 1862657033, 1266418056, 963775037, 2089974820, 2263052895, 1917689273, 448879540, 3550394620, 3981727096, 150775221, 3627908307, 1303187396, 508620638, 2975983352, 2726630617, !
 1817252668, 1876281319, 1457606340, 908771278, 3720792119, 3617206836, 2455994898, 1729034894, 1080033504], s3:[976866871, 3556439503, 2881648439, 1522871579, 1555064734, 1336096578, 3548522304, 2579274686, 3574697629, 3205460757, 3593280638, 3338716283, 3079412587, 564236357, 2993598910, 1781952180, 1464380207, 3163844217, 3332601554, 1699332808, 1393555694, 1183702653, 3581086237, 1288719814, 691649499, 2847557200, 2895455976, 3193889540, 2717570544, 1781354906, 1676643554, 2592534050, 3230253752, 1126444790, 2770207658, 2633158820, 2210423226, 2615765581, 2414155088, 3127139286, 673620729, 2805611233, 1269405062, 4015350505, 3341807571, 4149409754, 1057255273, 2012875353, 2162469141, 2276492801, 2601117357, 993977747, 3918593370, 2654263191, 753973209, 36408145, 2530585658, 25011837, 3520020182, 2088578344, 530523599, 2918365339, 1524020338, 1518925132, 3760827505, 3759777254, 1202760957, 3985898139, 3906192525, 674977740, 4174734889, 2031300136, 2019492241, 3983892565, !
 4153806404, 3822280332, 352677332, 2297720250, 60907813, 90501!
 309, 328
6998549, 1016092578, 2535922412, 2839152426, 457141659, 509813237, 4120667899, 652014361, 1966332200, 2975202805, 55981186, 2327461051, 676427537, 3255491064, 2882294119, 3433927263, 1307055953, 942726286, 933058658, 2468411793, 3933900994, 4215176142, 1361170020, 2001714738, 2830558078, 3274259782, 1222529897, 1679025792, 2729314320, 3714953764, 1770335741, 151462246, 3013232138, 1682292957, 1483529935, 471910574, 1539241949, 458788160, 3436315007, 1807016891, 3718408830, 978976581, 1043663428, 3165965781, 1927990952, 4200891579, 2372276910, 3208408903, 3533431907, 1412390302, 2931980059, 4132332400, 1947078029, 3881505623, 4168226417, 2941484381, 1077988104, 1320477388, 886195818, 18198404, 3786409000, 2509781533, 112762804, 3463356488, 1866414978, 891333506, 18488651, 661792760, 1628790961, 3885187036, 3141171499, 876946877, 2693282273, 1372485963, 791857591, 2686433993, 3759982718, 3167212022, 3472953795, 2716379847, 445679433, 3561995674, 3504004811, 3574258232, 5411716!
 2, 3331405415, 2381918588, 3769707343, 4154350007, 1140177722, 4074052095, 668550556, 3214352940, 367459370, 261225585, 2610173221, 4209349473, 3468074219, 3265815641, 314222801, 3066103646, 3808782860, 282218597, 3406013506, 3773591054, 379116347, 1285071038, 846784868, 2669647154, 3771962079, 3550491691, 2305946142, 453669953, 1268987020, 3317592352, 3279303384, 3744833421, 2610507566, 3859509063, 266596637, 3847019092, 517658769, 3462560207, 3443424879, 370717030, 4247526661, 2224018117, 4143653529, 4112773975, 2788324899, 2477274417, 1456262402, 2901442914, 1517677493, 1846949527, 2295493580, 3734397586, 2176403920, 1280348187, 1908823572, 3871786941, 846861322, 1172426758, 3287448474, 3383383037, 1655181056, 3139813346, 901632758, 1897031941, 2986607138, 3066810236, 3447102507, 1393639104, 373351379, 950779232, 625454576, 3124240540, 4148612726, 2007998917, 544563296, 2244738638, 2330496472, 2058025392, 1291430526, 424198748, 50039436, 29584100, 3605783033, 2429876329,!
  2791104160, 1057563949, 3255363231, 3075367218, 3463963227, 1!
 46904675
5, 985887462]};
-	function add(x, y) {
-		var sum = (x + y) & 4294967295;
-		if (sum < 0) {
-			sum = -sum;
-			return (65536 * ((sum >> 16) ^ 65535)) + (((sum & 65535) ^ 65535) + 1);
+
+/*	Blowfish
+ *	Created based on the C# implementation by Marcus Hahn (http://www.hotpixel.net/)
+ *	Unsigned math functions derived from Joe Gregorio's SecureSyndication GM script
+ *	http://bitworking.org/projects/securesyndication/
+ *	(Note that this is *not* an adaption of the above script)
+ *
+ *	version 1.0 
+ *	TRT 
+ *	2005-12-08
+ */
+dojo.crypto.Blowfish = new function(){
+	var POW2=Math.pow(2,2);
+	var POW3=Math.pow(2,3);
+	var POW4=Math.pow(2,4);
+	var POW8=Math.pow(2,8);
+	var POW16=Math.pow(2,16);
+	var POW24=Math.pow(2,24);
+	var iv=null;	//	CBC mode initialization vector
+	var boxes={
+		p:[
+			0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 
+			0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 
+			0x9216d5d9, 0x8979fb1b
+		],
+		s0:[
+			0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
+			0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
+			0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
+			0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
+			0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
+			0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
+			0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
+			0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
+			0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
+			0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
+			0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 
+			0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 
+			0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 
+			0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
+			0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
+			0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
+			0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 
+			0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 
+			0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 
+			0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 
+			0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
+			0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 
+			0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
+			0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 
+			0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
+			0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
+			0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
+			0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
+			0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
+			0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
+			0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
+			0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
+		],
+		s1:[
+			0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
+			0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
+			0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
+			0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
+			0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
+			0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
+			0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
+			0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 
+			0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 
+			0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
+			0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 
+			0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
+			0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 
+			0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 
+			0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
+			0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 
+			0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
+			0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 
+			0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
+			0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 
+			0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 
+			0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 
+			0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
+			0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
+			0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 
+			0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
+			0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
+			0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
+			0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
+			0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
+			0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
+			0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
+		],
+		s2:[
+			0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
+			0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
+			0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
+			0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
+			0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
+			0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
+			0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
+			0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
+			0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
+			0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
+			0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
+			0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
+			0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
+			0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
+			0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
+			0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
+			0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
+			0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
+			0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
+			0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
+			0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 
+			0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
+			0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
+			0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 
+			0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 
+			0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 
+			0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 
+			0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
+			0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
+			0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 
+			0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
+			0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
+		],
+		s3:[
+			0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
+			0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
+			0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 
+			0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
+			0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 
+			0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 
+			0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
+			0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 
+			0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 
+			0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 
+			0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
+			0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 
+			0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 
+			0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 
+			0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
+			0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
+			0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 
+			0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
+			0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 
+			0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 
+			0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 
+			0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 
+			0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
+			0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 
+			0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
+			0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 
+			0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 
+			0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 
+			0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 
+			0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
+			0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
+			0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
+		]
+	}
+////////////////////////////////////////////////////////////////////////////
+	function add(x,y){
+		var sum=(x+y)&0xffffffff;
+		if (sum<0){
+			sum=-sum;
+			return (0x10000*((sum>>16)^0xffff))+(((sum&0xffff)^0xffff)+1);
 		}
 		return sum;
 	}
-	function split(x) {
-		var r = x & 4294967295;
-		if (r < 0) {
-			r = -r;
-			return [((r & 65535) ^ 65535) + 1, (r >> 16) ^ 65535];
+	function split(x){
+		var r=x&0xffffffff;
+		if(r<0) {
+			r=-r;
+			return [((r&0xffff)^0xffff)+1,(r>>16)^0xffff];
 		}
-		return [r & 65535, (r >> 16)];
+		return [r&0xffff,(r>>16)];
 	}
-	function xor(x, y) {
-		var xs = split(x);
-		var ys = split(y);
-		return (65536 * (xs[1] ^ ys[1])) + (xs[0] ^ ys[0]);
+	function xor(x,y){
+		var xs=split(x);
+		var ys=split(y);
+		return (0x10000*(xs[1]^ys[1]))+(xs[0]^ys[0]);
 	}
-	function $(v, box) {
-		var d = v & 255;
-		v >>= 8;
-		var c = v & 255;
-		v >>= 8;
-		var b = v & 255;
-		v >>= 8;
-		var a = v & 255;
-		var r = add(box.s0[a], box.s1[b]);
-		r = xor(r, box.s2[c]);
-		return add(r, box.s3[d]);
+	function $(v, box){
+		var d=v&0xff; v>>=8;
+		var c=v&0xff; v>>=8;
+		var b=v&0xff; v>>=8;
+		var a=v&0xff;
+		var r=add(box.s0[a],box.s1[b]);
+		r=xor(r,box.s2[c]);
+		return add(r,box.s3[d]);
 	}
-	function eb(o, box) {
-		var l = o.left;
-		var r = o.right;
-		l = xor(l, box.p[0]);
-		r = xor(r, xor($(l, box), box.p[1]));
-		l = xor(l, xor($(r, box), box.p[2]));
-		r = xor(r, xor($(l, box), box.p[3]));
-		l = xor(l, xor($(r, box), box.p[4]));
-		r = xor(r, xor($(l, box), box.p[5]));
-		l = xor(l, xor($(r, box), box.p[6]));
-		r = xor(r, xor($(l, box), box.p[7]));
-		l = xor(l, xor($(r, box), box.p[8]));
-		r = xor(r, xor($(l, box), box.p[9]));
-		l = xor(l, xor($(r, box), box.p[10]));
-		r = xor(r, xor($(l, box), box.p[11]));
-		l = xor(l, xor($(r, box), box.p[12]));
-		r = xor(r, xor($(l, box), box.p[13]));
-		l = xor(l, xor($(r, box), box.p[14]));
-		r = xor(r, xor($(l, box), box.p[15]));
-		l = xor(l, xor($(r, box), box.p[16]));
-		o.right = l;
-		o.left = xor(r, box.p[17]);
+////////////////////////////////////////////////////////////////////////////
+	function eb(o, box){
+		var l=o.left;
+		var r=o.right;
+		l=xor(l,box.p[0]);
+		r=xor(r,xor($(l,box),box.p[1]));
+		l=xor(l,xor($(r,box),box.p[2]));
+		r=xor(r,xor($(l,box),box.p[3]));
+		l=xor(l,xor($(r,box),box.p[4]));
+		r=xor(r,xor($(l,box),box.p[5]));
+		l=xor(l,xor($(r,box),box.p[6]));
+		r=xor(r,xor($(l,box),box.p[7]));
+		l=xor(l,xor($(r,box),box.p[8]));
+		r=xor(r,xor($(l,box),box.p[9]));
+		l=xor(l,xor($(r,box),box.p[10]));
+		r=xor(r,xor($(l,box),box.p[11]));
+		l=xor(l,xor($(r,box),box.p[12]));
+		r=xor(r,xor($(l,box),box.p[13]));
+		l=xor(l,xor($(r,box),box.p[14]));
+		r=xor(r,xor($(l,box),box.p[15]));
+		l=xor(l,xor($(r,box),box.p[16]));
+		o.right=l;
+		o.left=xor(r,box.p[17]);
 	}
-	function db(o, box) {
-		var l = o.left;
-		var r = o.right;
-		l = xor(l, box.p[17]);
-		r = xor(r, xor($(l, box), box.p[16]));
-		l = xor(l, xor($(r, box), box.p[15]));
-		r = xor(r, xor($(l, box), box.p[14]));
-		l = xor(l, xor($(r, box), box.p[13]));
-		r = xor(r, xor($(l, box), box.p[12]));
-		l = xor(l, xor($(r, box), box.p[11]));
-		r = xor(r, xor($(l, box), box.p[10]));
-		l = xor(l, xor($(r, box), box.p[9]));
-		r = xor(r, xor($(l, box), box.p[8]));
-		l = xor(l, xor($(r, box), box.p[7]));
-		r = xor(r, xor($(l, box), box.p[6]));
-		l = xor(l, xor($(r, box), box.p[5]));
-		r = xor(r, xor($(l, box), box.p[4]));
-		l = xor(l, xor($(r, box), box.p[3]));
-		r = xor(r, xor($(l, box), box.p[2]));
-		l = xor(l, xor($(r, box), box.p[1]));
-		o.right = l;
-		o.left = xor(r, box.p[0]);
+
+	function db(o, box){
+		var l=o.left;
+		var r=o.right;
+		l=xor(l,box.p[17]);
+		r=xor(r,xor($(l,box),box.p[16]));
+		l=xor(l,xor($(r,box),box.p[15]));
+		r=xor(r,xor($(l,box),box.p[14]));
+		l=xor(l,xor($(r,box),box.p[13]));
+		r=xor(r,xor($(l,box),box.p[12]));
+		l=xor(l,xor($(r,box),box.p[11]));
+		r=xor(r,xor($(l,box),box.p[10]));
+		l=xor(l,xor($(r,box),box.p[9]));
+		r=xor(r,xor($(l,box),box.p[8]));
+		l=xor(l,xor($(r,box),box.p[7]));
+		r=xor(r,xor($(l,box),box.p[6]));
+		l=xor(l,xor($(r,box),box.p[5]));
+		r=xor(r,xor($(l,box),box.p[4]));
+		l=xor(l,xor($(r,box),box.p[3]));
+		r=xor(r,xor($(l,box),box.p[2]));
+		l=xor(l,xor($(r,box),box.p[1]));
+		o.right=l;
+		o.left=xor(r,box.p[0]);
 	}
-	function init(key) {
-		var k = key;
-		if (typeof (k) == "string") {
-			var a = [];
-			for (var i = 0; i < k.length; i++) {
-				a.push(k.charCodeAt(i) & 255);
-			}
-			k = a;
+
+	//	Note that we aren't caching contexts here; it might take a little longer
+	//	but we should be more secure this way.
+	function init(key){
+		var k=key;
+		if (typeof(k)=="string"){
+			var a=[];
+			for(var i=0; i<k.length; i++) 
+				a.push(k.charCodeAt(i)&0xff);
+			k=a;
 		}
-		var box = {p:[], s0:[], s1:[], s2:[], s3:[]};
-		for (var i = 0; i < boxes.p.length; i++) {
-			box.p.push(boxes.p[i]);
-		}
-		for (var i = 0; i < boxes.s0.length; i++) {
-			box.s0.push(boxes.s0[i]);
-		}
-		for (var i = 0; i < boxes.s1.length; i++) {
-			box.s1.push(boxes.s1[i]);
-		}
-		for (var i = 0; i < boxes.s2.length; i++) {
-			box.s2.push(boxes.s2[i]);
-		}
-		for (var i = 0; i < boxes.s3.length; i++) {
-			box.s3.push(boxes.s3[i]);
-		}
-		var pos = 0;
-		var data = 0;
-		for (var i = 0; i < box.p.length; i++) {
-			for (var j = 0; j < 4; j++) {
-				data = (data * POW8) | k[pos];
-				if (++pos == k.length) {
-					pos = 0;
-				}
+		//	init the boxes
+		var box = { p:[], s0:[], s1:[], s2:[], s3:[] };
+		for(var i=0; i<boxes.p.length; i++) box.p.push(boxes.p[i]);
+		for(var i=0; i<boxes.s0.length; i++) box.s0.push(boxes.s0[i]);
+		for(var i=0; i<boxes.s1.length; i++) box.s1.push(boxes.s1[i]);
+		for(var i=0; i<boxes.s2.length; i++) box.s2.push(boxes.s2[i]);
+		for(var i=0; i<boxes.s3.length; i++) box.s3.push(boxes.s3[i]);
+
+		//	init p with the key
+		var pos=0;
+		var data=0;
+		for(var i=0; i < box.p.length; i++){
+			for (var j=0; j<4; j++){
+				data = (data*POW8) | k[pos];
+				if(++pos==k.length) pos=0;
 			}
 			box.p[i] = xor(box.p[i], data);
 		}
-		var res = {left:0, right:0};
-		for (var i = 0; i < box.p.length; ) {
+
+		//	encrypt p and the s boxes
+		var res={ left:0, right:0 };
+		for(var i=0; i<box.p.length;){
 			eb(res, box);
-			box.p[i++] = res.left;
-			box.p[i++] = res.right;
+			box.p[i++]=res.left;
+			box.p[i++]=res.right;
 		}
-		for (var i = 0; i < 4; i++) {
-			for (var j = 0; j < box["s" + i].length; ) {
+		for (var i=0; i<4; i++){
+			for(var j=0; j<box["s"+i].length;){
 				eb(res, box);
-				box["s" + i][j++] = res.left;
-				box["s" + i][j++] = res.right;
+				box["s"+i][j++]=res.left;
+				box["s"+i][j++]=res.right;
 			}
 		}
 		return box;
 	}
-	function toBase64(ba) {
-		var p = "=";
-		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-		var s = [];
-		var l = ba.length;
-		var rm = l % 3;
-		var x = l - rm;
-		for (var i = 0; i < x; ) {
-			var t = ba[i++] << 16 | ba[i++] << 8 | ba[i++];
-			s.push(tab.charAt((t >>> 18) & 63));
-			s.push(tab.charAt((t >>> 12) & 63));
-			s.push(tab.charAt((t >>> 6) & 63));
-			s.push(tab.charAt(t & 63));
+
+////////////////////////////////////////////////////////////////////////////
+//	CONVERSION FUNCTIONS
+////////////////////////////////////////////////////////////////////////////
+	//	these operate on byte arrays, NOT word arrays.
+	function toBase64(ba){ 
+		var p="=";
+		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+		var s=[];
+		var count=0;
+		for (var i =0; i<ba.length;){
+			var t=ba[i++]<<16|ba[i++]<<8|ba[i++];
+			s.push(tab.charAt((t>>>18)&0x3f)); 
+			s.push(tab.charAt((t>>>12)&0x3f));
+			s.push(tab.charAt((t>>>6)&0x3f));
+			s.push(tab.charAt(t&0x3f));
+			count+=4;
 		}
-		switch (rm) {
-		  case 2:
-			var t = ba[i++] << 16 | ba[i++] << 8;
-			s.push(tab.charAt((t >>> 18) & 63));
-			s.push(tab.charAt((t >>> 12) & 63));
-			s.push(tab.charAt((t >>> 6) & 63));
-			s.push(p);
-			break;
-		  case 1:
-			var t = ba[i++] << 16;
-			s.push(tab.charAt((t >>> 18) & 63));
-			s.push(tab.charAt((t >>> 12) & 63));
-			s.push(p);
-			s.push(p);
-			break;
-		}
+		var pa=i-ba.length;
+		while((pa--)>0)	s.push(p);	
 		return s.join("");
 	}
-	function fromBase64(str) {
-		var s = str.split("");
-		var p = "=";
-		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-		var out = [];
-		var l = s.length;
-		while (s[--l] == p) {
+	function fromBase64(str){
+		var s=str.split("");
+		var p="=";
+		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+		var out=[];
+		var l=s.length;
+		while(s[--l]==p){ }
+		for (var i=0; i<l;){
+			var t=tab.indexOf(s[i++])<<18|tab.indexOf(s[i++])<<12|tab.indexOf(s[i++])<<6|tab.indexOf(s[i++]);
+			out.push((t>>>16)&0xff);
+			out.push((t>>>8)&0xff);
+			out.push(t&0xff);
 		}
-		for (var i = 0; i < l; ) {
-			var t = tab.indexOf(s[i++]) << 18 | tab.indexOf(s[i++]) << 12 | tab.indexOf(s[i++]) << 6 | tab.indexOf(s[i++]);
-			out.push((t >>> 16) & 255);
-			out.push((t >>> 8) & 255);
-			out.push(t & 255);
-		}
 		return out;
 	}
-	this.getIV = function (outputType) {
-		var out = outputType || dojo.crypto.outputTypes.Base64;
-		switch (out) {
-		  case dojo.crypto.outputTypes.Hex:
-			var s = [];
-			for (var i = 0; i < iv.length; i++) {
-				s.push((iv[i]).toString(16));
+////////////////////////////////////////////////////////////////////////////
+//	PUBLIC FUNCTIONS
+//	0.2: Only supporting ECB mode for now.
+////////////////////////////////////////////////////////////////////////////
+	this.getIV=function(outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				var s=[];
+				for(var i=0; i<iv.length; i++)
+					s.push((iv[i]).toString(16));
+				return s.join("");
 			}
-			return s.join("");
-		  case dojo.crypto.outputTypes.String:
-			return iv.join("");
-		  case dojo.crypto.outputTypes.Raw:
-			return iv;
-		  default:
-			return toBase64(iv);
-		}
-	};
-	this.setIV = function (data, inputType) {
-		var ip = inputType || dojo.crypto.outputTypes.Base64;
-		var ba = null;
-		switch (ip) {
-		  case dojo.crypto.outputTypes.String:
-			ba = [];
-			for (var i = 0; i < data.length; i++) {
-				ba.push(data.charCodeAt(i));
+			case dojo.crypto.outputTypes.String:{
+				return iv.join("");
 			}
-			break;
-		  case dojo.crypto.outputTypes.Hex:
-			ba = [];
-			var i = 0;
-			while (i + 1 < data.length) {
-				ba.push(parseInt(data.substr(i, 2), 16));
-				i += 2;
+			case dojo.crypto.outputTypes.Raw:{
+				return iv;
 			}
-			break;
-		  case dojo.crypto.outputTypes.Raw:
-			ba = data;
-			break;
-		  default:
-			ba = fromBase64(data);
-			break;
+			default:{
+				return toBase64(iv);
+			}
 		}
-		iv = {};
-		iv.left = ba[0] * POW24 | ba[1] * POW16 | ba[2] * POW8 | ba[3];
-		iv.right = ba[4] * POW24 | ba[5] * POW16 | ba[6] * POW8 | ba[7];
 	};
-	this.encrypt = function (plaintext, key, ao) {
-		var out = dojo.crypto.outputTypes.Base64;
-		var mode = dojo.crypto.cipherModes.EBC;
-		if (ao) {
-			if (ao.outputType) {
-				out = ao.outputType;
+	this.setIV=function(data, inputType){
+		var ip=inputType||dojo.crypto.outputTypes.Base64;
+		var ba=null;
+		switch(ip){
+			case dojo.crypto.outputTypes.String:{
+				ba=[];
+				for (var i=0; i<data.length; i++){
+					ba.push(data.charCodeAt(i));
+				}
+				break;
 			}
-			if (ao.cipherMode) {
-				mode = ao.cipherMode;
+			case dojo.crypto.outputTypes.Hex:{
+				ba=[];
+				var i=0;
+				while (i+1<data.length){
+					ba.push(parseInt(data.substr(i,2),16));
+					i+=2;
+				}
+				break;
 			}
+			case dojo.crypto.outputTypes.Raw:{
+				ba=data;
+				break;
+			}
+			default:{
+				ba=fromBase64(data);
+				break;
+			}
 		}
+		//	make it a pair of words now
+		iv={};
+		iv.left=ba[0]*POW24|ba[1]*POW16|ba[2]*POW8|ba[3];
+		iv.right=ba[4]*POW24|ba[5]*POW16|ba[6]*POW8|ba[7];
+	}
+	this.encrypt = function(plaintext, key, ao){
+		var out=dojo.crypto.outputTypes.Base64;
+		var mode=dojo.crypto.cipherModes.EBC;
+		if (ao){
+			if (ao.outputType) out=ao.outputType;
+			if (ao.cipherMode) mode=ao.cipherMode;
+		}
+
 		var bx = init(key);
-		var padding = 8 - (plaintext.length & 7);
-		for (var i = 0; i < padding; i++) {
-			plaintext += String.fromCharCode(padding);
-		}
-		var cipher = [];
-		var count = plaintext.length >> 3;
-		var pos = 0;
-		var o = {};
-		var isCBC = (mode == dojo.crypto.cipherModes.CBC);
-		var vector = {left:iv.left || null, right:iv.right || null};
-		for (var i = 0; i < count; i++) {
-			o.left = plaintext.charCodeAt(pos) * POW24 | plaintext.charCodeAt(pos + 1) * POW16 | plaintext.charCodeAt(pos + 2) * POW8 | plaintext.charCodeAt(pos + 3);
-			o.right = plaintext.charCodeAt(pos + 4) * POW24 | plaintext.charCodeAt(pos + 5) * POW16 | plaintext.charCodeAt(pos + 6) * POW8 | plaintext.charCodeAt(pos + 7);
-			if (isCBC) {
-				o.left = xor(o.left, vector.left);
-				o.right = xor(o.right, vector.right);
+		var padding = 8-(plaintext.length&7);
+		for (var i=0; i<padding; i++) plaintext+=String.fromCharCode(padding);
+		var cipher=[];
+		var count=plaintext.length >> 3;
+		var pos=0;
+		var o={};
+		var isCBC=(mode==dojo.crypto.cipherModes.CBC);
+		var vector={left:iv.left||null, right:iv.right||null};
+		for(var i=0; i<count; i++){
+			o.left=plaintext.charCodeAt(pos)*POW24
+				|plaintext.charCodeAt(pos+1)*POW16
+				|plaintext.charCodeAt(pos+2)*POW8
+				|plaintext.charCodeAt(pos+3);
+			o.right=plaintext.charCodeAt(pos+4)*POW24
+				|plaintext.charCodeAt(pos+5)*POW16
+				|plaintext.charCodeAt(pos+6)*POW8
+				|plaintext.charCodeAt(pos+7);
+
+			if(isCBC){
+				o.left=xor(o.left, vector.left);
+				o.right=xor(o.right, vector.right);
 			}
-			eb(o, bx);
-			if (isCBC) {
-				vector.left = o.left;
-				vector.right = o.right;
-				dojo.crypto.outputTypes.Hex;
+
+			eb(o, bx);	//	encrypt the block
+
+			if(isCBC){
+				vector.left=o.left;
+				vector.right=o.right;dojo.crypto.outputTypes.Hex
 			}
-			cipher.push((o.left >> 24) & 255);
-			cipher.push((o.left >> 16) & 255);
-			cipher.push((o.left >> 8) & 255);
-			cipher.push(o.left & 255);
-			cipher.push((o.right >> 24) & 255);
-			cipher.push((o.right >> 16) & 255);
-			cipher.push((o.right >> 8) & 255);
-			cipher.push(o.right & 255);
-			pos += 8;
+
+			cipher.push((o.left>>24)&0xff); 
+			cipher.push((o.left>>16)&0xff); 
+			cipher.push((o.left>>8)&0xff);
+			cipher.push(o.left&0xff);
+			cipher.push((o.right>>24)&0xff); 
+			cipher.push((o.right>>16)&0xff); 
+			cipher.push((o.right>>8)&0xff);
+			cipher.push(o.right&0xff);
+			pos+=8;
 		}
-		switch (out) {
-		  case dojo.crypto.outputTypes.Hex:
-			var s = [];
-			for (var i = 0; i < cipher.length; i++) {
-				s.push((cipher[i]).toString(16));
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				var s=[];
+				for(var i=0; i<cipher.length; i++)
+					s.push((cipher[i]).toString(16));
+				return s.join("");
 			}
-			return s.join("");
-		  case dojo.crypto.outputTypes.String:
-			return cipher.join("");
-		  case dojo.crypto.outputTypes.Raw:
-			return cipher;
-		  default:
-			return toBase64(cipher);
-		}
-	};
-	this.decrypt = function (ciphertext, key, ao) {
-		var ip = dojo.crypto.outputTypes.Base64;
-		var mode = dojo.crypto.cipherModes.EBC;
-		if (ao) {
-			if (ao.outputType) {
-				ip = ao.outputType;
+			case dojo.crypto.outputTypes.String:{
+				return cipher.join("");
 			}
-			if (ao.cipherMode) {
-				mode = ao.cipherMode;
+			case dojo.crypto.outputTypes.Raw:{
+				return cipher;
 			}
+			default:{
+				return toBase64(cipher);
+			}
 		}
+	};
+
+	this.decrypt = function(ciphertext, key, ao){
+		var ip=dojo.crypto.outputTypes.Base64;
+		var mode=dojo.crypto.cipherModes.EBC;
+		if (ao){
+			if (ao.outputType) ip=ao.outputType;
+			if (ao.cipherMode) mode=ao.cipherMode;
+		}
 		var bx = init(key);
-		var pt = [];
-		var c = null;
-		switch (ip) {
-		  case dojo.crypto.outputTypes.Hex:
-			c = [];
-			var i = 0;
-			while (i + 1 < ciphertext.length) {
-				c.push(parseInt(ciphertext.substr(i, 2), 16));
-				i += 2;
+		var pt=[];
+	
+		var c=null;
+		switch(ip){
+			case dojo.crypto.outputTypes.Hex:{
+				c=[];
+				var i=0;
+				while (i+1<ciphertext.length){
+					c.push(parseInt(ciphertext.substr(i,2),16));
+					i+=2;
+				}
+				break;
 			}
-			break;
-		  case dojo.crypto.outputTypes.String:
-			c = [];
-			for (var i = 0; i < ciphertext.length; i++) {
-				c.push(ciphertext.charCodeAt(i));
+			case dojo.crypto.outputTypes.String:{
+				c=[];
+				for (var i=0; i<ciphertext.length; i++){
+					c.push(ciphertext.charCodeAt(i));
+				}
+				break;
 			}
-			break;
-		  case dojo.crypto.outputTypes.Raw:
-			c = ciphertext;
-			break;
-		  default:
-			c = fromBase64(ciphertext);
-			break;
+			case dojo.crypto.outputTypes.Raw:{
+				c=ciphertext;	//	should be a byte array
+				break;
+			}
+			default:{
+				c=fromBase64(ciphertext);
+				break;
+			}
 		}
-		var count = c.length >> 3;
-		var pos = 0;
-		var o = {};
-		var isCBC = (mode == dojo.crypto.cipherModes.CBC);
-		var vector = {left:iv.left || null, right:iv.right || null};
-		for (var i = 0; i < count; i++) {
-			o.left = c[pos] * POW24 | c[pos + 1] * POW16 | c[pos + 2] * POW8 | c[pos + 3];
-			o.right = c[pos + 4] * POW24 | c[pos + 5] * POW16 | c[pos + 6] * POW8 | c[pos + 7];
-			if (isCBC) {
-				var left = o.left;
-				var right = o.right;
+
+		var count=c.length >> 3;
+		var pos=0;
+		var o={};
+		var isCBC=(mode==dojo.crypto.cipherModes.CBC);
+		var vector={left:iv.left||null, right:iv.right||null};
+		for(var i=0; i<count; i++){
+			o.left=c[pos]*POW24|c[pos+1]*POW16|c[pos+2]*POW8|c[pos+3];
+			o.right=c[pos+4]*POW24|c[pos+5]*POW16|c[pos+6]*POW8|c[pos+7];
+
+			if(isCBC){
+				var left=o.left;
+				var right=o.right;
 			}
-			db(o, bx);
-			if (isCBC) {
-				o.left = xor(o.left, vector.left);
-				o.right = xor(o.right, vector.right);
-				vector.left = left;
-				vector.right = right;
+
+			db(o, bx);	//	decrypt the block
+
+			if(isCBC){
+				o.left=xor(o.left, vector.left);
+				o.right=xor(o.right, vector.right);
+				vector.left=left;
+				vector.right=right;
 			}
-			pt.push((o.left >> 24) & 255);
-			pt.push((o.left >> 16) & 255);
-			pt.push((o.left >> 8) & 255);
-			pt.push(o.left & 255);
-			pt.push((o.right >> 24) & 255);
-			pt.push((o.right >> 16) & 255);
-			pt.push((o.right >> 8) & 255);
-			pt.push(o.right & 255);
-			pos += 8;
+
+			pt.push((o.left>>24)&0xff);
+			pt.push((o.left>>16)&0xff);
+			pt.push((o.left>>8)&0xff);
+			pt.push(o.left&0xff);
+			pt.push((o.right>>24)&0xff);
+			pt.push((o.right>>16)&0xff);
+			pt.push((o.right>>8)&0xff);
+			pt.push(o.right&0xff);
+			pos+=8;
 		}
-		if (pt[pt.length - 1] == pt[pt.length - 2] || pt[pt.length - 1] == 1) {
-			var n = pt[pt.length - 1];
-			pt.splice(pt.length - n, n);
+
+		//	check for padding, and remove.
+		if(pt[pt.length-1]==pt[pt.length-2]||pt[pt.length-1]==0x01){
+			var n=pt[pt.length-1];
+			pt.splice(pt.length-n, n);
 		}
-		for (var i = 0; i < pt.length; i++) {
-			pt[i] = String.fromCharCode(pt[i]);
-		}
+
+		//	convert to string
+		for(var i=0; i<pt.length; i++)
+			pt[i]=String.fromCharCode(pt[i]);
 		return pt.join("");
 	};
+
 	this.setIV("0000000000000000", dojo.crypto.outputTypes.Hex);
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/crypto/MD5.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto/MD5.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto/MD5.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,198 +1,193 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
 dojo.require("dojo.crypto");
 dojo.provide("dojo.crypto.MD5");
-dojo.crypto.MD5 = new function () {
-	var chrsz = 8;
-	var mask = (1 << chrsz) - 1;
+
+/*	Return to a port of Paul Johnstone's MD5 implementation
+ *	http://pajhome.org.uk/crypt/md5/index.html
+ *
+ *	Copyright (C) Paul Johnston 1999 - 2002.
+ *	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
+ * 	Distributed under the BSD License
+ *
+ *	Dojo port by Tom Trenka
+ *
+ *	2005-12-7
+ *	All conversions are internalized (no dependencies)
+ *	implemented getHMAC for message digest auth.
+ */
+dojo.crypto.MD5 = new function(){
+	var chrsz=8;
+	var mask=(1<<chrsz)-1;
 	function toWord(s) {
-		var wa = [];
-		for (var i = 0; i < s.length * chrsz; i += chrsz) {
-			wa[i >> 5] |= (s.charCodeAt(i / chrsz) & mask) << (i % 32);
-		}
-		return wa;
+	  var wa=[];
+	  for(var i=0; i<s.length*chrsz; i+=chrsz)
+		wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
+	  return wa;
 	}
-	function toString(wa) {
-		var s = [];
-		for (var i = 0; i < wa.length * 32; i += chrsz) {
-			s.push(String.fromCharCode((wa[i >> 5] >>> (i % 32)) & mask));
-		}
+	function toString(wa){
+		var s=[];
+		for(var i=0; i<wa.length*32; i+=chrsz)
+			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
 		return s.join("");
 	}
 	function toHex(wa) {
-		var h = "0123456789abcdef";
-		var s = [];
-		for (var i = 0; i < wa.length * 4; i++) {
-			s.push(h.charAt((wa[i >> 2] >> ((i % 4) * 8 + 4)) & 15) + h.charAt((wa[i >> 2] >> ((i % 4) * 8)) & 15));
+		var h="0123456789abcdef";
+		var s=[];
+		for(var i=0; i<wa.length*4; i++){
+			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
 		}
 		return s.join("");
 	}
-	function toBase64(wa) {
-		var p = "=";
-		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-		var s = [];
-		for (var i = 0; i < wa.length * 4; i += 3) {
-			var t = (((wa[i >> 2] >> 8 * (i % 4)) & 255) << 16) | (((wa[i + 1 >> 2] >> 8 * ((i + 1) % 4)) & 255) << 8) | ((wa[i + 2 >> 2] >> 8 * ((i + 2) % 4)) & 255);
-			for (var j = 0; j < 4; j++) {
-				if (i * 8 + j * 6 > wa.length * 32) {
-					s.push(p);
-				} else {
-					s.push(tab.charAt((t >> 6 * (3 - j)) & 63));
-				}
+	function toBase64(wa){
+		var p="=";
+		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+		var s=[];
+		for(var i=0; i<wa.length*4; i+=3){
+			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
+			for(var j=0; j<4; j++){
+				if(i*8+j*6>wa.length*32) s.push(p);
+				else s.push(tab.charAt((t>>6*(3-j))&0x3F));
 			}
 		}
 		return s.join("");
 	}
-	function add(x, y) {
-		var l = (x & 65535) + (y & 65535);
-		var m = (x >> 16) + (y >> 16) + (l >> 16);
-		return (m << 16) | (l & 65535);
+	function add(x,y) {
+		var l=(x&0xFFFF)+(y&0xFFFF);
+		var m=(x>>16)+(y>>16)+(l>>16);
+		return (m<<16)|(l&0xFFFF);
 	}
-	function R(n, c) {
-		return (n << c) | (n >>> (32 - c));
-	}
-	function C(q, a, b, x, s, t) {
-		return add(R(add(add(a, q), add(x, t)), s), b);
-	}
-	function FF(a, b, c, d, x, s, t) {
-		return C((b & c) | ((~b) & d), a, b, x, s, t);
-	}
-	function GG(a, b, c, d, x, s, t) {
-		return C((b & d) | (c & (~d)), a, b, x, s, t);
-	}
-	function HH(a, b, c, d, x, s, t) {
-		return C(b ^ c ^ d, a, b, x, s, t);
-	}
-	function II(a, b, c, d, x, s, t) {
-		return C(c ^ (b | (~d)), a, b, x, s, t);
-	}
-	function core(x, len) {
-		x[len >> 5] |= 128 << ((len) % 32);
-		x[(((len + 64) >>> 9) << 4) + 14] = len;
-		var a = 1732584193;
-		var b = -271733879;
-		var c = -1732584194;
-		var d = 271733878;
-		for (var i = 0; i < x.length; i += 16) {
-			var olda = a;
-			var oldb = b;
-			var oldc = c;
-			var oldd = d;
-			a = FF(a, b, c, d, x[i + 0], 7, -680876936);
-			d = FF(d, a, b, c, x[i + 1], 12, -389564586);
-			c = FF(c, d, a, b, x[i + 2], 17, 606105819);
-			b = FF(b, c, d, a, x[i + 3], 22, -1044525330);
-			a = FF(a, b, c, d, x[i + 4], 7, -176418897);
-			d = FF(d, a, b, c, x[i + 5], 12, 1200080426);
-			c = FF(c, d, a, b, x[i + 6], 17, -1473231341);
-			b = FF(b, c, d, a, x[i + 7], 22, -45705983);
-			a = FF(a, b, c, d, x[i + 8], 7, 1770035416);
-			d = FF(d, a, b, c, x[i + 9], 12, -1958414417);
-			c = FF(c, d, a, b, x[i + 10], 17, -42063);
-			b = FF(b, c, d, a, x[i + 11], 22, -1990404162);
-			a = FF(a, b, c, d, x[i + 12], 7, 1804603682);
-			d = FF(d, a, b, c, x[i + 13], 12, -40341101);
-			c = FF(c, d, a, b, x[i + 14], 17, -1502002290);
-			b = FF(b, c, d, a, x[i + 15], 22, 1236535329);
-			a = GG(a, b, c, d, x[i + 1], 5, -165796510);
-			d = GG(d, a, b, c, x[i + 6], 9, -1069501632);
-			c = GG(c, d, a, b, x[i + 11], 14, 643717713);
-			b = GG(b, c, d, a, x[i + 0], 20, -373897302);
-			a = GG(a, b, c, d, x[i + 5], 5, -701558691);
-			d = GG(d, a, b, c, x[i + 10], 9, 38016083);
-			c = GG(c, d, a, b, x[i + 15], 14, -660478335);
-			b = GG(b, c, d, a, x[i + 4], 20, -405537848);
-			a = GG(a, b, c, d, x[i + 9], 5, 568446438);
-			d = GG(d, a, b, c, x[i + 14], 9, -1019803690);
-			c = GG(c, d, a, b, x[i + 3], 14, -187363961);
-			b = GG(b, c, d, a, x[i + 8], 20, 1163531501);
-			a = GG(a, b, c, d, x[i + 13], 5, -1444681467);
-			d = GG(d, a, b, c, x[i + 2], 9, -51403784);
-			c = GG(c, d, a, b, x[i + 7], 14, 1735328473);
-			b = GG(b, c, d, a, x[i + 12], 20, -1926607734);
-			a = HH(a, b, c, d, x[i + 5], 4, -378558);
-			d = HH(d, a, b, c, x[i + 8], 11, -2022574463);
-			c = HH(c, d, a, b, x[i + 11], 16, 1839030562);
-			b = HH(b, c, d, a, x[i + 14], 23, -35309556);
-			a = HH(a, b, c, d, x[i + 1], 4, -1530992060);
-			d = HH(d, a, b, c, x[i + 4], 11, 1272893353);
-			c = HH(c, d, a, b, x[i + 7], 16, -155497632);
-			b = HH(b, c, d, a, x[i + 10], 23, -1094730640);
-			a = HH(a, b, c, d, x[i + 13], 4, 681279174);
-			d = HH(d, a, b, c, x[i + 0], 11, -358537222);
-			c = HH(c, d, a, b, x[i + 3], 16, -722521979);
-			b = HH(b, c, d, a, x[i + 6], 23, 76029189);
-			a = HH(a, b, c, d, x[i + 9], 4, -640364487);
-			d = HH(d, a, b, c, x[i + 12], 11, -421815835);
-			c = HH(c, d, a, b, x[i + 15], 16, 530742520);
-			b = HH(b, c, d, a, x[i + 2], 23, -995338651);
-			a = II(a, b, c, d, x[i + 0], 6, -198630844);
-			d = II(d, a, b, c, x[i + 7], 10, 1126891415);
-			c = II(c, d, a, b, x[i + 14], 15, -1416354905);
-			b = II(b, c, d, a, x[i + 5], 21, -57434055);
-			a = II(a, b, c, d, x[i + 12], 6, 1700485571);
-			d = II(d, a, b, c, x[i + 3], 10, -1894986606);
-			c = II(c, d, a, b, x[i + 10], 15, -1051523);
-			b = II(b, c, d, a, x[i + 1], 21, -2054922799);
-			a = II(a, b, c, d, x[i + 8], 6, 1873313359);
-			d = II(d, a, b, c, x[i + 15], 10, -30611744);
-			c = II(c, d, a, b, x[i + 6], 15, -1560198380);
-			b = II(b, c, d, a, x[i + 13], 21, 1309151649);
-			a = II(a, b, c, d, x[i + 4], 6, -145523070);
-			d = II(d, a, b, c, x[i + 11], 10, -1120210379);
-			c = II(c, d, a, b, x[i + 2], 15, 718787259);
-			b = II(b, c, d, a, x[i + 9], 21, -343485551);
-			a = add(a, olda);
-			b = add(b, oldb);
-			c = add(c, oldc);
-			d = add(d, oldd);
+	function R(n,c){ return (n<<c)|(n>>>(32-c)); }
+	function C(q,a,b,x,s,t){ return add(R(add(add(a,q),add(x,t)),s),b); }
+	function FF(a,b,c,d,x,s,t){ return C((b&c)|((~b)&d),a,b,x,s,t); }
+	function GG(a,b,c,d,x,s,t){ return C((b&d)|(c&(~d)),a,b,x,s,t); }
+	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
+	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }
+	function core(x,len){
+		x[len>>5]|=0x80<<((len)%32);
+		x[(((len+64)>>>9)<<4)+14]=len;
+		var a= 1732584193;
+		var b=-271733879;
+		var c=-1732584194;
+		var d= 271733878;
+		for(var i=0; i<x.length; i+=16){
+			var olda=a;
+			var oldb=b;
+			var oldc=c;
+			var oldd=d;
+
+			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
+			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
+			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
+			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
+			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
+			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
+			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
+			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
+			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
+			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
+			c=FF(c,d,a,b,x[i+10],17,-42063);
+			b=FF(b,c,d,a,x[i+11],22,-1990404162);
+			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
+			d=FF(d,a,b,c,x[i+13],12,-40341101);
+			c=FF(c,d,a,b,x[i+14],17,-1502002290);
+			b=FF(b,c,d,a,x[i+15],22, 1236535329);
+
+			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
+			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
+			c=GG(c,d,a,b,x[i+11],14, 643717713);
+			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
+			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
+			d=GG(d,a,b,c,x[i+10],9 , 38016083);
+			c=GG(c,d,a,b,x[i+15],14,-660478335);
+			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
+			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
+			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
+			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
+			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
+			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
+			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
+			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
+			b=GG(b,c,d,a,x[i+12],20,-1926607734);
+
+			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
+			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
+			c=HH(c,d,a,b,x[i+11],16, 1839030562);
+			b=HH(b,c,d,a,x[i+14],23,-35309556);
+			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
+			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
+			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
+			b=HH(b,c,d,a,x[i+10],23,-1094730640);
+			a=HH(a,b,c,d,x[i+13],4 , 681279174);
+			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
+			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
+			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
+			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
+			d=HH(d,a,b,c,x[i+12],11,-421815835);
+			c=HH(c,d,a,b,x[i+15],16, 530742520);
+			b=HH(b,c,d,a,x[i+ 2],23,-995338651);
+
+			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
+			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
+			c=II(c,d,a,b,x[i+14],15,-1416354905);
+			b=II(b,c,d,a,x[i+ 5],21,-57434055);
+			a=II(a,b,c,d,x[i+12],6 , 1700485571);
+			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
+			c=II(c,d,a,b,x[i+10],15,-1051523);
+			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
+			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
+			d=II(d,a,b,c,x[i+15],10,-30611744);
+			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
+			b=II(b,c,d,a,x[i+13],21, 1309151649);
+			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
+			d=II(d,a,b,c,x[i+11],10,-1120210379);
+			c=II(c,d,a,b,x[i+ 2],15, 718787259);
+			b=II(b,c,d,a,x[i+ 9],21,-343485551);
+
+			a = add(a,olda);
+			b = add(b,oldb);
+			c = add(c,oldc);
+			d = add(d,oldd);
 		}
-		return [a, b, c, d];
+		return [a,b,c,d];
 	}
-	function hmac(data, key) {
-		var wa = toWord(key);
-		if (wa.length > 16) {
-			wa = core(wa, key.length * chrsz);
+	function hmac(data,key){
+		var wa=toWord(key);
+		if(wa.length>16) wa=core(wa,key.length*chrsz);
+		var l=[], r=[];
+		for(var i=0; i<16; i++){
+			l[i]=wa[i]^0x36363636;
+			r[i]=wa[i]^0x5c5c5c5c;
 		}
-		var l = [], r = [];
-		for (var i = 0; i < 16; i++) {
-			l[i] = wa[i] ^ 909522486;
-			r[i] = wa[i] ^ 1549556828;
-		}
-		var h = core(l.concat(toWord(data)), 512 + data.length * chrsz);
-		return core(r.concat(h), 640);
+		var h=core(l.concat(toWord(data)),512+data.length*chrsz);
+		return core(r.concat(h),640);
 	}
-	this.compute = function (data, outputType) {
-		var out = outputType || dojo.crypto.outputTypes.Base64;
-		switch (out) {
-		  case dojo.crypto.outputTypes.Hex:
-			return toHex(core(toWord(data), data.length * chrsz));
-		  case dojo.crypto.outputTypes.String:
-			return toString(core(toWord(data), data.length * chrsz));
-		  default:
-			return toBase64(core(toWord(data), data.length * chrsz));
+
+	//	Public functions
+	this.compute=function(data,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(core(toWord(data),data.length*chrsz));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(core(toWord(data),data.length*chrsz));
+			}
+			default:{
+				return toBase64(core(toWord(data),data.length*chrsz));
+			}
 		}
 	};
-	this.getHMAC = function (data, key, outputType) {
-		var out = outputType || dojo.crypto.outputTypes.Base64;
-		switch (out) {
-		  case dojo.crypto.outputTypes.Hex:
-			return toHex(hmac(data, key));
-		  case dojo.crypto.outputTypes.String:
-			return toString(hmac(data, key));
-		  default:
-			return toBase64(hmac(data, key));
+	this.getHMAC=function(data,key,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(hmac(data,key));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(hmac(data,key));
+			}
+			default:{
+				return toBase64(hmac(data,key));
+			}
 		}
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/crypto/Rijndael.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto/Rijndael.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto/Rijndael.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,16 +8,15 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.crypto.Rijndael");
 dojo.require("dojo.crypto");
 dojo.require("dojo.experimental");
+
 dojo.experimental("dojo.crypto.Rijndael");
-dojo.crypto.Rijndael = new function () {
-	this.encrypt = function (plaintext, key) {
+
+dojo.crypto.Rijndael = new function(){
+	this.encrypt=function(plaintext, key){
 	};
-	this.decrypt = function (ciphertext, key) {
+	this.decrypt=function(ciphertext, key){
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/crypto/SHA1.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto/SHA1.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto/SHA1.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,171 +1,154 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
 dojo.require("dojo.crypto");
 dojo.provide("dojo.crypto.SHA1");
 dojo.require("dojo.experimental");
+
+/*
+ *	A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
+ *	in FIPS PUB 180-1
+ *
+ * 	Version 2.1a Copyright Paul Johnston 2000 - 2002.
+ * 	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
+ * 	Distributed under the BSD License
+ * 	See http://pajhome.org.uk/crypt/md5 for details.
+ *
+ *	Dojo port by Tom Trenka
+ */
 dojo.experimental("dojo.crypto.SHA1");
-dojo.crypto.SHA1 = new function () {
-	var chrsz = 8;
-	var mask = (1 << chrsz) - 1;
+
+dojo.crypto.SHA1 = new function(){
+	var chrsz=8;
+	var mask=(1<<chrsz)-1;
 	function toWord(s) {
-		var wa = [];
-		for (var i = 0; i < s.length * chrsz; i += chrsz) {
-			wa[i >> 5] |= (s.charCodeAt(i / chrsz) & mask) << (i % 32);
-		}
-		return wa;
+	  var wa=[];
+	  for(var i=0; i<s.length*chrsz; i+=chrsz)
+		wa[i>>5]|=(s.charCodeAt(i/chrsz)&mask)<<(i%32);
+	  return wa;
 	}
-	function toString(wa) {
-		var s = [];
-		for (var i = 0; i < wa.length * 32; i += chrsz) {
-			s.push(String.fromCharCode((wa[i >> 5] >>> (i % 32)) & mask));
-		}
+	function toString(wa){
+		var s=[];
+		for(var i=0; i<wa.length*32; i+=chrsz)
+			s.push(String.fromCharCode((wa[i>>5]>>>(i%32))&mask));
 		return s.join("");
 	}
 	function toHex(wa) {
-		var h = "0123456789abcdef";
-		var s = [];
-		for (var i = 0; i < wa.length * 4; i++) {
-			s.push(h.charAt((wa[i >> 2] >> ((i % 4) * 8 + 4)) & 15) + h.charAt((wa[i >> 2] >> ((i % 4) * 8)) & 15));
+		var h="0123456789abcdef";
+		var s=[];
+		for(var i=0; i<wa.length*4; i++){
+			s.push(h.charAt((wa[i>>2]>>((i%4)*8+4))&0xF)+h.charAt((wa[i>>2]>>((i%4)*8))&0xF));
 		}
 		return s.join("");
 	}
-	function toBase64(wa) {
-		var p = "=";
-		var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-		var s = [];
-		for (var i = 0; i < wa.length * 4; i += 3) {
-			var t = (((wa[i >> 2] >> 8 * (i % 4)) & 255) << 16) | (((wa[i + 1 >> 2] >> 8 * ((i + 1) % 4)) & 255) << 8) | ((wa[i + 2 >> 2] >> 8 * ((i + 2) % 4)) & 255);
-			for (var j = 0; j < 4; j++) {
-				if (i * 8 + j * 6 > wa.length * 32) {
-					s.push(p);
-				} else {
-					s.push(tab.charAt((t >> 6 * (3 - j)) & 63));
-				}
+	function toBase64(wa){
+		var p="=";
+		var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+		var s=[];
+		for(var i=0; i<wa.length*4; i+=3){
+			var t=(((wa[i>>2]>>8*(i%4))&0xFF)<<16)|(((wa[i+1>>2]>>8*((i+1)%4))&0xFF)<<8)|((wa[i+2>>2]>>8*((i+2)%4))&0xFF);
+			for(var j=0; j<4; j++){
+				if(i*8+j*6>wa.length*32) s.push(p);
+				else s.push(tab.charAt((t>>6*(3-j))&0x3F));
 			}
 		}
 		return s.join("");
 	}
-	function add(x, y) {
-		var l = (x & 65535) + (y & 65535);
-		var m = (x >> 16) + (y >> 16) + (l >> 16);
-		return (m << 16) | (l & 65535);
+
+	//	math
+	function add(x,y){
+		var l=(x&0xffff)+(y&0xffff);
+		var m=(x>>16)+(y>>16)+(l>>16);
+		return (m<<16)|(l&0xffff);
 	}
-	function r(x, n) {
-		return (x << n) | (x >>> (32 - n));
+	function r(x,n){  return (x<<n)|(x>>>(32-n)); }
+	
+	//	SHA rounds
+	function f(u,v,w){ return ((u&v)|(~u&w)); }
+	function g(u,v,w){ return ((u&v)|(u&w)|(v&w)); }
+	function h(u,v,w){ return (u^v^w); }
+	
+	function fn(i,u,v,w){
+		if(i<20) return f(u,v,w);
+		if(i<40) return h(u,v,w);
+		if(i<60) return g(u,v,w);
+		return h(u,v,w);
 	}
-	function f(u, v, w) {
-		return ((u & v) | (~u & w));
-	}
-	function g(u, v, w) {
-		return ((u & v) | (u & w) | (v & w));
-	}
-	function h(u, v, w) {
-		return (u ^ v ^ w);
-	}
-	function fn(i, u, v, w) {
-		if (i < 20) {
-			return f(u, v, w);
-		}
-		if (i < 40) {
-			return h(u, v, w);
-		}
-		if (i < 60) {
-			return g(u, v, w);
-		}
-		return h(u, v, w);
-	}
-	function cnst(i) {
-		if (i < 20) {
-			return 1518500249;
-		}
-		if (i < 40) {
-			return 1859775393;
-		}
-		if (i < 60) {
-			return -1894007588;
-		}
+	function cnst(i){
+		if(i<20) return 1518500249;
+		if(i<40) return 1859775393;
+		if(i<60) return -1894007588;
 		return -899497514;
 	}
-	function core(x, len) {
-		x[len >> 5] |= 128 << (24 - len % 32);
-		x[((len + 64 >> 9) << 4) + 15] = len;
-		var w = [];
-		var a = 1732584193;
-		var b = -271733879;
-		var c = -1732584194;
-		var d = 271733878;
-		var e = -1009589776;
-		for (var i = 0; i < x.length; i += 16) {
-			var olda = a;
-			var oldb = b;
-			var oldc = c;
-			var oldd = d;
-			var olde = e;
-			for (var j = 0; j < 80; j++) {
-				if (j < 16) {
-					w[j] = x[i + j];
-				} else {
-					w[j] = r(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
-				}
-				var t = add(add(r(a, 5), fn(j, b, c, d)), add(add(e, w[j]), cnst(j)));
-				e = d;
-				d = c;
-				c = r(b, 30);
-				b = a;
-				a = t;
+
+	function core(x,len){
+		x[len>>5]|=0x80<<(24-len%32);
+		x[((len+64>>9)<<4)+15]=len;
+
+		var w=[];
+		var a= 1732584193;		//	0x67452301
+		var b=-271733879;		//	0xefcdab89
+		var c=-1732584194;		//	0x98badcfe
+		var d= 271733878;		//	0x10325476
+		var e=-1009589776;		//	0xc3d2e1f0
+		
+		for(var i=0; i<x.length; i+=16){
+			var olda=a;
+			var oldb=b;
+			var oldc=c;
+			var oldd=d;
+			var olde=e;
+
+			for(var j=0; j<80; j++){
+				if(j<16) w[j]=x[i+j];
+				else w[j]=r(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);
+				var t=add(add(r(a,5),fn(j,b,c,d)),add(add(e,w[j]),cnst(j)));
+				e=d; d=c; c=r(b,30); b=a; a=t;
 			}
-			a = add(a, olda);
-			b = add(b, oldb);
-			c = add(c, oldc);
-			d = add(d, oldd);
-			e = add(e, olde);
+
+			a=add(a,olda);
+			b=add(b,oldb);
+			c=add(c,oldc);
+			d=add(d,oldd);
+			e=add(e,olde);
 		}
-		return [a, b, c, d, e];
+		return [a,b,c,d,e];
 	}
-	function hmac(data, key) {
-		var wa = toWord(key);
-		if (wa.length > 16) {
-			wa = core(wa, key.length * chrsz);
+	function hmac(data,key){
+		var wa=toWord(key);
+		if(wa.length>16) wa=core(wa,key.length*chrsz);
+		var l=[], r=[];
+		for(var i=0; i<16; i++){
+			l[i]=wa[i]^0x36363636;
+			r[i]=wa[i]^0x5c5c5c5c;
 		}
-		var l = [], r = [];
-		for (var i = 0; i < 16; i++) {
-			l[i] = wa[i] ^ 909522486;
-			r[i] = wa[i] ^ 1549556828;
-		}
-		var h = core(l.concat(toWord(data)), 512 + data.length * chrsz);
-		return core(r.concat(h), 640);
+		var h=core(l.concat(toWord(data)),512+data.length*chrsz);
+		return core(r.concat(h),640);
 	}
-	this.compute = function (data, outputType) {
-		var out = outputType || dojo.crypto.outputTypes.Base64;
-		switch (out) {
-		  case dojo.crypto.outputTypes.Hex:
-			return toHex(core(toWord(data), data.length * chrsz));
-		  case dojo.crypto.outputTypes.String:
-			return toString(core(toWord(data), data.length * chrsz));
-		  default:
-			return toBase64(core(toWord(data), data.length * chrsz));
+
+	this.compute=function(data,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(core(toWord(data),data.length*chrsz));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(core(toWord(data),data.length*chrsz));
+			}
+			default:{
+				return toBase64(core(toWord(data),data.length*chrsz));
+			}
 		}
 	};
-	this.getHMAC = function (data, key, outputType) {
-		var out = outputType || dojo.crypto.outputTypes.Base64;
-		switch (out) {
-		  case dojo.crypto.outputTypes.Hex:
-			return toHex(hmac(data, key));
-		  case dojo.crypto.outputTypes.String:
-			return toString(hmac(data, key));
-		  default:
-			return toBase64(hmac(data, key));
+	this.getHMAC=function(data,key,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(hmac(data,key));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(hmac(data,key));
+			}
+			default:{
+				return toBase64(hmac(data,key));
+			}
 		}
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/crypto/SHA256.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto/SHA256.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto/SHA256.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,14 +8,13 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.crypto.SHA256");
 dojo.require("dojo.crypto");
 dojo.require("dojo.experimental");
+
 dojo.experimental("dojo.crypto.SHA256");
-dojo.crypto.SHA256 = new function () {
-	this.compute = function (s) {
+
+dojo.crypto.SHA256 = new function(){
+	this.compute=function(s){
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/crypto/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,10 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.crypto", "dojo.crypto.MD5"]});
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.crypto",
+		"dojo.crypto.MD5"
+	]
+});
 dojo.provide("dojo.crypto.*");
-

Modified: tags/parley-0.53/root/static/magic/src/crypto.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/crypto.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/crypto.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,8 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.crypto");
-dojo.crypto.cipherModes = {ECB:0, CBC:1, PCBC:2, CFB:3, OFB:4, CTR:5};
-dojo.crypto.outputTypes = {Base64:0, Hex:1, String:2, Raw:3};
 
+//	enumerations for use in crypto code. Note that 0 == default, for the most part.
+dojo.crypto.cipherModes={ ECB:0, CBC:1, PCBC:2, CFB:3, OFB:4, CTR:5 };
+dojo.crypto.outputTypes={ Base64:0,Hex:1,String:2,Raw:3 };

Added: tags/parley-0.53/root/static/magic/src/data/Attribute.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/Attribute.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/Attribute.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,62 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.Attribute");
+dojo.require("dojo.data.Item");
+dojo.require("dojo.lang.assert");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Attribute = function(/* dojo.data.provider.Base */ dataProvider, /* string */ attributeId) {
+	/**
+	 * summary:
+	 * An Attribute object represents something like a column in 
+	 * a relational database.
+	 */
+	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, "optional"]);
+	dojo.lang.assertType(attributeId, String);
+	dojo.data.Item.call(this, dataProvider);
+	this._attributeId = attributeId;
+};
+dojo.inherits(dojo.data.Attribute, dojo.data.Item);
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Attribute.prototype.toString = function() {
+	return this._attributeId; // string
+};
+
+dojo.data.Attribute.prototype.getAttributeId = function() {
+	/**
+	 * summary: 
+	 * Returns the string token that uniquely identifies this
+	 * attribute within the context of a data provider.
+	 * For a data provider that accesses relational databases,
+	 * typical attributeIds might be tokens like "name", "age", 
+	 * "ssn", or "dept_key".
+	 */ 
+	return this._attributeId; // string
+};
+
+dojo.data.Attribute.prototype.getType = function() {
+	/**
+	 * summary: Returns the data type of the values of this attribute.
+	 */ 
+	return this.get('type'); // dojo.data.Type or null
+};
+
+dojo.data.Attribute.prototype.setType = function(/* dojo.data.Type or null */ type) {
+	/**
+	 * summary: Sets the data type for this attribute.
+	 */ 
+	this.set('type', type);
+};

Deleted: tags/parley-0.53/root/static/magic/src/data/CsvStore.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/CsvStore.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/CsvStore.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,115 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.data.CsvStore");
-dojo.require("dojo.data.core.RemoteStore");
-dojo.require("dojo.lang.assert");
-dojo.declare("dojo.data.CsvStore", dojo.data.core.RemoteStore, {_setupQueryRequest:function (result, requestKw) {
-	var serverQueryUrl = this._serverQueryUrl ? this._serverQueryUrl : "";
-	var queryUrl = result.query ? result.query : "";
-	requestKw.url = serverQueryUrl + queryUrl;
-	requestKw.method = "get";
-}, _resultToQueryData:function (serverResponseData) {
-	var csvFileContentString = serverResponseData;
-	var arrayOfArrays = this._getArrayOfArraysFromCsvFileContents(csvFileContentString);
-	var arrayOfObjects = this._getArrayOfObjectsFromArrayOfArrays(arrayOfArrays);
-	var remoteStoreData = this._getRemoteStoreDataFromArrayOfObjects(arrayOfObjects);
-	return remoteStoreData;
-}, _setupSaveRequest:function (saveKeywordArgs, requestKw) {
-}, _getArrayOfArraysFromCsvFileContents:function (csvFileContents) {
-	dojo.lang.assertType(csvFileContents, String);
-	var lineEndingCharacters = new RegExp("\r\n|\n|\r");
-	var leadingWhiteSpaceCharacters = new RegExp("^\\s+", "g");
-	var trailingWhiteSpaceCharacters = new RegExp("\\s+$", "g");
-	var doubleQuotes = new RegExp("\"\"", "g");
-	var arrayOfOutputRecords = [];
-	var arrayOfInputLines = csvFileContents.split(lineEndingCharacters);
-	for (var i in arrayOfInputLines) {
-		var singleLine = arrayOfInputLines[i];
-		if (singleLine.length > 0) {
-			var listOfFields = singleLine.split(",");
-			var j = 0;
-			while (j < listOfFields.length) {
-				var space_field_space = listOfFields[j];
-				var field_space = space_field_space.replace(leadingWhiteSpaceCharacters, "");
-				var field = field_space.replace(trailingWhiteSpaceCharacters, "");
-				var firstChar = field.charAt(0);
-				var lastChar = field.charAt(field.length - 1);
-				var secondToLastChar = field.charAt(field.length - 2);
-				var thirdToLastChar = field.charAt(field.length - 3);
-				if ((firstChar == "\"") && ((lastChar != "\"") || ((lastChar == "\"") && (secondToLastChar == "\"") && (thirdToLastChar != "\"")))) {
-					if (j + 1 === listOfFields.length) {
-						return null;
-					}
-					var nextField = listOfFields[j + 1];
-					listOfFields[j] = field_space + "," + nextField;
-					listOfFields.splice(j + 1, 1);
-				} else {
-					if ((firstChar == "\"") && (lastChar == "\"")) {
-						field = field.slice(1, (field.length - 1));
-						field = field.replace(doubleQuotes, "\"");
-					}
-					listOfFields[j] = field;
-					j += 1;
-				}
-			}
-			arrayOfOutputRecords.push(listOfFields);
-		}
-	}
-	return arrayOfOutputRecords;
-}, _getArrayOfObjectsFromArrayOfArrays:function (arrayOfArrays) {
-	dojo.lang.assertType(arrayOfArrays, Array);
-	var arrayOfItems = [];
-	if (arrayOfArrays.length > 1) {
-		var arrayOfKeys = arrayOfArrays[0];
-		for (var i = 1; i < arrayOfArrays.length; ++i) {
-			var row = arrayOfArrays[i];
-			var item = {};
-			for (var j in row) {
-				var value = row[j];
-				var key = arrayOfKeys[j];
-				item[key] = value;
-			}
-			arrayOfItems.push(item);
-		}
-	}
-	return arrayOfItems;
-}, _getRemoteStoreDataFromArrayOfObjects:function (arrayOfObjects) {
-	dojo.lang.assertType(arrayOfObjects, Array);
-	var output = {};
-	for (var i = 0; i < arrayOfObjects.length; ++i) {
-		var object = arrayOfObjects[i];
-		for (var key in object) {
-			var value = object[key];
-			object[key] = [value];
-		}
-		output[i] = object;
-	}
-	return output;
-}, newItem:function (attributes, keywordArgs) {
-	dojo.unimplemented("dojo.data.CsvStore.newItem");
-}, deleteItem:function (item) {
-	dojo.unimplemented("dojo.data.CsvStore.deleteItem");
-}, setValues:function (item, attribute, values) {
-	dojo.unimplemented("dojo.data.CsvStore.setValues");
-}, set:function (item, attribute, value) {
-	dojo.unimplemented("dojo.data.CsvStore.set");
-}, unsetAttribute:function (item, attribute) {
-	dojo.unimplemented("dojo.data.CsvStore.unsetAttribute");
-}, save:function (keywordArgs) {
-	dojo.unimplemented("dojo.data.CsvStore.save");
-}, revert:function () {
-	dojo.unimplemented("dojo.data.CsvStore.revert");
-}, isDirty:function (item) {
-	dojo.unimplemented("dojo.data.CsvStore.isDirty");
-}});
-

Added: tags/parley-0.53/root/static/magic/src/data/Item.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/Item.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/Item.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,332 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.Item");
+dojo.require("dojo.data.Observable");
+dojo.require("dojo.data.Value");
+dojo.require("dojo.lang.common");
+dojo.require("dojo.lang.assert");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Item = function(/* dojo.data.provider.Base */ dataProvider) {
+	/**
+	 * summary:
+	 * An Item has attributes and attribute values, sort of like 
+	 * a record in a database, or a 'struct' in C.  Instances of
+	 * the Item class know how to store and retrieve their
+	 * attribute values.
+	 */
+	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, "optional"]);
+	dojo.data.Observable.call(this);
+	this._dataProvider = dataProvider;
+	this._dictionaryOfAttributeValues = {};
+};
+dojo.inherits(dojo.data.Item, dojo.data.Observable);
+
+// -------------------------------------------------------------------
+// Public class methods
+// -------------------------------------------------------------------
+dojo.data.Item.compare = function(/* dojo.data.Item */ itemOne, /* dojo.data.Item */ itemTwo) {
+	/**
+	 * summary:
+	 * Given two Items to compare, this method returns 0, 1, or -1.
+	 * This method is designed to be used by sorting routines, like
+	 * the JavaScript built-in Array sort() method.
+	 * 
+	 * Example:
+	 * <pre>
+	 *   var a = dataProvider.newItem("kermit");
+	 *   var b = dataProvider.newItem("elmo");
+	 *   var c = dataProvider.newItem("grover");
+	 *   var array = new Array(a, b, c);
+	 *   array.sort(dojo.data.Item.compare);
+	 * </pre>
+	 */
+	dojo.lang.assertType(itemOne, dojo.data.Item);
+	if (!dojo.lang.isOfType(itemTwo, dojo.data.Item)) {
+		return -1;
+	}
+	var nameOne = itemOne.getName();
+	var nameTwo = itemTwo.getName();
+	if (nameOne == nameTwo) {
+		var attributeArrayOne = itemOne.getAttributes();
+		var attributeArrayTwo = itemTwo.getAttributes();
+		if (attributeArrayOne.length != attributeArrayTwo.length) {
+			if (attributeArrayOne.length > attributeArrayTwo.length) {
+				return 1; 
+			} else {
+				return -1;
+			}
+		}
+		for (var i in attributeArrayOne) {
+			var attribute = attributeArrayOne[i];
+			var arrayOfValuesOne = itemOne.getValues(attribute);
+			var arrayOfValuesTwo = itemTwo.getValues(attribute);
+			dojo.lang.assert(arrayOfValuesOne && (arrayOfValuesOne.length > 0));
+			if (!arrayOfValuesTwo) {
+				return 1;
+			}
+			if (arrayOfValuesOne.length != arrayOfValuesTwo.length) {
+				if (arrayOfValuesOne.length > arrayOfValuesTwo.length) {
+					return 1; 
+				} else {
+					return -1;
+				}
+			}
+			for (var j in arrayOfValuesOne) {
+				var value = arrayOfValuesOne[j];
+				if (!itemTwo.hasAttributeValue(value)) {
+					return 1;
+				}
+			}
+			return 0;
+		}
+	} else {
+		if (nameOne > nameTwo) {
+			return 1; 
+		} else {
+			return -1;  // 0, 1, or -1
+		}
+	}
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Item.prototype.toString = function() {
+	/**
+	 * Returns a simple string representation of the item.
+	 */
+	var arrayOfStrings = [];
+	var attributes = this.getAttributes();
+	for (var i in attributes) {
+		var attribute = attributes[i];
+		var arrayOfValues = this.getValues(attribute);
+		var valueString;
+		if (arrayOfValues.length == 1) {
+			valueString = arrayOfValues[0];
+		} else {
+			valueString = '[';
+			valueString += arrayOfValues.join(', ');
+			valueString += ']';
+		}
+		arrayOfStrings.push('  ' + attribute + ': ' + valueString);
+	}
+	var returnString = '{ ';
+	returnString += arrayOfStrings.join(',\n');
+	returnString += ' }';
+	return returnString; // string
+};
+
+dojo.data.Item.prototype.compare = function(/* dojo.data.Item */ otherItem) {
+	/**
+	 * summary: Compares this Item to another Item, and returns 0, 1, or -1.
+	 */ 
+	return dojo.data.Item.compare(this, otherItem); // 0, 1, or -1
+};
+
+dojo.data.Item.prototype.isEqual = function(/* dojo.data.Item */ otherItem) {
+	/**
+	 * summary: Returns true if this Item is equal to the otherItem, or false otherwise.
+	 */
+	return (this.compare(otherItem) == 0); // boolean
+};
+
+dojo.data.Item.prototype.getName = function() {
+	return this.get('name');
+};
+
+dojo.data.Item.prototype.get = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns a single literal value, like "foo" or 33.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		return null; // null
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		return literalOrValueOrArray.getValue(); // literal
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		var dojoDataValue = literalOrValueOrArray[0];
+		return dojoDataValue.getValue(); // literal
+	}
+	return literalOrValueOrArray; // literal
+};
+
+dojo.data.Item.prototype.getValue = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns a single instance of dojo.data.Value.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		return null; // null
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		return literalOrValueOrArray; // dojo.data.Value
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		var dojoDataValue = literalOrValueOrArray[0];
+		return dojoDataValue; // dojo.data.Value
+	}
+	var literal = literalOrValueOrArray;
+	dojoDataValue = new dojo.data.Value(literal);
+	this._dictionaryOfAttributeValues[attributeId] = dojoDataValue;
+	return dojoDataValue; // dojo.data.Value
+};
+
+dojo.data.Item.prototype.getValues = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns an array of dojo.data.Value objects.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		return null; // null
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		var array = [literalOrValueOrArray];
+		this._dictionaryOfAttributeValues[attributeId] = array;
+		return array; // Array
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		return literalOrValueOrArray; // Array
+	}
+	var literal = literalOrValueOrArray;
+	var dojoDataValue = new dojo.data.Value(literal);
+	array = [dojoDataValue];
+	this._dictionaryOfAttributeValues[attributeId] = array;
+	return array; // Array
+};
+
+dojo.data.Item.prototype.load = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: 
+	 * Used for loading an attribute value into an item when
+	 * the item is first being loaded into memory from some
+	 * data store (such as a file).
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	this._dataProvider.registerAttribute(attributeId);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		this._dictionaryOfAttributeValues[attributeId] = value;
+		return;
+	}
+	if (!(value instanceof dojo.data.Value)) {
+		value = new dojo.data.Value(value);
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		var array = [literalOrValueOrArray, value];
+		this._dictionaryOfAttributeValues[attributeId] = array;
+		return;
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		literalOrValueOrArray.push(value);
+		return;
+	}
+	var literal = literalOrValueOrArray;
+	var dojoDataValue = new dojo.data.Value(literal);
+	array = [dojoDataValue, value];
+	this._dictionaryOfAttributeValues[attributeId] = array;
+};
+
+dojo.data.Item.prototype.set = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: 
+	 * Used for setting an attribute value as a result of a
+	 * user action.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	this._dataProvider.registerAttribute(attributeId);
+	this._dictionaryOfAttributeValues[attributeId] = value;
+	this._dataProvider.noteChange(this, attributeId, value);
+};
+
+dojo.data.Item.prototype.setValue = function(/* string or dojo.data.Attribute */ attributeId, /* dojo.data.Value */ value) {
+	this.set(attributeId, value);
+};
+
+dojo.data.Item.prototype.addValue = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: 
+	 * Used for adding an attribute value as a result of a
+	 * user action.
+	 */ 
+	this.load(attributeId, value);
+	this._dataProvider.noteChange(this, attributeId, value);
+};
+
+dojo.data.Item.prototype.setValues = function(/* string or dojo.data.Attribute */ attributeId, /* Array */ arrayOfValues) {
+	/**
+	 * summary: 
+	 * Used for setting an array of attribute values as a result of a
+	 * user action.
+	 */
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	dojo.lang.assertType(arrayOfValues, Array);
+	this._dataProvider.registerAttribute(attributeId);
+	var finalArray = [];
+	this._dictionaryOfAttributeValues[attributeId] = finalArray;
+	for (var i in arrayOfValues) {
+		var value = arrayOfValues[i];
+		if (!(value instanceof dojo.data.Value)) {
+			value = new dojo.data.Value(value);
+		}
+		finalArray.push(value);
+		this._dataProvider.noteChange(this, attributeId, value);
+	}
+};
+
+dojo.data.Item.prototype.getAttributes = function() {
+	/**
+	 * summary: 
+	 * Returns an array containing all of the attributes for which
+	 * this item has attribute values.
+	 */ 
+	var arrayOfAttributes = [];
+	for (var key in this._dictionaryOfAttributeValues) {
+		arrayOfAttributes.push(this._dataProvider.getAttribute(key));
+	}
+	return arrayOfAttributes; // Array
+};
+
+dojo.data.Item.prototype.hasAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns true if the given attribute of the item has been assigned any value.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	for (var key in this._dictionaryOfAttributeValues) {
+		if (key == attributeId) {
+			return true; // boolean
+		}
+	}
+	return false; // boolean
+};
+
+dojo.data.Item.prototype.hasAttributeValue = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: Returns true if the given attribute of the item has been assigned the given value.
+	 */ 
+	var arrayOfValues = this.getValues(attributeId);
+	for (var i in arrayOfValues) {
+		var candidateValue = arrayOfValues[i];
+		if (candidateValue.isEqual(value)) {
+			return true; // boolean
+		}
+	}
+	return false; // boolean
+};
+
+

Added: tags/parley-0.53/root/static/magic/src/data/Kind.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/Kind.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/Kind.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,28 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.Kind");
+dojo.require("dojo.data.Item");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Kind = function(/* dojo.data.provider.Base */ dataProvider) {
+	/**
+	 * summary:
+	 * A Kind represents a kind of item.  In the dojo data model
+	 * the item Snoopy might belong to the 'kind' Dog, where in
+	 * a Java program the object Snoopy would belong to the 'class'
+	 * Dog, and in MySQL the record for Snoopy would be in the 
+	 * table Dog.
+	 */
+	dojo.data.Item.call(this, dataProvider);
+};
+dojo.inherits(dojo.data.Kind, dojo.data.Item);

Added: tags/parley-0.53/root/static/magic/src/data/Observable.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/Observable.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/Observable.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,59 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.Observable");
+dojo.require("dojo.lang.common");
+dojo.require("dojo.lang.assert");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Observable = function() {
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Observable.prototype.addObserver = function(/* object */ observer) {
+	/**
+	 * summary: Registers an object as an observer of this item,
+	 * so that the object will be notified when the item changes.
+	 */ 
+	dojo.lang.assertType(observer, Object);
+	dojo.lang.assertType(observer.observedObjectHasChanged, Function);
+	if (!this._arrayOfObservers) {
+		this._arrayOfObservers = [];
+	}
+	if (!dojo.lang.inArray(this._arrayOfObservers, observer)) {
+		this._arrayOfObservers.push(observer);
+	}
+};
+
+dojo.data.Observable.prototype.removeObserver = function(/* object */ observer) {
+	/**
+	 * summary: Removes the observer registration for a previously
+	 * registered object.
+	 */ 
+	if (!this._arrayOfObservers) {
+		return;
+	}
+	var index = dojo.lang.indexOf(this._arrayOfObservers, observer);
+	if (index != -1) {
+		this._arrayOfObservers.splice(index, 1);
+	}
+};
+
+dojo.data.Observable.prototype.getObservers = function() {
+	/**
+	 * summary: Returns an array with all the observers of this item.
+	 */ 
+	return this._arrayOfObservers; // Array or undefined
+};
+

Deleted: tags/parley-0.53/root/static/magic/src/data/OpmlStore.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/OpmlStore.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/OpmlStore.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,166 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.data.OpmlStore");
-dojo.require("dojo.data.core.Read");
-dojo.require("dojo.data.core.Result");
-dojo.require("dojo.lang.assert");
-dojo.require("dojo.json");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.data.OpmlStore");
-dojo.declare("dojo.data.OpmlStore", dojo.data.core.Read, {initializer:function (keywordParameters) {
-	this._arrayOfTopLevelItems = [];
-	this._metadataNodes = null;
-	this._loadFinished = false;
-	this._opmlFileUrl = keywordParameters["url"];
-}, _assertIsItem:function (item) {
-	if (!this.isItem(item)) {
-		throw new Error("dojo.data.OpmlStore: a function was passed an item argument that was not an item");
-	}
-}, _removeChildNodesThatAreNotElementNodes:function (node, recursive) {
-	var childNodes = node.childNodes;
-	if (childNodes.length == 0) {
-		return;
-	}
-	var nodesToRemove = [];
-	var i, childNode;
-	for (i = 0; i < childNodes.length; ++i) {
-		childNode = childNodes[i];
-		if (childNode.nodeType != Node.ELEMENT_NODE) {
-			nodesToRemove.push(childNode);
-		}
-	}
-	for (i = 0; i < nodesToRemove.length; ++i) {
-		childNode = nodesToRemove[i];
-		node.removeChild(childNode);
-	}
-	if (recursive) {
-		for (i = 0; i < childNodes.length; ++i) {
-			childNode = childNodes[i];
-			this._removeChildNodesThatAreNotElementNodes(childNode, recursive);
-		}
-	}
-}, _processRawXmlTree:function (rawXmlTree) {
-	var headNodes = rawXmlTree.getElementsByTagName("head");
-	var headNode = headNodes[0];
-	this._removeChildNodesThatAreNotElementNodes(headNode);
-	this._metadataNodes = headNode.childNodes;
-	var bodyNodes = rawXmlTree.getElementsByTagName("body");
-	var bodyNode = bodyNodes[0];
-	this._removeChildNodesThatAreNotElementNodes(bodyNode, true);
-	var bodyChildNodes = bodyNodes[0].childNodes;
-	for (var i = 0; i < bodyChildNodes.length; ++i) {
-		var node = bodyChildNodes[i];
-		if (node.tagName == "outline") {
-			this._arrayOfTopLevelItems.push(node);
-		}
-	}
-}, get:function (item, attribute, defaultValue) {
-	this._assertIsItem(item);
-	if (attribute == "children") {
-		return (item.firstChild || defaultValue);
-	} else {
-		var value = item.getAttribute(attribute);
-		value = (value != undefined) ? value : defaultValue;
-		return value;
-	}
-}, getValues:function (item, attribute) {
-	this._assertIsItem(item);
-	if (attribute == "children") {
-		var array = [];
-		for (var i = 0; i < item.childNodes.length; ++i) {
-			array.push(item.childNodes[i]);
-		}
-		return array;
-	} else {
-		return [item.getAttribute(attribute)];
-	}
-}, getAttributes:function (item) {
-	this._assertIsItem(item);
-	var attributes = [];
-	var xmlNode = item;
-	var xmlAttributes = xmlNode.attributes;
-	for (var i = 0; i < xmlAttributes.length; ++i) {
-		var xmlAttribute = xmlAttributes.item(i);
-		attributes.push(xmlAttribute.nodeName);
-	}
-	if (xmlNode.childNodes.length > 0) {
-		attributes.push("children");
-	}
-	return attributes;
-}, hasAttribute:function (item, attribute) {
-	return (this.getValues(item, attribute).length > 0);
-}, containsValue:function (item, attribute, value) {
-	var values = this.getValues(item, attribute);
-	for (var i = 0; i < values.length; ++i) {
-		var possibleValue = values[i];
-		if (value == possibleValue) {
-			return true;
-		}
-	}
-	return false;
-}, isItem:function (something) {
-	return (something && something.nodeType == Node.ELEMENT_NODE && something.tagName == "outline");
-}, isItemAvailable:function (something) {
-	return this.isItem(something);
-}, find:function (keywordArgs) {
-	var result = null;
-	if (keywordArgs instanceof dojo.data.core.Result) {
-		result = keywordArgs;
-		result.store = this;
-	} else {
-		result = new dojo.data.core.Result(keywordArgs, this);
-	}
-	var self = this;
-	var bindHandler = function (type, data, evt) {
-		var scope = result.scope || dj_global;
-		if (type == "load") {
-			self._processRawXmlTree(data);
-			if (result.saveResult) {
-				result.items = self._arrayOfTopLevelItems;
-			}
-			if (result.onbegin) {
-				result.onbegin.call(scope, result);
-			}
-			for (var i = 0; i < self._arrayOfTopLevelItems.length; i++) {
-				var item = self._arrayOfTopLevelItems[i];
-				if (result.onnext && !result._aborted) {
-					result.onnext.call(scope, item, result);
-				}
-			}
-			if (result.oncompleted && !result._aborted) {
-				result.oncompleted.call(scope, result);
-			}
-		} else {
-			if (type == "error" || type == "timeout") {
-				var errorObject = data;
-				if (result.onerror) {
-					result.onerror.call(scope, data);
-				}
-			}
-		}
-	};
-	if (!this._loadFinished) {
-		if (this._opmlFileUrl) {
-			var bindRequest = dojo.io.bind({url:this._opmlFileUrl, handle:bindHandler, mimetype:"text/xml", sync:(result.sync || false)});
-			result._abortFunc = bindRequest.abort;
-		}
-	}
-	return result;
-}, getIdentity:function (item) {
-	dojo.unimplemented("dojo.data.OpmlStore.getIdentity()");
-	return null;
-}, findByIdentity:function (identity) {
-	dojo.unimplemented("dojo.data.OpmlStore.findByIdentity()");
-	return null;
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/data/RdfStore.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/RdfStore.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/RdfStore.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,185 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.data.RdfStore");
-dojo.provide("dojo.data.RhizomeStore");
-dojo.require("dojo.lang.declare");
-dojo.require("dojo.data.core.RemoteStore");
-dojo.require("dojo.experimental");
-dojo.data.RdfDatatypeSerializer = function (type, convertFunc, uri) {
-	this.type = type;
-	this._converter = convertFunc;
-	this.uri = uri;
-	this.serialize = function (value) {
-		return this._converter.call(value, value);
-	};
-};
-dojo.declare("dojo.data.RdfStore", dojo.data.core.RemoteStore, {_datatypeMap:{literal:function (value) {
-	var literal = value.value;
-	if (value["xml:lang"]) {
-		literal.lang = value["xml:lang"];
-	}
-	return literal;
-}, uri:function (value) {
-	return {id:value.value};
-}, bnode:function (value) {
-	return {id:"_:" + value.value};
-}, "http://www.w3.org/2001/XMLSchema#int":function (value) {
-	return parseInt(value.value);
-}, "http://www.w3.org/2001/XMLSchema#integer":function (value) {
-	return parseInt(value.value);
-}, "http://www.w3.org/2001/XMLSchema#long":function (value) {
-	return parseInt(value.value);
-}, "http://www.w3.org/2001/XMLSchema#float":function (value) {
-	return parseFloat(value.value);
-}, "http://www.w3.org/2001/XMLSchema#double":function (value) {
-	return parseFloat(value.value);
-}, "http://www.w3.org/2001/XMLSchema#boolean":function (value) {
-	return !value || value == "false" || value == "0" ? false : true;
-}}, _datatypeSerializers:[new dojo.data.RdfDatatypeSerializer(Number, Number.toString, "http://www.w3.org/2001/XMLSchema#float"), new dojo.data.RdfDatatypeSerializer(Boolean, Boolean.toString, "http://www.w3.org/2001/XMLSchema#boolean")], _findDatatypeSerializer:function (value) {
-	var length = this._datatypeSerializers.length;
-	for (var i = 0; i < length; i++) {
-		var datatype = this._datatypeSerializers[i];
-		if (value instanceof datatype.type) {
-			return datatype;
-		}
-	}
-}, _toRDFValue:function (value) {
-	var rdfvalue = {};
-	if (value.id) {
-		if (value.id.slice(0, 2) == "_:") {
-			rdfvalue.type = "bnode";
-			rdfvalue.value = value.id.substring(2);
-		} else {
-			rdfvalue.type = "uri";
-			rdfvalue.value = value.id;
-		}
-	} else {
-		if (typeof value == "string" || value instanceof String) {
-			rdfvalue.type = "literal";
-			rdfvalue.value = value;
-			if (value.lang) {
-				rdfvalue["xml:lang"] = value.lang;
-			}
-		} else {
-			if (typeof value == "number") {
-				value = new Number(value);
-			} else {
-				if (typeof value == "boolean") {
-					value = new Boolean(value);
-				}
-			}
-			var datatype = this._findDatatypeSerializer(value);
-			if (datatype) {
-				rdfvalue = {"type":"typed-literal", "datatype":datatype.uri, "value":value.toString()};
-			} else {
-				rdfvalue = {"type":"literal", "value":value.toString()};
-			}
-		}
-	}
-	return rdfvalue;
-}, _setupSaveRequest:function (saveKeywordArgs, requestKw) {
-	var rdfResult = {"head":{"vars":["s", "p", "o"]}, "results":{"bindings":[]}};
-	var resources = [];
-	for (var key in this._deleted) {
-		resources.push(key);
-	}
-	rdfResult.results.deleted = resources;
-	for (key in this._changed) {
-		var subject = this._toRDFValue(this.getIdentity(key));
-		var attributes = this._changed[key];
-		for (var attr in attributes) {
-			var predicate = {type:"uri", value:attr};
-			var values = attributes[attr];
-			if (!values.length) {
-				continue;
-			}
-			var rdfvalues = [];
-			for (var i = 0; i < values.length; i++) {
-				var rdfvalue = this._toRDFValue(values[i]);
-				rdfResult.results.bindings.push({s:subject, p:predicate, o:rdfvalue});
-			}
-		}
-	}
-	var oldRegistry = dojo.json.jsonRegistry;
-	dojo.json.jsonRegistry = this._jsonRegistry;
-	var jsonString = dojo.json.serialize(rdfResult);
-	dojo.json.jsonRegistry = oldRegistry;
-	requestKw.postContent = jsonString;
-}, _resultToQueryMetadata:function (json) {
-	return json.head;
-}, _resultToQueryData:function (json) {
-	var items = {};
-	var stmts = json.results.bindings;
-	for (var i = 0; i < stmts.length; i++) {
-		var stmt = stmts[i];
-		var subject = stmt.s.value;
-		if (stmt.s.type == "bnode") {
-			subject = "_:" + subject;
-		}
-		var attributes = data[subject];
-		if (!attributes) {
-			attributes = {};
-			data[stmt.s] = attributes;
-		}
-		var attr = attributes[stmt.p.value];
-		if (!attr) {
-			attributes[stmt.p.value] = [stmt.o];
-		} else {
-			attr.push(stmt.o);
-		}
-	}
-	return items;
-}});
-dojo.declare("dojo.data.RhizomeStore", dojo.data.RdfStore, {initializer:function (kwArgs) {
-	this._serverQueryUrl = kwArgs.baseUrl + "search?view=json&searchType=RxPath&search=";
-	this._serverSaveUrl = kwArgs.baseUrl + "save-metadata";
-}, _resultToQueryMetadata:function (json) {
-	return json;
-}, _resultToQueryData:function (json) {
-	return json;
-}, _setupSaveRequest:function (saveKeywordArgs, requestKw) {
-	requestKw.url = this._serverSaveUrl;
-	requestKw.method = "post";
-	requestKw.mimetype = "text/plain";
-	var resources = [];
-	for (var key in this._deleted) {
-		resources.push(key);
-	}
-	var changes = {};
-	for (key in this._changed) {
-		if (!this._added[key]) {
-			resources.push(key);
-		}
-		var attributes = this._changed[key];
-		var rdfattributes = {};
-		for (var attr in attributes) {
-			var values = attributes[attr];
-			if (!values.length) {
-				continue;
-			}
-			var rdfvalues = [];
-			for (var i = 0; i < values.length; i++) {
-				var rdfvalue = this._toRDFValue(values[i]);
-				rdfvalues.push(rdfvalue);
-			}
-			rdfattributes[attr] = rdfvalues;
-		}
-		changes[key] = rdfattributes;
-	}
-	var oldRegistry = dojo.json.jsonRegistry;
-	dojo.json.jsonRegistry = this._jsonRegistry;
-	var jsonString = dojo.json.serialize(changes);
-	dojo.json.jsonRegistry = oldRegistry;
-	requestKw.content = {rdfFormat:"json", resource:resources, metadata:jsonString};
-}});
-

Added: tags/parley-0.53/root/static/magic/src/data/ResultSet.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/ResultSet.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/ResultSet.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,70 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.ResultSet");
+dojo.require("dojo.lang.assert");
+dojo.require("dojo.collections.Collections");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.ResultSet = function(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfItems) {
+	/**
+	 * summary:
+	 * A ResultSet holds a collection of Items.  A data provider
+	 * returns a ResultSet in reponse to a query.
+	 * (The name "Result Set" comes from the MySQL terminology.)
+	 */
+	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, "optional"]);
+	dojo.lang.assertType(arrayOfItems, [Array, "optional"]);
+	dojo.data.Observable.call(this);
+	this._dataProvider = dataProvider;
+	this._arrayOfItems = [];
+	if (arrayOfItems) {
+		this._arrayOfItems = arrayOfItems;
+	}
+};
+dojo.inherits(dojo.data.ResultSet, dojo.data.Observable);
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.ResultSet.prototype.toString = function() {
+	var returnString = this._arrayOfItems.join(', ');
+	return returnString; // string
+};
+
+dojo.data.ResultSet.prototype.toArray = function() {
+	return this._arrayOfItems; // Array
+};
+
+dojo.data.ResultSet.prototype.getIterator = function() {
+	return new dojo.collections.Iterator(this._arrayOfItems);
+};
+
+dojo.data.ResultSet.prototype.getLength = function() {
+	return this._arrayOfItems.length; // integer
+};
+
+dojo.data.ResultSet.prototype.getItemAt = function(/* numeric */ index) {
+	return this._arrayOfItems[index];
+};
+
+dojo.data.ResultSet.prototype.indexOf = function(/* dojo.data.Item */ item) {
+	return dojo.lang.indexOf(this._arrayOfItems, item); // integer
+};
+
+dojo.data.ResultSet.prototype.contains = function(/* dojo.data.Item */ item) {
+	return dojo.lang.inArray(this._arrayOfItems, item); // boolean
+};
+
+dojo.data.ResultSet.prototype.getDataProvider = function() {
+	return this._dataProvider; // dojo.data.provider.Base
+};
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/data/Type.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/Type.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/Type.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,25 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.Type");
+dojo.require("dojo.data.Item");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Type = function(/* dojo.data.provider.Base */ dataProvider) {
+	/**
+	 * summary:
+	 * A Type represents a type of value, like Text, Number, Picture,
+	 * or Varchar.
+	 */
+	dojo.data.Item.call(this, dataProvider);
+};
+dojo.inherits(dojo.data.Type, dojo.data.Item);

Added: tags/parley-0.53/root/static/magic/src/data/Value.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/Value.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/Value.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,55 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.Value");
+dojo.require("dojo.lang.assert");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Value = function(/* anything */ value) {
+	/**
+	 * summary:
+	 * A Value represents a simple literal value (like "foo" or 334),
+	 * or a reference value (a pointer to an Item).
+	 */
+	this._value = value;
+	this._type = null;
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Value.prototype.toString = function() {
+	return this._value.toString(); // string
+};
+
+dojo.data.Value.prototype.getValue = function() {
+	/**
+	 * summary: Returns the value itself.
+	 */ 
+	return this._value; // anything
+};
+
+dojo.data.Value.prototype.getType = function() {
+	/**
+	 * summary: Returns the data type of the value.
+	 */ 
+	dojo.unimplemented('dojo.data.Value.prototype.getType');
+	return this._type; // dojo.data.Type
+};
+
+dojo.data.Value.prototype.compare = function() {
+	dojo.unimplemented('dojo.data.Value.prototype.compare');
+};
+
+dojo.data.Value.prototype.isEqual = function() {
+	dojo.unimplemented('dojo.data.Value.prototype.isEqual');
+};

Deleted: tags/parley-0.53/root/static/magic/src/data/YahooStore.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/YahooStore.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/YahooStore.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,44 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.data.YahooStore");
-dojo.require("dojo.data.core.RemoteStore");
-dojo.require("dojo.lang.declare");
-dojo.require("dojo.io.ScriptSrcIO");
-dojo.declare("dojo.data.YahooStore", dojo.data.core.RemoteStore, {_setupQueryRequest:function (result, requestKw) {
-	var start = 1;
-	var count = 1;
-	if (result) {
-		start = result.start || start;
-		count = result.count || count;
-	}
-	var sourceUrl = "http://api.search.yahoo.com/WebSearchService/V1/webSearch?appid=dojo&language=en&query=" + result.query + "&start=" + start + "&results=" + count + "&output=json";
-	requestKw.url = sourceUrl;
-	requestKw.transport = "ScriptSrcTransport";
-	requestKw.mimetype = "text/json";
-	requestKw.jsonParamName = "callback";
-}, _resultToQueryMetadata:function (json) {
-	return json.ResultSet;
-}, _resultToQueryData:function (json) {
-	var data = {};
-	for (var i = 0; i < json.ResultSet.totalResultsReturned; ++i) {
-		var record = json.ResultSet.Result[i];
-		var item = {};
-		item["Url"] = [record.Url];
-		item["Title"] = [record.Title];
-		item["Summary"] = [record.Summary];
-		var arrayIndex = (json.ResultSet.firstResultPosition - 1) + i;
-		data[arrayIndex.toString()] = item;
-	}
-	return data;
-}});
-

Added: tags/parley-0.53/root/static/magic/src/data/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.require("dojo.experimental");
+
+dojo.experimental("dojo.data.*");
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.data.Item",
+		"dojo.data.ResultSet",
+		"dojo.data.provider.FlatFile"
+	]
+});
+dojo.provide("dojo.data.*");
+

Added: tags/parley-0.53/root/static/magic/src/data/format/Csv.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/format/Csv.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/format/Csv.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,112 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.format.Csv");
+dojo.require("dojo.lang.assert");
+
+
+dojo.data.format.Csv = new function() {
+
+	// -------------------------------------------------------------------
+	// Public functions
+	// -------------------------------------------------------------------
+	this.getArrayStructureFromCsvFileContents = function(/* string */ csvFileContents) {
+		/**
+		 * Given a string containing CSV records, this method parses
+		 * the string and returns a data structure containing the parsed
+		 * content.  The data structure we return is an array of length
+		 * R, where R is the number of rows (lines) in the CSV data.  The 
+		 * return array contains one sub-array for each CSV line, and each 
+		 * sub-array contains C string values, where C is the number of 
+		 * columns in the CSV data.
+		 * 
+		 * For example, given this CSV string as input:
+		 * <pre>
+		 *   "Title, Year, Producer \n Alien, 1979, Ridley Scott \n Blade Runner, 1982, Ridley Scott"
+		 * </pre>
+		 * We will return this data structure:
+		 * <pre>
+		 *   [["Title", "Year", "Producer"]
+		 *    ["Alien", "1979", "Ridley Scott"],  
+		 *    ["Blade Runner", "1982", "Ridley Scott"]]
+		 * </pre>
+		 */
+		dojo.lang.assertType(csvFileContents, String);
+		
+		var lineEndingCharacters = new RegExp("\r\n|\n|\r");
+		var leadingWhiteSpaceCharacters = new RegExp("^\\s+",'g');
+		var trailingWhiteSpaceCharacters = new RegExp("\\s+$",'g');
+		var doubleQuotes = new RegExp('""','g');
+		var arrayOfOutputRecords = [];
+		
+		var arrayOfInputLines = csvFileContents.split(lineEndingCharacters);
+		for (var i in arrayOfInputLines) {
+			var singleLine = arrayOfInputLines[i];
+			if (singleLine.length > 0) {
+				var listOfFields = singleLine.split(',');
+				var j = 0;
+				while (j < listOfFields.length) {
+					var space_field_space = listOfFields[j];
+					var field_space = space_field_space.replace(leadingWhiteSpaceCharacters, ''); // trim leading whitespace
+					var field = field_space.replace(trailingWhiteSpaceCharacters, ''); // trim trailing whitespace
+					var firstChar = field.charAt(0);
+					var lastChar = field.charAt(field.length - 1);
+					var secondToLastChar = field.charAt(field.length - 2);
+					var thirdToLastChar = field.charAt(field.length - 3);
+					if ((firstChar == '"') && 
+							((lastChar != '"') || 
+							 ((lastChar == '"') && (secondToLastChar == '"') && (thirdToLastChar != '"')) )) {
+						if (j+1 === listOfFields.length) {
+							// alert("The last field in record " + i + " is corrupted:\n" + field);
+							return null;
+						}
+						var nextField = listOfFields[j+1];
+						listOfFields[j] = field_space + ',' + nextField;
+						listOfFields.splice(j+1, 1); // delete element [j+1] from the list
+					} else {
+						if ((firstChar == '"') && (lastChar == '"')) {
+							field = field.slice(1, (field.length - 1)); // trim the " characters off the ends
+							field = field.replace(doubleQuotes, '"');   // replace "" with "
+						}
+						listOfFields[j] = field;
+						j += 1;
+					}
+				}
+				arrayOfOutputRecords.push(listOfFields);
+			}
+		}
+		return arrayOfOutputRecords; // Array
+	};
+
+	this.loadDataProviderFromFileContents = function(/* dojo.data.provider.Base */ dataProvider, /* string */ csvFileContents) {
+		dojo.lang.assertType(dataProvider, dojo.data.provider.Base);
+		dojo.lang.assertType(csvFileContents, String);
+		var arrayOfArrays = this.getArrayStructureFromCsvFileContents(csvFileContents);
+		if (arrayOfArrays) {
+			var arrayOfKeys = arrayOfArrays[0];
+			for (var i = 1; i < arrayOfArrays.length; ++i) {
+				var row = arrayOfArrays[i];
+				var item = dataProvider.getNewItemToLoad();
+				for (var j in row) {
+					var value = row[j];
+					var key = arrayOfKeys[j];
+					item.load(key, value);
+				}
+			}
+		}
+	};
+	
+	this.getCsvStringFromResultSet = function(/* dojo.data.ResultSet */ resultSet) {
+		dojo.unimplemented('dojo.data.format.Csv.getCsvStringFromResultSet');
+		var csvString = null;
+		return csvString; // String
+	};
+	
+}();

Added: tags/parley-0.53/root/static/magic/src/data/format/Json.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/format/Json.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/format/Json.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,103 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.format.Json");
+dojo.require("dojo.lang.assert");
+
+dojo.data.format.Json = new function() {
+
+	// -------------------------------------------------------------------
+	// Public functions
+	// -------------------------------------------------------------------
+	this.loadDataProviderFromFileContents = function(/* dojo.data.provider.Base */ dataProvider, /* string */ jsonFileContents) {
+		dojo.lang.assertType(dataProvider, dojo.data.provider.Base);
+		dojo.lang.assertType(jsonFileContents, String);
+		var arrayOfJsonData = eval("(" + jsonFileContents + ")");
+		this.loadDataProviderFromArrayOfJsonData(dataProvider, arrayOfJsonData);
+	};
+	
+	this.loadDataProviderFromArrayOfJsonData = function(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
+		dojo.lang.assertType(arrayOfJsonData, [Array, "optional"]);
+		if (arrayOfJsonData && (arrayOfJsonData.length > 0)) {
+			var firstRow = arrayOfJsonData[0];
+			dojo.lang.assertType(firstRow, [Array, "pureobject"]);
+			if (dojo.lang.isArray(firstRow)) {
+				_loadDataProviderFromArrayOfArrays(dataProvider, arrayOfJsonData);
+			} else {
+				dojo.lang.assertType(firstRow, "pureobject");
+				_loadDataProviderFromArrayOfObjects(dataProvider, arrayOfJsonData);
+			}
+		}
+	};
+
+	this.getJsonStringFromResultSet = function(/* dojo.data.ResultSet */ resultSet) {
+		dojo.unimplemented('dojo.data.format.Json.getJsonStringFromResultSet');
+		var jsonString = null;
+		return jsonString; // String
+	};
+
+	// -------------------------------------------------------------------
+	// Private functions
+	// -------------------------------------------------------------------
+	function _loadDataProviderFromArrayOfArrays(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
+		/** 
+		 * Example: 
+		 * var arrayOfJsonStates = [
+		 * 	 [ "abbr",  "population",  "name" ]
+		 * 	 [  "WA",     5894121,      "Washington"    ],
+		 * 	 [  "WV",     1808344,      "West Virginia" ],
+		 * 	 [  "WI",     5453896,      "Wisconsin"     ],
+		 *   [  "WY",      493782,      "Wyoming"       ] ];
+		 * this._loadFromArrayOfArrays(arrayOfJsonStates);
+		 */
+		var arrayOfKeys = arrayOfJsonData[0];
+		for (var i = 1; i < arrayOfJsonData.length; ++i) {
+			var row = arrayOfJsonData[i];
+			var item = dataProvider.getNewItemToLoad();
+			for (var j in row) {
+				var value = row[j];
+				var key = arrayOfKeys[j];
+				item.load(key, value);
+			}
+		}
+	}
+
+	function _loadDataProviderFromArrayOfObjects(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
+		/** 
+		 * Example: 
+		 * var arrayOfJsonStates = [
+		 * 	 { abbr: "WA", name: "Washington" },
+		 * 	 { abbr: "WV", name: "West Virginia" },
+		 * 	 { abbr: "WI", name: "Wisconsin", song: "On, Wisconsin!" },
+		 * 	 { abbr: "WY", name: "Wyoming", cities: ["Lander", "Cheyenne", "Laramie"] } ];
+		 * this._loadFromArrayOfArrays(arrayOfJsonStates);
+		 */
+		// dojo.debug("_loadDataProviderFromArrayOfObjects");
+		for (var i in arrayOfJsonData) {
+			var row = arrayOfJsonData[i];
+			var item = dataProvider.getNewItemToLoad();
+			for (var key in row) {
+				var value = row[key];
+				if (dojo.lang.isArray(value)) {
+					var arrayOfValues = value;
+					for (var j in arrayOfValues) {
+						value = arrayOfValues[j];
+						item.load(key, value);
+						// dojo.debug("loaded: " + key + " = " + value); 
+					}
+				} else {
+					item.load(key, value);
+				}
+			}
+		}
+	}
+	
+}();
+

Added: tags/parley-0.53/root/static/magic/src/data/provider/Base.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/provider/Base.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/provider/Base.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,183 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.provider.Base");
+dojo.require("dojo.lang.assert");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.Base = function() {
+	/**
+	 * summary:
+	 * A Data Provider serves as a connection to some data source,
+	 * like a relational database.  This data provider Base class
+	 * serves as an abstract superclass for other data provider
+	 * classes.
+	 */
+	this._countOfNestedTransactions = 0;
+	this._changesInCurrentTransaction = null;
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.Base.prototype.beginTransaction = function() {
+	/**
+	 * Marks the beginning of a transaction.
+	 *
+	 * Each time you call beginTransaction() you open a new transaction, 
+	 * which you need to close later using endTransaction().  Transactions
+	 * may be nested, but the beginTransaction and endTransaction calls
+	 * always need to come in pairs.
+	 */
+	if (this._countOfNestedTransactions === 0) {
+		this._changesInCurrentTransaction = [];
+	}
+	this._countOfNestedTransactions += 1;
+};
+
+dojo.data.provider.Base.prototype.endTransaction = function() {
+	/**
+	 * Marks the end of a transaction.
+	 */
+	this._countOfNestedTransactions -= 1;
+	dojo.lang.assert(this._countOfNestedTransactions >= 0);
+
+	if (this._countOfNestedTransactions === 0) {
+		var listOfChangesMade = this._saveChanges();
+		this._changesInCurrentTransaction = null;
+		if (listOfChangesMade.length > 0) {
+			// dojo.debug("endTransaction: " + listOfChangesMade.length + " changes made");
+			this._notifyObserversOfChanges(listOfChangesMade);
+		}
+	}
+};
+
+dojo.data.provider.Base.prototype.getNewItemToLoad = function() {
+	return this._newItem(); // dojo.data.Item
+};
+
+dojo.data.provider.Base.prototype.newItem = function(/* string */ itemName) {
+	/**
+	 * Creates a new item.
+	 */
+	dojo.lang.assertType(itemName, [String, "optional"]);
+	var item = this._newItem();
+	if (itemName) {
+		item.set('name', itemName);
+	}
+	return item; // dojo.data.Item
+};
+
+dojo.data.provider.Base.prototype.newAttribute = function(/* string */ attributeId) {
+	/**
+	 * Creates a new attribute.
+	 */
+	dojo.lang.assertType(attributeId, String); // FIXME: should be optional
+	var attribute = this._newAttribute(attributeId);
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype.getAttribute = function(/* string */ attributeId) {
+	dojo.unimplemented('dojo.data.provider.Base');
+	var attribute;
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype.getAttributes = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	return this._arrayOfAttributes; // Array
+};
+
+dojo.data.provider.Base.prototype.fetchArray = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	return []; // Array
+};
+
+dojo.data.provider.Base.prototype.fetchResultSet = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	var resultSet;
+	return resultSet; // dojo.data.ResultSet
+};
+
+dojo.data.provider.Base.prototype.noteChange = function(/* dojo.data.Item */ item, /* string or dojo.data.Attribute */ attribute, /* anything */ value) {
+	var change = {item: item, attribute: attribute, value: value};
+	if (this._countOfNestedTransactions === 0) {
+		this.beginTransaction();
+		this._changesInCurrentTransaction.push(change);
+		this.endTransaction();
+	} else {
+		this._changesInCurrentTransaction.push(change);
+	}
+};
+
+dojo.data.provider.Base.prototype.addItemObserver = function(/* dojo.data.Item */ item, /* object */ observer) {
+	/**
+	 * summary: Registers an object as an observer of an item,
+	 * so that the object will be notified when the item changes.
+	 */
+	dojo.lang.assertType(item, dojo.data.Item);
+	item.addObserver(observer);
+};
+
+dojo.data.provider.Base.prototype.removeItemObserver = function(/* dojo.data.Item */ item, /* object */ observer) {
+	/**
+	 * summary: Removes the observer registration for a previously
+	 * registered object.
+	 */ 
+	dojo.lang.assertType(item, dojo.data.Item);
+	item.removeObserver(observer);
+};
+
+// -------------------------------------------------------------------
+// Private instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.Base.prototype._newItem = function() {
+	var item = new dojo.data.Item(this);
+	return item; // dojo.data.Item
+};
+
+dojo.data.provider.Base.prototype._newAttribute = function(/* String */ attributeId) {
+	var attribute = new dojo.data.Attribute(this);
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype._saveChanges = function() {
+	var arrayOfChangesMade = this._changesInCurrentTransaction;
+	return arrayOfChangesMade; // Array
+};
+
+dojo.data.provider.Base.prototype._notifyObserversOfChanges = function(/* Array */ arrayOfChanges) {
+	var arrayOfResultSets = this._getResultSets();
+	for (var i in arrayOfChanges) {
+		var change = arrayOfChanges[i];
+		var changedItem = change.item;
+		var arrayOfItemObservers = changedItem.getObservers();
+		for (var j in arrayOfItemObservers) {
+			var observer = arrayOfItemObservers[j];
+			observer.observedObjectHasChanged(changedItem, change);
+		}
+		for (var k in arrayOfResultSets) {
+			var resultSet = arrayOfResultSets[k];
+			var arrayOfResultSetObservers = resultSet.getObservers();
+			for (var m in arrayOfResultSetObservers) {
+				observer = arrayOfResultSetObservers[m];
+				observer.observedObjectHasChanged(resultSet, change);
+			}
+		}
+	}
+};
+
+dojo.data.provider.Base.prototype._getResultSets = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	return []; // Array
+};
+

Added: tags/parley-0.53/root/static/magic/src/data/provider/Delicious.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/provider/Delicious.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/provider/Delicious.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,85 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.provider.Delicious");
+dojo.require("dojo.data.provider.FlatFile");
+dojo.require("dojo.data.format.Json");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.Delicious = function() {
+	/**
+	 * summary:
+	 * The Delicious Data Provider can be used to take data from
+	 * del.icio.us and make it available as dojo.data.Items
+	 * In order to use the Delicious Data Provider, you need 
+	 * to have loaded a script tag that looks like this:
+	 * <script type="text/javascript" src="http://del.icio.us/feeds/json/gumption?count=8"></script>
+	 */
+	dojo.data.provider.FlatFile.call(this);
+	// Delicious = null;
+	if (Delicious && Delicious.posts) {
+		dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, Delicious.posts);
+	} else {
+		// document.write("<script type='text/javascript'>dojo.data.provider.Delicious._fetchComplete()</script>");		
+		/*
+		document.write("<script type='text/javascript'>alert('boo!');</script>");		
+		document.write("<script type='text/javascript'>var foo = 'not dojo'; alert('dojo == ' + foo);</script>");		
+		document.write("<script type='text/javascript'>var foo = fetchComplete; alert('dojo == ' + foo);</script>");		
+		fetchComplete();
+		*/
+		// dojo.debug("Delicious line 29: constructor");
+	}
+	var u = this.registerAttribute('u');
+	var d = this.registerAttribute('d');
+	var t = this.registerAttribute('t');
+	
+	u.load('name', 'Bookmark');
+	d.load('name', 'Description');
+	t.load('name', 'Tags');
+	
+	u.load('type', 'String');
+	d.load('type', 'String');
+	t.load('type', 'String');
+};
+dojo.inherits(dojo.data.provider.Delicious, dojo.data.provider.FlatFile);
+
+/********************************************************************
+ * FIXME: the rest of this is work in progress
+ *
+ 
+dojo.data.provider.Delicious.prototype.getNewItemToLoad = function() {
+	var newItem = this._newItem();
+	this._currentArray.push(newItem);
+	return newItem; // dojo.data.Item
+};
+
+dojo.data.provider.Delicious.prototype.fetchArray = function(query) {
+	if (!query) {	
+		query = "gumption";
+	}
+	this._currentArray = [];
+	alert("Delicious line 60: loadDataProviderFromArrayOfJsonData");
+	alert("Delicious line 61: " + dojo);
+		var sourceUrl = "http://del.icio.us/feeds/json/" + query + "?count=8";
+		document.write("<script type='text/javascript' src='" + sourceUrl + "'></script>");
+		document.write("<script type='text/javascript'>alert('line 63: ' + Delicious.posts[0].u);</script>");		
+		document.write("<script type='text/javascript'>callMe();</script>");		
+	alert("line 66");
+	dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, Delicious.posts);
+	return this._currentArray; // Array
+};
+
+callMe = function() {
+	alert("callMe!");
+};
+
+*/

Added: tags/parley-0.53/root/static/magic/src/data/provider/FlatFile.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/provider/FlatFile.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/provider/FlatFile.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,153 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.provider.FlatFile");
+dojo.require("dojo.data.provider.Base");
+dojo.require("dojo.data.Item");
+dojo.require("dojo.data.Attribute");
+dojo.require("dojo.data.ResultSet");
+dojo.require("dojo.data.format.Json");
+dojo.require("dojo.data.format.Csv");
+dojo.require("dojo.lang.assert");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.FlatFile = function(/* keywords */ keywordParameters) {
+	/**
+	 * summary:
+	 * A Json Data Provider knows how to read in simple JSON data
+	 * tables and make their contents accessable as Items.
+	 */
+	dojo.lang.assertType(keywordParameters, ["pureobject", "optional"]);
+	dojo.data.provider.Base.call(this);
+	this._arrayOfItems = [];
+	this._resultSet = null;
+	this._dictionaryOfAttributes = {};
+
+	if (keywordParameters) {
+		var jsonObjects = keywordParameters["jsonObjects"];
+		var jsonString  = keywordParameters["jsonString"];
+		var fileUrl     = keywordParameters["url"];
+		if (jsonObjects) {
+			dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, jsonObjects);
+		}
+		if (jsonString) {
+			dojo.data.format.Json.loadDataProviderFromFileContents(this, jsonString);
+		}
+		if (fileUrl) {
+			var arrayOfParts = fileUrl.split('.');
+			var lastPart = arrayOfParts[(arrayOfParts.length - 1)];
+			var formatParser = null;
+			if (lastPart == "json") {
+				formatParser = dojo.data.format.Json;
+			}
+			if (lastPart == "csv") {
+				formatParser = dojo.data.format.Csv;
+			}
+			if (formatParser) {
+				var fileContents = dojo.hostenv.getText(fileUrl);
+				formatParser.loadDataProviderFromFileContents(this, fileContents);
+			} else {
+				dojo.lang.assert(false, "new dojo.data.provider.FlatFile({url: }) was passed a file without a .csv or .json suffix");
+			}
+		}
+	}
+};
+dojo.inherits(dojo.data.provider.FlatFile, dojo.data.provider.Base);
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.FlatFile.prototype.getProviderCapabilities = function(/* string */ keyword) {
+	dojo.lang.assertType(keyword, [String, "optional"]);
+	if (!this._ourCapabilities) {
+		this._ourCapabilities = {
+			transactions: false,
+			undo: false,
+			login: false,
+			versioning: false,
+			anonymousRead: true,
+			anonymousWrite: false,
+			permissions: false,
+			queries: false,
+			strongTyping: false,
+			datatypes: [String, Date, Number]
+		};
+	}
+	if (keyword) {
+		return this._ourCapabilities[keyword];
+	} else {
+		return this._ourCapabilities;
+	}
+};
+
+dojo.data.provider.FlatFile.prototype.registerAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
+	var registeredAttribute = this.getAttribute(attributeId);
+	if (!registeredAttribute) {
+		var newAttribute = new dojo.data.Attribute(this, attributeId);
+		this._dictionaryOfAttributes[attributeId] = newAttribute;
+		registeredAttribute = newAttribute;
+	}
+	return registeredAttribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.FlatFile.prototype.getAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
+	var attribute = (this._dictionaryOfAttributes[attributeId] || null);
+	return attribute; // dojo.data.Attribute or null
+};
+
+dojo.data.provider.FlatFile.prototype.getAttributes = function() {
+	var arrayOfAttributes = [];
+	for (var key in this._dictionaryOfAttributes) {
+		var attribute = this._dictionaryOfAttributes[key];
+		arrayOfAttributes.push(attribute);
+	}
+	return arrayOfAttributes; // Array
+};
+
+dojo.data.provider.FlatFile.prototype.fetchArray = function(query) {
+	/**
+	 * summary: Returns an Array containing all of the Items.
+	 */ 
+	return this._arrayOfItems; // Array
+};
+
+dojo.data.provider.FlatFile.prototype.fetchResultSet = function(query) {
+	/**
+	 * summary: Returns a ResultSet containing all of the Items.
+	 */ 
+	if (!this._resultSet) {
+		this._resultSet = new dojo.data.ResultSet(this, this.fetchArray(query));
+	}
+	return this._resultSet; // dojo.data.ResultSet
+};
+
+// -------------------------------------------------------------------
+// Private instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.FlatFile.prototype._newItem = function() {
+	var item = new dojo.data.Item(this);
+	this._arrayOfItems.push(item);
+	return item; // dojo.data.Item
+};
+
+dojo.data.provider.FlatFile.prototype._newAttribute = function(/* String */ attributeId) {
+	dojo.lang.assertType(attributeId, String);
+	dojo.lang.assert(this.getAttribute(attributeId) === null);
+	var attribute = new dojo.data.Attribute(this, attributeId);
+	this._dictionaryOfAttributes[attributeId] = attribute;
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype._getResultSets = function() {
+	return [this._resultSet]; // Array
+};
+

Added: tags/parley-0.53/root/static/magic/src/data/provider/JotSpot.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/provider/JotSpot.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/provider/JotSpot.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,27 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.provider.JotSpot");
+dojo.require("dojo.data.provider.Base");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.JotSpot = function() {
+	/**
+	 * summary:
+	 * A JotSpot Data Provider knows how to read data from a JotSpot data 
+	 * store and make the contents accessable as dojo.data.Items.
+	 */
+	dojo.unimplemented('dojo.data.provider.JotSpot');
+};
+
+dojo.inherits(dojo.data.provider.JotSpot, dojo.data.provider.Base);
+

Added: tags/parley-0.53/root/static/magic/src/data/provider/MySql.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/provider/MySql.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/provider/MySql.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,27 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.data.provider.MySql");
+dojo.require("dojo.data.provider.Base");
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.MySql = function() {
+	/**
+	 * summary:
+	 * A MySql Data Provider knows how to connect to a MySQL database
+	 * on a server and and make the content records available as 
+	 * dojo.data.Items.
+	 */
+	dojo.unimplemented('dojo.data.provider.MySql');
+};
+
+dojo.inherits(dojo.data.provider.MySql, dojo.data.provider.Base);

Added: tags/parley-0.53/root/static/magic/src/data/to_do.txt
===================================================================
--- tags/parley-0.53/root/static/magic/src/data/to_do.txt	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data/to_do.txt	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,45 @@
+Existing Features
+ * can import data from .json or .csv format files
+ * can import data from del.icio.us
+ * can create and modify data programmatically
+ * can bind data to dojo.widget.Chart
+ * can bind data to dojo.widget.SortableTable
+ * can bind one data set to multiple widgets
+ * notifications: widgets are notified when data changes
+ * notification available per-item or per-resultSet
+ * can create ad-hoc attributes
+ * attributes can be loosely-typed 
+ * attributes can have meta-data like type and display name
+ * half-implemented support for sorting
+ * half-implemented support for export to .json
+ * API for getting data in simple arrays 
+ * API for getting ResultSets with iterators (precursor to support for something like the openrico.org live grid)
+ 
+~~~~~~~~~~~~~~~~~~~~~~~~
+To-Do List
+ * be able to import data from an html <table></table>
+ * think about being able to import data from some type of XML 
+ * think about integration with dojo.undo.Manager
+ * think more about how to represent the notion of different data types
+ * think about what problems we'll run into when we have a MySQL data provider
+ * in TableBindingHack, improve support for data types in the SortableTable binding
+ * deal with ids (including MySQL multi-field keys)
+ * add support for item-references:  employeeItem.set('department', departmentItem);
+ * deal with Attributes as instances of Items, not just subclasses of Items
+ * unit tests for compare/sort code
+ * unit tests for everything
+ * implement item.toString('json') and item.toString('xml')
+ * implement dataProvider.newItem({name: 'foo', age: 26})
+ * deal better with transactions
+ * add support for deleting items
+ * don't send out multiple notifications to the same observer
+ * deal with item versions
+ * prototype a Yahoo data provider -- http://developer.yahoo.net/common/json.html
+ * prototype a data provider that enforces strong typing
+ * prototype a data provider that prevents ad-hoc attributes
+ * prototype a data provider that enforces single-kind item
+ * prototype a data provider that allows for login/authentication
+ * have loosely typed result sets play nicely with widgets that expect strong typing
+ * prototype an example of spreadsheet-style formulas or derivation rules
+ * experiment with some sort of fetch() that returns only a subset of a data provider's items
+

Modified: tags/parley-0.53/root/static/magic/src/data.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/data.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/data.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,8 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.data");
 
+// currently a stub for dojo.data
 
-dojo.provide("dojo.data");
 dojo.data = {};
-

Modified: tags/parley-0.53/root/static/magic/src/date.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/date.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/date.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,754 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.date");
 
 
-dojo.provide("dojo.date");
-dojo.deprecated("dojo.date", "use one of the modules in dojo.date.* instead", "0.5");
+/* Supplementary Date Functions
+ *******************************/
 
+dojo.date.setDayOfYear = function (dateObject, dayofyear) {
+	dateObject.setMonth(0);
+	dateObject.setDate(dayofyear);
+	return dateObject;
+}
+
+dojo.date.getDayOfYear = function (dateObject) {
+	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);
+	return Math.floor((dateObject.getTime() -
+		firstDayOfYear.getTime()) / 86400000);
+}
+
+
+
+
+dojo.date.setWeekOfYear = function (dateObject, week, firstDay) {
+	if (arguments.length == 1) { firstDay = 0; } // Sunday
+	dojo.unimplemented("dojo.date.setWeekOfYear");
+}
+
+dojo.date.getWeekOfYear = function (dateObject, firstDay) {
+	if (arguments.length == 1) { firstDay = 0; } // Sunday
+
+	// work out the first day of the year corresponding to the week
+	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);
+	var day = firstDayOfYear.getDay();
+	firstDayOfYear.setDate(firstDayOfYear.getDate() -
+			day + firstDay - (day > firstDay ? 7 : 0));
+
+	return Math.floor((dateObject.getTime() -
+		firstDayOfYear.getTime()) / 604800000);
+}
+
+
+
+
+dojo.date.setIsoWeekOfYear = function (dateObject, week, firstDay) {
+	if (arguments.length == 1) { firstDay = 1; } // Monday
+	dojo.unimplemented("dojo.date.setIsoWeekOfYear");
+}
+
+dojo.date.getIsoWeekOfYear = function (dateObject, firstDay) {
+	if (arguments.length == 1) { firstDay = 1; } // Monday
+	dojo.unimplemented("dojo.date.getIsoWeekOfYear");
+}
+
+
+
+
+/* ISO 8601 Functions
+ *********************/
+
+dojo.date.setIso8601 = function (dateObject, string){
+	var comps = (string.indexOf("T") == -1) ? string.split(" ") : string.split("T");
+	dojo.date.setIso8601Date(dateObject, comps[0]);
+	if (comps.length == 2) { dojo.date.setIso8601Time(dateObject, comps[1]); }
+	return dateObject;
+}
+
+dojo.date.fromIso8601 = function (string) {
+	return dojo.date.setIso8601(new Date(0, 0), string);
+}
+
+
+
+
+dojo.date.setIso8601Date = function (dateObject, string) {
+	var regexp = "^([0-9]{4})((-?([0-9]{2})(-?([0-9]{2}))?)|" +
+			"(-?([0-9]{3}))|(-?W([0-9]{2})(-?([1-7]))?))?$";
+	var d = string.match(new RegExp(regexp));
+	if(!d) {
+		dojo.debug("invalid date string: " + string);
+		return false;
+	}
+	var year = d[1];
+	var month = d[4];
+	var date = d[6];
+	var dayofyear = d[8];
+	var week = d[10];
+	var dayofweek = (d[12]) ? d[12] : 1;
+
+	dateObject.setYear(year);
+	
+	if (dayofyear) { dojo.date.setDayOfYear(dateObject, Number(dayofyear)); }
+	else if (week) {
+		dateObject.setMonth(0);
+		dateObject.setDate(1);
+		var gd = dateObject.getDay();
+		var day =  (gd) ? gd : 7;
+		var offset = Number(dayofweek) + (7 * Number(week));
+		
+		if (day <= 4) { dateObject.setDate(offset + 1 - day); }
+		else { dateObject.setDate(offset + 8 - day); }
+	} else {
+		if (month) { 
+			dateObject.setDate(1);
+			dateObject.setMonth(month - 1); 
+		}
+		if (date) { dateObject.setDate(date); }
+	}
+	
+	return dateObject;
+}
+
+dojo.date.fromIso8601Date = function (string) {
+	return dojo.date.setIso8601Date(new Date(0, 0), string);
+}
+
+
+
+
+dojo.date.setIso8601Time = function (dateObject, string) {
+	// first strip timezone info from the end
+	var timezone = "Z|(([-+])([0-9]{2})(:?([0-9]{2}))?)$";
+	var d = string.match(new RegExp(timezone));
+
+	var offset = 0; // local time if no tz info
+	if (d) {
+		if (d[0] != 'Z') {
+			offset = (Number(d[3]) * 60) + Number(d[5]);
+			offset *= ((d[2] == '-') ? 1 : -1);
+		}
+		offset -= dateObject.getTimezoneOffset();
+		string = string.substr(0, string.length - d[0].length);
+	}
+
+	// then work out the time
+	var regexp = "^([0-9]{2})(:?([0-9]{2})(:?([0-9]{2})(\.([0-9]+))?)?)?$";
+	var d = string.match(new RegExp(regexp));
+	if(!d) {
+		dojo.debug("invalid time string: " + string);
+		return false;
+	}
+	var hours = d[1];
+	var mins = Number((d[3]) ? d[3] : 0);
+	var secs = (d[5]) ? d[5] : 0;
+	var ms = d[7] ? (Number("0." + d[7]) * 1000) : 0;
+
+	dateObject.setHours(hours);
+	dateObject.setMinutes(mins);
+	dateObject.setSeconds(secs);
+	dateObject.setMilliseconds(ms);
+	
+	return dateObject;
+}
+
+dojo.date.fromIso8601Time = function (string) {
+	return dojo.date.setIso8601Time(new Date(0, 0), string);
+}
+
+
+
+/* Informational Functions
+ **************************/
+
+dojo.date.shortTimezones = ["IDLW", "BET", "HST", "MART", "AKST", "PST", "MST",
+	"CST", "EST", "AST", "NFT", "BST", "FST", "AT", "GMT", "CET", "EET", "MSK",
+	"IRT", "GST", "AFT", "AGTT", "IST", "NPT", "ALMT", "MMT", "JT", "AWST",
+	"JST", "ACST", "AEST", "LHST", "VUT", "NFT", "NZT", "CHAST", "PHOT",
+	"LINT"];
+dojo.date.timezoneOffsets = [-720, -660, -600, -570, -540, -480, -420, -360,
+	-300, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300,
+	330, 345, 360, 390, 420, 480, 540, 570, 600, 630, 660, 690, 720, 765, 780,
+	840];
+/*
+dojo.date.timezones = ["International Date Line West", "Bering Standard Time",
+	"Hawaiian Standard Time", "Marquesas Time", "Alaska Standard Time",
+	"Pacific Standard Time (USA)", "Mountain Standard Time",
+	"Central Standard Time (USA)", "Eastern Standard Time (USA)",
+	"Atlantic Standard Time", "Newfoundland Time", "Brazil Standard Time",
+	"Fernando de Noronha Standard Time (Brazil)", "Azores Time",
+	"Greenwich Mean Time", "Central Europe Time", "Eastern Europe Time",
+	"Moscow Time", "Iran Standard Time", "Gulf Standard Time",
+	"Afghanistan Time", "Aqtobe Time", "Indian Standard Time", "Nepal Time",
+	"Almaty Time", "Myanmar Time", "Java Time",
+	"Australian Western Standard Time", "Japan Standard Time",
+	"Australian Central Standard Time", "Lord Hove Standard Time (Australia)",
+	"Vanuata Time", "Norfolk Time (Australia)", "New Zealand Standard Time",
+	"Chatham Standard Time (New Zealand)", "Phoenix Islands Time (Kribati)",
+	"Line Islands Time (Kribati)"];
+*/
+dojo.date.months = ["January", "February", "March", "April", "May", "June",
+	"July", "August", "September", "October", "November", "December"];
+dojo.date.shortMonths = ["Jan", "Feb", "Mar", "Apr", "May", "June",
+	"July", "Aug", "Sep", "Oct", "Nov", "Dec"];
+dojo.date.days = ["Sunday", "Monday", "Tuesday", "Wednesday",
+	"Thursday", "Friday", "Saturday"];
+dojo.date.shortDays = ["Sun", "Mon", "Tues", "Wed", "Thur", "Fri", "Sat"];
+
+
+dojo.date.getDaysInMonth = function (dateObject) {
+	var month = dateObject.getMonth();
+	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+	if (month == 1 && dojo.date.isLeapYear(dateObject)) { return 29; }
+	else { return days[month]; }
+}
+
+dojo.date.isLeapYear = function (dateObject) {
+	/*
+	 * Leap years are years with an additional day YYYY-02-29, where the year
+	 * number is a multiple of four with the following exception: If a year
+	 * is a multiple of 100, then it is only a leap year if it is also a
+	 * multiple of 400. For example, 1900 was not a leap year, but 2000 is one.
+	 */
+	var year = dateObject.getFullYear();
+	return (year%400 == 0) ? true : (year%100 == 0) ? false : (year%4 == 0) ? true : false;
+}
+
+
+
+dojo.date.getDayName = function (dateObject) {
+	return dojo.date.days[dateObject.getDay()];
+}
+
+dojo.date.getDayShortName = function (dateObject) {
+	return dojo.date.shortDays[dateObject.getDay()];
+}
+
+
+
+
+dojo.date.getMonthName = function (dateObject) {
+	return dojo.date.months[dateObject.getMonth()];
+}
+
+dojo.date.getMonthShortName = function (dateObject) {
+	return dojo.date.shortMonths[dateObject.getMonth()];
+}
+
+
+
+
+dojo.date.getTimezoneName = function (dateObject) {
+	// need to negate timezones to get it right 
+	// i.e UTC+1 is CET winter, but getTimezoneOffset returns -60
+	var timezoneOffset = -(dateObject.getTimezoneOffset());
+	
+	for (var i = 0; i < dojo.date.timezoneOffsets.length; i++) {
+		if (dojo.date.timezoneOffsets[i] == timezoneOffset) {
+			return dojo.date.shortTimezones[i];
+		}
+	}
+	
+	// we don't know so return it formatted as "+HH:MM"
+	function $ (s) { s = String(s); while (s.length < 2) { s = "0" + s; } return s; }
+	return (timezoneOffset < 0 ? "-" : "+") + $(Math.floor(Math.abs(
+		timezoneOffset)/60)) + ":" + $(Math.abs(timezoneOffset)%60);
+}
+
+
+
+
+dojo.date.getOrdinal = function (dateObject) {
+	var date = dateObject.getDate();
+
+	if (date%100 != 11 && date%10 == 1) { return "st"; }
+	else if (date%100 != 12 && date%10 == 2) { return "nd"; }
+	else if (date%100 != 13 && date%10 == 3) { return "rd"; }
+	else { return "th"; }
+}
+
+
+
+/* Date Formatter Functions
+ ***************************/
+
+// POSIX strftime
+// see <http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html>
+dojo.date.format = dojo.date.strftime = function (dateObject, format) {
+
+	// zero pad
+	var padChar = null;
+	function _ (s, n) {
+		s = String(s);
+		n = (n || 2) - s.length;
+		while (n-- > 0) { s = (padChar == null ? "0" : padChar) + s; }
+		return s;
+	}
+	
+	function $ (property) {
+		switch (property) {
+			case "a": // abbreviated weekday name according to the current locale
+				return dojo.date.getDayShortName(dateObject); break;
+
+			case "A": // full weekday name according to the current locale
+				return dojo.date.getDayName(dateObject); break;
+
+			case "b":
+			case "h": // abbreviated month name according to the current locale
+				return dojo.date.getMonthShortName(dateObject); break;
+				
+			case "B": // full month name according to the current locale
+				return dojo.date.getMonthName(dateObject); break;
+				
+			case "c": // preferred date and time representation for the current
+				      // locale
+				return dateObject.toLocaleString(); break;
+
+			case "C": // century number (the year divided by 100 and truncated
+				      // to an integer, range 00 to 99)
+				return _(Math.floor(dateObject.getFullYear()/100)); break;
+				
+			case "d": // day of the month as a decimal number (range 01 to 31)
+				return _(dateObject.getDate()); break;
+				
+			case "D": // same as %m/%d/%y
+				return $("m") + "/" + $("d") + "/" + $("y"); break;
+					
+			case "e": // day of the month as a decimal number, a single digit is
+				      // preceded by a space (range ' 1' to '31')
+				if (padChar == null) { padChar = " "; }
+				return _(dateObject.getDate(), 2); break;
+			
+			case "g": // like %G, but without the century.
+				break;
+			
+			case "G": // The 4-digit year corresponding to the ISO week number
+				      // (see %V).  This has the same format and value as %Y,
+				      // except that if the ISO week number belongs to the
+				      // previous or next year, that year is used instead.
+				break;
+			
+			case "F": // same as %Y-%m-%d
+				return $("Y") + "-" + $("m") + "-" + $("d"); break;
+				
+			case "H": // hour as a decimal number using a 24-hour clock (range
+				      // 00 to 23)
+				return _(dateObject.getHours()); break;
+				
+			case "I": // hour as a decimal number using a 12-hour clock (range
+				      // 01 to 12)
+				return _(dateObject.getHours() % 12 || 12); break;
+				
+			case "j": // day of the year as a decimal number (range 001 to 366)
+				return _(dojo.date.getDayOfYear(dateObject), 3); break;
+				
+			case "m": // month as a decimal number (range 01 to 12)
+				return _(dateObject.getMonth() + 1); break;
+				
+			case "M": // minute as a decimal numbe
+				return _(dateObject.getMinutes()); break;
+			
+			case "n":
+				return "\n"; break;
+
+			case "p": // either `am' or `pm' according to the given time value,
+				      // or the corresponding strings for the current locale
+				return dateObject.getHours() < 12 ? "am" : "pm"; break;
+				
+			case "r": // time in a.m. and p.m. notation
+				return $("I") + ":" + $("M") + ":" + $("S") + " " + $("p"); break;
+				
+			case "R": // time in 24 hour notation
+				return $("H") + ":" + $("M"); break;
+				
+			case "S": // second as a decimal number
+				return _(dateObject.getSeconds()); break;
+
+			case "t":
+				return "\t"; break;
+
+			case "T": // current time, equal to %H:%M:%S
+				return $("H") + ":" + $("M") + ":" + $("S"); break;
+				
+			case "u": // weekday as a decimal number [1,7], with 1 representing
+				      // Monday
+				return String(dateObject.getDay() || 7); break;
+				
+			case "U": // week number of the current year as a decimal number,
+				      // starting with the first Sunday as the first day of the
+				      // first week
+				return _(dojo.date.getWeekOfYear(dateObject)); break;
+
+			case "V": // week number of the year (Monday as the first day of the
+				      // week) as a decimal number [01,53]. If the week containing
+				      // 1 January has four or more days in the new year, then it 
+				      // is considered week 1. Otherwise, it is the last week of 
+				      // the previous year, and the next week is week 1.
+				return _(dojo.date.getIsoWeekOfYear(dateObject)); break;
+				
+			case "W": // week number of the current year as a decimal number,
+				      // starting with the first Monday as the first day of the
+				      // first week
+				return _(dojo.date.getWeekOfYear(dateObject, 1)); break;
+				
+			case "w": // day of the week as a decimal, Sunday being 0
+				return String(dateObject.getDay()); break;
+
+			case "x": // preferred date representation for the current locale
+				      // without the time
+				break;
+
+			case "X": // preferred date representation for the current locale
+				      // without the time
+				break;
+
+			case "y": // year as a decimal number without a century (range 00 to
+				      // 99)
+				return _(dateObject.getFullYear()%100); break;
+				
+			case "Y": // year as a decimal number including the century
+				return String(dateObject.getFullYear()); break;
+			
+			case "z": // time zone or name or abbreviation
+				var timezoneOffset = dateObject.getTimezoneOffset();
+				return (timezoneOffset < 0 ? "-" : "+") + 
+					_(Math.floor(Math.abs(timezoneOffset)/60)) + ":" +
+					_(Math.abs(timezoneOffset)%60); break;
+				
+			case "Z": // time zone or name or abbreviation
+				return dojo.date.getTimezoneName(dateObject); break;
+			
+			case "%":
+				return "%"; break;
+		}
+	}
+
+	// parse the formatting string and construct the resulting string
+	var string = "";
+	var i = 0, index = 0, switchCase;
+	while ((index = format.indexOf("%", i)) != -1) {
+		string += format.substring(i, index++);
+		
+		// inspect modifier flag
+		switch (format.charAt(index++)) {
+			case "_": // Pad a numeric result string with spaces.
+				padChar = " "; break;
+			case "-": // Do not pad a numeric result string.
+				padChar = ""; break;
+			case "0": // Pad a numeric result string with zeros.
+				padChar = "0"; break;
+			case "^": // Convert characters in result string to upper case.
+				switchCase = "upper"; break;
+			case "#": // Swap the case of the result string.
+				switchCase = "swap"; break;
+			default: // no modifer flag so decremenet the index
+				padChar = null; index--; break;
+		}
+
+		// toggle case if a flag is set
+		var property = $(format.charAt(index++));
+		if (switchCase == "upper" ||
+			(switchCase == "swap" && /[a-z]/.test(property))) {
+			property = property.toUpperCase();
+		} else if (switchCase == "swap" && !/[a-z]/.test(property)) {
+			property = property.toLowerCase();
+		}
+		var swicthCase = null;
+		
+		string += property;
+		i = index;
+	}
+	string += format.substring(i);
+	
+	return string;
+}
+
+/* compare and add
+ ******************/
+dojo.date.compareTypes={
+	// 	summary
+	//	bitmask for comparison operations.
+	DATE:1, TIME:2 
+};
+dojo.date.compare=function(/* Date */ dateA, /* Date */ dateB, /* int */ options){
+	//	summary
+	//	Compare two date objects by date, time, or both.
+	var dA=dateA;
+	var dB=dateB||new Date();
+	var now=new Date();
+	var opt=options||(dojo.date.compareTypes.DATE|dojo.date.compareTypes.TIME);
+	var d1=new Date(
+		((opt&dojo.date.compareTypes.DATE)?(dA.getFullYear()):now.getFullYear()), 
+		((opt&dojo.date.compareTypes.DATE)?(dA.getMonth()):now.getMonth()), 
+		((opt&dojo.date.compareTypes.DATE)?(dA.getDate()):now.getDate()), 
+		((opt&dojo.date.compareTypes.TIME)?(dA.getHours()):0), 
+		((opt&dojo.date.compareTypes.TIME)?(dA.getMinutes()):0), 
+		((opt&dojo.date.compareTypes.TIME)?(dA.getSeconds()):0)
+	);
+	var d2=new Date(
+		((opt&dojo.date.compareTypes.DATE)?(dB.getFullYear()):now.getFullYear()), 
+		((opt&dojo.date.compareTypes.DATE)?(dB.getMonth()):now.getMonth()), 
+		((opt&dojo.date.compareTypes.DATE)?(dB.getDate()):now.getDate()), 
+		((opt&dojo.date.compareTypes.TIME)?(dB.getHours()):0), 
+		((opt&dojo.date.compareTypes.TIME)?(dB.getMinutes()):0), 
+		((opt&dojo.date.compareTypes.TIME)?(dB.getSeconds()):0)
+	);
+	if(d1.valueOf()>d2.valueOf()){
+		return 1;	//	int
+	}
+	if(d1.valueOf()<d2.valueOf()){
+		return -1;	//	int
+	}
+	return 0;	//	int
+}
+
+dojo.date.dateParts={ 
+	//	summary
+	//	constants for use in dojo.date.add
+	YEAR:0, MONTH:1, DAY:2, HOUR:3, MINUTE:4, SECOND:5, MILLISECOND:6 
+};
+dojo.date.add=function(/* Date */ d, /* dojo.date.dateParts */ unit, /* int */ amount){
+	var n=(amount)?amount:1;
+	var v;
+	switch(unit){
+		case dojo.date.dateParts.YEAR:{
+			v=new Date(d.getFullYear()+n, d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.MONTH:{
+			v=new Date(d.getFullYear(), d.getMonth()+n, d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.HOUR:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours()+n, d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.MINUTE:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes()+n, d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.SECOND:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds()+n, d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.MILLISECOND:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()+n);
+			break;
+		}
+		default:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate()+n, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+		}
+	};
+	return v;	//	Date
+};
+
+/* Deprecated
+ *************/
+
+
+dojo.date.toString = function(date, format){
+	dojo.deprecated("dojo.date.toString",
+		"use dojo.date.format instead", "0.4");
+
+	if (format.indexOf("#d") > -1) {
+		format = format.replace(/#dddd/g, dojo.date.getDayOfWeekName(date));
+		format = format.replace(/#ddd/g, dojo.date.getShortDayOfWeekName(date));
+		format = format.replace(/#dd/g, (date.getDate().toString().length==1?"0":"")+date.getDate());
+		format = format.replace(/#d/g, date.getDate());
+	}
+
+	if (format.indexOf("#M") > -1) {
+		format = format.replace(/#MMMM/g, dojo.date.getMonthName(date));
+		format = format.replace(/#MMM/g, dojo.date.getShortMonthName(date));
+		format = format.replace(/#MM/g, ((date.getMonth()+1).toString().length==1?"0":"")+(date.getMonth()+1));
+		format = format.replace(/#M/g, date.getMonth() + 1);
+	}
+
+	if (format.indexOf("#y") > -1) {
+		var fullYear = date.getFullYear().toString();
+		format = format.replace(/#yyyy/g, fullYear);
+		format = format.replace(/#yy/g, fullYear.substring(2));
+		format = format.replace(/#y/g, fullYear.substring(3));
+	}
+
+	// Return if only date needed;
+	if (format.indexOf("#") == -1) {
+		return format;
+	}
+	
+	if (format.indexOf("#h") > -1) {
+		var hours = date.getHours();
+		hours = (hours > 12 ? hours - 12 : (hours == 0) ? 12 : hours);
+		format = format.replace(/#hh/g, (hours.toString().length==1?"0":"")+hours);
+		format = format.replace(/#h/g, hours);
+	}
+	
+	if (format.indexOf("#H") > -1) {
+		format = format.replace(/#HH/g, (date.getHours().toString().length==1?"0":"")+date.getHours());
+		format = format.replace(/#H/g, date.getHours());
+	}
+	
+	if (format.indexOf("#m") > -1) {
+		format = format.replace(/#mm/g, (date.getMinutes().toString().length==1?"0":"")+date.getMinutes());
+		format = format.replace(/#m/g, date.getMinutes());
+	}
+
+	if (format.indexOf("#s") > -1) {
+		format = format.replace(/#ss/g, (date.getSeconds().toString().length==1?"0":"")+date.getSeconds());
+		format = format.replace(/#s/g, date.getSeconds());
+	}
+	
+	if (format.indexOf("#T") > -1) {
+		format = format.replace(/#TT/g, date.getHours() >= 12 ? "PM" : "AM");
+		format = format.replace(/#T/g, date.getHours() >= 12 ? "P" : "A");
+	}
+
+	if (format.indexOf("#t") > -1) {
+		format = format.replace(/#tt/g, date.getHours() >= 12 ? "pm" : "am");
+		format = format.replace(/#t/g, date.getHours() >= 12 ? "p" : "a");
+	}
+					
+	return format;
+	
+}
+
+
+dojo.date.daysInMonth = function (month, year) {
+	dojo.deprecated("daysInMonth(month, year)",
+		"replaced by getDaysInMonth(dateObject)", "0.4");
+	return dojo.date.getDaysInMonth(new Date(year, month, 1));
+}
+
+/**
+ *
+ * Returns a string of the date in the version "January 1, 2004"
+ *
+ * @param date The date object
+ */
+dojo.date.toLongDateString = function(date) {
+	dojo.deprecated("dojo.date.toLongDateString",
+		'use dojo.date.format(date, "%B %e, %Y") instead', "0.4");
+	return dojo.date.format(date, "%B %e, %Y")
+}
+
+/**
+ *
+ * Returns a string of the date in the version "Jan 1, 2004"
+ *
+ * @param date The date object
+ */
+dojo.date.toShortDateString = function(date) {
+	dojo.deprecated("dojo.date.toShortDateString",
+		'use dojo.date.format(date, "%b %e, %Y") instead', "0.4");
+	return dojo.date.format(date, "%b %e, %Y");
+}
+
+/**
+ *
+ * Returns military formatted time
+ *
+ * @param date the date object
+ */
+dojo.date.toMilitaryTimeString = function(date){
+	dojo.deprecated("dojo.date.toMilitaryTimeString",
+		'use dojo.date.format(date, "%T")', "0.4");
+	return dojo.date.format(date, "%T");
+}
+
+/**
+ *
+ * Returns a string of the date relative to the current date.
+ *
+ * @param date The date object
+ *
+ * Example returns:
+ * - "1 minute ago"
+ * - "4 minutes ago"
+ * - "Yesterday"
+ * - "2 days ago"
+ */
+dojo.date.toRelativeString = function(date) {
+	var now = new Date();
+	var diff = (now - date) / 1000;
+	var end = " ago";
+	var future = false;
+	if(diff < 0) {
+		future = true;
+		end = " from now";
+		diff = -diff;
+	}
+
+	if(diff < 60) {
+		diff = Math.round(diff);
+		return diff + " second" + (diff == 1 ? "" : "s") + end;
+	} else if(diff < 3600) {
+		diff = Math.round(diff/60);
+		return diff + " minute" + (diff == 1 ? "" : "s") + end;
+	} else if(diff < 3600*24 && date.getDay() == now.getDay()) {
+		diff = Math.round(diff/3600);
+		return diff + " hour" + (diff == 1 ? "" : "s") + end;
+	} else if(diff < 3600*24*7) {
+		diff = Math.round(diff/(3600*24));
+		if(diff == 1) {
+			return future ? "Tomorrow" : "Yesterday";
+		} else {
+			return diff + " days" + end;
+		}
+	} else {
+		return dojo.date.toShortDateString(date);
+	}
+}
+
+/**
+ * Retrieves the day of the week the Date is set to.
+ *
+ * @return The day of the week
+ */
+dojo.date.getDayOfWeekName = function (date) {
+	dojo.deprecated("dojo.date.getDayOfWeekName",
+		"use dojo.date.getDayName instead", "0.4");
+	return dojo.date.days[date.getDay()];
+}
+
+/**
+ * Retrieves the short day of the week name the Date is set to.
+ *
+ * @return The short day of the week name
+ */
+dojo.date.getShortDayOfWeekName = function (date) {
+	dojo.deprecated("dojo.date.getShortDayOfWeekName",
+		"use dojo.date.getDayShortName instead", "0.4");
+	return dojo.date.shortDays[date.getDay()];
+}
+
+/**
+ * Retrieves the short month name the Date is set to.
+ *
+ * @return The short month name
+ */
+dojo.date.getShortMonthName = function (date) {
+	dojo.deprecated("dojo.date.getShortMonthName",
+		"use dojo.date.getMonthShortName instead", "0.4");
+	return dojo.date.shortMonths[date.getMonth()];
+}
+
+
+/**
+ * Convert a Date to a SQL string, optionally ignoring the HH:MM:SS portion of the Date
+ */
+dojo.date.toSql = function(date, noTime) {
+	return dojo.date.format(date, "%F" + !noTime ? " %T" : "");
+}
+
+/**
+ * Convert a SQL date string to a JavaScript Date object
+ */
+dojo.date.fromSql = function(sqlDate) {
+	var parts = sqlDate.split(/[\- :]/g);
+	while(parts.length < 6) {
+		parts.push(0);
+	}
+	return new Date(parts[0], (parseInt(parts[1],10)-1), parts[2], parts[3], parts[4], parts[5]);
+}
+

Modified: tags/parley-0.53/root/static/magic/src/debug/Firebug.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/debug/Firebug.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/debug/Firebug.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,50 +8,10 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.debug.Firebug");
-dojo.deprecated("dojo.debug.Firebug is slated for removal in 0.5; use dojo.debug.console instead.", "0.5");
-if (dojo.render.html.moz) {
-	if (console && console.log) {
-		var consoleLog = function () {
-			if (!djConfig.isDebug) {
-				return;
-			}
-			var args = dojo.lang.toArray(arguments);
-			args.splice(0, 0, "DEBUG: ");
-			console.log.apply(console, args);
-		};
-		dojo.debug = consoleLog;
-		dojo.debugDeep = consoleLog;
-		dojo.debugShallow = function (obj) {
-			if (!djConfig.isDebug) {
-				return;
-			}
-			if (dojo.lang.isArray(obj)) {
-				console.log("Array: ", obj);
-				for (var i = 0; x < obj.length; i++) {
-					console.log("	", "[" + i + "]", obj[i]);
-				}
-			} else {
-				console.log("Object: ", obj);
-				var propNames = [];
-				for (var prop in obj) {
-					propNames.push(prop);
-				}
-				propNames.sort();
-				dojo.lang.forEach(propNames, function (prop) {
-					try {
-						console.log("	", prop, obj[prop]);
-					}
-					catch (e) {
-						console.log("	", prop, "ERROR", e.message, e);
-					}
-				});
-			}
-		};
-	} else {
-		dojo.debug("dojo.debug.Firebug requires Firebug > 0.4");
-	}
-}
 
+if (console.log) {
+	dojo.hostenv.println=console.log;
+} else {
+	dojo.debug("dojo.debug.Firebug requires Firebug > 0.4");
+}

Deleted: tags/parley-0.53/root/static/magic/src/debug/console.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/debug/console.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/debug/console.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,97 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.debug.console");
-dojo.require("dojo.logging.ConsoleLogger");
-if (window.console) {
-	if (console.info != null) {
-		dojo.hostenv.println = function () {
-			if (!djConfig.isDebug) {
-				return;
-			}
-			console.info.apply(console, arguments);
-		};
-		dojo.debug = dojo.hostenv.println;
-		dojo.debugDeep = dojo.debug;
-		dojo.debugShallow = function (obj, showMethods, sort) {
-			if (!djConfig.isDebug) {
-				return;
-			}
-			showMethods = (showMethods != false);
-			sort = (sort != false);
-			if (obj == null || obj.constructor == null) {
-				return dojo.debug(obj);
-			}
-			var type = obj.declaredClass;
-			if (type == null) {
-				type = obj.constructor.toString().match(/function\s*(.*)\(/);
-				if (type) {
-					type = type[1];
-				}
-			}
-			if (type) {
-				if (type == "String" || type == "Number") {
-					return dojo.debug(type + ": ", obj);
-				}
-				if (showMethods && !sort) {
-					var sortedObj = obj;
-				} else {
-					var propNames = [];
-					if (showMethods) {
-						for (var prop in obj) {
-							propNames.push(prop);
-						}
-					} else {
-						for (var prop in obj) {
-							if (typeof obj[prop] != "function") {
-								propNames.push(prop);
-							} else {
-								dojo.debug(prop);
-							}
-						}
-					}
-					if (sort) {
-						propNames.sort();
-					}
-					var sortedObj = {};
-					dojo.lang.forEach(propNames, function (prop) {
-						sortedObj[prop] = obj[prop];
-					});
-				}
-				return dojo.debug(type + ": %o\n%2.o", obj, sortedObj);
-			}
-			return dojo.debug(obj.constructor + ": ", obj);
-		};
-	} else {
-		if (console.log != null) {
-			dojo.hostenv.println = function () {
-				if (!djConfig.isDebug) {
-					return;
-				}
-				var args = dojo.lang.toArray(arguments);
-				console.log("DEBUG: " + args.join(" "));
-			};
-			dojo.debug = dojo.hostenv.println;
-		} else {
-			dojo.debug("dojo.debug.console requires Firebug > 0.4");
-		}
-	}
-} else {
-	if (dojo.render.html.opera) {
-		if (opera && opera.postError) {
-			dojo.hostenv.println = opera.postError;
-		} else {
-			dojo.debug("dojo.debug.Opera requires Opera > 8.0");
-		}
-	}
-}
-

Modified: tags/parley-0.53/root/static/magic/src/debug/deep.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/debug/deep.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/debug/deep.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -21,14 +21,11 @@
 
 function startMeUp(){
 	frame = document.getElementById('frame');
-	// GET string 
-	var index = location.search.split("=").pop();
-	var debugObj = window.opener.dojo.debugDeep;
-	var debugVar = debugObj.debugVars[index] || window.debugVar;
-	buildTable('root', frame, debugVar);
+	buildTable('root', frame, window.debugVar);
 }
 
 function buildTable(path, parent, obj){
+
 	var keys = [];
 	var vals = [];
 	for(var prop in obj){

Modified: tags/parley-0.53/root/static/magic/src/debug.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/debug.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/debug.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,28 +8,30 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.debug");
-dojo.debug = function () {
-	if (!djConfig.isDebug) {
-		return;
-	}
+/**
+ * Produce a line of debug output. 
+ * Does nothing unless djConfig.isDebug is true.
+ * varargs, joined with ''.
+ * Caller should not supply a trailing "\n".
+ */
+dojo.debug = function(){
+	if (!djConfig.isDebug) { return; }
 	var args = arguments;
-	if (dj_undef("println", dojo.hostenv)) {
+	if(dj_undef("println", dojo.hostenv)){
 		dojo.raise("dojo.debug not available (yet?)");
 	}
 	var isJUM = dj_global["jum"] && !dj_global["jum"].isBrowser;
-	var s = [(isJUM ? "" : "DEBUG: ")];
-	for (var i = 0; i < args.length; ++i) {
-		if (!false && args[i] && args[i] instanceof Error) {
-			var msg = "[" + args[i].name + ": " + dojo.errorToString(args[i]) + (args[i].fileName ? ", file: " + args[i].fileName : "") + (args[i].lineNumber ? ", line: " + args[i].lineNumber : "") + "]";
+	var s = [(isJUM ? "": "DEBUG: ")];
+	for(var i=0;i<args.length;++i){
+		if(!false && args[i] && args[i] instanceof Error){
+			var msg = "[" + args[i].name + ": " + dojo.errorToString(args[i]) +
+				(args[i].fileName ? ", file: " + args[i].fileName : "") +
+				(args[i].lineNumber ? ", line: " + args[i].lineNumber : "") + "]";
 		} else {
 			try {
 				var msg = String(args[i]);
-			}
-			catch (e) {
-				if (dojo.render.html.ie) {
+			} catch(e) {
+				if(dojo.render.html.ie) {
 					var msg = "[ActiveXObject]";
 				} else {
 					var msg = "[unknown]";
@@ -38,48 +40,41 @@
 		}
 		s.push(msg);
 	}
-	dojo.hostenv.println(s.join(" "));
-};
-dojo.debugShallow = function (obj) {
-	if (!djConfig.isDebug) {
-		return;
+	if(isJUM){ // this seems to be the only way to get JUM to "play nice"
+		jum.debug(s.join(" "));
+	}else{
+		dojo.hostenv.println(s.join(" "));
 	}
-	dojo.debug("------------------------------------------------------------");
-	dojo.debug("Object: " + obj);
+}
+
+/**
+ * this is really hacky for now - just 
+ * display the properties of the object
+**/
+
+dojo.debugShallow = function(obj){
+	if (!djConfig.isDebug) { return; }
+	dojo.debug('------------------------------------------------------------');
+	dojo.debug('Object: '+obj);
 	var props = [];
-	for (var prop in obj) {
+	for(var prop in obj){
 		try {
-			props.push(prop + ": " + obj[prop]);
+			props.push(prop + ': ' + obj[prop]);
+		} catch(E) {
+			props.push(prop + ': ERROR - ' + E.message);
 		}
-		catch (E) {
-			props.push(prop + ": ERROR - " + E.message);
-		}
 	}
 	props.sort();
-	for (var i = 0; i < props.length; i++) {
+	for(var i = 0; i < props.length; i++) {
 		dojo.debug(props[i]);
 	}
-	dojo.debug("------------------------------------------------------------");
-};
-dojo.debugDeep = function (obj) {
-	if (!djConfig.isDebug) {
-		return;
-	}
-	if (!dojo.uri || !dojo.uri.dojoUri) {
-		return dojo.debug("You'll need to load dojo.uri.* for deep debugging - sorry!");
-	}
-	if (!window.open) {
-		return dojo.debug("Deep debugging is only supported in host environments with window.open");
-	}
-	var idx = dojo.debugDeep.debugVars.length;
-	dojo.debugDeep.debugVars.push(obj);
-	var url = (djConfig["dojoDebugDeepHtmlUrl"] || new dojo.uri.Uri(location, dojo.uri.moduleUri("dojo.debug", "deep.html")).toString()) + "?var=" + idx;
-	var win = window.open(url, "_blank", "width=600, height=400, resizable=yes, scrollbars=yes, status=yes");
-	try {
-		win.debugVar = obj;
-	}
-	catch (e) {
-	}
-};
-dojo.debugDeep.debugVars = [];
+	dojo.debug('------------------------------------------------------------');
+}
 
+dojo.debugDeep = function(obj){
+	if (!djConfig.isDebug) { return; }
+	if (!dojo.uri || !dojo.uri.dojoUri){ return dojo.debug("You'll need to load dojo.uri.* for deep debugging - sorry!"); }
+	if (!window.open){ return dojo.debug('Deep debugging is only supported in host environments with window.open'); }
+	var win = window.open(dojo.uri.dojoUri("src/debug/deep.html"), '_blank', 'width=600, height=400, resizable=yes, scrollbars=yes, status=yes');
+	win.debugVar = obj;
+}

Modified: tags/parley-0.53/root/static/magic/src/dnd/DragAndDrop.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/DragAndDrop.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/DragAndDrop.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,69 +8,168 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.require("dojo.lang");
+dojo.provide("dojo.dnd.DragSource");
+dojo.provide("dojo.dnd.DropTarget");
+dojo.provide("dojo.dnd.DragObject");
+dojo.provide("dojo.dnd.DragAndDrop");
 
+dojo.dnd.DragSource = function(){
+	var dm = dojo.dnd.dragManager;
+	if(dm["registerDragSource"]){ // side-effect prevention
+		dm.registerDragSource(this);
+	}
+}
 
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.func");
-dojo.require("dojo.lang.declare");
-dojo.provide("dojo.dnd.DragAndDrop");
-dojo.declare("dojo.dnd.DragSource", null, {type:"", onDragEnd:function (evt) {
-}, onDragStart:function (evt) {
-}, onSelected:function (evt) {
-}, unregister:function () {
-	dojo.dnd.dragManager.unregisterDragSource(this);
-}, reregister:function () {
-	dojo.dnd.dragManager.registerDragSource(this);
-}});
-dojo.declare("dojo.dnd.DragObject", null, {type:"", register:function () {
+dojo.lang.extend(dojo.dnd.DragSource, {
+	type: "",
+
+	onDragEnd: function(){
+	},
+
+	onDragStart: function(){
+	},
+
+	/*
+	 * This function gets called when the DOM element was 
+	 * selected for dragging by the HtmlDragAndDropManager.
+	 */
+	onSelected: function(){
+	},
+
+	unregister: function(){
+		dojo.dnd.dragManager.unregisterDragSource(this);
+	},
+
+	reregister: function(){
+		dojo.dnd.dragManager.registerDragSource(this);
+	}
+});
+
+dojo.dnd.DragObject = function(){
 	var dm = dojo.dnd.dragManager;
-	if (dm["registerDragObject"]) {
+	if(dm["registerDragObject"]){ // side-effect prevention
 		dm.registerDragObject(this);
 	}
-}, onDragStart:function (evt) {
-}, onDragMove:function (evt) {
-}, onDragOver:function (evt) {
-}, onDragOut:function (evt) {
-}, onDragEnd:function (evt) {
-}, onDragLeave:dojo.lang.forward("onDragOut"), onDragEnter:dojo.lang.forward("onDragOver"), ondragout:dojo.lang.forward("onDragOut"), ondragover:dojo.lang.forward("onDragOver")});
-dojo.declare("dojo.dnd.DropTarget", null, {acceptsType:function (type) {
-	if (!dojo.lang.inArray(this.acceptedTypes, "*")) {
-		if (!dojo.lang.inArray(this.acceptedTypes, type)) {
-			return false;
+}
+
+dojo.lang.extend(dojo.dnd.DragObject, {
+	type: "",
+
+	onDragStart: function(){
+		// gets called directly after being created by the DragSource
+		// default action is to clone self as icon
+	},
+
+	onDragMove: function(){
+		// this changes the UI for the drag icon
+		//	"it moves itself"
+	},
+
+	onDragOver: function(){
+	},
+
+	onDragOut: function(){
+	},
+
+	onDragEnd: function(){
+	},
+
+	// normal aliases
+	onDragLeave: this.onDragOut,
+	onDragEnter: this.onDragOver,
+
+	// non-camel aliases
+	ondragout: this.onDragOut,
+	ondragover: this.onDragOver
+});
+
+dojo.dnd.DropTarget = function(){
+	if (this.constructor == dojo.dnd.DropTarget) { return; } // need to be subclassed
+	this.acceptedTypes = [];
+	dojo.dnd.dragManager.registerDropTarget(this);
+}
+
+dojo.lang.extend(dojo.dnd.DropTarget, {
+
+	acceptsType: function(type){
+		if(!dojo.lang.inArray(this.acceptedTypes, "*")){ // wildcard
+			if(!dojo.lang.inArray(this.acceptedTypes, type)) { return false; }
 		}
-	}
-	return true;
-}, accepts:function (dragObjects) {
-	if (!dojo.lang.inArray(this.acceptedTypes, "*")) {
-		for (var i = 0; i < dragObjects.length; i++) {
-			if (!dojo.lang.inArray(this.acceptedTypes, dragObjects[i].type)) {
-				return false;
+		return true;
+	},
+
+	accepts: function(dragObjects){
+		if(!dojo.lang.inArray(this.acceptedTypes, "*")){ // wildcard
+			for (var i = 0; i < dragObjects.length; i++) {
+				if (!dojo.lang.inArray(this.acceptedTypes,
+					dragObjects[i].type)) { return false; }
 			}
 		}
+		return true;
+	},
+
+	onDragOver: function(){
+	},
+
+	onDragOut: function(){
+	},
+
+	onDragMove: function(){
+	},
+
+	onDropStart: function(){
+	},
+
+	onDrop: function(){
+	},
+
+	onDropEnd: function(){
 	}
-	return true;
-}, unregister:function () {
-	dojo.dnd.dragManager.unregisterDropTarget(this);
-}, onDragOver:function (evt) {
-}, onDragOut:function (evt) {
-}, onDragMove:function (evt) {
-}, onDropStart:function (evt) {
-}, onDrop:function (evt) {
-}, onDropEnd:function () {
-}}, function () {
-	this.acceptedTypes = [];
 });
-dojo.dnd.DragEvent = function () {
+
+// NOTE: this interface is defined here for the convenience of the DragManager
+// implementor. It is expected that in most cases it will be satisfied by
+// extending a native event (DOM event in HTML and SVG).
+dojo.dnd.DragEvent = function(){
 	this.dragSource = null;
 	this.dragObject = null;
 	this.target = null;
 	this.eventStatus = "success";
-};
-dojo.declare("dojo.dnd.DragManager", null, {selectedSources:[], dragObjects:[], dragSources:[], registerDragSource:function (source) {
-}, dropTargets:[], registerDropTarget:function (target) {
-}, lastDragTarget:null, currentDragTarget:null, onKeyDown:function () {
-}, onMouseOut:function () {
-}, onMouseMove:function () {
-}, onMouseUp:function () {
-}});
+	//
+	// can be one of:
+	//	[	"dropSuccess", "dropFailure", "dragMove",
+	//		"dragStart", "dragEnter", "dragLeave"]
+	//
+}
 
+dojo.dnd.DragManager = function(){
+	/*
+	 *	The DragManager handles listening for low-level events and dispatching
+	 *	them to higher-level primitives like drag sources and drop targets. In
+	 *	order to do this, it must keep a list of the items.
+	 */
+}
+
+dojo.lang.extend(dojo.dnd.DragManager, {
+	selectedSources: [],
+	dragObjects: [],
+	dragSources: [],
+	registerDragSource: function(){},
+	dropTargets: [],
+	registerDropTarget: function(){},
+	lastDragTarget: null,
+	currentDragTarget: null,
+	onKeyDown: function(){},
+	onMouseOut: function(){},
+	onMouseMove: function(){},
+	onMouseUp: function(){}
+});
+
+// NOTE: despite the existance of the DragManager class, there will be a
+// singleton drag manager provided by the renderer-specific D&D support code.
+// It is therefore sane for us to assign instance variables to the DragManager
+// prototype
+
+// The renderer-specific file will define the following object:
+// dojo.dnd.dragManager = null;

Modified: tags/parley-0.53/root/static/magic/src/dnd/HtmlDragAndDrop.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/HtmlDragAndDrop.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/HtmlDragAndDrop.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,362 +8,468 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.dnd.HtmlDragAndDrop");
+dojo.provide("dojo.dnd.HtmlDragSource");
+dojo.provide("dojo.dnd.HtmlDropTarget");
+dojo.provide("dojo.dnd.HtmlDragObject");
 
-
-dojo.provide("dojo.dnd.HtmlDragAndDrop");
 dojo.require("dojo.dnd.HtmlDragManager");
 dojo.require("dojo.dnd.DragAndDrop");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.util");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.html.iframe");
+
+dojo.require("dojo.dom");
+dojo.require("dojo.style");
+dojo.require("dojo.html");
+dojo.require("dojo.html.extras");
 dojo.require("dojo.lang.extras");
 dojo.require("dojo.lfx.*");
-dojo.require("dojo.event.*");
-dojo.declare("dojo.dnd.HtmlDragSource", dojo.dnd.DragSource, {dragClass:"", onDragStart:function () {
-	var dragObj = new dojo.dnd.HtmlDragObject(this.dragObject, this.type);
-	if (this.dragClass) {
-		dragObj.dragClass = this.dragClass;
-	}
-	if (this.constrainToContainer) {
-		dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
-	}
-	return dragObj;
-}, setDragHandle:function (node) {
+dojo.require("dojo.event");
+
+dojo.dnd.HtmlDragSource = function(node, type){
 	node = dojo.byId(node);
-	dojo.dnd.dragManager.unregisterDragSource(this);
-	this.domNode = node;
-	dojo.dnd.dragManager.registerDragSource(this);
-}, setDragTarget:function (node) {
-	this.dragObject = node;
-}, constrainTo:function (container) {
-	this.constrainToContainer = true;
-	if (container) {
-		this.constrainingContainer = container;
-	}
-}, onSelected:function () {
-	for (var i = 0; i < this.dragObjects.length; i++) {
-		dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragSource(this.dragObjects[i]));
-	}
-}, addDragObjects:function (el) {
-	for (var i = 0; i < arguments.length; i++) {
-		this.dragObjects.push(dojo.byId(arguments[i]));
-	}
-}}, function (node, type) {
-	node = dojo.byId(node);
 	this.dragObjects = [];
 	this.constrainToContainer = false;
-	if (node) {
+	if(node){
 		this.domNode = node;
 		this.dragObject = node;
-		this.type = (type) || (this.domNode.nodeName.toLowerCase());
-		dojo.dnd.DragSource.prototype.reregister.call(this);
+		// register us
+		dojo.dnd.DragSource.call(this);
+		// set properties that might have been clobbered by the mixin
+		this.type = (type)||(this.domNode.nodeName.toLowerCase());
 	}
+}
+dojo.inherits(dojo.dnd.HtmlDragSource, dojo.dnd.DragSource);
+dojo.lang.extend(dojo.dnd.HtmlDragSource, {
+	dragClass: "", // CSS classname(s) applied to node when it is being dragged
+
+	onDragStart: function(){
+		var dragObj = new dojo.dnd.HtmlDragObject(this.dragObject, this.type);
+		if(this.dragClass) { dragObj.dragClass = this.dragClass; }
+
+		if (this.constrainToContainer) {
+			dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
+		}
+
+		return dragObj;
+	},
+
+	setDragHandle: function(node){
+		node = dojo.byId(node);
+		dojo.dnd.dragManager.unregisterDragSource(this);
+		this.domNode = node;
+		dojo.dnd.dragManager.registerDragSource(this);
+	},
+
+	setDragTarget: function(node){
+		this.dragObject = node;
+	},
+
+	constrainTo: function(container) {
+		this.constrainToContainer = true;
+		if (container) {
+			this.constrainingContainer = container;
+		}
+	},
+	
+	/*
+	*
+	* see dojo.dnd.DragSource.onSelected
+	*/
+	onSelected: function() {
+		for (var i=0; i<this.dragObjects.length; i++) {
+			dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragSource(this.dragObjects[i]));
+		}
+	},
+
+	/**
+	* Register elements that should be dragged along with
+	* the actual DragSource.
+	*
+	* Example usage:
+	* 	var dragSource = new dojo.dnd.HtmlDragSource(...);
+	*	// add a single element
+	*	dragSource.addDragObjects(dojo.byId('id1'));
+	*	// add multiple elements to drag along
+	*	dragSource.addDragObjects(dojo.byId('id2'), dojo.byId('id3'));
+	*
+	* el A dom node to add to the drag list.
+	*/
+	addDragObjects: function(/*DOMNode*/ el) {
+		for (var i=0; i<arguments.length; i++) {
+			this.dragObjects.push(arguments[i]);
+		}
+	}
 });
-dojo.declare("dojo.dnd.HtmlDragObject", dojo.dnd.DragObject, {dragClass:"", opacity:0.5, createIframe:true, disableX:false, disableY:false, createDragNode:function () {
-	var node = this.domNode.cloneNode(true);
-	if (this.dragClass) {
-		dojo.html.addClass(node, this.dragClass);
-	}
-	if (this.opacity < 1) {
-		dojo.html.setOpacity(node, this.opacity);
-	}
-	var ltn = node.tagName.toLowerCase();
-	var isTr = (ltn == "tr");
-	if ((isTr) || (ltn == "tbody")) {
-		var doc = this.domNode.ownerDocument;
-		var table = doc.createElement("table");
-		if (isTr) {
+
+dojo.dnd.HtmlDragObject = function(node, type){
+	this.domNode = dojo.byId(node);
+	this.type = type;
+	this.constrainToContainer = false;
+	this.dragSource = null;
+}
+dojo.inherits(dojo.dnd.HtmlDragObject, dojo.dnd.DragObject);
+dojo.lang.extend(dojo.dnd.HtmlDragObject, {
+	dragClass: "",
+	opacity: 0.5,
+	createIframe: true,		// workaround IE6 bug
+
+	// if true, node will not move in X and/or Y direction
+	disableX: false,
+	disableY: false,
+
+	createDragNode: function() {
+		var node = this.domNode.cloneNode(true);
+		if(this.dragClass) { dojo.html.addClass(node, this.dragClass); }
+		if(this.opacity < 1) { dojo.style.setOpacity(node, this.opacity); }
+		if(node.tagName.toLowerCase() == "tr"){
+			// dojo.debug("Dragging table row")
+			// Create a table for the cloned row
+			var doc = this.domNode.ownerDocument;
+			var table = doc.createElement("table");
 			var tbody = doc.createElement("tbody");
+			tbody.appendChild(node);
 			table.appendChild(tbody);
-			tbody.appendChild(node);
-		} else {
-			table.appendChild(node);
+
+			// Set a fixed width to the cloned TDs
+			var domTds = this.domNode.childNodes;
+			var cloneTds = node.childNodes;
+			for(var i = 0; i < domTds.length; i++){
+			    if((cloneTds[i])&&(cloneTds[i].style)){
+				    cloneTds[i].style.width = dojo.style.getContentWidth(domTds[i]) + "px";
+			    }
+			}
+			node = table;
 		}
-		var tmpSrcTr = ((isTr) ? this.domNode : this.domNode.firstChild);
-		var tmpDstTr = ((isTr) ? node : node.firstChild);
-		var domTds = tmpSrcTr.childNodes;
-		var cloneTds = tmpDstTr.childNodes;
-		for (var i = 0; i < domTds.length; i++) {
-			if ((cloneTds[i]) && (cloneTds[i].style)) {
-				cloneTds[i].style.width = dojo.html.getContentBox(domTds[i]).width + "px";
+
+		if((dojo.render.html.ie55||dojo.render.html.ie60) && this.createIframe){
+			with(node.style) {
+				top="0px";
+				left="0px";
 			}
+			var outer = document.createElement("div");
+			outer.appendChild(node);
+			this.bgIframe = new dojo.html.BackgroundIframe(outer);
+			outer.appendChild(this.bgIframe.iframe);
+			node = outer;
 		}
-		node = table;
-	}
-	if ((dojo.render.html.ie55 || dojo.render.html.ie60) && this.createIframe) {
-		with (node.style) {
-			top = "0px";
-			left = "0px";
+		node.style.zIndex = 999;
+		return node;
+	},
+
+	onDragStart: function(e){
+		dojo.html.clearSelection();
+
+		this.scrollOffset = dojo.html.getScrollOffset();
+		this.dragStartPosition = dojo.style.getAbsolutePosition(this.domNode, true);
+
+		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
+			x: this.dragStartPosition.x - e.pageX};
+
+		this.dragClone = this.createDragNode();
+
+		this.containingBlockPosition = this.domNode.offsetParent ? 
+			dojo.style.getAbsolutePosition(this.domNode.offsetParent) : {x:0, y:0};
+
+		if (this.constrainToContainer) {
+			this.constraints = this.getConstraints();
 		}
-		var outer = document.createElement("div");
-		outer.appendChild(node);
-		this.bgIframe = new dojo.html.BackgroundIframe(outer);
-		outer.appendChild(this.bgIframe.iframe);
-		node = outer;
-	}
-	node.style.zIndex = 999;
-	return node;
-}, onDragStart:function (e) {
-	dojo.html.clearSelection();
-	this.scrollOffset = dojo.html.getScroll().offset;
-	this.dragStartPosition = dojo.html.getAbsolutePosition(this.domNode, true);
-	this.dragOffset = {y:this.dragStartPosition.y - e.pageY, x:this.dragStartPosition.x - e.pageX};
-	this.dragClone = this.createDragNode();
-	this.containingBlockPosition = this.domNode.offsetParent ? dojo.html.getAbsolutePosition(this.domNode.offsetParent, true) : {x:0, y:0};
-	if (this.constrainToContainer) {
-		this.constraints = this.getConstraints();
-	}
-	with (this.dragClone.style) {
-		position = "absolute";
-		top = this.dragOffset.y + e.pageY + "px";
-		left = this.dragOffset.x + e.pageX + "px";
-	}
-	dojo.body().appendChild(this.dragClone);
-	dojo.event.topic.publish("dragStart", {source:this});
-}, getConstraints:function () {
-	if (this.constrainingContainer.nodeName.toLowerCase() == "body") {
-		var viewport = dojo.html.getViewport();
-		var width = viewport.width;
-		var height = viewport.height;
-		var scroll = dojo.html.getScroll().offset;
-		var x = scroll.x;
-		var y = scroll.y;
-	} else {
-		var content = dojo.html.getContentBox(this.constrainingContainer);
-		width = content.width;
-		height = content.height;
-		x = this.containingBlockPosition.x + dojo.html.getPixelValue(this.constrainingContainer, "padding-left", true) + dojo.html.getBorderExtent(this.constrainingContainer, "left");
-		y = this.containingBlockPosition.y + dojo.html.getPixelValue(this.constrainingContainer, "padding-top", true) + dojo.html.getBorderExtent(this.constrainingContainer, "top");
-	}
-	var mb = dojo.html.getMarginBox(this.domNode);
-	return {minX:x, minY:y, maxX:x + width - mb.width, maxY:y + height - mb.height};
-}, updateDragOffset:function () {
-	var scroll = dojo.html.getScroll().offset;
-	if (scroll.y != this.scrollOffset.y) {
-		var diff = scroll.y - this.scrollOffset.y;
-		this.dragOffset.y += diff;
-		this.scrollOffset.y = scroll.y;
-	}
-	if (scroll.x != this.scrollOffset.x) {
-		var diff = scroll.x - this.scrollOffset.x;
-		this.dragOffset.x += diff;
-		this.scrollOffset.x = scroll.x;
-	}
-}, onDragMove:function (e) {
-	this.updateDragOffset();
-	var x = this.dragOffset.x + e.pageX;
-	var y = this.dragOffset.y + e.pageY;
-	if (this.constrainToContainer) {
-		if (x < this.constraints.minX) {
-			x = this.constraints.minX;
+
+		// set up for dragging
+		with(this.dragClone.style){
+			position = "absolute";
+			top = this.dragOffset.y + e.pageY + "px";
+			left = this.dragOffset.x + e.pageX + "px";
 		}
-		if (y < this.constraints.minY) {
-			y = this.constraints.minY;
+
+		document.body.appendChild(this.dragClone);
+
+		dojo.event.topic.publish('dragStart', { source: this } );
+	},
+
+	/** Return min/max x/y (relative to document.body) for this object) **/
+	getConstraints: function() {
+		if (this.constrainingContainer.nodeName.toLowerCase() == 'body') {
+			var width = dojo.html.getViewportWidth();
+			var height = dojo.html.getViewportHeight();
+			var x = 0;
+			var y = 0;
+		} else {
+			width = dojo.style.getContentWidth(this.constrainingContainer);
+			height = dojo.style.getContentHeight(this.constrainingContainer);
+			x =
+				this.containingBlockPosition.x +
+				dojo.style.getPixelValue(this.constrainingContainer, "padding-left", true) +
+				dojo.style.getBorderExtent(this.constrainingContainer, "left");
+			y =
+				this.containingBlockPosition.y +
+				dojo.style.getPixelValue(this.constrainingContainer, "padding-top", true) +
+				dojo.style.getBorderExtent(this.constrainingContainer, "top");
 		}
-		if (x > this.constraints.maxX) {
-			x = this.constraints.maxX;
+
+		return {
+			minX: x,
+			minY: y,
+			maxX: x + width - dojo.style.getOuterWidth(this.domNode),
+			maxY: y + height - dojo.style.getOuterHeight(this.domNode)
 		}
-		if (y > this.constraints.maxY) {
-			y = this.constraints.maxY;
+	},
+
+	updateDragOffset: function() {
+		var scroll = dojo.html.getScrollOffset();
+		if(scroll.y != this.scrollOffset.y) {
+			var diff = scroll.y - this.scrollOffset.y;
+			this.dragOffset.y += diff;
+			this.scrollOffset.y = scroll.y;
 		}
+		if(scroll.x != this.scrollOffset.x) {
+			var diff = scroll.x - this.scrollOffset.x;
+			this.dragOffset.x += diff;
+			this.scrollOffset.x = scroll.x;
+		}
+	},
+
+	/** Moves the node to follow the mouse */
+	onDragMove: function(e){
+		this.updateDragOffset();
+		var x = this.dragOffset.x + e.pageX;
+		var y = this.dragOffset.y + e.pageY;
+
+		if (this.constrainToContainer) {
+			if (x < this.constraints.minX) { x = this.constraints.minX; }
+			if (y < this.constraints.minY) { y = this.constraints.minY; }
+			if (x > this.constraints.maxX) { x = this.constraints.maxX; }
+			if (y > this.constraints.maxY) { y = this.constraints.maxY; }
+		}
+
+		this.setAbsolutePosition(x, y);
+
+		dojo.event.topic.publish('dragMove', { source: this } );
+	},
+
+	/**
+	 * Set the position of the drag clone.  (x,y) is relative to <body>.
+	 */
+	setAbsolutePosition: function(x, y){
+		// The drag clone is attached to document.body so this is trivial
+		if(!this.disableY) { this.dragClone.style.top = y + "px"; }
+		if(!this.disableX) { this.dragClone.style.left = x + "px"; }
+	},
+
+
+	/**
+	 * If the drag operation returned a success we reomve the clone of
+	 * ourself from the original position. If the drag operation returned
+	 * failure we slide back over to where we came from and end the operation
+	 * with a little grace.
+	 */
+	onDragEnd: function(e){
+		switch(e.dragStatus){
+
+			case "dropSuccess":
+				dojo.dom.removeNode(this.dragClone);
+				this.dragClone = null;
+				break;
+
+			case "dropFailure": // slide back to the start
+				var startCoords = dojo.style.getAbsolutePosition(this.dragClone, true);
+				// offset the end so the effect can be seen
+				var endCoords = [this.dragStartPosition.x + 1,
+					this.dragStartPosition.y + 1];
+
+				// animate
+				var line = new dojo.lfx.Line(startCoords, endCoords);
+				var anim = new dojo.lfx.Animation(500, line, dojo.lfx.easeOut);
+				var dragObject = this;
+				dojo.event.connect(anim, "onAnimate", function(e) {
+					dragObject.dragClone.style.left = e[0] + "px";
+					dragObject.dragClone.style.top = e[1] + "px";
+				});
+				dojo.event.connect(anim, "onEnd", function (e) {
+					// pause for a second (not literally) and disappear
+					dojo.lang.setTimeout(function() {
+							dojo.dom.removeNode(dragObject.dragClone);
+							// Allow drag clone to be gc'ed
+							dragObject.dragClone = null;
+						},
+						200);
+				});
+				anim.play();
+				break;
+		}
+
+		// shortly the browser will fire an onClick() event,
+		// but since this was really a drag, just squelch it
+		dojo.event.connect(this.domNode, "onclick", this, "squelchOnClick");
+
+		dojo.event.topic.publish('dragEnd', { source: this } );
+	},
+
+	squelchOnClick: function(e){
+		// squelch this onClick() event because it's the result of a drag (it's not a real click)
+		e.preventDefault();
+
+		// but if a real click comes along, allow it
+		dojo.event.disconnect(this.domNode, "onclick", this, "squelchOnClick");
+	},
+
+	constrainTo: function(container) {
+		this.constrainToContainer=true;
+		if (container) {
+			this.constrainingContainer = container;
+		} else {
+			this.constrainingContainer = this.domNode.parentNode;
+		}
 	}
-	this.setAbsolutePosition(x, y);
-	dojo.event.topic.publish("dragMove", {source:this});
-}, setAbsolutePosition:function (x, y) {
-	if (!this.disableY) {
-		this.dragClone.style.top = y + "px";
-	}
-	if (!this.disableX) {
-		this.dragClone.style.left = x + "px";
-	}
-}, onDragEnd:function (e) {
-	switch (e.dragStatus) {
-	  case "dropSuccess":
-		dojo.html.removeNode(this.dragClone);
-		this.dragClone = null;
-		break;
-	  case "dropFailure":
-		var startCoords = dojo.html.getAbsolutePosition(this.dragClone, true);
-		var endCoords = {left:this.dragStartPosition.x + 1, top:this.dragStartPosition.y + 1};
-		var anim = dojo.lfx.slideTo(this.dragClone, endCoords, 300);
-		var dragObject = this;
-		dojo.event.connect(anim, "onEnd", function (e) {
-			dojo.html.removeNode(dragObject.dragClone);
-			dragObject.dragClone = null;
-		});
-		anim.play();
-		break;
-	}
-	dojo.event.topic.publish("dragEnd", {source:this});
-}, constrainTo:function (container) {
-	this.constrainToContainer = true;
-	if (container) {
-		this.constrainingContainer = container;
-	} else {
-		this.constrainingContainer = this.domNode.parentNode;
-	}
-}}, function (node, type) {
+});
+
+dojo.dnd.HtmlDropTarget = function(node, types){
+	if (arguments.length == 0) { return; }
 	this.domNode = dojo.byId(node);
-	this.type = type;
-	this.constrainToContainer = false;
-	this.dragSource = null;
-	dojo.dnd.DragObject.prototype.register.call(this);
-});
-dojo.declare("dojo.dnd.HtmlDropTarget", dojo.dnd.DropTarget, {vertical:false, onDragOver:function (e) {
-	if (!this.accepts(e.dragObjects)) {
-		return false;
+	dojo.dnd.DropTarget.call(this);
+	if(types && dojo.lang.isString(types)) {
+		types = [types];
 	}
-	this.childBoxes = [];
-	for (var i = 0, child; i < this.domNode.childNodes.length; i++) {
-		child = this.domNode.childNodes[i];
-		if (child.nodeType != dojo.html.ELEMENT_NODE) {
-			continue;
+	this.acceptedTypes = types || [];
+}
+dojo.inherits(dojo.dnd.HtmlDropTarget, dojo.dnd.DropTarget);
+
+dojo.lang.extend(dojo.dnd.HtmlDropTarget, {
+	onDragOver: function(e){
+		if(!this.accepts(e.dragObjects)){ return false; }
+
+		// cache the positions of the child nodes
+		this.childBoxes = [];
+		for (var i = 0, child; i < this.domNode.childNodes.length; i++) {
+			child = this.domNode.childNodes[i];
+			if (child.nodeType != dojo.dom.ELEMENT_NODE) { continue; }
+			var pos = dojo.style.getAbsolutePosition(child, true);
+			var height = dojo.style.getInnerHeight(child);
+			var width = dojo.style.getInnerWidth(child);
+			this.childBoxes.push({top: pos.y, bottom: pos.y+height,
+				left: pos.x, right: pos.x+width, node: child});
 		}
-		var pos = dojo.html.getAbsolutePosition(child, true);
-		var inner = dojo.html.getBorderBox(child);
-		this.childBoxes.push({top:pos.y, bottom:pos.y + inner.height, left:pos.x, right:pos.x + inner.width, height:inner.height, width:inner.width, node:child});
-	}
-	return true;
-}, _getNodeUnderMouse:function (e) {
-	for (var i = 0, child; i < this.childBoxes.length; i++) {
-		with (this.childBoxes[i]) {
-			if (e.pageX >= left && e.pageX <= right && e.pageY >= top && e.pageY <= bottom) {
-				return i;
+
+		// TODO: use dummy node
+
+		return true;
+	},
+
+	_getNodeUnderMouse: function(e){
+		// find the child
+		for (var i = 0, child; i < this.childBoxes.length; i++) {
+			with (this.childBoxes[i]) {
+				if (e.pageX >= left && e.pageX <= right &&
+					e.pageY >= top && e.pageY <= bottom) { return i; }
 			}
 		}
-	}
-	return -1;
-}, createDropIndicator:function () {
-	this.dropIndicator = document.createElement("div");
-	with (this.dropIndicator.style) {
-		position = "absolute";
-		zIndex = 999;
-		if (this.vertical) {
-			borderLeftWidth = "1px";
-			borderLeftColor = "black";
-			borderLeftStyle = "solid";
-			height = dojo.html.getBorderBox(this.domNode).height + "px";
-			top = dojo.html.getAbsolutePosition(this.domNode, true).y + "px";
-		} else {
+
+		return -1;
+	},
+
+	createDropIndicator: function() {
+		this.dropIndicator = document.createElement("div");
+		with (this.dropIndicator.style) {
+			position = "absolute";
+			zIndex = 999;
 			borderTopWidth = "1px";
 			borderTopColor = "black";
 			borderTopStyle = "solid";
-			width = dojo.html.getBorderBox(this.domNode).width + "px";
-			left = dojo.html.getAbsolutePosition(this.domNode, true).x + "px";
+			width = dojo.style.getInnerWidth(this.domNode) + "px";
+			left = dojo.style.getAbsoluteX(this.domNode, true) + "px";
 		}
-	}
-}, onDragMove:function (e, dragObjects) {
-	var i = this._getNodeUnderMouse(e);
-	if (!this.dropIndicator) {
-		this.createDropIndicator();
-	}
-	var gravity = this.vertical ? dojo.html.gravity.WEST : dojo.html.gravity.NORTH;
-	var hide = false;
-	if (i < 0) {
-		if (this.childBoxes.length) {
-			var before = (dojo.html.gravity(this.childBoxes[0].node, e) & gravity);
-			if (before) {
-				hide = true;
-			}
-		} else {
-			var before = true;
+	},
+
+	onDragMove: function(e, dragObjects){
+		var i = this._getNodeUnderMouse(e);
+
+		if(!this.dropIndicator){
+			this.createDropIndicator();
 		}
-	} else {
-		var child = this.childBoxes[i];
-		var before = (dojo.html.gravity(child.node, e) & gravity);
-		if (child.node === dragObjects[0].dragSource.domNode) {
-			hide = true;
-		} else {
-			var currentPosChild = before ? (i > 0 ? this.childBoxes[i - 1] : child) : (i < this.childBoxes.length - 1 ? this.childBoxes[i + 1] : child);
-			if (currentPosChild.node === dragObjects[0].dragSource.domNode) {
-				hide = true;
+
+		if(i < 0) {
+			if(this.childBoxes.length) {
+				var before = (dojo.html.gravity(this.childBoxes[0].node, e) & dojo.html.gravity.NORTH);
+			} else {
+				var before = true;
 			}
-		}
-	}
-	if (hide) {
-		this.dropIndicator.style.display = "none";
-		return;
-	} else {
-		this.dropIndicator.style.display = "";
-	}
-	this.placeIndicator(e, dragObjects, i, before);
-	if (!dojo.html.hasParent(this.dropIndicator)) {
-		dojo.body().appendChild(this.dropIndicator);
-	}
-}, placeIndicator:function (e, dragObjects, boxIndex, before) {
-	var targetProperty = this.vertical ? "left" : "top";
-	var child;
-	if (boxIndex < 0) {
-		if (this.childBoxes.length) {
-			child = before ? this.childBoxes[0] : this.childBoxes[this.childBoxes.length - 1];
 		} else {
-			this.dropIndicator.style[targetProperty] = dojo.html.getAbsolutePosition(this.domNode, true)[this.vertical ? "x" : "y"] + "px";
+			var child = this.childBoxes[i];
+			var before = (dojo.html.gravity(child.node, e) & dojo.html.gravity.NORTH);
 		}
-	} else {
-		child = this.childBoxes[boxIndex];
-	}
-	if (child) {
-		this.dropIndicator.style[targetProperty] = (before ? child[targetProperty] : child[this.vertical ? "right" : "bottom"]) + "px";
-		if (this.vertical) {
-			this.dropIndicator.style.height = child.height + "px";
-			this.dropIndicator.style.top = child.top + "px";
-		} else {
-			this.dropIndicator.style.width = child.width + "px";
-			this.dropIndicator.style.left = child.left + "px";
+		this.placeIndicator(e, dragObjects, i, before);
+
+		if(!dojo.html.hasParent(this.dropIndicator)) {
+			document.body.appendChild(this.dropIndicator);
 		}
-	}
-}, onDragOut:function (e) {
-	if (this.dropIndicator) {
-		dojo.html.removeNode(this.dropIndicator);
-		delete this.dropIndicator;
-	}
-}, onDrop:function (e) {
-	this.onDragOut(e);
-	var i = this._getNodeUnderMouse(e);
-	var gravity = this.vertical ? dojo.html.gravity.WEST : dojo.html.gravity.NORTH;
-	if (i < 0) {
-		if (this.childBoxes.length) {
-			if (dojo.html.gravity(this.childBoxes[0].node, e) & gravity) {
-				return this.insert(e, this.childBoxes[0].node, "before");
+	},
+
+	/**
+	 * Position the horizontal line that indicates "insert between these two items"
+	 */
+	placeIndicator: function(e, dragObjects, boxIndex, before) {
+		with(this.dropIndicator.style){
+			if (boxIndex < 0) {
+				if (this.childBoxes.length) {
+					top = (before ? this.childBoxes[0].top
+						: this.childBoxes[this.childBoxes.length - 1].bottom) + "px";
+				} else {
+					top = dojo.style.getAbsoluteY(this.domNode, true) + "px";
+				}
 			} else {
-				return this.insert(e, this.childBoxes[this.childBoxes.length - 1].node, "after");
+				var child = this.childBoxes[boxIndex];
+				top = (before ? child.top : child.bottom) + "px";
 			}
 		}
-		return this.insert(e, this.domNode, "append");
-	}
-	var child = this.childBoxes[i];
-	if (dojo.html.gravity(child.node, e) & gravity) {
-		return this.insert(e, child.node, "before");
-	} else {
-		return this.insert(e, child.node, "after");
-	}
-}, insert:function (e, refNode, position) {
-	var node = e.dragObject.domNode;
-	if (position == "before") {
-		return dojo.html.insertBefore(node, refNode);
-	} else {
-		if (position == "after") {
-			return dojo.html.insertAfter(node, refNode);
-		} else {
-			if (position == "append") {
-				refNode.appendChild(node);
-				return true;
+	},
+
+	onDragOut: function(e) {
+		if(this.dropIndicator) {
+			dojo.dom.removeNode(this.dropIndicator);
+			delete this.dropIndicator;
+		}
+	},
+
+	/**
+	 * Inserts the DragObject as a child of this node relative to the
+	 * position of the mouse.
+	 *
+	 * @return true if the DragObject was inserted, false otherwise
+	 */
+	onDrop: function(e){
+		this.onDragOut(e);
+
+		var i = this._getNodeUnderMouse(e);
+
+		if (i < 0) {
+			if (this.childBoxes.length) {
+				if (dojo.html.gravity(this.childBoxes[0].node, e) & dojo.html.gravity.NORTH) {
+					return this.insert(e, this.childBoxes[0].node, "before");
+				} else {
+					return this.insert(e, this.childBoxes[this.childBoxes.length-1].node, "after");
+				}
 			}
+			return this.insert(e, this.domNode, "append");
 		}
+
+		var child = this.childBoxes[i];
+		if (dojo.html.gravity(child.node, e) & dojo.html.gravity.NORTH) {
+			return this.insert(e, child.node, "before");
+		} else {
+			return this.insert(e, child.node, "after");
+		}
+	},
+
+	insert: function(e, refNode, position) {
+		var node = e.dragObject.domNode;
+
+		if(position == "before") {
+			return dojo.html.insertBefore(node, refNode);
+		} else if(position == "after") {
+			return dojo.html.insertAfter(node, refNode);
+		} else if(position == "append") {
+			refNode.appendChild(node);
+			return true;
+		}
+
+		return false;
 	}
-	return false;
-}}, function (node, types) {
-	if (arguments.length == 0) {
-		return;
-	}
-	this.domNode = dojo.byId(node);
-	dojo.dnd.DropTarget.call(this);
-	if (types && dojo.lang.isString(types)) {
-		types = [types];
-	}
-	this.acceptedTypes = types || [];
-	dojo.dnd.dragManager.registerDropTarget(this);
 });
-

Deleted: tags/parley-0.53/root/static/magic/src/dnd/HtmlDragCopy.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/HtmlDragCopy.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/HtmlDragCopy.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,70 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.dnd.HtmlDragCopy");
-dojo.require("dojo.dnd.*");
-dojo.declare("dojo.dnd.HtmlDragCopySource", dojo.dnd.HtmlDragSource, function (node, type, copyOnce) {
-	this.copyOnce = copyOnce;
-	this.makeCopy = true;
-}, {onDragStart:function () {
-	var dragObj = new dojo.dnd.HtmlDragCopyObject(this.dragObject, this.type, this);
-	if (this.dragClass) {
-		dragObj.dragClass = this.dragClass;
-	}
-	if (this.constrainToContainer) {
-		dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
-	}
-	return dragObj;
-}, onSelected:function () {
-	for (var i = 0; i < this.dragObjects.length; i++) {
-		dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragCopySource(this.dragObjects[i]));
-	}
-}});
-dojo.declare("dojo.dnd.HtmlDragCopyObject", dojo.dnd.HtmlDragObject, function (dragObject, type, source) {
-	this.copySource = source;
-}, {onDragStart:function (e) {
-	dojo.dnd.HtmlDragCopyObject.superclass.onDragStart.apply(this, arguments);
-	if (this.copySource.makeCopy) {
-		this.sourceNode = this.domNode;
-		this.domNode = this.domNode.cloneNode(true);
-	}
-}, onDragEnd:function (e) {
-	switch (e.dragStatus) {
-	  case "dropFailure":
-		var startCoords = dojo.html.getAbsolutePosition(this.dragClone, true);
-		var endCoords = {left:this.dragStartPosition.x + 1, top:this.dragStartPosition.y + 1};
-		var anim = dojo.lfx.slideTo(this.dragClone, endCoords, 500, dojo.lfx.easeOut);
-		var dragObject = this;
-		dojo.event.connect(anim, "onEnd", function (e) {
-			dojo.lang.setTimeout(function () {
-				dojo.html.removeNode(dragObject.dragClone);
-				dragObject.dragClone = null;
-				if (dragObject.copySource.makeCopy) {
-					dojo.html.removeNode(dragObject.domNode);
-					dragObject.domNode = dragObject.sourceNode;
-					dragObject.sourceNode = null;
-				}
-			}, 200);
-		});
-		anim.play();
-		dojo.event.topic.publish("dragEnd", {source:this});
-		return;
-	}
-	dojo.dnd.HtmlDragCopyObject.superclass.onDragEnd.apply(this, arguments);
-	this.copySource.dragObject = this.domNode;
-	if (this.copySource.copyOnce) {
-		this.copySource.makeCopy = false;
-	}
-	new dojo.dnd.HtmlDragCopySource(this.sourceNode, this.type, this.copySource.copyOnce);
-	this.sourceNode = null;
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/dnd/HtmlDragManager.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/HtmlDragManager.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/HtmlDragManager.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,288 +8,468 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.dnd.HtmlDragManager");
 dojo.require("dojo.dnd.DragAndDrop");
 dojo.require("dojo.event.*");
 dojo.require("dojo.lang.array");
-dojo.require("dojo.html.common");
-dojo.require("dojo.html.layout");
-dojo.declare("dojo.dnd.HtmlDragManager", dojo.dnd.DragManager, {disabled:false, nestedTargets:false, mouseDownTimer:null, dsCounter:0, dsPrefix:"dojoDragSource", dropTargetDimensions:[], currentDropTarget:null, previousDropTarget:null, _dragTriggered:false, selectedSources:[], dragObjects:[], dragSources:[], dropTargets:[], currentX:null, currentY:null, lastX:null, lastY:null, mouseDownX:null, mouseDownY:null, threshold:7, dropAcceptable:false, cancelEvent:function (e) {
-	e.stopPropagation();
-	e.preventDefault();
-}, registerDragSource:function (ds) {
-	if (ds["domNode"]) {
-		var dp = this.dsPrefix;
-		var dpIdx = dp + "Idx_" + (this.dsCounter++);
-		ds.dragSourceId = dpIdx;
-		this.dragSources[dpIdx] = ds;
-		ds.domNode.setAttribute(dp, dpIdx);
-		if (dojo.render.html.ie) {
-			dojo.event.browser.addListener(ds.domNode, "ondragstart", this.cancelEvent);
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+
+// NOTE: there will only ever be a single instance of HTMLDragManager, so it's
+// safe to use prototype properties for book-keeping.
+dojo.dnd.HtmlDragManager = function(){
+}
+
+dojo.inherits(dojo.dnd.HtmlDragManager, dojo.dnd.DragManager);
+
+dojo.lang.extend(dojo.dnd.HtmlDragManager, {
+	/**
+	 * There are several sets of actions that the DnD code cares about in the
+	 * HTML context:
+	 *	1.) mouse-down ->
+	 *			(draggable selection)
+	 *			(dragObject generation)
+	 *		mouse-move ->
+	 *			(draggable movement)
+	 *			(droppable detection)
+	 *			(inform droppable)
+	 *			(inform dragObject)
+	 *		mouse-up
+	 *			(inform/destroy dragObject)
+	 *			(inform draggable)
+	 *			(inform droppable)
+	 *	2.) mouse-down -> mouse-down
+	 *			(click-hold context menu)
+	 *	3.) mouse-click ->
+	 *			(draggable selection)
+	 *		shift-mouse-click ->
+	 *			(augment draggable selection)
+	 *		mouse-down ->
+	 *			(dragObject generation)
+	 *		mouse-move ->
+	 *			(draggable movement)
+	 *			(droppable detection)
+	 *			(inform droppable)
+	 *			(inform dragObject)
+	 *		mouse-up
+	 *			(inform draggable)
+	 *			(inform droppable)
+	 *	4.) mouse-up
+	 *			(clobber draggable selection)
+	 */
+	disabled: false, // to kill all dragging!
+	nestedTargets: false,
+	mouseDownTimer: null, // used for click-hold operations
+	dsCounter: 0,
+	dsPrefix: "dojoDragSource",
+
+	// dimension calculation cache for use durring drag
+	dropTargetDimensions: [],
+
+	currentDropTarget: null,
+	// currentDropTargetPoints: null,
+	previousDropTarget: null,
+	_dragTriggered: false,
+
+	selectedSources: [],
+	dragObjects: [],
+
+	// mouse position properties
+	currentX: null,
+	currentY: null,
+	lastX: null,
+	lastY: null,
+	mouseDownX: null,
+	mouseDownY: null,
+	threshold: 7,
+
+	dropAcceptable: false,
+
+	cancelEvent: function(e){ e.stopPropagation(); e.preventDefault();},
+
+	// method over-rides
+	registerDragSource: function(ds){
+		if(ds["domNode"]){
+			// FIXME: dragSource objects SHOULD have some sort of property that
+			// references their DOM node, we shouldn't just be passing nodes and
+			// expecting it to work.
+			var dp = this.dsPrefix;
+			var dpIdx = dp+"Idx_"+(this.dsCounter++);
+			ds.dragSourceId = dpIdx;
+			this.dragSources[dpIdx] = ds;
+			ds.domNode.setAttribute(dp, dpIdx);
+
+			// so we can drag links
+			if(dojo.render.html.ie){
+				dojo.event.connect(ds.domNode, "ondragstart", this.cancelEvent);
+			}
 		}
-	}
-}, unregisterDragSource:function (ds) {
-	if (ds["domNode"]) {
-		var dp = this.dsPrefix;
-		var dpIdx = ds.dragSourceId;
-		delete ds.dragSourceId;
-		delete this.dragSources[dpIdx];
-		ds.domNode.setAttribute(dp, null);
-		if (dojo.render.html.ie) {
-			dojo.event.browser.removeListener(ds.domNode, "ondragstart", this.cancelEvent);
+	},
+
+	unregisterDragSource: function(ds){
+		if (ds["domNode"]){
+
+			var dp = this.dsPrefix;
+			var dpIdx = ds.dragSourceId;
+			delete ds.dragSourceId;
+			delete this.dragSources[dpIdx];
+			ds.domNode.setAttribute(dp, null);
 		}
-	}
-}, registerDropTarget:function (dt) {
-	this.dropTargets.push(dt);
-}, unregisterDropTarget:function (dt) {
-	var index = dojo.lang.find(this.dropTargets, dt, true);
-	if (index >= 0) {
-		this.dropTargets.splice(index, 1);
-	}
-}, getDragSource:function (e) {
-	var tn = e.target;
-	if (tn === dojo.body()) {
-		return;
-	}
-	var ta = dojo.html.getAttribute(tn, this.dsPrefix);
-	while ((!ta) && (tn)) {
-		tn = tn.parentNode;
-		if ((!tn) || (tn === dojo.body())) {
+		if(dojo.render.html.ie){
+			dojo.event.disconnect(ds.domNode, "ondragstart", this.cancelEvent );
+		}
+	},
+
+	registerDropTarget: function(dt){
+		this.dropTargets.push(dt);
+	},
+
+	unregisterDropTarget: function(dt){
+		var index = dojo.lang.find(this.dropTargets, dt, true);
+		if (index>=0) {
+			this.dropTargets.splice(index, 1);
+		}
+	},
+
+	/**
+	* Get the DOM element that is meant to drag.
+	* Loop through the parent nodes of the event target until
+	* the element is found that was created as a DragSource and 
+	* return it.
+	*
+	* @param event object The event for which to get the drag source.
+	*/
+	getDragSource: function(e){
+		var tn = e.target;
+		if(tn === document.body){ return; }
+		var ta = dojo.html.getAttribute(tn, this.dsPrefix);
+		while((!ta)&&(tn)){
+			tn = tn.parentNode;
+			if((!tn)||(tn === document.body)){ return; }
+			ta = dojo.html.getAttribute(tn, this.dsPrefix);
+		}
+		return this.dragSources[ta];
+	},
+
+	onKeyDown: function(e){
+	},
+
+	onMouseDown: function(e){
+		if(this.disabled) { return; }
+
+		// only begin on left click
+		if(dojo.render.html.ie) {
+			if(e.button != 1) { return; }
+		} else if(e.which != 1) {
 			return;
 		}
-		ta = dojo.html.getAttribute(tn, this.dsPrefix);
-	}
-	return this.dragSources[ta];
-}, onKeyDown:function (e) {
-}, onMouseDown:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	if (dojo.render.html.ie) {
-		if (e.button != 1) {
+
+		var target = e.target.nodeType == dojo.dom.TEXT_NODE ?
+			e.target.parentNode : e.target;
+
+		// do not start drag involvement if the user is interacting with
+		// a form element.
+		if(dojo.html.isTag(target, "button", "textarea", "input", "select", "option")) {
 			return;
 		}
-	} else {
-		if (e.which != 1) {
+
+		// find a selection object, if one is a parent of the source node
+		var ds = this.getDragSource(e);
+		
+		// this line is important.  if we aren't selecting anything then
+		// we need to return now, so preventDefault() isn't called, and thus
+		// the event is propogated to other handling code
+		if(!ds){ return; }
+
+		if(!dojo.lang.inArray(this.selectedSources, ds)){
+			this.selectedSources.push(ds);
+			ds.onSelected();
+		}
+
+ 		this.mouseDownX = e.pageX;
+ 		this.mouseDownY = e.pageY;
+
+		// Must stop the mouse down from being propogated, or otherwise can't
+		// drag links in firefox.
+		// WARNING: preventing the default action on all mousedown events
+		// prevents user interaction with the contents.
+		e.preventDefault();
+
+		dojo.event.connect(document, "onmousemove", this, "onMouseMove");
+	},
+
+	onMouseUp: function(e, cancel){
+		// if we aren't dragging then ignore the mouse-up
+		// (in particular, don't call preventDefault(), because other
+		// code may need to process this event)
+		if(this.selectedSources.length==0){
 			return;
 		}
-	}
-	var target = e.target.nodeType == dojo.html.TEXT_NODE ? e.target.parentNode : e.target;
-	if (dojo.html.isTag(target, "button", "textarea", "input", "select", "option")) {
-		return;
-	}
-	var ds = this.getDragSource(e);
-	if (!ds) {
-		return;
-	}
-	if (!dojo.lang.inArray(this.selectedSources, ds)) {
-		this.selectedSources.push(ds);
-		ds.onSelected();
-	}
-	this.mouseDownX = e.pageX;
-	this.mouseDownY = e.pageY;
-	e.preventDefault();
-	dojo.event.connect(document, "onmousemove", this, "onMouseMove");
-}, onMouseUp:function (e, cancel) {
-	if (this.selectedSources.length == 0) {
-		return;
-	}
-	this.mouseDownX = null;
-	this.mouseDownY = null;
-	this._dragTriggered = false;
-	e.dragSource = this.dragSource;
-	if ((!e.shiftKey) && (!e.ctrlKey)) {
-		if (this.currentDropTarget) {
-			this.currentDropTarget.onDropStart();
-		}
-		dojo.lang.forEach(this.dragObjects, function (tempDragObj) {
-			var ret = null;
-			if (!tempDragObj) {
-				return;
+
+		this.mouseDownX = null;
+		this.mouseDownY = null;
+		this._dragTriggered = false;
+ 		// e.preventDefault();
+		e.dragSource = this.dragSource;
+		if((!e.shiftKey)&&(!e.ctrlKey)){
+			if(this.currentDropTarget) {
+				this.currentDropTarget.onDropStart();
 			}
-			if (this.currentDropTarget) {
-				e.dragObject = tempDragObj;
-				var ce = this.currentDropTarget.domNode.childNodes;
-				if (ce.length > 0) {
-					e.dropTarget = ce[0];
-					while (e.dropTarget == tempDragObj.domNode) {
-						e.dropTarget = e.dropTarget.nextSibling;
+			dojo.lang.forEach(this.dragObjects, function(tempDragObj){
+				var ret = null;
+				if(!tempDragObj){ return; }
+				if(this.currentDropTarget) {
+					e.dragObject = tempDragObj;
+
+					// NOTE: we can't get anything but the current drop target
+					// here since the drag shadow blocks mouse-over events.
+					// This is probelematic for dropping "in" something
+					var ce = this.currentDropTarget.domNode.childNodes;
+					if(ce.length > 0){
+						e.dropTarget = ce[0];
+						while(e.dropTarget == tempDragObj.domNode){
+							e.dropTarget = e.dropTarget.nextSibling;
+						}
+					}else{
+						e.dropTarget = this.currentDropTarget.domNode;
 					}
-				} else {
-					e.dropTarget = this.currentDropTarget.domNode;
+					if(this.dropAcceptable){
+						ret = this.currentDropTarget.onDrop(e);
+					}else{
+						 this.currentDropTarget.onDragOut(e);
+					}
 				}
-				if (this.dropAcceptable) {
-					ret = this.currentDropTarget.onDrop(e);
-				} else {
-					this.currentDropTarget.onDragOut(e);
-				}
-			}
-			e.dragStatus = this.dropAcceptable && ret ? "dropSuccess" : "dropFailure";
-			dojo.lang.delayThese([function () {
-				try {
-					tempDragObj.dragSource.onDragEnd(e);
-				}
-				catch (err) {
-					var ecopy = {};
-					for (var i in e) {
-						if (i == "type") {
-							ecopy.type = "mouseup";
-							continue;
+
+				e.dragStatus = this.dropAcceptable && ret ? "dropSuccess" : "dropFailure";
+				// decouple the calls for onDragEnd, so they don't block the execution here
+				// ie. if the onDragEnd would call an alert, the execution here is blocked until the
+				// user has confirmed the alert box and then the rest of the dnd code is executed
+				// while the mouse doesnt "hold" the dragged object anymore ... and so on
+				dojo.lang.delayThese([
+					function() {
+						// in FF1.5 this throws an exception, see 
+						// http://dojotoolkit.org/pipermail/dojo-interest/2006-April/006751.html
+						try{
+							tempDragObj.dragSource.onDragEnd(e)
+						} catch(err) {
+							// since the problem seems passing e, we just copy all 
+							// properties and try the copy ...
+							var ecopy = {};
+							for (var i in e) {
+								if (i=="type") { // the type property contains the exception, no idea why...
+									ecopy.type = "mouseup";
+									continue;
+								}
+								ecopy[i] = e[i];
+							}
+							tempDragObj.dragSource.onDragEnd(ecopy);
 						}
-						ecopy[i] = e[i];
 					}
-					tempDragObj.dragSource.onDragEnd(ecopy);
-				}
-			}, function () {
-				tempDragObj.onDragEnd(e);
-			}]);
-		}, this);
-		this.selectedSources = [];
-		this.dragObjects = [];
-		this.dragSource = null;
-		if (this.currentDropTarget) {
-			this.currentDropTarget.onDropEnd();
+					, function() {tempDragObj.onDragEnd(e)}]);
+			}, this);
+
+			this.selectedSources = [];
+			this.dragObjects = [];
+			this.dragSource = null;
+			if(this.currentDropTarget) {
+				this.currentDropTarget.onDropEnd();
+			}
 		}
-	} else {
-	}
-	dojo.event.disconnect(document, "onmousemove", this, "onMouseMove");
-	this.currentDropTarget = null;
-}, onScroll:function () {
-	for (var i = 0; i < this.dragObjects.length; i++) {
-		if (this.dragObjects[i].updateDragOffset) {
-			this.dragObjects[i].updateDragOffset();
+
+		dojo.event.disconnect(document, "onmousemove", this, "onMouseMove");
+		this.currentDropTarget = null;
+	},
+
+	onScroll: function(){
+		for(var i = 0; i < this.dragObjects.length; i++) {
+			if(this.dragObjects[i].updateDragOffset) {
+				this.dragObjects[i].updateDragOffset();
+			}
 		}
-	}
-	if (this.dragObjects.length) {
+		// TODO: do not recalculate, only adjust coordinates
 		this.cacheTargetLocations();
-	}
-}, _dragStartDistance:function (x, y) {
-	if ((!this.mouseDownX) || (!this.mouseDownX)) {
-		return;
-	}
-	var dx = Math.abs(x - this.mouseDownX);
-	var dx2 = dx * dx;
-	var dy = Math.abs(y - this.mouseDownY);
-	var dy2 = dy * dy;
-	return parseInt(Math.sqrt(dx2 + dy2), 10);
-}, cacheTargetLocations:function () {
-	dojo.profile.start("cacheTargetLocations");
-	this.dropTargetDimensions = [];
-	dojo.lang.forEach(this.dropTargets, function (tempTarget) {
-		var tn = tempTarget.domNode;
-		if (!tn || !tempTarget.accepts([this.dragSource])) {
+	},
+
+	_dragStartDistance: function(x, y){
+		if((!this.mouseDownX)||(!this.mouseDownX)){
 			return;
 		}
-		var abs = dojo.html.getAbsolutePosition(tn, true);
-		var bb = dojo.html.getBorderBox(tn);
-		this.dropTargetDimensions.push([[abs.x, abs.y], [abs.x + bb.width, abs.y + bb.height], tempTarget]);
-	}, this);
-	dojo.profile.end("cacheTargetLocations");
-}, onMouseMove:function (e) {
-	if ((dojo.render.html.ie) && (e.button != 1)) {
-		this.currentDropTarget = null;
-		this.onMouseUp(e, true);
-		return;
-	}
-	if ((this.selectedSources.length) && (!this.dragObjects.length)) {
-		var dx;
-		var dy;
-		if (!this._dragTriggered) {
-			this._dragTriggered = (this._dragStartDistance(e.pageX, e.pageY) > this.threshold);
-			if (!this._dragTriggered) {
-				return;
-			}
-			dx = e.pageX - this.mouseDownX;
-			dy = e.pageY - this.mouseDownY;
+		var dx = Math.abs(x-this.mouseDownX);
+		var dx2 = dx*dx;
+		var dy = Math.abs(y-this.mouseDownY);
+		var dy2 = dy*dy;
+		return parseInt(Math.sqrt(dx2+dy2), 10);
+	},
+
+	cacheTargetLocations: function(){
+		this.dropTargetDimensions = [];
+		dojo.lang.forEach(this.dropTargets, function(tempTarget){
+			var tn = tempTarget.domNode;
+			if(!tn){ return; }
+			var ttx = dojo.style.getAbsoluteX(tn, true);
+			var tty = dojo.style.getAbsoluteY(tn, true);
+			this.dropTargetDimensions.push([
+				[ttx, tty],	// upper-left
+				// lower-right
+				[ ttx+dojo.style.getInnerWidth(tn), tty+dojo.style.getInnerHeight(tn) ],
+				tempTarget
+			]);
+			//dojo.debug("Cached for "+tempTarget)
+		}, this);
+		//dojo.debug("Cache locations")
+	},
+
+	onMouseMove: function(e){
+		if((dojo.render.html.ie)&&(e.button != 1)){
+			// Oooops - mouse up occurred - e.g. when mouse was not over the
+			// window. I don't think we can detect this for FF - but at least
+			// we can be nice in IE.
+			this.currentDropTarget = null;
+			this.onMouseUp(e, true);
+			return;
 		}
-		this.dragSource = this.selectedSources[0];
-		dojo.lang.forEach(this.selectedSources, function (tempSource) {
-			if (!tempSource) {
-				return;
+
+		// if we've got some sources, but no drag objects, we need to send
+		// onDragStart to all the right parties and get things lined up for
+		// drop target detection
+
+		if(	(this.selectedSources.length)&&
+			(!this.dragObjects.length) ){
+			var dx;
+			var dy;
+			if(!this._dragTriggered){
+				this._dragTriggered = (this._dragStartDistance(e.pageX, e.pageY) > this.threshold);
+				if(!this._dragTriggered){ return; }
+				dx = e.pageX - this.mouseDownX;
+				dy = e.pageY - this.mouseDownY;
 			}
-			var tdo = tempSource.onDragStart(e);
-			if (tdo) {
-				tdo.onDragStart(e);
-				tdo.dragOffset.y += dy;
-				tdo.dragOffset.x += dx;
-				tdo.dragSource = tempSource;
-				this.dragObjects.push(tdo);
-			}
-		}, this);
-		this.previousDropTarget = null;
-		this.cacheTargetLocations();
-	}
-	dojo.lang.forEach(this.dragObjects, function (dragObj) {
-		if (dragObj) {
-			dragObj.onDragMove(e);
+
+			// the first element is always our dragSource, if there are multiple
+			// selectedSources (elements that move along) then the first one is the master
+			// and for it the events will be fired etc.
+			this.dragSource = this.selectedSources[0];
+			
+			dojo.lang.forEach(this.selectedSources, function(tempSource){
+				if(!tempSource){ return; }
+				var tdo = tempSource.onDragStart(e);
+				if(tdo){
+					tdo.onDragStart(e);
+
+					// "bump" the drag object to account for the drag threshold
+					tdo.dragOffset.top += dy;
+					tdo.dragOffset.left += dx;
+					tdo.dragSource = tempSource;
+
+					this.dragObjects.push(tdo);
+				}
+			}, this);
+
+			/* clean previous drop target in dragStart */
+			this.previousDropTarget = null;
+
+			this.cacheTargetLocations();
 		}
-	});
-	if (this.currentDropTarget) {
-		var c = dojo.html.toCoordinateObject(this.currentDropTarget.domNode, true);
-		var dtp = [[c.x, c.y], [c.x + c.width, c.y + c.height]];
-	}
-	if ((!this.nestedTargets) && (dtp) && (this.isInsideBox(e, dtp))) {
-		if (this.dropAcceptable) {
-			this.currentDropTarget.onDragMove(e, this.dragObjects);
+
+		// FIXME: we need to add dragSources and dragObjects to e
+		dojo.lang.forEach(this.dragObjects, function(dragObj){
+			if(dragObj){ dragObj.onDragMove(e); }
+		});
+
+		// if we have a current drop target, check to see if we're outside of
+		// it. If so, do all the actions that need doing.
+		if(this.currentDropTarget){
+			//dojo.debug(dojo.dom.hasParent(this.currentDropTarget.domNode))
+			var c = dojo.style.toCoordinateArray(this.currentDropTarget.domNode, true);
+			//		var dtp = this.currentDropTargetPoints;
+			var dtp = [
+				[c[0],c[1]], [c[0]+c[2], c[1]+c[3]]
+			];
 		}
-	} else {
-		var bestBox = this.findBestTarget(e);
-		if (bestBox.target === null) {
-			if (this.currentDropTarget) {
-				this.currentDropTarget.onDragOut(e);
-				this.previousDropTarget = this.currentDropTarget;
-				this.currentDropTarget = null;
+
+		if((!this.nestedTargets)&&(dtp)&&(this.isInsideBox(e, dtp))){
+			if(this.dropAcceptable){
+				this.currentDropTarget.onDragMove(e, this.dragObjects);
 			}
-			this.dropAcceptable = false;
-			return;
-		}
-		if (this.currentDropTarget !== bestBox.target) {
-			if (this.currentDropTarget) {
-				this.previousDropTarget = this.currentDropTarget;
-				this.currentDropTarget.onDragOut(e);
+		}else{
+			// FIXME: need to fix the event object!
+			// see if we can find a better drop target
+			var bestBox = this.findBestTarget(e);
+
+			if(bestBox.target === null){
+				if(this.currentDropTarget){
+					this.currentDropTarget.onDragOut(e);
+					this.previousDropTarget = this.currentDropTarget;
+					this.currentDropTarget = null;
+					// this.currentDropTargetPoints = null;
+				}
+				this.dropAcceptable = false;
+				return;
 			}
-			this.currentDropTarget = bestBox.target;
-			e.dragObjects = this.dragObjects;
-			this.dropAcceptable = this.currentDropTarget.onDragOver(e);
-		} else {
-			if (this.dropAcceptable) {
-				this.currentDropTarget.onDragMove(e, this.dragObjects);
+
+			if(this.currentDropTarget !== bestBox.target){
+				if(this.currentDropTarget){
+					this.previousDropTarget = this.currentDropTarget;
+					this.currentDropTarget.onDragOut(e);
+				}
+				this.currentDropTarget = bestBox.target;
+				// this.currentDropTargetPoints = bestBox.points;
+				e.dragObjects = this.dragObjects;
+				this.dropAcceptable = this.currentDropTarget.onDragOver(e);
+
+			}else{
+				if(this.dropAcceptable){
+					this.currentDropTarget.onDragMove(e, this.dragObjects);
+				}
 			}
 		}
-	}
-}, findBestTarget:function (e) {
-	var _this = this;
-	var bestBox = new Object();
-	bestBox.target = null;
-	bestBox.points = null;
-	dojo.lang.every(this.dropTargetDimensions, function (tmpDA) {
-		if (!_this.isInsideBox(e, tmpDA)) {
+	},
+
+	findBestTarget: function(e) {
+		var _this = this;
+		var bestBox = new Object();
+		bestBox.target = null;
+		bestBox.points = null;
+		dojo.lang.every(this.dropTargetDimensions, function(tmpDA) {
+			if(!_this.isInsideBox(e, tmpDA))
+				return true;
+			bestBox.target = tmpDA[2];
+			bestBox.points = tmpDA;
+			// continue iterating only if _this.nestedTargets == true
+			return Boolean(_this.nestedTargets);
+		});
+
+		return bestBox;
+	},
+
+	isInsideBox: function(e, coords){
+		if(	(e.pageX > coords[0][0])&&
+			(e.pageX < coords[1][0])&&
+			(e.pageY > coords[0][1])&&
+			(e.pageY < coords[1][1]) ){
 			return true;
 		}
-		bestBox.target = tmpDA[2];
-		bestBox.points = tmpDA;
-		return Boolean(_this.nestedTargets);
-	});
-	return bestBox;
-}, isInsideBox:function (e, coords) {
-	if ((e.pageX > coords[0][0]) && (e.pageX < coords[1][0]) && (e.pageY > coords[0][1]) && (e.pageY < coords[1][1])) {
-		return true;
+		return false;
+	},
+
+	onMouseOver: function(e){
+	},
+
+	onMouseOut: function(e){
 	}
-	return false;
-}, onMouseOver:function (e) {
-}, onMouseOut:function (e) {
-}});
+});
+
 dojo.dnd.dragManager = new dojo.dnd.HtmlDragManager();
-(function () {
+
+// global namespace protection closure
+(function(){
 	var d = document;
 	var dm = dojo.dnd.dragManager;
-	dojo.event.connect(d, "onkeydown", dm, "onKeyDown");
-	dojo.event.connect(d, "onmouseover", dm, "onMouseOver");
-	dojo.event.connect(d, "onmouseout", dm, "onMouseOut");
-	dojo.event.connect(d, "onmousedown", dm, "onMouseDown");
-	dojo.event.connect(d, "onmouseup", dm, "onMouseUp");
-	dojo.event.connect(window, "onscroll", dm, "onScroll");
+	// set up event handlers on the document
+	dojo.event.connect(d, "onkeydown", 		dm, "onKeyDown");
+	dojo.event.connect(d, "onmouseover",	dm, "onMouseOver");
+	dojo.event.connect(d, "onmouseout", 	dm, "onMouseOut");
+	dojo.event.connect(d, "onmousedown",	dm, "onMouseDown");
+	dojo.event.connect(d, "onmouseup",		dm, "onMouseUp");
+	// TODO: process scrolling of elements, not only window
+	dojo.event.connect(window, "onscroll",	dm, "onScroll");
 })();
-

Modified: tags/parley-0.53/root/static/magic/src/dnd/HtmlDragMove.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/HtmlDragMove.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/HtmlDragMove.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,47 +8,69 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.dnd.HtmlDragMove");
+dojo.provide("dojo.dnd.HtmlDragMoveSource");
+dojo.provide("dojo.dnd.HtmlDragMoveObject");
 dojo.require("dojo.dnd.*");
-dojo.declare("dojo.dnd.HtmlDragMoveSource", dojo.dnd.HtmlDragSource, {onDragStart:function () {
-	var dragObj = new dojo.dnd.HtmlDragMoveObject(this.dragObject, this.type);
-	if (this.constrainToContainer) {
-		dragObj.constrainTo(this.constrainingContainer);
+
+dojo.dnd.HtmlDragMoveSource = function(node, type){
+	dojo.dnd.HtmlDragSource.call(this, node, type);
+}
+dojo.inherits(dojo.dnd.HtmlDragMoveSource, dojo.dnd.HtmlDragSource);
+dojo.lang.extend(dojo.dnd.HtmlDragMoveSource, {
+	onDragStart: function(){
+		var dragObj =  new dojo.dnd.HtmlDragMoveObject(this.dragObject, this.type);
+		if (this.constrainToContainer) {
+			dragObj.constrainTo(this.constrainingContainer);
+		}
+		return dragObj;
+	},
+	/*
+	 * see dojo.dnd.HtmlDragSource.onSelected
+	 */
+	onSelected: function() {
+		for (var i=0; i<this.dragObjects.length; i++) {
+			dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragMoveSource(this.dragObjects[i]));
+		}
 	}
-	return dragObj;
-}, onSelected:function () {
-	for (var i = 0; i < this.dragObjects.length; i++) {
-		dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragMoveSource(this.dragObjects[i]));
+});
+
+dojo.dnd.HtmlDragMoveObject = function(node, type){
+	dojo.dnd.HtmlDragObject.call(this, node, type);
+}
+dojo.inherits(dojo.dnd.HtmlDragMoveObject, dojo.dnd.HtmlDragObject);
+dojo.lang.extend(dojo.dnd.HtmlDragMoveObject, {
+	onDragEnd: function(e){
+		// shortly the browser will fire an onClick() event,
+		// but since this was really a drag, just squelch it
+		dojo.event.connect(this.domNode, "onclick", this, "squelchOnClick");
+	},
+	onDragStart: function(e){
+		dojo.html.clearSelection();
+
+		this.dragClone = this.domNode;
+
+		this.scrollOffset = dojo.html.getScrollOffset();
+		this.dragStartPosition = dojo.style.getAbsolutePosition(this.domNode, true);
+		
+		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
+			x: this.dragStartPosition.x - e.pageX};
+
+		this.containingBlockPosition = this.domNode.offsetParent ? 
+			dojo.style.getAbsolutePosition(this.domNode.offsetParent, true) : {x:0, y:0};
+
+		this.dragClone.style.position = "absolute";
+
+		if (this.constrainToContainer) {
+			this.constraints = this.getConstraints();
+		}
+	},
+	/**
+	 * Set the position of the drag node.  (x,y) is relative to <body>.
+	 */
+	setAbsolutePosition: function(x, y){
+		// The drag clone is attached to it's constraining container so offset for that
+		if(!this.disableY) { this.domNode.style.top = (y-this.containingBlockPosition.y) + "px"; }
+		if(!this.disableX) { this.domNode.style.left = (x-this.containingBlockPosition.x) + "px"; }
 	}
-}});
-dojo.declare("dojo.dnd.HtmlDragMoveObject", dojo.dnd.HtmlDragObject, {onDragStart:function (e) {
-	dojo.html.clearSelection();
-	this.dragClone = this.domNode;
-	if (dojo.html.getComputedStyle(this.domNode, "position") != "absolute") {
-		this.domNode.style.position = "relative";
-	}
-	var left = parseInt(dojo.html.getComputedStyle(this.domNode, "left"));
-	var top = parseInt(dojo.html.getComputedStyle(this.domNode, "top"));
-	this.dragStartPosition = {x:isNaN(left) ? 0 : left, y:isNaN(top) ? 0 : top};
-	this.scrollOffset = dojo.html.getScroll().offset;
-	this.dragOffset = {y:this.dragStartPosition.y - e.pageY, x:this.dragStartPosition.x - e.pageX};
-	this.containingBlockPosition = {x:0, y:0};
-	if (this.constrainToContainer) {
-		this.constraints = this.getConstraints();
-	}
-	dojo.event.connect(this.domNode, "onclick", this, "_squelchOnClick");
-}, onDragEnd:function (e) {
-}, setAbsolutePosition:function (x, y) {
-	if (!this.disableY) {
-		this.domNode.style.top = y + "px";
-	}
-	if (!this.disableX) {
-		this.domNode.style.left = x + "px";
-	}
-}, _squelchOnClick:function (e) {
-	dojo.event.browser.stopEvent(e);
-	dojo.event.disconnect(this.domNode, "onclick", this, "_squelchOnClick");
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/dnd/Sortable.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/Sortable.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/Sortable.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,17 +8,21 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.dnd.Sortable");
+dojo.require("dojo.dnd.*");
 
+dojo.dnd.Sortable = function () {}
 
-dojo.provide("dojo.dnd.Sortable");
-dojo.require("dojo.dnd.*");
-dojo.dnd.Sortable = function () {
-};
-dojo.lang.extend(dojo.dnd.Sortable, {ondragstart:function (e) {
-	var dragObject = e.target;
-	while (dragObject.parentNode && dragObject.parentNode != this) {
-		dragObject = dragObject.parentNode;
+dojo.lang.extend(dojo.dnd.Sortable, {
+
+	ondragstart: function (e) {
+		var dragObject = e.target;
+		while (dragObject.parentNode && dragObject.parentNode != this) {
+			dragObject = dragObject.parentNode;
+		}
+		// TODO: should apply HtmlDropTarget interface to self
+		// TODO: should apply HtmlDragObject interface?
+		return dragObject;
 	}
-	return dragObject;
-}});
 
+});

Modified: tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDrop.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDrop.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDrop.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,246 +8,466 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/**
+ * TreeDrag* specialized on managing subtree drags
+ * It selects nodes and visualises what's going on,
+ * but delegates real actions upon tree to the controller
+ *
+ * This code is considered a part of controller
+*/
 
+dojo.provide("dojo.dnd.TreeDragAndDrop");
+dojo.provide("dojo.dnd.TreeDragSource");
+dojo.provide("dojo.dnd.TreeDropTarget");
+dojo.provide("dojo.dnd.TreeDNDController");
 
-dojo.provide("dojo.dnd.TreeDragAndDrop");
 dojo.require("dojo.dnd.HtmlDragAndDrop");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.lang.array");
 dojo.require("dojo.lang.extras");
-dojo.require("dojo.html.layout");
-dojo.dnd.TreeDragSource = function (node, syncController, type, treeNode) {
+
+dojo.dnd.TreeDragSource = function(node, syncController, type, treeNode){
 	this.controller = syncController;
 	this.treeNode = treeNode;
+
 	dojo.dnd.HtmlDragSource.call(this, node, type);
-};
+}
+
 dojo.inherits(dojo.dnd.TreeDragSource, dojo.dnd.HtmlDragSource);
-dojo.lang.extend(dojo.dnd.TreeDragSource, {onDragStart:function () {
-	var dragObject = dojo.dnd.HtmlDragSource.prototype.onDragStart.call(this);
-	dragObject.treeNode = this.treeNode;
-	dragObject.onDragStart = dojo.lang.hitch(dragObject, function (e) {
-		this.savedSelectedNode = this.treeNode.tree.selector.selectedNode;
-		if (this.savedSelectedNode) {
-			this.savedSelectedNode.unMarkSelected();
+
+dojo.lang.extend(dojo.dnd.TreeDragSource, {
+	onDragStart: function(){
+		/* extend adds functions to prototype */
+		var dragObject = dojo.dnd.HtmlDragSource.prototype.onDragStart.call(this);
+		//dojo.debugShallow(dragObject)
+
+		dragObject.treeNode = this.treeNode;
+
+		dragObject.onDragStart = dojo.lang.hitch(dragObject, function(e) {
+
+			/* save selection */
+			this.savedSelectedNode = this.treeNode.tree.selector.selectedNode;
+			if (this.savedSelectedNode) {
+				this.savedSelectedNode.unMarkSelected();
+			}
+
+			var result = dojo.dnd.HtmlDragObject.prototype.onDragStart.apply(this, arguments);
+
+
+			/* remove background grid from cloned object */
+			var cloneGrid = this.dragClone.getElementsByTagName('img');
+			for(var i=0; i<cloneGrid.length; i++) {
+				cloneGrid.item(i).style.backgroundImage='url()';
+			}
+
+			return result;
+
+
+		});
+
+		dragObject.onDragEnd = function(e) {
+
+			/* restore selection */
+			if (this.savedSelectedNode) {
+				this.savedSelectedNode.markSelected();
+			}
+			//dojo.debug(e.dragStatus);
+
+			return dojo.dnd.HtmlDragObject.prototype.onDragEnd.apply(this, arguments);
 		}
-		var result = dojo.dnd.HtmlDragObject.prototype.onDragStart.apply(this, arguments);
-		var cloneGrid = this.dragClone.getElementsByTagName("img");
-		for (var i = 0; i < cloneGrid.length; i++) {
-			cloneGrid.item(i).style.backgroundImage = "url()";
-		}
-		return result;
-	});
-	dragObject.onDragEnd = function (e) {
-		if (this.savedSelectedNode) {
-			this.savedSelectedNode.markSelected();
-		}
-		return dojo.dnd.HtmlDragObject.prototype.onDragEnd.apply(this, arguments);
-	};
-	return dragObject;
-}, onDragEnd:function (e) {
-	var res = dojo.dnd.HtmlDragSource.prototype.onDragEnd.call(this, e);
-	return res;
-}});
-dojo.dnd.TreeDropTarget = function (domNode, controller, type, treeNode) {
+		//dojo.debug(dragObject.domNode.outerHTML)
+
+
+		return dragObject;
+	},
+
+	onDragEnd: function(e){
+
+
+		 var res = dojo.dnd.HtmlDragSource.prototype.onDragEnd.call(this, e);
+
+
+		 return res;
+	}
+});
+
+// .......................................
+
+dojo.dnd.TreeDropTarget = function(domNode, controller, type, treeNode, DNDMode){
+
 	this.treeNode = treeNode;
-	this.controller = controller;
+	this.controller = controller; // I will sync-ly process drops
+	this.DNDMode = DNDMode;
+
 	dojo.dnd.HtmlDropTarget.apply(this, [domNode, type]);
-};
+}
+
 dojo.inherits(dojo.dnd.TreeDropTarget, dojo.dnd.HtmlDropTarget);
-dojo.lang.extend(dojo.dnd.TreeDropTarget, {autoExpandDelay:1500, autoExpandTimer:null, position:null, indicatorStyle:"2px black solid", showIndicator:function (position) {
-	if (this.position == position) {
-		return;
-	}
-	this.hideIndicator();
-	this.position = position;
-	if (position == "before") {
-		this.treeNode.labelNode.style.borderTop = this.indicatorStyle;
-	} else {
-		if (position == "after") {
+
+dojo.lang.extend(dojo.dnd.TreeDropTarget, {
+
+	autoExpandDelay: 1500,
+	autoExpandTimer: null,
+
+
+	position: null,
+
+	indicatorStyle: "2px black solid",
+
+	showIndicator: function(position) {
+
+		// do not change style too often, cause of blinking possible
+		if (this.position == position) {
+			return;
+		}
+
+		//dojo.debug(position)
+
+		this.hideIndicator();
+
+		this.position = position;
+
+		if (position == "before") {
+			this.treeNode.labelNode.style.borderTop = this.indicatorStyle;
+		} else if (position == "after") {
 			this.treeNode.labelNode.style.borderBottom = this.indicatorStyle;
-		} else {
-			if (position == "onto") {
-				this.treeNode.markSelected();
+		} else if (position == "onto") {
+			this.treeNode.markSelected();
+		}
+
+
+	},
+
+	hideIndicator: function() {
+		this.treeNode.labelNode.style.borderBottom="";
+		this.treeNode.labelNode.style.borderTop="";
+		this.treeNode.unMarkSelected();
+		this.position = null;
+	},
+
+
+
+	// is the target possibly ok ?
+	// This function is run on dragOver, but drop possibility is also determined by position over node
+	// that's why acceptsWithPosition is called
+	// doesnt take index into account ( can change while moving mouse w/o changing target )
+
+
+	/**
+	 * Coarse (tree-level) access check.
+	 * We can't determine real accepts status w/o position
+	*/
+	onDragOver: function(e){
+//dojo.debug("onDragOver for "+e);
+
+
+		var accepts = dojo.dnd.HtmlDropTarget.prototype.onDragOver.apply(this, arguments);
+
+		//dojo.debug("TreeDropTarget.onDragOver accepts:"+accepts)
+
+		if (accepts && this.treeNode.isFolder && !this.treeNode.isExpanded) {
+			this.setAutoExpandTimer();
+		}
+
+		return accepts;
+	},
+
+	/* Parent.onDragOver calls this function to get accepts status */
+	accepts: function(dragObjects) {
+
+		var accepts = dojo.dnd.HtmlDropTarget.prototype.accepts.apply(this, arguments);
+
+		if (!accepts) return false;
+
+		var sourceTreeNode = dragObjects[0].treeNode;
+
+		if (dojo.lang.isUndefined(sourceTreeNode) || !sourceTreeNode || !sourceTreeNode.isTreeNode) {
+			dojo.raise("Source is not TreeNode or not found");
+		}
+
+		if (sourceTreeNode === this.treeNode) return false;
+
+		return true;
+	},
+
+
+
+	setAutoExpandTimer: function() {
+		// set up autoexpand timer
+		var _this = this;
+
+		var autoExpand = function () {
+			if (dojo.dnd.dragManager.currentDropTarget === _this) {
+				_this.controller.expand(_this.treeNode);
 			}
 		}
-	}
-}, hideIndicator:function () {
-	this.treeNode.labelNode.style.borderBottom = "";
-	this.treeNode.labelNode.style.borderTop = "";
-	this.treeNode.unMarkSelected();
-	this.position = null;
-}, onDragOver:function (e) {
-	var accepts = dojo.dnd.HtmlDropTarget.prototype.onDragOver.apply(this, arguments);
-	if (accepts && this.treeNode.isFolder && !this.treeNode.isExpanded) {
-		this.setAutoExpandTimer();
-	}
-	return accepts;
-}, accepts:function (dragObjects) {
-	var accepts = dojo.dnd.HtmlDropTarget.prototype.accepts.apply(this, arguments);
-	if (!accepts) {
-		return false;
-	}
-	var sourceTreeNode = dragObjects[0].treeNode;
-	if (dojo.lang.isUndefined(sourceTreeNode) || !sourceTreeNode || !sourceTreeNode.isTreeNode) {
-		dojo.raise("Source is not TreeNode or not found");
-	}
-	if (sourceTreeNode === this.treeNode) {
-		return false;
-	}
-	return true;
-}, setAutoExpandTimer:function () {
-	var _this = this;
-	var autoExpand = function () {
-		if (dojo.dnd.dragManager.currentDropTarget === _this) {
-			_this.controller.expand(_this.treeNode);
+
+		this.autoExpandTimer = dojo.lang.setTimeout(autoExpand, _this.autoExpandDelay);
+	},
+
+
+	getAcceptPosition: function(e, sourceTreeNode) {
+
+		var DNDMode = this.DNDMode;
+
+		if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO &&
+			// check if ONTO is allowed localy
+			!(
+			  !this.treeNode.actionIsDisabled(dojo.widget.TreeNode.prototype.actions.ADDCHILD) // check dynamically cause may change w/o regeneration of dropTarget
+			  && sourceTreeNode.parent !== this.treeNode
+			  && this.controller.canMove(sourceTreeNode, this.treeNode)
+			 )
+		) {
+			// disable ONTO if can't move
+			DNDMode &= ~dojo.widget.Tree.prototype.DNDModes.ONTO;
 		}
-	};
-	this.autoExpandTimer = dojo.lang.setTimeout(autoExpand, _this.autoExpandDelay);
-}, getDNDMode:function () {
-	return this.treeNode.tree.DNDMode;
-}, getAcceptPosition:function (e, sourceTreeNode) {
-	var DNDMode = this.getDNDMode();
-	if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO && !(!this.treeNode.actionIsDisabled(dojo.widget.TreeNode.prototype.actions.ADDCHILD) && sourceTreeNode.parent !== this.treeNode && this.controller.canMove(sourceTreeNode, this.treeNode))) {
-		DNDMode &= ~dojo.widget.Tree.prototype.DNDModes.ONTO;
-	}
-	var position = this.getPosition(e, DNDMode);
-	if (position == "onto" || (!this.isAdjacentNode(sourceTreeNode, position) && this.controller.canMove(sourceTreeNode, this.treeNode.parent))) {
-		return position;
-	} else {
+
+
+		var position = this.getPosition(e, DNDMode);
+
+		//dojo.debug(DNDMode & +" : "+position);
+
+
+		// if onto is here => it was allowed before, no accept check is needed
+		if (position=="onto" ||
+			(!this.isAdjacentNode(sourceTreeNode, position)
+			 && this.controller.canMove(sourceTreeNode, this.treeNode.parent)
+			)
+		) {
+			return position;
+		} else {
+			return false;
+		}
+
+	},
+
+	onDragOut: function(e) {
+		this.clearAutoExpandTimer();
+
+		this.hideIndicator();
+	},
+
+
+	clearAutoExpandTimer: function() {
+		if (this.autoExpandTimer) {
+			clearTimeout(this.autoExpandTimer);
+			this.autoExpandTimer = null;
+		}
+	},
+
+
+
+	onDragMove: function(e, dragObjects){
+
+		var sourceTreeNode = dragObjects[0].treeNode;
+
+		var position = this.getAcceptPosition(e, sourceTreeNode);
+
+		if (position) {
+			this.showIndicator(position);
+		}
+
+	},
+
+	isAdjacentNode: function(sourceNode, position) {
+
+		if (sourceNode === this.treeNode) return true;
+		if (sourceNode.getNextSibling() === this.treeNode && position=="before") return true;
+		if (sourceNode.getPreviousSibling() === this.treeNode && position=="after") return true;
+
 		return false;
-	}
-}, onDragOut:function (e) {
-	this.clearAutoExpandTimer();
-	this.hideIndicator();
-}, clearAutoExpandTimer:function () {
-	if (this.autoExpandTimer) {
-		clearTimeout(this.autoExpandTimer);
-		this.autoExpandTimer = null;
-	}
-}, onDragMove:function (e, dragObjects) {
-	var sourceTreeNode = dragObjects[0].treeNode;
-	var position = this.getAcceptPosition(e, sourceTreeNode);
-	if (position) {
-		this.showIndicator(position);
-	}
-}, isAdjacentNode:function (sourceNode, position) {
-	if (sourceNode === this.treeNode) {
-		return true;
-	}
-	if (sourceNode.getNextSibling() === this.treeNode && position == "before") {
-		return true;
-	}
-	if (sourceNode.getPreviousSibling() === this.treeNode && position == "after") {
-		return true;
-	}
-	return false;
-}, getPosition:function (e, DNDMode) {
-	var node = dojo.byId(this.treeNode.labelNode);
-	var mousey = e.pageY || e.clientY + dojo.body().scrollTop;
-	var nodey = dojo.html.getAbsolutePosition(node).y;
-	var height = dojo.html.getBorderBox(node).height;
-	var relY = mousey - nodey;
-	var p = relY / height;
-	var position = "";
-	if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO && DNDMode & dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
-		if (p <= 0.3) {
-			position = "before";
-		} else {
-			if (p <= 0.7) {
+	},
+
+
+	/* get DNDMode and see which position e fits */
+	getPosition: function(e, DNDMode) {
+		node = dojo.byId(this.treeNode.labelNode);
+		var mousey = e.pageY || e.clientY + document.body.scrollTop;
+		var nodey = dojo.html.getAbsoluteY(node);
+		var height = dojo.html.getInnerHeight(node);
+
+		var relY = mousey - nodey;
+		var p = relY / height;
+
+		var position = ""; // "" <=> forbidden
+		if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO
+		  && DNDMode & dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
+			if (p<=0.3) {
+				position = "before";
+			} else if (p<=0.7) {
 				position = "onto";
 			} else {
 				position = "after";
 			}
-		}
-	} else {
-		if (DNDMode & dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
-			if (p <= 0.5) {
+		} else if (DNDMode & dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
+			if (p<=0.5) {
 				position = "before";
 			} else {
 				position = "after";
 			}
+		}
+		else if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO) {
+			position = "onto";
+		}
+
+
+		return position;
+	},
+
+
+
+	getTargetParentIndex: function(sourceTreeNode, position) {
+
+		var index = position == "before" ? this.treeNode.getParentIndex() : this.treeNode.getParentIndex()+1;
+		if (this.treeNode.parent === sourceTreeNode.parent
+		  && this.treeNode.getParentIndex() > sourceTreeNode.getParentIndex()) {
+		  	index--;  // dragging a node is different for simple move bacause of before-after issues
+		}
+
+		return index;
+	},
+
+
+	onDrop: function(e){
+		// onDragOut will clean position
+
+
+		var position = this.position;
+
+//dojo.debug(position);
+
+		this.onDragOut(e);
+
+		var sourceTreeNode = e.dragObject.treeNode;
+
+		if (!dojo.lang.isObject(sourceTreeNode)) {
+			dojo.raise("TreeNode not found in dragObject")
+		}
+
+		if (position == "onto") {
+			return this.controller.move(sourceTreeNode, this.treeNode, 0);
 		} else {
-			if (DNDMode & dojo.widget.Tree.prototype.DNDModes.ONTO) {
-				position = "onto";
-			}
+			var index = this.getTargetParentIndex(sourceTreeNode, position);
+			return this.controller.move(sourceTreeNode, this.treeNode.parent, index);
 		}
+
+		//dojo.debug('drop2');
+
+
+
 	}
-	return position;
-}, getTargetParentIndex:function (sourceTreeNode, position) {
-	var index = position == "before" ? this.treeNode.getParentIndex() : this.treeNode.getParentIndex() + 1;
-	if (this.treeNode.parent === sourceTreeNode.parent && this.treeNode.getParentIndex() > sourceTreeNode.getParentIndex()) {
-		index--;
-	}
-	return index;
-}, onDrop:function (e) {
-	var position = this.position;
-	this.onDragOut(e);
-	var sourceTreeNode = e.dragObject.treeNode;
-	if (!dojo.lang.isObject(sourceTreeNode)) {
-		dojo.raise("TreeNode not found in dragObject");
-	}
-	if (position == "onto") {
-		return this.controller.move(sourceTreeNode, this.treeNode, 0);
-	} else {
-		var index = this.getTargetParentIndex(sourceTreeNode, position);
-		return this.controller.move(sourceTreeNode, this.treeNode.parent, index);
-	}
-}});
-dojo.dnd.TreeDNDController = function (treeController) {
+
+
+});
+
+
+
+dojo.dnd.TreeDNDController = function(treeController) {
+
+	// I use this controller to perform actions
 	this.treeController = treeController;
+
 	this.dragSources = {};
+
 	this.dropTargets = {};
-};
-dojo.lang.extend(dojo.dnd.TreeDNDController, {listenTree:function (tree) {
-	dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
-	dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
-	dojo.event.topic.subscribe(tree.eventNames.moveTo, this, "onMoveTo");
-	dojo.event.topic.subscribe(tree.eventNames.addChild, this, "onAddChild");
-	dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
-	dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-}, unlistenTree:function (tree) {
-	dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
-	dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
-	dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, "onMoveTo");
-	dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, "onAddChild");
-	dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
-	dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-}, onTreeDestroy:function (message) {
-	this.unlistenTree(message.source);
-}, onCreateDOMNode:function (message) {
-	this.registerDNDNode(message.source);
-}, onAddChild:function (message) {
-	this.registerDNDNode(message.child);
-}, onMoveFrom:function (message) {
-	var _this = this;
-	dojo.lang.forEach(message.child.getDescendants(), function (node) {
-		_this.unregisterDNDNode(node);
-	});
-}, onMoveTo:function (message) {
-	var _this = this;
-	dojo.lang.forEach(message.child.getDescendants(), function (node) {
-		_this.registerDNDNode(node);
-	});
-}, registerDNDNode:function (node) {
-	if (!node.tree.DNDMode) {
-		return;
+
+}
+
+dojo.lang.extend(dojo.dnd.TreeDNDController, {
+
+
+	listenTree: function(tree) {
+		//dojo.debug("Listen tree "+tree);
+		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
+		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
+		dojo.event.topic.subscribe(tree.eventNames.moveTo, this, "onMoveTo");
+		dojo.event.topic.subscribe(tree.eventNames.addChild, this, "onAddChild");
+		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+	},
+
+
+	unlistenTree: function(tree) {
+		//dojo.debug("Listen tree "+tree);
+		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
+		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
+		dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, "onMoveTo");
+		dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, "onAddChild");
+		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+	},
+
+	onTreeDestroy: function(message) {
+		this.unlistenTree(message.source);
+		// I'm not widget so don't use destroy() call and dieWithTree
+	},
+
+	onCreateDOMNode: function(message) {
+		this.registerDNDNode(message.source);
+	},
+
+	onAddChild: function(message) {
+		this.registerDNDNode(message.child);
+	},
+
+	onMoveFrom: function(message) {
+		var _this = this;
+		dojo.lang.forEach(
+			message.child.getDescendants(),
+			function(node) { _this.unregisterDNDNode(node); }
+		);
+	},
+
+	onMoveTo: function(message) {
+		var _this = this;
+		dojo.lang.forEach(
+			message.child.getDescendants(),
+			function(node) { _this.registerDNDNode(node); }
+		);
+	},
+
+	/**
+	 * Controller(node model) creates DNDNodes because it passes itself to node for synchroneous drops processing
+	 * I can't process DnD with events cause an event can't return result success/false
+	*/
+	registerDNDNode: function(node) {
+		if (!node.tree.DNDMode) return;
+
+//dojo.debug("registerDNDNode "+node);
+
+		/* I drag label, not domNode, because large domNodes are very slow to copy and large to drag */
+
+		var source = null;
+		var target = null;
+
+		if (!node.actionIsDisabled(node.actions.MOVE)) {
+			//dojo.debug("reg source")
+			var source = new dojo.dnd.TreeDragSource(node.labelNode, this, node.tree.widgetId, node);
+			this.dragSources[node.widgetId] = source;
+		}
+
+		var target = new dojo.dnd.TreeDropTarget(node.labelNode, this.treeController, node.tree.DNDAcceptTypes, node, node.tree.DNDMode);
+
+		this.dropTargets[node.widgetId] = target;
+
+	},
+
+
+	unregisterDNDNode: function(node) {
+
+		if (this.dragSources[node.widgetId]) {
+			dojo.dnd.dragManager.unregisterDragSource(this.dragSources[node.widgetId]);
+			delete this.dragSources[node.widgetId];
+		}
+
+		if (this.dropTargets[node.widgetId]) {
+			dojo.dnd.dragManager.unregisterDropTarget(this.dropTargets[node.widgetId]);
+			delete this.dropTargets[node.widgetId];
+		}
 	}
-	var source = null;
-	var target = null;
-	if (!node.actionIsDisabled(node.actions.MOVE)) {
-		var source = new dojo.dnd.TreeDragSource(node.labelNode, this, node.tree.widgetId, node);
-		this.dragSources[node.widgetId] = source;
-	}
-	var target = new dojo.dnd.TreeDropTarget(node.labelNode, this.treeController, node.tree.DNDAcceptTypes, node);
-	this.dropTargets[node.widgetId] = target;
-}, unregisterDNDNode:function (node) {
-	if (this.dragSources[node.widgetId]) {
-		dojo.dnd.dragManager.unregisterDragSource(this.dragSources[node.widgetId]);
-		delete this.dragSources[node.widgetId];
-	}
-	if (this.dropTargets[node.widgetId]) {
-		dojo.dnd.dragManager.unregisterDropTarget(this.dropTargets[node.widgetId]);
-		delete this.dropTargets[node.widgetId];
-	}
-}});
 
+
+
+
+
+});

Deleted: tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDropV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDropV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/TreeDragAndDropV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,218 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.dnd.TreeDragAndDropV3");
-dojo.require("dojo.dnd.HtmlDragAndDrop");
-dojo.require("dojo.lang.func");
-dojo.require("dojo.lang.array");
-dojo.require("dojo.lang.extras");
-dojo.require("dojo.Deferred");
-dojo.require("dojo.html.layout");
-dojo.dnd.TreeDragSourceV3 = function (node, syncController, type, treeNode) {
-	this.controller = syncController;
-	this.treeNode = treeNode;
-	dojo.dnd.HtmlDragSource.call(this, node, type);
-};
-dojo.inherits(dojo.dnd.TreeDragSourceV3, dojo.dnd.HtmlDragSource);
-dojo.dnd.TreeDropTargetV3 = function (domNode, controller, type, treeNode) {
-	this.treeNode = treeNode;
-	this.controller = controller;
-	dojo.dnd.HtmlDropTarget.call(this, domNode, type);
-};
-dojo.inherits(dojo.dnd.TreeDropTargetV3, dojo.dnd.HtmlDropTarget);
-dojo.lang.extend(dojo.dnd.TreeDropTargetV3, {autoExpandDelay:1500, autoExpandTimer:null, position:null, indicatorStyle:"2px black groove", showIndicator:function (position) {
-	if (this.position == position) {
-		return;
-	}
-	this.hideIndicator();
-	this.position = position;
-	var node = this.treeNode;
-	node.contentNode.style.width = dojo.html.getBorderBox(node.labelNode).width + "px";
-	if (position == "onto") {
-		node.contentNode.style.border = this.indicatorStyle;
-	} else {
-		if (position == "before") {
-			node.contentNode.style.borderTop = this.indicatorStyle;
-		} else {
-			if (position == "after") {
-				node.contentNode.style.borderBottom = this.indicatorStyle;
-			}
-		}
-	}
-}, hideIndicator:function () {
-	this.treeNode.contentNode.style.borderBottom = "";
-	this.treeNode.contentNode.style.borderTop = "";
-	this.treeNode.contentNode.style.border = "";
-	this.treeNode.contentNode.style.width = "";
-	this.position = null;
-}, onDragOver:function (e) {
-	var accepts = dojo.dnd.HtmlDropTarget.prototype.onDragOver.apply(this, arguments);
-	if (accepts && this.treeNode.isFolder && !this.treeNode.isExpanded) {
-		this.setAutoExpandTimer();
-	}
-	if (accepts) {
-		this.cacheNodeCoords();
-	}
-	return accepts;
-}, accepts:function (dragObjects) {
-	var accepts = dojo.dnd.HtmlDropTarget.prototype.accepts.apply(this, arguments);
-	if (!accepts) {
-		return false;
-	}
-	for (var i = 0; i < dragObjects.length; i++) {
-		var sourceTreeNode = dragObjects[i].treeNode;
-		if (sourceTreeNode === this.treeNode) {
-			return false;
-		}
-	}
-	return true;
-}, setAutoExpandTimer:function () {
-	var _this = this;
-	var autoExpand = function () {
-		if (dojo.dnd.dragManager.currentDropTarget === _this) {
-			_this.controller.expand(_this.treeNode);
-			dojo.dnd.dragManager.cacheTargetLocations();
-		}
-	};
-	this.autoExpandTimer = dojo.lang.setTimeout(autoExpand, _this.autoExpandDelay);
-}, getAcceptPosition:function (e, dragObjects) {
-	var DndMode = this.treeNode.tree.DndMode;
-	if (DndMode & dojo.widget.TreeV3.prototype.DndModes.ONTO && this.treeNode.actionIsDisabledNow(this.treeNode.actions.ADDCHILD)) {
-		DndMode &= ~dojo.widget.TreeV3.prototype.DndModes.ONTO;
-	}
-	var position = this.getPosition(e, DndMode);
-	if (position == "onto") {
-		return position;
-	}
-	for (var i = 0; i < dragObjects.length; i++) {
-		var source = dragObjects[i].dragSource;
-		if (source.treeNode && this.isAdjacentNode(source.treeNode, position)) {
-			continue;
-		}
-		if (!this.controller.canMove(source.treeNode ? source.treeNode : source, this.treeNode.parent)) {
-			return false;
-		}
-	}
-	return position;
-}, onDropEnd:function (e) {
-	this.clearAutoExpandTimer();
-	this.hideIndicator();
-}, onDragOut:function (e) {
-	this.clearAutoExpandTimer();
-	this.hideIndicator();
-}, clearAutoExpandTimer:function () {
-	if (this.autoExpandTimer) {
-		clearTimeout(this.autoExpandTimer);
-		this.autoExpandTimer = null;
-	}
-}, onDragMove:function (e, dragObjects) {
-	var position = this.getAcceptPosition(e, dragObjects);
-	if (position) {
-		this.showIndicator(position);
-	}
-}, isAdjacentNode:function (sourceNode, position) {
-	if (sourceNode === this.treeNode) {
-		return true;
-	}
-	if (sourceNode.getNextSibling() === this.treeNode && position == "before") {
-		return true;
-	}
-	if (sourceNode.getPreviousSibling() === this.treeNode && position == "after") {
-		return true;
-	}
-	return false;
-}, cacheNodeCoords:function () {
-	var node = this.treeNode.contentNode;
-	this.cachedNodeY = dojo.html.getAbsolutePosition(node).y;
-	this.cachedNodeHeight = dojo.html.getBorderBox(node).height;
-}, getPosition:function (e, DndMode) {
-	var mousey = e.pageY || e.clientY + dojo.body().scrollTop;
-	var relY = mousey - this.cachedNodeY;
-	var p = relY / this.cachedNodeHeight;
-	var position = "";
-	if (DndMode & dojo.widget.TreeV3.prototype.DndModes.ONTO && DndMode & dojo.widget.TreeV3.prototype.DndModes.BETWEEN) {
-		if (p <= 0.33) {
-			position = "before";
-		} else {
-			if (p <= 0.66 || this.treeNode.isExpanded && this.treeNode.children.length && !this.treeNode.isLastChild()) {
-				position = "onto";
-			} else {
-				position = "after";
-			}
-		}
-	} else {
-		if (DndMode & dojo.widget.TreeV3.prototype.DndModes.BETWEEN) {
-			if (p <= 0.5 || this.treeNode.isExpanded && this.treeNode.children.length && !this.treeNode.isLastChild()) {
-				position = "before";
-			} else {
-				position = "after";
-			}
-		} else {
-			if (DndMode & dojo.widget.TreeV3.prototype.DndModes.ONTO) {
-				position = "onto";
-			}
-		}
-	}
-	return position;
-}, getTargetParentIndex:function (source, position) {
-	var index = position == "before" ? this.treeNode.getParentIndex() : this.treeNode.getParentIndex() + 1;
-	if (source.treeNode && this.treeNode.parent === source.treeNode.parent && this.treeNode.getParentIndex() > source.treeNode.getParentIndex()) {
-		index--;
-	}
-	return index;
-}, onDrop:function (e) {
-	var position = this.position;
-	var source = e.dragObject.dragSource;
-	var targetParent, targetIndex;
-	if (position == "onto") {
-		targetParent = this.treeNode;
-		targetIndex = 0;
-	} else {
-		targetIndex = this.getTargetParentIndex(source, position);
-		targetParent = this.treeNode.parent;
-	}
-	var r = this.getDropHandler(e, source, targetParent, targetIndex)();
-	return r;
-}, getDropHandler:function (e, source, targetParent, targetIndex) {
-	var handler;
-	var _this = this;
-	handler = function () {
-		var result;
-		if (source.treeNode) {
-			result = _this.controller.move(source.treeNode, targetParent, targetIndex, true);
-		} else {
-			if (dojo.lang.isFunction(source.onDrop)) {
-				source.onDrop(targetParent, targetIndex);
-			}
-			var treeNode = source.getTreeNode();
-			if (treeNode) {
-				result = _this.controller.createChild(targetParent, targetIndex, treeNode, true);
-			} else {
-				result = true;
-			}
-		}
-		if (result instanceof dojo.Deferred) {
-			var isSuccess = result.fired == 0;
-			if (!isSuccess) {
-				_this.handleDropError(source, targetParent, targetIndex, result);
-			}
-			return isSuccess;
-		} else {
-			return result;
-		}
-	};
-	return handler;
-}, handleDropError:function (source, parent, index, result) {
-	dojo.debug("TreeDropTargetV3.handleDropError: DND error occured");
-	dojo.debugShallow(result);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/dnd/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dnd/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dnd/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,9 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.dnd.DragAndDrop"], browser:["dojo.dnd.HtmlDragAndDrop"], dashboard:["dojo.dnd.HtmlDragAndDrop"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.dnd.DragAndDrop"],
+	browser: ["dojo.dnd.HtmlDragAndDrop"],
+	dashboard: ["dojo.dnd.HtmlDragAndDrop"]
+});
 dojo.provide("dojo.dnd.*");
-

Added: tags/parley-0.53/root/static/magic/src/doc.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/doc.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/doc.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,622 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.doc");
+dojo.require("dojo.io.*");
+dojo.require("dojo.event.topic");
+dojo.require("dojo.rpc.JotService");
+dojo.require("dojo.dom");
+
+/*
+ * TODO:
+ *
+ * Package summary needs to compensate for "is"
+ * Handle host environments
+ * Deal with dojo.widget weirdness
+ * Parse parameters
+ * Limit function parameters to only the valid ones (Involves packing parameters onto meta during rewriting)
+ * Package display page
+ *
+ */
+
+dojo.doc._count = 0;
+dojo.doc._keys = {};
+dojo.doc._myKeys = [];
+dojo.doc._callbacks = {function_names: []};
+dojo.doc._cache = {}; // Saves the JSON objects in cache
+dojo.doc._rpc = new dojo.rpc.JotService;
+dojo.doc._rpc.serviceUrl = "http://dojotoolkit.org/~pottedmeat/jsonrpc.php";
+
+dojo.lang.mixin(dojo.doc, {
+	functionNames: function(/*mixed*/ selectKey, /*Function*/ callback){
+		// summary: Returns an ordered list of package and function names.
+		dojo.debug("functionNames()");
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		dojo.doc._buildCache({
+			type: "function_names",
+			callbacks: [dojo.doc._functionNames, callback],
+			selectKey: selectKey
+		});
+	},
+
+	_functionNames: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug("_functionNames()");
+		var searchData = [];
+		for(var key in data){
+			// Add the package if it doesn't exist in its children
+			if(!dojo.lang.inArray(data[key], key)){
+				searchData.push([key, key]);
+			}
+			// Add the functions
+			for(var pkg_key in data[key]){
+				searchData.push([data[key][pkg_key], data[key][pkg_key]]);
+			}
+		}
+
+		searchData = searchData.sort(dojo.doc._sort);
+
+		if(evt.callbacks && evt.callbacks.length){
+			var callback = evt.callbacks.shift();
+			callback.call(null, type, searchData, evt);
+		}
+	},
+
+	getMeta: function(/*mixed*/ selectKey, /*Function*/ callback, /*Function*/ name, /*String?*/ id){
+		// summary: Gets information about a function in regards to its meta data
+		dojo.debug("getMeta(" + name + ")");
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		dojo.doc._buildCache({
+			type: "meta",
+			callbacks: [callback],
+			name: name,
+			id: id,
+			selectKey: selectKey
+		});
+	},
+
+	_getMeta: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug("_getMeta(" + evt.name + ") has package: " + evt.pkg + " with: " + type);
+		if("load" == type && evt.pkg){
+			evt.type = "meta";
+			dojo.doc._buildCache(evt);
+		}else{
+			if(evt.callbacks && evt.callbacks.length){
+				var callback = evt.callbacks.shift();
+				callback.call(null, "error", {}, evt);
+			}
+		}
+	},
+
+	getSrc: function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name, /*String?*/ id){
+		// summary: Gets src file (created by the doc parser)
+		dojo.debug("getSrc()");
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}	
+		dojo.doc._buildCache({
+			type: "src",
+			callbacks: [callback],
+			name: name,
+			id: id,
+			selectKey: selectKey
+		});
+	},
+
+	_getSrc: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug("_getSrc()");
+		if(evt.pkg){	
+			evt.type = "src";
+			dojo.doc._buildCache(evt);
+		}else{
+			if(evt.callbacks && evt.callbacks.length){
+				var callback =  evt.callbacks.shift();
+				callback.call(null, "error", {}, evt);
+			}
+		}
+	},
+
+	getDoc: function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name, /*String?*/ id){
+		// summary: Gets external documentation stored on jot
+		dojo.debug("getDoc()");
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		var input = {
+			type: "doc",
+			callbacks: [callback],
+			name: name,
+			id: id,
+			selectKey: selectKey
+		}
+		dojo.doc.functionPackage(dojo.doc._getDoc, input);
+	},
+
+	_getDoc: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug("_getDoc(" + evt.pkg + "/" + evt.name + ")");
+	
+		dojo.doc._keys[evt.selectKey] = {count: 0};
+
+		var search = {};
+		search.forFormName = "DocFnForm";
+		search.limit = 1;
+
+		if(!evt.id){
+			search.filter = "it/DocFnForm/require = '" + evt.pkg + "' and it/DocFnForm/name = '" + evt.name + "' and not(it/DocFnForm/id)";
+		}else{
+			search.filter = "it/DocFnForm/require = '" + evt.pkg + "' and it/DocFnForm/name = '" + evt.name + "' and it/DocFnForm/id = '" + evt.id + "'";
+		}
+		dojo.debug(dojo.json.serialize(search));
+	
+		dojo.doc._rpc.callRemote("search", search).addCallbacks(function(data){ evt.type = "fn"; dojo.doc._gotDoc("load", data.list[0], evt); }, function(data){ evt.type = "fn"; dojo.doc._gotDoc("error", {}, evt); });
+	
+		search.forFormName = "DocParamForm";
+
+		if(!evt.id){
+			search.filter = "it/DocParamForm/fns = '" + evt.pkg + "=>" + evt.name + "'";
+		}else{
+			search.filter = "it/DocParamForm/fns = '" + evt.pkg + "=>" + evt.name + "=>" + evt.id + "'";
+		}
+		delete search.limit;
+
+		dojo.doc._rpc.callRemote("search", search).addCallbacks(function(data){ evt.type = "param"; dojo.doc._gotDoc("load", data.list, evt); }, function(data){ evt.type = "param"; dojo.doc._gotDoc("error", {}, evt); });
+	},
+
+	_gotDoc: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug("_gotDoc(" + evt.type + ") for " + evt.selectKey);
+		dojo.doc._keys[evt.selectKey][evt.type] = data;
+		if(++dojo.doc._keys[evt.selectKey].count == 2){
+			dojo.debug("_gotDoc() finished");
+			var keys = dojo.doc._keys[evt.selectKey];
+			var description = '';
+			if(!keys.fn){
+				keys.fn = {}
+			}
+			if(keys.fn["main/text"]){
+				description = dojo.dom.createDocumentFromText(keys.fn["main/text"]).childNodes[0].innerHTML;
+				if(!description){
+					description = keys.fn["main/text"];
+				}			
+			}
+			data = {
+				description: description,
+				returns: keys.fn["DocFnForm/returns"],
+				id: keys.fn["DocFnForm/id"],
+				parameters: {},
+				variables: []
+			}
+			for(var i = 0, param; param = keys["param"][i]; i++){
+				data.parameters[param["DocParamForm/name"]] = {
+					description: param["DocParamForm/desc"]
+				};
+			}
+
+			delete dojo.doc._keys[evt.selectKey];
+		
+			if(evt.callbacks && evt.callbacks.length){
+				var callback = evt.callbacks.shift();
+				callback.call(null, "load", data, evt);
+			}
+		}
+	},
+
+	getPkgMeta: function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name){
+		dojo.debug("getPkgMeta(" + name + ")");
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		dojo.doc._buildCache({
+			type: "pkgmeta",
+			callbacks: [callback],
+			name: name,
+			selectKey: selectKey
+		});
+	},
+
+	_getPkgMeta: function(/*Object*/ input){
+		dojo.debug("_getPkgMeta(" + input.name + ")");
+		input.type = "pkgmeta";
+		dojo.doc._buildCache(input);
+	},
+
+	_onDocSearch: function(/*Object*/ input){
+		dojo.debug("_onDocSearch(" + input.name + ")");
+		if(!input.name){
+			return;
+		}
+		if(!input.selectKey){
+			input.selectKey = ++dojo.doc._count;
+		}
+		input.callbacks = [dojo.doc._onDocSearchFn];
+		input.name = input.name.toLowerCase();
+		input.type = "function_names";
+
+		dojo.doc._buildCache(input);
+	},
+
+	_onDocSearchFn: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug("_onDocSearchFn(" + evt.name + ")");
+		var packages = [];
+		var size = 0;
+		pkgLoop:
+		for(var pkg in data){
+			for(var i = 0, fn; fn = data[pkg][i]; i++){
+				if(fn.toLowerCase().indexOf(evt.name) != -1){
+					// Build a list of all packages that need to be loaded and their loaded state.
+					++size;
+					packages.push(pkg);
+					continue pkgLoop;
+				}
+			}
+		}
+		dojo.doc._keys[evt.selectKey] = {};
+		dojo.doc._keys[evt.selectKey].pkgs = packages;
+		dojo.doc._keys[evt.selectKey].pkg = evt.name; // Remember what we were searching for
+		dojo.doc._keys[evt.selectKey].loaded = 0;
+		for(var i = 0, pkg; pkg = packages[i]; i++){
+			setTimeout("dojo.doc.getPkgMeta(\"" + evt.selectKey + "\", dojo.doc._onDocResults, \"" + pkg + "\");", i*10);
+		}
+	},
+
+	_onDocResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug("_onDocResults(" + evt.name + "/" + dojo.doc._keys[evt.selectKey].pkg + ") " + type);
+		++dojo.doc._keys[evt.selectKey].loaded;
+
+		if(dojo.doc._keys[evt.selectKey].loaded == dojo.doc._keys[evt.selectKey].pkgs.length){
+			var info = dojo.doc._keys[evt.selectKey];
+			var pkgs = info.pkgs;
+			var name = info.pkg;
+			delete dojo.doc._keys[evt.selectKey];
+			var results = {selectKey: evt.selectKey, docResults: []};
+			data = dojo.doc._cache;
+
+			for(var i = 0, pkg; pkg = pkgs[i]; i++){
+				if(!data[pkg]){
+					continue;
+				}
+				for(var fn in data[pkg]["meta"]){
+					if(fn.toLowerCase().indexOf(name) == -1){
+						continue;
+					}
+					if(fn != "requires"){
+						for(var pId in data[pkg]["meta"][fn]){
+							var result = {
+								pkg: pkg,
+								name: fn,
+								summary: ""
+							}
+							if(data[pkg]["meta"][fn][pId].summary){
+								result.summary = data[pkg]["meta"][fn][pId].summary;
+							}
+							results.docResults.push(result);
+						}
+					}
+				}
+			}
+
+			dojo.debug("Publishing docResults");
+			dojo.doc._printResults(results);
+		}
+	},
+	
+	_printResults: function(results){
+		dojo.debug("_printResults(): called");
+		// summary: Call this function to send the /doc/results topic
+	},
+
+	_onDocSelectFunction: function(/*Object*/ input){
+		// summary: Get doc, meta, and src
+		var name = input.name;
+		var selectKey = selectKey;
+		dojo.debug("_onDocSelectFunction(" + name + ")");
+		if(!name){
+			return false;
+		}
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+
+		dojo.doc._keys[selectKey] = {size: 0};
+		dojo.doc._myKeys[++dojo.doc._count] = {selectKey: selectKey, type: "meta"}
+		dojo.doc.getMeta(dojo.doc._count, dojo.doc._onDocSelectResults, name);
+		dojo.doc._myKeys[++dojo.doc._count] = {selectKey: selectKey, type: "src"}
+		dojo.doc.getSrc(dojo.doc._count, dojo.doc._onDocSelectResults, name);
+		dojo.doc._myKeys[++dojo.doc._count] = {selectKey: selectKey, type: "doc"}
+		dojo.doc.getDoc(dojo.doc._count, dojo.doc._onDocSelectResults, name);
+	},
+
+	_onDocSelectResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug("dojo.doc._onDocSelectResults(" + evt.type + ", " + evt.name + ")");
+		var myKey = dojo.doc._myKeys[evt.selectKey];
+		dojo.doc._keys[myKey.selectKey][myKey.type] = data;
+		dojo.doc._keys[myKey.selectKey].size;
+		if(++dojo.doc._keys[myKey.selectKey].size == 3){
+			var key = dojo.lang.mixin(evt, dojo.doc._keys[myKey.selectKey]);
+			delete key.size;
+			dojo.debug("Publishing docFunctionDetail");
+			dojo.doc._printFunctionDetail(key);
+			delete dojo.doc._keys[myKey.selectKey];
+			delete dojo.doc._myKeys[evt.selectKey];
+		}
+	},
+	
+	_printFunctionDetail: function(results) {
+		// summary: Call this function to send the /doc/functionDetail topic event
+	},
+
+	_buildCache: function(/*Object*/ input){
+		var type = input.type;
+		var pkg = input.pkg;
+		var callbacks = input.callbacks;
+		var id = input.id;
+		if(!id){
+			id = "_";
+		}
+		var name = input.name;
+	
+		dojo.debug("_buildCache() type: " + type);
+		if(type == "function_names"){
+			if(!dojo.doc._cache["function_names"]){
+				dojo.debug("_buildCache() new cache");
+				if(callbacks && callbacks.length){
+					dojo.doc._callbacks.function_names.push([input, callbacks.shift()]);
+				}
+				dojo.doc._cache["function_names"] = {loading: true};
+				dojo.io.bind({
+					url: "json/function_names",
+					mimetype: "text/json",
+					error: function(type, data, evt){
+						dojo.debug("Unable to load function names");
+						for(var i = 0, callback; callback = dojo.doc._callbacks.function_names[i]; i++){
+							callback[1].call(null, "error", {}, callback[0]);
+						}
+					},
+					load: function(type, data, evt){
+						dojo.doc._cache['function_names'] = data;
+						for(var i = 0, callback; callback = dojo.doc._callbacks.function_names[i]; i++){
+							callback[1].call(null, "load", data, callback[0]);
+						}
+					}
+				});
+			}else if(dojo.doc._cache["function_names"].loading){
+				dojo.debug("_buildCache() loading cache");
+				if(callbacks && callbacks.length){
+					dojo.doc._callbacks.function_names.push([input, callbacks.shift()]);
+				}
+			}else{
+				dojo.debug("_buildCache() from cache");
+				if(callbacks && callbacks.length){
+					var callback = callbacks.shift();
+					callback.call(null, "load", dojo.doc._cache["function_names"], input);
+				}
+			}
+		}else if(type == "meta" || type == "src"){
+			if(!pkg){
+				if(type == "meta"){
+					dojo.doc.functionPackage(dojo.doc._getMeta, input);
+				}else{
+					dojo.doc.functionPackage(dojo.doc._getSrc, input);
+				}
+			}else{
+				try{
+					var cached = dojo.doc._cache[pkg][name][id][type];
+				}catch(e){}
+
+				if(cached){
+					if(callbacks && callbacks.length){
+						var callback = callbacks.shift();
+						callback.call(null, "load", cached, input);
+						return;
+					}
+				}
+
+				dojo.debug("Finding " + type + " for: " + pkg + ", function: " + name + ", id: " + id);
+
+				var mimetype = "text/json";
+				if(type == "src"){
+					mimetype = "text/plain"
+				}
+
+				var url = "json/" + pkg + "/" + name + "/" + id + "/" + type;
+
+				dojo.io.bind({
+					url: url,
+					input: input,
+					mimetype: mimetype,
+					error: function(type, data, evt, args){
+						var input = args.input;
+						var pkg = input.pkg;
+						var type = input.type;
+						var callbacks = input.callbacks;
+						var id = input.id;
+						var name = input.name;
+
+						if(callbacks && callbacks.length){
+							if(!data){
+								data = {};
+							}
+							if(!dojo.doc._cache[pkg]){
+								dojo.doc._cache[pkg] = {};
+							}
+							if(!dojo.doc._cache[pkg][name]){
+								dojo.doc._cache[pkg][name] = {};
+							}
+							if(type == "meta"){
+								data.sig = dojo.doc._cache[pkg][name][id].sig;
+								data.params = dojo.doc._cache[pkg][name][id].params;
+							}
+							var callback = callbacks.shift();
+							callback.call(null, "error", data, args.input);
+						}
+					},
+					load: function(type, data, evt, args){
+						var input = args.input;
+						var pkg = input.pkg;
+						var type = input.type;
+						var id = input.id;
+						var name = input.name;
+						var cache = dojo.doc._cache;
+						dojo.debug("_buildCache() loaded " + type);
+
+						if(!data){
+							data = {};
+						}
+						if(!cache[pkg]){
+							dojo.doc._cache[pkg] = {};
+						}
+						if(!cache[pkg][name]){
+							dojo.doc._cache[pkg][name] = {};
+						}
+						if(!cache[pkg][name][id]){
+							dojo.doc._cache[pkg][name][id] = {};
+						}
+						if(!cache[pkg][name][id].meta){
+							dojo.doc._cache[pkg][name][id].meta = {};
+						}
+						dojo.doc._cache[pkg][name][id][type] = data;
+						if(callbacks && callbacks.length){
+							var callback = callbacks.shift();
+							callback.call(null, "load", data, args.input);
+						}
+					}
+				});
+			}
+		}else if(type == "pkgmeta"){
+			try{
+				var cached = dojo.doc._cache[name]["meta"];
+			}catch(e){}
+
+			if(cached){
+				if(callbacks && callbacks.length){
+					var callback = callbacks.shift();
+					callback.call(null, "load", cached, input);
+					return;
+				}
+			}
+
+			dojo.debug("Finding package meta for: " + name);
+
+			dojo.io.bind({
+				url: "json/" + name + "/meta",
+				input: input,
+				mimetype: "text/json",
+				error: function(type, data, evt, args){
+					var callbacks = args.input.callbacks;
+					if(callbacks && callbacks.length){
+						var callback = callbacks.shift();
+						callback.call(null, "error", {}, args.input);
+					}
+				},
+				load: function(type, data, evt, args){
+					var pkg = args.input.name;
+					var cache = dojo.doc._cache;
+
+					dojo.debug("_buildCache() loaded for: " + pkg);
+					if(!cache[pkg]){
+						dojo.doc._cache[pkg] = {};
+					}
+				
+					if(!cache[pkg]["meta"]){
+						dojo.doc._cache[pkg]["meta"] = {};
+					}
+				
+					var methods = data.methods;
+					if(methods){
+						for(var method in methods){
+							if (method == "is") {
+								continue;
+							}
+							for(var pId in methods[method]){
+								if(!cache[pkg]["meta"][method]){
+									dojo.doc._cache[pkg]["meta"][method] = {};
+								}
+								if(!cache[pkg]["meta"][method][pId]){
+									dojo.doc._cache[pkg]["meta"][method][pId] = {};
+								}
+								dojo.doc._cache[pkg]["meta"][method][pId].summary = methods[method][pId];
+							}
+						}
+					}
+
+					dojo.doc._cache[pkg]["meta"].methods = methods;
+					var requires = data.requires;
+					if(requires){
+						dojo.doc._cache[pkg]["meta"].requires = requires;
+					}
+					if(callbacks && callbacks.length){
+						var callback = callbacks.shift();
+						callback.call(null, "load", methods, input);
+					}
+				}
+			});
+		}
+	},
+
+	selectFunction: function(/*String*/ name, /*String?*/ id){
+		// summary: The combined information
+	},
+
+	savePackage: function(/*String*/ name, /*String*/ description){
+		dojo.doc._rpc.callRemote(
+			"saveForm",
+			{
+				form: "DocPkgForm",
+				path: "/WikiHome/DojoDotDoc/id",
+				pname1: "main/text",
+				pvalue1: "Test"
+			}
+		).addCallbacks(dojo.doc._results, dojo.doc._results);
+	},
+
+	functionPackage: function(/*Function*/ callback, /*Object*/ input){
+		dojo.debug("functionPackage() name: " + input.name + " for type: " + input.type);
+		input.type = "function_names";
+		input.callbacks.unshift(callback);
+		input.callbacks.unshift(dojo.doc._functionPackage);
+		dojo.doc._buildCache(input);
+	},
+
+	_functionPackage: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug("_functionPackage() name: " + evt.name + " for: " + evt.type + " with: " + type);
+		evt.pkg = '';
+
+		var data = dojo.doc._cache['function_names'];
+		for(var key in data){
+			if(dojo.lang.inArray(data[key], evt.name)){
+				evt.pkg = key;
+				break;
+			}
+		}
+
+		if(evt.callbacks && evt.callbacks.length){
+			var callback = evt.callbacks.shift();
+			callback.call(null, type, data[key], evt);
+		}
+	},
+
+	_sort: function(a, b){
+		if(a[0] < b[0]){
+			return -1;
+		}
+		if(a[0] > b[0]){
+			return 1;
+		}
+	  return 0;
+	}
+});
+
+dojo.event.topic.subscribe("/doc/search", dojo.doc, "_onDocSearch");
+dojo.event.topic.subscribe("/doc/selectFunction", dojo.doc, "_onDocSelectFunction");
+
+dojo.event.topic.registerPublisher("/doc/results", dojo.doc, "_printResults");
+dojo.event.topic.registerPublisher("/doc/functionDetail", dojo.doc, "_printFunctionDetail");
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/docs.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/docs.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/docs.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,671 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-dojo.provide("dojo.docs");
-dojo.require("dojo.io.*");
-dojo.require("dojo.event.topic");
-dojo.require("dojo.rpc.JotService");
-dojo.require("dojo.dom");
-dojo.require("dojo.uri.Uri");
-dojo.require("dojo.Deferred");
-dojo.require("dojo.DeferredList");
-
-/*
- * TODO:
- *
- * Package summary needs to compensate for "is"
- * Handle host environments
- * Deal with dojo.widget weirdness
- * Parse parameters
- * Limit function parameters to only the valid ones (Involves packing parameters onto meta during rewriting)
- *
- */
-
-dojo.docs = new function() {
-	this._url = dojo.uri.dojoUri("docscripts");
-	this._rpc = new dojo.rpc.JotService;
-	this._rpc.serviceUrl = dojo.uri.dojoUri("docscripts/jsonrpc.php");
-};
-dojo.lang.mixin(dojo.docs, {
-	_count: 0,
-	_callbacks: {function_names: []},
-	_cache: {}, // Saves the JSON objects in cache
-	require: function(/*String*/ require, /*bool*/ sync) {
-		dojo.debug("require(): " + require);
-		var parts = require.split("/");
-		
-		var size = parts.length;
-		var deferred = new dojo.Deferred;
-		var args = {
-			mimetype: "text/json",
-			load: function(type, data){
-				dojo.debug("require(): loaded for " + require);
-				
-				if(parts[0] != "function_names") {
-					for(var i = 0, part; part = parts[i]; i++){
-						data = data[part];
-					}
-				}
-				deferred.callback(data);
-			},
-			error: function(){
-				deferred.errback();
-			}
-		};
-
-		if(location.protocol == "file:"){
-			if(size){
-				if(parts[parts.length - 1] == "documentation"){
-					parts[parts.length - 1] = "meta";
-				}
-			
-				if(parts[0] == "function_names"){
-					args.url = [this._url, "local_json", "function_names"].join("/");
-				}else{
-					var dirs = parts[0].split(".");
-					args.url = [this._url, "local_json", dirs[0]].join("/");
-					if(dirs.length > 1){
-						args.url = [args.url, dirs[1]].join(".");
-					}
-				}
-			}
-		}
-		
-		dojo.io.bind(args);
-		return deferred;
-	},
-	getFunctionNames: function(){
-		return this.require("function_names"); // dojo.Deferred
-	},
-	unFormat: function(/*String*/ string){
-		var fString = string;
-		if(string.charAt(string.length - 1) == "_"){
-			fString = [string.substring(0, string.length - 1), "*"].join("");
-		}
-		return fString;
-	},
-	getMeta: function(/*String*/ pkg, /*String*/ name, /*Function*/ callback, /*String?*/ id){
-		// summary: Gets information about a function in regards to its meta data
-		if(typeof name == "function"){
-			// pId: a
-			// pkg: ignore
-			id = callback;
-			callback = name;
-			name = pkg;
-			pkg = null;
-			dojo.debug("getMeta(" + name + ")");
-		}else{
-			dojo.debug("getMeta(" + pkg + "/" + name + ")");
-		}
-		
-		if(!id){
-			id = "_";
-		}
-	},
-	_withPkg: function(/*String*/ type, /*Object*/ data, /*Object*/ evt, /*Object*/ input, /*String*/ newType){
-		dojo.debug("_withPkg(" + evt.name + ") has package: " + data[0]);
-		evt.pkg = data[0];
-		if("load" == type && evt.pkg){
-			evt.type = newType;
-		}else{
-			if(evt.callbacks && evt.callbacks.length){
-				evt.callbacks.shift()("error", {}, evt, evt.input);
-			}
-		}
-	},
-	_gotMeta: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
-		dojo.debug("_gotMeta(" + evt.name + ")");
-
-		var cached = dojo.docs._getCache(evt.pkg, evt.name, "meta", "functions", evt.id);
-		if(cached.summary){
-			data.summary = cached.summary;
-		}
-		if(evt.callbacks && evt.callbacks.length){
-			evt.callbacks.shift()(type, data, evt, evt.input);
-		}
-	},
-	getSrc: function(/*String*/ name, /*Function*/ callback, /*String?*/ id){
-		// summary: Gets src file (created by the doc parser)
-		dojo.debug("getSrc(" + name + ")");
-		if(!id){
-			id = "_";
-		}
-	},
-	getDoc: function(/*String*/ name, /*Function*/ callback, /*String?*/ id){
-		// summary: Gets external documentation stored on Jot for a given function
-		dojo.debug("getDoc(" + name  + ")");
-
-		if(!id){
-			id = "_";
-		}
-
-		var input = {};
-
-		input.type = "doc";
-		input.name = name;
-		input.callbacks = [callback];
-	},
-	_gotDoc: function(/*String*/ type, /*Array*/ data, /*Object*/ evt, /*Object*/ input){
-		dojo.debug("_gotDoc(" + evt.type + ")");
-		
-		evt[evt.type] = data;
-		if(evt.expects && evt.expects.doc){
-			for(var i = 0, expect; expect = evt.expects.doc[i]; i++){
-				if(!(expect in evt)){
-					dojo.debug("_gotDoc() waiting for more data");
-					return;
-				}
-			}
-		}
-		
-		var cache = dojo.docs._getCache(evt.pkg, "meta", "functions", evt.name, evt.id, "meta");
-
-		var description = evt.fn.description;
-		cache.description = description;
-		data = {
-			returns: evt.fn.returns,
-			id: evt.id,
-			variables: []
-		}
-		if(!cache.parameters){
-			cache.parameters = {};
-		}
-		for(var i = 0, param; param = evt.param[i]; i++){
-			var fName = param["DocParamForm/name"];
-			if(!cache.parameters[fName]){
-				cache.parameters[fName] = {};
-			}
-			cache.parameters[fName].description = param["DocParamForm/desc"]
-		}
-
-		data.description = cache.description;
-		data.parameters = cache.parameters;
-		
-		evt.type = "doc";
-	
-		if(evt.callbacks && evt.callbacks.length){
-			evt.callbacks.shift()("load", data, evt, input);
-		}
-	},
-	getPkgDoc: function(/*String*/ name, /*Function*/ callback){
-		// summary: Gets external documentation stored on Jot for a given package
-		dojo.debug("getPkgDoc(" + name + ")");
-		var input = {};
-	},
-	getPkgInfo: function(/*String*/ name, /*Function*/ callback){
-		// summary: Gets a combination of the metadata and external documentation for a given package
-		dojo.debug("getPkgInfo(" + name + ")");
-
-		var input = {
-			expects: {
-				pkginfo: ["pkgmeta", "pkgdoc"]
-			},
-			callback: callback
-		};
-		dojo.docs.getPkgMeta(input, name, dojo.docs._getPkgInfo);
-		dojo.docs.getPkgDoc(input, name, dojo.docs._getPkgInfo);
-	},
-	_getPkgInfo: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
-		dojo.debug("_getPkgInfo() for " + evt.type);
-		var input = {};
-		var results = {};
-		if(typeof key == "object"){
-			input = key;
-			input[evt.type] = data;
-			if(input.expects && input.expects.pkginfo){
-				for(var i = 0, expect; expect = input.expects.pkginfo[i]; i++){
-					if(!(expect in input)){
-						dojo.debug("_getPkgInfo() waiting for more data");
-						return;
-					}
-				}
-			}
-			results = input.pkgmeta;
-			results.description = input.pkgdoc;
-		}
-
-		if(input.callback){
-			input.callback("load", results, evt);
-		}
-	},
-	getInfo: function(/*String*/ name, /*Function*/ callback){
-		dojo.debug("getInfo(" + name + ")");
-		var input = {
-			expects: {
-				"info": ["meta", "doc"]
-			},
-			callback: callback
-		}
-		dojo.docs.getMeta(input, name, dojo.docs._getInfo);
-		dojo.docs.getDoc(input, name, dojo.docs._getInfo);
-	},
-	_getInfo: function(/*String*/ type, /*String*/ data, /*Object*/ evt, /*Object*/ input){
-		dojo.debug("_getInfo(" + evt.type + ")");
-		if(input && input.expects && input.expects.info){
-			input[evt.type] = data;
-			for(var i = 0, expect; expect = input.expects.info[i]; i++){
-				if(!(expect in input)){
-					dojo.debug("_getInfo() waiting for more data");
-					return;
-				}
-			}
-		}
-
-		if(input.callback){
-			input.callback("load", dojo.docs._getCache(evt.pkg, "meta", "functions", evt.name, evt.id, "meta"), evt, input);
-		}
-	},
-	_getMainText: function(/*String*/ text){
-		// summary: Grabs the innerHTML from a Jot Rech Text node
-		dojo.debug("_getMainText()");
-		return text.replace(/^<html[^<]*>/, "").replace(/<\/html>$/, "").replace(/<\w+\s*\/>/g, "");
-	},
-	getPackageMeta: function(/*Object*/ input){
-		dojo.debug("getPackageMeta(): " + input.package);
-		return this.require(input.package + "/meta", input.sync);
-	},
-	getFunctionMeta: function(/*Object*/ input){
-		var package = input.package || "";
-		var name = input.name;
-		var id = input.id || "_";
-		dojo.debug("getFunctionMeta(): " + name);
-
-		if(!name) return;
-
-		if(package){
-			return this.require(package + "/meta/functions/" + name + "/" + id + "/meta");
-		}else{
-			this.getFunctionNames();
-		}
-	},
-	getFunctionDocumentation: function(/*Object*/ input){
-		var package = input.package || "";
-		var name = input.name;
-		var id = input.id || "_";
-		dojo.debug("getFunctionDocumentation(): " + name);
-		
-		if(!name) return;
-		
-		if(package){
-			return this.require(package + "/meta/functions/" + name + "/" + id + "/documentation");
-		}
-	},
-	_onDocSearch: function(/*Object*/ input){
-		var _this = this;
-		var name = input.name.toLowerCase();
-		if(!name) return;
-
-		this.getFunctionNames().addCallback(function(data){
-			dojo.debug("_onDocSearch(): function names loaded for " + name);
-
-			var output = [];
-			var list = [];
-			var closure = function(pkg, fn) {
-				return function(data){
-					dojo.debug("_onDocSearch(): package meta loaded for: " + pkg);
-					if(data.functions){
-						var functions = data.functions;
-						for(var key in functions){
-							if(fn == key){
-								var ids = functions[key];
-								for(var id in ids){
-									var fnMeta = ids[id];
-									output.push({
-										package: pkg,
-										name: fn,
-										id: id,
-										summary: fnMeta.summary
-									});
-								}
-							}
-						}
-					}
-					return output;
-				}
-			}
-
-			pkgLoop:
-			for(var pkg in data){
-				if(pkg.toLowerCase() == name){
-					name = pkg;
-					dojo.debug("_onDocSearch found a package");
-					//dojo.docs._onDocSelectPackage(input);
-					return;
-				}
-				for(var i = 0, fn; fn = data[pkg][i]; i++){
-					if(fn.toLowerCase().indexOf(name) != -1){
-						dojo.debug("_onDocSearch(): Search matched " + fn);
-						var meta = _this.getPackageMeta({package: pkg});
-						meta.addCallback(closure(pkg, fn));
-						list.push(meta);
-
-						// Build a list of all packages that need to be loaded and their loaded state.
-						continue pkgLoop;
-					}
-				}
-			}
-			
-			list = new dojo.DeferredList(list);
-			list.addCallback(function(results){
-				dojo.debug("_onDocSearch(): All packages loaded");
-				_this._printFunctionResults(results[0][1]);
-			});
-		});
-	},
-	_onDocSearchFn: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
-		dojo.debug("_onDocSearchFn(" + evt.name + ")");
-
-		var name = evt.name || evt.pkg;
-
-		dojo.debug("_onDocSearchFn found a function");
-
-		evt.pkgs = packages;
-		evt.pkg = name;
-		evt.loaded = 0;
-		for(var i = 0, pkg; pkg = packages[i]; i++){
-			dojo.docs.getPkgMeta(evt, pkg, dojo.docs._onDocResults);
-		}
-	},
-	_onPkgResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt, /*Object*/ input){
-		dojo.debug("_onPkgResults(" + evt.type + ")");
-		var description = "";
-		var path = "";
-		var methods = {};
-		var requires = {};
-		if(input){
-			input[evt.type] = data;
-			if(input.expects && input.expects.pkgresults){
-				for(var i = 0, expect; expect = input.expects.pkgresults[i]; i++){
-					if(!(expect in input)){
-						dojo.debug("_onPkgResults() waiting for more data");
-						return;
-					}
-				}
-			}
-			path = input.pkgdoc.path;
-			description = input.pkgdoc.description;
-			methods = input.pkgmeta.methods;
-			requires = input.pkgmeta.requires;
-		}
-		var pkg = evt.name.replace("_", "*");
-		var results = {
-			path: path,
-			description: description,
-			size: 0,
-			methods: [],
-			pkg: pkg,
-			requires: requires
-		}
-		var rePrivate = /_[^.]+$/;
-		for(var method in methods){
-			if(!rePrivate.test(method)){
-				for(var pId in methods[method]){
-					results.methods.push({
-						pkg: pkg,
-						name: method,
-						id: pId,
-						summary: methods[method][pId].summary
-					})
-				}
-			}
-		}
-		results.size = results.methods.length;
-		dojo.docs._printPkgResult(results);
-	},
-	_onDocResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt, /*Object*/ input){
-		dojo.debug("_onDocResults(" + evt.name + "/" + input.pkg + ") " + type);
-		++input.loaded;
-
-		if(input.loaded == input.pkgs.length){
-			var pkgs = input.pkgs;
-			var name = input.pkg;
-			var results = {methods: []};
-			var rePrivate = /_[^.]+$/;
-			data = dojo.docs._cache;
-
-			for(var i = 0, pkg; pkg = pkgs[i]; i++){
-				var methods = dojo.docs._getCache(pkg, "meta", "methods");
-				for(var fn in methods){
-					if(fn.toLowerCase().indexOf(name) == -1){
-						continue;
-					}
-					if(fn != "requires" && !rePrivate.test(fn)){
-						for(var pId in methods[fn]){
-							var result = {
-								pkg: pkg,
-								name: fn,
-								id: "_",
-								summary: ""
-							}
-							if(methods[fn][pId].summary){
-								result.summary = methods[fn][pId].summary;
-							}
-							results.methods.push(result);
-						}
-					}
-				}
-			}
-
-			dojo.debug("Publishing docResults");
-			dojo.docs._printFnResults(results);
-		}
-	},
-	_printFunctionResults: function(results){
-		dojo.debug("_printFnResults(): called");
-		// summary: Call this function to send the /docs/function/results topic
-	},
-	_printPkgResult: function(results){
-		dojo.debug("_printPkgResult(): called");
-	},
-	_onDocSelectFunction: function(/*Object*/ input){
-		// summary: Get doc, meta, and src
-		var name = input.name;
-		var package = input.package || "";
-		var id = input.id || "_";
-		dojo.debug("_onDocSelectFunction(" + name + ")");
-		if(!name || !package) return false;
-
-		var pkgMeta = this.getPackageMeta({package: package});
-		var meta = this.getFunctionMeta({package: package, name: name, id: id});
-		var doc = this.getFunctionDocumentation({package: package, name: name, id: id});
-		
-		var list = new dojo.DeferredList([pkgMeta, meta, doc]);
-		list.addCallback(function(results){
-			dojo.debug("_onDocSelectFunction() loaded");
-			for(var i = 0, result; result = results[i]; i++){
-				dojo.debugShallow(result[1]);
-			}
-		});
-		
-		return list;
-	},
-	_onDocSelectPackage: function(/*Object*/ input){
-		dojo.debug("_onDocSelectPackage(" + input.name + ")")
-		input.expects = {
-			"pkgresults": ["pkgmeta", "pkgdoc"]
-		};
-		dojo.docs.getPkgMeta(input, input.name, dojo.docs._onPkgResults);
-		dojo.docs.getPkgDoc(input, input.name, dojo.docs._onPkgResults);
-	},
-	_onDocSelectResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt, /*Object*/ input){
-		dojo.debug("_onDocSelectResults(" + evt.type + ", " + evt.name + ")");
-		if(evt.type == "meta"){
-			dojo.docs.getPkgMeta(input, evt.pkg, dojo.docs._onDocSelectResults);
-		}
-		if(input){
-			input[evt.type] = data;
-			if(input.expects && input.expects.docresults){
-				for(var i = 0, expect; expect = input.expects.docresults[i]; i++){
-					if(!(expect in input)){
-						dojo.debug("_onDocSelectResults() waiting for more data");
-						return;
-					}
-				}
-			}
-		}
-
-		dojo.docs._printFunctionDetail(input);
-	},
-	
-	_printFunctionDetail: function(results) {
-		// summary: Call this function to send the /docs/function/detail topic event
-	},
-
-	selectFunction: function(/*String*/ name, /*String?*/ id){
-		// summary: The combined information
-	},
-	savePackage: function(/*Object*/ callbackObject, /*String*/ callback, /*Object*/ parameters){
-		dojo.event.kwConnect({
-			srcObj: dojo.docs,
-			srcFunc: "_savedPkgRpc",
-			targetObj: callbackObject,
-			targetFunc: callback,
-			once: true
-		});
-		
-		var props = {};
-		var cache = dojo.docs._getCache(parameters.pkg, "meta");
-
-		var i = 1;
-
-		if(!cache.path){
-			var path = "id";
-			props[["pname", i].join("")] = "DocPkgForm/require";
-			props[["pvalue", i++].join("")] = parameters.pkg;
-		}else{
-			var path = cache.path;
-		}
-
-		props.form = "//DocPkgForm";
-		props.path = ["/WikiHome/DojoDotDoc/", path].join("");
-
-		if(parameters.description){
-			props[["pname", i].join("")] = "main/text";
-			props[["pvalue", i++].join("")] = parameters.description;
-		}
-		
-		dojo.docs._rpc.callRemote("saveForm",	props).addCallbacks(dojo.docs._pkgRpc, dojo.docs._pkgRpc);
-	},
-	_pkgRpc: function(data){
-		if(data.name){
-			dojo.docs._getCache(data["DocPkgForm/require"], "meta").path = data.name;
-			dojo.docs._savedPkgRpc("load");
-		}else{
-			dojo.docs._savedPkgRpc("error");
-		}
-	},
-	_savedPkgRpc: function(type){
-	},
-	functionPackages: function(/*String*/ name, /*Function*/ callback, /*Object*/ input){
-		// summary: Gets the package associated with a function and stores it in the .pkg value of input
-		dojo.debug("functionPackages() name: " + name);
-
-		if(!input){
-			input = {};
-		}
-		if(!input.callbacks){
-			input.callbacks = [];
-		}
-
-		input.type = "function_names";
-		input.name = name;
-		input.callbacks.unshift(callback);
-		input.callbacks.unshift(dojo.docs._functionPackages);
-	},
-	_functionPackages: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
-		dojo.debug("_functionPackages() name: " + evt.name);
-		evt.pkg = '';
-
-		var results = [];
-		var data = dojo.docs._cache['function_names'];
-		for(var key in data){
-			if(dojo.lang.inArray(data[key], evt.name)){
-				dojo.debug("_functionPackages() package: " + key);
-				results.push(key);
-			}
-		}
-
-		if(evt.callbacks && evt.callbacks.length){
-			evt.callbacks.shift()(type, results, evt, evt.input);
-		}
-	},
-	setUserName: function(/*String*/ name){
-		dojo.docs._userName = name;
-		if(name && dojo.docs._password){
-			dojo.docs._logIn();
-		}
-	},
-	setPassword: function(/*String*/ password){
-		dojo.docs._password = password;
-		if(password && dojo.docs._userName){
-			dojo.docs._logIn();
-		}
-	},
-	_logIn: function(){
-		dojo.io.bind({
-			url: dojo.docs._rpc.serviceUrl.toString(),
-			method: "post",
-			mimetype: "text/json",
-			content: {
-				username: dojo.docs._userName,
-				password: dojo.docs._password
-			},
-			load: function(type, data){
-				if(data.error){
-					dojo.docs.logInSuccess();
-				}else{
-					dojo.docs.logInFailure();
-				}
-			},
-			error: function(){
-				dojo.docs.logInFailure();
-			}
-		});
-	},
-	logInSuccess: function(){},
-	logInFailure: function(){},
-	_set: function(/*Object*/ base, /*String...*/ keys, /*String*/ value){
-		var args = [];
-		for(var i = 0, arg; arg = arguments[i]; i++){
-			args.push(arg);
-		}
-
-		if(args.length < 3) return;
-		base = args.shift();
-		value = args.pop();
-		var key = args.pop();
-		for(var i = 0, arg; arg = args[i]; i++){
-			if(typeof base[arg] != "object"){
-				base[arg] = {};
-			}
-			base = base[arg];
-		}
-		base[key] = value;
-	},
-	_getCache: function(/*String...*/ keys){
-		var obj = dojo.docs._cache;
-		for(var i = 0; i < arguments.length; i++){
-			var arg = arguments[i];
-			if(!obj[arg]){
-				obj[arg] = {};
-			}
-			obj = obj[arg];
-		}
-		return obj;
-	}
-});
-
-dojo.event.topic.subscribe("/docs/search", dojo.docs, "_onDocSearch");
-dojo.event.topic.subscribe("/docs/function/select", dojo.docs, "_onDocSelectFunction");
-dojo.event.topic.subscribe("/docs/package/select", dojo.docs, "_onDocSelectPackage");
-
-dojo.event.topic.registerPublisher("/docs/function/results", dojo.docs, "_printFunctionResults");
-dojo.event.topic.registerPublisher("/docs/function/detail", dojo.docs, "_printFunctionDetail");
-dojo.event.topic.registerPublisher("/docs/package/detail", dojo.docs, "_printPkgResult");

Modified: tags/parley-0.53/root/static/magic/src/dom.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/dom.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/dom.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,374 +8,478 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.dom");
+dojo.require("dojo.lang.array");
 
+dojo.dom.ELEMENT_NODE                  = 1;
+dojo.dom.ATTRIBUTE_NODE                = 2;
+dojo.dom.TEXT_NODE                     = 3;
+dojo.dom.CDATA_SECTION_NODE            = 4;
+dojo.dom.ENTITY_REFERENCE_NODE         = 5;
+dojo.dom.ENTITY_NODE                   = 6;
+dojo.dom.PROCESSING_INSTRUCTION_NODE   = 7;
+dojo.dom.COMMENT_NODE                  = 8;
+dojo.dom.DOCUMENT_NODE                 = 9;
+dojo.dom.DOCUMENT_TYPE_NODE            = 10;
+dojo.dom.DOCUMENT_FRAGMENT_NODE        = 11;
+dojo.dom.NOTATION_NODE                 = 12;
+	
+dojo.dom.dojoml = "http://www.dojotoolkit.org/2004/dojoml";
 
-dojo.provide("dojo.dom");
-dojo.dom.ELEMENT_NODE = 1;
-dojo.dom.ATTRIBUTE_NODE = 2;
-dojo.dom.TEXT_NODE = 3;
-dojo.dom.CDATA_SECTION_NODE = 4;
-dojo.dom.ENTITY_REFERENCE_NODE = 5;
-dojo.dom.ENTITY_NODE = 6;
-dojo.dom.PROCESSING_INSTRUCTION_NODE = 7;
-dojo.dom.COMMENT_NODE = 8;
-dojo.dom.DOCUMENT_NODE = 9;
-dojo.dom.DOCUMENT_TYPE_NODE = 10;
-dojo.dom.DOCUMENT_FRAGMENT_NODE = 11;
-dojo.dom.NOTATION_NODE = 12;
-dojo.dom.dojoml = "http://www.dojotoolkit.org/2004/dojoml";
-dojo.dom.xmlns = {svg:"http://www.w3.org/2000/svg", smil:"http://www.w3.org/2001/SMIL20/", mml:"http://www.w3.org/1998/Math/MathML", cml:"http://www.xml-cml.org", xlink:"http://www.w3.org/1999/xlink", xhtml:"http://www.w3.org/1999/xhtml", xul:"http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", xbl:"http://www.mozilla.org/xbl", fo:"http://www.w3.org/1999/XSL/Format", xsl:"http://www.w3.org/1999/XSL/Transform", xslt:"http://www.w3.org/1999/XSL/Transform", xi:"http://www.w3.org/2001/XInclude", xforms:"http://www.w3.org/2002/01/xforms", saxon:"http://icl.com/saxon", xalan:"http://xml.apache.org/xslt", xsd:"http://www.w3.org/2001/XMLSchema", dt:"http://www.w3.org/2001/XMLSchema-datatypes", xsi:"http://www.w3.org/2001/XMLSchema-instance", rdf:"http://www.w3.org/1999/02/22-rdf-syntax-ns#", rdfs:"http://www.w3.org/2000/01/rdf-schema#", dc:"http://purl.org/dc/elements/1.1/", dcq:"http://purl.org/dc/qualifiers/1.0", "soap-env":"http://schemas.xmlsoap.org/soap/envelope/",!
  wsdl:"http://schemas.xmlsoap.org/wsdl/", AdobeExtensions:"http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"};
-dojo.dom.isNode = function (wh) {
-	if (typeof Element == "function") {
+/**
+ *	comprehensive list of XML namespaces
+**/
+dojo.dom.xmlns = {
+	svg : "http://www.w3.org/2000/svg",
+	smil : "http://www.w3.org/2001/SMIL20/",
+	mml : "http://www.w3.org/1998/Math/MathML",
+	cml : "http://www.xml-cml.org",
+	xlink : "http://www.w3.org/1999/xlink",
+	xhtml : "http://www.w3.org/1999/xhtml",
+	xul : "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
+	xbl : "http://www.mozilla.org/xbl",
+	fo : "http://www.w3.org/1999/XSL/Format",
+	xsl : "http://www.w3.org/1999/XSL/Transform",
+	xslt : "http://www.w3.org/1999/XSL/Transform",
+	xi : "http://www.w3.org/2001/XInclude",
+	xforms : "http://www.w3.org/2002/01/xforms",
+	saxon : "http://icl.com/saxon",
+	xalan : "http://xml.apache.org/xslt",
+	xsd : "http://www.w3.org/2001/XMLSchema",
+	dt: "http://www.w3.org/2001/XMLSchema-datatypes",
+	xsi : "http://www.w3.org/2001/XMLSchema-instance",
+	rdf : "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
+	rdfs : "http://www.w3.org/2000/01/rdf-schema#",
+	dc : "http://purl.org/dc/elements/1.1/",
+	dcq: "http://purl.org/dc/qualifiers/1.0",
+	"soap-env" : "http://schemas.xmlsoap.org/soap/envelope/",
+	wsdl : "http://schemas.xmlsoap.org/wsdl/",
+	AdobeExtensions : "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/"
+};
+
+dojo.dom.isNode = function(wh){
+	if(typeof Element == "object") {
 		try {
 			return wh instanceof Element;
-		}
-		catch (e) {
-		}
+		} catch(E) {}
 	} else {
+		// best-guess
 		return wh && !isNaN(wh.nodeType);
 	}
-};
-dojo.dom.getUniqueId = function () {
-	var _document = dojo.doc();
+}
+
+dojo.dom.getTagName = function(node){
+	dojo.deprecated("dojo.dom.getTagName", "use node.tagName instead", "0.4");
+
+	var tagName = node.tagName;
+	if(tagName.substr(0,5).toLowerCase()!="dojo:"){
+		
+		if(tagName.substr(0,4).toLowerCase()=="dojo"){
+			// FIXME: this assuumes tag names are always lower case
+			return "dojo:" + tagName.substring(4).toLowerCase();
+		}
+
+		// allow lower-casing
+		var djt = node.getAttribute("dojoType")||node.getAttribute("dojotype");
+		if(djt){
+			return "dojo:"+djt.toLowerCase();
+		}
+		
+		if((node.getAttributeNS)&&(node.getAttributeNS(this.dojoml,"type"))){
+			return "dojo:" + node.getAttributeNS(this.dojoml,"type").toLowerCase();
+		}
+		try{
+			// FIXME: IE really really doesn't like this, so we squelch
+			// errors for it
+			djt = node.getAttribute("dojo:type");
+		}catch(e){ /* FIXME: log? */ }
+		if(djt){
+			return "dojo:"+djt.toLowerCase();
+		}
+
+		if((!dj_global["djConfig"])||(!djConfig["ignoreClassNames"])){
+			// FIXME: should we make this optionally enabled via djConfig?
+			var classes = node.className||node.getAttribute("class");
+			// FIXME: following line, without check for existence of classes.indexOf
+			// breaks firefox 1.5's svg widgets
+			if((classes)&&(classes.indexOf)&&(classes.indexOf("dojo-") != -1)){
+				var aclasses = classes.split(" ");
+				for(var x=0; x<aclasses.length; x++){
+					if((aclasses[x].length>5)&&(aclasses[x].indexOf("dojo-")>=0)){
+						return "dojo:"+aclasses[x].substr(5).toLowerCase();
+					}
+				}
+			}
+		}
+
+	}
+	return tagName.toLowerCase();
+}
+
+dojo.dom.getUniqueId = function(){
 	do {
 		var id = "dj_unique_" + (++arguments.callee._idIncrement);
-	} while (_document.getElementById(id));
+	}while(document.getElementById(id));
 	return id;
-};
+}
 dojo.dom.getUniqueId._idIncrement = 0;
-dojo.dom.firstElement = dojo.dom.getFirstChildElement = function (parentNode, tagName) {
+
+dojo.dom.firstElement = dojo.dom.getFirstChildElement = function(parentNode, tagName){
 	var node = parentNode.firstChild;
-	while (node && node.nodeType != dojo.dom.ELEMENT_NODE) {
+	while(node && node.nodeType != dojo.dom.ELEMENT_NODE){
 		node = node.nextSibling;
 	}
-	if (tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
+	if(tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
 		node = dojo.dom.nextElement(node, tagName);
 	}
 	return node;
-};
-dojo.dom.lastElement = dojo.dom.getLastChildElement = function (parentNode, tagName) {
+}
+
+dojo.dom.lastElement = dojo.dom.getLastChildElement = function(parentNode, tagName){
 	var node = parentNode.lastChild;
-	while (node && node.nodeType != dojo.dom.ELEMENT_NODE) {
+	while(node && node.nodeType != dojo.dom.ELEMENT_NODE) {
 		node = node.previousSibling;
 	}
-	if (tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
+	if(tagName && node && node.tagName && node.tagName.toLowerCase() != tagName.toLowerCase()) {
 		node = dojo.dom.prevElement(node, tagName);
 	}
 	return node;
-};
-dojo.dom.nextElement = dojo.dom.getNextSiblingElement = function (node, tagName) {
-	if (!node) {
-		return null;
-	}
+}
+
+dojo.dom.nextElement = dojo.dom.getNextSiblingElement = function(node, tagName){
+	if(!node) { return null; }
 	do {
 		node = node.nextSibling;
-	} while (node && node.nodeType != dojo.dom.ELEMENT_NODE);
-	if (node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
+	} while(node && node.nodeType != dojo.dom.ELEMENT_NODE);
+
+	if(node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
 		return dojo.dom.nextElement(node, tagName);
 	}
 	return node;
-};
-dojo.dom.prevElement = dojo.dom.getPreviousSiblingElement = function (node, tagName) {
-	if (!node) {
-		return null;
-	}
-	if (tagName) {
-		tagName = tagName.toLowerCase();
-	}
+}
+
+dojo.dom.prevElement = dojo.dom.getPreviousSiblingElement = function(node, tagName){
+	if(!node) { return null; }
+	if(tagName) { tagName = tagName.toLowerCase(); }
 	do {
 		node = node.previousSibling;
-	} while (node && node.nodeType != dojo.dom.ELEMENT_NODE);
-	if (node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
+	} while(node && node.nodeType != dojo.dom.ELEMENT_NODE);
+
+	if(node && tagName && tagName.toLowerCase() != node.tagName.toLowerCase()) {
 		return dojo.dom.prevElement(node, tagName);
 	}
 	return node;
-};
-dojo.dom.moveChildren = function (srcNode, destNode, trim) {
+}
+
+// TODO: hmph
+/*this.forEachChildTag = function(node, unaryFunc) {
+	var child = this.getFirstChildTag(node);
+	while(child) {
+		if(unaryFunc(child) == "break") { break; }
+		child = this.getNextSiblingTag(child);
+	}
+}*/
+
+dojo.dom.moveChildren = function(srcNode, destNode, trim){
 	var count = 0;
-	if (trim) {
-		while (srcNode.hasChildNodes() && srcNode.firstChild.nodeType == dojo.dom.TEXT_NODE) {
+	if(trim) {
+		while(srcNode.hasChildNodes() &&
+			srcNode.firstChild.nodeType == dojo.dom.TEXT_NODE) {
 			srcNode.removeChild(srcNode.firstChild);
 		}
-		while (srcNode.hasChildNodes() && srcNode.lastChild.nodeType == dojo.dom.TEXT_NODE) {
+		while(srcNode.hasChildNodes() &&
+			srcNode.lastChild.nodeType == dojo.dom.TEXT_NODE) {
 			srcNode.removeChild(srcNode.lastChild);
 		}
 	}
-	while (srcNode.hasChildNodes()) {
+	while(srcNode.hasChildNodes()){
 		destNode.appendChild(srcNode.firstChild);
 		count++;
 	}
 	return count;
-};
-dojo.dom.copyChildren = function (srcNode, destNode, trim) {
+}
+
+dojo.dom.copyChildren = function(srcNode, destNode, trim){
 	var clonedNode = srcNode.cloneNode(true);
 	return this.moveChildren(clonedNode, destNode, trim);
-};
-dojo.dom.replaceChildren = function (node, newChild) {
-	var nodes = [];
-	if (dojo.render.html.ie) {
-		for (var i = 0; i < node.childNodes.length; i++) {
-			nodes.push(node.childNodes[i]);
-		}
-	}
+}
+
+dojo.dom.removeChildren = function(node){
+	var count = node.childNodes.length;
+	while(node.hasChildNodes()){ node.removeChild(node.firstChild); }
+	return count;
+}
+
+dojo.dom.replaceChildren = function(node, newChild){
+	// FIXME: what if newChild is an array-like object?
 	dojo.dom.removeChildren(node);
 	node.appendChild(newChild);
-	for (var i = 0; i < nodes.length; i++) {
-		dojo.dom.destroyNode(nodes[i]);
-	}
-};
-dojo.dom.removeChildren = function (node) {
-	var count = node.childNodes.length;
-	while (node.hasChildNodes()) {
-		dojo.dom.removeNode(node.firstChild);
-	}
-	return count;
-};
-dojo.dom.replaceNode = function (node, newNode) {
-	return node.parentNode.replaceChild(newNode, node);
-};
-dojo.dom.destroyNode = function (node) {
-	if (node.parentNode) {
-		node = dojo.dom.removeNode(node);
-	}
-	if (node.nodeType != 3) {
-		if (dojo.evalObjPath("dojo.event.browser.clean", false)) {
-			dojo.event.browser.clean(node);
-		}
-		if (dojo.render.html.ie) {
-			node.outerHTML = "";
-		}
-	}
-};
-dojo.dom.removeNode = function (node) {
-	if (node && node.parentNode) {
+}
+
+dojo.dom.removeNode = function(node){
+	if(node && node.parentNode){
+		// return a ref to the removed child
 		return node.parentNode.removeChild(node);
 	}
-};
-dojo.dom.getAncestors = function (node, filterFunction, returnFirstHit) {
+}
+
+dojo.dom.getAncestors = function(node, filterFunction, returnFirstHit) {
 	var ancestors = [];
-	var isFunction = (filterFunction && (filterFunction instanceof Function || typeof filterFunction == "function"));
-	while (node) {
+	var isFunction = dojo.lang.isFunction(filterFunction);
+	while(node) {
 		if (!isFunction || filterFunction(node)) {
 			ancestors.push(node);
 		}
-		if (returnFirstHit && ancestors.length > 0) {
-			return ancestors[0];
-		}
+		if (returnFirstHit && ancestors.length > 0) { return ancestors[0]; }
+		
 		node = node.parentNode;
 	}
-	if (returnFirstHit) {
-		return null;
-	}
+	if (returnFirstHit) { return null; }
 	return ancestors;
-};
-dojo.dom.getAncestorsByTag = function (node, tag, returnFirstHit) {
+}
+
+dojo.dom.getAncestorsByTag = function(node, tag, returnFirstHit) {
 	tag = tag.toLowerCase();
-	return dojo.dom.getAncestors(node, function (el) {
-		return ((el.tagName) && (el.tagName.toLowerCase() == tag));
+	return dojo.dom.getAncestors(node, function(el){
+		return ((el.tagName)&&(el.tagName.toLowerCase() == tag));
 	}, returnFirstHit);
-};
-dojo.dom.getFirstAncestorByTag = function (node, tag) {
+}
+
+dojo.dom.getFirstAncestorByTag = function(node, tag) {
 	return dojo.dom.getAncestorsByTag(node, tag, true);
-};
-dojo.dom.isDescendantOf = function (node, ancestor, guaranteeDescendant) {
-	if (guaranteeDescendant && node) {
+}
+
+dojo.dom.isDescendantOf = function(node, ancestor, guaranteeDescendant){
+	// guaranteeDescendant allows us to be a "true" isDescendantOf function
+	if(guaranteeDescendant && node) { node = node.parentNode; }
+	while(node) {
+		if(node == ancestor){ return true; }
 		node = node.parentNode;
 	}
-	while (node) {
-		if (node == ancestor) {
-			return true;
-		}
-		node = node.parentNode;
-	}
 	return false;
-};
-dojo.dom.innerXML = function (node) {
-	if (node.innerXML) {
+}
+
+dojo.dom.innerXML = function(node){
+	if(node.innerXML){
 		return node.innerXML;
-	} else {
-		if (node.xml) {
-			return node.xml;
-		} else {
-			if (typeof XMLSerializer != "undefined") {
-				return (new XMLSerializer()).serializeToString(node);
-			}
-		}
+	}else if (node.xml){
+		return node.xml;
+	}else if(typeof XMLSerializer != "undefined"){
+		return (new XMLSerializer()).serializeToString(node);
 	}
-};
-dojo.dom.createDocument = function () {
+}
+
+dojo.dom.createDocument = function(){
 	var doc = null;
-	var _document = dojo.doc();
-	if (!dj_undef("ActiveXObject")) {
-		var prefixes = ["MSXML2", "Microsoft", "MSXML", "MSXML3"];
-		for (var i = 0; i < prefixes.length; i++) {
-			try {
-				doc = new ActiveXObject(prefixes[i] + ".XMLDOM");
-			}
-			catch (e) {
-			}
-			if (doc) {
-				break;
-			}
+
+	if(!dj_undef("ActiveXObject")){
+		var prefixes = [ "MSXML2", "Microsoft", "MSXML", "MSXML3" ];
+		for(var i = 0; i<prefixes.length; i++){
+			try{
+				doc = new ActiveXObject(prefixes[i]+".XMLDOM");
+			}catch(e){ /* squelch */ };
+
+			if(doc){ break; }
 		}
-	} else {
-		if ((_document.implementation) && (_document.implementation.createDocument)) {
-			doc = _document.implementation.createDocument("", "", null);
-		}
+	}else if((document.implementation)&&
+		(document.implementation.createDocument)){
+		doc = document.implementation.createDocument("", "", null);
 	}
+	
 	return doc;
-};
-dojo.dom.createDocumentFromText = function (str, mimetype) {
-	if (!mimetype) {
-		mimetype = "text/xml";
-	}
-	if (!dj_undef("DOMParser")) {
+}
+
+dojo.dom.createDocumentFromText = function(str, mimetype){
+	if(!mimetype){ mimetype = "text/xml"; }
+	if(!dj_undef("DOMParser")){
 		var parser = new DOMParser();
 		return parser.parseFromString(str, mimetype);
-	} else {
-		if (!dj_undef("ActiveXObject")) {
-			var domDoc = dojo.dom.createDocument();
-			if (domDoc) {
-				domDoc.async = false;
-				domDoc.loadXML(str);
-				return domDoc;
-			} else {
-				dojo.debug("toXml didn't work?");
+	}else if(!dj_undef("ActiveXObject")){
+		var domDoc = dojo.dom.createDocument();
+		if(domDoc){
+			domDoc.async = false;
+			domDoc.loadXML(str);
+			return domDoc;
+		}else{
+			dojo.debug("toXml didn't work?");
+		}
+	/*
+	}else if((dojo.render.html.capable)&&(dojo.render.html.safari)){
+		// FIXME: this doesn't appear to work!
+		// from: http://web-graphics.com/mtarchive/001606.php
+		// var xml = '<?xml version="1.0"?>'+str;
+		var mtype = "text/xml";
+		var xml = '<?xml version="1.0"?>'+str;
+		var url = "data:"+mtype+";charset=utf-8,"+encodeURIComponent(xml);
+		var req = new XMLHttpRequest();
+		req.open("GET", url, false);
+		req.overrideMimeType(mtype);
+		req.send(null);
+		return req.responseXML;
+	*/
+	}else if(document.createElement){
+		// FIXME: this may change all tags to uppercase!
+		var tmp = document.createElement("xml");
+		tmp.innerHTML = str;
+		if(document.implementation && document.implementation.createDocument) {
+			var xmlDoc = document.implementation.createDocument("foo", "", null);
+			for(var i = 0; i < tmp.childNodes.length; i++) {
+				xmlDoc.importNode(tmp.childNodes.item(i), true);
 			}
-		} else {
-			var _document = dojo.doc();
-			if (_document.createElement) {
-				var tmp = _document.createElement("xml");
-				tmp.innerHTML = str;
-				if (_document.implementation && _document.implementation.createDocument) {
-					var xmlDoc = _document.implementation.createDocument("foo", "", null);
-					for (var i = 0; i < tmp.childNodes.length; i++) {
-						xmlDoc.importNode(tmp.childNodes.item(i), true);
-					}
-					return xmlDoc;
-				}
-				return ((tmp.document) && (tmp.document.firstChild ? tmp.document.firstChild : tmp));
-			}
+			return xmlDoc;
 		}
+		// FIXME: probably not a good idea to have to return an HTML fragment
+		// FIXME: the tmp.doc.firstChild is as tested from IE, so it may not
+		// work that way across the board
+		return ((tmp.document)&&
+			(tmp.document.firstChild ?  tmp.document.firstChild : tmp));
 	}
 	return null;
-};
-dojo.dom.prependChild = function (node, parent) {
-	if (parent.firstChild) {
+}
+
+dojo.dom.prependChild = function(node, parent) {
+	if(parent.firstChild) {
 		parent.insertBefore(node, parent.firstChild);
 	} else {
 		parent.appendChild(node);
 	}
 	return true;
-};
-dojo.dom.insertBefore = function (node, ref, force) {
-	if ((force != true) && (node === ref || node.nextSibling === ref)) {
-		return false;
-	}
+}
+
+dojo.dom.insertBefore = function(node, ref, force){
+	if (force != true &&
+		(node === ref || node.nextSibling === ref)){ return false; }
 	var parent = ref.parentNode;
 	parent.insertBefore(node, ref);
 	return true;
-};
-dojo.dom.insertAfter = function (node, ref, force) {
+}
+
+dojo.dom.insertAfter = function(node, ref, force){
 	var pn = ref.parentNode;
-	if (ref == pn.lastChild) {
-		if ((force != true) && (node === ref)) {
+	if(ref == pn.lastChild){
+		if((force != true)&&(node === ref)){
 			return false;
 		}
 		pn.appendChild(node);
-	} else {
+	}else{
 		return this.insertBefore(node, ref.nextSibling, force);
 	}
 	return true;
-};
-dojo.dom.insertAtPosition = function (node, ref, position) {
-	if ((!node) || (!ref) || (!position)) {
-		return false;
-	}
-	switch (position.toLowerCase()) {
-	  case "before":
-		return dojo.dom.insertBefore(node, ref);
-	  case "after":
-		return dojo.dom.insertAfter(node, ref);
-	  case "first":
-		if (ref.firstChild) {
-			return dojo.dom.insertBefore(node, ref.firstChild);
-		} else {
+}
+
+dojo.dom.insertAtPosition = function(node, ref, position){
+	if((!node)||(!ref)||(!position)){ return false; }
+	switch(position.toLowerCase()){
+		case "before":
+			return dojo.dom.insertBefore(node, ref);
+		case "after":
+			return dojo.dom.insertAfter(node, ref);
+		case "first":
+			if(ref.firstChild){
+				return dojo.dom.insertBefore(node, ref.firstChild);
+			}else{
+				ref.appendChild(node);
+				return true;
+			}
+			break;
+		default: // aka: last
 			ref.appendChild(node);
 			return true;
-		}
-		break;
-	  default:
-		ref.appendChild(node);
-		return true;
 	}
-};
-dojo.dom.insertAtIndex = function (node, containingNode, insertionIndex) {
+}
+
+dojo.dom.insertAtIndex = function(node, containingNode, insertionIndex){
 	var siblingNodes = containingNode.childNodes;
-	if (!siblingNodes.length || siblingNodes.length == insertionIndex) {
+
+	// if there aren't any kids yet, just add it to the beginning
+
+	if (!siblingNodes.length){
 		containingNode.appendChild(node);
 		return true;
 	}
-	if (insertionIndex == 0) {
-		return dojo.dom.prependChild(node, containingNode);
+
+	// otherwise we need to walk the childNodes
+	// and find our spot
+
+	var after = null;
+
+	for(var i=0; i<siblingNodes.length; i++){
+
+		var sibling_index = siblingNodes.item(i)["getAttribute"] ? parseInt(siblingNodes.item(i).getAttribute("dojoinsertionindex")) : -1;
+
+		if (sibling_index < insertionIndex){
+			after = siblingNodes.item(i);
+		}
 	}
-	return dojo.dom.insertAfter(node, siblingNodes[insertionIndex - 1]);
-};
-dojo.dom.textContent = function (node, text) {
-	if (arguments.length > 1) {
-		var _document = dojo.doc();
-		dojo.dom.replaceChildren(node, _document.createTextNode(text));
+
+	if (after){
+		// add it after the node in {after}
+
+		return dojo.dom.insertAfter(node, after);
+	}else{
+		// add it to the start
+
+		return dojo.dom.insertBefore(node, siblingNodes.item(0));
+	}
+}
+	
+/**
+ * implementation of the DOM Level 3 attribute.
+ * 
+ * @param node The node to scan for text
+ * @param text Optional, set the text to this value.
+ */
+dojo.dom.textContent = function(node, text){
+	if (text) {
+		dojo.dom.replaceChildren(node, document.createTextNode(text));
 		return text;
 	} else {
-		if (node.textContent != undefined) {
-			return node.textContent;
-		}
 		var _result = "";
-		if (node == null) {
-			return _result;
-		}
+		if (node == null) { return _result; }
 		for (var i = 0; i < node.childNodes.length; i++) {
 			switch (node.childNodes[i].nodeType) {
-			  case 1:
-			  case 5:
-				_result += dojo.dom.textContent(node.childNodes[i]);
-				break;
-			  case 3:
-			  case 2:
-			  case 4:
-				_result += node.childNodes[i].nodeValue;
-				break;
-			  default:
-				break;
+				case 1: // ELEMENT_NODE
+				case 5: // ENTITY_REFERENCE_NODE
+					_result += dojo.dom.textContent(node.childNodes[i]);
+					break;
+				case 3: // TEXT_NODE
+				case 2: // ATTRIBUTE_NODE
+				case 4: // CDATA_SECTION_NODE
+					_result += node.childNodes[i].nodeValue;
+					break;
+				default:
+					break;
 			}
 		}
 		return _result;
 	}
-};
+}
+
+dojo.dom.collectionToArray = function(collection){
+	dojo.deprecated("dojo.dom.collectionToArray", "use dojo.lang.toArray instead", "0.4");
+	return dojo.lang.toArray(collection);
+}
+
 dojo.dom.hasParent = function (node) {
-	return Boolean(node && node.parentNode && dojo.dom.isNode(node.parentNode));
-};
-dojo.dom.isTag = function (node) {
-	if (node && node.tagName) {
-		for (var i = 1; i < arguments.length; i++) {
-			if (node.tagName == String(arguments[i])) {
-				return String(arguments[i]);
-			}
-		}
+	return node && node.parentNode && dojo.dom.isNode(node.parentNode);
+}
+
+/**
+ * Determines if node has any of the provided tag names and
+ * returns the tag name that matches, empty string otherwise.
+ *
+ * Examples:
+ *
+ * myFooNode = <foo />
+ * isTag(myFooNode, "foo"); // returns "foo"
+ * isTag(myFooNode, "bar"); // returns ""
+ * isTag(myFooNode, "FOO"); // returns ""
+ * isTag(myFooNode, "hey", "foo", "bar"); // returns "foo"
+**/
+dojo.dom.isTag = function(node /* ... */) {
+	if(node && node.tagName) {
+		var arr = dojo.lang.toArray(arguments, 1);
+		return arr[ dojo.lang.find(node.tagName, arr) ] || "";
 	}
 	return "";
-};
-dojo.dom.setAttributeNS = function (elem, namespaceURI, attrName, attrValue) {
-	if (elem == null || ((elem == undefined) && (typeof elem == "undefined"))) {
-		dojo.raise("No element given to dojo.dom.setAttributeNS");
-	}
-	if (!((elem.setAttributeNS == undefined) && (typeof elem.setAttributeNS == "undefined"))) {
-		elem.setAttributeNS(namespaceURI, attrName, attrValue);
-	} else {
-		var ownerDoc = elem.ownerDocument;
-		var attribute = ownerDoc.createNode(2, attrName, namespaceURI);
-		attribute.nodeValue = attrValue;
-		elem.setAttributeNode(attribute);
-	}
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/event/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/event/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/event/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,9 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.event.common", "dojo.event.topic"], browser:["dojo.event.browser"], dashboard:["dojo.event.browser"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.event", "dojo.event.topic"],
+	browser: ["dojo.event.browser"],
+	dashboard: ["dojo.event.browser"]
+});
 dojo.provide("dojo.event.*");
-

Modified: tags/parley-0.53/root/static/magic/src/event/browser.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/event/browser.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/event/browser.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,484 +8,266 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.event.browser");
-dojo.require("dojo.event.common");
-dojo._ie_clobber = new function () {
+dojo.require("dojo.event");
+
+// FIXME: any particular reason this is in the global scope?
+dojo._ie_clobber = new function(){
 	this.clobberNodes = [];
-	function nukeProp(node, prop) {
-		try {
-			node[prop] = null;
-		}
-		catch (e) {
-		}
-		try {
-			delete node[prop];
-		}
-		catch (e) {
-		}
-		try {
-			node.removeAttribute(prop);
-		}
-		catch (e) {
-		}
+
+	function nukeProp(node, prop){
+		// try{ node.removeAttribute(prop); 	}catch(e){ /* squelch */ }
+		try{ node[prop] = null; 			}catch(e){ /* squelch */ }
+		try{ delete node[prop]; 			}catch(e){ /* squelch */ }
+		// FIXME: JotLive needs this, but I'm not sure if it's too slow or not
+		try{ node.removeAttribute(prop);	}catch(e){ /* squelch */ }
 	}
-	this.clobber = function (nodeRef) {
+
+	this.clobber = function(nodeRef){
 		var na;
 		var tna;
-		if (nodeRef) {
+		if(nodeRef){
 			tna = nodeRef.all || nodeRef.getElementsByTagName("*");
 			na = [nodeRef];
-			for (var x = 0; x < tna.length; x++) {
-				if (tna[x]["__doClobber__"]) {
+			for(var x=0; x<tna.length; x++){
+				// if we're gonna be clobbering the thing, at least make sure
+				// we aren't trying to do it twice
+				if(tna[x]["__doClobber__"]){
 					na.push(tna[x]);
 				}
 			}
-		} else {
-			try {
-				window.onload = null;
-			}
-			catch (e) {
-			}
+		}else{
+			try{ window.onload = null; }catch(e){}
 			na = (this.clobberNodes.length) ? this.clobberNodes : document.all;
 		}
 		tna = null;
 		var basis = {};
-		for (var i = na.length - 1; i >= 0; i = i - 1) {
+		for(var i = na.length-1; i>=0; i=i-1){
 			var el = na[i];
-			try {
-				if (el && el["__clobberAttrs__"]) {
-					for (var j = 0; j < el.__clobberAttrs__.length; j++) {
-						nukeProp(el, el.__clobberAttrs__[j]);
-					}
-					nukeProp(el, "__clobberAttrs__");
-					nukeProp(el, "__doClobber__");
+			if(el["__clobberAttrs__"]){
+				for(var j=0; j<el.__clobberAttrs__.length; j++){
+					nukeProp(el, el.__clobberAttrs__[j]);
 				}
+				nukeProp(el, "__clobberAttrs__");
+				nukeProp(el, "__doClobber__");
 			}
-			catch (e) {
-			}
 		}
 		na = null;
-	};
-};
-if (dojo.render.html.ie) {
-	dojo.addOnUnload(function () {
+	}
+}
+
+if(dojo.render.html.ie){
+	dojo.addOnUnload(function(){
 		dojo._ie_clobber.clobber();
-		try {
-			if ((dojo["widget"]) && (dojo.widget["manager"])) {
+		try{
+			if((dojo["widget"])&&(dojo.widget["manager"])){
 				dojo.widget.manager.destroyAll();
 			}
-		}
-		catch (e) {
-		}
-		if (dojo.widget) {
-			for (var name in dojo.widget._templateCache) {
-				if (dojo.widget._templateCache[name].node) {
-					dojo.dom.destroyNode(dojo.widget._templateCache[name].node);
-					dojo.widget._templateCache[name].node = null;
-					delete dojo.widget._templateCache[name].node;
-				}
-			}
-		}
-		try {
-			window.onload = null;
-		}
-		catch (e) {
-		}
-		try {
-			window.onunload = null;
-		}
-		catch (e) {
-		}
+		}catch(e){}
+		try{ window.onload = null; }catch(e){}
+		try{ window.onunload = null; }catch(e){}
 		dojo._ie_clobber.clobberNodes = [];
+		// CollectGarbage();
 	});
 }
-dojo.event.browser = new function () {
+
+dojo.event.browser = new function(){
+
 	var clobberIdx = 0;
-	this.normalizedEventName = function (eventName) {
-		switch (eventName) {
-		  case "CheckboxStateChange":
-		  case "DOMAttrModified":
-		  case "DOMMenuItemActive":
-		  case "DOMMenuItemInactive":
-		  case "DOMMouseScroll":
-		  case "DOMNodeInserted":
-		  case "DOMNodeRemoved":
-		  case "RadioStateChange":
-			return eventName;
-			break;
-		  default:
-			var lcn = eventName.toLowerCase();
-			return (lcn.indexOf("on") == 0) ? lcn.substr(2) : lcn;
-			break;
-		}
-	};
-	this.clean = function (node) {
-		if (dojo.render.html.ie) {
+
+	this.clean = function(node){
+		if(dojo.render.html.ie){ 
 			dojo._ie_clobber.clobber(node);
 		}
-	};
-	this.addClobberNode = function (node) {
-		if (!dojo.render.html.ie) {
-			return;
-		}
-		if (!node["__doClobber__"]) {
+	}
+
+	this.addClobberNode = function(node){
+		if(!dojo.render.html.ie){ return; }
+		if(!node["__doClobber__"]){
 			node.__doClobber__ = true;
 			dojo._ie_clobber.clobberNodes.push(node);
+			// this might not be the most efficient thing to do, but it's
+			// much less error prone than other approaches which were
+			// previously tried and failed
 			node.__clobberAttrs__ = [];
 		}
-	};
-	this.addClobberNodeAttrs = function (node, props) {
-		if (!dojo.render.html.ie) {
-			return;
-		}
+	}
+
+	this.addClobberNodeAttrs = function(node, props){
+		if(!dojo.render.html.ie){ return; }
 		this.addClobberNode(node);
-		for (var x = 0; x < props.length; x++) {
+		for(var x=0; x<props.length; x++){
 			node.__clobberAttrs__.push(props[x]);
 		}
-	};
-	this.removeListener = function (node, evtName, fp, capture) {
-		if (!capture) {
-			var capture = false;
-		}
-		evtName = dojo.event.browser.normalizedEventName(evtName);
-		if (evtName == "key") {
-			if (dojo.render.html.ie) {
-				this.removeListener(node, "onkeydown", fp, capture);
-			}
-			evtName = "keypress";
-		}
-		if (node.removeEventListener) {
+	}
+
+	this.removeListener = function(node, evtName, fp, capture){
+		if(!capture){ var capture = false; }
+		evtName = evtName.toLowerCase();
+		if(evtName.substr(0,2)=="on"){ evtName = evtName.substr(2); }
+		// FIXME: this is mostly a punt, we aren't actually doing anything on IE
+		if(node.removeEventListener){
 			node.removeEventListener(evtName, fp, capture);
 		}
-	};
-	this.addListener = function (node, evtName, fp, capture, dontFix) {
-		if (!node) {
-			return;
-		}
-		if (!capture) {
-			var capture = false;
-		}
-		evtName = dojo.event.browser.normalizedEventName(evtName);
-		if (evtName == "key") {
-			if (dojo.render.html.ie) {
-				this.addListener(node, "onkeydown", fp, capture, dontFix);
-			}
-			evtName = "keypress";
-		}
-		if (!dontFix) {
-			var newfp = function (evt) {
-				if (!evt) {
-					evt = window.event;
-				}
+	}
+
+	this.addListener = function(node, evtName, fp, capture, dontFix){
+		if(!node){ return; } // FIXME: log and/or bail?
+		if(!capture){ var capture = false; }
+		evtName = evtName.toLowerCase();
+		if(evtName.substr(0,2)!="on"){ evtName = "on"+evtName; }
+
+		if(!dontFix){
+			// build yet another closure around fp in order to inject fixEvent
+			// around the resulting event
+			var newfp = function(evt){
+				if(!evt){ evt = window.event; }
 				var ret = fp(dojo.event.browser.fixEvent(evt, this));
-				if (capture) {
+				if(capture){
 					dojo.event.browser.stopEvent(evt);
 				}
 				return ret;
-			};
-		} else {
+			}
+		}else{
 			newfp = fp;
 		}
-		if (node.addEventListener) {
-			node.addEventListener(evtName, newfp, capture);
+
+		if(node.addEventListener){ 
+			node.addEventListener(evtName.substr(2), newfp, capture);
 			return newfp;
-		} else {
-			evtName = "on" + evtName;
-			if (typeof node[evtName] == "function") {
+		}else{
+			if(typeof node[evtName] == "function" ){
 				var oldEvt = node[evtName];
-				node[evtName] = function (e) {
+				node[evtName] = function(e){
 					oldEvt(e);
 					return newfp(e);
-				};
-			} else {
-				node[evtName] = newfp;
+				}
+			}else{
+				node[evtName]=newfp;
 			}
-			if (dojo.render.html.ie) {
+			if(dojo.render.html.ie){
 				this.addClobberNodeAttrs(node, [evtName]);
 			}
 			return newfp;
 		}
-	};
-	this.isEvent = function (obj) {
-		return (typeof obj != "undefined") && (obj) && (typeof Event != "undefined") && (obj.eventPhase);
-	};
+	}
+
+	this.isEvent = function(obj){
+		// FIXME: event detection hack ... could test for additional attributes
+		// if necessary
+		return (typeof obj != "undefined")&&(typeof Event != "undefined")&&(obj.eventPhase);
+		// Event does not support instanceof in Opera, otherwise:
+		//return (typeof Event != "undefined")&&(obj instanceof Event);
+	}
+
 	this.currentEvent = null;
-	this.callListener = function (listener, curTarget) {
-		if (typeof listener != "function") {
+	
+	this.callListener = function(listener, curTarget){
+		if(typeof listener != 'function'){
 			dojo.raise("listener not a function: " + listener);
 		}
 		dojo.event.browser.currentEvent.currentTarget = curTarget;
 		return listener.call(curTarget, dojo.event.browser.currentEvent);
-	};
-	this._stopPropagation = function () {
+	}
+
+	this.stopPropagation = function(){
 		dojo.event.browser.currentEvent.cancelBubble = true;
+	}
+
+	this.preventDefault = function(){
+	  dojo.event.browser.currentEvent.returnValue = false;
+	}
+
+	this.keys = {
+		KEY_BACKSPACE: 8,
+		KEY_TAB: 9,
+		KEY_ENTER: 13,
+		KEY_SHIFT: 16,
+		KEY_CTRL: 17,
+		KEY_ALT: 18,
+		KEY_PAUSE: 19,
+		KEY_CAPS_LOCK: 20,
+		KEY_ESCAPE: 27,
+		KEY_SPACE: 32,
+		KEY_PAGE_UP: 33,
+		KEY_PAGE_DOWN: 34,
+		KEY_END: 35,
+		KEY_HOME: 36,
+		KEY_LEFT_ARROW: 37,
+		KEY_UP_ARROW: 38,
+		KEY_RIGHT_ARROW: 39,
+		KEY_DOWN_ARROW: 40,
+		KEY_INSERT: 45,
+		KEY_DELETE: 46,
+		KEY_LEFT_WINDOW: 91,
+		KEY_RIGHT_WINDOW: 92,
+		KEY_SELECT: 93,
+		KEY_F1: 112,
+		KEY_F2: 113,
+		KEY_F3: 114,
+		KEY_F4: 115,
+		KEY_F5: 116,
+		KEY_F6: 117,
+		KEY_F7: 118,
+		KEY_F8: 119,
+		KEY_F9: 120,
+		KEY_F10: 121,
+		KEY_F11: 122,
+		KEY_F12: 123,
+		KEY_NUM_LOCK: 144,
+		KEY_SCROLL_LOCK: 145
 	};
-	this._preventDefault = function () {
-		dojo.event.browser.currentEvent.returnValue = false;
-	};
-	this.keys = {KEY_BACKSPACE:8, KEY_TAB:9, KEY_CLEAR:12, KEY_ENTER:13, KEY_SHIFT:16, KEY_CTRL:17, KEY_ALT:18, KEY_PAUSE:19, KEY_CAPS_LOCK:20, KEY_ESCAPE:27, KEY_SPACE:32, KEY_PAGE_UP:33, KEY_PAGE_DOWN:34, KEY_END:35, KEY_HOME:36, KEY_LEFT_ARROW:37, KEY_UP_ARROW:38, KEY_RIGHT_ARROW:39, KEY_DOWN_ARROW:40, KEY_INSERT:45, KEY_DELETE:46, KEY_HELP:47, KEY_LEFT_WINDOW:91, KEY_RIGHT_WINDOW:92, KEY_SELECT:93, KEY_NUMPAD_0:96, KEY_NUMPAD_1:97, KEY_NUMPAD_2:98, KEY_NUMPAD_3:99, KEY_NUMPAD_4:100, KEY_NUMPAD_5:101, KEY_NUMPAD_6:102, KEY_NUMPAD_7:103, KEY_NUMPAD_8:104, KEY_NUMPAD_9:105, KEY_NUMPAD_MULTIPLY:106, KEY_NUMPAD_PLUS:107, KEY_NUMPAD_ENTER:108, KEY_NUMPAD_MINUS:109, KEY_NUMPAD_PERIOD:110, KEY_NUMPAD_DIVIDE:111, KEY_F1:112, KEY_F2:113, KEY_F3:114, KEY_F4:115, KEY_F5:116, KEY_F6:117, KEY_F7:118, KEY_F8:119, KEY_F9:120, KEY_F10:121, KEY_F11:122, KEY_F12:123, KEY_F13:124, KEY_F14:125, KEY_F15:126, KEY_NUM_LOCK:144, KEY_SCROLL_LOCK:145};
+
+	// reverse lookup
 	this.revKeys = [];
-	for (var key in this.keys) {
+	for(var key in this.keys){
 		this.revKeys[this.keys[key]] = key;
 	}
-	this.fixEvent = function (evt, sender) {
-		if (!evt) {
-			if (window["event"]) {
-				evt = window.event;
-			}
+
+	this.fixEvent = function(evt, sender){
+		if((!evt)&&(window["event"])){
+			var evt = window.event;
 		}
-		if ((evt["type"]) && (evt["type"].indexOf("key") == 0)) {
+		
+		if((evt["type"])&&(evt["type"].indexOf("key") == 0)){ // key events
 			evt.keys = this.revKeys;
-			for (var key in this.keys) {
+			// FIXME: how can we eliminate this iteration?
+			for(var key in this.keys) {
 				evt[key] = this.keys[key];
 			}
-			if (evt["type"] == "keydown" && dojo.render.html.ie) {
-				switch (evt.keyCode) {
-				  case evt.KEY_SHIFT:
-				  case evt.KEY_CTRL:
-				  case evt.KEY_ALT:
-				  case evt.KEY_CAPS_LOCK:
-				  case evt.KEY_LEFT_WINDOW:
-				  case evt.KEY_RIGHT_WINDOW:
-				  case evt.KEY_SELECT:
-				  case evt.KEY_NUM_LOCK:
-				  case evt.KEY_SCROLL_LOCK:
-				  case evt.KEY_NUMPAD_0:
-				  case evt.KEY_NUMPAD_1:
-				  case evt.KEY_NUMPAD_2:
-				  case evt.KEY_NUMPAD_3:
-				  case evt.KEY_NUMPAD_4:
-				  case evt.KEY_NUMPAD_5:
-				  case evt.KEY_NUMPAD_6:
-				  case evt.KEY_NUMPAD_7:
-				  case evt.KEY_NUMPAD_8:
-				  case evt.KEY_NUMPAD_9:
-				  case evt.KEY_NUMPAD_PERIOD:
-					break;
-				  case evt.KEY_NUMPAD_MULTIPLY:
-				  case evt.KEY_NUMPAD_PLUS:
-				  case evt.KEY_NUMPAD_ENTER:
-				  case evt.KEY_NUMPAD_MINUS:
-				  case evt.KEY_NUMPAD_DIVIDE:
-					break;
-				  case evt.KEY_PAUSE:
-				  case evt.KEY_TAB:
-				  case evt.KEY_BACKSPACE:
-				  case evt.KEY_ENTER:
-				  case evt.KEY_ESCAPE:
-				  case evt.KEY_PAGE_UP:
-				  case evt.KEY_PAGE_DOWN:
-				  case evt.KEY_END:
-				  case evt.KEY_HOME:
-				  case evt.KEY_LEFT_ARROW:
-				  case evt.KEY_UP_ARROW:
-				  case evt.KEY_RIGHT_ARROW:
-				  case evt.KEY_DOWN_ARROW:
-				  case evt.KEY_INSERT:
-				  case evt.KEY_DELETE:
-				  case evt.KEY_F1:
-				  case evt.KEY_F2:
-				  case evt.KEY_F3:
-				  case evt.KEY_F4:
-				  case evt.KEY_F5:
-				  case evt.KEY_F6:
-				  case evt.KEY_F7:
-				  case evt.KEY_F8:
-				  case evt.KEY_F9:
-				  case evt.KEY_F10:
-				  case evt.KEY_F11:
-				  case evt.KEY_F12:
-				  case evt.KEY_F12:
-				  case evt.KEY_F13:
-				  case evt.KEY_F14:
-				  case evt.KEY_F15:
-				  case evt.KEY_CLEAR:
-				  case evt.KEY_HELP:
-					evt.key = evt.keyCode;
-					break;
-				  default:
-					if (evt.ctrlKey || evt.altKey) {
-						var unifiedCharCode = evt.keyCode;
-						if (unifiedCharCode >= 65 && unifiedCharCode <= 90 && evt.shiftKey == false) {
-							unifiedCharCode += 32;
-						}
-						if (unifiedCharCode >= 1 && unifiedCharCode <= 26 && evt.ctrlKey) {
-							unifiedCharCode += 96;
-						}
-						evt.key = String.fromCharCode(unifiedCharCode);
-					}
-				}
-			} else {
-				if (evt["type"] == "keypress") {
-					if (dojo.render.html.opera) {
-						if (evt.which == 0) {
-							evt.key = evt.keyCode;
-						} else {
-							if (evt.which > 0) {
-								switch (evt.which) {
-								  case evt.KEY_SHIFT:
-								  case evt.KEY_CTRL:
-								  case evt.KEY_ALT:
-								  case evt.KEY_CAPS_LOCK:
-								  case evt.KEY_NUM_LOCK:
-								  case evt.KEY_SCROLL_LOCK:
-									break;
-								  case evt.KEY_PAUSE:
-								  case evt.KEY_TAB:
-								  case evt.KEY_BACKSPACE:
-								  case evt.KEY_ENTER:
-								  case evt.KEY_ESCAPE:
-									evt.key = evt.which;
-									break;
-								  default:
-									var unifiedCharCode = evt.which;
-									if ((evt.ctrlKey || evt.altKey || evt.metaKey) && (evt.which >= 65 && evt.which <= 90 && evt.shiftKey == false)) {
-										unifiedCharCode += 32;
-									}
-									evt.key = String.fromCharCode(unifiedCharCode);
-								}
-							}
-						}
-					} else {
-						if (dojo.render.html.ie) {
-							if (!evt.ctrlKey && !evt.altKey && evt.keyCode >= evt.KEY_SPACE) {
-								evt.key = String.fromCharCode(evt.keyCode);
-							}
-						} else {
-							if (dojo.render.html.safari) {
-								switch (evt.keyCode) {
-								  case 25:
-									evt.key = evt.KEY_TAB;
-									evt.shift = true;
-									break;
-								  case 63232:
-									evt.key = evt.KEY_UP_ARROW;
-									break;
-								  case 63233:
-									evt.key = evt.KEY_DOWN_ARROW;
-									break;
-								  case 63234:
-									evt.key = evt.KEY_LEFT_ARROW;
-									break;
-								  case 63235:
-									evt.key = evt.KEY_RIGHT_ARROW;
-									break;
-								  case 63236:
-									evt.key = evt.KEY_F1;
-									break;
-								  case 63237:
-									evt.key = evt.KEY_F2;
-									break;
-								  case 63238:
-									evt.key = evt.KEY_F3;
-									break;
-								  case 63239:
-									evt.key = evt.KEY_F4;
-									break;
-								  case 63240:
-									evt.key = evt.KEY_F5;
-									break;
-								  case 63241:
-									evt.key = evt.KEY_F6;
-									break;
-								  case 63242:
-									evt.key = evt.KEY_F7;
-									break;
-								  case 63243:
-									evt.key = evt.KEY_F8;
-									break;
-								  case 63244:
-									evt.key = evt.KEY_F9;
-									break;
-								  case 63245:
-									evt.key = evt.KEY_F10;
-									break;
-								  case 63246:
-									evt.key = evt.KEY_F11;
-									break;
-								  case 63247:
-									evt.key = evt.KEY_F12;
-									break;
-								  case 63250:
-									evt.key = evt.KEY_PAUSE;
-									break;
-								  case 63272:
-									evt.key = evt.KEY_DELETE;
-									break;
-								  case 63273:
-									evt.key = evt.KEY_HOME;
-									break;
-								  case 63275:
-									evt.key = evt.KEY_END;
-									break;
-								  case 63276:
-									evt.key = evt.KEY_PAGE_UP;
-									break;
-								  case 63277:
-									evt.key = evt.KEY_PAGE_DOWN;
-									break;
-								  case 63302:
-									evt.key = evt.KEY_INSERT;
-									break;
-								  case 63248:
-								  case 63249:
-								  case 63289:
-									break;
-								  default:
-									evt.key = evt.charCode >= evt.KEY_SPACE ? String.fromCharCode(evt.charCode) : evt.keyCode;
-								}
-							} else {
-								evt.key = evt.charCode > 0 ? String.fromCharCode(evt.charCode) : evt.keyCode;
-							}
-						}
-					}
-				}
+			if((dojo.render.html.ie)&&(evt["type"] == "keypress")){
+				evt.charCode = evt.keyCode;
 			}
 		}
-		if (dojo.render.html.ie) {
-			if (!evt.target) {
-				evt.target = evt.srcElement;
-			}
-			if (!evt.currentTarget) {
-				evt.currentTarget = (sender ? sender : evt.srcElement);
-			}
-			if (!evt.layerX) {
-				evt.layerX = evt.offsetX;
-			}
-			if (!evt.layerY) {
-				evt.layerY = evt.offsetY;
-			}
-			var doc = (evt.srcElement && evt.srcElement.ownerDocument) ? evt.srcElement.ownerDocument : document;
-			var docBody = ((dojo.render.html.ie55) || (doc["compatMode"] == "BackCompat")) ? doc.body : doc.documentElement;
-			if (!evt.pageX) {
-				evt.pageX = evt.clientX + (docBody.scrollLeft || 0);
-			}
-			if (!evt.pageY) {
-				evt.pageY = evt.clientY + (docBody.scrollTop || 0);
-			}
-			if (evt.type == "mouseover") {
-				evt.relatedTarget = evt.fromElement;
-			}
-			if (evt.type == "mouseout") {
-				evt.relatedTarget = evt.toElement;
-			}
+	
+		if(dojo.render.html.ie){
+			if(!evt.target){ evt.target = evt.srcElement; }
+			if(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }
+			if(!evt.layerX){ evt.layerX = evt.offsetX; }
+			if(!evt.layerY){ evt.layerY = evt.offsetY; }
+			// FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module
+			var docBody = ((dojo.render.html.ie55)||(document["compatMode"] == "BackCompat")) ? document.body : document.documentElement;
+			if(!evt.pageX){ evt.pageX = evt.clientX + (docBody.scrollLeft || 0) }
+			if(!evt.pageY){ evt.pageY = evt.clientY + (docBody.scrollTop || 0) }
+			// mouseover
+			if(evt.type == "mouseover"){ evt.relatedTarget = evt.fromElement; }
+			// mouseout
+			if(evt.type == "mouseout"){ evt.relatedTarget = evt.toElement; }
 			this.currentEvent = evt;
 			evt.callListener = this.callListener;
-			evt.stopPropagation = this._stopPropagation;
-			evt.preventDefault = this._preventDefault;
+			evt.stopPropagation = this.stopPropagation;
+			evt.preventDefault = this.preventDefault;
 		}
 		return evt;
-	};
-	this.stopEvent = function (evt) {
-		if (window.event) {
-			evt.cancelBubble = true;
-			evt.returnValue = false;
-		} else {
-			evt.preventDefault();
-			evt.stopPropagation();
-		}
-	};
-};
+	}
 
+	this.stopEvent = function(ev) {
+		if(window.event){
+			ev.returnValue = false;
+			ev.cancelBubble = true;
+		}else{
+			ev.preventDefault();
+			ev.stopPropagation();
+		}
+	}
+}

Deleted: tags/parley-0.53/root/static/magic/src/event/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/event/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/event/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,560 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.event.common");
-dojo.require("dojo.lang.array");
-dojo.require("dojo.lang.extras");
-dojo.require("dojo.lang.func");
-dojo.event = new function () {
-	this._canTimeout = dojo.lang.isFunction(dj_global["setTimeout"]) || dojo.lang.isAlien(dj_global["setTimeout"]);
-	function interpolateArgs(args, searchForNames) {
-		var dl = dojo.lang;
-		var ao = {srcObj:dj_global, srcFunc:null, adviceObj:dj_global, adviceFunc:null, aroundObj:null, aroundFunc:null, adviceType:(args.length > 2) ? args[0] : "after", precedence:"last", once:false, delay:null, rate:0, adviceMsg:false, maxCalls:-1};
-		switch (args.length) {
-		  case 0:
-			return;
-		  case 1:
-			return;
-		  case 2:
-			ao.srcFunc = args[0];
-			ao.adviceFunc = args[1];
-			break;
-		  case 3:
-			if ((dl.isObject(args[0])) && (dl.isString(args[1])) && (dl.isString(args[2]))) {
-				ao.adviceType = "after";
-				ao.srcObj = args[0];
-				ao.srcFunc = args[1];
-				ao.adviceFunc = args[2];
-			} else {
-				if ((dl.isString(args[1])) && (dl.isString(args[2]))) {
-					ao.srcFunc = args[1];
-					ao.adviceFunc = args[2];
-				} else {
-					if ((dl.isObject(args[0])) && (dl.isString(args[1])) && (dl.isFunction(args[2]))) {
-						ao.adviceType = "after";
-						ao.srcObj = args[0];
-						ao.srcFunc = args[1];
-						var tmpName = dl.nameAnonFunc(args[2], ao.adviceObj, searchForNames);
-						ao.adviceFunc = tmpName;
-					} else {
-						if ((dl.isFunction(args[0])) && (dl.isObject(args[1])) && (dl.isString(args[2]))) {
-							ao.adviceType = "after";
-							ao.srcObj = dj_global;
-							var tmpName = dl.nameAnonFunc(args[0], ao.srcObj, searchForNames);
-							ao.srcFunc = tmpName;
-							ao.adviceObj = args[1];
-							ao.adviceFunc = args[2];
-						}
-					}
-				}
-			}
-			break;
-		  case 4:
-			if ((dl.isObject(args[0])) && (dl.isObject(args[2]))) {
-				ao.adviceType = "after";
-				ao.srcObj = args[0];
-				ao.srcFunc = args[1];
-				ao.adviceObj = args[2];
-				ao.adviceFunc = args[3];
-			} else {
-				if ((dl.isString(args[0])) && (dl.isString(args[1])) && (dl.isObject(args[2]))) {
-					ao.adviceType = args[0];
-					ao.srcObj = dj_global;
-					ao.srcFunc = args[1];
-					ao.adviceObj = args[2];
-					ao.adviceFunc = args[3];
-				} else {
-					if ((dl.isString(args[0])) && (dl.isFunction(args[1])) && (dl.isObject(args[2]))) {
-						ao.adviceType = args[0];
-						ao.srcObj = dj_global;
-						var tmpName = dl.nameAnonFunc(args[1], dj_global, searchForNames);
-						ao.srcFunc = tmpName;
-						ao.adviceObj = args[2];
-						ao.adviceFunc = args[3];
-					} else {
-						if ((dl.isString(args[0])) && (dl.isObject(args[1])) && (dl.isString(args[2])) && (dl.isFunction(args[3]))) {
-							ao.srcObj = args[1];
-							ao.srcFunc = args[2];
-							var tmpName = dl.nameAnonFunc(args[3], dj_global, searchForNames);
-							ao.adviceObj = dj_global;
-							ao.adviceFunc = tmpName;
-						} else {
-							if (dl.isObject(args[1])) {
-								ao.srcObj = args[1];
-								ao.srcFunc = args[2];
-								ao.adviceObj = dj_global;
-								ao.adviceFunc = args[3];
-							} else {
-								if (dl.isObject(args[2])) {
-									ao.srcObj = dj_global;
-									ao.srcFunc = args[1];
-									ao.adviceObj = args[2];
-									ao.adviceFunc = args[3];
-								} else {
-									ao.srcObj = ao.adviceObj = ao.aroundObj = dj_global;
-									ao.srcFunc = args[1];
-									ao.adviceFunc = args[2];
-									ao.aroundFunc = args[3];
-								}
-							}
-						}
-					}
-				}
-			}
-			break;
-		  case 6:
-			ao.srcObj = args[1];
-			ao.srcFunc = args[2];
-			ao.adviceObj = args[3];
-			ao.adviceFunc = args[4];
-			ao.aroundFunc = args[5];
-			ao.aroundObj = dj_global;
-			break;
-		  default:
-			ao.srcObj = args[1];
-			ao.srcFunc = args[2];
-			ao.adviceObj = args[3];
-			ao.adviceFunc = args[4];
-			ao.aroundObj = args[5];
-			ao.aroundFunc = args[6];
-			ao.once = args[7];
-			ao.delay = args[8];
-			ao.rate = args[9];
-			ao.adviceMsg = args[10];
-			ao.maxCalls = (!isNaN(parseInt(args[11]))) ? args[11] : -1;
-			break;
-		}
-		if (dl.isFunction(ao.aroundFunc)) {
-			var tmpName = dl.nameAnonFunc(ao.aroundFunc, ao.aroundObj, searchForNames);
-			ao.aroundFunc = tmpName;
-		}
-		if (dl.isFunction(ao.srcFunc)) {
-			ao.srcFunc = dl.getNameInObj(ao.srcObj, ao.srcFunc);
-		}
-		if (dl.isFunction(ao.adviceFunc)) {
-			ao.adviceFunc = dl.getNameInObj(ao.adviceObj, ao.adviceFunc);
-		}
-		if ((ao.aroundObj) && (dl.isFunction(ao.aroundFunc))) {
-			ao.aroundFunc = dl.getNameInObj(ao.aroundObj, ao.aroundFunc);
-		}
-		if (!ao.srcObj) {
-			dojo.raise("bad srcObj for srcFunc: " + ao.srcFunc);
-		}
-		if (!ao.adviceObj) {
-			dojo.raise("bad adviceObj for adviceFunc: " + ao.adviceFunc);
-		}
-		if (!ao.adviceFunc) {
-			dojo.debug("bad adviceFunc for srcFunc: " + ao.srcFunc);
-			dojo.debugShallow(ao);
-		}
-		return ao;
-	}
-	this.connect = function () {
-		if (arguments.length == 1) {
-			var ao = arguments[0];
-		} else {
-			var ao = interpolateArgs(arguments, true);
-		}
-		if (dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == "onkey")) {
-			if (dojo.render.html.ie) {
-				ao.srcFunc = "onkeydown";
-				this.connect(ao);
-			}
-			ao.srcFunc = "onkeypress";
-		}
-		if (dojo.lang.isArray(ao.srcObj) && ao.srcObj != "") {
-			var tmpAO = {};
-			for (var x in ao) {
-				tmpAO[x] = ao[x];
-			}
-			var mjps = [];
-			dojo.lang.forEach(ao.srcObj, function (src) {
-				if ((dojo.render.html.capable) && (dojo.lang.isString(src))) {
-					src = dojo.byId(src);
-				}
-				tmpAO.srcObj = src;
-				mjps.push(dojo.event.connect.call(dojo.event, tmpAO));
-			});
-			return mjps;
-		}
-		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
-		if (ao.adviceFunc) {
-			var mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);
-		}
-		mjp.kwAddAdvice(ao);
-		return mjp;
-	};
-	this.log = function (a1, a2) {
-		var kwArgs;
-		if ((arguments.length == 1) && (typeof a1 == "object")) {
-			kwArgs = a1;
-		} else {
-			kwArgs = {srcObj:a1, srcFunc:a2};
-		}
-		kwArgs.adviceFunc = function () {
-			var argsStr = [];
-			for (var x = 0; x < arguments.length; x++) {
-				argsStr.push(arguments[x]);
-			}
-			dojo.debug("(" + kwArgs.srcObj + ")." + kwArgs.srcFunc, ":", argsStr.join(", "));
-		};
-		this.kwConnect(kwArgs);
-	};
-	this.connectBefore = function () {
-		var args = ["before"];
-		for (var i = 0; i < arguments.length; i++) {
-			args.push(arguments[i]);
-		}
-		return this.connect.apply(this, args);
-	};
-	this.connectAround = function () {
-		var args = ["around"];
-		for (var i = 0; i < arguments.length; i++) {
-			args.push(arguments[i]);
-		}
-		return this.connect.apply(this, args);
-	};
-	this.connectOnce = function () {
-		var ao = interpolateArgs(arguments, true);
-		ao.once = true;
-		return this.connect(ao);
-	};
-	this.connectRunOnce = function () {
-		var ao = interpolateArgs(arguments, true);
-		ao.maxCalls = 1;
-		return this.connect(ao);
-	};
-	this._kwConnectImpl = function (kwArgs, disconnect) {
-		var fn = (disconnect) ? "disconnect" : "connect";
-		if (typeof kwArgs["srcFunc"] == "function") {
-			kwArgs.srcObj = kwArgs["srcObj"] || dj_global;
-			var tmpName = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);
-			kwArgs.srcFunc = tmpName;
-		}
-		if (typeof kwArgs["adviceFunc"] == "function") {
-			kwArgs.adviceObj = kwArgs["adviceObj"] || dj_global;
-			var tmpName = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);
-			kwArgs.adviceFunc = tmpName;
-		}
-		kwArgs.srcObj = kwArgs["srcObj"] || dj_global;
-		kwArgs.adviceObj = kwArgs["adviceObj"] || kwArgs["targetObj"] || dj_global;
-		kwArgs.adviceFunc = kwArgs["adviceFunc"] || kwArgs["targetFunc"];
-		return dojo.event[fn](kwArgs);
-	};
-	this.kwConnect = function (kwArgs) {
-		return this._kwConnectImpl(kwArgs, false);
-	};
-	this.disconnect = function () {
-		if (arguments.length == 1) {
-			var ao = arguments[0];
-		} else {
-			var ao = interpolateArgs(arguments, true);
-		}
-		if (!ao.adviceFunc) {
-			return;
-		}
-		if (dojo.lang.isString(ao.srcFunc) && (ao.srcFunc.toLowerCase() == "onkey")) {
-			if (dojo.render.html.ie) {
-				ao.srcFunc = "onkeydown";
-				this.disconnect(ao);
-			}
-			ao.srcFunc = "onkeypress";
-		}
-		if (!ao.srcObj[ao.srcFunc]) {
-			return null;
-		}
-		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc, true);
-		mjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once);
-		return mjp;
-	};
-	this.kwDisconnect = function (kwArgs) {
-		return this._kwConnectImpl(kwArgs, true);
-	};
-};
-dojo.event.MethodInvocation = function (join_point, obj, args) {
-	this.jp_ = join_point;
-	this.object = obj;
-	this.args = [];
-	for (var x = 0; x < args.length; x++) {
-		this.args[x] = args[x];
-	}
-	this.around_index = -1;
-};
-dojo.event.MethodInvocation.prototype.proceed = function () {
-	this.around_index++;
-	if (this.around_index >= this.jp_.around.length) {
-		return this.jp_.object[this.jp_.methodname].apply(this.jp_.object, this.args);
-	} else {
-		var ti = this.jp_.around[this.around_index];
-		var mobj = ti[0] || dj_global;
-		var meth = ti[1];
-		return mobj[meth].call(mobj, this);
-	}
-};
-dojo.event.MethodJoinPoint = function (obj, funcName) {
-	this.object = obj || dj_global;
-	this.methodname = funcName;
-	this.methodfunc = this.object[funcName];
-	this.squelch = false;
-};
-dojo.event.MethodJoinPoint.getForMethod = function (obj, funcName) {
-	if (!obj) {
-		obj = dj_global;
-	}
-	var ofn = obj[funcName];
-	if (!ofn) {
-		ofn = obj[funcName] = function () {
-		};
-		if (!obj[funcName]) {
-			dojo.raise("Cannot set do-nothing method on that object " + funcName);
-		}
-	} else {
-		if ((typeof ofn != "function") && (!dojo.lang.isFunction(ofn)) && (!dojo.lang.isAlien(ofn))) {
-			return null;
-		}
-	}
-	var jpname = funcName + "$joinpoint";
-	var jpfuncname = funcName + "$joinpoint$method";
-	var joinpoint = obj[jpname];
-	if (!joinpoint) {
-		var isNode = false;
-		if (dojo.event["browser"]) {
-			if ((obj["attachEvent"]) || (obj["nodeType"]) || (obj["addEventListener"])) {
-				isNode = true;
-				dojo.event.browser.addClobberNodeAttrs(obj, [jpname, jpfuncname, funcName]);
-			}
-		}
-		var origArity = ofn.length;
-		obj[jpfuncname] = ofn;
-		joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, jpfuncname);
-		if (!isNode) {
-			obj[funcName] = function () {
-				return joinpoint.run.apply(joinpoint, arguments);
-			};
-		} else {
-			obj[funcName] = function () {
-				var args = [];
-				if (!arguments.length) {
-					var evt = null;
-					try {
-						if (obj.ownerDocument) {
-							evt = obj.ownerDocument.parentWindow.event;
-						} else {
-							if (obj.documentElement) {
-								evt = obj.documentElement.ownerDocument.parentWindow.event;
-							} else {
-								if (obj.event) {
-									evt = obj.event;
-								} else {
-									evt = window.event;
-								}
-							}
-						}
-					}
-					catch (e) {
-						evt = window.event;
-					}
-					if (evt) {
-						args.push(dojo.event.browser.fixEvent(evt, this));
-					}
-				} else {
-					for (var x = 0; x < arguments.length; x++) {
-						if ((x == 0) && (dojo.event.browser.isEvent(arguments[x]))) {
-							args.push(dojo.event.browser.fixEvent(arguments[x], this));
-						} else {
-							args.push(arguments[x]);
-						}
-					}
-				}
-				return joinpoint.run.apply(joinpoint, args);
-			};
-		}
-		obj[funcName].__preJoinArity = origArity;
-	}
-	return joinpoint;
-};
-dojo.lang.extend(dojo.event.MethodJoinPoint, {squelch:false, unintercept:function () {
-	this.object[this.methodname] = this.methodfunc;
-	this.before = [];
-	this.after = [];
-	this.around = [];
-}, disconnect:dojo.lang.forward("unintercept"), run:function () {
-	var obj = this.object || dj_global;
-	var args = arguments;
-	var aargs = [];
-	for (var x = 0; x < args.length; x++) {
-		aargs[x] = args[x];
-	}
-	var unrollAdvice = function (marr) {
-		if (!marr) {
-			dojo.debug("Null argument to unrollAdvice()");
-			return;
-		}
-		var callObj = marr[0] || dj_global;
-		var callFunc = marr[1];
-		if (!callObj[callFunc]) {
-			dojo.raise("function \"" + callFunc + "\" does not exist on \"" + callObj + "\"");
-		}
-		var aroundObj = marr[2] || dj_global;
-		var aroundFunc = marr[3];
-		var msg = marr[6];
-		var maxCount = marr[7];
-		if (maxCount > -1) {
-			if (maxCount == 0) {
-				return;
-			}
-			marr[7]--;
-		}
-		var undef;
-		var to = {args:[], jp_:this, object:obj, proceed:function () {
-			return callObj[callFunc].apply(callObj, to.args);
-		}};
-		to.args = aargs;
-		var delay = parseInt(marr[4]);
-		var hasDelay = ((!isNaN(delay)) && (marr[4] !== null) && (typeof marr[4] != "undefined"));
-		if (marr[5]) {
-			var rate = parseInt(marr[5]);
-			var cur = new Date();
-			var timerSet = false;
-			if ((marr["last"]) && ((cur - marr.last) <= rate)) {
-				if (dojo.event._canTimeout) {
-					if (marr["delayTimer"]) {
-						clearTimeout(marr.delayTimer);
-					}
-					var tod = parseInt(rate * 2);
-					var mcpy = dojo.lang.shallowCopy(marr);
-					marr.delayTimer = setTimeout(function () {
-						mcpy[5] = 0;
-						unrollAdvice(mcpy);
-					}, tod);
-				}
-				return;
-			} else {
-				marr.last = cur;
-			}
-		}
-		if (aroundFunc) {
-			aroundObj[aroundFunc].call(aroundObj, to);
-		} else {
-			if ((hasDelay) && ((dojo.render.html) || (dojo.render.svg))) {
-				dj_global["setTimeout"](function () {
-					if (msg) {
-						callObj[callFunc].call(callObj, to);
-					} else {
-						callObj[callFunc].apply(callObj, args);
-					}
-				}, delay);
-			} else {
-				if (msg) {
-					callObj[callFunc].call(callObj, to);
-				} else {
-					callObj[callFunc].apply(callObj, args);
-				}
-			}
-		}
-	};
-	var unRollSquelch = function () {
-		if (this.squelch) {
-			try {
-				return unrollAdvice.apply(this, arguments);
-			}
-			catch (e) {
-				dojo.debug(e);
-			}
-		} else {
-			return unrollAdvice.apply(this, arguments);
-		}
-	};
-	if ((this["before"]) && (this.before.length > 0)) {
-		dojo.lang.forEach(this.before.concat(new Array()), unRollSquelch);
-	}
-	var result;
-	try {
-		if ((this["around"]) && (this.around.length > 0)) {
-			var mi = new dojo.event.MethodInvocation(this, obj, args);
-			result = mi.proceed();
-		} else {
-			if (this.methodfunc) {
-				result = this.object[this.methodname].apply(this.object, args);
-			}
-		}
-	}
-	catch (e) {
-		if (!this.squelch) {
-			dojo.debug(e, "when calling", this.methodname, "on", this.object, "with arguments", args);
-			dojo.raise(e);
-		}
-	}
-	if ((this["after"]) && (this.after.length > 0)) {
-		dojo.lang.forEach(this.after.concat(new Array()), unRollSquelch);
-	}
-	return (this.methodfunc) ? result : null;
-}, getArr:function (kind) {
-	var type = "after";
-	if ((typeof kind == "string") && (kind.indexOf("before") != -1)) {
-		type = "before";
-	} else {
-		if (kind == "around") {
-			type = "around";
-		}
-	}
-	if (!this[type]) {
-		this[type] = [];
-	}
-	return this[type];
-}, kwAddAdvice:function (args) {
-	this.addAdvice(args["adviceObj"], args["adviceFunc"], args["aroundObj"], args["aroundFunc"], args["adviceType"], args["precedence"], args["once"], args["delay"], args["rate"], args["adviceMsg"], args["maxCalls"]);
-}, addAdvice:function (thisAdviceObj, thisAdvice, thisAroundObj, thisAround, adviceType, precedence, once, delay, rate, asMessage, maxCalls) {
-	var arr = this.getArr(adviceType);
-	if (!arr) {
-		dojo.raise("bad this: " + this);
-	}
-	var ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage, maxCalls];
-	if (once) {
-		if (this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr) >= 0) {
-			return;
-		}
-	}
-	if (precedence == "first") {
-		arr.unshift(ao);
-	} else {
-		arr.push(ao);
-	}
-}, hasAdvice:function (thisAdviceObj, thisAdvice, adviceType, arr) {
-	if (!arr) {
-		arr = this.getArr(adviceType);
-	}
-	var ind = -1;
-	for (var x = 0; x < arr.length; x++) {
-		var aao = (typeof thisAdvice == "object") ? (new String(thisAdvice)).toString() : thisAdvice;
-		var a1o = (typeof arr[x][1] == "object") ? (new String(arr[x][1])).toString() : arr[x][1];
-		if ((arr[x][0] == thisAdviceObj) && (a1o == aao)) {
-			ind = x;
-		}
-	}
-	return ind;
-}, removeAdvice:function (thisAdviceObj, thisAdvice, adviceType, once) {
-	var arr = this.getArr(adviceType);
-	var ind = this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr);
-	if (ind == -1) {
-		return false;
-	}
-	while (ind != -1) {
-		arr.splice(ind, 1);
-		if (once) {
-			break;
-		}
-		ind = this.hasAdvice(thisAdviceObj, thisAdvice, adviceType, arr);
-	}
-	return true;
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/event/topic.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/event/topic.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/event/topic.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,72 +8,92 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.require("dojo.event");
+dojo.provide("dojo.event.topic");
 
+dojo.event.topic = new function(){
+	this.topics = {};
 
-dojo.require("dojo.event.common");
-dojo.provide("dojo.event.topic");
-dojo.event.topic = new function () {
-	this.topics = {};
-	this.getTopic = function (topic) {
-		if (!this.topics[topic]) {
-			this.topics[topic] = new this.TopicImpl(topic);
+	this.getTopic = function(topicName){
+		if(!this.topics[topicName]){
+			this.topics[topicName] = new this.TopicImpl(topicName);
 		}
-		return this.topics[topic];
-	};
-	this.registerPublisher = function (topic, obj, funcName) {
+		return this.topics[topicName];
+	}
+
+	this.registerPublisher = function(topic, obj, funcName){
 		var topic = this.getTopic(topic);
 		topic.registerPublisher(obj, funcName);
-	};
-	this.subscribe = function (topic, obj, funcName) {
+	}
+
+	this.subscribe = function(topic, obj, funcName){
 		var topic = this.getTopic(topic);
 		topic.subscribe(obj, funcName);
-	};
-	this.unsubscribe = function (topic, obj, funcName) {
+	}
+
+	this.unsubscribe = function(topic, obj, funcName){
 		var topic = this.getTopic(topic);
 		topic.unsubscribe(obj, funcName);
-	};
-	this.destroy = function (topic) {
+	}
+
+	this.destroy = function(topic){
 		this.getTopic(topic).destroy();
 		delete this.topics[topic];
-	};
-	this.publishApply = function (topic, args) {
+	}
+
+	this.publishApply = function(topic, args){
 		var topic = this.getTopic(topic);
 		topic.sendMessage.apply(topic, args);
-	};
-	this.publish = function (topic, message) {
+	}
+
+	this.publish = function(topic, message){
 		var topic = this.getTopic(topic);
+		// if message is an array, we treat it as a set of arguments,
+		// otherwise, we just pass on the arguments passed in as-is
 		var args = [];
-		for (var x = 1; x < arguments.length; x++) {
+		// could we use concat instead here?
+		for(var x=1; x<arguments.length; x++){
 			args.push(arguments[x]);
 		}
 		topic.sendMessage.apply(topic, args);
-	};
-};
-dojo.event.topic.TopicImpl = function (topicName) {
+	}
+}
+
+dojo.event.topic.TopicImpl = function(topicName){
 	this.topicName = topicName;
-	this.subscribe = function (listenerObject, listenerMethod) {
-		var tf = listenerMethod || listenerObject;
+
+	this.subscribe = function(listenerObject, listenerMethod){
+		var tf = listenerMethod||listenerObject;
 		var to = (!listenerMethod) ? dj_global : listenerObject;
-		return dojo.event.kwConnect({srcObj:this, srcFunc:"sendMessage", adviceObj:to, adviceFunc:tf});
-	};
-	this.unsubscribe = function (listenerObject, listenerMethod) {
+		dojo.event.kwConnect({
+			srcObj:		this, 
+			srcFunc:	"sendMessage", 
+			adviceObj:	to,
+			adviceFunc: tf
+		});
+	}
+
+	this.unsubscribe = function(listenerObject, listenerMethod){
 		var tf = (!listenerMethod) ? listenerObject : listenerMethod;
 		var to = (!listenerMethod) ? null : listenerObject;
-		return dojo.event.kwDisconnect({srcObj:this, srcFunc:"sendMessage", adviceObj:to, adviceFunc:tf});
-	};
-	this._getJoinPoint = function () {
-		return dojo.event.MethodJoinPoint.getForMethod(this, "sendMessage");
-	};
-	this.setSquelch = function (shouldSquelch) {
-		this._getJoinPoint().squelch = shouldSquelch;
-	};
-	this.destroy = function () {
-		this._getJoinPoint().disconnect();
-	};
-	this.registerPublisher = function (publisherObject, publisherMethod) {
+		dojo.event.kwDisconnect({
+			srcObj:		this, 
+			srcFunc:	"sendMessage", 
+			adviceObj:	to,
+			adviceFunc: tf
+		});
+	}
+
+	this.destroy = function(){
+		dojo.event.MethodJoinPoint.getForMethod(this, "sendMessage").disconnect();
+	}
+
+	this.registerPublisher = function(publisherObject, publisherMethod){
 		dojo.event.connect(publisherObject, publisherMethod, this, "sendMessage");
-	};
-	this.sendMessage = function (message) {
-	};
-};
+	}
 
+	this.sendMessage = function(message){
+		// The message has been propagated
+	}
+}
+

Modified: tags/parley-0.53/root/static/magic/src/event.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/event.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/event.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,568 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.event");
 
+dojo.require("dojo.lang.array");
+dojo.require("dojo.lang.extras");
+dojo.require("dojo.lang.func");
 
-dojo.provide("dojo.event");
-dojo.require("dojo.event.*");
-dojo.deprecated("dojo.event", "replaced by dojo.event.*", "0.5");
+dojo.event = new function(){
+	this.canTimeout = dojo.lang.isFunction(dj_global["setTimeout"])||dojo.lang.isAlien(dj_global["setTimeout"]);
 
+	// FIXME: where should we put this method (not here!)?
+	function interpolateArgs(args, searchForNames){
+		var dl = dojo.lang;
+		var ao = {
+			srcObj: dj_global,
+			srcFunc: null,
+			adviceObj: dj_global,
+			adviceFunc: null,
+			aroundObj: null,
+			aroundFunc: null,
+			adviceType: (args.length>2) ? args[0] : "after",
+			precedence: "last",
+			once: false,
+			delay: null,
+			rate: 0,
+			adviceMsg: false
+		};
+
+		switch(args.length){
+			case 0: return;
+			case 1: return;
+			case 2:
+				ao.srcFunc = args[0];
+				ao.adviceFunc = args[1];
+				break;
+			case 3:
+				if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isString(args[2]))){
+					ao.adviceType = "after";
+					ao.srcObj = args[0];
+					ao.srcFunc = args[1];
+					ao.adviceFunc = args[2];
+				}else if((dl.isString(args[1]))&&(dl.isString(args[2]))){
+					ao.srcFunc = args[1];
+					ao.adviceFunc = args[2];
+				}else if((dl.isObject(args[0]))&&(dl.isString(args[1]))&&(dl.isFunction(args[2]))){
+					ao.adviceType = "after";
+					ao.srcObj = args[0];
+					ao.srcFunc = args[1];
+					var tmpName  = dl.nameAnonFunc(args[2], ao.adviceObj, searchForNames);
+					ao.adviceFunc = tmpName;
+				}else if((dl.isFunction(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))){
+					ao.adviceType = "after";
+					ao.srcObj = dj_global;
+					var tmpName  = dl.nameAnonFunc(args[0], ao.srcObj, searchForNames);
+					ao.srcFunc = tmpName;
+					ao.adviceObj = args[1];
+					ao.adviceFunc = args[2];
+				}
+				break;
+			case 4:
+				if((dl.isObject(args[0]))&&(dl.isObject(args[2]))){
+					// we can assume that we've got an old-style "connect" from
+					// the sigslot school of event attachment. We therefore
+					// assume after-advice.
+					ao.adviceType = "after";
+					ao.srcObj = args[0];
+					ao.srcFunc = args[1];
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else if((dl.isString(args[0]))&&(dl.isString(args[1]))&&(dl.isObject(args[2]))){
+					ao.adviceType = args[0];
+					ao.srcObj = dj_global;
+					ao.srcFunc = args[1];
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else if((dl.isString(args[0]))&&(dl.isFunction(args[1]))&&(dl.isObject(args[2]))){
+					ao.adviceType = args[0];
+					ao.srcObj = dj_global;
+					var tmpName  = dl.nameAnonFunc(args[1], dj_global, searchForNames);
+					ao.srcFunc = tmpName;
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else if((dl.isString(args[0]))&&(dl.isObject(args[1]))&&(dl.isString(args[2]))&&(dl.isFunction(args[3]))){
+					ao.srcObj = args[1];
+					ao.srcFunc = args[2];
+					var tmpName  = dl.nameAnonFunc(args[3], dj_global, searchForNames);
+					ao.adviceObj = dj_global;
+					ao.adviceFunc = tmpName;
+				}else if(dl.isObject(args[1])){
+					ao.srcObj = args[1];
+					ao.srcFunc = args[2];
+					ao.adviceObj = dj_global;
+					ao.adviceFunc = args[3];
+				}else if(dl.isObject(args[2])){
+					ao.srcObj = dj_global;
+					ao.srcFunc = args[1];
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else{
+					ao.srcObj = ao.adviceObj = ao.aroundObj = dj_global;
+					ao.srcFunc = args[1];
+					ao.adviceFunc = args[2];
+					ao.aroundFunc = args[3];
+				}
+				break;
+			case 6:
+				ao.srcObj = args[1];
+				ao.srcFunc = args[2];
+				ao.adviceObj = args[3]
+				ao.adviceFunc = args[4];
+				ao.aroundFunc = args[5];
+				ao.aroundObj = dj_global;
+				break;
+			default:
+				ao.srcObj = args[1];
+				ao.srcFunc = args[2];
+				ao.adviceObj = args[3]
+				ao.adviceFunc = args[4];
+				ao.aroundObj = args[5];
+				ao.aroundFunc = args[6];
+				ao.once = args[7];
+				ao.delay = args[8];
+				ao.rate = args[9];
+				ao.adviceMsg = args[10];
+				break;
+		}
+
+		if(dl.isFunction(ao.aroundFunc)){
+			var tmpName  = dl.nameAnonFunc(ao.aroundFunc, ao.aroundObj, searchForNames);
+			ao.aroundFunc = tmpName;
+		}
+
+		if(dl.isFunction(ao.srcFunc)){
+			ao.srcFunc = dl.getNameInObj(ao.srcObj, ao.srcFunc);
+		}
+
+		if(dl.isFunction(ao.adviceFunc)){
+			ao.adviceFunc = dl.getNameInObj(ao.adviceObj, ao.adviceFunc);
+		}
+
+		if((ao.aroundObj)&&(dl.isFunction(ao.aroundFunc))){
+			ao.aroundFunc = dl.getNameInObj(ao.aroundObj, ao.aroundFunc);
+		}
+
+		if(!ao.srcObj){
+			dojo.raise("bad srcObj for srcFunc: "+ao.srcFunc);
+		}
+		if(!ao.adviceObj){
+			dojo.raise("bad adviceObj for adviceFunc: "+ao.adviceFunc);
+		}
+		return ao;
+	}
+
+	this.connect = function(){
+		if(arguments.length == 1){
+			var ao = arguments[0];
+		}else{
+			var ao = interpolateArgs(arguments, true);
+		}
+
+		if(dojo.lang.isArray(ao.srcObj) && ao.srcObj!=""){
+			var tmpAO = {};
+			for(var x in ao){
+				tmpAO[x] = ao[x];
+			}
+			var mjps = [];
+			dojo.lang.forEach(ao.srcObj, function(src){
+				if((dojo.render.html.capable)&&(dojo.lang.isString(src))){
+					src = dojo.byId(src);
+					// dojo.debug(src);
+				}
+				tmpAO.srcObj = src;
+				// dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);
+				// dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);
+				mjps.push(dojo.event.connect.call(dojo.event, tmpAO));
+			});
+			return mjps;
+		}
+
+		// FIXME: just doing a "getForMethod()" seems to be enough to put this into infinite recursion!!
+		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
+		if(ao.adviceFunc){
+			var mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);
+		}
+
+		mjp.kwAddAdvice(ao);
+
+		return mjp;	// advanced users might want to fsck w/ the join point
+					// manually
+	}
+
+	this.log = function(a1, a2){
+		var kwArgs;
+		if((arguments.length == 1)&&(typeof a1 == "object")){
+			kwArgs = a1;
+		}else{
+			kwArgs = {
+				srcObj: a1,
+				srcFunc: a2
+			};
+		}
+		kwArgs.adviceFunc = function(){
+			var argsStr = [];
+			for(var x=0; x<arguments.length; x++){
+				argsStr.push(arguments[x]);
+			}
+			dojo.debug("("+kwArgs.srcObj+")."+kwArgs.srcFunc, ":", argsStr.join(", "));
+		}
+		this.kwConnect(kwArgs);
+	}
+
+	this.connectBefore = function(){
+		var args = ["before"];
+		for(var i = 0; i < arguments.length; i++) { args.push(arguments[i]); }
+		return this.connect.apply(this, args);
+	}
+
+	this.connectAround = function(){
+		var args = ["around"];
+		for(var i = 0; i < arguments.length; i++) { args.push(arguments[i]); }
+		return this.connect.apply(this, args);
+	}
+
+	this.connectOnce = function(){
+		var ao = interpolateArgs(arguments, true);
+		ao.once = true;
+		return this.connect(ao);
+	}
+
+	this._kwConnectImpl = function(kwArgs, disconnect){
+		var fn = (disconnect) ? "disconnect" : "connect";
+		if(typeof kwArgs["srcFunc"] == "function"){
+			kwArgs.srcObj = kwArgs["srcObj"]||dj_global;
+			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);
+			kwArgs.srcFunc = tmpName;
+		}
+		if(typeof kwArgs["adviceFunc"] == "function"){
+			kwArgs.adviceObj = kwArgs["adviceObj"]||dj_global;
+			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);
+			kwArgs.adviceFunc = tmpName;
+		}
+		return dojo.event[fn](	(kwArgs["type"]||kwArgs["adviceType"]||"after"),
+									kwArgs["srcObj"]||dj_global,
+									kwArgs["srcFunc"],
+									kwArgs["adviceObj"]||kwArgs["targetObj"]||dj_global,
+									kwArgs["adviceFunc"]||kwArgs["targetFunc"],
+									kwArgs["aroundObj"],
+									kwArgs["aroundFunc"],
+									kwArgs["once"],
+									kwArgs["delay"],
+									kwArgs["rate"],
+									kwArgs["adviceMsg"]||false );
+	}
+
+	this.kwConnect = function(kwArgs){
+		return this._kwConnectImpl(kwArgs, false);
+
+	}
+
+	this.disconnect = function(){
+		var ao = interpolateArgs(arguments, true);
+		if(!ao.adviceFunc){ return; } // nothing to disconnect
+		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
+		return mjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once);
+	}
+
+	this.kwDisconnect = function(kwArgs){
+		return this._kwConnectImpl(kwArgs, true);
+	}
+}
+
+// exactly one of these is created whenever a method with a joint point is run,
+// if there is at least one 'around' advice.
+dojo.event.MethodInvocation = function(join_point, obj, args) {
+	this.jp_ = join_point;
+	this.object = obj;
+	this.args = [];
+	for(var x=0; x<args.length; x++){
+		this.args[x] = args[x];
+	}
+	// the index of the 'around' that is currently being executed.
+	this.around_index = -1;
+}
+
+dojo.event.MethodInvocation.prototype.proceed = function() {
+	this.around_index++;
+	if(this.around_index >= this.jp_.around.length){
+		return this.jp_.object[this.jp_.methodname].apply(this.jp_.object, this.args);
+		// return this.jp_.run_before_after(this.object, this.args);
+	}else{
+		var ti = this.jp_.around[this.around_index];
+		var mobj = ti[0]||dj_global;
+		var meth = ti[1];
+		return mobj[meth].call(mobj, this);
+	}
+} 
+
+
+dojo.event.MethodJoinPoint = function(obj, methname){
+	this.object = obj||dj_global;
+	this.methodname = methname;
+	this.methodfunc = this.object[methname];
+	this.before = [];
+	this.after = [];
+	this.around = [];
+}
+
+dojo.event.MethodJoinPoint.getForMethod = function(obj, methname) {
+	// if(!(methname in obj)){
+	if(!obj){ obj = dj_global; }
+	if(!obj[methname]){
+		// supply a do-nothing method implementation
+		obj[methname] = function(){};
+		if(!obj[methname]){
+			// e.g. cannot add to inbuilt objects in IE6
+			dojo.raise("Cannot set do-nothing method on that object "+methname);
+		}
+	}else if((!dojo.lang.isFunction(obj[methname]))&&(!dojo.lang.isAlien(obj[methname]))){
+		return null; // FIXME: should we throw an exception here instead?
+	}
+	// we hide our joinpoint instance in obj[methname + '$joinpoint']
+	var jpname = methname + "$joinpoint";
+	var jpfuncname = methname + "$joinpoint$method";
+	var joinpoint = obj[jpname];
+	if(!joinpoint){
+		var isNode = false;
+		if(dojo.event["browser"]){
+			if( (obj["attachEvent"])||
+				(obj["nodeType"])||
+				(obj["addEventListener"]) ){
+				isNode = true;
+				dojo.event.browser.addClobberNodeAttrs(obj, [jpname, jpfuncname, methname]);
+			}
+		}
+		var origArity = obj[methname].length;
+		obj[jpfuncname] = obj[methname];
+		// joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, methname);
+		joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, jpfuncname);
+		obj[methname] = function(){ 
+			var args = [];
+
+			if((isNode)&&(!arguments.length)){
+				var evt = null;
+				try{
+					if(obj.ownerDocument){
+						evt = obj.ownerDocument.parentWindow.event;
+					}else if(obj.documentElement){
+						evt = obj.documentElement.ownerDocument.parentWindow.event;
+					}else{
+						evt = window.event;
+					}
+				}catch(e){
+					evt = window.event;
+				}
+
+				if(evt){
+					args.push(dojo.event.browser.fixEvent(evt, this));
+				}
+			}else{
+				for(var x=0; x<arguments.length; x++){
+					if((x==0)&&(isNode)&&(dojo.event.browser.isEvent(arguments[x]))){
+						args.push(dojo.event.browser.fixEvent(arguments[x], this));
+					}else{
+						args.push(arguments[x]);
+					}
+				}
+			}
+			// return joinpoint.run.apply(joinpoint, arguments); 
+			return joinpoint.run.apply(joinpoint, args); 
+		}
+		obj[methname].__preJoinArity = origArity;
+	}
+	return joinpoint;
+}
+
+dojo.lang.extend(dojo.event.MethodJoinPoint, {
+	unintercept: function(){
+		this.object[this.methodname] = this.methodfunc;
+		this.before = [];
+		this.after = [];
+		this.around = [];
+	},
+
+	disconnect: dojo.lang.forward("unintercept"),
+
+	run: function() {
+		var obj = this.object||dj_global;
+		var args = arguments;
+
+		// optimization. We only compute once the array version of the arguments
+		// pseudo-arr in order to prevent building it each time advice is unrolled.
+		var aargs = [];
+		for(var x=0; x<args.length; x++){
+			aargs[x] = args[x];
+		}
+
+		var unrollAdvice  = function(marr){ 
+			if(!marr){
+				dojo.debug("Null argument to unrollAdvice()");
+				return;
+			}
+		  
+			var callObj = marr[0]||dj_global;
+			var callFunc = marr[1];
+			
+			if(!callObj[callFunc]){
+				dojo.raise("function \"" + callFunc + "\" does not exist on \"" + callObj + "\"");
+			}
+			
+			var aroundObj = marr[2]||dj_global;
+			var aroundFunc = marr[3];
+			var msg = marr[6];
+			var undef;
+
+			var to = {
+				args: [],
+				jp_: this,
+				object: obj,
+				proceed: function(){
+					return callObj[callFunc].apply(callObj, to.args);
+				}
+			};
+			to.args = aargs;
+
+			var delay = parseInt(marr[4]);
+			var hasDelay = ((!isNaN(delay))&&(marr[4]!==null)&&(typeof marr[4] != "undefined"));
+			if(marr[5]){
+				var rate = parseInt(marr[5]);
+				var cur = new Date();
+				var timerSet = false;
+				if((marr["last"])&&((cur-marr.last)<=rate)){
+					if(dojo.event.canTimeout){
+						if(marr["delayTimer"]){
+							clearTimeout(marr.delayTimer);
+						}
+						var tod = parseInt(rate*2); // is rate*2 naive?
+						var mcpy = dojo.lang.shallowCopy(marr);
+						marr.delayTimer = setTimeout(function(){
+							// FIXME: on IE at least, event objects from the
+							// browser can go out of scope. How (or should?) we
+							// deal with it?
+							mcpy[5] = 0;
+							unrollAdvice(mcpy);
+						}, tod);
+					}
+					return;
+				}else{
+					marr.last = cur;
+				}
+			}
+
+			// FIXME: need to enforce rates for a connection here!
+
+			if(aroundFunc){
+				// NOTE: around advice can't delay since we might otherwise depend
+				// on execution order!
+				aroundObj[aroundFunc].call(aroundObj, to);
+			}else{
+				// var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);
+				if((hasDelay)&&((dojo.render.html)||(dojo.render.svg))){  // FIXME: the render checks are grotty!
+					dj_global["setTimeout"](function(){
+						if(msg){
+							callObj[callFunc].call(callObj, to); 
+						}else{
+							callObj[callFunc].apply(callObj, args); 
+						}
+					}, delay);
+				}else{ // many environments can't support delay!
+					if(msg){
+						callObj[callFunc].call(callObj, to); 
+					}else{
+						callObj[callFunc].apply(callObj, args); 
+					}
+				}
+			}
+		}
+
+		if(this.before.length>0){
+			dojo.lang.forEach(this.before, unrollAdvice);
+		}
+
+		var result;
+		if(this.around.length>0){
+			var mi = new dojo.event.MethodInvocation(this, obj, args);
+			result = mi.proceed();
+		}else if(this.methodfunc){
+			result = this.object[this.methodname].apply(this.object, args);
+		}
+
+		if(this.after.length>0){
+			dojo.lang.forEach(this.after, unrollAdvice);
+		}
+
+		return (this.methodfunc) ? result : null;
+	},
+
+	getArr: function(kind){
+		var arr = this.after;
+		// FIXME: we should be able to do this through props or Array.in()
+		if((typeof kind == "string")&&(kind.indexOf("before")!=-1)){
+			arr = this.before;
+		}else if(kind=="around"){
+			arr = this.around;
+		}
+		return arr;
+	},
+
+	kwAddAdvice: function(args){
+		this.addAdvice(	args["adviceObj"], args["adviceFunc"], 
+						args["aroundObj"], args["aroundFunc"], 
+						args["adviceType"], args["precedence"], 
+						args["once"], args["delay"], args["rate"], 
+						args["adviceMsg"]);
+	},
+
+	addAdvice: function(	thisAdviceObj, thisAdvice, 
+							thisAroundObj, thisAround, 
+							advice_kind, precedence, 
+							once, delay, rate, asMessage){
+		var arr = this.getArr(advice_kind);
+		if(!arr){
+			dojo.raise("bad this: " + this);
+		}
+
+		var ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage];
+		
+		if(once){
+			if(this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr) >= 0){
+				return;
+			}
+		}
+
+		if(precedence == "first"){
+			arr.unshift(ao);
+		}else{
+			arr.push(ao);
+		}
+	},
+
+	hasAdvice: function(thisAdviceObj, thisAdvice, advice_kind, arr){
+		if(!arr){ arr = this.getArr(advice_kind); }
+		var ind = -1;
+		for(var x=0; x<arr.length; x++){
+			var aao = (typeof thisAdvice == "object") ? (new String(thisAdvice)).toString() : thisAdvice;
+			var a1o = (typeof arr[x][1] == "object") ? (new String(arr[x][1])).toString() : arr[x][1];
+			if((arr[x][0] == thisAdviceObj)&&(a1o == aao)){
+				ind = x;
+			}
+		}
+		return ind;
+	},
+
+	removeAdvice: function(thisAdviceObj, thisAdvice, advice_kind, once){
+		var arr = this.getArr(advice_kind);
+		var ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);
+		if(ind == -1){
+			return false;
+		}
+		while(ind != -1){
+			arr.splice(ind, 1);
+			if(once){ break; }
+			ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);
+		}
+		return true;
+	}
+});

Modified: tags/parley-0.53/root/static/magic/src/experimental.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/experimental.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/experimental.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,15 +8,14 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.experimental");
-dojo.experimental = function (moduleName, extra) {
-	var message = "EXPERIMENTAL: " + moduleName;
-	message += " -- Not yet ready for use.  APIs subject to change without notice.";
-	if (extra) {
-		message += " " + extra;
-	}
-	dojo.debug(message);
-};
 
+/**
+ * Convenience for informing of experimental code.
+ */
+dojo.experimental = function(packageName, extra){
+	var mess = "EXPERIMENTAL: " + packageName;
+	mess += " -- Not yet ready for use.  APIs subject to change without notice.";
+	if(extra){ mess += " " + extra; }
+	dojo.debug(mess);
+}

Modified: tags/parley-0.53/root/static/magic/src/flash/flash6/DojoExternalInterface.as
===================================================================
--- tags/parley-0.53/root/static/magic/src/flash/flash6/DojoExternalInterface.as	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/flash/flash6/DojoExternalInterface.as	2008-10-08 11:42:12 UTC (rev 952)
@@ -108,8 +108,7 @@
 		
 		// check at regular intervals for return results	
 		var resultsChecker = function(){
-			if((typeof _root._returnResult != "undefined")&&
-				(_root._returnResult != "undefined")){
+			if(_root._returnResult != undefined){
 				clearInterval(_root._callbackID);
 				resultsCallback.call(null, _root._returnResult);
 			}

Modified: tags/parley-0.53/root/static/magic/src/flash.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/flash.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/flash.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,439 +8,1237 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.flash");
-dojo.require("dojo.string.*");
-dojo.require("dojo.uri.*");
-dojo.require("dojo.html.common");
-dojo.flash = function () {
-};
-dojo.flash = {flash6_version:null, flash8_version:null, ready:false, _visible:true, _loadedListeners:new Array(), _installingListeners:new Array(), setSwf:function (fileInfo) {
-	if (fileInfo == null || dojo.lang.isUndefined(fileInfo)) {
-		return;
-	}
-	if (fileInfo.flash6 != null && !dojo.lang.isUndefined(fileInfo.flash6)) {
-		this.flash6_version = fileInfo.flash6;
-	}
-	if (fileInfo.flash8 != null && !dojo.lang.isUndefined(fileInfo.flash8)) {
-		this.flash8_version = fileInfo.flash8;
-	}
-	if (!dojo.lang.isUndefined(fileInfo.visible)) {
-		this._visible = fileInfo.visible;
-	}
-	this._initialize();
-}, useFlash6:function () {
-	if (this.flash6_version == null) {
-		return false;
-	} else {
-		if (this.flash6_version != null && dojo.flash.info.commVersion == 6) {
-			return true;
-		} else {
-			return false;
-		}
-	}
-}, useFlash8:function () {
-	if (this.flash8_version == null) {
-		return false;
-	} else {
-		if (this.flash8_version != null && dojo.flash.info.commVersion == 8) {
-			return true;
-		} else {
-			return false;
-		}
-	}
-}, addLoadedListener:function (listener) {
-	this._loadedListeners.push(listener);
-}, addInstallingListener:function (listener) {
-	this._installingListeners.push(listener);
-}, loaded:function () {
-	dojo.flash.ready = true;
-	if (dojo.flash._loadedListeners.length > 0) {
-		for (var i = 0; i < dojo.flash._loadedListeners.length; i++) {
-			dojo.flash._loadedListeners[i].call(null);
-		}
-	}
-}, installing:function () {
-	if (dojo.flash._installingListeners.length > 0) {
-		for (var i = 0; i < dojo.flash._installingListeners.length; i++) {
-			dojo.flash._installingListeners[i].call(null);
-		}
-	}
-}, _initialize:function () {
-	var installer = new dojo.flash.Install();
-	dojo.flash.installer = installer;
-	if (installer.needed() == true) {
-		installer.install();
-	} else {
-		dojo.flash.obj = new dojo.flash.Embed(this._visible);
-		dojo.flash.obj.write(dojo.flash.info.commVersion);
-		dojo.flash.comm = new dojo.flash.Communicator();
-	}
-}};
-dojo.flash.Info = function () {
-	if (dojo.render.html.ie) {
-		document.writeln("<script language=\"VBScript\" type=\"text/vbscript\">");
-		document.writeln("Function VBGetSwfVer(i)");
-		document.writeln("  on error resume next");
-		document.writeln("  Dim swControl, swVersion");
-		document.writeln("  swVersion = 0");
-		document.writeln("  set swControl = CreateObject(\"ShockwaveFlash.ShockwaveFlash.\" + CStr(i))");
-		document.writeln("  if (IsObject(swControl)) then");
-		document.writeln("	swVersion = swControl.GetVariable(\"$version\")");
-		document.writeln("  end if");
-		document.writeln("  VBGetSwfVer = swVersion");
-		document.writeln("End Function");
-		document.writeln("</script>");
-	}
-	this._detectVersion();
-	this._detectCommunicationVersion();
-};
-dojo.flash.Info.prototype = {version:-1, versionMajor:-1, versionMinor:-1, versionRevision:-1, capable:false, commVersion:6, installing:false, isVersionOrAbove:function (reqMajorVer, reqMinorVer, reqVer) {
-	reqVer = parseFloat("." + reqVer);
-	if (this.versionMajor >= reqMajorVer && this.versionMinor >= reqMinorVer && this.versionRevision >= reqVer) {
-		return true;
-	} else {
-		return false;
-	}
-}, _detectVersion:function () {
-	var versionStr;
-	for (var testVersion = 25; testVersion > 0; testVersion--) {
-		if (dojo.render.html.ie) {
-			versionStr = VBGetSwfVer(testVersion);
-		} else {
-			versionStr = this._JSFlashInfo(testVersion);
-		}
-		if (versionStr == -1) {
-			this.capable = false;
-			return;
-		} else {
-			if (versionStr != 0) {
-				var versionArray;
-				if (dojo.render.html.ie) {
-					var tempArray = versionStr.split(" ");
-					var tempString = tempArray[1];
-					versionArray = tempString.split(",");
-				} else {
-					versionArray = versionStr.split(".");
-				}
-				this.versionMajor = versionArray[0];
-				this.versionMinor = versionArray[1];
-				this.versionRevision = versionArray[2];
-				var versionString = this.versionMajor + "." + this.versionRevision;
-				this.version = parseFloat(versionString);
-				this.capable = true;
-				break;
-			}
-		}
-	}
-}, _JSFlashInfo:function (testVersion) {
-	if (navigator.plugins != null && navigator.plugins.length > 0) {
-		if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
-			var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
-			var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
-			var descArray = flashDescription.split(" ");
-			var tempArrayMajor = descArray[2].split(".");
-			var versionMajor = tempArrayMajor[0];
-			var versionMinor = tempArrayMajor[1];
-			if (descArray[3] != "") {
-				var tempArrayMinor = descArray[3].split("r");
-			} else {
-				var tempArrayMinor = descArray[4].split("r");
-			}
-			var versionRevision = tempArrayMinor[1] > 0 ? tempArrayMinor[1] : 0;
-			var version = versionMajor + "." + versionMinor + "." + versionRevision;
-			return version;
-		}
-	}
-	return -1;
-}, _detectCommunicationVersion:function () {
-	if (this.capable == false) {
-		this.commVersion = null;
-		return;
-	}
-	if (typeof djConfig["forceFlashComm"] != "undefined" && typeof djConfig["forceFlashComm"] != null) {
-		this.commVersion = djConfig["forceFlashComm"];
-		return;
-	}
-	if (dojo.render.html.safari == true || dojo.render.html.opera == true) {
-		this.commVersion = 8;
-	} else {
-		this.commVersion = 6;
-	}
-}};
-dojo.flash.Embed = function (visible) {
-	this._visible = visible;
-};
-dojo.flash.Embed.prototype = {width:215, height:138, id:"flashObject", _visible:true, protocol:function () {
-	switch (window.location.protocol) {
-	  case "https:":
-		return "https";
-		break;
-	  default:
-		return "http";
-		break;
-	}
-}, write:function (flashVer, doExpressInstall) {
-	if (dojo.lang.isUndefined(doExpressInstall)) {
-		doExpressInstall = false;
-	}
-	var containerStyle = new dojo.string.Builder();
-	containerStyle.append("width: " + this.width + "px; ");
-	containerStyle.append("height: " + this.height + "px; ");
-	if (this._visible == false) {
-		containerStyle.append("position: absolute; ");
-		containerStyle.append("z-index: 10000; ");
-		containerStyle.append("top: -1000px; ");
-		containerStyle.append("left: -1000px; ");
-	}
-	containerStyle = containerStyle.toString();
-	var objectHTML;
-	var swfloc;
-	if (flashVer == 6) {
-		swfloc = dojo.flash.flash6_version;
-		var dojoPath = djConfig.baseRelativePath;
-		swfloc = swfloc + "?baseRelativePath=" + escape(dojoPath);
-		objectHTML = "<embed id=\"" + this.id + "\" src=\"" + swfloc + "\" " + "	quality=\"high\" bgcolor=\"#ffffff\" " + "	width=\"" + this.width + "\" height=\"" + this.height + "\" " + "	name=\"" + this.id + "\" " + "	align=\"middle\" allowScriptAccess=\"sameDomain\" " + "	type=\"application/x-shockwave-flash\" swLiveConnect=\"true\" " + "	pluginspage=\"" + this.protocol() + "://www.macromedia.com/go/getflashplayer\">";
-	} else {
-		swfloc = dojo.flash.flash8_version;
-		var swflocObject = swfloc;
-		var swflocEmbed = swfloc;
-		var dojoPath = djConfig.baseRelativePath;
-		if (doExpressInstall) {
-			var redirectURL = escape(window.location);
-			document.title = document.title.slice(0, 47) + " - Flash Player Installation";
-			var docTitle = escape(document.title);
-			swflocObject += "?MMredirectURL=" + redirectURL + "&MMplayerType=ActiveX" + "&MMdoctitle=" + docTitle + "&baseRelativePath=" + escape(dojoPath);
-			swflocEmbed += "?MMredirectURL=" + redirectURL + "&MMplayerType=PlugIn" + "&baseRelativePath=" + escape(dojoPath);
-		}
-		if (swflocEmbed.indexOf("?") == -1) {
-			swflocEmbed += "?baseRelativePath=" + escape(dojoPath) + "' ";
-		}
-		objectHTML = "<object classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" " + "codebase=\"" + this.protocol() + "://fpdownload.macromedia.com/pub/shockwave/cabs/flash/" + "swflash.cab#version=8,0,0,0\" " + "width=\"" + this.width + "\" " + "height=\"" + this.height + "\" " + "id=\"" + this.id + "\" " + "align=\"middle\"> " + "<param name=\"allowScriptAccess\" value=\"sameDomain\" /> " + "<param name=\"movie\" value=\"" + swflocObject + "\" /> " + "<param name=\"quality\" value=\"high\" /> " + "<param name=\"bgcolor\" value=\"#ffffff\" /> " + "<embed src=\"" + swflocEmbed + "' " + "quality=\"high\" " + "bgcolor=\"#ffffff\" " + "width=\"" + this.width + "\" " + "height=\"" + this.height + "\" " + "id=\"" + this.id + "\" " + "name=\"" + this.id + "\" " + "swLiveConnect=\"true\" " + "align=\"middle\" " + "allowScriptAccess=\"sameDomain\" " + "type=\"application/x-shockwave-flash\" " + "pluginspage=\"" + this.protocol() + "://www.macromedia.com/go/getflashplayer\" />" + "</!
 object>";
-	}
-	objectHTML = "<div id=\"" + this.id + "Container\" style=\"" + containerStyle + "\"> " + objectHTML + "</div>";
-	document.writeln(objectHTML);
-}, get:function () {
-	return document.getElementById(this.id);
-}, setVisible:function (visible) {
-	var container = dojo.byId(this.id + "Container");
-	if (visible == true) {
-		container.style.visibility = "visible";
-	} else {
-		container.style.position = "absolute";
-		container.style.x = "-1000px";
-		container.style.y = "-1000px";
-		container.style.visibility = "hidden";
-	}
-}, center:function () {
-	var elementWidth = this.width;
-	var elementHeight = this.height;
-	var scroll_offset = dojo.html.getScroll().offset;
-	var viewport_size = dojo.html.getViewport();
-	var x = scroll_offset.x + (viewport_size.width - elementWidth) / 2;
-	var y = scroll_offset.y + (viewport_size.height - elementHeight) / 2;
-	var container = dojo.byId(this.id + "Container");
-	container.style.top = y + "px";
-	container.style.left = x + "px";
-}};
-dojo.flash.Communicator = function () {
-	if (dojo.flash.useFlash6()) {
-		this._writeFlash6();
-	} else {
-		if (dojo.flash.useFlash8()) {
-			this._writeFlash8();
-		}
-	}
-};
-dojo.flash.Communicator.prototype = {_writeFlash6:function () {
-	var id = dojo.flash.obj.id;
-	document.writeln("<script language=\"JavaScript\">");
-	document.writeln("  function " + id + "_DoFSCommand(command, args){ ");
-	document.writeln("	dojo.flash.comm._handleFSCommand(command, args); ");
-	document.writeln("}");
-	document.writeln("</script>");
-	if (dojo.render.html.ie) {
-		document.writeln("<SCRIPT LANGUAGE=VBScript> ");
-		document.writeln("on error resume next ");
-		document.writeln("Sub " + id + "_FSCommand(ByVal command, ByVal args)");
-		document.writeln(" call " + id + "_DoFSCommand(command, args)");
-		document.writeln("end sub");
-		document.writeln("</SCRIPT> ");
-	}
-}, _writeFlash8:function () {
-}, _handleFSCommand:function (command, args) {
-	if (command != null && !dojo.lang.isUndefined(command) && /^FSCommand:(.*)/.test(command) == true) {
-		command = command.match(/^FSCommand:(.*)/)[1];
-	}
-	if (command == "addCallback") {
-		this._fscommandAddCallback(command, args);
-	} else {
-		if (command == "call") {
-			this._fscommandCall(command, args);
-		} else {
-			if (command == "fscommandReady") {
-				this._fscommandReady();
-			}
-		}
-	}
-}, _fscommandAddCallback:function (command, args) {
-	var functionName = args;
-	var callFunc = function () {
-		return dojo.flash.comm._call(functionName, arguments);
-	};
-	dojo.flash.comm[functionName] = callFunc;
-	dojo.flash.obj.get().SetVariable("_succeeded", true);
-}, _fscommandCall:function (command, args) {
-	var plugin = dojo.flash.obj.get();
-	var functionName = args;
-	var numArgs = parseInt(plugin.GetVariable("_numArgs"));
-	var flashArgs = new Array();
-	for (var i = 0; i < numArgs; i++) {
-		var currentArg = plugin.GetVariable("_" + i);
-		flashArgs.push(currentArg);
-	}
-	var runMe;
-	if (functionName.indexOf(".") == -1) {
-		runMe = window[functionName];
-	} else {
-		runMe = eval(functionName);
-	}
-	var results = null;
-	if (!dojo.lang.isUndefined(runMe) && runMe != null) {
-		results = runMe.apply(null, flashArgs);
-	}
-	plugin.SetVariable("_returnResult", results);
-}, _fscommandReady:function () {
-	var plugin = dojo.flash.obj.get();
-	plugin.SetVariable("fscommandReady", "true");
-}, _call:function (functionName, args) {
-	var plugin = dojo.flash.obj.get();
-	plugin.SetVariable("_functionName", functionName);
-	plugin.SetVariable("_numArgs", args.length);
-	for (var i = 0; i < args.length; i++) {
-		var value = args[i];
-		value = value.replace(/\0/g, "\\0");
-		plugin.SetVariable("_" + i, value);
-	}
-	plugin.TCallLabel("/_flashRunner", "execute");
-	var results = plugin.GetVariable("_returnResult");
-	results = results.replace(/\\0/g, "\x00");
-	return results;
-}, _addExternalInterfaceCallback:function (methodName) {
-	var wrapperCall = function () {
-		var methodArgs = new Array(arguments.length);
-		for (var i = 0; i < arguments.length; i++) {
-			methodArgs[i] = arguments[i];
-		}
-		return dojo.flash.comm._execFlash(methodName, methodArgs);
-	};
-	dojo.flash.comm[methodName] = wrapperCall;
-}, _encodeData:function (data) {
-	var entityRE = /\&([^;]*)\;/g;
-	data = data.replace(entityRE, "&amp;$1;");
-	data = data.replace(/</g, "&lt;");
-	data = data.replace(/>/g, "&gt;");
-	data = data.replace("\\", "&custom_backslash;&custom_backslash;");
-	data = data.replace(/\n/g, "\\n");
-	data = data.replace(/\r/g, "\\r");
-	data = data.replace(/\f/g, "\\f");
-	data = data.replace(/\0/g, "\\0");
-	data = data.replace(/\'/g, "\\'");
-	data = data.replace(/\"/g, "\\\"");
-	return data;
-}, _decodeData:function (data) {
-	if (data == null || typeof data == "undefined") {
-		return data;
-	}
-	data = data.replace(/\&custom_lt\;/g, "<");
-	data = data.replace(/\&custom_gt\;/g, ">");
-	data = eval("\"" + data + "\"");
-	return data;
-}, _chunkArgumentData:function (value, argIndex) {
-	var plugin = dojo.flash.obj.get();
-	var numSegments = Math.ceil(value.length / 1024);
-	for (var i = 0; i < numSegments; i++) {
-		var startCut = i * 1024;
-		var endCut = i * 1024 + 1024;
-		if (i == (numSegments - 1)) {
-			endCut = i * 1024 + value.length;
-		}
-		var piece = value.substring(startCut, endCut);
-		piece = this._encodeData(piece);
-		plugin.CallFunction("<invoke name=\"chunkArgumentData\" " + "returntype=\"javascript\">" + "<arguments>" + "<string>" + piece + "</string>" + "<number>" + argIndex + "</number>" + "</arguments>" + "</invoke>");
-	}
-}, _chunkReturnData:function () {
-	var plugin = dojo.flash.obj.get();
-	var numSegments = plugin.getReturnLength();
-	var resultsArray = new Array();
-	for (var i = 0; i < numSegments; i++) {
-		var piece = plugin.CallFunction("<invoke name=\"chunkReturnData\" " + "returntype=\"javascript\">" + "<arguments>" + "<number>" + i + "</number>" + "</arguments>" + "</invoke>");
-		if (piece == "\"\"" || piece == "''") {
-			piece = "";
-		} else {
-			piece = piece.substring(1, piece.length - 1);
-		}
-		resultsArray.push(piece);
-	}
-	var results = resultsArray.join("");
-	return results;
-}, _execFlash:function (methodName, methodArgs) {
-	var plugin = dojo.flash.obj.get();
-	plugin.startExec();
-	plugin.setNumberArguments(methodArgs.length);
-	for (var i = 0; i < methodArgs.length; i++) {
-		this._chunkArgumentData(methodArgs[i], i);
-	}
-	plugin.exec(methodName);
-	var results = this._chunkReturnData();
-	results = this._decodeData(results);
-	plugin.endExec();
-	return results;
-}};
-dojo.flash.Install = function () {
-};
-dojo.flash.Install.prototype = {needed:function () {
-	if (dojo.flash.info.capable == false) {
-		return true;
-	}
-	if (dojo.render.os.mac == true && !dojo.flash.info.isVersionOrAbove(8, 0, 0)) {
-		return true;
-	}
-	if (!dojo.flash.info.isVersionOrAbove(6, 0, 0)) {
-		return true;
-	}
-	return false;
-}, install:function () {
-	dojo.flash.info.installing = true;
-	dojo.flash.installing();
-	if (dojo.flash.info.capable == false) {
-		var installObj = new dojo.flash.Embed(false);
-		installObj.write(8);
-	} else {
-		if (dojo.flash.info.isVersionOrAbove(6, 0, 65)) {
-			var installObj = new dojo.flash.Embed(false);
-			installObj.write(8, true);
-			installObj.setVisible(true);
-			installObj.center();
-		} else {
-			alert("This content requires a more recent version of the Macromedia " + " Flash Player.");
-			window.location.href = +dojo.flash.Embed.protocol() + "://www.macromedia.com/go/getflashplayer";
-		}
-	}
-}, _onInstallStatus:function (msg) {
-	if (msg == "Download.Complete") {
-		dojo.flash._initialize();
-	} else {
-		if (msg == "Download.Cancelled") {
-			alert("This content requires a more recent version of the Macromedia " + " Flash Player.");
-			window.location.href = dojo.flash.Embed.protocol() + "://www.macromedia.com/go/getflashplayer";
-		} else {
-			if (msg == "Download.Failed") {
-				alert("There was an error downloading the Flash Player update. " + "Please try again later, or visit macromedia.com to download " + "the latest version of the Flash plugin.");
-			}
-		}
-	}
-}};
-dojo.flash.info = new dojo.flash.Info();
-
+dojo.provide("dojo.flash");
+
+dojo.require("dojo.string.*");
+dojo.require("dojo.uri.*");
+
+
+/** 
+		The goal of dojo.flash is to make it easy to extend Flash's capabilities
+		into an AJAX/DHTML environment. Robust, performant, reliable 
+		JavaScript/Flash communication is harder than most realize when they
+		delve into the topic, especially if you want it
+		to work on Internet Explorer, Firefox, and Safari, and to be able to
+		push around hundreds of K of information quickly. Dojo.flash makes it
+		possible to support these platforms; you have to jump through a few
+		hoops to get its capabilites, but if you are a library writer 
+		who wants to bring Flash's storage or streaming sockets ability into
+		DHTML, for example, then dojo.flash is perfect for you.
+  
+		Dojo.flash provides an easy object for interacting with the Flash plugin. 
+		This object provides methods to determine the current version of the Flash
+		plugin (dojo.flash.info); execute Flash instance methods 
+		independent of the Flash version
+		being used (dojo.flash.comm); write out the necessary markup to 
+		dynamically insert a Flash object into the page (dojo.flash.Embed; and 
+		do dynamic installation and upgrading of the current Flash plugin in 
+		use (dojo.flash.Install).
+		
+		To use dojo.flash, you must first wait until Flash is finished loading 
+		and initializing before you attempt communication or interaction. 
+		To know when Flash is finished use dojo.event.connect:
+		
+		dojo.event.connect(dojo.flash, "loaded", myInstance, "myCallback");
+		
+		Then, while the page is still loading provide the file name
+		and the major version of Flash that will be used for Flash/JavaScript
+		communication (see "Flash Communication" below for information on the 
+		different kinds of Flash/JavaScript communication supported and how they 
+		depend on the version of Flash installed):
+		
+		dojo.flash.setSwf({flash6: "src/storage/storage_flash6.swf",
+											 flash8: "src/storage/storage_flash8.swf"});
+		
+		This will cause dojo.flash to pick the best way of communicating
+		between Flash and JavaScript based on the platform.
+		
+		If no SWF files are specified, then Flash is not initialized.
+		
+		Your Flash must use DojoExternalInterface to expose Flash methods and
+		to call JavaScript; see "Flash Communication" below for details.
+		
+		setSwf can take an optional 'visible' attribute to control whether
+		the Flash object is visible or not on the page; the default is visible:
+		
+		dojo.flash.setSwf({flash6: "src/storage/storage_flash6.swf",
+											 flash8: "src/storage/storage_flash8.swf",
+											 visible: false});
+		
+		Once finished, you can query Flash version information:
+		
+		dojo.flash.info.version
+		
+		Or can communicate with Flash methods that were exposed:
+		
+		var results = dojo.flash.comm.sayHello("Some Message");
+		
+		Only string values are currently supported for both arguments and
+		for return results. Everything will be cast to a string on both
+		the JavaScript and Flash sides.
+		
+		-------------------
+		Flash Communication
+		-------------------
+		
+		dojo.flash allows Flash/JavaScript communication in 
+		a way that can pass large amounts of data back and forth reliably and
+		very fast. The dojo.flash
+		framework encapsulates the specific way in which this communication occurs,
+		presenting a common interface to JavaScript irrespective of the underlying
+		Flash version.
+		
+		There are currently three major ways to do Flash/JavaScript communication
+		in the Flash community:
+		
+		1) Flash 6+ - Uses Flash methods, such as SetVariable and TCallLabel,
+		and the fscommand handler to do communication. Strengths: Very fast,
+		mature, and can send extremely large amounts of data; can do
+		synchronous method calls. Problems: Does not work on Safari; works on 
+		Firefox/Mac OS X only if Flash 8 plugin is installed; cryptic to work with.
+		
+		2) Flash 8+ - Uses ExternalInterface, which provides a way for Flash
+		methods to register themselves for callbacks from JavaScript, and a way
+		for Flash to call JavaScript. Strengths: Works on Safari; elegant to
+		work with; can do synchronous method calls. Problems: Extremely buggy 
+		(fails if there are new lines in the data, for example); performance
+		degrades drastically in O(n^2) time as data grows; locks up the browser while
+		it is communicating; does not work in Internet Explorer if Flash
+		object is dynamically added to page with document.writeln, DOM methods,
+		or innerHTML.
+		
+		3) Flash 6+ - Uses two seperate Flash applets, one that we 
+		create over and over, passing input data into it using the PARAM tag, 
+		which then uses a Flash LocalConnection to pass the data to the main Flash
+		applet; communication back to Flash is accomplished using a getURL
+		call with a javascript protocol handler, such as "javascript:myMethod()".
+		Strengths: the most cross browser, cross platform pre-Flash 8 method
+		of Flash communication known; works on Safari. Problems: Timing issues;
+		clunky and complicated; slow; can only send very small amounts of
+		data (several K); all method calls are asynchronous.
+		
+		dojo.flash.comm uses only the first two methods. This framework
+		was created primarily for dojo.storage, which needs to pass very large
+		amounts of data synchronously and reliably across the Flash/JavaScript
+		boundary. We use the first method, the Flash 6 method, on all platforms
+		that support it, while using the Flash 8 ExternalInterface method
+		only on Safari with some special code to help correct ExternalInterface's
+		bugs.
+		
+		Since dojo.flash needs to have two versions of the Flash
+		file it wants to generate, a Flash 6 and a Flash 8 version to gain
+		true cross-browser compatibility, several tools are provided to ease
+		development on the Flash side.
+		
+		In your Flash file, if you want to expose Flash methods that can be
+		called, use the DojoExternalInterface class to register methods. This
+		class is an exact API clone of the standard ExternalInterface class, but
+		can work in Flash 6+ browsers. Under the covers it uses the best
+		mechanism to do communication:
+		
+		class HelloWorld{
+			function HelloWorld(){
+				// Initialize the DojoExternalInterface class
+				DojoExternalInterface.initialize();
+				
+				// Expose your methods
+				DojoExternalInterface.addCallback("sayHello", this, this.sayHello);
+				
+				// Tell JavaScript that you are ready to have method calls
+				DojoExternalInterface.loaded();
+				
+				// Call some JavaScript
+				var resultsReady = function(results){
+					trace("Received the following results from JavaScript: " + results);
+				}
+				DojoExternalInterface.call("someJavaScriptMethod", resultsReady, 
+																	 someParameter);
+			}
+			
+			function sayHello(){ ... }
+			
+			static main(){ ... }
+		}
+		
+		DojoExternalInterface adds two new functions to the ExternalInterface
+		API: initialize() and loaded(). initialize() must be called before
+		any addCallback() or call() methods are run, and loaded() must be
+		called after you are finished adding your callbacks. Calling loaded()
+		will fire the dojo.flash.loaded() event, so that JavaScript can know that
+		Flash has finished loading and adding its callbacks, and can begin to
+		interact with the Flash file.
+		
+		To generate your SWF files, use the ant task
+		"buildFlash". You must have the open source Motion Twin ActionScript 
+		compiler (mtasc) installed and in your path to use the "buildFlash"
+		ant task; download and install mtasc from http://www.mtasc.org/.
+		
+		
+		
+		buildFlash usage:
+		
+		ant buildFlash -Ddojo.flash.file=../tests/flash/HelloWorld.as
+		
+		where "dojo.flash.file" is the relative path to your Flash 
+		ActionScript file.
+		
+		This will generate two SWF files, one ending in _flash6.swf and the other
+		ending in _flash8.swf in the same directory as your ActionScript method:
+		
+		HelloWorld_flash6.swf
+		HelloWorld_flash8.swf
+		
+		Initialize dojo.flash with the filename and Flash communication version to
+		use during page load; see the documentation for dojo.flash for details:
+		
+		dojo.flash.setSwf({flash6: "tests/flash/HelloWorld_flash6.swf",
+											 flash8: "tests/flash/HelloWorld_flash8.swf"});
+		
+		Now, your Flash methods can be called from JavaScript as if they are native
+		Flash methods, mirrored exactly on the JavaScript side:
+		
+		dojo.flash.comm.sayHello();
+		
+		Only Strings are supported being passed back and forth currently.
+		
+		JavaScript to Flash communication is synchronous; i.e., results are returned
+		directly from the method call:
+		
+		var results = dojo.flash.comm.sayHello();
+		
+		Flash to JavaScript communication is asynchronous due to limitations in
+		the underlying technologies; you must use a results callback to handle
+		results returned by JavaScript in your Flash AS files:
+		
+		var resultsReady = function(results){
+			trace("Received the following results from JavaScript: " + results);
+		}
+		DojoExternalInterface.call("someJavaScriptMethod", resultsReady);
+		
+		
+		
+		-------------------
+		Notes
+		-------------------
+		
+		If you have both Flash 6 and Flash 8 versions of your file:
+		
+		dojo.flash.setSwf({flash6: "tests/flash/HelloWorld_flash6.swf",
+											 flash8: "tests/flash/HelloWorld_flash8.swf"});
+											 
+		but want to force the browser to use a certain version of Flash for
+		all platforms (for testing, for example), use the djConfig
+		variable 'forceFlashComm' with the version number to force:
+		
+		var djConfig = { forceFlashComm: 6 };
+		
+		Two values are currently supported, 6 and 8, for the two styles of
+		communication described above. Just because you force dojo.flash
+		to use a particular communication style is no guarantee that it will
+		work; for example, Flash 8 communication doesn't work in Internet
+		Explorer due to bugs in Flash, and Flash 6 communication does not work
+		in Safari. It is best to let dojo.flash determine the best communication
+		mechanism, and to use the value above only for debugging the dojo.flash
+		framework itself.
+		
+		Also note that dojo.flash can currently only work with one Flash object
+		on the page; it and the API do not yet support multiple Flash objects on
+		the same page.
+		
+		We use some special tricks to get decent, linear performance
+		out of Flash 8's ExternalInterface on Safari; see the blog
+		post 
+		http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html
+		for details.
+		
+		Your code can detect whether the Flash player is installing or having
+		its version revved in two ways. First, if dojo.flash detects that
+		Flash installation needs to occur, it sets dojo.flash.info.installing
+		to true. Second, you can detect if installation is necessary with the
+		following callback:
+		
+		dojo.event.connect(dojo.flash, "installing", myInstance, "myCallback");
+		
+		You can use this callback to delay further actions that might need Flash;
+		when installation is finished the full page will be refreshed and the
+		user will be placed back on your page with Flash installed.
+		
+		Two utility methods exist if you want to add loading and installing
+		listeners without creating dependencies on dojo.event; these are
+		'addLoadingListener' and 'addInstallingListener'.
+		
+		-------------------
+		Todo/Known Issues
+		-------------------
+
+		There are several tasks I was not able to do, or did not need to fix
+		to get dojo.storage out:		
+		
+		* When using Flash 8 communication, Flash method calls to JavaScript
+		are not working properly; serialization might also be broken for certain
+		invalid characters when it is Flash invoking JavaScript methods.
+		The Flash side needs to have more sophisticated serialization/
+		deserialization mechanisms like JavaScript currently has. The
+		test_flash2.html unit tests should also be updated to have much more
+		sophisticated Flash to JavaScript unit tests, including large
+		amounts of data.
+		
+		* On Internet Explorer, after doing a basic install, the page is
+		not refreshed or does not detect that Flash is now available. The way
+		to fix this is to create a custom small Flash file that is pointed to
+		during installation; when it is finished loading, it does a callback
+		that says that Flash installation is complete on IE, and we can proceed
+		to initialize the dojo.flash subsystem.
+		
+		@author Brad Neuberg, bkn3 at columbia.edu
+*/
+
+dojo.flash = {
+	flash6_version: null,
+	flash8_version: null,
+	ready: false,
+	_visible: true,
+	_loadedListeners: new Array(),
+	_installingListeners: new Array(),
+	
+	/** Sets the SWF files and versions we are using. */
+	setSwf: function(fileInfo){
+		//dojo.debug("setSwf");
+		if(fileInfo == null || dojo.lang.isUndefined(fileInfo)){
+			return;
+		}
+		
+		if(fileInfo.flash6 != null && !dojo.lang.isUndefined(fileInfo.flash6)){
+			this.flash6_version = fileInfo.flash6;
+		}
+		
+		if(fileInfo.flash8 != null && !dojo.lang.isUndefined(fileInfo.flash8)){
+			this.flash8_version = fileInfo.flash8;
+		}
+		
+		if(!dojo.lang.isUndefined(fileInfo.visible)){
+			this._visible = fileInfo.visible;
+		}
+		
+		// initialize ourselves		
+		this._initialize();
+	},
+	
+	/** Returns whether we are using Flash 6 for communication on this platform. */
+	useFlash6: function(){
+		if(this.flash6_version == null){
+			return false;
+		}else if (this.flash6_version != null && dojo.flash.info.commVersion == 6){
+			// if we have a flash 6 version of this SWF, and this browser supports 
+			// communicating using Flash 6 features...
+			return true;
+		}else{
+			return false;
+		}
+	},
+	
+	/** Returns whether we are using Flash 8 for communication on this platform. */
+	useFlash8: function(){
+		if(this.flash8_version == null){
+			return false;
+		}else if (this.flash8_version != null && dojo.flash.info.commVersion == 8){
+			// if we have a flash 8 version of this SWF, and this browser supports
+			// communicating using Flash 8 features...
+			return true;
+		}else{
+			return false;
+		}
+	},
+	
+	/** Adds a listener to know when Flash is finished loading. 
+			Useful if you don't want a dependency on dojo.event. */
+	addLoadedListener: function(listener){
+		this._loadedListeners.push(listener);
+	},
+
+	/** Adds a listener to know if Flash is being installed. 
+			Useful if you don't want a dependency on dojo.event. */
+	addInstallingListener: function(listener){
+		this._installingListeners.push(listener);
+	},	
+	
+	/** 
+			A callback when the Flash subsystem is finished loading and can be
+			worked with. To be notified when Flash is finished loading, connect
+			your callback to this method using the following:
+			
+			dojo.event.connect(dojo.flash, "loaded", myInstance, "myCallback");
+	*/
+	loaded: function(){
+		//dojo.debug("dojo.flash.loaded");
+		dojo.flash.ready = true;
+		if(dojo.flash._loadedListeners.length > 0){
+			for(var i = 0;i < dojo.flash._loadedListeners.length; i++){
+				dojo.flash._loadedListeners[i].call(null);
+			}
+		}
+	},
+	
+	/** 
+			A callback to know if Flash is currently being installed or
+			having its version revved. To be notified if Flash is installing, connect
+			your callback to this method using the following:
+			
+			dojo.event.connect(dojo.flash, "installing", myInstance, "myCallback");
+	*/
+	installing: function(){
+	 //dojo.debug("installing");
+	 if(dojo.flash._installingListeners.length > 0){
+			for(var i = 0; i < dojo.flash._installingListeners.length; i++){
+				dojo.flash._installingListeners[i].call(null);
+			}
+		}
+	},
+	
+	/** Initializes dojo.flash. */
+	_initialize: function(){
+		//dojo.debug("dojo.flash._initialize");
+		// see if we need to rev or install Flash on this platform
+		var installer = new dojo.flash.Install();
+		dojo.flash.installer = installer;
+
+		if(installer.needed() == true){		
+			installer.install();
+		}else{
+			//dojo.debug("Writing object out");
+			// write the flash object into the page
+			dojo.flash.obj = new dojo.flash.Embed(this._visible);
+			dojo.flash.obj.write(dojo.flash.info.commVersion);
+			
+			// initialize the way we do Flash/JavaScript communication
+			dojo.flash.comm = new dojo.flash.Communicator();
+		}
+	}
+};
+
+
+/** 
+		A class that helps us determine whether Flash is available,
+		it's major and minor versions, and what Flash version features should
+		be used for Flash/JavaScript communication. Parts of this code
+		are adapted from the automatic Flash plugin detection code autogenerated 
+		by the Macromedia Flash 8 authoring environment. 
+		
+		An instance of this class can be accessed on dojo.flash.info after
+		the page is finished loading.
+		
+		This constructor must be called before the page is finished loading. 
+*/
+dojo.flash.Info = function(){
+	// Visual basic helper required to detect Flash Player ActiveX control 
+	// version information on Internet Explorer
+	if(dojo.render.html.ie){
+		document.writeln('<script language="VBScript" type="text/vbscript"\>');
+		document.writeln('Function VBGetSwfVer(i)');
+		document.writeln('  on error resume next');
+		document.writeln('  Dim swControl, swVersion');
+		document.writeln('  swVersion = 0');
+		document.writeln('  set swControl = CreateObject("ShockwaveFlash.ShockwaveFlash." + CStr(i))');
+		document.writeln('  if (IsObject(swControl)) then');
+		document.writeln('    swVersion = swControl.GetVariable("$version")');
+		document.writeln('  end if');
+		document.writeln('  VBGetSwfVer = swVersion');
+		document.writeln('End Function');
+		document.writeln('</script\>');
+	}
+	
+	this._detectVersion();
+	this._detectCommunicationVersion();
+}
+
+dojo.flash.Info.prototype = {
+	/** The full version string, such as "8r22". */
+	version: -1,
+	
+	/** 
+			The major, minor, and revisions of the plugin. For example, if the
+			plugin is 8r22, then the major version is 8, the minor version is 0,
+			and the revision is 22. 
+	*/
+	versionMajor: -1,
+	versionMinor: -1,
+	versionRevision: -1,
+	
+	/** Whether this platform has Flash already installed. */
+	capable: false,
+	
+	/** 
+			The major version number for how our Flash and JavaScript communicate.
+			This can currently be the following values:
+			6 - We use a combination of the Flash plugin methods, such as SetVariable
+			and TCallLabel, along with fscommands, to do communication.
+			8 - We use the ExternalInterface API. 
+			-1 - For some reason neither method is supported, and no communication
+			is possible. 
+	*/
+	commVersion: 6,
+	
+	/** Set if we are in the middle of a Flash installation session. */
+	installing: false,
+	
+	/** 
+			Asserts that this environment has the given major, minor, and revision
+			numbers for the Flash player. Returns true if the player is equal
+			or above the given version, false otherwise.
+			
+			Example: To test for Flash Player 7r14:
+			
+			dojo.flash.info.isVersionOrAbove(7, 0, 14)
+	*/
+	isVersionOrAbove: function(reqMajorVer, reqMinorVer, reqVer){
+		// make the revision a decimal (i.e. transform revision 14 into
+		// 0.14
+		reqVer = parseFloat("." + reqVer);
+		
+		if(this.versionMajor >= reqMajorVer && this.versionMinor >= reqMinorVer
+			 && this.versionRevision >= reqVer){
+			return true;
+		}else{
+			return false;
+		}
+	},
+	
+	_detectVersion: function(){
+		var versionStr;
+		
+		// loop backwards through the versions until we find the newest version	
+		for(var testVersion = 25; testVersion > 0; testVersion--){
+			if(dojo.render.html.ie){
+				versionStr = VBGetSwfVer(testVersion);
+			}else{
+				versionStr = this._JSFlashInfo(testVersion);		
+			}
+				
+			if(versionStr == -1 ){
+				this.capable = false; 
+				return;
+			}else if(versionStr != 0){
+				var versionArray;
+				if(dojo.render.html.ie){
+					var tempArray = versionStr.split(" ");
+					var tempString = tempArray[1];
+					versionArray = tempString.split(",");
+				}else{
+					versionArray = versionStr.split(".");
+				}
+					
+				this.versionMajor = versionArray[0];
+				this.versionMinor = versionArray[1];
+				this.versionRevision = versionArray[2];
+				
+				// 7.0r24 == 7.24
+				var versionString = this.versionMajor + "." + this.versionRevision;
+				this.version = parseFloat(versionString);
+				
+				this.capable = true;
+				
+				break;
+			}
+		}
+	},
+	
+	/** 
+			JavaScript helper required to detect Flash Player PlugIn version 
+			information. Internet Explorer uses a corresponding Visual Basic
+			version to interact with the Flash ActiveX control. 
+	*/
+	_JSFlashInfo: function(testVersion){
+		// NS/Opera version >= 3 check for Flash plugin in plugin array
+		if(navigator.plugins != null && navigator.plugins.length > 0){
+			if(navigator.plugins["Shockwave Flash 2.0"] || 
+				 navigator.plugins["Shockwave Flash"]){
+				var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
+				var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
+				var descArray = flashDescription.split(" ");
+				var tempArrayMajor = descArray[2].split(".");
+				var versionMajor = tempArrayMajor[0];
+				var versionMinor = tempArrayMajor[1];
+				if(descArray[3] != ""){
+					var tempArrayMinor = descArray[3].split("r");
+				}else{
+					var tempArrayMinor = descArray[4].split("r");
+				}
+				var versionRevision = tempArrayMinor[1] > 0 ? tempArrayMinor[1] : 0;
+				var version = versionMajor + "." + versionMinor + "." 
+											+ versionRevision;
+											
+				return version;
+			}
+		}
+		
+		return -1;
+	},
+	
+	/** 
+			Detects the mechanisms that should be used for Flash/JavaScript 
+			communication, setting 'commVersion' to either 6 or 8. If the value is
+			6, we use Flash Plugin 6+ features, such as GetVariable, TCallLabel,
+			and fscommand, to do Flash/JavaScript communication; if the value is
+			8, we use the ExternalInterface API for communication. 
+	*/
+	_detectCommunicationVersion: function(){
+		if(this.capable == false){
+			this.commVersion = null;
+			return;
+		}
+		
+		// detect if the user has over-ridden the default flash version
+		if (typeof djConfig["forceFlashComm"] != "undefined" &&
+				typeof djConfig["forceFlashComm"] != null){
+			this.commVersion = djConfig["forceFlashComm"];
+			return;
+		}
+		
+		// we prefer Flash 6 features over Flash 8, because they are much faster
+		// and much less buggy
+		
+		// at this point, we don't have a flash file to detect features on,
+		// so we need to instead look at the browser environment we are in
+		if(dojo.render.html.safari == true || dojo.render.html.opera == true){
+			this.commVersion = 8;
+		}else{
+			this.commVersion = 6;
+		}
+	}
+};
+
+/** A class that is used to write out the Flash object into the page. */
+dojo.flash.Embed = function(visible){
+	this._visible = visible;
+}
+
+dojo.flash.Embed.prototype = {
+	/** 
+			The width of this Flash applet. The default is the minimal width
+			necessary to show the Flash settings dialog. 
+	*/
+	width: 215,
+	
+	/** 
+			The height of this Flash applet. The default is the minimal height
+			necessary to show the Flash settings dialog. 
+	*/
+	height: 138,
+	
+	/** The id of the Flash object. */
+	id: "flashObject",
+	
+	/** Controls whether this is a visible Flash applet or not. */
+	_visible: true,
+			
+	/** 
+			Writes the Flash into the page. This must be called before the page
+			is finished loading. 
+			@param flashVer The Flash version to write.
+			@param doExpressInstall Whether to write out Express Install
+			information. Optional value; defaults to false.
+	*/
+	write: function(flashVer, doExpressInstall){
+		//dojo.debug("write");
+		if(dojo.lang.isUndefined(doExpressInstall)){
+			doExpressInstall = false;
+		}
+		
+		// determine our container div's styling
+		var containerStyle = new dojo.string.Builder();
+		containerStyle.append("width: " + this.width + "px; ");
+		containerStyle.append("height: " + this.height + "px; ");
+		if(this._visible == false){
+			containerStyle.append("position: absolute; ");
+			containerStyle.append("z-index: 10000; ");
+			containerStyle.append("top: -1000px; ");
+			containerStyle.append("left: -1000px; ");
+		}
+		containerStyle = containerStyle.toString();
+
+		// figure out the SWF file to get and how to write out the correct HTML
+		// for this Flash version
+		var objectHTML;
+		var swfloc;
+		// Flash 6
+		if(flashVer == 6){
+			swfloc = dojo.flash.flash6_version;
+			var dojoPath = djConfig.baseRelativePath;
+			swfloc = swfloc + "?baseRelativePath=" + escape(dojoPath);
+			
+			objectHTML = 
+						  '<embed id="' + this.id + '" src="' + swfloc + '" '
+						+ '    quality="high" bgcolor="#ffffff" '
+						+ '    width="' + this.width + '" height="' + this.height + '" '
+						+ '    name="' + this.id + '" '
+						+ '    align="middle" allowScriptAccess="sameDomain" '
+						+ '    type="application/x-shockwave-flash" swLiveConnect="true" '
+						+ '    pluginspage="http://www.macromedia.com/go/getflashplayer">';
+		}else{ // Flash 8
+			swfloc = dojo.flash.flash8_version;
+			var swflocObject = swfloc;
+			var swflocEmbed = swfloc;
+			var dojoPath = djConfig.baseRelativePath;
+			if(doExpressInstall){
+				// the location to redirect to after installing
+				var redirectURL = escape(window.location);
+				document.title = document.title.slice(0, 47) + " - Flash Player Installation";
+				var docTitle = escape(document.title);
+				swflocObject += "?MMredirectURL=" + redirectURL
+				                + "&MMplayerType=ActiveX"
+				                + "&MMdoctitle=" + docTitle
+								+ "&baseRelativePath=" + escape(dojoPath);
+				swflocEmbed += "?MMredirectURL=" + redirectURL 
+								+ "&MMplayerType=PlugIn"
+								+ "&baseRelativePath=" + escape(dojoPath);
+			}
+			
+			objectHTML =
+				'<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" '
+				  + 'codebase="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0" '
+				  + 'width="' + this.width + '" '
+				  + 'height="' + this.height + '" '
+				  + 'id="' + this.id + '" '
+				  + 'align="middle"> '
+				  + '<param name="allowScriptAccess" value="sameDomain" /> '
+				  + '<param name="movie" value="' + swflocObject + '" /> '
+				  + '<param name="quality" value="high" /> '
+				  + '<param name="bgcolor" value="#ffffff" /> '
+				  + '<embed src="' + swflocEmbed + '" '
+				  + 'quality="high" '
+				  + 'bgcolor="#ffffff" '
+				  + 'width="' + this.width + '" '
+				  + 'height="' + this.height + '" '
+				  + 'id="' + this.id + '" '
+				  + 'name="' + this.id + '" '
+				  + 'swLiveConnect="true" '
+				  + 'align="middle" '
+				  + 'allowScriptAccess="sameDomain" '
+				  + 'type="application/x-shockwave-flash" '+ "&baseRelativePath=" + escape(dojoPath);
+				  + 'pluginspage="http://www.macromedia.com/go/getflashplayer" />'
+				+ '</object>';
+		}
+
+		// now write everything out
+		objectHTML = '<div id="' + this.id + 'Container" style="' + containerStyle + '"> '
+						+ objectHTML
+					 + '</div>';
+		document.writeln(objectHTML);
+	},  
+	
+	/** Gets the Flash object DOM node. */
+	get: function(){
+		//return (dojo.render.html.ie) ? window[this.id] : document[this.id];
+		
+		// more robust way to get Flash object; version above can break
+		// communication on IE sometimes
+		return document.getElementById(this.id);
+	},
+	
+	/** Sets the visibility of this Flash object. */
+	setVisible: function(visible){
+		var container = dojo.byId(this.id + "Container");
+		if(visible == true){
+			container.style.visibility = "visible";
+		}else{
+			container.style.position = "absolute";
+			container.style.x = "-1000px";
+			container.style.y = "-1000px";
+			container.style.visibility = "hidden";
+		}
+	},
+	
+	/** Centers the flash applet on the page. */
+	center: function(){
+		// FIXME: replace this with Dojo's centering code rather than our own
+		// We want to center the Flash applet vertically and horizontally
+		var elementWidth = this.width;
+		var elementHeight = this.height;
+    
+		// get the browser width and height; the code below
+		// works in IE and Firefox in compatibility, non-strict
+		// mode
+		var browserWidth = document.body.clientWidth;
+		var browserHeight = document.body.clientHeight;
+    
+		// in Firefox if we are in standards compliant mode
+		// (with a strict doctype), then the browser width
+		// and height have to be computed from the root level
+		// HTML element not the BODY element
+		if(!dojo.render.html.ie && document.compatMode == "CSS1Compat"){
+			browserWidth = document.body.parentNode.clientWidth;
+			browserHeight = document.body.parentNode.clientHeight;
+		}else if(dojo.render.html.ie && document.compatMode == "CSS1Compat"){
+			// IE 6 in standards compliant mode has to be calculated
+			// differently
+			browserWidth = document.documentElement.clientWidth;
+			browserHeight = document.documentElement.clientHeight;
+		}else if(dojo.render.html.safari){ // Safari works different
+			browserHeight = self.innerHeight;
+		}
+    
+		// get where we are scrolled to in the document
+		// the code below works in FireFox
+		var scrolledByWidth = window.scrollX;
+		var scrolledByHeight = window.scrollY;
+		// compute these values differently for IE;
+		// IE has two possibilities; it is either in standards
+		// compatibility mode or it is not
+		if(typeof scrolledByWidth == "undefined"){
+			if(document.compatMode == "CSS1Compat"){ // standards mode
+				scrolledByWidth = document.documentElement.scrollLeft;
+				scrolledByHeight = document.documentElement.scrollTop;
+			}else{ // Pre IE6 non-standards mode
+				scrolledByWidth = document.body.scrollLeft;
+				scrolledByHeight = document.body.scrollTop;
+			}
+		}
+
+		// compute the centered position    
+		var x = scrolledByWidth + (browserWidth - elementWidth) / 2;
+		var y = scrolledByHeight + (browserHeight - elementHeight) / 2; 
+
+		// set the centered position
+		var container = dojo.byId(this.id + "Container");
+		container.style.top = y + "px";
+		container.style.left = x + "px";
+	}
+};
+
+
+/** 
+		A class that is used to communicate between Flash and JavaScript in 
+		a way that can pass large amounts of data back and forth reliably,
+		very fast, and with synchronous method calls. This class encapsulates the 
+		specific way in which this communication occurs,
+		presenting a common interface to JavaScript irrespective of the underlying
+		Flash version.
+*/
+dojo.flash.Communicator = function(){
+	if(dojo.flash.useFlash6()){
+		this._writeFlash6();
+	}else if (dojo.flash.useFlash8()){
+		this._writeFlash8();
+	}
+}
+
+dojo.flash.Communicator.prototype = {
+	_writeFlash6: function(){
+		var id = dojo.flash.obj.id;
+		
+		// global function needed for Flash 6 callback;
+		// we write it out as a script tag because the VBScript hook for IE
+		// callbacks does not work properly if this function is evalled() from
+		// within the Dojo system
+		document.writeln('<script language="JavaScript">');
+		document.writeln('  function ' + id + '_DoFSCommand(command, args){ ');
+		document.writeln('    dojo.flash.comm._handleFSCommand(command, args); ');
+		document.writeln('}');
+		document.writeln('</script>');
+		
+		// hook for Internet Explorer to receive FSCommands from Flash
+		if(dojo.render.html.ie){
+			document.writeln('<SCRIPT LANGUAGE=VBScript\> ');
+			document.writeln('on error resume next ');
+			document.writeln('Sub ' + id + '_FSCommand(ByVal command, ByVal args)');
+			document.writeln(' call ' + id + '_DoFSCommand(command, args)');
+			document.writeln('end sub');
+			document.writeln('</SCRIPT\> ');
+		}
+	},
+	
+	_writeFlash8: function(){
+		// nothing needs to be written out for Flash 8 communication; 
+		// happens automatically
+	},
+	
+	/** Flash 6 communication. */
+	
+	/** Handles fscommand's from Flash to JavaScript. Flash 6 communication. */
+	_handleFSCommand: function(command, args){
+		//dojo.debug("fscommand, command="+command+", args="+args);
+		// Flash 8 on Mac/Firefox precedes all commands with the string "FSCommand:";
+		// strip it off if it is present
+		if(command != null && !dojo.lang.isUndefined(command)
+			&& /^FSCommand:(.*)/.test(command) == true){
+			command = command.match(/^FSCommand:(.*)/)[1];
+		}
+		 
+		if(command == "addCallback"){ // add Flash method for JavaScript callback
+			this._fscommandAddCallback(command, args);
+		}else if(command == "call"){ // Flash to JavaScript method call
+			this._fscommandCall(command, args);
+		}else if(command == "fscommandReady"){ // see if fscommands are ready
+			this._fscommandReady();
+		}
+	},
+	
+	/** Handles registering a callable Flash function. Flash 6 communication. */
+	_fscommandAddCallback: function(command, args){
+		var functionName = args;
+			
+		// do a trick, where we link this function name to our wrapper
+		// function, _call, that does the actual JavaScript to Flash call
+		var callFunc = function(){
+			return dojo.flash.comm._call(functionName, arguments);
+		};			
+		dojo.flash.comm[functionName] = callFunc;
+		
+		// indicate that the call was successful
+		dojo.flash.obj.get().SetVariable("_succeeded", true);
+	},
+	
+	/** Handles Flash calling a JavaScript function. Flash 6 communication. */
+	_fscommandCall: function(command, args){
+		var plugin = dojo.flash.obj.get();
+		var functionName = args;
+		
+		// get the number of arguments to this method call and build them up
+		var numArgs = parseInt(plugin.GetVariable("_numArgs"));
+		var flashArgs = new Array();
+		for(var i = 0; i < numArgs; i++){
+			var currentArg = plugin.GetVariable("_" + i);
+			flashArgs.push(currentArg);
+		}
+		
+		// get the function instance; we technically support more capabilities
+		// than ExternalInterface, which can only call global functions; if
+		// the method name has a dot in it, such as "dojo.flash.loaded", we
+		// eval it so that the method gets run against an instance
+		var runMe;
+		if(functionName.indexOf(".") == -1){ // global function
+			runMe = window[functionName];
+		}else{
+			// instance function
+			runMe = eval(functionName);
+		}
+		
+		// make the call and get the results
+		var results = null;
+		if(!dojo.lang.isUndefined(runMe) && runMe != null){
+			results = runMe.apply(null, flashArgs);
+		}
+		
+		// return the results to flash
+		plugin.SetVariable("_returnResult", results);
+	},
+	
+	/** Reports that fscommands are ready to run if executed from Flash. */
+	_fscommandReady: function(){
+		var plugin = dojo.flash.obj.get();
+		plugin.SetVariable("fscommandReady", "true");
+	},
+	
+	/** 
+			The actual function that will execute a JavaScript to Flash call; used
+			by the Flash 6 communication method. 
+	*/
+	_call: function(functionName, args){
+		// we do JavaScript to Flash method calls by setting a Flash variable
+		// "_functionName" with the function name; "_numArgs" with the number
+		// of arguments; and "_0", "_1", etc for each numbered argument. Flash
+		// reads these, executes the function call, and returns the result
+		// in "_returnResult"
+		var plugin = dojo.flash.obj.get();
+		plugin.SetVariable("_functionName", functionName);
+		plugin.SetVariable("_numArgs", args.length);
+		for(var i = 0; i < args.length; i++){
+			// unlike Flash 8's ExternalInterface, Flash 6 has no problem with
+			// any special characters _except_ for the null character \0; double
+			// encode this so the Flash side never sees it, but we can get it 
+			// back if the value comes back to JavaScript
+			var value = args[i];
+			value = value.replace(/\0/g, "\\0");
+			
+			plugin.SetVariable("_" + i, value);
+		}
+		
+		// now tell Flash to execute this method using the Flash Runner
+		plugin.TCallLabel("/_flashRunner", "execute");
+		
+		// get the results
+		var results = plugin.GetVariable("_returnResult");
+		
+		// we double encoded all null characters as //0 because Flash breaks
+		// if they are present; turn the //0 back into /0
+		results = results.replace(/\\0/g, "\0");
+		
+		return results;
+	},
+	
+	/** Flash 8 communication. */
+	
+	/** 
+			Registers the existence of a Flash method that we can call with
+			JavaScript, using Flash 8's ExternalInterface. 
+	*/
+	_addExternalInterfaceCallback: function(methodName){
+		var wrapperCall = function(){
+			// some browsers don't like us changing values in the 'arguments' array, so
+			// make a fresh copy of it
+			var methodArgs = new Array(arguments.length);
+			for(var i = 0; i < arguments.length; i++){
+				methodArgs[i] = arguments[i];
+			}
+			return dojo.flash.comm._execFlash(methodName, methodArgs);
+		};
+		
+		dojo.flash.comm[methodName] = wrapperCall;
+	},
+	
+	/** 
+			Encodes our data to get around ExternalInterface bugs.
+			Flash 8 communication.
+	*/
+	_encodeData: function(data){
+		// double encode all entity values, or they will be mis-decoded
+		// by Flash when returned
+		var entityRE = /\&([^;]*)\;/g;
+		data = data.replace(entityRE, "&amp;$1;");
+		
+		// entity encode XML-ish characters, or Flash's broken XML serializer
+		// breaks
+		data = data.replace(/</g, "&lt;");
+		data = data.replace(/>/g, "&gt;");
+		
+		// transforming \ into \\ doesn't work; just use a custom encoding
+		data = data.replace("\\", "&custom_backslash;&custom_backslash;");
+		
+		data = data.replace(/\n/g, "\\n");
+		data = data.replace(/\r/g, "\\r");
+		data = data.replace(/\f/g, "\\f");
+		data = data.replace(/\0/g, "\\0"); // null character
+		data = data.replace(/\'/g, "\\\'");
+		data = data.replace(/\"/g, '\\\"');
+		
+		return data;
+	},
+	
+	/** 
+			Decodes our data to get around ExternalInterface bugs.
+			Flash 8 communication.
+	*/
+	_decodeData: function(data){
+		if(data == null || typeof data == "undefined"){
+			return data;
+		}
+		
+		// certain XMLish characters break Flash's wire serialization for
+		// ExternalInterface; these are encoded on the 
+		// DojoExternalInterface side into a custom encoding, rather than
+		// the standard entity encoding, because otherwise we won't be able to
+		// differentiate between our own encoding and any entity characters
+		// that are being used in the string itself
+		data = data.replace(/\&custom_lt\;/g, "<");
+		data = data.replace(/\&custom_gt\;/g, ">");
+		
+		// Unfortunately, Flash returns us our String with special characters
+		// like newlines broken into seperate characters. So if \n represents
+		// a new line, Flash returns it as "\" and "n". This means the character
+		// is _not_ a newline. This forces us to eval() the string to cause
+		// escaped characters to turn into their real special character values.
+		data = eval('"' + data + '"');
+		
+		return data;
+	},
+	
+	/** 
+			Sends our method arguments over to Flash in chunks in order to
+			have ExternalInterface's performance not be O(n^2).
+			Flash 8 communication.
+	*/
+	_chunkArgumentData: function(value, argIndex){
+		var plugin = dojo.flash.obj.get();
+		
+		// cut up the string into pieces, and push over each piece one
+		// at a time
+		var numSegments = Math.ceil(value.length / 1024);
+		for(var i = 0; i < numSegments; i++){
+			var startCut = i * 1024;
+			var endCut = i * 1024 + 1024;
+			if(i == (numSegments - 1)){
+				endCut = i * 1024 + value.length;
+			}
+			
+			var piece = value.substring(startCut, endCut);
+			
+			// encode each piece seperately, rather than the entire
+			// argument data, because ocassionally a special 
+			// character, such as an entity like &foobar;, will fall between
+			// piece boundaries, and we _don't_ want to encode that value if
+			// it falls between boundaries, or else we will end up with incorrect
+			// data when we patch the pieces back together on the other side
+			piece = this._encodeData(piece);
+			
+			// directly use the underlying CallFunction method used by
+			// ExternalInterface, which is vastly faster for large strings
+			// and lets us bypass some Flash serialization bugs
+			plugin.CallFunction('<invoke name="chunkArgumentData" '
+														+ 'returntype="javascript">'
+														+ '<arguments>'
+														+ '<string>' + piece + '</string>'
+														+ '<number>' + argIndex + '</number>'
+														+ '</arguments>'
+														+ '</invoke>');
+		}
+	},
+	
+	/** 
+			Gets our method return data in chunks for better performance.
+			Flash 8 communication.
+	*/
+	_chunkReturnData: function(){
+		var plugin = dojo.flash.obj.get();
+		
+		var numSegments = plugin.getReturnLength();
+		var resultsArray = new Array();
+		for(var i = 0; i < numSegments; i++){
+			// directly use the underlying CallFunction method used by
+			// ExternalInterface, which is vastly faster for large strings
+			var piece = 
+					plugin.CallFunction('<invoke name="chunkReturnData" '
+															+ 'returntype="javascript">'
+															+ '<arguments>'
+															+ '<number>' + i + '</number>'
+															+ '</arguments>'
+															+ '</invoke>');
+															
+			// remove any leading or trailing JavaScript delimiters, which surround
+			// our String when it comes back from Flash since we bypass Flash's
+			// deserialization routines by directly calling CallFunction on the
+			// plugin
+			if(piece == '""' || piece == "''"){
+				piece = "";
+			}else{
+				piece = piece.substring(1, piece.length-1);
+			}
+		
+			resultsArray.push(piece);
+		}
+		var results = resultsArray.join("");
+		
+		return results;
+	},
+	
+	/** 
+			Executes a Flash method; called from the JavaScript wrapper proxy we
+			create on dojo.flash.comm.
+			Flash 8 communication.
+	*/
+	_execFlash: function(methodName, methodArgs){
+		var plugin = dojo.flash.obj.get();
+				
+		// begin Flash method execution
+		plugin.startExec();
+		
+		// set the number of arguments
+		plugin.setNumberArguments(methodArgs.length);
+		
+		// chunk and send over each argument
+		for(var i = 0; i < methodArgs.length; i++){
+			this._chunkArgumentData(methodArgs[i], i);
+		}
+		
+		// execute the method
+		plugin.exec(methodName);
+														
+		// get the return result
+		var results = this._chunkReturnData();
+		
+		// decode the results
+		results = this._decodeData(results);
+		
+		// reset everything
+		plugin.endExec();
+		
+		return results;
+
+	}
+}
+
+/** 
+		Figures out the best way to automatically install the Flash plugin
+		for this browser and platform. Also determines if installation or
+		revving of the current plugin is needed on this platform.
+*/
+dojo.flash.Install = function(){
+}
+
+dojo.flash.Install.prototype = {
+	/** 
+			Determines if installation or revving of the current plugin is 
+			needed. 
+	*/
+	needed: function(){
+		// do we even have flash?
+		if(dojo.flash.info.capable == false){
+			return true;
+		}
+
+		// are we on the Mac? Safari needs Flash version 8 to do Flash 8
+		// communication, while Firefox/Mac needs Flash 8 to fix bugs it has
+		// with Flash 6 communication
+		if(dojo.render.os.mac == true && !dojo.flash.info.isVersionOrAbove(8, 0, 0)){
+			return true;
+		}
+
+		// other platforms need at least Flash 6 or above
+		if(!dojo.flash.info.isVersionOrAbove(6, 0, 0)){
+			return true;
+		}
+
+		// otherwise we don't need installation
+		return false;
+	},
+
+	/** Performs installation or revving of the Flash plugin. */
+	install: function(){
+		//dojo.debug("install");
+		// indicate that we are installing
+		dojo.flash.info.installing = true;
+		dojo.flash.installing();
+		
+		if(dojo.flash.info.capable == false){ // we have no Flash at all
+			//dojo.debug("Completely new install");
+			// write out a simple Flash object to force the browser to prompt
+			// the user to install things
+			var installObj = new dojo.flash.Embed(false);
+			installObj.write(8); // write out HTML for Flash 8 version+
+		}else if(dojo.flash.info.isVersionOrAbove(6, 0, 65)){ // Express Install
+			//dojo.debug("Express install");
+			var installObj = new dojo.flash.Embed(false);
+			installObj.write(8, true); // write out HTML for Flash 8 version+
+			installObj.setVisible(true);
+			installObj.center();
+		}else{ // older Flash install than version 6r65
+			alert("This content requires a more recent version of the Macromedia "
+						+" Flash Player.");
+			window.location.href = "http://www.macromedia.com/go/getflashplayer";
+		}
+	},
+	
+	/** 
+			Called when the Express Install is either finished, failed, or was
+			rejected by the user.
+	*/
+	_onInstallStatus: function(msg){
+		if (msg == "Download.Complete"){
+			// Installation is complete.
+			dojo.flash._initialize();
+		}else if(msg == "Download.Cancelled"){
+			alert("This content requires a more recent version of the Macromedia "
+						+" Flash Player.");
+			window.location.href = "http://www.macromedia.com/go/getflashplayer";
+		}else if (msg == "Download.Failed"){
+			// The end user failed to download the installer due to a network failure
+			alert("There was an error downloading the Flash Player update. "
+						+ "Please try again later, or visit macromedia.com to download "
+						+ "the latest version of the Flash plugin.");
+		}	
+	}
+}
+
+// find out if Flash is installed
+dojo.flash.info = new dojo.flash.Info();
+
+// vim:ts=4:noet:tw=0:

Added: tags/parley-0.53/root/static/magic/src/fx/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/fx/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/fx/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.kwCompoundRequire({
+	browser: ["dojo.fx.html"],
+	dashboard: ["dojo.fx.html"]
+});
+dojo.provide("dojo.fx.*");

Added: tags/parley-0.53/root/static/magic/src/fx/html.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/fx/html.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/fx/html.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,573 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.fx.html");
+
+dojo.require("dojo.style");
+dojo.require("dojo.math.curves");
+dojo.require("dojo.lang.func");
+dojo.require("dojo.animation");
+dojo.require("dojo.event.*");
+dojo.require("dojo.graphics.color");
+
+dojo.deprecated("dojo.fx.html", "use dojo.lfx.html instead", "0.4");
+
+dojo.fx.duration = 300;
+
+dojo.fx.html._makeFadeable = function(node){
+	if(dojo.render.html.ie){
+		// only set the zoom if the "tickle" value would be the same as the
+		// default
+		if( (node.style.zoom.length == 0) &&
+			(dojo.style.getStyle(node, "zoom") == "normal") ){
+			// make sure the node "hasLayout"
+			// NOTE: this has been tested with larger and smaller user-set text
+			// sizes and works fine
+			node.style.zoom = "1";
+			// node.style.zoom = "normal";
+		}
+		// don't set the width to auto if it didn't already cascade that way.
+		// We don't want to f anyones designs
+		if(	(node.style.width.length == 0) &&
+			(dojo.style.getStyle(node, "width") == "auto") ){
+			node.style.width = "auto";
+		}
+	}
+}
+
+dojo.fx.html.fadeOut = function(node, duration, callback, dontPlay) {
+	return dojo.fx.html.fade(node, duration, dojo.style.getOpacity(node), 0, callback, dontPlay);
+};
+
+dojo.fx.html.fadeIn = function(node, duration, callback, dontPlay) {
+	return dojo.fx.html.fade(node, duration, dojo.style.getOpacity(node), 1, callback, dontPlay);
+};
+
+dojo.fx.html.fadeHide = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	if(!duration) { duration = 150; } // why not have a default?
+	return dojo.fx.html.fadeOut(node, duration, function(node) {
+		node.style.display = "none";
+		if(typeof callback == "function") { callback(node); }
+	});
+};
+
+dojo.fx.html.fadeShow = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	if(!duration) { duration = 150; } // why not have a default?
+	node.style.display = "block";
+	return dojo.fx.html.fade(node, duration, 0, 1, callback, dontPlay);
+};
+
+dojo.fx.html.fade = function(node, duration, startOpac, endOpac, callback, dontPlay) {
+	node = dojo.byId(node);
+	dojo.fx.html._makeFadeable(node);
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line([startOpac],[endOpac]),
+		duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, "onAnimate", function(e) {
+		dojo.style.setOpacity(node, e.x);
+	});
+	if(callback) {
+		dojo.event.connect(anim, "onEnd", function(e) {
+			callback(node, anim);
+		});
+	}
+	if(!dontPlay) { anim.play(true); }
+	return anim;
+};
+
+dojo.fx.html.slideTo = function(node, duration, endCoords, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endCoords;
+		endCoords = tmp;
+	}
+	node = dojo.byId(node);
+
+	var top = node.offsetTop;
+	var left = node.offsetLeft;
+	var pos = dojo.style.getComputedStyle(node, 'position');
+
+	if (pos == 'relative' || pos == 'static') {
+		top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
+		left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
+	}
+
+	return dojo.fx.html.slide(node, duration, [left, top],
+		endCoords, callback, dontPlay);
+};
+
+dojo.fx.html.slideBy = function(node, duration, coords, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = coords;
+		coords = tmp;
+	}
+	node = dojo.byId(node);
+
+	var top = node.offsetTop;
+	var left = node.offsetLeft;
+	var pos = dojo.style.getComputedStyle(node, 'position');
+
+	if (pos == 'relative' || pos == 'static') {
+		top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
+		left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
+	}
+
+	return dojo.fx.html.slideTo(node, duration, [left+coords[0], top+coords[1]],
+		callback, dontPlay);
+};
+
+dojo.fx.html.slide = function(node, duration, startCoords, endCoords, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endCoords;
+		endCoords = startCoords;
+		startCoords = tmp;
+	}
+	node = dojo.byId(node);
+
+	if (dojo.style.getComputedStyle(node, 'position') == 'static') {
+		node.style.position = 'relative';
+	}
+
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startCoords, endCoords),
+		duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, "onAnimate", function(e) {
+		with( node.style ) {
+			left = e.x + "px";
+			top = e.y + "px";
+		}
+	});
+	if(callback) {
+		dojo.event.connect(anim, "onEnd", function(e) {
+			callback(node, anim);
+		});
+	}
+	if(!dontPlay) { anim.play(true); }
+	return anim;
+};
+
+// Fade from startColor to the node's background color
+dojo.fx.html.colorFadeIn = function(node, duration, startColor, delay, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = startColor;
+		startColor = tmp;
+	}
+	node = dojo.byId(node);
+	var color = dojo.style.getBackgroundColor(node);
+	var bg = dojo.style.getStyle(node, "background-color").toLowerCase();
+	var wasTransparent = bg == "transparent" || bg == "rgba(0, 0, 0, 0)";
+	while(color.length > 3) { color.pop(); }
+
+	var rgb = new dojo.graphics.color.Color(startColor).toRgb();
+	var anim = dojo.fx.html.colorFade(node, duration||dojo.fx.duration, startColor, color, callback, true);
+	dojo.event.connect(anim, "onEnd", function(e) {
+		if( wasTransparent ) {
+			node.style.backgroundColor = "transparent";
+		}
+	});
+	if( delay > 0 ) {
+		node.style.backgroundColor = "rgb(" + rgb.join(",") + ")";
+		if(!dontPlay) { setTimeout(function(){anim.play(true)}, delay); }
+	} else {
+		if(!dontPlay) { anim.play(true); }
+	}
+	return anim;
+};
+// alias for (probably?) common use/terminology
+dojo.fx.html.highlight = dojo.fx.html.colorFadeIn;
+dojo.fx.html.colorFadeFrom = dojo.fx.html.colorFadeIn;
+
+// Fade from node's background color to endColor
+dojo.fx.html.colorFadeOut = function(node, duration, endColor, delay, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endColor;
+		endColor = tmp;
+	}
+	node = dojo.byId(node);
+	var color = new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node)).toRgb();
+
+	var rgb = new dojo.graphics.color.Color(endColor).toRgb();
+	var anim = dojo.fx.html.colorFade(node, duration||dojo.fx.duration, color, rgb, callback, delay > 0 || dontPlay);
+	if( delay > 0 ) {
+		node.style.backgroundColor = "rgb(" + color.join(",") + ")";
+		if(!dontPlay) { setTimeout(function(){anim.play(true)}, delay); }
+	}
+	return anim;
+};
+// FIXME: not sure which name is better. an alias here may be bad.
+dojo.fx.html.unhighlight = dojo.fx.html.colorFadeOut;
+dojo.fx.html.colorFadeTo = dojo.fx.html.colorFadeOut;
+
+// Fade node background from startColor to endColor
+dojo.fx.html.colorFade = function(node, duration, startColor, endColor, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endColor;
+		endColor = startColor;
+		startColor = tmp;
+	}
+	node = dojo.byId(node);
+	var startRgb = new dojo.graphics.color.Color(startColor).toRgb();
+	var endRgb = new dojo.graphics.color.Color(endColor).toRgb();
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startRgb, endRgb),
+		duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, "onAnimate", function(e) {
+		node.style.backgroundColor = "rgb(" + e.coordsAsInts().join(",") + ")";
+	});
+	if(callback) {
+		dojo.event.connect(anim, "onEnd", function(e) {
+			callback(node, anim);
+		});
+	}
+	if( !dontPlay ) { anim.play(true); }
+	return anim;
+};
+
+dojo.fx.html.wipeIn = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	var overflow = dojo.style.getStyle(node, "overflow");
+	if(overflow == "visible") {
+		node.style.overflow = "hidden";
+	}
+	node.style.height = 0;
+	dojo.style.show(node);
+	var anim = dojo.fx.html.wipe(node, duration, 0, node.scrollHeight, null, true);
+	dojo.event.connect(anim, "onEnd", function() {
+		node.style.overflow = overflow;
+		node.style.visibility = "";
+		node.style.height = "auto";
+		if(callback) { callback(node, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+}
+
+dojo.fx.html.wipeOut = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	var overflow = dojo.style.getStyle(node, "overflow");
+	if(overflow == "visible") {
+		node.style.overflow = "hidden";
+	}
+	var anim = dojo.fx.html.wipe(node, duration, node.offsetHeight, 0, null, true);
+	dojo.event.connect(anim, "onEnd", function() {
+		dojo.style.hide(node);
+		node.style.visibility = "hidden";
+		node.style.overflow = overflow;
+		if(callback) { callback(node, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+}
+
+dojo.fx.html.wipe = function(node, duration, startHeight, endHeight, callback, dontPlay) {
+	node = dojo.byId(node);
+	var anim = new dojo.animation.Animation([[startHeight], [endHeight]], duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, "onAnimate", function(e) {
+		node.style.height = e.x + "px";
+	});
+	dojo.event.connect(anim, "onEnd", function() {
+		if(callback) { callback(node, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+}
+
+dojo.fx.html.wiper = function(node, controlNode) {
+	this.node = dojo.byId(node);
+	if(controlNode) {
+		dojo.event.connect(dojo.byId(controlNode), "onclick", this, "toggle");
+	}
+}
+dojo.lang.extend(dojo.fx.html.wiper, {
+	duration: dojo.fx.duration,
+	_anim: null,
+
+	toggle: function() {
+		if(!this._anim) {
+			var type = "wipe" + (dojo.style.isVisible(this.node) ? "Out" : "In");
+			this._anim = dojo.fx[type](this.node, this.duration, dojo.lang.hitch(this, "_callback"));
+		}
+	},
+
+	_callback: function() {
+		this._anim = null;
+	}
+});
+
+dojo.fx.html.explode = function(start, endNode, duration, callback, dontPlay) {
+	var startCoords = dojo.style.toCoordinateArray(start);
+
+	var outline = document.createElement("div");
+	with(outline.style) {
+		position = "absolute";
+		border = "1px solid black";
+		display = "none";
+	}
+	document.body.appendChild(outline);
+
+	endNode = dojo.byId(endNode);
+	with(endNode.style) {
+		visibility = "hidden";
+		display = "block";
+	}
+	var endCoords = dojo.style.toCoordinateArray(endNode);
+
+	with(endNode.style) {
+		display = "none";
+		visibility = "visible";
+	}
+
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startCoords, endCoords),
+		duration||dojo.fx.duration, 0
+	);
+	dojo.event.connect(anim, "onBegin", function(e) {
+		outline.style.display = "block";
+	});
+	dojo.event.connect(anim, "onAnimate", function(e) {
+		with(outline.style) {
+			left = e.x + "px";
+			top = e.y + "px";
+			width = e.coords[2] + "px";
+			height = e.coords[3] + "px";
+		}
+	});
+
+	dojo.event.connect(anim, "onEnd", function() {
+		endNode.style.display = "block";
+		outline.parentNode.removeChild(outline);
+		if(callback) { callback(endNode, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+};
+
+dojo.fx.html.implode = function(startNode, end, duration, callback, dontPlay) {
+	var startCoords = dojo.style.toCoordinateArray(startNode);
+	var endCoords = dojo.style.toCoordinateArray(end);
+
+	startNode = dojo.byId(startNode);
+	var outline = document.createElement("div");
+	with(outline.style) {
+		position = "absolute";
+		border = "1px solid black";
+		display = "none";
+	}
+	document.body.appendChild(outline);
+
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startCoords, endCoords),
+		duration||dojo.fx.duration, 0
+	);
+	dojo.event.connect(anim, "onBegin", function(e) {
+		startNode.style.display = "none";
+		outline.style.display = "block";
+	});
+	dojo.event.connect(anim, "onAnimate", function(e) {
+		with(outline.style) {
+			left = e.x + "px";
+			top = e.y + "px";
+			width = e.coords[2] + "px";
+			height = e.coords[3] + "px";
+		}
+	});
+
+	dojo.event.connect(anim, "onEnd", function() {
+		outline.parentNode.removeChild(outline);
+		if(callback) { callback(startNode, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+};
+
+dojo.fx.html.Exploder = function(triggerNode, boxNode) {
+	triggerNode = dojo.byId(triggerNode);
+	boxNode = dojo.byId(boxNode);
+	var _this = this;
+
+	// custom options
+	this.waitToHide = 500;
+	this.timeToShow = 100;
+	this.waitToShow = 200;
+	this.timeToHide = 70;
+	this.autoShow = false;
+	this.autoHide = false;
+
+	var animShow = null;
+	var animHide = null;
+
+	var showTimer = null;
+	var hideTimer = null;
+
+	var startCoords = null;
+	var endCoords = null;
+
+	this.showing = false;
+
+	this.onBeforeExplode = null;
+	this.onAfterExplode = null;
+	this.onBeforeImplode = null;
+	this.onAfterImplode = null;
+	this.onExploding = null;
+	this.onImploding = null;
+
+	this.timeShow = function() {
+		clearTimeout(showTimer);
+		showTimer = setTimeout(_this.show, _this.waitToShow);
+	}
+
+	this.show = function() {
+		clearTimeout(showTimer);
+		clearTimeout(hideTimer);
+		//triggerNode.blur();
+
+		if( (animHide && animHide.status() == "playing")
+			|| (animShow && animShow.status() == "playing")
+			|| _this.showing ) { return; }
+
+		if(typeof _this.onBeforeExplode == "function") { _this.onBeforeExplode(triggerNode, boxNode); }
+		animShow = dojo.fx.html.explode(triggerNode, boxNode, _this.timeToShow, function(e) {
+			_this.showing = true;
+			if(typeof _this.onAfterExplode == "function") { _this.onAfterExplode(triggerNode, boxNode); }
+		});
+		if(typeof _this.onExploding == "function") {
+			dojo.event.connect(animShow, "onAnimate", this, "onExploding");
+		}
+	}
+
+	this.timeHide = function() {
+		clearTimeout(showTimer);
+		clearTimeout(hideTimer);
+		if(_this.showing) {
+			hideTimer = setTimeout(_this.hide, _this.waitToHide);
+		}
+	}
+
+	this.hide = function() {
+		clearTimeout(showTimer);
+		clearTimeout(hideTimer);
+		if( animShow && animShow.status() == "playing" ) {
+			return;
+		}
+
+		_this.showing = false;
+		if(typeof _this.onBeforeImplode == "function") { _this.onBeforeImplode(triggerNode, boxNode); }
+		animHide = dojo.fx.html.implode(boxNode, triggerNode, _this.timeToHide, function(e){
+			if(typeof _this.onAfterImplode == "function") { _this.onAfterImplode(triggerNode, boxNode); }
+		});
+		if(typeof _this.onImploding == "function") {
+			dojo.event.connect(animHide, "onAnimate", this, "onImploding");
+		}
+	}
+
+	// trigger events
+	dojo.event.connect(triggerNode, "onclick", function(e) {
+		if(_this.showing) {
+			_this.hide();
+		} else {
+			_this.show();
+		}
+	});
+	dojo.event.connect(triggerNode, "onmouseover", function(e) {
+		if(_this.autoShow) {
+			_this.timeShow();
+		}
+	});
+	dojo.event.connect(triggerNode, "onmouseout", function(e) {
+		if(_this.autoHide) {
+			_this.timeHide();
+		}
+	});
+
+	// box events
+	dojo.event.connect(boxNode, "onmouseover", function(e) {
+		clearTimeout(hideTimer);
+	});
+	dojo.event.connect(boxNode, "onmouseout", function(e) {
+		if(_this.autoHide) {
+			_this.timeHide();
+		}
+	});
+
+	// document events
+	dojo.event.connect(document.documentElement || document.body, "onclick", function(e) {
+		function isDesc(node, ancestor) {
+			while(node) {
+				if(node == ancestor){ return true; }
+				node = node.parentNode;
+			}
+			return false;
+		}
+		if(_this.autoHide && _this.showing
+			&& !isDesc(e.target, boxNode)
+			&& !isDesc(e.target, triggerNode) ) {
+			_this.hide();
+		}
+	});
+
+	return this;
+};
+
+/**** 
+	Strategies for displaying/hiding objects
+	This presents a standard interface for each of the effects
+*****/
+dojo.fx.html.toggle={}
+
+dojo.fx.html.toggle.plain = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.style.show(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.style.hide(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	}
+}
+
+dojo.fx.html.toggle.fade = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.fadeShow(node, duration, callback);
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.fadeHide(node, duration, callback);
+	}
+}
+
+dojo.fx.html.toggle.wipe = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.wipeIn(node, duration, callback);
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.wipeOut(node, duration, callback);
+	}
+}
+
+dojo.fx.html.toggle.explode = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.explode(explodeSrc||[0,0,0,0], node, duration, callback);
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.implode(node, explodeSrc||[0,0,0,0], duration, callback);
+	}
+}
+
+dojo.lang.mixin(dojo.fx, dojo.fx.html);

Added: tags/parley-0.53/root/static/magic/src/fx/svg.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/fx/svg.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/fx/svg.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,99 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.fx.svg");
+
+dojo.require("dojo.svg");
+dojo.require("dojo.animation.*");
+dojo.require("dojo.event.*");
+
+dojo.fx.svg.fadeOut = function(node, duration, callback){
+	return dojo.fx.svg.fade(node, duration, dojo.svg.getOpacity(node), 0, callback);
+};
+dojo.fx.svg.fadeIn = function(node, duration, callback){
+	return dojo.fx.svg.fade(node, duration, dojo.svg.getOpacity(node), 1, callback);
+};
+dojo.fx.svg.fadeHide = function(node, duration, callback){
+	if(!duration) { duration = 150; } // why not have a default?
+	return dojo.fx.svg.fadeOut(node, duration, function(node) {
+		if(typeof callback == "function") { callback(node); }
+	});
+};
+dojo.fx.svg.fadeShow = function(node, duration, callback){
+	if(!duration) { duration = 150; } // why not have a default?
+	return dojo.fx.svg.fade(node, duration, 0, 1, callback);
+};
+dojo.fx.svg.fade = function(node, duration, startOpac, endOpac, callback){
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line([startOpac],[endOpac]),
+		duration,
+		0
+	);
+	dojo.event.connect(anim, "onAnimate", function(e){
+		dojo.svg.setOpacity(node, e.x);
+	});
+	if (callback) {
+		dojo.event.connect(anim, "onEnd", function(e){
+			callback(node, anim);
+		});
+	};
+	anim.play(true);
+	return anim;
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+//	TODO
+/////////////////////////////////////////////////////////////////////////////////////////
+
+//	SLIDES
+dojo.fx.svg.slideTo = function(node, endCoords, duration, callback) { };
+dojo.fx.svg.slideBy = function(node, coords, duration, callback) { };
+dojo.fx.svg.slide = function(node, startCoords, endCoords, duration, callback) { 
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line([startCoords],[endCoords]),
+		duration,
+		0
+	);
+	dojo.event.connect(anim, "onAnimate", function(e){
+		dojo.svg.setCoords(node, {x: e.x, y: e.y });
+	});
+	if (callback) {
+		dojo.event.connect(anim, "onEnd", function(e){
+			callback(node, anim);
+		});
+	};
+	anim.play(true);
+	return anim;
+};
+
+//	COLORS
+dojo.fx.svg.colorFadeIn = function(node, startRGB, duration, delay, callback) { };
+dojo.fx.svg.highlight = dojo.fx.svg.colorFadeIn;
+dojo.fx.svg.colorFadeFrom = dojo.fx.svg.colorFadeIn;
+
+dojo.fx.svg.colorFadeOut = function(node, endRGB, duration, delay, callback) { };
+dojo.fx.svg.unhighlight = dojo.fx.svg.colorFadeOut;
+dojo.fx.svg.colorFadeTo = dojo.fx.svg.colorFadeOut;
+
+dojo.fx.svg.colorFade = function(node, startRGB, endRGB, duration, callback, dontPlay) { };
+
+//	WIPES
+dojo.fx.svg.wipeIn = function(node, duration, callback, dontPlay) { };
+dojo.fx.svg.wipeInToHeight = function(node, duration, height, callback, dontPlay) { }
+dojo.fx.svg.wipeOut = function(node, duration, callback, dontPlay) { };
+
+//	Explode and Implode
+dojo.fx.svg.explode = function(startNode, endNode, duration, callback) { };
+dojo.fx.svg.explodeFromBox = function(startCoords, endNode, duration, callback) { };
+dojo.fx.svg.implode = function(startNode, endNode, duration, callback) { };
+dojo.fx.svg.implodeToBox = function(startNode, endCoords, duration, callback) { };
+dojo.fx.svg.Exploder = function(triggerNode, boxNode) { };
+
+//	html mixes in, we want SVG to remain separate

Modified: tags/parley-0.53/root/static/magic/src/graphics/Colorspace.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/graphics/Colorspace.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/graphics/Colorspace.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,10 +8,937 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.graphics.Colorspace");
 
+dojo.require("dojo.lang");
+dojo.require("dojo.math.matrix");
 
-dojo.provide("dojo.graphics.Colorspace");
-dojo.require("dojo.gfx.Colorspace");
-dojo.deprecated("dojo.graphics.Colorspace: use dojo.gfx.Colorspace instead.", "0.5");
-dojo.graphics.Colorspace = dojo.gfx.Colorspace;
+//
+// to convert to YUV:
+//   c.whitePoint = 'D65';
+//   c.RGBWorkingSpace = 'pal_secam_rgb';
+//   var out = c.convert([r,g,b], 'RGB', 'XYZ');
+//
+// to convert to YIQ:
+//   c.whitePoint = 'D65';
+//   c.RGBWorkingSpace = 'ntsc_rgb';
+//   var out = c.convert([r,g,b], 'RGB', 'XYZ');
+//
 
+dojo.graphics.Colorspace =function(){
+
+	this.whitePoint = 'D65';
+	this.stdObserver = '10';
+	this.chromaticAdaptationAlg = 'bradford';
+	this.RGBWorkingSpace = 's_rgb';
+	this.useApproxCIELabMapping = 1; // see http://www.brucelindbloom.com/LContinuity.html
+
+	this.chainMaps = {
+		'RGB_to_xyY'  : ['XYZ'],
+		'xyY_to_RGB'  : ['XYZ'],
+		'RGB_to_Lab'  : ['XYZ'],
+		'Lab_to_RGB'  : ['XYZ'],
+		'RGB_to_LCHab': ['XYZ', 'Lab'],
+		'LCHab_to_RGB': ['Lab'],
+		'xyY_to_Lab'  : ['XYZ'],
+		'Lab_to_xyY'  : ['XYZ'],
+		'XYZ_to_LCHab': ['Lab'],
+		'LCHab_to_XYZ': ['Lab'],
+		'xyY_to_LCHab': ['XYZ', 'Lab'],
+		'LCHab_to_xyY': ['Lab', 'XYZ'],
+		'RGB_to_Luv'  : ['XYZ'],
+		'Luv_to_RGB'  : ['XYZ'],
+		'xyY_to_Luv'  : ['XYZ'],
+		'Luv_to_xyY'  : ['XYZ'],
+		'Lab_to_Luv'  : ['XYZ'],
+		'Luv_to_Lab'  : ['XYZ'],
+		'LCHab_to_Luv': ['Lab', 'XYZ'],
+		'Luv_to_LCHab': ['XYZ', 'Lab'],
+		'RGB_to_LCHuv'  : ['XYZ', 'Luv'],
+		'LCHuv_to_RGB'  : ['Luv', 'XYZ'],
+		'XYZ_to_LCHuv'  : ['Luv'],
+		'LCHuv_to_XYZ'  : ['Luv'],
+		'xyY_to_LCHuv'  : ['XYZ', 'Luv'],
+		'LCHuv_to_xyY'  : ['Luv', 'XYZ'],
+		'Lab_to_LCHuv'  : ['XYZ', 'Luv'],
+		'LCHuv_to_Lab'  : ['Luv', 'XYZ'],
+		'LCHab_to_LCHuv': ['Lab', 'XYZ', 'Luv'],
+		'LCHuv_to_LCHab': ['Luv', 'XYZ', 'Lab'],
+		'XYZ_to_CMY'    : ['RGB'],
+		'CMY_to_XYZ'    : ['RGB'],
+		'xyY_to_CMY'    : ['RGB'],
+		'CMY_to_xyY'    : ['RGB'],
+		'Lab_to_CMY'    : ['RGB'],
+		'CMY_to_Lab'    : ['RGB'],
+		'LCHab_to_CMY'  : ['RGB'],
+		'CMY_to_LCHab'  : ['RGB'],
+		'Luv_to_CMY'    : ['RGB'],
+		'CMY_to_Luv'    : ['RGB'],
+		'LCHuv_to_CMY'  : ['RGB'],
+		'CMY_to_LCHuv'  : ['RGB'],
+		'XYZ_to_HSL'    : ['RGB'],
+		'HSL_to_XYZ'    : ['RGB'],
+		'xyY_to_HSL'    : ['RGB'],
+		'HSL_to_xyY'    : ['RGB'],
+		'Lab_to_HSL'    : ['RGB'],
+		'HSL_to_Lab'    : ['RGB'],
+		'LCHab_to_HSL'  : ['RGB'],
+		'HSL_to_LCHab'  : ['RGB'],
+		'Luv_to_HSL'    : ['RGB'],
+		'HSL_to_Luv'    : ['RGB'],
+		'LCHuv_to_HSL'  : ['RGB'],
+		'HSL_to_LCHuv'  : ['RGB'],
+		'CMY_to_HSL'    : ['RGB'],
+		'HSL_to_CMY'    : ['RGB'],
+		'CMYK_to_HSL'   : ['RGB'],
+		'HSL_to_CMYK'   : ['RGB'],
+		'XYZ_to_HSV'    : ['RGB'],
+		'HSV_to_XYZ'    : ['RGB'],
+		'xyY_to_HSV'    : ['RGB'],
+		'HSV_to_xyY'    : ['RGB'],
+		'Lab_to_HSV'    : ['RGB'],
+		'HSV_to_Lab'    : ['RGB'],
+		'LCHab_to_HSV'  : ['RGB'],
+		'HSV_to_LCHab'  : ['RGB'],
+		'Luv_to_HSV'    : ['RGB'],
+		'HSV_to_Luv'    : ['RGB'],
+		'LCHuv_to_HSV'  : ['RGB'],
+		'HSV_to_LCHuv'  : ['RGB'],
+		'CMY_to_HSV'    : ['RGB'],
+		'HSV_to_CMY'    : ['RGB'],
+		'CMYK_to_HSV'   : ['RGB'],
+		'HSV_to_CMYK'   : ['RGB'],
+		'HSL_to_HSV'    : ['RGB'],
+		'HSV_to_HSL'    : ['RGB'],
+		'XYZ_to_CMYK'   : ['RGB'],
+		'CMYK_to_XYZ'   : ['RGB'],
+		'xyY_to_CMYK'   : ['RGB'],
+		'CMYK_to_xyY'   : ['RGB'],
+		'Lab_to_CMYK'   : ['RGB'],
+		'CMYK_to_Lab'   : ['RGB'],
+		'LCHab_to_CMYK' : ['RGB'],
+		'CMYK_to_LCHab' : ['RGB'],
+		'Luv_to_CMYK'   : ['RGB'],
+		'CMYK_to_Luv'   : ['RGB'],
+		'LCHuv_to_CMYK' : ['RGB'],
+		'CMYK_to_LCHuv' : ['RGB']
+	};
+
+
+	return this;
+}
+
+dojo.graphics.Colorspace.prototype.convert = function(col, model_from, model_to){
+
+	var k = model_from+'_to_'+model_to;
+
+	if (this[k]){
+		return this[k](col);
+	}else{
+		if (this.chainMaps[k]){
+
+			var cur = model_from;
+			var models = this.chainMaps[k].concat();
+			models.push(model_to);
+
+			for(var i=0; i<models.length; i++){
+
+				col = this.convert(col, cur, models[i]);
+				cur = models[i];
+			}
+
+			return col;
+
+		}else{
+
+			dojo.debug("Can't convert from "+model_from+' to '+model_to);
+		}
+	}
+}
+
+dojo.graphics.Colorspace.prototype.munge = function(keys, args){
+
+	if (dojo.lang.isArray(args[0])){
+		args = args[0];
+	}
+
+	var out = new Array();
+
+	for (var i=0; i<keys.length; i++){
+		out[keys.charAt(i)] = args[i];
+	}
+
+	return out;
+}
+
+dojo.graphics.Colorspace.prototype.getWhitePoint = function(){
+
+	var x = 0;
+	var y = 0;
+	var t = 0;
+
+	// ref: http://en.wikipedia.org/wiki/White_point
+	// TODO: i need some good/better white point values
+
+	switch(this.stdObserver){
+		case '2' :
+			switch(this.whitePoint){
+				case 'E'   : x=1/3    ; y=1/3    ; t=5400; break; //Equal energy
+				case 'D50' : x=0.34567; y=0.35850; t=5000; break;
+				case 'D55' : x=0.33242; y=0.34743; t=5500; break;
+				case 'D65' : x=0.31271; y=0.32902; t=6500; break;
+				case 'D75' : x=0.29902; y=0.31485; t=7500; break;
+				case 'A'   : x=0.44757; y=0.40745; t=2856; break; //Incandescent tungsten
+				case 'B'   : x=0.34842; y=0.35161; t=4874; break;
+				case 'C'   : x=0.31006; y=0.31616; t=6774; break;
+				case '9300': x=0.28480; y=0.29320; t=9300; break; //Blue phosphor monitors
+				case 'F2'  : x=0.37207; y=0.37512; t=4200; break; //Cool White Fluorescent
+				case 'F7'  : x=0.31285; y=0.32918; t=6500; break; //Narrow Band Daylight Fluorescent
+				case 'F11' : x=0.38054; y=0.37691; t=4000; break; //Narrow Band White Fluorescent
+				default: dojo.debug('White point '+this.whitePoint+" isn't defined for Std. Observer "+this.strObserver);
+			};
+			break;
+		case '10' :
+			switch(this.whitePoint){
+				case 'E'   : x=1/3    ; y=1/3    ; t=5400; break; //Equal energy
+				case 'D50' : x=0.34773; y=0.35952; t=5000; break;
+				case 'D55' : x=0.33411; y=0.34877; t=5500; break;
+				case 'D65' : x=0.31382; y=0.33100; t=6500; break;
+				case 'D75' : x=0.29968; y=0.31740; t=7500; break;
+				case 'A'   : x=0.45117; y=0.40594; t=2856; break; //Incandescent tungsten
+				case 'B'   : x=0.3498 ; y=0.3527 ; t=4874; break;
+				case 'C'   : x=0.31039; y=0.31905; t=6774; break;
+				case 'F2'  : x=0.37928; y=0.36723; t=4200; break; //Cool White Fluorescent
+				case 'F7'  : x=0.31565; y=0.32951; t=6500; break; //Narrow Band Daylight Fluorescent
+				case 'F11' : x=0.38543; y=0.37110; t=4000; break; //Narrow Band White Fluorescent
+				default: dojo.debug('White point '+this.whitePoint+" isn't defined for Std. Observer "+this.strObserver);
+			};
+			break;
+		default:
+			dojo.debug("Std. Observer "+this.strObserver+" isn't defined");
+	}
+
+	var z = 1 - x - y;
+
+	var wp = {'x':x, 'y':y, 'z':z, 't':t};
+
+	wp.Y = 1;
+
+	var XYZ = this.xyY_to_XYZ([wp.x, wp.y, wp.Y]);
+
+	wp.X = XYZ[0];
+	wp.Y = XYZ[1];
+	wp.Z = XYZ[2];
+
+	return wp
+}
+
+dojo.graphics.Colorspace.prototype.getPrimaries = function(){
+
+	// ref: http://www.fho-emden.de/~hoffmann/ciexyz29082000.pdf
+	// ref: http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
+
+	var m = [];
+
+	switch(this.RGBWorkingSpace){
+
+		case 'adobe_rgb_1998'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.297361, 0.2100, 0.7100, 0.627355, 0.1500, 0.0600, 0.075285]; break;
+		case 'apple_rgb'	: m = [1.8, 'D65', 0.6250, 0.3400, 0.244634, 0.2800, 0.5950, 0.672034, 0.1550, 0.0700, 0.083332]; break;
+		case 'best_rgb'		: m = [2.2, 'D50', 0.7347, 0.2653, 0.228457, 0.2150, 0.7750, 0.737352, 0.1300, 0.0350, 0.034191]; break;
+		case 'beta_rgb'		: m = [2.2, 'D50', 0.6888, 0.3112, 0.303273, 0.1986, 0.7551, 0.663786, 0.1265, 0.0352, 0.032941]; break;
+		case 'bruce_rgb'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.240995, 0.2800, 0.6500, 0.683554, 0.1500, 0.0600, 0.075452]; break;
+		case 'cie_rgb'		: m = [2.2, 'E'  , 0.7350, 0.2650, 0.176204, 0.2740, 0.7170, 0.812985, 0.1670, 0.0090, 0.010811]; break;
+		case 'color_match_rgb'	: m = [1.8, 'D50', 0.6300, 0.3400, 0.274884, 0.2950, 0.6050, 0.658132, 0.1500, 0.0750, 0.066985]; break;
+		case 'don_rgb_4'	: m = [2.2, 'D50', 0.6960, 0.3000, 0.278350, 0.2150, 0.7650, 0.687970, 0.1300, 0.0350, 0.033680]; break;
+		case 'eci_rgb'		: m = [1.8, 'D50', 0.6700, 0.3300, 0.320250, 0.2100, 0.7100, 0.602071, 0.1400, 0.0800, 0.077679]; break;
+		case 'ekta_space_ps5'	: m = [2.2, 'D50', 0.6950, 0.3050, 0.260629, 0.2600, 0.7000, 0.734946, 0.1100, 0.0050, 0.004425]; break;
+		case 'ntsc_rgb'		: m = [2.2, 'C'  , 0.6700, 0.3300, 0.298839, 0.2100, 0.7100, 0.586811, 0.1400, 0.0800, 0.114350]; break;
+		case 'pal_secam_rgb'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.222021, 0.2900, 0.6000, 0.706645, 0.1500, 0.0600, 0.071334]; break;
+		case 'pro_photo_rgb'	: m = [1.8, 'D50', 0.7347, 0.2653, 0.288040, 0.1596, 0.8404, 0.711874, 0.0366, 0.0001, 0.000086]; break;
+		case 'smpte-c_rgb'	: m = [2.2, 'D65', 0.6300, 0.3400, 0.212395, 0.3100, 0.5950, 0.701049, 0.1550, 0.0700, 0.086556]; break;
+		case 's_rgb'		: m = [2.2, 'D65', 0.6400, 0.3300, 0.212656, 0.3000, 0.6000, 0.715158, 0.1500, 0.0600, 0.072186]; break;
+		case 'wide_gamut_rgb'	: m = [2.2, 'D50', 0.7350, 0.2650, 0.258187, 0.1150, 0.8260, 0.724938, 0.1570, 0.0180, 0.016875]; break;
+
+		default: dojo.debug("RGB working space "+this.RGBWorkingSpace+" isn't defined");
+	}
+
+	var p = {};
+
+	p.name = this.RGBWorkingSpace;
+	p.gamma = m[0];
+	p.wp = m[1];
+
+	p.xr = m[2];
+	p.yr = m[3];
+	p.Yr = m[4];
+
+	p.xg = m[5];
+	p.yg = m[6];
+	p.Yg = m[7];
+
+	p.xb = m[8];
+	p.yb = m[9];
+	p.Yb = m[10];
+
+	// if WP doesn't match current WP, convert the primaries over
+
+	if (p.wp != this.whitePoint){
+
+		var r = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xr, p.yr, p.Yr]), p.wp, this.whitePoint ) );
+		var g = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xg, p.yg, p.Yg]), p.wp, this.whitePoint ) );
+		var b = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xb, p.yb, p.Yb]), p.wp, this.whitePoint ) );
+
+		p.xr = r[0];
+		p.yr = r[1];
+		p.Yr = r[2];
+
+		p.xg = g[0];
+		p.yg = g[1];
+		p.Yg = g[2];
+
+		p.xb = b[0];
+		p.yb = b[1];
+		p.Yb = b[2];
+
+		p.wp = this.whitePoint;
+	}
+
+	p.zr = 1 - p.xr - p.yr;
+	p.zg = 1 - p.xg - p.yg;
+	p.zb = 1 - p.xb - p.yb;
+
+	return p;
+}
+
+dojo.graphics.Colorspace.prototype.epsilon = function(){
+
+	return this.useApproxCIELabMapping ? 0.008856 : 216 / 24289;
+}
+
+dojo.graphics.Colorspace.prototype.kappa = function(){
+
+	return this.useApproxCIELabMapping ? 903.3 : 24389 / 27;
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_xyY = function(){
+	var src = this.munge('XYZ', arguments);
+
+	var sum = src.X + src.Y + src.Z;
+
+	if (sum == 0){
+
+		var wp = this.getWhitePoint();
+		var x = wp.x;
+		var y = wp.y;
+	}else{
+		var x = src.X / sum;
+		var y = src.Y / sum;
+	}
+
+	var Y = src.Y;
+
+
+	return [x, y, Y];
+}
+
+dojo.graphics.Colorspace.prototype.xyY_to_XYZ = function(){
+	var src = this.munge('xyY', arguments);
+
+	if (src.y == 0){
+
+		var X = 0;
+		var Y = 0;
+		var Z = 0;
+	}else{
+		var X = (src.x * src.Y) / src.y;
+		var Y = src.Y;
+		var Z = ((1 - src.x - src.y) * src.Y) / src.y;
+	}
+
+	return [X, Y, Z];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_XYZ = function(){
+	var src = this.munge('RGB', arguments);
+
+	var m = this.getRGB_XYZ_Matrix();
+	var pr = this.getPrimaries();
+
+	if (this.RGBWorkingSpace == 's_rgb'){
+
+		var r = (src.R > 0.04045) ? Math.pow(((src.R + 0.055) / 1.055), 2.4) : src.R / 12.92;
+		var g = (src.G > 0.04045) ? Math.pow(((src.G + 0.055) / 1.055), 2.4) : src.G / 12.92;
+		var b = (src.B > 0.04045) ? Math.pow(((src.B + 0.055) / 1.055), 2.4) : src.B / 12.92;
+
+	}else{
+
+		var r = Math.pow(src.R, pr.gamma);
+		var g = Math.pow(src.G, pr.gamma);
+		var b = Math.pow(src.B, pr.gamma);
+	}
+
+	var XYZ = dojo.math.matrix.multiply([[r, g, b]], m);
+
+	return [XYZ[0][0], XYZ[0][1], XYZ[0][2]];
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_RGB = function(){
+	var src = this.munge('XYZ', arguments);
+
+	var mi = this.getXYZ_RGB_Matrix();
+	var pr = this.getPrimaries();
+
+	var rgb = dojo.math.matrix.multiply([[src.X, src.Y, src.Z]], mi);
+	var r = rgb[0][0];
+	var g = rgb[0][1];
+	var b = rgb[0][2];
+
+	if (this.RGBWorkingSpace == 's_rgb'){
+
+		var R = (r > 0.0031308) ? (1.055 * Math.pow(r, 1.0/2.4)) - 0.055 : 12.92 * r;
+		var G = (g > 0.0031308) ? (1.055 * Math.pow(g, 1.0/2.4)) - 0.055 : 12.92 * g;
+		var B = (b > 0.0031308) ? (1.055 * Math.pow(b, 1.0/2.4)) - 0.055 : 12.92 * b;
+	}else{
+		var R = Math.pow(r, 1/pr.gamma);
+		var G = Math.pow(g, 1/pr.gamma);
+		var B = Math.pow(b, 1/pr.gamma);
+	}
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_Lab = function(){
+	var src = this.munge('XYZ', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var xr = src.X / wp.X;
+	var yr = src.Y / wp.Y;
+	var zr = src.Z / wp.Z;
+
+	var fx = (xr > this.epsilon()) ? Math.pow(xr, 1/3) : (this.kappa() * xr + 16) / 116;
+	var fy = (yr > this.epsilon()) ? Math.pow(yr, 1/3) : (this.kappa() * yr + 16) / 116;
+	var fz = (zr > this.epsilon()) ? Math.pow(zr, 1/3) : (this.kappa() * zr + 16) / 116;
+
+	var L = 116 * fy - 16;
+	var a = 500 * (fx - fy);
+	var b = 200 * (fy - fz);
+
+	return [L, a, b];
+}
+
+dojo.graphics.Colorspace.prototype.Lab_to_XYZ = function(){
+	var src = this.munge('Lab', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var yr = (src.L > (this.kappa() * this.epsilon())) ? Math.pow((src.L + 16) / 116, 3) : src.L / this.kappa();
+
+	var fy = (yr > this.epsilon()) ? (src.L + 16) / 116 : (this.kappa() * yr + 16) / 116;
+
+	var fx = (src.a / 500) + fy;
+	var fz = fy - (src.b / 200);
+
+	var fxcube = Math.pow(fx, 3);
+	var fzcube = Math.pow(fz, 3);
+
+	var xr = (fxcube > this.epsilon()) ? fxcube : (116 * fx - 16) / this.kappa();
+	var zr = (fzcube > this.epsilon()) ? fzcube : (116 * fz - 16) / this.kappa();
+
+	var X = xr * wp.X;
+	var Y = yr * wp.Y;
+	var Z = zr * wp.Z;
+
+	return [X, Y, Z];
+}
+
+dojo.graphics.Colorspace.prototype.Lab_to_LCHab = function(){
+	var src = this.munge('Lab', arguments);
+
+	var L = src.L;
+	var C = Math.pow(src.a * src.a + src.b * src.b, 0.5);
+	var H = Math.atan2(src.b, src.a) * (180 / Math.PI);
+
+	if (H < 0){ H += 360; }
+	if (H > 360){ H -= 360; }
+
+	return [L, C, H];
+}
+
+dojo.graphics.Colorspace.prototype.LCHab_to_Lab = function(){
+	var src = this.munge('LCH', arguments);
+
+	var H_rad = src.H * (Math.PI / 180);
+
+	var L = src.L;
+
+	var a = src.C / Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);
+	if ((90 < src.H) && (src.H < 270)){ a= -a; }
+
+	var b = Math.pow(Math.pow(src.C, 2) - Math.pow(a, 2), 0.5);
+	if (src.H > 180){ b = -b; }
+
+	return [L, a, b];
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+// this function converts an XYZ color array (col) from one whitepoint (src_w) to another (dst_w)
+//
+
+dojo.graphics.Colorspace.prototype.chromaticAdaptation = function(col, src_w, dst_w){
+
+	col = this.munge('XYZ', [col]);
+
+	//
+	// gather white point data for the source and dest
+	//
+
+	var old_wp = this.whitePoint;
+
+	this.whitePoint = src_w;
+	var wp_src = this.getWhitePoint();
+
+	this.whitePoint = dst_w;
+	var wp_dst = this.getWhitePoint();
+
+	this.whitePoint = old_wp;
+
+
+	//
+	// get a transformation matricies
+	//
+
+	switch(this.chromaticAdaptationAlg){
+		case 'xyz_scaling':
+			var ma = [[1,0,0],[0,1,0],[0,0,1]];
+			var mai = [[1,0,0],[0,1,0],[0,0,1]];
+			break;
+		case 'bradford':
+			var ma = [[0.8951, -0.7502, 0.0389],[0.2664, 1.7135, -0.0685],[-0.1614, 0.0367, 1.0296]];
+			var mai = [[0.986993, 0.432305, -0.008529],[-0.147054, 0.518360, 0.040043],[0.159963, 0.049291, 0.968487]];
+			break;
+		case 'von_kries':
+			var ma = [[0.40024, -0.22630, 0.00000],[0.70760, 1.16532, 0.00000],[-0.08081, 0.04570, 0.91822]]
+			var mai = [[1.859936, 0.361191, 0.000000],[-1.129382, 0.638812, 0.000000],[0.219897, -0.000006, 1.089064]]
+			break;
+		default:
+			dojo.debug("The "+this.chromaticAdaptationAlg+" chromatic adaptation algorithm matricies are not defined");
+	}
+
+
+	//
+	// calculate the cone response domains
+	//
+
+	var domain_src = dojo.math.matrix.multiply( [[wp_src.x, wp_src.y, wp_src.z]], ma);
+	var domain_dst = dojo.math.matrix.multiply( [[wp_dst.x, wp_dst.y, wp_dst.z]], ma);
+
+
+	//
+	// construct the centre matrix
+	//
+
+	var centre = [
+		[domain_dst[0][0]/domain_src[0][0], 0, 0],
+		[0, domain_dst[0][1]/domain_src[0][1], 0],
+		[0, 0, domain_dst[0][2]/domain_src[0][2]]
+	];
+
+
+	//
+	// caclulate 'm'
+	//
+
+	var m = dojo.math.matrix.multiply( dojo.math.matrix.multiply( ma, centre ), mai );
+
+
+	//
+	// construct source color matrix
+	//
+
+	var dst = dojo.math.matrix.multiply( [[ col.X, col.Y, col.Z ]], m );
+
+	return dst[0];
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+
+dojo.graphics.Colorspace.prototype.getRGB_XYZ_Matrix = function(){
+
+	var wp = this.getWhitePoint();
+	var pr = this.getPrimaries();
+
+	var Xr = pr.xr / pr.yr;
+	var Yr = 1;
+	var Zr = (1 - pr.xr - pr.yr) / pr.yr;
+
+	var Xg = pr.xg / pr.yg;
+	var Yg = 1;
+	var Zg = (1 - pr.xg - pr.yg) / pr.yg;
+
+	var Xb = pr.xb / pr.yb;
+	var Yb = 1;
+	var Zb = (1 - pr.xb - pr.yb) / pr.yb;
+
+	var m1 = [[Xr, Yr, Zr],[Xg, Yg, Zg],[Xb, Yb, Zb]];
+	var m2 = [[wp.X, wp.Y, wp.Z]];
+	var sm = dojo.math.matrix.multiply(m2, dojo.math.matrix.inverse(m1));
+
+	var Sr = sm[0][0];
+	var Sg = sm[0][1];
+	var Sb = sm[0][2];
+
+	var m4 = [[Sr*Xr, Sr*Yr, Sr*Zr],
+		  [Sg*Xg, Sg*Yg, Sg*Zg],
+		  [Sb*Xb, Sb*Yb, Sb*Zb]];
+
+	return m4;
+}
+
+dojo.graphics.Colorspace.prototype.getXYZ_RGB_Matrix = function(){
+
+	var m = this.getRGB_XYZ_Matrix();
+
+	return dojo.math.matrix.inverse(m);
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_Luv = function(){
+
+	var src = this.munge('XYZ', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var ud = (4 * src.X) / (src.X + 15 * src.Y + 3 * src.Z);
+	var vd = (9 * src.Y) / (src.X + 15 * src.Y + 3 * src.Z);
+
+	var udr = (4 * wp.X) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+	var vdr = (9 * wp.Y) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+
+	var yr = src.Y / wp.Y;
+
+	var L = (yr > this.epsilon()) ? 116 * Math.pow(yr, 1/3) - 16 : this.kappa() * yr;
+	var u = 13 * L * (ud-udr);
+	var v = 13 * L * (vd-vdr);
+
+	return [L, u, v];
+}
+
+dojo.graphics.Colorspace.prototype.Luv_to_XYZ = function(){
+
+	var src = this.munge('Luv', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var uz = (4 * wp.X) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+	var vz = (9 * wp.Y) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+
+	var Y = (src.L > this.kappa() * this.epsilon()) ? Math.pow((src.L + 16) / 116, 3) : src.L / this.kappa();
+
+	var a = (1 / 3) * (((52 * src.L) / (src.u + 13 * src.L * uz)) - 1);
+	var b = -5 * Y;
+	var c = - (1 / 3);
+	var d = Y * (((39 * src.L) / (src.v + 13 * src.L * vz)) - 5);
+
+	var X = (d - b) / (a - c);
+	var Z = X * a + b;
+
+	return [X, Y, Z];
+}
+
+dojo.graphics.Colorspace.prototype.Luv_to_LCHuv = function(){
+
+	var src = this.munge('Luv', arguments);
+
+	var L = src.L;
+	var C = Math.pow(src.u * src.u + src.v * src.v, 0.5);
+	var H = Math.atan2(src.v, src.u) * (180 / Math.PI);
+
+	if (H < 0){ H += 360; }
+	if (H > 360){ H -= 360; }
+
+	return [L, C, H];
+}
+
+dojo.graphics.Colorspace.prototype.LCHuv_to_Luv = function(){
+
+	var src = this.munge('LCH', arguments);
+
+	var H_rad = src.H * (Math.PI / 180);
+
+	var L = src.L;
+	var u = src.C / Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);
+	var v = Math.pow(src.C * src.C - u * u, 0.5);
+
+	if ((90 < src.H) && (src.H < 270)){ u *= -1; }
+	if (src.H > 180){ v *= -1; }
+
+	return [L, u, v];
+}
+
+dojo.graphics.Colorspace.colorTemp_to_whitePoint = function(T){
+
+	if (T < 4000){
+		dojo.debug("Can't find a white point for temperatures under 4000K");
+		return [0,0];
+	}
+
+	if (T > 25000){
+		dojo.debug("Can't find a white point for temperatures over 25000K");
+		return [0,0];
+	}
+
+	var T1 = T;
+	var T2 = T * T;
+	var T3 = T2 * T;
+
+	var ten9 = Math.pow(10, 9);
+	var ten6 = Math.pow(10, 6);
+	var ten3 = Math.pow(10, 3);
+
+	if (T <= 7000){
+
+		var x = (-4.6070 * ten9 / T3) + (2.9678 * ten6 / T2) + (0.09911 * ten3 / T) + 0.244063;
+	}else{
+		var x = (-2.0064 * ten9 / T3) + (1.9018 * ten6 / T2) + (0.24748 * ten3 / T) + 0.237040;
+	}
+
+	var y = -3.000 * x * x + 2.870 * x - 0.275;
+
+	return [x, y];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_CMY = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	var C = 1 - src.R;
+	var M = 1 - src.G;
+	var Y = 1 - src.B;
+
+	return [C, M, Y];
+}
+
+dojo.graphics.Colorspace.prototype.CMY_to_RGB = function(){
+
+	var src = this.munge('CMY', arguments);
+
+	var R = 1 - src.C;
+	var G = 1 - src.M;
+	var B = 1 - src.Y;
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_CMYK = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	var K = Math.min(1-src.R, 1-src.G, 1-src.B);
+	var C = (1 - src.R - K) / (1 - K);
+	var M = (1 - src.G - K) / (1 - K);
+	var Y = (1 - src.B - K) / (1 - K);
+
+	return [C, M, Y, K];
+}
+
+dojo.graphics.Colorspace.prototype.CMYK_to_RGB = function(){
+
+	var src = this.munge('CMYK', arguments);
+
+	var R = 1 - Math.min(1, src.C * (1-src.K) + src.K);
+	var G = 1 - Math.min(1, src.M * (1-src.K) + src.K);
+	var B = 1 - Math.min(1, src.Y * (1-src.K) + src.K);
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.CMY_to_CMYK = function(){
+
+	var src = this.munge('CMY', arguments);
+
+	var K = Math.min(src.C, src.M, src.Y);
+	var C = (src.C - K) / (1 - K);
+	var M = (src.M - K) / (1 - K);
+	var Y = (src.Y - K) / (1 - K);
+
+	return [C, M, Y, K];
+}
+
+dojo.graphics.Colorspace.prototype.CMYK_to_CMY = function(){
+
+	var src = this.munge('CMYK', arguments);
+
+	var C = Math.min(1, src.C * (1-src.K) + src.K);
+	var M = Math.min(1, src.M * (1-src.K) + src.K);
+	var Y = Math.min(1, src.Y * (1-src.K) + src.K);
+
+	return [C, M, Y];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_HSV = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	// Based on C Code in "Computer Graphics -- Principles and Practice,"
+	// Foley et al, 1996, p. 592. 
+
+	var min = Math.min(src.R, src.G, src.B);
+	var V = Math.max(src.R, src.G, src.B);
+
+	var delta = V - min;
+
+	var H = null;
+	var S = (V == 0) ? 0 : delta / V;
+
+	if (S == 0){
+		H = 0;
+	}else{
+		if (src.R == V){
+			H = 60 * (src.G - src.B) / delta;
+		}else{
+			if (src.G == V){
+				H = 120 + 60 * (src.B - src.R) / delta;
+			}else{
+				if (src.B == V){
+					// between magenta and cyan
+					H = 240 + 60 * (src.R - src.G) / delta;
+				}
+			}
+		}
+		if (H < 0){
+			H += 360;
+		}
+	}
+
+	H = (H == 0) ? 360 : H;
+
+	return [H, S, V];
+}
+
+dojo.graphics.Colorspace.prototype.HSV_to_RGB = function(){
+ 
+	var src = this.munge('HSV', arguments);
+
+	if (src.H == 360){ src.H = 0;}
+
+	// Based on C Code in "Computer Graphics -- Principles and Practice,"
+	// Foley et al, 1996, p. 593.
+
+	var r = null;
+	var g = null;
+	var b = null;
+
+	if (src.S == 0){
+		// color is on black-and-white center line
+		// achromatic: shades of gray
+		var R = src.V;
+		var G = src.V;
+		var B = src.V;
+	}else{
+		// chromatic color
+		var hTemp = src.H / 60;		// h is now IN [0,6]
+		var i = Math.floor(hTemp);	// largest integer <= h
+		var f = hTemp - i;		// fractional part of h
+
+		var p = src.V * (1 - src.S);
+		var q = src.V * (1 - (src.S * f));
+		var t = src.V * (1 - (src.S * (1 - f)));
+
+		switch(i){
+			case 0: R = src.V; G = t    ; B = p    ; break;
+			case 1: R = q    ; G = src.V; B = p    ; break;
+			case 2: R = p    ; G = src.V; B = t    ; break;
+			case 3: R = p    ; G = q    ; B = src.V; break;
+			case 4: R = t    ; G = p    ; B = src.V; break;
+			case 5: R = src.V; G = p    ; B = q    ; break;
+		}
+	}
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_HSL = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	//
+	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
+	//
+
+
+	var min = Math.min(src.R, src.G, src.B);
+	var max = Math.max(src.R, src.G, src.B);
+	var delta = max - min;
+
+	var H = 0;
+	var S = 0;
+	var L = (min + max) / 2;
+
+	if ((L > 0) && (L < 1)){
+		S = delta / ((L < 0.5) ? (2 * L) : (2 - 2 * L));
+	}
+
+	if (delta > 0) {
+		if ((max == src.R) && (max != src.G)){
+			H += (src.G - src.B) / delta;
+		}
+		if ((max == src.G) && (max != src.B)){
+			H += (2 + (src.B - src.R) / delta);
+		}
+		if ((max == src.B) && (max != src.R)){
+			H += (4 + (src.R - src.G) / delta);
+		}
+		H *= 60;
+	}
+
+	H = (H == 0) ? 360 : H;
+
+	return [H, S, L];
+}
+
+dojo.graphics.Colorspace.prototype.HSL_to_RGB = function(){
+ 
+	var src = this.munge('HSL', arguments);
+
+	//
+	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
+	//
+
+	while (src.H < 0){ src.H += 360; }
+	while (src.H >= 360){ src.H -= 360; }
+
+	var R = 0;
+	var G = 0;
+	var B = 0;
+
+	if (src.H < 120){
+		R = (120 - src.H) / 60;
+		G = src.H / 60;
+		B = 0;
+	}else if (src.H < 240){
+		R = 0;
+		G = (240 - src.H) / 60;
+		B = (src.H - 120) / 60;
+	}else{
+		R = (src.H - 240) / 60;
+		G = 0;
+		B = (360 - src.H) / 60;
+	}
+
+	R = 2 * src.S * Math.min(R, 1) + (1 - src.S);
+	G = 2 * src.S * Math.min(G, 1) + (1 - src.S);
+	B = 2 * src.S * Math.min(B, 1) + (1 - src.S);
+
+	if (src.L < 0.5){
+		R = src.L * R;
+		G = src.L * G;
+		B = src.L * B;
+	}else{
+		R = (1 - src.L) * R + 2 * src.L - 1;
+		G = (1 - src.L) * G + 2 * src.L - 1;
+		B = (1 - src.L) * B + 2 * src.L - 1;
+	}
+
+	return [R, G, B];
+}

Modified: tags/parley-0.53/root/static/magic/src/graphics/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/graphics/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/graphics/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,7 +8,8 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
+dojo.kwCompoundRequire({
+	browser:	["dojo.graphics.htmlEffects"],
+	dashboard:	["dojo.graphics.htmlEffects"]
+});
 dojo.provide("dojo.graphics.*");
-

Modified: tags/parley-0.53/root/static/magic/src/graphics/color/hsl.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/graphics/color/hsl.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/graphics/color/hsl.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,25 +8,137 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.graphics.color.hsl");
+dojo.require("dojo.lang.array");
 
+dojo.lang.extend(dojo.graphics.color.Color, {
 
-dojo.provide("dojo.graphics.color.hsl");
-dojo.require("dojo.gfx.color.hsl");
-dojo.deprecated("dojo.graphics.color.hsl has been replaced with dojo.gfx.color.hsl", "0.5");
-dojo.graphics.color.rgb2hsl = function (r, g, b) {
-	dojo.deprecated("dojo.graphics.color.rgb2hsl has been replaced with dojo.gfx.color.rgb2hsl", "0.5");
-	return dojo.gfx.color.rgb2hsl(r, g, b);
-};
-dojo.graphics.color.hsl2rgb = function (h, s, l) {
-	dojo.deprecated("dojo.graphics.color.hsl2rgb has been replaced with dojo.gfx.color.hsl2rgb", "0.5");
-	return dojo.gfx.color.hsl2rgb(h, s, l);
-};
-dojo.graphics.color.hsl2hex = function (h, s, l) {
-	dojo.deprecated("dojo.graphics.color.hsl2hex has been replaced with dojo.gfx.color.hsl2hex", "0.5");
-	return dojo.gfx.color.hsl2hex(h, s, l);
-};
-dojo.graphics.color.hex2hsl = function (hex) {
-	dojo.deprecated("dojo.graphics.color.hex2hsl has been replaced with dojo.gfx.color.hex2hsl", "0.5");
-	return dojo.gfx.color.hex2hsl(hex);
-};
+	toHsl: function() {
+		return dojo.graphics.color.rgb2hsl(this.toRgb());
+	}
+});
 
+dojo.graphics.color.rgb2hsl = function(r, g, b){
+
+	if (dojo.lang.isArray(r)) {
+		b = r[2] || 0;
+		g = r[1] || 0;
+		r = r[0] || 0;
+	}
+
+	r /= 255;
+	g /= 255;
+	b /= 255;
+
+	//
+	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
+	//
+
+	var h = null;
+	var s = null;
+	var l = null;
+
+
+	var min = Math.min(r, g, b);
+	var max = Math.max(r, g, b);
+	var delta = max - min;
+
+	l = (min + max) / 2;
+
+	s = 0;
+
+	if ((l > 0) && (l < 1)){
+		s = delta / ((l < 0.5) ? (2 * l) : (2 - 2 * l));
+	}
+
+	h = 0;
+
+	if (delta > 0) {
+		if ((max == r) && (max != g)){
+			h += (g - b) / delta;
+		}
+		if ((max == g) && (max != b)){
+			h += (2 + (b - r) / delta);
+		}
+		if ((max == b) && (max != r)){
+			h += (4 + (r - g) / delta);
+		}
+		h *= 60;
+	}
+
+	h = (h == 0) ? 360 : Math.ceil((h / 360) * 255);
+	s = Math.ceil(s * 255);
+	l = Math.ceil(l * 255);
+
+	return [h, s, l];
+}
+
+dojo.graphics.color.hsl2rgb = function(h, s, l){
+ 
+	if (dojo.lang.isArray(h)) {
+		l = h[2] || 0;
+		s = h[1] || 0;
+		h = h[0] || 0;
+	}
+
+	h = (h / 255) * 360;
+	if (h == 360){ h = 0;}
+	s = s / 255;
+	l = l / 255;
+
+	//
+	// based on C code from http://astronomy.swin.edu.au/~pbourke/colour/hsl/
+	//
+
+
+	while (h < 0){ h += 360; }
+	while (h > 360){ h -= 360; }
+	var r, g, b;
+	if (h < 120){
+		r = (120 - h) / 60;
+		g = h / 60;
+		b = 0;
+	}else if (h < 240){
+		r = 0;
+		g = (240 - h) / 60;
+		b = (h - 120) / 60;
+	}else{
+		r = (h - 240) / 60;
+		g = 0;
+		b = (360 - h) / 60;
+	}
+
+	r = Math.min(r, 1);
+	g = Math.min(g, 1);
+	b = Math.min(b, 1);
+
+	r = 2 * s * r + (1 - s);
+	g = 2 * s * g + (1 - s);
+	b = 2 * s * b + (1 - s);
+
+	if (l < 0.5){
+		r = l * r;
+		g = l * g;
+		b = l * b;
+	}else{
+		r = (1 - l) * r + 2 * l - 1;
+		g = (1 - l) * g + 2 * l - 1;
+		b = (1 - l) * b + 2 * l - 1;
+	}
+
+	r = Math.ceil(r * 255);
+	g = Math.ceil(g * 255);
+	b = Math.ceil(b * 255);
+
+	return [r, g, b];
+}
+
+dojo.graphics.color.hsl2hex = function(h, s, l){
+	var rgb = dojo.graphics.color.hsl2rgb(h, s, l);
+	return dojo.graphics.color.rgb2hex(rgb[0], rgb[1], rgb[2]);
+}
+
+dojo.graphics.color.hex2hsl = function(hex){
+	var rgb = dojo.graphics.color.hex2rgb(hex);
+	return dojo.graphics.color.rgb2hsl(rgb[0], rgb[1], rgb[2]);
+}

Modified: tags/parley-0.53/root/static/magic/src/graphics/color/hsv.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/graphics/color/hsv.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/graphics/color/hsv.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,17 +8,134 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.graphics.color.hsv");
+dojo.require("dojo.lang.array");
 
+dojo.lang.extend(dojo.graphics.color.Color, {
 
-dojo.provide("dojo.graphics.color.hsv");
-dojo.require("dojo.gfx.color.hsv");
-dojo.deprecated("dojo.graphics.color.hsv has been replaced by dojo.gfx.color.hsv", "0.5");
-dojo.graphics.color.rgb2hsv = function (r, g, b) {
-	dojo.deprecated("dojo.graphics.color.rgb2hsv has been replaced by dojo.gfx.color.rgb2hsv", "0.5");
-	return dojo.gfx.color.rgb2hsv(r, g, b);
-};
-dojo.graphics.color.hsv2rgb = function (h, s, v) {
-	dojo.deprecated("dojo.graphics.color.hsv2rgb has been replaced by dojo.gfx.color.hsv2rgb", "0.5");
-	return dojo.gfx.color.hsv2rgb(h, s, v);
-};
+	toHsv: function() {
+		return dojo.graphics.color.rgb2hsv(this.toRgb());
+	}
 
+});
+
+dojo.graphics.color.rgb2hsv = function(r, g, b){
+
+	if (dojo.lang.isArray(r)) {
+		b = r[2] || 0;
+		g = r[1] || 0;
+		r = r[0] || 0;
+	}
+
+	// r,g,b, each 0 to 255, to HSV.
+	// h = 0.0 to 360.0 (corresponding to 0..360.0 degrees around hexcone)
+	// s = 0.0 (shade of gray) to 1.0 (pure color)
+	// v = 0.0 (black) to 1.0 {white)
+	//
+	// Based on C Code in "Computer Graphics -- Principles and Practice,"
+	// Foley et al, 1996, p. 592. 
+	//
+	// our calculatuions are based on 'regular' values (0-360, 0-1, 0-1) 
+	// but we return bytes values (0-255, 0-255, 0-255)
+
+	var h = null;
+	var s = null;
+	var v = null;
+
+	var min = Math.min(r, g, b);
+	v = Math.max(r, g, b);
+
+	var delta = v - min;
+
+	// calculate saturation (0 if r, g and b are all 0)
+
+	s = (v == 0) ? 0 : delta/v;
+
+	if (s == 0){
+		// achromatic: when saturation is, hue is undefined
+		h = 0;
+	}else{
+		// chromatic
+		if (r == v){
+			// between yellow and magenta
+			h = 60 * (g - b) / delta;
+		}else{
+			if (g == v){
+				// between cyan and yellow
+				h = 120 + 60 * (b - r) / delta;
+			}else{
+				if (b == v){
+					// between magenta and cyan
+					h = 240 + 60 * (r - g) / delta;
+				}
+			}
+		}
+		if (h < 0){
+			h += 360;
+		}
+	}
+
+
+	h = (h == 0) ? 360 : Math.ceil((h / 360) * 255);
+	s = Math.ceil(s * 255);
+
+	return [h, s, v];
+}
+
+dojo.graphics.color.hsv2rgb = function(h, s, v){
+ 
+	if (dojo.lang.isArray(h)) {
+		v = h[2] || 0;
+		s = h[1] || 0;
+		h = h[0] || 0;
+	}
+
+	h = (h / 255) * 360;
+	if (h == 360){ h = 0;}
+
+	s = s / 255;
+	v = v / 255;
+
+	// Based on C Code in "Computer Graphics -- Principles and Practice,"
+	// Foley et al, 1996, p. 593.
+	//
+	// H = 0.0 to 360.0 (corresponding to 0..360 degrees around hexcone) 0 for S = 0
+	// S = 0.0 (shade of gray) to 1.0 (pure color)
+	// V = 0.0 (black) to 1.0 (white)
+
+	var r = null;
+	var g = null;
+	var b = null;
+
+	if (s == 0){
+		// color is on black-and-white center line
+		// achromatic: shades of gray
+		r = v;
+		g = v;
+		b = v;
+	}else{
+		// chromatic color
+		var hTemp = h / 60;		// h is now IN [0,6]
+		var i = Math.floor(hTemp);	// largest integer <= h
+		var f = hTemp - i;		// fractional part of h
+
+		var p = v * (1 - s);
+		var q = v * (1 - (s * f));
+		var t = v * (1 - (s * (1 - f)));
+
+		switch(i){
+			case 0: r = v; g = t; b = p; break;
+			case 1: r = q; g = v; b = p; break;
+			case 2: r = p; g = v; b = t; break;
+			case 3: r = p; g = q; b = v; break;
+			case 4: r = t; g = p; b = v; break;
+			case 5: r = v; g = p; b = q; break;
+		}
+	}
+
+	r = Math.ceil(r * 255);
+	g = Math.ceil(g * 255);
+	b = Math.ceil(b * 255);
+
+	return [r, g, b];
+}

Modified: tags/parley-0.53/root/static/magic/src/graphics/color.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/graphics/color.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/graphics/color.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,31 +8,159 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.graphics.color");
+dojo.require("dojo.lang.array");
 
+// TODO: rewrite the "x2y" methods to take advantage of the parsing
+//       abilities of the Color object. Also, beef up the Color
+//       object (as possible) to parse most common formats
 
-dojo.provide("dojo.graphics.color");
-dojo.require("dojo.gfx.color");
-dojo.deprecated("dojo.graphics.color.Color is now dojo.gfx.color.Color.", "0.5");
-dojo.graphics.color.Color = dojo.gfx.color.Color;
-dojo.graphics.color.named = dojo.gfx.color.named;
-dojo.graphics.color.blend = function (a, b, weight) {
-	dojo.deprecated("dojo.graphics.color.blend is now dojo.gfx.color.blend", "0.5");
-	return dojo.gfx.color.blend(a, b, weight);
+// takes an r, g, b, a(lpha) value, [r, g, b, a] array, "rgb(...)" string, hex string (#aaa, #aaaaaa, aaaaaaa)
+dojo.graphics.color.Color = function(r, g, b, a) {
+	// dojo.debug("r:", r[0], "g:", r[1], "b:", r[2]);
+	if(dojo.lang.isArray(r)) {
+		this.r = r[0];
+		this.g = r[1];
+		this.b = r[2];
+		this.a = r[3]||1.0;
+	} else if(dojo.lang.isString(r)) {
+		var rgb = dojo.graphics.color.extractRGB(r);
+		this.r = rgb[0];
+		this.g = rgb[1];
+		this.b = rgb[2];
+		this.a = g||1.0;
+	} else if(r instanceof dojo.graphics.color.Color) {
+		this.r = r.r;
+		this.b = r.b;
+		this.g = r.g;
+		this.a = r.a;
+	} else {
+		this.r = r;
+		this.g = g;
+		this.b = b;
+		this.a = a;
+	}
+}
+
+dojo.graphics.color.Color.fromArray = function(arr) {
+	return new dojo.graphics.color.Color(arr[0], arr[1], arr[2], arr[3]);
+}
+
+dojo.lang.extend(dojo.graphics.color.Color, {
+	toRgb: function(includeAlpha) {
+		if(includeAlpha) {
+			return this.toRgba();
+		} else {
+			return [this.r, this.g, this.b];
+		}
+	},
+
+	toRgba: function() {
+		return [this.r, this.g, this.b, this.a];
+	},
+
+	toHex: function() {
+		return dojo.graphics.color.rgb2hex(this.toRgb());
+	},
+
+	toCss: function() {
+		return "rgb(" + this.toRgb().join() + ")";
+	},
+
+	toString: function() {
+		return this.toHex(); // decent default?
+	},
+
+	blend: function(color, weight) {
+		return dojo.graphics.color.blend(this.toRgb(), new dojo.graphics.color.Color(color).toRgb(), weight);
+	}
+});
+
+dojo.graphics.color.named = {
+	white:      [255,255,255],
+	black:      [0,0,0],
+	red:        [255,0,0],
+	green:	    [0,255,0],
+	blue:       [0,0,255],
+	navy:       [0,0,128],
+	gray:       [128,128,128],
+	silver:     [192,192,192]
 };
-dojo.graphics.color.blendHex = function (a, b, weight) {
-	dojo.deprecated("dojo.graphics.color.blendHex is now dojo.gfx.color.blendHex", "0.5");
-	return dojo.gfx.color.rgb2hex(dojo.gfx.color.blend(dojo.gfx.color.hex2rgb(a), dojo.gfx.color.hex2rgb(b), weight));
-};
-dojo.graphics.color.extractRGB = function (color) {
-	dojo.deprecated("dojo.graphics.color.extractRGB is now dojo.gfx.color.extractRGB", "0.5");
-	return dojo.gfx.color.extractRGB(color);
-};
-dojo.graphics.color.hex2rgb = function (hex) {
-	dojo.deprecated("dojo.graphics.color.hex2rgb is now dojo.gfx.color.hex2rgb", "0.5");
-	return dojo.gfx.color.hex2rgb(hex);
-};
-dojo.graphics.color.rgb2hex = function (r, g, b) {
-	dojo.deprecated("dojo.graphics.color.rgb2hex is now dojo.gfx.color.rgb2hex", "0.5");
-	return dojo.gfx.color.rgb2hex;
-};
 
+// blend colors a and b (both as RGB array or hex strings) with weight from -1 to +1, 0 being a 50/50 blend
+dojo.graphics.color.blend = function(a, b, weight) {
+	if(typeof a == "string") { return dojo.graphics.color.blendHex(a, b, weight); }
+	if(!weight) { weight = 0; }
+	else if(weight > 1) { weight = 1; }
+	else if(weight < -1) { weight = -1; }
+	var c = new Array(3);
+	for(var i = 0; i < 3; i++) {
+		var half = Math.abs(a[i] - b[i])/2;
+		c[i] = Math.floor(Math.min(a[i], b[i]) + half + (half * weight));
+	}
+	return c;
+}
+
+// very convenient blend that takes and returns hex values
+// (will get called automatically by blend when blend gets strings)
+dojo.graphics.color.blendHex = function(a, b, weight) {
+	return dojo.graphics.color.rgb2hex(dojo.graphics.color.blend(dojo.graphics.color.hex2rgb(a), dojo.graphics.color.hex2rgb(b), weight));
+}
+
+// get RGB array from css-style color declarations
+dojo.graphics.color.extractRGB = function(color) {
+	var hex = "0123456789abcdef";
+	color = color.toLowerCase();
+	if( color.indexOf("rgb") == 0 ) {
+		var matches = color.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
+		var ret = matches.splice(1, 3);
+		return ret;
+	} else {
+		var colors = dojo.graphics.color.hex2rgb(color);
+		if(colors) {
+			return colors;
+		} else {
+			// named color (how many do we support?)
+			return dojo.graphics.color.named[color] || [255, 255, 255];
+		}
+	}
+}
+
+dojo.graphics.color.hex2rgb = function(hex) {
+	var hexNum = "0123456789ABCDEF";
+	var rgb = new Array(3);
+	if( hex.indexOf("#") == 0 ) { hex = hex.substring(1); }
+	hex = hex.toUpperCase();
+	if(hex.replace(new RegExp("["+hexNum+"]", "g"), "") != "") {
+		return null;
+	}
+	if( hex.length == 3 ) {
+		rgb[0] = hex.charAt(0) + hex.charAt(0)
+		rgb[1] = hex.charAt(1) + hex.charAt(1)
+		rgb[2] = hex.charAt(2) + hex.charAt(2);
+	} else {
+		rgb[0] = hex.substring(0, 2);
+		rgb[1] = hex.substring(2, 4);
+		rgb[2] = hex.substring(4);
+	}
+	for(var i = 0; i < rgb.length; i++) {
+		rgb[i] = hexNum.indexOf(rgb[i].charAt(0)) * 16 + hexNum.indexOf(rgb[i].charAt(1));
+	}
+	return rgb;
+}
+
+dojo.graphics.color.rgb2hex = function(r, g, b) {
+	if(dojo.lang.isArray(r)) {
+		g = r[1] || 0;
+		b = r[2] || 0;
+		r = r[0] || 0;
+	}
+	var ret = dojo.lang.map([r, g, b], function(x) {
+		x = new Number(x);
+		var s = x.toString(16);
+		while(s.length < 2) { s = "0" + s; }
+		return s;
+	});
+	ret.unshift("#");
+	return ret.join("");
+}

Modified: tags/parley-0.53/root/static/magic/src/hostenv_adobesvg.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_adobesvg.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_adobesvg.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,246 +8,376 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-if (typeof window == "undefined") {
+/*
+ * Adobe SVG Viewer host environment
+ */
+if(typeof window == 'undefined'){
 	dojo.raise("attempt to use adobe svg hostenv when no window object");
 }
-with (dojo.render) {
+
+with(dojo.render){
 	name = navigator.appName;
 	ver = parseFloat(navigator.appVersion, 10);
-	switch (navigator.platform) {
-	  case "MacOS":
-		os.osx = true;
-		break;
-	  case "Linux":
-		os.linux = true;
-		break;
-	  case "Windows":
-		os.win = true;
-		break;
-	  default:
-		os.linux = true;
-		break;
-	}
+	switch(navigator.platform){
+		case "MacOS":
+			os.osx =  true;
+			break;
+		case "Linux":
+			os.linux =  true;
+			break;
+		case "Windows":
+			os.win =  true;
+			break;
+		default:
+			os.linux = true;
+			break;
+	};
 	svg.capable = true;
 	svg.support.builtin = true;
 	svg.adobe = true;
-}
-dojo.hostenv.println = function (s) {
-	try {
-		var ti = document.createElement("text");
-		ti.setAttribute("x", "50");
-		var yPos = 25 + 15 * document.getElementsByTagName("text").length;
-		ti.setAttribute("y", yPos);
+};
+
+// browserEval("alert(window.location);");
+
+dojo.hostenv.println = function(s){
+	try{
+    // FIXME: this may not work with adobe's viewer, as we may first need a 
+		// reference to the svgDocument
+		// FIXME: need a way to determine where to position the text for this
+    var ti = document.createElement("text");
+    ti.setAttribute("x","50");
+		var yPos = 25 + 15*document.getElementsByTagName("text").length;
+    ti.setAttribute("y",yPos);
 		var tn = document.createTextNode(s);
 		ti.appendChild(tn);
 		document.documentElement.appendChild(ti);
+	}catch(e){
+
 	}
-	catch (e) {
-	}
-};
-dojo.debug = function () {
-	if (!djConfig.isDebug) {
-		return;
-	}
+}
+
+dojo.debug = function() {
+	if (!djConfig.isDebug) { return; }
 	var args = arguments;
-	if (typeof dojo.hostenv.println != "function") {
+	if(typeof dojo.hostenv.println != 'function'){
 		dojo.raise("attempt to call dojo.debug when there is no dojo.hostenv println implementation (yet?)");
 	}
 	var isJUM = dj_global["jum"];
-	var s = isJUM ? "" : "DEBUG: ";
-	for (var i = 0; i < args.length; ++i) {
-		s += args[i];
-	}
-	if (isJUM) {
+	var s = isJUM ? "": "DEBUG: ";
+	for(var i=0;i<args.length;++i){ s += args[i]; }
+	if(isJUM){ // this seems to be the only way to get JUM to "play nice"
 		jum.debug(s);
-	} else {
+	}else{
 		dojo.hostenv.println(s);
 	}
-};
+}
+
 dojo.hostenv.startPackage("dojo.hostenv");
-dojo.hostenv.name_ = "adobesvg";
+
+dojo.hostenv.name_ = 'adobesvg';
+
 dojo.hostenv.anonCtr = 0;
 dojo.hostenv.anon = {};
-dojo.hostenv.nameAnonFunc = function (anonFuncPtr, namespaceObj) {
-	var ret = "_" + this.anonCtr++;
+
+dojo.hostenv.nameAnonFunc = function(anonFuncPtr, namespaceObj){
+	var ret = "_"+this.anonCtr++;
 	var nso = (namespaceObj || this.anon);
-	while (typeof nso[ret] != "undefined") {
-		ret = "_" + this.anonCtr++;
+	while(typeof nso[ret] != "undefined"){
+		ret = "_"+this.anonCtr++;
 	}
 	nso[ret] = anonFuncPtr;
 	return ret;
-};
+}
+
 dojo.hostenv.modulesLoadedFired = false;
 dojo.hostenv.modulesLoadedListeners = [];
 dojo.hostenv.getTextStack = [];
 dojo.hostenv.loadUriStack = [];
 dojo.hostenv.loadedUris = [];
-dojo.hostenv.modulesLoaded = function () {
-	if (this.modulesLoadedFired) {
-		return;
-	}
-	if ((this.loadUriStack.length == 0) && (this.getTextStack.length == 0)) {
-		if (this.inFlightCount > 0) {
+
+
+dojo.hostenv.modulesLoaded = function(){
+	if(this.modulesLoadedFired){ return; }
+	if((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){
+		if(this.inFlightCount > 0){ 
 			dojo.debug("couldn't initialize, there are files still in flight");
 			return;
 		}
 		this.modulesLoadedFired = true;
 		var mll = this.modulesLoadedListeners;
-		for (var x = 0; x < mll.length; x++) {
+		for(var x=0; x<mll.length; x++){
 			mll[x]();
 		}
 	}
-};
-dojo.hostenv.getNewAnonFunc = function () {
-	var ret = "_" + this.anonCtr++;
-	while (typeof this.anon[ret] != "undefined") {
-		ret = "_" + this.anonCtr++;
+}
+
+dojo.hostenv.getNewAnonFunc = function(){
+	var ret = "_"+this.anonCtr++;
+	while(typeof this.anon[ret] != "undefined"){
+		ret = "_"+this.anonCtr++;
 	}
-	eval("dojo.nostenv.anon." + ret + " = function(){};");
+	// this.anon[ret] = function(){};
+	eval("dojo.nostenv.anon."+ret+" = function(){};");
 	return [ret, this.anon[ret]];
-};
-dojo.hostenv.displayStack = function () {
+}
+
+dojo.hostenv.displayStack = function(){
 	var oa = [];
 	var stack = this.loadUriStack;
-	for (var x = 0; x < stack.length; x++) {
+	for(var x=0; x<stack.length; x++){
 		oa.unshift([stack[x][0], (typeof stack[x][2])]);
 	}
-	dojo.debug("<pre>" + oa.join("\n") + "</pre>");
-};
-dojo.hostenv.unwindUriStack = function () {
+	dojo.debug("<pre>"+oa.join("\n")+"</pre>");
+}
+
+dojo.hostenv.unwindUriStack = function(){
 	var stack = this.loadUriStack;
-	for (var x in dojo.hostenv.loadedUris) {
-		for (var y = stack.length - 1; y >= 0; y--) {
-			if (stack[y][0] == x) {
+	for(var x in dojo.hostenv.loadedUris){
+		for(var y=stack.length-1; y>=0; y--){
+			if(stack[y][0]==x){
 				stack.splice(y, 1);
 			}
 		}
 	}
 	var next = stack.pop();
-	if ((!next) && (stack.length == 0)) {
+	if((!next)&&(stack.length==0)){ 
 		return;
 	}
-	for (var x = 0; x < stack.length; x++) {
-		if ((stack[x][0] == next[0]) && (stack[x][2])) {
-			next[2] == stack[x][2];
+	for(var x=0; x<stack.length; x++){
+		if((stack[x][0]==next[0])&&(stack[x][2])){
+			next[2] == stack[x][2]
 		}
 	}
 	var last = next;
-	while (dojo.hostenv.loadedUris[next[0]]) {
+	while(dojo.hostenv.loadedUris[next[0]]){
 		last = next;
 		next = stack.pop();
 	}
-	while (typeof next[2] == "string") {
-		try {
+	while(typeof next[2] == "string"){ // unwind as far as we can
+		try{
+			// dojo.debug("<pre><![CDATA["+next[2]+"]]></pre>");
 			dj_eval(next[2]);
 			next[1](true);
+		}catch(e){
+			dojo.debug("we got an error when loading "+next[0]);
+			dojo.debug("error: "+e);
+			// for(var x in e){ alert(x+" "+e[x]); }
 		}
-		catch (e) {
-			dojo.debug("we got an error when loading " + next[0]);
-			dojo.debug("error: " + e);
-		}
 		dojo.hostenv.loadedUris[next[0]] = true;
 		dojo.hostenv.loadedUris.push(next[0]);
 		last = next;
 		next = stack.pop();
-		if ((!next) && (stack.length == 0)) {
-			break;
-		}
-		while (dojo.hostenv.loadedUris[next[0]]) {
+		if((!next)&&(stack.length==0)){ break; }
+		while(dojo.hostenv.loadedUris[next[0]]){
 			last = next;
 			next = stack.pop();
 		}
 	}
-	if (next) {
+	if(next){
 		stack.push(next);
-		dojo.debug("### CHOKED ON: " + next[0]);
+		dojo.debug("### CHOKED ON: "+next[0]);
 	}
-};
-dojo.hostenv.loadUri = function (uri, cb) {
-	if (dojo.hostenv.loadedUris[uri]) {
+}
+
+/**
+ * Reads the contents of the URI, and evaluates the contents.
+ * Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.
+ * The result of the eval is not available to the caller.
+ */
+dojo.hostenv.loadUri = function(uri, cb){
+	if(dojo.hostenv.loadedUris[uri]){
 		return;
 	}
 	var stack = this.loadUriStack;
 	stack.push([uri, cb, null]);
-	var tcb = function (contents) {
-		if (contents.content) {
+	var tcb = function(contents){
+		// gratuitous hack for Adobe SVG 3, what a fucking POS
+		if(contents.content){
 			contents = contents.content;
 		}
+
+		// stack management
 		var next = stack.pop();
-		if ((!next) && (stack.length == 0)) {
+		if((!next)&&(stack.length==0)){ 
 			dojo.hostenv.modulesLoaded();
 			return;
 		}
-		if (typeof contents == "string") {
+		if(typeof contents == "string"){
 			stack.push(next);
-			for (var x = 0; x < stack.length; x++) {
-				if (stack[x][0] == uri) {
+			for(var x=0; x<stack.length; x++){
+				if(stack[x][0]==uri){
 					stack[x][2] = contents;
 				}
 			}
 			next = stack.pop();
 		}
-		if (dojo.hostenv.loadedUris[next[0]]) {
+		if(dojo.hostenv.loadedUris[next[0]]){ 
+			// dojo.debug("WE ALREADY HAD: "+next[0]);
 			dojo.hostenv.unwindUriStack();
 			return;
 		}
+		// push back onto stack
 		stack.push(next);
-		if (next[0] != uri) {
-			if (typeof next[2] == "string") {
+		if(next[0]!=uri){
+			//  and then unwind as far as we can
+			if(typeof next[2] == "string"){
 				dojo.hostenv.unwindUriStack();
 			}
-		} else {
-			if (!contents) {
+
+		}else{
+			if(!contents){ 
 				next[1](false);
-			} else {
+			}else{
 				var deps = dojo.hostenv.getDepsForEval(next[2]);
-				if (deps.length > 0) {
+				if(deps.length>0){
 					eval(deps.join(";"));
-				} else {
+				}else{
 					dojo.hostenv.unwindUriStack();
 				}
 			}
 		}
-	};
+	}
 	this.getText(uri, tcb, true);
-};
-dojo.hostenv.loadModule = function (modulename, exact_only, omit_module_check) {
+}
+
+/**
+ * Reads the contents of the URI, and evaluates the contents.
+ * Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.
+ * The result of the eval is not available to the caller.
+ */
+dojo.hostenv.loadUri = function(uri, cb){
+	if(dojo.hostenv.loadedUris[uri]){
+		return;
+	}
+	var stack = this.loadUriStack;
+	stack.push([uri, cb, null]);
+	var tcb = function(contents){
+		// gratuitous hack for Adobe SVG 3, what a fucking POS
+		if(contents.content){
+			contents = contents.content;
+		}
+
+		// stack management
+		var next = stack.pop();
+		if((!next)&&(stack.length==0)){ 
+			dojo.hostenv.modulesLoaded();
+			return;
+		}
+		if(typeof contents == "string"){
+			stack.push(next);
+			for(var x=0; x<stack.length; x++){
+				if(stack[x][0]==uri){
+					stack[x][2] = contents;
+				}
+			}
+			next = stack.pop();
+		}
+		if(dojo.hostenv.loadedUris[next[0]]){ 
+			// dojo.debug("WE ALREADY HAD: "+next[0]);
+			dojo.hostenv.unwindUriStack();
+			return;
+		}
+		// push back onto stack
+		stack.push(next);
+		if(next[0]!=uri){
+			//  and then unwind as far as we can
+			if(typeof next[2] == "string"){
+				dojo.hostenv.unwindUriStack();
+			}
+
+		}else{
+			if(!contents){ 
+				next[1](false);
+			}else{
+				var deps = dojo.hostenv.getDepsForEval(next[2]);
+				if(deps.length>0){
+					eval(deps.join(";"));
+				}else{
+					dojo.hostenv.unwindUriStack();
+				}
+			}
+		}
+	}
+	this.getText(uri, tcb, true);
+}
+
+/**
+* loadModule("A.B") first checks to see if symbol A.B is defined. 
+* If it is, it is simply returned (nothing to do).
+* If it is not defined, it will look for "A/B.js" in the script root directory, followed
+* by "A.js".
+* It throws if it cannot find a file to load, or if the symbol A.B is not defined after loading.
+* It returns the object A.B.
+*
+* This does nothing about importing symbols into the current package.
+* It is presumed that the caller will take care of that. For example, to import
+* all symbols:
+*
+*    with (dojo.hostenv.loadModule("A.B")) {
+*       ...
+*    }
+*
+* And to import just the leaf symbol:
+*
+*    var B = dojo.hostenv.loadModule("A.B");
+*    ...
+*
+* dj_load is an alias for dojo.hostenv.loadModule
+*/
+dojo.hostenv.loadModule = function(modulename, exact_only, omit_module_check){
+	// alert("dojo.hostenv.loadModule('"+modulename+"');");
 	var module = this.findModule(modulename, 0);
-	if (module) {
+	if(module){
 		return module;
 	}
-	if (typeof this.loading_modules_[modulename] !== "undefined") {
+
+	// dojo.debug("dojo.hostenv.loadModule('"+modulename+"');");
+
+	// protect against infinite recursion from mutual dependencies
+	if (typeof this.loading_modules_[modulename] !== 'undefined'){
+		// NOTE: this should never throw an exception!! "recursive" includes
+		// are normal in the course of app and module building, so blow out of
+		// it gracefully, but log it in debug mode
+
+		// dojo.raise("recursive attempt to load module '" + modulename + "'");
 		dojo.debug("recursive attempt to load module '" + modulename + "'");
-	} else {
+	}else{
 		this.addedToLoadingCount.push(modulename);
 	}
 	this.loading_modules_[modulename] = 1;
-	var relpath = modulename.replace(/\./g, "/") + ".js";
+
+
+	// convert periods to slashes
+	var relpath = modulename.replace(/\./g, '/') + '.js';
+
 	var syms = modulename.split(".");
 	var nsyms = modulename.split(".");
-	if (syms[0] == "dojo") {
-		syms[0] = "src";
+	if(syms[0]=="dojo"){ // FIXME: need a smarter way to do this!
+		syms[0] = "src"; 
 	}
 	var last = syms.pop();
 	syms.push(last);
+	// figure out if we're looking for a full package, if so, we want to do
+	// things slightly diffrently
 	var _this = this;
 	var pfn = this.pkgFileName;
-	if (last == "*") {
-		modulename = (nsyms.slice(0, -1)).join(".");
+	if(last=="*"){
+		modulename = (nsyms.slice(0, -1)).join('.');
+
 		var module = this.findModule(modulename, 0);
-		if (module) {
+		// dojo.debug("found: "+modulename+"="+module);
+		if(module){
 			_this.removedFromLoadingCount.push(modulename);
 			return module;
 		}
-		var nextTry = function (lastStatus) {
-			if (lastStatus) {
-				module = _this.findModule(modulename, false);
-				if ((!module) && (syms[syms.length - 1] != pfn)) {
-					dojo.raise("Module symbol '" + modulename + "' is not defined after loading '" + relpath + "'");
+
+		var nextTry = function(lastStatus){
+			if(lastStatus){ 
+				module = _this.findModule(modulename, false); // pass in false so we can give better error
+				if((!module)&&(syms[syms.length-1]!=pfn)){
+					dojo.raise("Module symbol '" + modulename + "' is not defined after loading '" + relpath + "'"); 
 				}
-				if (module) {
+				if(module){
 					_this.removedFromLoadingCount.push(modulename);
 					dojo.hostenv.modulesLoaded();
 					return;
@@ -255,126 +385,187 @@
 			}
 			syms.pop();
 			syms.push(pfn);
-			relpath = syms.join("/") + ".js";
-			if (relpath.charAt(0) == "/") {
+			// dojo.debug("syms: "+syms);
+			relpath = syms.join("/") + '.js';
+			if(relpath.charAt(0)=="/"){
 				relpath = relpath.slice(1);
 			}
+			// dojo.debug("relpath: "+relpath);
 			_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
-		};
+		}
+
 		nextTry();
-	} else {
-		relpath = syms.join("/") + ".js";
-		modulename = nsyms.join(".");
-		var nextTry = function (lastStatus) {
-			if (lastStatus) {
-				module = _this.findModule(modulename, false);
-				if ((!module) && (syms[syms.length - 1] != pfn)) {
-					dojo.raise("Module symbol '" + modulename + "' is not defined after loading '" + relpath + "'");
+	}else{
+		relpath = syms.join("/") + '.js';
+		modulename = nsyms.join('.');
+
+		var nextTry = function(lastStatus){
+			// dojo.debug("lastStatus: "+lastStatus);
+			if(lastStatus){ 
+				// dojo.debug("inital relpath: "+relpath);
+				module = _this.findModule(modulename, false); // pass in false so we can give better error
+				// if(!module){
+				if((!module)&&(syms[syms.length-1]!=pfn)){
+					dojo.raise("Module symbol '" + modulename + "' is not defined after loading '" + relpath + "'"); 
 				}
-				if (module) {
+				if(module){
 					_this.removedFromLoadingCount.push(modulename);
 					dojo.hostenv.modulesLoaded();
 					return;
 				}
 			}
-			var setPKG = (syms[syms.length - 1] == pfn) ? false : true;
+			var setPKG = (syms[syms.length-1]==pfn) ? false : true;
 			syms.pop();
-			if (setPKG) {
+			if(setPKG){
 				syms.push(pfn);
 			}
-			relpath = syms.join("/") + ".js";
-			if (relpath.charAt(0) == "/") {
+			relpath = syms.join("/") + '.js';
+			if(relpath.charAt(0)=="/"){
 				relpath = relpath.slice(1);
 			}
+			// dojo.debug("relpath: "+relpath);
 			_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
-		};
+		}
+
 		this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
 	}
 	return;
-};
+}
+
+/**
+ * Read the contents of the specified uri and return those contents.
+ *
+ * FIXME: Make sure this is consistent with other implementations of getText
+ * @param uri A relative or absolute uri. If absolute, it still must be in the same "domain" as we are.
+ * @param async_cb If not specified, returns false as synchronous is not
+ * supported. If specified, load asynchronously, and use async_cb as the handler which receives the result of the request.
+ * @param fail_ok Default false. If fail_ok and !async_cb and loading fails, return null instead of throwing.
+ */ 
 dojo.hostenv.async_cb = null;
-dojo.hostenv.unWindGetTextStack = function () {
-	if (dojo.hostenv.inFlightCount > 0) {
+
+dojo.hostenv.unWindGetTextStack = function(){
+	if(dojo.hostenv.inFlightCount>0){
 		setTimeout("dojo.hostenv.unWindGetTextStack()", 100);
 		return;
 	}
+	// we serialize because this goddamned environment is too fucked up
+	// to know how to do anything else
 	dojo.hostenv.inFlightCount++;
 	var next = dojo.hostenv.getTextStack.pop();
-	if ((!next) && (dojo.hostenv.getTextStack.length == 0)) {
+	if((!next)&&(dojo.hostenv.getTextStack.length==0)){ 
 		dojo.hostenv.inFlightCount--;
-		dojo.hostenv.async_cb = function () {
-		};
+		dojo.hostenv.async_cb = function(){};
 		return;
 	}
 	dojo.hostenv.async_cb = next[1];
-	window.getURL(next[0], function (result) {
+	// http = window.getURL(uri, dojo.hostenv.anon[cbn]);
+	window.getURL(next[0], function(result){ 
 		dojo.hostenv.inFlightCount--;
 		dojo.hostenv.async_cb(result.content);
 		dojo.hostenv.unWindGetTextStack();
 	});
-};
-dojo.hostenv.getText = function (uri, async_cb, fail_ok) {
-	try {
-		if (async_cb) {
+}
+
+dojo.hostenv.getText = function(uri, async_cb, fail_ok){
+	// dojo.debug("Calling getText()");
+	try{
+		if(async_cb){
 			dojo.hostenv.getTextStack.push([uri, async_cb, fail_ok]);
 			dojo.hostenv.unWindGetTextStack();
-		} else {
+		}else{
 			return dojo.raise("No synchronous XMLHTTP implementation available, for uri " + uri);
 		}
-	}
-	catch (e) {
+	}catch(e){
 		return dojo.raise("No XMLHTTP implementation available, for uri " + uri);
 	}
-};
-dojo.hostenv.postText = function (uri, async_cb, text, fail_ok, mime_type, encoding) {
+}
+
+
+/**
+ * Makes an async post to the specified uri.
+ *
+ * FIXME: Not sure that we need this, but adding for completeness.
+ * More details about the implementation of this are available at 
+ * http://wiki.svg.org/index.php/PostUrl
+ * @param uri A relative or absolute uri. If absolute, it still must be in the same "domain" as we are.
+ * @param async_cb If not specified, returns false as synchronous is not
+ * supported. If specified, load asynchronously, and use async_cb as the progress handler which takes the xmlhttp object as its argument. If async_cb, this function returns null.
+ * @param text Data to post
+ * @param fail_ok Default false. If fail_ok and !async_cb and loading fails, return null instead of throwing.
+ * @param mime_type optional MIME type of the posted data (such as "text/plain")
+ * @param encoding optional encoding for data. null, 'gzip' and 'deflate' are possible values. If browser does not support binary post this parameter is ignored.
+ */ 
+dojo.hostenv.postText = function(uri, async_cb, text, fail_ok, mime_type, encoding){
 	var http = null;
-	var async_callback = function (httpResponse) {
+	
+	var async_callback = function(httpResponse){
 		if (!httpResponse.success) {
 			dojo.raise("Request for uri '" + uri + "' resulted in " + httpResponse.status);
 		}
-		if (!httpResponse.content) {
-			if (!fail_ok) {
-				dojo.raise("Request for uri '" + uri + "' resulted in no content");
-			}
+		
+		if(!httpResponse.content) {
+			if (!fail_ok) dojo.raise("Request for uri '" + uri + "' resulted in no content");
 			return null;
 		}
+		// FIXME: wtf, I'm losing a reference to async_cb
 		async_cb(httpResponse.content);
-	};
+	}
+	
 	try {
-		if (async_cb) {
+		if(async_cb) {
 			http = window.postURL(uri, text, async_callback, mimeType, encoding);
 		} else {
-			return dojo.raise("No synchronous XMLHTTP post implementation available, for uri " + uri);
+		return dojo.raise("No synchronous XMLHTTP post implementation available, for uri " + uri);
 		}
-	}
-	catch (e) {
+	} catch(e) {
 		return dojo.raise("No XMLHTTP post implementation available, for uri " + uri);
 	}
-};
+}
+
+/*
+ * It turns out that if we check *right now*, as this script file is being loaded,
+ * then the last script element in the window DOM is ourselves.
+ * That is because any subsequent script elements haven't shown up in the document
+ * object yet.
+ */
 function dj_last_script_src() {
-	var scripts = window.document.getElementsByTagName("script");
-	if (scripts.length < 1) {
-		dojo.raise("No script elements in window.document, so can't figure out my script src");
+	var scripts = window.document.getElementsByTagName('script');
+	if(scripts.length < 1){ 
+		dojo.raise("No script elements in window.document, so can't figure out my script src"); 
 	}
-	var li = scripts.length - 1;
+	var li = scripts.length-1;
 	var xlinkNS = "http://www.w3.org/1999/xlink";
 	var src = null;
 	var script = null;
-	while (!src) {
+	while(!src){
 		script = scripts.item(li);
-		src = script.getAttributeNS(xlinkNS, "href");
+		src = script.getAttributeNS(xlinkNS,"href");
 		li--;
-		if (li < 0) {
-			break;
-		}
+		if(li<0){ break; }
+		// break;
 	}
-	if (!src) {
+	if(!src){
 		dojo.raise("Last script element (out of " + scripts.length + ") has no src");
 	}
 	return src;
 }
-if (!dojo.hostenv["library_script_uri_"]) {
+
+if(!dojo.hostenv["library_script_uri_"]){
 	dojo.hostenv.library_script_uri_ = dj_last_script_src();
 }
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");
 
+// dojo.hostenv.loadUri = function(uri){
+	/* FIXME: adding a script element doesn't seem to be synchronous, and so
+	 * checking for namespace or object existance after loadUri using this
+	 * method will error out. Need to figure out some other way of handling
+	 * this!
+	 */
+	/*
+	var se = document.createElement("script");
+	se.src = uri;
+	var head = document.getElementsByTagName("head")[0];
+	head.appendChild(se);
+	// document.write("<script type='text/javascript' src='"+uri+"' />");
+	return 1;
+}
+*/

Modified: tags/parley-0.53/root/static/magic/src/hostenv_browser.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_browser.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_browser.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,410 +8,353 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+if(typeof window == 'undefined'){
+	dojo.raise("no window object");
+}
 
-
-if (typeof window != "undefined") {
-	(function () {
-		if (djConfig.allowQueryConfig) {
-			var baseUrl = document.location.toString();
-			var params = baseUrl.split("?", 2);
-			if (params.length > 1) {
-				var paramStr = params[1];
-				var pairs = paramStr.split("&");
-				for (var x in pairs) {
-					var sp = pairs[x].split("=");
-					if ((sp[0].length > 9) && (sp[0].substr(0, 9) == "djConfig.")) {
-						var opt = sp[0].substr(9);
-						try {
-							djConfig[opt] = eval(sp[1]);
-						}
-						catch (e) {
-							djConfig[opt] = sp[1];
-						}
+// attempt to figure out the path to dojo if it isn't set in the config
+(function() {
+	// before we get any further with the config options, try to pick them out
+	// of the URL. Most of this code is from NW
+	if(djConfig.allowQueryConfig){
+		var baseUrl = document.location.toString(); // FIXME: use location.query instead?
+		var params = baseUrl.split("?", 2);
+		if(params.length > 1){
+			var paramStr = params[1];
+			var pairs = paramStr.split("&");
+			for(var x in pairs){
+				var sp = pairs[x].split("=");
+				// FIXME: is this eval dangerous?
+				if((sp[0].length > 9)&&(sp[0].substr(0, 9) == "djConfig.")){
+					var opt = sp[0].substr(9);
+					try{
+						djConfig[opt]=eval(sp[1]);
+					}catch(e){
+						djConfig[opt]=sp[1];
 					}
 				}
 			}
 		}
-		if (((djConfig["baseScriptUri"] == "") || (djConfig["baseRelativePath"] == "")) && (document && document.getElementsByTagName)) {
-			var scripts = document.getElementsByTagName("script");
-			var rePkg = /(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
-			for (var i = 0; i < scripts.length; i++) {
-				var src = scripts[i].getAttribute("src");
-				if (!src) {
-					continue;
-				}
-				var m = src.match(rePkg);
-				if (m) {
-					var root = src.substring(0, m.index);
-					if (src.indexOf("bootstrap1") > -1) {
-						root += "../";
-					}
-					if (!this["djConfig"]) {
-						djConfig = {};
-					}
-					if (djConfig["baseScriptUri"] == "") {
-						djConfig["baseScriptUri"] = root;
-					}
-					if (djConfig["baseRelativePath"] == "") {
-						djConfig["baseRelativePath"] = root;
-					}
-					break;
-				}
+	}
+
+	if(((djConfig["baseScriptUri"] == "")||(djConfig["baseRelativePath"] == "")) &&(document && document.getElementsByTagName)){
+		var scripts = document.getElementsByTagName("script");
+		var rePkg = /(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
+		for(var i = 0; i < scripts.length; i++) {
+			var src = scripts[i].getAttribute("src");
+			if(!src) { continue; }
+			var m = src.match(rePkg);
+			if(m) {
+				var root = src.substring(0, m.index);
+				if(src.indexOf("bootstrap1") > -1) { root += "../"; }
+				if(!this["djConfig"]) { djConfig = {}; }
+				if(djConfig["baseScriptUri"] == "") { djConfig["baseScriptUri"] = root; }
+				if(djConfig["baseRelativePath"] == "") { djConfig["baseRelativePath"] = root; }
+				break;
 			}
 		}
-		var dr = dojo.render;
-		var drh = dojo.render.html;
-		var drs = dojo.render.svg;
-		var dua = (drh.UA = navigator.userAgent);
-		var dav = (drh.AV = navigator.appVersion);
-		var t = true;
-		var f = false;
-		drh.capable = t;
-		drh.support.builtin = t;
-		dr.ver = parseFloat(drh.AV);
-		dr.os.mac = dav.indexOf("Macintosh") >= 0;
-		dr.os.win = dav.indexOf("Windows") >= 0;
-		dr.os.linux = dav.indexOf("X11") >= 0;
-		drh.opera = dua.indexOf("Opera") >= 0;
-		drh.khtml = (dav.indexOf("Konqueror") >= 0) || (dav.indexOf("Safari") >= 0);
-		drh.safari = dav.indexOf("Safari") >= 0;
-		var geckoPos = dua.indexOf("Gecko");
-		drh.mozilla = drh.moz = (geckoPos >= 0) && (!drh.khtml);
-		if (drh.mozilla) {
-			drh.geckoVersion = dua.substring(geckoPos + 6, geckoPos + 14);
-		}
-		drh.ie = (document.all) && (!drh.opera);
-		drh.ie50 = drh.ie && dav.indexOf("MSIE 5.0") >= 0;
-		drh.ie55 = drh.ie && dav.indexOf("MSIE 5.5") >= 0;
-		drh.ie60 = drh.ie && dav.indexOf("MSIE 6.0") >= 0;
-		drh.ie70 = drh.ie && dav.indexOf("MSIE 7.0") >= 0;
-		var cm = document["compatMode"];
-		drh.quirks = (cm == "BackCompat") || (cm == "QuirksMode") || drh.ie55 || drh.ie50;
-		dojo.locale = dojo.locale || (drh.ie ? navigator.userLanguage : navigator.language).toLowerCase();
-		dr.vml.capable = drh.ie;
-		drs.capable = f;
+	}
+
+	// fill in the rendering support information in dojo.render.*
+	var dr = dojo.render;
+	var drh = dojo.render.html;
+	var drs = dojo.render.svg;
+	var dua = drh.UA = navigator.userAgent;
+	var dav = drh.AV = navigator.appVersion;
+	var t = true;
+	var f = false;
+	drh.capable = t;
+	drh.support.builtin = t;
+
+	dr.ver = parseFloat(drh.AV);
+	dr.os.mac = dav.indexOf("Macintosh") >= 0;
+	dr.os.win = dav.indexOf("Windows") >= 0;
+	// could also be Solaris or something, but it's the same browser
+	dr.os.linux = dav.indexOf("X11") >= 0;
+
+	drh.opera = dua.indexOf("Opera") >= 0;
+	drh.khtml = (dav.indexOf("Konqueror") >= 0)||(dav.indexOf("Safari") >= 0);
+	drh.safari = dav.indexOf("Safari") >= 0;
+	var geckoPos = dua.indexOf("Gecko");
+	drh.mozilla = drh.moz = (geckoPos >= 0)&&(!drh.khtml);
+	if (drh.mozilla) {
+		// gecko version is YYYYMMDD
+		drh.geckoVersion = dua.substring(geckoPos + 6, geckoPos + 14);
+	}
+	drh.ie = (document.all)&&(!drh.opera);
+	drh.ie50 = drh.ie && dav.indexOf("MSIE 5.0")>=0;
+	drh.ie55 = drh.ie && dav.indexOf("MSIE 5.5")>=0;
+	drh.ie60 = drh.ie && dav.indexOf("MSIE 6.0")>=0;
+	drh.ie70 = drh.ie && dav.indexOf("MSIE 7.0")>=0;
+
+	// TODO: is the HTML LANG attribute relevant?
+	dojo.locale = (drh.ie ? navigator.userLanguage : navigator.language).toLowerCase();
+
+	dr.vml.capable=drh.ie;
+	drs.capable = f;
+	drs.support.plugin = f;
+	drs.support.builtin = f;
+	if (document.implementation
+		&& document.implementation.hasFeature
+		&& document.implementation.hasFeature("org.w3c.dom.svg", "1.0")
+	){
+		drs.capable = t;
+		drs.support.builtin = t;
 		drs.support.plugin = f;
-		drs.support.builtin = f;
-		var tdoc = window["document"];
-		var tdi = tdoc["implementation"];
-		if ((tdi) && (tdi["hasFeature"]) && (tdi.hasFeature("org.w3c.dom.svg", "1.0"))) {
-			drs.capable = t;
-			drs.support.builtin = t;
-			drs.support.plugin = f;
-		}
-		if (drh.safari) {
-			var tmp = dua.split("AppleWebKit/")[1];
-			var ver = parseFloat(tmp.split(" ")[0]);
-			if (ver >= 420) {
-				drs.capable = t;
-				drs.support.builtin = t;
-				drs.support.plugin = f;
+	}
+})();
+
+dojo.hostenv.startPackage("dojo.hostenv");
+
+dojo.render.name = dojo.hostenv.name_ = 'browser';
+dojo.hostenv.searchIds = [];
+
+// These are in order of decreasing likelihood; this will change in time.
+dojo.hostenv._XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
+
+dojo.hostenv.getXmlhttpObject = function(){
+    var http = null;
+	var last_e = null;
+	try{ http = new XMLHttpRequest(); }catch(e){}
+    if(!http){
+		for(var i=0; i<3; ++i){
+			var progid = dojo.hostenv._XMLHTTP_PROGIDS[i];
+			try{
+				http = new ActiveXObject(progid);
+			}catch(e){
+				last_e = e;
 			}
-		} else {
-		}
-	})();
-	dojo.hostenv.startPackage("dojo.hostenv");
-	dojo.render.name = dojo.hostenv.name_ = "browser";
-	dojo.hostenv.searchIds = [];
-	dojo.hostenv._XMLHTTP_PROGIDS = ["Msxml2.XMLHTTP", "Microsoft.XMLHTTP", "Msxml2.XMLHTTP.4.0"];
-	dojo.hostenv.getXmlhttpObject = function () {
-		var http = null;
-		var last_e = null;
-		try {
-			http = new XMLHttpRequest();
-		}
-		catch (e) {
-		}
-		if (!http) {
-			for (var i = 0; i < 3; ++i) {
-				var progid = dojo.hostenv._XMLHTTP_PROGIDS[i];
-				try {
-					http = new ActiveXObject(progid);
-				}
-				catch (e) {
-					last_e = e;
-				}
-				if (http) {
-					dojo.hostenv._XMLHTTP_PROGIDS = [progid];
-					break;
-				}
+
+			if(http){
+				dojo.hostenv._XMLHTTP_PROGIDS = [progid];  // so faster next time
+				break;
 			}
 		}
-		if (!http) {
-			return dojo.raise("XMLHTTP not available", last_e);
-		}
-		return http;
-	};
-	dojo.hostenv._blockAsync = false;
-	dojo.hostenv.getText = function (uri, async_cb, fail_ok) {
-		if (!async_cb) {
-			this._blockAsync = true;
-		}
-		var http = this.getXmlhttpObject();
-		function isDocumentOk(http) {
-			var stat = http["status"];
-			return Boolean((!stat) || ((200 <= stat) && (300 > stat)) || (stat == 304));
-		}
-		if (async_cb) {
-			var _this = this, timer = null, gbl = dojo.global();
-			var xhr = dojo.evalObjPath("dojo.io.XMLHTTPTransport");
-			http.onreadystatechange = function () {
-				if (timer) {
-					gbl.clearTimeout(timer);
-					timer = null;
+
+		/*if(http && !http.toString) {
+			http.toString = function() { "[object XMLHttpRequest]"; }
+		}*/
+	}
+
+	if(!http){
+		return dojo.raise("XMLHTTP not available", last_e);
+	}
+
+	return http;
+}
+
+/**
+ * Read the contents of the specified uri and return those contents.
+ *
+ * @param uri A relative or absolute uri. If absolute, it still must be in the
+ * same "domain" as we are.
+ *
+ * @param async_cb If not specified, load synchronously. If specified, load
+ * asynchronously, and use async_cb as the progress handler which takes the
+ * xmlhttp object as its argument. If async_cb, this function returns null.
+ *
+ * @param fail_ok Default false. If fail_ok and !async_cb and loading fails,
+ * return null instead of throwing.
+ */
+dojo.hostenv.getText = function(uri, async_cb, fail_ok){
+
+	var http = this.getXmlhttpObject();
+
+	if(async_cb){
+		http.onreadystatechange = function(){
+			if(4==http.readyState){
+				if((!http["status"])||((200 <= http.status)&&(300 > http.status))){
+					// dojo.debug("LOADED URI: "+uri);
+					async_cb(http.responseText);
 				}
-				if (_this._blockAsync || (xhr && xhr._blockAsync)) {
-					timer = gbl.setTimeout(function () {
-						http.onreadystatechange.apply(this);
-					}, 10);
-				} else {
-					if (4 == http.readyState) {
-						if (isDocumentOk(http)) {
-							async_cb(http.responseText);
-						}
-					}
-				}
-			};
-		}
-		http.open("GET", uri, async_cb ? true : false);
-		try {
-			http.send(null);
-			if (async_cb) {
-				return null;
 			}
-			if (!isDocumentOk(http)) {
-				var err = Error("Unable to load " + uri + " status:" + http.status);
-				err.status = http.status;
-				err.responseText = http.responseText;
-				throw err;
-			}
 		}
-		catch (e) {
-			this._blockAsync = false;
-			if ((fail_ok) && (!async_cb)) {
-				return null;
-			} else {
-				throw e;
-			}
-		}
-		this._blockAsync = false;
-		return http.responseText;
-	};
-	dojo.hostenv.defaultDebugContainerId = "dojoDebug";
-	dojo.hostenv._println_buffer = [];
-	dojo.hostenv._println_safe = false;
-	dojo.hostenv.println = function (line) {
-		if (!dojo.hostenv._println_safe) {
-			dojo.hostenv._println_buffer.push(line);
-		} else {
-			try {
-				var console = document.getElementById(djConfig.debugContainerId ? djConfig.debugContainerId : dojo.hostenv.defaultDebugContainerId);
-				if (!console) {
-					console = dojo.body();
-				}
-				var div = document.createElement("div");
-				div.appendChild(document.createTextNode(line));
-				console.appendChild(div);
-			}
-			catch (e) {
-				try {
-					document.write("<div>" + line + "</div>");
-				}
-				catch (e2) {
-					window.status = line;
-				}
-			}
-		}
-	};
-	dojo.addOnLoad(function () {
-		dojo.hostenv._println_safe = true;
-		while (dojo.hostenv._println_buffer.length > 0) {
-			dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
-		}
-	});
-	function dj_addNodeEvtHdlr(node, evtName, fp) {
-		var oldHandler = node["on" + evtName] || function () {
-		};
-		node["on" + evtName] = function () {
-			fp.apply(node, arguments);
-			oldHandler.apply(node, arguments);
-		};
-		return true;
 	}
-	dojo.hostenv._djInitFired = false;
-	function dj_load_init(e) {
-		dojo.hostenv._djInitFired = true;
-		var type = (e && e.type) ? e.type.toLowerCase() : "load";
-		if (arguments.callee.initialized || (type != "domcontentloaded" && type != "load")) {
-			return;
+
+	http.open('GET', uri, async_cb ? true : false);
+	try{
+		http.send(null);
+		if(async_cb){
+			return null;
 		}
-		arguments.callee.initialized = true;
-		if (typeof (_timer) != "undefined") {
-			clearInterval(_timer);
-			delete _timer;
+		if((http["status"])&&((200 > http.status)||(300 <= http.status))){
+			throw Error("Unable to load "+uri+" status:"+ http.status);
 		}
-		var initFunc = function () {
-			if (dojo.render.html.ie) {
-				dojo.hostenv.makeWidgets();
-			}
-		};
-		if (dojo.hostenv.inFlightCount == 0) {
-			initFunc();
-			dojo.hostenv.modulesLoaded();
-		} else {
-			dojo.hostenv.modulesLoadedListeners.unshift(initFunc);
+	}catch(e){
+		if((fail_ok)&&(!async_cb)){
+			return null;
+		}else{
+			throw e;
 		}
 	}
-	if (document.addEventListener) {
-		if (dojo.render.html.opera || (dojo.render.html.moz && (djConfig["enableMozDomContentLoaded"] === true))) {
-			document.addEventListener("DOMContentLoaded", dj_load_init, null);
-		}
-		window.addEventListener("load", dj_load_init, null);
+
+	return http.responseText;
+}
+
+/*
+ * It turns out that if we check *right now*, as this script file is being loaded,
+ * then the last script element in the window DOM is ourselves.
+ * That is because any subsequent script elements haven't shown up in the document
+ * object yet.
+ */
+ /*
+function dj_last_script_src() {
+    var scripts = window.document.getElementsByTagName('script');
+    if(scripts.length < 1){
+		dojo.raise("No script elements in window.document, so can't figure out my script src");
 	}
-	if (dojo.render.html.ie && dojo.render.os.win) {
-		document.attachEvent("onreadystatechange", function (e) {
-			if (document.readyState == "complete") {
-				dj_load_init();
-			}
-		});
+    var script = scripts[scripts.length - 1];
+    var src = script.src;
+    if(!src){
+		dojo.raise("Last script element (out of " + scripts.length + ") has no src");
 	}
-	if (/(WebKit|khtml)/i.test(navigator.userAgent)) {
-		var _timer = setInterval(function () {
-			if (/loaded|complete/.test(document.readyState)) {
-				dj_load_init();
+    return src;
+}
+
+if(!dojo.hostenv["library_script_uri_"]){
+	dojo.hostenv.library_script_uri_ = dj_last_script_src();
+}
+*/
+
+dojo.hostenv.defaultDebugContainerId = 'dojoDebug';
+dojo.hostenv._println_buffer = [];
+dojo.hostenv._println_safe = false;
+dojo.hostenv.println = function (line){
+	if(!dojo.hostenv._println_safe){
+		dojo.hostenv._println_buffer.push(line);
+	}else{
+		try {
+			var console = document.getElementById(djConfig.debugContainerId ?
+				djConfig.debugContainerId : dojo.hostenv.defaultDebugContainerId);
+			if(!console) { console = document.getElementsByTagName("body")[0] || document.body; }
+
+			var div = document.createElement("div");
+			div.appendChild(document.createTextNode(line));
+			console.appendChild(div);
+		} catch (e) {
+			try{
+				// safari needs the output wrapped in an element for some reason
+				document.write("<div>" + line + "</div>");
+			}catch(e2){
+				window.status = line;
 			}
-		}, 10);
+		}
 	}
-	if (dojo.render.html.ie) {
-		dj_addNodeEvtHdlr(window, "beforeunload", function () {
-			dojo.hostenv._unloading = true;
-			window.setTimeout(function () {
-				dojo.hostenv._unloading = false;
-			}, 0);
-		});
+}
+
+dojo.addOnLoad(function(){
+	dojo.hostenv._println_safe = true;
+	while(dojo.hostenv._println_buffer.length > 0){
+		dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
 	}
-	dj_addNodeEvtHdlr(window, "unload", function () {
-		dojo.hostenv.unloaded();
-		if ((!dojo.render.html.ie) || (dojo.render.html.ie && dojo.hostenv._unloading)) {
-			dojo.hostenv.unloaded();
+});
+
+function dj_addNodeEvtHdlr(node, evtName, fp, capture){
+	var oldHandler = node["on"+evtName] || function(){};
+	node["on"+evtName] = function(){
+		fp.apply(node, arguments);
+		oldHandler.apply(node, arguments);
+	}
+	return true;
+}
+
+
+/* Uncomment this to allow init after DOMLoad, not after window.onload
+
+// Mozilla exposes the event we could use
+if (dojo.render.html.mozilla) {
+   document.addEventListener("DOMContentLoaded", dj_load_init, null);
+}
+// for Internet Explorer. readyState will not be achieved on init call, but dojo doesn't need it
+//Tighten up the comments below to allow init after DOMLoad, not after window.onload
+/ * @cc_on @ * /
+/ * @if (@_win32)
+    document.write("<script defer>dj_load_init()<"+"/script>");
+/ * @end @ * /
+*/
+
+// default for other browsers
+// potential TODO: apply setTimeout approach for other browsers
+// that will cause flickering though ( document is loaded and THEN is processed)
+// maybe show/hide required in this case..
+// TODO: other browsers may support DOMContentLoaded/defer attribute. Add them to above.
+dj_addNodeEvtHdlr(window, "load", function(){
+	// allow multiple calls, only first one will take effect
+	if(arguments.callee.initialized){ return; }
+	arguments.callee.initialized = true;
+
+	var initFunc = function(){
+		//perform initialization
+		if(dojo.render.html.ie){
+			dojo.hostenv.makeWidgets();
 		}
-	});
-	dojo.hostenv.makeWidgets = function () {
-		var sids = [];
-		if (djConfig.searchIds && djConfig.searchIds.length > 0) {
-			sids = sids.concat(djConfig.searchIds);
-		}
-		if (dojo.hostenv.searchIds && dojo.hostenv.searchIds.length > 0) {
-			sids = sids.concat(dojo.hostenv.searchIds);
-		}
-		if ((djConfig.parseWidgets) || (sids.length > 0)) {
-			if (dojo.evalObjPath("dojo.widget.Parse")) {
+	};
+
+	if(dojo.hostenv.inFlightCount == 0){
+		initFunc();
+		dojo.hostenv.modulesLoaded();
+	}else{
+		dojo.addOnLoad(initFunc);
+	}
+});
+
+dj_addNodeEvtHdlr(window, "unload", function(){
+	dojo.hostenv.unloaded();
+});
+
+dojo.hostenv.makeWidgets = function(){
+	// you can put searchIds in djConfig and dojo.hostenv at the moment
+	// we should probably eventually move to one or the other
+	var sids = [];
+	if(djConfig.searchIds && djConfig.searchIds.length > 0) {
+		sids = sids.concat(djConfig.searchIds);
+	}
+	if(dojo.hostenv.searchIds && dojo.hostenv.searchIds.length > 0) {
+		sids = sids.concat(dojo.hostenv.searchIds);
+	}
+
+	if((djConfig.parseWidgets)||(sids.length > 0)){
+		if(dojo.evalObjPath("dojo.widget.Parse")){
+			// we must do this on a delay to avoid:
+			//	http://www.shaftek.org/blog/archives/000212.html
+			// IE is such a tremendous peice of shit.
 				var parser = new dojo.xml.Parse();
-				if (sids.length > 0) {
-					for (var x = 0; x < sids.length; x++) {
+				if(sids.length > 0){
+					for(var x=0; x<sids.length; x++){
 						var tmpNode = document.getElementById(sids[x]);
-						if (!tmpNode) {
-							continue;
-						}
+						if(!tmpNode){ continue; }
 						var frag = parser.parseElement(tmpNode, null, true);
 						dojo.widget.getParser().createComponents(frag);
 					}
-				} else {
-					if (djConfig.parseWidgets) {
-						var frag = parser.parseElement(dojo.body(), null, true);
-						dojo.widget.getParser().createComponents(frag);
-					}
+				}else if(djConfig.parseWidgets){
+					var frag  = parser.parseElement(document.getElementsByTagName("body")[0] || document.body, null, true);
+					dojo.widget.getParser().createComponents(frag);
 				}
-			}
 		}
-	};
-	dojo.addOnLoad(function () {
-		if (!dojo.render.html.ie) {
-			dojo.hostenv.makeWidgets();
-		}
-	});
-	try {
-		if (dojo.render.html.ie) {
-			document.namespaces.add("v", "urn:schemas-microsoft-com:vml");
-			document.createStyleSheet().addRule("v\\:*", "behavior:url(#default#VML)");
-		}
 	}
-	catch (e) {
+}
+
+dojo.addOnLoad(function(){
+	if(!dojo.render.html.ie) {
+		dojo.hostenv.makeWidgets();
 	}
-	dojo.hostenv.writeIncludes = function () {
-	};
-	if (!dj_undef("document", this)) {
-		dj_currentDocument = this.document;
+});
+
+try {
+	if (dojo.render.html.ie) {
+		document.write('<style>v\:*{ behavior:url(#default#VML); }</style>');
+		document.write('<xml:namespace ns="urn:schemas-microsoft-com:vml" prefix="v"/>');
 	}
-	dojo.doc = function () {
-		return dj_currentDocument;
-	};
-	dojo.body = function () {
-		return dojo.doc().body || dojo.doc().getElementsByTagName("body")[0];
-	};
-	dojo.byId = function (id, doc) {
-		if ((id) && ((typeof id == "string") || (id instanceof String))) {
-			if (!doc) {
-				doc = dj_currentDocument;
-			}
-			var ele = doc.getElementById(id);
-			if (ele && (ele.id != id) && doc.all) {
-				ele = null;
-				eles = doc.all[id];
-				if (eles) {
-					if (eles.length) {
-						for (var i = 0; i < eles.length; i++) {
-							if (eles[i].id == id) {
-								ele = eles[i];
-								break;
-							}
-						}
-					} else {
-						ele = eles;
-					}
-				}
-			}
-			return ele;
-		}
-		return id;
-	};
-	dojo.setContext = function (globalObject, globalDocument) {
-		dj_currentContext = globalObject;
-		dj_currentDocument = globalDocument;
-	};
-	dojo._fireCallback = function (callback, context, cbArguments) {
-		if ((context) && ((typeof callback == "string") || (callback instanceof String))) {
-			callback = context[callback];
-		}
-		return (context ? callback.apply(context, cbArguments || []) : callback());
-	};
-	dojo.withGlobal = function (globalObject, callback, thisObject, cbArguments) {
-		var rval;
-		var oldGlob = dj_currentContext;
-		var oldDoc = dj_currentDocument;
-		try {
-			dojo.setContext(globalObject, globalObject.document);
-			rval = dojo._fireCallback(callback, thisObject, cbArguments);
-		}
-		finally {
-			dojo.setContext(oldGlob, oldDoc);
-		}
-		return rval;
-	};
-	dojo.withDoc = function (documentObject, callback, thisObject, cbArguments) {
-		var rval;
-		var oldDoc = dj_currentDocument;
-		try {
-			dj_currentDocument = documentObject;
-			rval = dojo._fireCallback(callback, thisObject, cbArguments);
-		}
-		finally {
-			dj_currentDocument = oldDoc;
-		}
-		return rval;
-	};
-}
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");
-dojo.requireIf(djConfig["debugAtAllCosts"] && !window.widget && !djConfig["useXDomain"], "dojo.browser_debug");
-dojo.requireIf(djConfig["debugAtAllCosts"] && !window.widget && djConfig["useXDomain"], "dojo.browser_debug_xd");
+} catch (e) { }
 
+// stub, over-ridden by debugging code. This will at least keep us from
+// breaking when it's not included
+dojo.hostenv.writeIncludes = function(){}
+
+dojo.byId = function(id, doc){
+	if(id && (typeof id == "string" || id instanceof String)){
+		if(!doc){ doc = document; }
+		return doc.getElementById(id);
+	}
+	return id; // assume it's a node
+}

Modified: tags/parley-0.53/root/static/magic/src/hostenv_dashboard.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_dashboard.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_dashboard.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,31 +8,31 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.render.name = dojo.hostenv.name_ = "dashboard";
 
+dojo.hostenv.println = function(/*String*/ message){
+	// summary: Prints a message to the OS X console
+	return alert(message); // null
+}
 
-dojo.render.name = dojo.hostenv.name_ = "dashboard";
-dojo.hostenv.println = function (message) {
-	return alert(message);
-};
-dojo.hostenv.getXmlhttpObject = function (kwArgs) {
-	if (widget.system && kwArgs) {
-		if ((kwArgs.contentType && kwArgs.contentType.indexOf("text/") != 0) || (kwArgs.headers && kwArgs.headers["content-type"] && kwArgs.headers["content-type"].indexOf("text/") != 0)) {
+dojo.hostenv.getXmlhttpObject = function(/*Object*/ kwArgs){
+	// summary: Returns the appropriate transfer object for the call type
+	if(widget.system && kwArgs){
+		if((kwArgs.contentType && kwArgs.contentType.indexOf("text/") != 0) || (kwArgs.headers && kwArgs.headers["content-type"] && kwArgs.headers["content-type"].indexOf("text/") != 0)){
 			var curl = new dojo.hostenv.CurlRequest;
 			curl._save = true;
 			return curl;
-		} else {
-			if (kwArgs.method && kwArgs.method.toUpperCase() == "HEAD") {
-				return new dojo.hostenv.CurlRequest;
-			} else {
-				if (kwArgs.headers && kwArgs.header.referer) {
-					return new dojo.hostenv.CurlRequest;
-				}
-			}
+		}else if(kwArgs.method && kwArgs.method.toUpperCase() == "HEAD"){
+			return new dojo.hostenv.CurlRequest;
+		}else if(kwArgs.headers && kwArgs.header.referer){
+			return new dojo.hostenv.CurlRequest; 
 		}
 	}
-	return new XMLHttpRequest;
-};
-dojo.hostenv.CurlRequest = function () {
+	return new XMLHttpRequest; // XMLHttpRequest
+}
+
+dojo.hostenv.CurlRequest = function(){
+	// summary: Emulates the XMLHttpRequest Object
 	this.onreadystatechange = null;
 	this.readyState = 0;
 	this.responseText = "";
@@ -50,84 +50,99 @@
 	this._fileName = "";
 	this._username = "";
 	this._password = "";
-};
-dojo.hostenv.CurlRequest.prototype.open = function (method, url, async, username, password) {
+}
+
+dojo.hostenv.CurlRequest.prototype.open = function(/*String*/ method, /*URL*/ url, /*Boolean?*/ async, /*String?*/ username, /*String?*/ password){
 	this._method = method;
 	this._url = url;
-	if (async) {
+	if(async){
 		this._async = async;
 	}
-	if (username) {
+	if(username){
 		this._username = username;
 	}
-	if (password) {
+	if(password){
 		this._password = password;
 	}
-};
-dojo.hostenv.CurlRequest.prototype.setRequestHeader = function (label, value) {
-	switch (label) {
-	  case "Referer":
-		this._referrer = value;
-		break;
-	  case "content-type":
-		break;
-	  default:
-		this._headers.push(label + "=" + value);
-		break;
+}
+
+dojo.hostenv.CurlRequest.prototype.setRequestHeader = function(/*String*/ label, /*String*/ value){
+	switch(label){
+		case "Referer":
+			this._referrer = value;
+			break;
+		case "content-type":
+			break;
+		default:
+			this._headers.push(label + "=" + value);
+			break;
 	}
-};
-dojo.hostenv.CurlRequest.prototype.getAllResponseHeaders = function () {
-	return this._responseHeader;
-};
-dojo.hostenv.CurlRequest.prototype.getResponseHeader = function (headerLabel) {
-	return this._responseHeaders[headerLabel];
-};
-dojo.hostenv.CurlRequest.prototype.send = function (content) {
+}
+
+dojo.hostenv.CurlRequest.prototype.getAllResponseHeaders = function(){
+	return this._responseHeader; // String
+}
+
+dojo.hostenv.CurlRequest.prototype.getResponseHeader = function(/*String*/ headerLabel){
+	return this._responseHeaders[headerLabel]; // String
+}
+
+// -sS = Show only errors in errorString
+// -i = Display headers with return
+// -e = Referrer URI
+// -H = Headers
+// -d = data to be sent (forces POST)
+// -G = forces GET
+// -o = Writes to file (in the cache directory)
+// -I = Only load headers
+// -u = user:password
+dojo.hostenv.CurlRequest.prototype.send = function(/*String*/ content){
 	this.readyState = 1;
-	if (this.onreadystatechange) {
+	if(this.onreadystatechange){
 		this.onreadystatechange.call(this);
 	}
-	var query = {sS:""};
-	if (this._referrer) {
+	var query = {sS: ""};
+	if(this._referrer){
 		query.e = this._referrer;
 	}
-	if (this._headers.length) {
+	if(this._headers.length){
 		query.H = this._headers.join("&");
 	}
-	if (this._username) {
-		if (this._password) {
+	if(this._username){
+		if(this._password){
 			query.u = this._username + ":" + this._password;
-		} else {
+		}else{
 			query.u = this._username;
 		}
 	}
-	if (content) {
+	if(content){
 		query.d = this.content;
-		if (this._method != "POST") {
+		if(this._method != "POST"){
 			query.G = "";
 		}
 	}
-	if (this._method == "HEAD") {
+	if(this._method == "HEAD"){
 		query.I = "";
-	} else {
-		if (this._save) {
-			query.I = "";
-		} else {
+	}else{
+		if(this._save){
+			query.I = ""; // Get the headers in the initial query
+		}else{
 			query.i = "";
 		}
 	}
+
 	var system = widget.system(dojo.hostenv.CurlRequest._formatCall(query, this._url), null);
 	this.readyState = 2;
-	if (this.onreadystatechange) {
+	if(this.onreadystatechange){
 		this.onreadystatechange.call(this);
 	}
-	if (system.errorString) {
+	if(system.errorString){
 		this.responseText = system.errorString;
 		this.status = 0;
-	} else {
-		if (this._save) {
+	}else{
+		if(this._save){
 			this._responseHeader = system.outputString;
-		} else {
+		}else{
 			var split = system.outputString.replace(/\r/g, "").split("\n\n", 2);
 			this._responseHeader = split[0];
 			this.responseText = split[1];
@@ -135,46 +150,48 @@
 		split = this._responseHeader.split("\n");
 		this.statusText = split.shift();
 		this.status = this.statusText.split(" ")[1];
-		for (var i = 0, header; header = split[i]; i++) {
+		for(var i = 0, header; header = split[i]; i++){
 			var header_split = header.split(": ", 2);
 			this._responseHeaders[header_split[0]] = header_split[1];
 		}
-		if (this._save) {
+		if(this._save){
 			widget.system("/bin/mkdir cache", null);
+			// First, make a file name
 			this._fileName = this._url.split("/").pop().replace(/\W/g, "");
-			this._fileName += "." + this._responseHeaders["Content-Type"].replace(/[\r\n]/g, "").split("/").pop();
+			// Then, get its extension
+			this._fileName += "." + this._responseHeaders["Content-Type"].replace(/[\r\n]/g, "").split("/").pop()
 			delete query.I;
-			query.o = "cache/" + this._fileName;
+			query.o = "cache/" + this._fileName; // Tell it where to be saved.
 			system = widget.system(dojo.hostenv.CurlRequest._formatCall(query, this._url), null);
-			if (!system.errorString) {
+			if(!system.errorString){
 				this.responseText = "cache/" + this._fileName;
 			}
-		} else {
-			if (this._method == "HEAD") {
-				this.responseText = this._responseHeader;
-			}
+		}else if(this._method == "HEAD"){
+			this.responseText = this._responseHeader;
 		}
 	}
+
 	this.readyState = 4;
-	if (this.onreadystatechange) {
+	if(this.onreadystatechange){
 		this.onreadystatechange.call(this);
 	}
-};
-dojo.hostenv.CurlRequest._formatCall = function (query, url) {
+}
+
+dojo.hostenv.CurlRequest._formatCall = function(query, url){
 	var call = ["/usr/bin/curl"];
-	for (var key in query) {
-		if (query[key] != "") {
-			call.push("-" + key + " '" + query[key].replace(/'/g, "'") + "'");
-		} else {
+	for(var key in query){
+		if(query[key] != ""){
+			call.push("-" + key + " '" + query[key].replace(/'/g, "\'") + "'");
+		}else{
 			call.push("-" + key);
 		}
 	}
-	call.push("'" + url.replace(/'/g, "'") + "'");
+	call.push("'" + url.replace(/'/g, "\'") + "'");
 	return call.join(" ");
-};
-dojo.hostenv.exit = function () {
-	if (widget.system) {
+}
+
+dojo.hostenv.exit = function(){
+	if(widget.system){
 		widget.system("/bin/rm -rf cache/*", null);
 	}
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/hostenv_jsc.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_jsc.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_jsc.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -74,5 +74,3 @@
 dojo.hostenv.getLibraryScriptUri = function(){
 	return System.Environment.GetCommandLineArgs()[0];
 }
-
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");

Modified: tags/parley-0.53/root/static/magic/src/hostenv_rhino.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_rhino.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_rhino.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,126 +8,177 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/*
+* Rhino host environment
+*/
 
+// make jsc shut up (so we can use jsc for sanity checking) 
+/*@cc_on
+ at if (@_jscript_version >= 7)
+var loadClass; var print; var load; var quit; var version; var Packages; var java;
+ at end
+@*/
 
-dojo.hostenv.println = function (line) {
-	if (arguments.length > 0) {
-		print(arguments[0]);
-		for (var i = 1; i < arguments.length; i++) {
-			var valid = false;
-			for (var p in arguments[i]) {
-				valid = true;
-				break;
+// TODO: not sure what we gain from the next line, anyone?
+//if (typeof loadClass == 'undefined') { dojo.raise("attempt to use Rhino host environment when no 'loadClass' global"); }
+
+dojo.render.name = dojo.hostenv.name_ = 'rhino';
+dojo.hostenv.getVersion = function() {return version()};
+
+// see comments in spidermonkey loadUri
+dojo.hostenv.loadUri = function(uri, cb){
+	dojo.debug("uri: "+uri);
+	try{
+		// FIXME: what about remote URIs?
+		var found = true;
+		if(!(new java.io.File(uri)).exists()){
+			try{
+				// try it as a file first, URL second
+				(new java.io.URL(uri)).openStream();
+			}catch(e){
+				found = false;
 			}
-			if (valid) {
-				dojo.debugShallow(arguments[i]);
-			}
 		}
-	} else {
-		print(line);
+		if(!found){
+			dojo.debug(uri+" does not exist");
+			if(cb){ cb(0); }
+			return 0;
+		}
+		var ok = load(uri);
+		// dojo.debug(typeof ok);
+		dojo.debug("rhino load('", uri, "') returned. Ok: ", ok);
+		if(cb){ cb(1); }
+		return 1;
+	}catch(e){
+		dojo.debug("rhino load('", uri, "') failed");
+		if(cb){ cb(0); }
+		return 0;
 	}
-};
-dojo.locale = dojo.locale || java.util.Locale.getDefault().toString().replace("_", "-").toLowerCase();
-dojo.render.name = dojo.hostenv.name_ = "rhino";
-dojo.hostenv.getVersion = function () {
-	return version();
-};
-if (dj_undef("byId")) {
-	dojo.byId = function (id, doc) {
-		if (id && (typeof id == "string" || id instanceof String)) {
-			if (!doc) {
-				doc = document;
-			}
-			return doc.getElementById(id);
-		}
-		return id;
-	};
 }
-dojo.hostenv.loadUri = function (uri, cb) {
-	try {
-		var local = (new java.io.File(uri)).exists();
-		if (!local) {
-			try {
-				var stream = (new java.net.URL(uri)).openStream();
-				stream.close();
-			}
-			catch (e) {
-				return false;
-			}
-		}
-		if (cb) {
-			var contents = (local ? readText : readUri)(uri, "UTF-8");
-			cb(eval("(" + contents + ")"));
-		} else {
-			load(uri);
-		}
-		return true;
-	}
-	catch (e) {
-		dojo.debug("rhino load('" + uri + "') failed. Exception: " + e);
-		return false;
-	}
-};
-dojo.hostenv.exit = function (exitcode) {
+
+dojo.hostenv.println = print;
+dojo.hostenv.exit = function(exitcode){ 
 	quit(exitcode);
-};
+}
+
+// Hack to determine current script...
+//
+// These initial attempts failed:
+//   1. get an EcmaError and look at e.getSourceName(): try {eval ("static in return")} catch(e) { ...
+//   Won't work because NativeGlobal.java only does a put of "name" and "message", not a wrapped reflecting object.
+//   Even if the EcmaError object had the sourceName set.
+//  
+//   2. var e = Packages.org.mozilla.javascript.Context.getCurrentContext().reportError('');
+//   Won't work because it goes directly to the errorReporter, not the return value.
+//   We want context.interpreterSourceFile and context.interpreterLine, which are used in static Context.getSourcePositionFromStack
+//   (set by Interpreter.java at interpretation time, if in interpreter mode).
+//
+//   3. var e = Packages.org.mozilla.javascript.Context.getCurrentContext().reportRuntimeError('');
+//   This returns an object, but e.message still does not have source info.
+//   In compiler mode, perhaps not set; in interpreter mode, perhaps not used by errorReporter?
+//
+// What we found works is to do basically the same hack as is done in getSourcePositionFromStack,
+// making a new java.lang.Exception() and then calling printStackTrace on a string stream.
+// We have to parse the string for the .js files (different from the java files).
+// This only works however in compiled mode (-opt 0 or higher).
+// In interpreter mode, entire stack is java.
+// When compiled, printStackTrace is like:
+// java.lang.Exception
+//	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
+//	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
+//	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
+//	at java.lang.reflect.Constructor.newInstance(Constructor.java:274)
+//	at org.mozilla.javascript.NativeJavaClass.constructSpecific(NativeJavaClass.java:228)
+//	at org.mozilla.javascript.NativeJavaClass.construct(NativeJavaClass.java:185)
+//	at org.mozilla.javascript.ScriptRuntime.newObject(ScriptRuntime.java:1269)
+//	at org.mozilla.javascript.gen.c2.call(/Users/mda/Sites/burstproject/testrhino.js:27)
+//    ...
+//	at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)
+//
+// Note may get different answers based on:
+//    Context.setOptimizationLevel(-1)
+//    Context.setGeneratingDebug(true)
+//    Context.setGeneratingSource(true) 
+//
+// Some somewhat helpful posts:
+//    http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=9v9n0g%246gr1%40ripley.netscape.com
+//    http://groups.google.com/groups?hl=en&lr=&ie=UTF-8&oe=UTF-8&safe=off&selm=3BAA2DC4.6010702%40atg.com
+//
+// Note that Rhino1.5R5 added source name information in some exceptions.
+// But this seems not to help in command-line Rhino, because Context.java has an error reporter
+// so no EvaluationException is thrown.
+
+// do it by using java java.lang.Exception
 function dj_rhino_current_script_via_java(depth) {
-	var optLevel = Packages.org.mozilla.javascript.Context.getCurrentContext().getOptimizationLevel();
-	var caw = new java.io.CharArrayWriter();
-	var pw = new java.io.PrintWriter(caw);
-	var exc = new java.lang.Exception();
-	var s = caw.toString();
-	var matches = s.match(/[^\(]*\.js\)/gi);
-	if (!matches) {
+    var optLevel = Packages.org.mozilla.javascript.Context.getCurrentContext().getOptimizationLevel();  
+    if (optLevel == -1) dojo.unimplemented("getCurrentScriptURI (determine current script path for rhino when interpreter mode)", '');
+    var caw = new java.io.CharArrayWriter();
+    var pw = new java.io.PrintWriter(caw);
+    var exc = new java.lang.Exception();
+    var s = caw.toString();
+    // we have to exclude the ones with or without line numbers because they put double entries in:
+    //   at org.mozilla.javascript.gen.c3._c4(/Users/mda/Sites/burstproject/burst/Runtime.js:56)
+    //   at org.mozilla.javascript.gen.c3.call(/Users/mda/Sites/burstproject/burst/Runtime.js)
+    var matches = s.match(/[^\(]*\.js\)/gi);
+    if(!matches){
 		throw Error("cannot parse printStackTrace output: " + s);
 	}
-	var fname = ((typeof depth != "undefined") && (depth)) ? matches[depth + 1] : matches[matches.length - 1];
-	var fname = matches[3];
-	if (!fname) {
-		fname = matches[1];
-	}
-	if (!fname) {
-		throw Error("could not find js file in printStackTrace output: " + s);
-	}
-	return fname;
+
+    // matches[0] is entire string, matches[1] is this function, matches[2] is caller, ...
+    var fname = ((typeof depth != 'undefined')&&(depth)) ? matches[depth + 1] : matches[matches.length - 1];
+    var fname = matches[3];
+	if(!fname){ fname = matches[1]; }
+    // print("got fname '" + fname + "' from stack string '" + s + "'");
+    if (!fname) throw Error("could not find js file in printStackTrace output: " + s);
+    //print("Rhino getCurrentScriptURI returning '" + fname + "' from: " + s); 
+    return fname;
 }
-function readText(path, encoding) {
-	encoding = encoding || "utf-8";
-	var jf = new java.io.File(path);
-	var is = new java.io.FileInputStream(jf);
-	return dj_readInputStream(is, encoding);
-}
-function readUri(uri, encoding) {
-	var conn = (new java.net.URL(uri)).openConnection();
-	encoding = encoding || conn.getContentEncoding() || "utf-8";
-	var is = conn.getInputStream();
-	return dj_readInputStream(is, encoding);
-}
-function dj_readInputStream(is, encoding) {
-	var input = new java.io.BufferedReader(new java.io.InputStreamReader(is, encoding));
-	try {
-		var sb = new java.lang.StringBuffer();
-		var line = "";
-		while ((line = input.readLine()) !== null) {
-			sb.append(line);
-			sb.append(java.lang.System.getProperty("line.separator"));
-		}
-		return sb.toString();
+
+// UNUSED: leverage new support in native exception for getSourceName
+/*
+function dj_rhino_current_script_via_eval_exception() {
+    var exc;
+    // 'ReferenceError: "undefinedsymbol" is not defined.'
+    try {eval ("undefinedsymbol()") } catch(e) {exc = e;}
+    // 'Error: whatever'
+    // try{throw Error("whatever");} catch(e) {exc = e;}
+    // 'SyntaxError: identifier is a reserved word'
+    // try {eval ("static in return")} catch(e) { exc = e; }
+    print("got exception: '" + exc + "'");
+    print("exc.stack=" + (typeof exc.stack));
+    var sn = exc.getSourceName();
+    print("SourceName=" + sn);
+    return sn;
+} 
+*/
+
+// reading a file from disk in Java is a humiliating experience by any measure.
+// Lets avoid that and just get the freaking text
+function readText(uri){
+	// NOTE: we intentionally avoid handling exceptions, since the caller will
+	// want to know
+	var jf = new java.io.File(uri);
+	var sb = new java.lang.StringBuffer();
+	var input = new java.io.BufferedReader(new java.io.FileReader(jf));
+	var line = "";
+	while((line = input.readLine()) != null){
+		sb.append(line);
+		sb.append(java.lang.System.getProperty("line.separator"));
 	}
-	finally {
-		input.close();
-	}
+	return sb.toString();
 }
-if (!djConfig.libraryScriptUri.length) {
-	try {
+
+// call this now because later we may not be on the top of the stack
+if(!djConfig.libraryScriptUri.length){
+	try{
 		djConfig.libraryScriptUri = dj_rhino_current_script_via_java(1);
-	}
-	catch (e) {
-		if (djConfig["isDebug"]) {
+	}catch(e){
+		// otherwise just fake it
+		if(djConfig["isDebug"]){
 			print("\n");
-			print("we have no idea where Dojo is located.");
+			print("we have no idea where Dojo is located from.");
 			print("Please try loading rhino in a non-interpreted mode or set a");
-			print("\n\tdjConfig.libraryScriptUri\n");
+			print("\n	djConfig.libraryScriptUri\n");
 			print("Setting the dojo path to './'");
 			print("This is probably wrong!");
 			print("\n");
@@ -136,28 +187,4 @@
 		djConfig.libraryScriptUri = "./";
 	}
 }
-dojo.doc = function () {
-	return document;
-};
-dojo.body = function () {
-	return document.body;
-};
-function setTimeout(func, delay) {
-	var def = {sleepTime:delay, hasSlept:false, run:function () {
-		if (!this.hasSlept) {
-			this.hasSlept = true;
-			java.lang.Thread.currentThread().sleep(this.sleepTime);
-		}
-		try {
-			func();
-		}
-		catch (e) {
-			dojo.debug("Error running setTimeout thread:" + e);
-		}
-	}};
-	var runnable = new java.lang.Runnable(def);
-	var thread = new java.lang.Thread(runnable);
-	thread.start();
-}
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");
 

Modified: tags/parley-0.53/root/static/magic/src/hostenv_spidermonkey.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_spidermonkey.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_spidermonkey.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,43 +8,72 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/*
+ * SpiderMonkey host environment
+ */
 
+dojo.hostenv.name_ = 'spidermonkey';
 
-dojo.hostenv.name_ = "spidermonkey";
 dojo.hostenv.println = print;
-dojo.hostenv.exit = function (exitcode) {
-	quit(exitcode);
-};
-dojo.hostenv.getVersion = function () {
-	return version();
-};
-if (typeof line2pc == "undefined") {
+dojo.hostenv.exit = function(exitcode){ 
+	quit(exitcode); 
+}
+
+// version() returns 0, sigh. and build() returns nothing but just prints.
+dojo.hostenv.getVersion = function(){ return version(); }
+
+// make jsc shut up (so we can use jsc for sanity checking) 
+/*@cc_on
+ at if (@_jscript_version >= 7)
+var line2pc; var print; var load; var quit;
+ at end
+@*/
+
+if(typeof line2pc == 'undefined'){
 	dojo.raise("attempt to use SpiderMonkey host environment when no 'line2pc' global");
 }
-function dj_spidermonkey_current_file(depth) {
-	var s = "";
-	try {
+
+/*
+ * This is a hack that determines the current script file by parsing a generated
+ * stack trace (relying on the non-standard "stack" member variable of the
+ * SpiderMonkey Error object).
+ * If param depth is passed in, it'll return the script file which is that far down
+ * the stack, but that does require that you know how deep your stack is when you are
+ * calling.
+ */
+function dj_spidermonkey_current_file(depth){
+    var s = '';
+    try{
 		throw Error("whatever");
-	}
-	catch (e) {
+	}catch(e){
 		s = e.stack;
 	}
-	var matches = s.match(/[^@]*\.js/gi);
-	if (!matches) {
+    // lines are like: bu_getCurrentScriptURI_spidermonkey("ScriptLoader.js")@burst/Runtime.js:101
+    var matches = s.match(/[^@]*\.js/gi);
+    if(!matches){ 
 		dojo.raise("could not parse stack string: '" + s + "'");
 	}
-	var fname = (typeof depth != "undefined" && depth) ? matches[depth + 1] : matches[matches.length - 1];
-	if (!fname) {
+    var fname = (typeof depth != 'undefined' && depth) ? matches[depth + 1] : matches[matches.length - 1];
+    if(!fname){ 
 		dojo.raise("could not find file name in stack string '" + s + "'");
 	}
-	return fname;
+    //print("SpiderMonkeyRuntime got fname '" + fname + "' from stack string '" + s + "'");
+    return fname;
 }
-if (!dojo.hostenv.library_script_uri_) {
-	dojo.hostenv.library_script_uri_ = dj_spidermonkey_current_file(0);
+
+// call this now because later we may not be on the top of the stack
+if(!dojo.hostenv.library_script_uri_){ 
+	dojo.hostenv.library_script_uri_ = dj_spidermonkey_current_file(0); 
 }
-dojo.hostenv.loadUri = function (uri) {
+
+dojo.hostenv.loadUri = function(uri){
+	// spidermonkey load() evaluates the contents into the global scope (which
+	// is what we want).
+	// TODO: sigh, load() does not return a useful value. 
+	// Perhaps it is returning the value of the last thing evaluated?
 	var ok = load(uri);
+	// dojo.debug("spidermonkey load(", uri, ") returned ", ok);
 	return 1;
-};
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");
+}
 
+

Modified: tags/parley-0.53/root/static/magic/src/hostenv_svg.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_svg.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_svg.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,196 +8,186 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-if (typeof window == "undefined") {
+//	hostenv_svg
+if(typeof window == 'undefined'){
 	dojo.raise("attempt to use adobe svg hostenv when no window object");
 }
-dojo.debug = function () {
-	if (!djConfig.isDebug) {
-		return;
-	}
+dojo.debug = function(){ 
+	if (!djConfig.isDebug) { return; }
 	var args = arguments;
 	var isJUM = dj_global["jum"];
-	var s = isJUM ? "" : "DEBUG: ";
-	for (var i = 0; i < args.length; ++i) {
-		s += args[i];
-	}
-	if (isJUM) {
+	var s = isJUM ? "": "DEBUG: ";
+	for (var i = 0; i < args.length; ++i){ s += args[i]; }
+	if (isJUM){ // this seems to be the only way to get JUM to "play nice"
 		jum.debug(s);
-	} else {
+	} else{ 
 		dojo.hostenv.println(s);
 	}
 };
+
+//	set up dojo.render.
 dojo.render.name = navigator.appName;
 dojo.render.ver = parseFloat(navigator.appVersion, 10);
-switch (navigator.platform) {
-  case "MacOS":
-	dojo.render.os.osx = true;
-	break;
-  case "Linux":
-	dojo.render.os.linux = true;
-	break;
-  case "Windows":
-	dojo.render.os.win = true;
-	break;
-  default:
-	dojo.render.os.linux = true;
-	break;
-}
+switch(navigator.platform){
+	case "MacOS":
+		dojo.render.os.osx =  true;
+		break;
+	case "Linux":
+		dojo.render.os.linux =  true;
+		break;
+	case "Windows":
+		dojo.render.os.win =  true;
+		break;
+	default:
+		dojo.render.os.linux = true;
+		break;
+};
 dojo.render.svg.capable = true;
 dojo.render.svg.support.builtin = true;
+//	FIXME the following two is a big-ass hack for now.
 dojo.render.svg.moz = ((navigator.userAgent.indexOf("Gecko") >= 0) && (!((navigator.appVersion.indexOf("Konqueror") >= 0) || (navigator.appVersion.indexOf("Safari") >= 0))));
 dojo.render.svg.adobe = (window.parseXML != null);
+
+//	agent-specific implementations.
+
+//	from old hostenv_adobesvg.
 dojo.hostenv.startPackage("dojo.hostenv");
-dojo.hostenv.println = function (s) {
+dojo.hostenv.println = function(s){ 
 	try {
 		var ti = document.createElement("text");
-		ti.setAttribute("x", "50");
+		ti.setAttribute("x","50");
 		ti.setAttribute("y", (25 + 15 * document.getElementsByTagName("text").length));
 		ti.appendChild(document.createTextNode(s));
 		document.documentElement.appendChild(ti);
-	}
-	catch (e) {
-	}
+	} catch(e){ }
 };
 dojo.hostenv.name_ = "svg";
-dojo.hostenv.setModulePrefix = function (module, prefix) {
-};
-dojo.hostenv.getModulePrefix = function (module) {
-};
+
+//	expected/defined by bootstrap1.js
+dojo.hostenv.setModulePrefix = function(module, prefix){ };
+dojo.hostenv.getModulePrefix = function(module){ };
 dojo.hostenv.getTextStack = [];
 dojo.hostenv.loadUriStack = [];
 dojo.hostenv.loadedUris = [];
 dojo.hostenv.modules_ = {};
 dojo.hostenv.modulesLoadedFired = false;
 dojo.hostenv.modulesLoadedListeners = [];
-dojo.hostenv.getText = function (uri, cb, data) {
-	if (!cb) {
-		var cb = function (result) {
-			window.alert(result);
-		};
-	}
+dojo.hostenv.getText = function(uri, cb, data){ 
+	if (!cb) var cb = function(result){ window.alert(result); };
 	if (!data) {
 		window.getUrl(uri, cb);
 	} else {
 		window.postUrl(uri, data, cb);
 	}
 };
-dojo.hostenv.getLibaryScriptUri = function () {
-};
-dojo.hostenv.loadUri = function (uri) {
-};
-dojo.hostenv.loadUriAndCheck = function (uri, module) {
-};
-dojo.hostenv.loadModule = function (moduleName) {
+dojo.hostenv.getLibaryScriptUri = function(){ };
+
+dojo.hostenv.loadUri = function(uri){ };
+dojo.hostenv.loadUriAndCheck = function(uri, module){ };
+
+//	aliased in loader.js, don't ignore
+//	we are going to kill loadModule for the first round of SVG stuff, and include shit manually.
+dojo.hostenv.loadModule = function(moduleName){
+	//	just like startPackage, but this time we're just checking to make sure it exists already.
 	var a = moduleName.split(".");
 	var currentObj = window;
 	var s = [];
-	for (var i = 0; i < a.length; i++) {
-		if (a[i] == "*") {
-			continue;
-		}
+	for (var i = 0; i < a.length; i++){
+		if (a[i] == "*") continue;
 		s.push(a[i]);
-		if (!currentObj[a[i]]) {
+		if (!currentObj[a[i]]){
 			dojo.raise("dojo.require('" + moduleName + "'): module does not exist.");
-		} else {
-			currentObj = currentObj[a[i]];
-		}
+		} else currentObj = currentObj[a[i]];
 	}
-	return;
+	return; 
 };
-dojo.hostenv.startPackage = function (moduleName) {
+dojo.hostenv.startPackage = function(moduleName){
 	var a = moduleName.split(".");
 	var currentObj = window;
 	var s = [];
-	for (var i = 0; i < a.length; i++) {
-		if (a[i] == "*") {
-			continue;
-		}
+	for (var i = 0; i < a.length; i++){
+		if (a[i] == "*") continue;
 		s.push(a[i]);
-		if (!currentObj[a[i]]) {
-			currentObj[a[i]] = {};
-		}
+		if (!currentObj[a[i]]) currentObj[a[i]] = {};
 		currentObj = currentObj[a[i]];
 	}
-	return;
+	return; 
 };
-if (window.parseXML) {
-	window.XMLSerialzer = function () {
+
+//	wrapper objects for ASVG
+if (window.parseXML){
+	window.XMLSerialzer = function(){
+		//	based on WebFX RichTextControl getXHTML() function.
 		function nodeToString(n, a) {
-			function fixText(s) {
-				return String(s).replace(/\&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;");
-			}
-			function fixAttribute(s) {
-				return fixText(s).replace(/\"/g, "&quot;");
-			}
+			function fixText(s) { return String(s).replace(/\&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;"); }
+			function fixAttribute(s) { return fixText(s).replace(/\"/g, "&quot;"); }
 			switch (n.nodeType) {
-			  case 1:
-				var name = n.nodeName;
-				a.push("<" + name);
-				for (var i = 0; i < n.attributes.length; i++) {
-					if (n.attributes.item(i).specified) {
-						a.push(" " + n.attributes.item(i).nodeName.toLowerCase() + "=\"" + fixAttribute(n.attributes.item(i).nodeValue) + "\"");
+				case 1:	{	//	ELEMENT
+					var name = n.nodeName;
+					a.push("<" + name);
+					for (var i = 0; i < n.attributes.length; i++) {
+						if (n.attributes.item(i).specified) {
+							a.push(" " + n.attributes.item(i).nodeName.toLowerCase() + "=\"" + fixAttribute(n.attributes.item(i).nodeValue) + "\"");
+						}
 					}
+					if (n.canHaveChildren || n.hasChildNodes()) {
+						a.push(">");
+						for (var i = 0; i < n.childNodes.length; i++) nodeToString(n.childNodes.item(i), a);
+						a.push("</" + name + ">\n");
+					} else a.push(" />\n");
+					break;
 				}
-				if (n.canHaveChildren || n.hasChildNodes()) {
-					a.push(">");
-					for (var i = 0; i < n.childNodes.length; i++) {
-						nodeToString(n.childNodes.item(i), a);
-					}
-					a.push("</" + name + ">\n");
-				} else {
-					a.push(" />\n");
+				case 3: {	//	TEXT
+					a.push(fixText(n.nodeValue));
+					break;
 				}
-				break;
-			  case 3:
-				a.push(fixText(n.nodeValue));
-				break;
-			  case 4:
-				a.push("<![CDA" + "TA[\n" + n.nodeValue + "\n]" + "]>");
-				break;
-			  case 7:
-				a.push(n.nodeValue);
-				if (/(^<\?xml)|(^<\!DOCTYPE)/.test(n.nodeValue)) {
-					a.push("\n");
+				case 4: {	//	CDATA
+					a.push("<![CDA" + "TA[\n" + n.nodeValue + "\n]" + "]>");
+					break;
 				}
-				break;
-			  case 8:
-				a.push("<!-- " + n.nodeValue + " -->\n");
-				break;
-			  case 9:
-			  case 11:
-				for (var i = 0; i < n.childNodes.length; i++) {
-					nodeToString(n.childNodes.item(i), a);
+				case 7:{	//	PROCESSING INSTRUCTION
+					a.push(n.nodeValue);
+					if (/(^<\?xml)|(^<\!DOCTYPE)/.test(n.nodeValue)) a.push("\n");
+					break;
 				}
-				break;
-			  default:
-				a.push("<!--\nNot Supported:\n\n" + "nodeType: " + n.nodeType + "\nnodeName: " + n.nodeName + "\n-->");
+				case 8:{	//	COMMENT
+					a.push("<!-- " + n.nodeValue + " -->\n");
+					break;
+				}
+				case 9:		//	DOCUMENT
+				case 11:{	//	DOCUMENT FRAGMENT
+					for (var i = 0; i < n.childNodes.length; i++) nodeToString(n.childNodes.item(i), a);
+					break;
+				}
+				default:{
+					a.push("<!--\nNot Supported:\n\n" + "nodeType: " + n.nodeType + "\nnodeName: " + n.nodeName + "\n-->");
+				}
 			}
 		}
-		this.serializeToString = function (node) {
+		this.serializeToString = function(node){
 			var a = [];
 			nodeToString(node, a);
 			return a.join("");
 		};
 	};
-	window.DOMParser = function () {
-		this.parseFromString = function (s) {
+
+	window.DOMParser = function(){
+		//	mimetype is basically ignored
+		this.parseFromString = function(s){
 			return parseXML(s, window.document);
-		};
+		}
 	};
-	window.XMLHttpRequest = function () {
+
+	window.XMLHttpRequest = function(){
+		//	we ignore the setting and getting of content-type.
 		var uri = null;
 		var method = "POST";
-		var isAsync = true;
-		var cb = function (d) {
+		var isAsync = true;	
+		var cb = function(d){
 			this.responseText = d.content;
 			try {
 				this.responseXML = parseXML(this.responseText, window.document);
-			}
-			catch (e) {
-			}
+			} catch(e){}
 			this.status = "200";
 			this.statusText = "OK";
 			if (!d.success) {
@@ -207,41 +197,27 @@
 			this.onload();
 			this.onreadystatechange();
 		};
-		this.onload = function () {
-		};
+		this.onload = function(){};
 		this.readyState = 4;
-		this.onreadystatechange = function () {
-		};
+		this.onreadystatechange = function(){};
 		this.status = 0;
 		this.statusText = "";
 		this.responseBody = null;
 		this.responseStream = null;
 		this.responseXML = null;
 		this.responseText = null;
-		this.abort = function () {
-			return;
-		};
-		this.getAllResponseHeaders = function () {
-			return [];
-		};
-		this.getResponseHeader = function (n) {
-			return null;
-		};
-		this.setRequestHeader = function (nm, val) {
-		};
-		this.open = function (meth, url, async) {
+		this.abort = function(){ return; };
+		this.getAllResponseHeaders = function(){ return []; };
+		this.getResponseHeader = function(n){ return null; };
+		this.setRequestHeader = function(nm, val){ };
+		this.open = function(meth, url, async){ 
 			method = meth;
 			uri = url;
 		};
-		this.send = function (data) {
+		this.send = function(data){
 			var d = data || null;
-			if (method == "GET") {
-				getURL(uri, cb);
-			} else {
-				postURL(uri, data, cb);
-			}
+			if (method == "GET") getURL(uri, cb);
+			else postURL(uri, data, cb);
 		};
 	};
 }
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");
-

Modified: tags/parley-0.53/root/static/magic/src/hostenv_wsh.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/hostenv_wsh.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/hostenv_wsh.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,28 +8,39 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/*
+ * WSH
+ */
 
+dojo.hostenv.name_ = 'wsh';
 
-dojo.hostenv.name_ = "wsh";
-if (typeof WScript == "undefined") {
+// make jsc shut up (so can sanity check)
+/*@cc_on
+ at if (@_jscript_version >= 7)
+var WScript;
+ at end
+@*/
+
+// make sure we are in right environment
+if(typeof WScript == 'undefined'){
 	dojo.raise("attempt to use WSH host environment when no WScript global");
 }
+
 dojo.hostenv.println = WScript.Echo;
-dojo.hostenv.getCurrentScriptUri = function () {
+
+dojo.hostenv.getCurrentScriptUri = function(){
 	return WScript.ScriptFullName();
-};
-dojo.hostenv.getText = function (fpath) {
+}
+
+dojo.hostenv.getText = function(fpath){
 	var fso = new ActiveXObject("Scripting.FileSystemObject");
-	var istream = fso.OpenTextFile(fpath, 1);
-	if (!istream) {
+	var istream = fso.OpenTextFile(fpath, 1); // iomode==1 means read only
+	if(!istream){
 		return null;
 	}
 	var contents = istream.ReadAll();
 	istream.Close();
 	return contents;
-};
-dojo.hostenv.exit = function (exitcode) {
-	WScript.Quit(exitcode);
-};
-dojo.requireIf((djConfig["isDebug"] || djConfig["debugAtAllCosts"]), "dojo.debug");
+}
 
+dojo.hostenv.exit = function(exitcode){ WScript.Quit(exitcode); }

Modified: tags/parley-0.53/root/static/magic/src/html/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,7 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.html.common", "dojo.html.style"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.html", "dojo.html.extras", "dojo.html.shadow"]
+});
 dojo.provide("dojo.html.*");
-

Deleted: tags/parley-0.53/root/static/magic/src/html/color.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/color.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/color.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,38 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.require("dojo.html.style");
-dojo.provide("dojo.html.color");
-dojo.require("dojo.gfx.color");
-dojo.require("dojo.lang.common");
-dojo.html.getBackgroundColor = function (node) {
-	node = dojo.byId(node);
-	var color;
-	do {
-		color = dojo.html.getStyle(node, "background-color");
-		if (color.toLowerCase() == "rgba(0, 0, 0, 0)") {
-			color = "transparent";
-		}
-		if (node == document.getElementsByTagName("body")[0]) {
-			node = null;
-			break;
-		}
-		node = node.parentNode;
-	} while (node && dojo.lang.inArray(["transparent", ""], color));
-	if (color == "transparent") {
-		color = [255, 255, 255, 0];
-	} else {
-		color = dojo.gfx.color.extractRGB(color);
-	}
-	return color;
-};
-

Deleted: tags/parley-0.53/root/static/magic/src/html/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,182 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.html.common");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.dom");
-dojo.lang.mixin(dojo.html, dojo.dom);
-dojo.html.body = function () {
-	dojo.deprecated("dojo.html.body() moved to dojo.body()", "0.5");
-	return dojo.body();
-};
-dojo.html.getEventTarget = function (evt) {
-	if (!evt) {
-		evt = dojo.global().event || {};
-	}
-	var t = (evt.srcElement ? evt.srcElement : (evt.target ? evt.target : null));
-	while ((t) && (t.nodeType != 1)) {
-		t = t.parentNode;
-	}
-	return t;
-};
-dojo.html.getViewport = function () {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	var w = 0;
-	var h = 0;
-	if (dojo.render.html.mozilla) {
-		w = _document.documentElement.clientWidth;
-		h = _window.innerHeight;
-	} else {
-		if (!dojo.render.html.opera && _window.innerWidth) {
-			w = _window.innerWidth;
-			h = _window.innerHeight;
-		} else {
-			if (!dojo.render.html.opera && dojo.exists(_document, "documentElement.clientWidth")) {
-				var w2 = _document.documentElement.clientWidth;
-				if (!w || w2 && w2 < w) {
-					w = w2;
-				}
-				h = _document.documentElement.clientHeight;
-			} else {
-				if (dojo.body().clientWidth) {
-					w = dojo.body().clientWidth;
-					h = dojo.body().clientHeight;
-				}
-			}
-		}
-	}
-	return {width:w, height:h};
-};
-dojo.html.getScroll = function () {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	var top = _window.pageYOffset || _document.documentElement.scrollTop || dojo.body().scrollTop || 0;
-	var left = _window.pageXOffset || _document.documentElement.scrollLeft || dojo.body().scrollLeft || 0;
-	return {top:top, left:left, offset:{x:left, y:top}};
-};
-dojo.html.getParentByType = function (node, type) {
-	var _document = dojo.doc();
-	var parent = dojo.byId(node);
-	type = type.toLowerCase();
-	while ((parent) && (parent.nodeName.toLowerCase() != type)) {
-		if (parent == (_document["body"] || _document["documentElement"])) {
-			return null;
-		}
-		parent = parent.parentNode;
-	}
-	return parent;
-};
-dojo.html.getAttribute = function (node, attr) {
-	node = dojo.byId(node);
-	if ((!node) || (!node.getAttribute)) {
-		return null;
-	}
-	var ta = typeof attr == "string" ? attr : new String(attr);
-	var v = node.getAttribute(ta.toUpperCase());
-	if ((v) && (typeof v == "string") && (v != "")) {
-		return v;
-	}
-	if (v && v.value) {
-		return v.value;
-	}
-	if ((node.getAttributeNode) && (node.getAttributeNode(ta))) {
-		return (node.getAttributeNode(ta)).value;
-	} else {
-		if (node.getAttribute(ta)) {
-			return node.getAttribute(ta);
-		} else {
-			if (node.getAttribute(ta.toLowerCase())) {
-				return node.getAttribute(ta.toLowerCase());
-			}
-		}
-	}
-	return null;
-};
-dojo.html.hasAttribute = function (node, attr) {
-	return dojo.html.getAttribute(dojo.byId(node), attr) ? true : false;
-};
-dojo.html.getCursorPosition = function (e) {
-	e = e || dojo.global().event;
-	var cursor = {x:0, y:0};
-	if (e.pageX || e.pageY) {
-		cursor.x = e.pageX;
-		cursor.y = e.pageY;
-	} else {
-		var de = dojo.doc().documentElement;
-		var db = dojo.body();
-		cursor.x = e.clientX + ((de || db)["scrollLeft"]) - ((de || db)["clientLeft"]);
-		cursor.y = e.clientY + ((de || db)["scrollTop"]) - ((de || db)["clientTop"]);
-	}
-	return cursor;
-};
-dojo.html.isTag = function (node) {
-	node = dojo.byId(node);
-	if (node && node.tagName) {
-		for (var i = 1; i < arguments.length; i++) {
-			if (node.tagName.toLowerCase() == String(arguments[i]).toLowerCase()) {
-				return String(arguments[i]).toLowerCase();
-			}
-		}
-	}
-	return "";
-};
-if (dojo.render.html.ie && !dojo.render.html.ie70) {
-	if (window.location.href.substr(0, 6).toLowerCase() != "https:") {
-		(function () {
-			var xscript = dojo.doc().createElement("script");
-			xscript.src = "javascript:'dojo.html.createExternalElement=function(doc, tag){ return doc.createElement(tag); }'";
-			dojo.doc().getElementsByTagName("head")[0].appendChild(xscript);
-		})();
-	}
-} else {
-	dojo.html.createExternalElement = function (doc, tag) {
-		return doc.createElement(tag);
-	};
-}
-dojo.html._callDeprecated = function (inFunc, replFunc, args, argName, retValue) {
-	dojo.deprecated("dojo.html." + inFunc, "replaced by dojo.html." + replFunc + "(" + (argName ? "node, {" + argName + ": " + argName + "}" : "") + ")" + (retValue ? "." + retValue : ""), "0.5");
-	var newArgs = [];
-	if (argName) {
-		var argsIn = {};
-		argsIn[argName] = args[1];
-		newArgs.push(args[0]);
-		newArgs.push(argsIn);
-	} else {
-		newArgs = args;
-	}
-	var ret = dojo.html[replFunc].apply(dojo.html, args);
-	if (retValue) {
-		return ret[retValue];
-	} else {
-		return ret;
-	}
-};
-dojo.html.getViewportWidth = function () {
-	return dojo.html._callDeprecated("getViewportWidth", "getViewport", arguments, null, "width");
-};
-dojo.html.getViewportHeight = function () {
-	return dojo.html._callDeprecated("getViewportHeight", "getViewport", arguments, null, "height");
-};
-dojo.html.getViewportSize = function () {
-	return dojo.html._callDeprecated("getViewportSize", "getViewport", arguments);
-};
-dojo.html.getScrollTop = function () {
-	return dojo.html._callDeprecated("getScrollTop", "getScroll", arguments, null, "top");
-};
-dojo.html.getScrollLeft = function () {
-	return dojo.html._callDeprecated("getScrollLeft", "getScroll", arguments, null, "left");
-};
-dojo.html.getScrollOffset = function () {
-	return dojo.html._callDeprecated("getScrollOffset", "getScroll", arguments, null, "offset");
-};
-

Deleted: tags/parley-0.53/root/static/magic/src/html/display.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/display.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/display.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,147 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.html.display");
-dojo.require("dojo.html.style");
-dojo.html._toggle = function (node, tester, setter) {
-	node = dojo.byId(node);
-	setter(node, !tester(node));
-	return tester(node);
-};
-dojo.html.show = function (node) {
-	node = dojo.byId(node);
-	if (dojo.html.getStyleProperty(node, "display") == "none") {
-		dojo.html.setStyle(node, "display", (node.dojoDisplayCache || ""));
-		node.dojoDisplayCache = undefined;
-	}
-};
-dojo.html.hide = function (node) {
-	node = dojo.byId(node);
-	if (typeof node["dojoDisplayCache"] == "undefined") {
-		var d = dojo.html.getStyleProperty(node, "display");
-		if (d != "none") {
-			node.dojoDisplayCache = d;
-		}
-	}
-	dojo.html.setStyle(node, "display", "none");
-};
-dojo.html.setShowing = function (node, showing) {
-	dojo.html[(showing ? "show" : "hide")](node);
-};
-dojo.html.isShowing = function (node) {
-	return (dojo.html.getStyleProperty(node, "display") != "none");
-};
-dojo.html.toggleShowing = function (node) {
-	return dojo.html._toggle(node, dojo.html.isShowing, dojo.html.setShowing);
-};
-dojo.html.displayMap = {tr:"", td:"", th:"", img:"inline", span:"inline", input:"inline", button:"inline"};
-dojo.html.suggestDisplayByTagName = function (node) {
-	node = dojo.byId(node);
-	if (node && node.tagName) {
-		var tag = node.tagName.toLowerCase();
-		return (tag in dojo.html.displayMap ? dojo.html.displayMap[tag] : "block");
-	}
-};
-dojo.html.setDisplay = function (node, display) {
-	dojo.html.setStyle(node, "display", ((display instanceof String || typeof display == "string") ? display : (display ? dojo.html.suggestDisplayByTagName(node) : "none")));
-};
-dojo.html.isDisplayed = function (node) {
-	return (dojo.html.getComputedStyle(node, "display") != "none");
-};
-dojo.html.toggleDisplay = function (node) {
-	return dojo.html._toggle(node, dojo.html.isDisplayed, dojo.html.setDisplay);
-};
-dojo.html.setVisibility = function (node, visibility) {
-	dojo.html.setStyle(node, "visibility", ((visibility instanceof String || typeof visibility == "string") ? visibility : (visibility ? "visible" : "hidden")));
-};
-dojo.html.isVisible = function (node) {
-	return (dojo.html.getComputedStyle(node, "visibility") != "hidden");
-};
-dojo.html.toggleVisibility = function (node) {
-	return dojo.html._toggle(node, dojo.html.isVisible, dojo.html.setVisibility);
-};
-dojo.html.setOpacity = function (node, opacity, dontFixOpacity) {
-	node = dojo.byId(node);
-	var h = dojo.render.html;
-	if (!dontFixOpacity) {
-		if (opacity >= 1) {
-			if (h.ie) {
-				dojo.html.clearOpacity(node);
-				return;
-			} else {
-				opacity = 0.999999;
-			}
-		} else {
-			if (opacity < 0) {
-				opacity = 0;
-			}
-		}
-	}
-	if (h.ie) {
-		if (node.nodeName.toLowerCase() == "tr") {
-			var tds = node.getElementsByTagName("td");
-			for (var x = 0; x < tds.length; x++) {
-				tds[x].style.filter = "Alpha(Opacity=" + opacity * 100 + ")";
-			}
-		}
-		node.style.filter = "Alpha(Opacity=" + opacity * 100 + ")";
-	} else {
-		if (h.moz) {
-			node.style.opacity = opacity;
-			node.style.MozOpacity = opacity;
-		} else {
-			if (h.safari) {
-				node.style.opacity = opacity;
-				node.style.KhtmlOpacity = opacity;
-			} else {
-				node.style.opacity = opacity;
-			}
-		}
-	}
-};
-dojo.html.clearOpacity = function (node) {
-	node = dojo.byId(node);
-	var ns = node.style;
-	var h = dojo.render.html;
-	if (h.ie) {
-		try {
-			if (node.filters && node.filters.alpha) {
-				ns.filter = "";
-			}
-		}
-		catch (e) {
-		}
-	} else {
-		if (h.moz) {
-			ns.opacity = 1;
-			ns.MozOpacity = 1;
-		} else {
-			if (h.safari) {
-				ns.opacity = 1;
-				ns.KhtmlOpacity = 1;
-			} else {
-				ns.opacity = 1;
-			}
-		}
-	}
-};
-dojo.html.getOpacity = function (node) {
-	node = dojo.byId(node);
-	var h = dojo.render.html;
-	if (h.ie) {
-		var opac = (node.filters && node.filters.alpha && typeof node.filters.alpha.opacity == "number" ? node.filters.alpha.opacity : 100) / 100;
-	} else {
-		var opac = node.style.opacity || node.style.MozOpacity || node.style.KhtmlOpacity || 1;
-	}
-	return opac >= 0.999999 ? 1 : Number(opac);
-};
-

Added: tags/parley-0.53/root/static/magic/src/html/extras.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/extras.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/extras.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,428 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.require("dojo.html");
+dojo.provide("dojo.html.extras");
+dojo.require("dojo.string.extras"); 
+
+/**
+ * Calculates the mouse's direction of gravity relative to the centre
+ * of the given node.
+ * <p>
+ * If you wanted to insert a node into a DOM tree based on the mouse
+ * position you might use the following code:
+ * <pre>
+ * if (gravity(node, e) & gravity.NORTH) { [insert before]; }
+ * else { [insert after]; }
+ * </pre>
+ *
+ * @param node The node
+ * @param e		The event containing the mouse coordinates
+ * @return		 The directions, NORTH or SOUTH and EAST or WEST. These
+ *						 are properties of the function.
+ */
+dojo.html.gravity = function(node, e){
+	node = dojo.byId(node);
+	var mouse = dojo.html.getCursorPosition(e);
+
+	with (dojo.html) {
+		var nodecenterx = getAbsoluteX(node, true) + (getInnerWidth(node) / 2);
+		var nodecentery = getAbsoluteY(node, true) + (getInnerHeight(node) / 2);
+	}
+	
+	with (dojo.html.gravity) {
+		return ((mouse.x < nodecenterx ? WEST : EAST) |
+			(mouse.y < nodecentery ? NORTH : SOUTH));
+	}
+}
+
+dojo.html.gravity.NORTH = 1;
+dojo.html.gravity.SOUTH = 1 << 1;
+dojo.html.gravity.EAST = 1 << 2;
+dojo.html.gravity.WEST = 1 << 3;
+
+
+/**
+ * Attempts to return the text as it would be rendered, with the line breaks
+ * sorted out nicely. Unfinished.
+ */
+dojo.html.renderedTextContent = function(node){
+	node = dojo.byId(node);
+	var result = "";
+	if (node == null) { return result; }
+	for (var i = 0; i < node.childNodes.length; i++) {
+		switch (node.childNodes[i].nodeType) {
+			case 1: // ELEMENT_NODE
+			case 5: // ENTITY_REFERENCE_NODE
+				var display = "unknown";
+				try {
+					display = dojo.style.getStyle(node.childNodes[i], "display");
+				} catch(E) {}
+				switch (display) {
+					case "block": case "list-item": case "run-in":
+					case "table": case "table-row-group": case "table-header-group":
+					case "table-footer-group": case "table-row": case "table-column-group":
+					case "table-column": case "table-cell": case "table-caption":
+						// TODO: this shouldn't insert double spaces on aligning blocks
+						result += "\n";
+						result += dojo.html.renderedTextContent(node.childNodes[i]);
+						result += "\n";
+						break;
+					
+					case "none": break;
+					
+					default:
+						if(node.childNodes[i].tagName && node.childNodes[i].tagName.toLowerCase() == "br") {
+							result += "\n";
+						} else {
+							result += dojo.html.renderedTextContent(node.childNodes[i]);
+						}
+						break;
+				}
+				break;
+			case 3: // TEXT_NODE
+			case 2: // ATTRIBUTE_NODE
+			case 4: // CDATA_SECTION_NODE
+				var text = node.childNodes[i].nodeValue;
+				var textTransform = "unknown";
+				try {
+					textTransform = dojo.style.getStyle(node, "text-transform");
+				} catch(E) {}
+				switch (textTransform){
+					case "capitalize": text = dojo.string.capitalize(text); break;
+					case "uppercase": text = text.toUpperCase(); break;
+					case "lowercase": text = text.toLowerCase(); break;
+					default: break; // leave as is
+				}
+				// TODO: implement
+				switch (textTransform){
+					case "nowrap": break;
+					case "pre-wrap": break;
+					case "pre-line": break;
+					case "pre": break; // leave as is
+					default:
+						// remove whitespace and collapse first space
+						text = text.replace(/\s+/, " ");
+						if (/\s$/.test(result)) { text.replace(/^\s/, ""); }
+						break;
+				}
+				result += text;
+				break;
+			default:
+				break;
+		}
+	}
+	return result;
+}
+
+dojo.html.createNodesFromText = function(txt, trim){
+	if(trim) { txt = dojo.string.trim(txt); }
+
+	var tn = document.createElement("div");
+	// tn.style.display = "none";
+	tn.style.visibility= "hidden";
+	document.body.appendChild(tn);
+	var tableType = "none";
+	if((/^<t[dh][\s\r\n>]/i).test(dojo.string.trimStart(txt))) {
+		txt = "<table><tbody><tr>" + txt + "</tr></tbody></table>";
+		tableType = "cell";
+	} else if((/^<tr[\s\r\n>]/i).test(dojo.string.trimStart(txt))) {
+		txt = "<table><tbody>" + txt + "</tbody></table>";
+		tableType = "row";
+	} else if((/^<(thead|tbody|tfoot)[\s\r\n>]/i).test(dojo.string.trimStart(txt))) {
+		txt = "<table>" + txt + "</table>";
+		tableType = "section";
+	}
+	tn.innerHTML = txt;
+	if(tn["normalize"]){
+		tn.normalize();
+	}
+
+	var parent = null;
+	switch(tableType) {
+		case "cell":
+			parent = tn.getElementsByTagName("tr")[0];
+			break;
+		case "row":
+			parent = tn.getElementsByTagName("tbody")[0];
+			break;
+		case "section":
+			parent = tn.getElementsByTagName("table")[0];
+			break;
+		default:
+			parent = tn;
+			break;
+	}
+
+	/* this doesn't make much sense, I'm assuming it just meant trim() so wrap was replaced with trim
+	if(wrap){ 
+		var ret = [];
+		// start hack
+		var fc = tn.firstChild;
+		ret[0] = ((fc.nodeValue == " ")||(fc.nodeValue == "\t")) ? fc.nextSibling : fc;
+		// end hack
+		// tn.style.display = "none";
+		document.body.removeChild(tn);
+		return ret;
+	}
+	*/
+	var nodes = [];
+	for(var x=0; x<parent.childNodes.length; x++){
+		nodes.push(parent.childNodes[x].cloneNode(true));
+	}
+	tn.style.display = "none"; // FIXME: why do we do this?
+	document.body.removeChild(tn);
+	return nodes;
+}
+
+/* TODO: merge placeOnScreen and placeOnScreenPoint to make 1 function that allows you
+ * to define which corner(s) you want to bind to. Something like so:
+ *
+ * kes(node, desiredX, desiredY, "TR")
+ * kes(node, [desiredX, desiredY], ["TR", "BL"])
+ *
+ * TODO: make this function have variable call sigs
+ *
+ * kes(node, ptArray, cornerArray, padding, hasScroll)
+ * kes(node, ptX, ptY, cornerA, cornerB, cornerC, paddingArray, hasScroll)
+ */
+
+/**
+ * Keeps 'node' in the visible area of the screen while trying to
+ * place closest to desiredX, desiredY. The input coordinates are
+ * expected to be the desired screen position, not accounting for
+ * scrolling. If you already accounted for scrolling, set 'hasScroll'
+ * to true. Set padding to either a number or array for [paddingX, paddingY]
+ * to put some buffer around the element you want to position.
+ * NOTE: node is assumed to be absolutely or relatively positioned.
+ *
+ * Alternate call sig:
+ *  placeOnScreen(node, [x, y], padding, hasScroll)
+ *
+ * Examples:
+ *  placeOnScreen(node, 100, 200)
+ *  placeOnScreen("myId", [800, 623], 5)
+ *  placeOnScreen(node, 234, 3284, [2, 5], true)
+ */
+dojo.html.placeOnScreen = function(node, desiredX, desiredY, padding, hasScroll) {
+	if(dojo.lang.isArray(desiredX)) {
+		hasScroll = padding;
+		padding = desiredY;
+		desiredY = desiredX[1];
+		desiredX = desiredX[0];
+	}
+
+	if(!isNaN(padding)) {
+		padding = [Number(padding), Number(padding)];
+	} else if(!dojo.lang.isArray(padding)) {
+		padding = [0, 0];
+	}
+
+	var scroll = dojo.html.getScrollOffset();
+	var view = dojo.html.getViewportSize();
+
+	node = dojo.byId(node);
+	var w = node.offsetWidth + padding[0];
+	var h = node.offsetHeight + padding[1];
+
+	if(hasScroll) {
+		desiredX -= scroll.x;
+		desiredY -= scroll.y;
+	}
+
+	var x = desiredX + w;
+	if(x > view.w) {
+		x = view.w - w;
+	} else {
+		x = desiredX;
+	}
+	x = Math.max(padding[0], x) + scroll.x;
+
+	var y = desiredY + h;
+	if(y > view.h) {
+		y = view.h - h;
+	} else {
+		y = desiredY;
+	}
+	y = Math.max(padding[1], y) + scroll.y;
+
+	node.style.left = x + "px";
+	node.style.top = y + "px";
+
+	var ret = [x, y];
+	ret.x = x;
+	ret.y = y;
+	return ret;
+}
+
+/**
+ * Like placeOnScreenPoint except that it attempts to keep one of the node's
+ * corners at desiredX, desiredY.  Favors the bottom right position
+ *
+ * Examples placing node at mouse position (where e = [Mouse event]):
+ *  placeOnScreenPoint(node, e.clientX, e.clientY);
+ */
+dojo.html.placeOnScreenPoint = function(node, desiredX, desiredY, padding, hasScroll) {
+	if(dojo.lang.isArray(desiredX)) {
+		hasScroll = padding;
+		padding = desiredY;
+		desiredY = desiredX[1];
+		desiredX = desiredX[0];
+	}
+
+	if(!isNaN(padding)) {
+		padding = [Number(padding), Number(padding)];
+	} else if(!dojo.lang.isArray(padding)) {
+		padding = [0, 0];
+	}
+
+	var scroll = dojo.html.getScrollOffset();
+	var view = dojo.html.getViewportSize();
+
+	node = dojo.byId(node);
+	var oldDisplay = node.style.display;
+	node.style.display="";
+	var w = dojo.style.getInnerWidth(node);
+	var h = dojo.style.getInnerHeight(node);
+	node.style.display=oldDisplay;
+
+	if(hasScroll) {
+		desiredX -= scroll.x;
+		desiredY -= scroll.y;
+	}
+
+	var x = -1, y = -1;
+	//dojo.debug((desiredX+padding[0]) + w, "<=", view.w, "&&", (desiredY+padding[1]) + h, "<=", view.h);
+	if((desiredX+padding[0]) + w <= view.w && (desiredY+padding[1]) + h <= view.h) { // TL
+		x = (desiredX+padding[0]);
+		y = (desiredY+padding[1]);
+		//dojo.debug("TL", x, y);
+	}
+
+	//dojo.debug((desiredX-padding[0]), "<=", view.w, "&&", (desiredY+padding[1]) + h, "<=", view.h);
+	if((x < 0 || y < 0) && (desiredX-padding[0]) <= view.w && (desiredY+padding[1]) + h <= view.h) { // TR
+		x = (desiredX-padding[0]) - w;
+		y = (desiredY+padding[1]);
+		//dojo.debug("TR", x, y);
+	}
+
+	//dojo.debug((desiredX+padding[0]) + w, "<=", view.w, "&&", (desiredY-padding[1]), "<=", view.h);
+	if((x < 0 || y < 0) && (desiredX+padding[0]) + w <= view.w && (desiredY-padding[1]) <= view.h) { // BL
+		x = (desiredX+padding[0]);
+		y = (desiredY-padding[1]) - h;
+		//dojo.debug("BL", x, y);
+	}
+
+	//dojo.debug((desiredX-padding[0]), "<=", view.w, "&&", (desiredY-padding[1]), "<=", view.h);
+	if((x < 0 || y < 0) && (desiredX-padding[0]) <= view.w && (desiredY-padding[1]) <= view.h) { // BR
+		x = (desiredX-padding[0]) - w;
+		y = (desiredY-padding[1]) - h;
+		//dojo.debug("BR", x, y);
+	}
+
+	if(x < 0 || y < 0 || (x + w > view.w) || (y + h > view.h)) {
+		return dojo.html.placeOnScreen(node, desiredX, desiredY, padding, hasScroll);
+	}
+
+	x += scroll.x;
+	y += scroll.y;
+
+	node.style.left = x + "px";
+	node.style.top = y + "px";
+
+	var ret = [x, y];
+	ret.x = x;
+	ret.y = y;
+	return ret;
+}
+
+/**
+ * For IE z-index schenanigans
+ * Two possible uses:
+ *   1. new dojo.html.BackgroundIframe(node)
+ *        Makes a background iframe as a child of node, that fills area (and position) of node
+ *
+ *   2. new dojo.html.BackgroundIframe()
+ *        Attaches frame to document.body.  User must call size() to set size.
+ */
+dojo.html.BackgroundIframe = function(node) {
+	if(dojo.render.html.ie55 || dojo.render.html.ie60) {
+		var html=
+				 "<iframe "
+				+"style='position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;"
+				+        "z-index: -1; filter:Alpha(Opacity=\"0\");' "
+				+">";
+		this.iframe = document.createElement(html);
+		if(node){
+			node.appendChild(this.iframe);
+			this.domNode=node;
+		}else{
+			document.body.appendChild(this.iframe);
+			this.iframe.style.display="none";
+		}
+	}
+}
+dojo.lang.extend(dojo.html.BackgroundIframe, {
+	iframe: null,
+
+	// TODO: this function shouldn't be necessary but setting width=height=100% doesn't work!
+	onResized: function(){
+		if(this.iframe && this.domNode && this.domNode.parentElement){ // No parentElement if onResized() timeout event occurs on a removed domnode
+			var w = dojo.style.getOuterWidth(this.domNode);
+			var h = dojo.style.getOuterHeight(this.domNode);
+			if (w  == 0 || h == 0 ){
+				dojo.lang.setTimeout(this, this.onResized, 50);
+				return;
+			}
+			var s = this.iframe.style;
+			s.width = w + "px";
+			s.height = h + "px";
+		}
+	},
+
+	// Call this function if the iframe is connected to document.body rather
+	// than the node being shadowed (TODO: erase)
+	size: function(node) {
+		if(!this.iframe) { return; }
+
+		var coords = dojo.style.toCoordinateArray(node, true);
+
+		var s = this.iframe.style;
+		s.width = coords.w + "px";
+		s.height = coords.h + "px";
+		s.left = coords.x + "px";
+		s.top = coords.y + "px";
+	},
+
+	setZIndex: function(node /* or number */) {
+		if(!this.iframe) { return; }
+
+		if(dojo.dom.isNode(node)) {
+			this.iframe.style.zIndex = dojo.html.getStyle(node, "z-index") - 1;
+		} else if(!isNaN(node)) {
+			this.iframe.style.zIndex = node;
+		}
+	},
+
+	show: function() {
+		if(!this.iframe) { return; }
+		this.iframe.style.display = "block";
+	},
+
+	hide: function() {
+		if(!this.ie) { return; }
+		var s = this.iframe.style;
+		s.display = "none";
+	},
+
+	remove: function() {
+		dojo.dom.removeNode(this.iframe);
+	}
+});

Deleted: tags/parley-0.53/root/static/magic/src/html/iframe.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/iframe.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/iframe.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,84 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.html.iframe");
-dojo.require("dojo.html.util");
-dojo.html.iframeContentWindow = function (iframe_el) {
-	var win = dojo.html.getDocumentWindow(dojo.html.iframeContentDocument(iframe_el)) || dojo.html.iframeContentDocument(iframe_el).__parent__ || (iframe_el.name && document.frames[iframe_el.name]) || null;
-	return win;
-};
-dojo.html.iframeContentDocument = function (iframe_el) {
-	var doc = iframe_el.contentDocument || ((iframe_el.contentWindow) && (iframe_el.contentWindow.document)) || ((iframe_el.name) && (document.frames[iframe_el.name]) && (document.frames[iframe_el.name].document)) || null;
-	return doc;
-};
-dojo.html.BackgroundIframe = function (node) {
-	if (dojo.render.html.ie55 || dojo.render.html.ie60) {
-		var html = "<iframe src='javascript:false'" + " style='position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;" + "z-index: -1; filter:Alpha(Opacity=\"0\");' " + ">";
-		this.iframe = dojo.doc().createElement(html);
-		this.iframe.tabIndex = -1;
-		if (node) {
-			node.appendChild(this.iframe);
-			this.domNode = node;
-		} else {
-			dojo.body().appendChild(this.iframe);
-			this.iframe.style.display = "none";
-		}
-	}
-};
-dojo.lang.extend(dojo.html.BackgroundIframe, {iframe:null, onResized:function () {
-	if (this.iframe && this.domNode && this.domNode.parentNode) {
-		var outer = dojo.html.getMarginBox(this.domNode);
-		if (outer.width == 0 || outer.height == 0) {
-			dojo.lang.setTimeout(this, this.onResized, 100);
-			return;
-		}
-		this.iframe.style.width = outer.width + "px";
-		this.iframe.style.height = outer.height + "px";
-	}
-}, size:function (node) {
-	if (!this.iframe) {
-		return;
-	}
-	var coords = dojo.html.toCoordinateObject(node, true, dojo.html.boxSizing.BORDER_BOX);
-	with (this.iframe.style) {
-		width = coords.width + "px";
-		height = coords.height + "px";
-		left = coords.left + "px";
-		top = coords.top + "px";
-	}
-}, setZIndex:function (node) {
-	if (!this.iframe) {
-		return;
-	}
-	if (dojo.dom.isNode(node)) {
-		this.iframe.style.zIndex = dojo.html.getStyle(node, "z-index") - 1;
-	} else {
-		if (!isNaN(node)) {
-			this.iframe.style.zIndex = node;
-		}
-	}
-}, show:function () {
-	if (this.iframe) {
-		this.iframe.style.display = "block";
-	}
-}, hide:function () {
-	if (this.iframe) {
-		this.iframe.style.display = "none";
-	}
-}, remove:function () {
-	if (this.iframe) {
-		dojo.html.removeNode(this.iframe, true);
-		delete this.iframe;
-		this.iframe = null;
-	}
-}});
-

Added: tags/parley-0.53/root/static/magic/src/html/images/shadowTR..png
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/html/images/shadowTR..png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Modified: tags/parley-0.53/root/static/magic/src/html/layout.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/layout.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/layout.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,381 +8,114 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.html.layout");
-dojo.require("dojo.html.common");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.display");
-dojo.html.sumAncestorProperties = function (node, prop) {
-	node = dojo.byId(node);
-	if (!node) {
-		return 0;
-	}
-	var retVal = 0;
-	while (node) {
-		if (dojo.html.getComputedStyle(node, "position") == "fixed") {
-			return 0;
-		}
-		var val = node[prop];
-		if (val) {
-			retVal += val - 0;
-			if (node == dojo.body()) {
-				break;
-			}
-		}
-		node = node.parentNode;
-	}
-	return retVal;
-};
-dojo.html.setStyleAttributes = function (node, attributes) {
-	node = dojo.byId(node);
-	var splittedAttribs = attributes.replace(/(;)?\s*$/, "").split(";");
-	for (var i = 0; i < splittedAttribs.length; i++) {
-		var nameValue = splittedAttribs[i].split(":");
-		var name = nameValue[0].replace(/\s*$/, "").replace(/^\s*/, "").toLowerCase();
-		var value = nameValue[1].replace(/\s*$/, "").replace(/^\s*/, "");
-		switch (name) {
-		  case "opacity":
-			dojo.html.setOpacity(node, value);
-			break;
-		  case "content-height":
-			dojo.html.setContentBox(node, {height:value});
-			break;
-		  case "content-width":
-			dojo.html.setContentBox(node, {width:value});
-			break;
-		  case "outer-height":
-			dojo.html.setMarginBox(node, {height:value});
-			break;
-		  case "outer-width":
-			dojo.html.setMarginBox(node, {width:value});
-			break;
-		  default:
-			node.style[dojo.html.toCamelCase(name)] = value;
-		}
-	}
-};
-dojo.html.boxSizing = {MARGIN_BOX:"margin-box", BORDER_BOX:"border-box", PADDING_BOX:"padding-box", CONTENT_BOX:"content-box"};
-dojo.html.getAbsolutePosition = dojo.html.abs = function (node, includeScroll, boxType) {
-	node = dojo.byId(node, node.ownerDocument);
-	var ret = {x:0, y:0};
-	var bs = dojo.html.boxSizing;
-	if (!boxType) {
-		boxType = bs.CONTENT_BOX;
-	}
-	var nativeBoxType = 2;
-	var targetBoxType;
-	switch (boxType) {
-	  case bs.MARGIN_BOX:
-		targetBoxType = 3;
-		break;
-	  case bs.BORDER_BOX:
-		targetBoxType = 2;
-		break;
-	  case bs.PADDING_BOX:
-	  default:
-		targetBoxType = 1;
-		break;
-	  case bs.CONTENT_BOX:
-		targetBoxType = 0;
-		break;
-	}
-	var h = dojo.render.html;
-	var db = document["body"] || document["documentElement"];
-	if (h.ie) {
-		with (node.getBoundingClientRect()) {
-			ret.x = left - 2;
-			ret.y = top - 2;
-		}
-	} else {
-		if (document.getBoxObjectFor) {
-			nativeBoxType = 1;
-			try {
-				var bo = document.getBoxObjectFor(node);
-				ret.x = bo.x - dojo.html.sumAncestorProperties(node, "scrollLeft");
-				ret.y = bo.y - dojo.html.sumAncestorProperties(node, "scrollTop");
-			}
-			catch (e) {
-			}
-		} else {
-			if (node["offsetParent"]) {
-				var endNode;
-				if ((h.safari) && (node.style.getPropertyValue("position") == "absolute") && (node.parentNode == db)) {
-					endNode = db;
-				} else {
-					endNode = db.parentNode;
-				}
-				if (node.parentNode != db) {
-					var nd = node;
-					if (dojo.render.html.opera) {
-						nd = db;
-					}
-					ret.x -= dojo.html.sumAncestorProperties(nd, "scrollLeft");
-					ret.y -= dojo.html.sumAncestorProperties(nd, "scrollTop");
-				}
-				var curnode = node;
-				do {
-					var n = curnode["offsetLeft"];
-					if (!h.opera || n > 0) {
-						ret.x += isNaN(n) ? 0 : n;
-					}
-					var m = curnode["offsetTop"];
-					ret.y += isNaN(m) ? 0 : m;
-					curnode = curnode.offsetParent;
-				} while ((curnode != endNode) && (curnode != null));
-			} else {
-				if (node["x"] && node["y"]) {
-					ret.x += isNaN(node.x) ? 0 : node.x;
-					ret.y += isNaN(node.y) ? 0 : node.y;
-				}
-			}
-		}
-	}
-	if (includeScroll) {
-		var scroll = dojo.html.getScroll();
-		ret.y += scroll.top;
-		ret.x += scroll.left;
-	}
-	var extentFuncArray = [dojo.html.getPaddingExtent, dojo.html.getBorderExtent, dojo.html.getMarginExtent];
-	if (nativeBoxType > targetBoxType) {
-		for (var i = targetBoxType; i < nativeBoxType; ++i) {
-			ret.y += extentFuncArray[i](node, "top");
-			ret.x += extentFuncArray[i](node, "left");
-		}
-	} else {
-		if (nativeBoxType < targetBoxType) {
-			for (var i = targetBoxType; i > nativeBoxType; --i) {
-				ret.y -= extentFuncArray[i - 1](node, "top");
-				ret.x -= extentFuncArray[i - 1](node, "left");
-			}
-		}
-	}
-	ret.top = ret.y;
-	ret.left = ret.x;
-	return ret;
-};
-dojo.html.isPositionAbsolute = function (node) {
-	return (dojo.html.getComputedStyle(node, "position") == "absolute");
-};
-dojo.html._sumPixelValues = function (node, selectors, autoIsZero) {
-	var total = 0;
-	for (var x = 0; x < selectors.length; x++) {
-		total += dojo.html.getPixelValue(node, selectors[x], autoIsZero);
-	}
-	return total;
-};
-dojo.html.getMargin = function (node) {
-	return {width:dojo.html._sumPixelValues(node, ["margin-left", "margin-right"], (dojo.html.getComputedStyle(node, "position") == "absolute")), height:dojo.html._sumPixelValues(node, ["margin-top", "margin-bottom"], (dojo.html.getComputedStyle(node, "position") == "absolute"))};
-};
-dojo.html.getBorder = function (node) {
-	return {width:dojo.html.getBorderExtent(node, "left") + dojo.html.getBorderExtent(node, "right"), height:dojo.html.getBorderExtent(node, "top") + dojo.html.getBorderExtent(node, "bottom")};
-};
-dojo.html.getBorderExtent = function (node, side) {
-	return (dojo.html.getStyle(node, "border-" + side + "-style") == "none" ? 0 : dojo.html.getPixelValue(node, "border-" + side + "-width"));
-};
-dojo.html.getMarginExtent = function (node, side) {
-	return dojo.html._sumPixelValues(node, ["margin-" + side], dojo.html.isPositionAbsolute(node));
-};
-dojo.html.getPaddingExtent = function (node, side) {
-	return dojo.html._sumPixelValues(node, ["padding-" + side], true);
-};
-dojo.html.getPadding = function (node) {
-	return {width:dojo.html._sumPixelValues(node, ["padding-left", "padding-right"], true), height:dojo.html._sumPixelValues(node, ["padding-top", "padding-bottom"], true)};
-};
-dojo.html.getPadBorder = function (node) {
-	var pad = dojo.html.getPadding(node);
-	var border = dojo.html.getBorder(node);
-	return {width:pad.width + border.width, height:pad.height + border.height};
-};
-dojo.html.getBoxSizing = function (node) {
-	var h = dojo.render.html;
-	var bs = dojo.html.boxSizing;
-	if (((h.ie) || (h.opera)) && node.nodeName.toLowerCase() != "img") {
-		var cm = document["compatMode"];
-		if ((cm == "BackCompat") || (cm == "QuirksMode")) {
-			return bs.BORDER_BOX;
-		} else {
-			return bs.CONTENT_BOX;
-		}
-	} else {
-		if (arguments.length == 0) {
-			node = document.documentElement;
-		}
-		var sizing;
-		if (!h.ie) {
-			sizing = dojo.html.getStyle(node, "-moz-box-sizing");
-			if (!sizing) {
-				sizing = dojo.html.getStyle(node, "box-sizing");
-			}
-		}
-		return (sizing ? sizing : bs.CONTENT_BOX);
-	}
-};
-dojo.html.isBorderBox = function (node) {
-	return (dojo.html.getBoxSizing(node) == dojo.html.boxSizing.BORDER_BOX);
-};
-dojo.html.getBorderBox = function (node) {
-	node = dojo.byId(node);
-	return {width:node.offsetWidth, height:node.offsetHeight};
-};
-dojo.html.getPaddingBox = function (node) {
-	var box = dojo.html.getBorderBox(node);
-	var border = dojo.html.getBorder(node);
-	return {width:box.width - border.width, height:box.height - border.height};
-};
-dojo.html.getContentBox = function (node) {
-	node = dojo.byId(node);
-	var padborder = dojo.html.getPadBorder(node);
-	return {width:node.offsetWidth - padborder.width, height:node.offsetHeight - padborder.height};
-};
-dojo.html.setContentBox = function (node, args) {
-	node = dojo.byId(node);
-	var width = 0;
-	var height = 0;
-	var isbb = dojo.html.isBorderBox(node);
-	var padborder = (isbb ? dojo.html.getPadBorder(node) : {width:0, height:0});
-	var ret = {};
-	if (typeof args.width != "undefined") {
-		width = args.width + padborder.width;
-		ret.width = dojo.html.setPositivePixelValue(node, "width", width);
-	}
-	if (typeof args.height != "undefined") {
-		height = args.height + padborder.height;
-		ret.height = dojo.html.setPositivePixelValue(node, "height", height);
-	}
-	return ret;
-};
-dojo.html.getMarginBox = function (node) {
-	var borderbox = dojo.html.getBorderBox(node);
-	var margin = dojo.html.getMargin(node);
-	return {width:borderbox.width + margin.width, height:borderbox.height + margin.height};
-};
-dojo.html.setMarginBox = function (node, args) {
-	node = dojo.byId(node);
-	var width = 0;
-	var height = 0;
-	var isbb = dojo.html.isBorderBox(node);
-	var padborder = (!isbb ? dojo.html.getPadBorder(node) : {width:0, height:0});
-	var margin = dojo.html.getMargin(node);
-	var ret = {};
-	if (typeof args.width != "undefined") {
-		width = args.width - padborder.width;
-		width -= margin.width;
-		ret.width = dojo.html.setPositivePixelValue(node, "width", width);
-	}
-	if (typeof args.height != "undefined") {
-		height = args.height - padborder.height;
-		height -= margin.height;
-		ret.height = dojo.html.setPositivePixelValue(node, "height", height);
-	}
-	return ret;
-};
-dojo.html.getElementBox = function (node, type) {
-	var bs = dojo.html.boxSizing;
-	switch (type) {
-	  case bs.MARGIN_BOX:
-		return dojo.html.getMarginBox(node);
-	  case bs.BORDER_BOX:
-		return dojo.html.getBorderBox(node);
-	  case bs.PADDING_BOX:
-		return dojo.html.getPaddingBox(node);
-	  case bs.CONTENT_BOX:
-	  default:
-		return dojo.html.getContentBox(node);
-	}
-};
-dojo.html.toCoordinateObject = dojo.html.toCoordinateArray = function (coords, includeScroll, boxtype) {
-	if (coords instanceof Array || typeof coords == "array") {
-		dojo.deprecated("dojo.html.toCoordinateArray", "use dojo.html.toCoordinateObject({left: , top: , width: , height: }) instead", "0.5");
-		while (coords.length < 4) {
-			coords.push(0);
-		}
-		while (coords.length > 4) {
-			coords.pop();
-		}
-		var ret = {left:coords[0], top:coords[1], width:coords[2], height:coords[3]};
-	} else {
-		if (!coords.nodeType && !(coords instanceof String || typeof coords == "string") && ("width" in coords || "height" in coords || "left" in coords || "x" in coords || "top" in coords || "y" in coords)) {
-			var ret = {left:coords.left || coords.x || 0, top:coords.top || coords.y || 0, width:coords.width || 0, height:coords.height || 0};
-		} else {
-			var node = dojo.byId(coords);
-			var pos = dojo.html.abs(node, includeScroll, boxtype);
-			var marginbox = dojo.html.getMarginBox(node);
-			var ret = {left:pos.left, top:pos.top, width:marginbox.width, height:marginbox.height};
-		}
-	}
-	ret.x = ret.left;
-	ret.y = ret.top;
-	return ret;
-};
-dojo.html.setMarginBoxWidth = dojo.html.setOuterWidth = function (node, width) {
-	return dojo.html._callDeprecated("setMarginBoxWidth", "setMarginBox", arguments, "width");
-};
-dojo.html.setMarginBoxHeight = dojo.html.setOuterHeight = function () {
-	return dojo.html._callDeprecated("setMarginBoxHeight", "setMarginBox", arguments, "height");
-};
-dojo.html.getMarginBoxWidth = dojo.html.getOuterWidth = function () {
-	return dojo.html._callDeprecated("getMarginBoxWidth", "getMarginBox", arguments, null, "width");
-};
-dojo.html.getMarginBoxHeight = dojo.html.getOuterHeight = function () {
-	return dojo.html._callDeprecated("getMarginBoxHeight", "getMarginBox", arguments, null, "height");
-};
-dojo.html.getTotalOffset = function (node, type, includeScroll) {
-	return dojo.html._callDeprecated("getTotalOffset", "getAbsolutePosition", arguments, null, type);
-};
-dojo.html.getAbsoluteX = function (node, includeScroll) {
-	return dojo.html._callDeprecated("getAbsoluteX", "getAbsolutePosition", arguments, null, "x");
-};
-dojo.html.getAbsoluteY = function (node, includeScroll) {
-	return dojo.html._callDeprecated("getAbsoluteY", "getAbsolutePosition", arguments, null, "y");
-};
-dojo.html.totalOffsetLeft = function (node, includeScroll) {
-	return dojo.html._callDeprecated("totalOffsetLeft", "getAbsolutePosition", arguments, null, "left");
-};
-dojo.html.totalOffsetTop = function (node, includeScroll) {
-	return dojo.html._callDeprecated("totalOffsetTop", "getAbsolutePosition", arguments, null, "top");
-};
-dojo.html.getMarginWidth = function (node) {
-	return dojo.html._callDeprecated("getMarginWidth", "getMargin", arguments, null, "width");
-};
-dojo.html.getMarginHeight = function (node) {
-	return dojo.html._callDeprecated("getMarginHeight", "getMargin", arguments, null, "height");
-};
-dojo.html.getBorderWidth = function (node) {
-	return dojo.html._callDeprecated("getBorderWidth", "getBorder", arguments, null, "width");
-};
-dojo.html.getBorderHeight = function (node) {
-	return dojo.html._callDeprecated("getBorderHeight", "getBorder", arguments, null, "height");
-};
-dojo.html.getPaddingWidth = function (node) {
-	return dojo.html._callDeprecated("getPaddingWidth", "getPadding", arguments, null, "width");
-};
-dojo.html.getPaddingHeight = function (node) {
-	return dojo.html._callDeprecated("getPaddingHeight", "getPadding", arguments, null, "height");
-};
-dojo.html.getPadBorderWidth = function (node) {
-	return dojo.html._callDeprecated("getPadBorderWidth", "getPadBorder", arguments, null, "width");
-};
-dojo.html.getPadBorderHeight = function (node) {
-	return dojo.html._callDeprecated("getPadBorderHeight", "getPadBorder", arguments, null, "height");
-};
-dojo.html.getBorderBoxWidth = dojo.html.getInnerWidth = function () {
-	return dojo.html._callDeprecated("getBorderBoxWidth", "getBorderBox", arguments, null, "width");
-};
-dojo.html.getBorderBoxHeight = dojo.html.getInnerHeight = function () {
-	return dojo.html._callDeprecated("getBorderBoxHeight", "getBorderBox", arguments, null, "height");
-};
-dojo.html.getContentBoxWidth = dojo.html.getContentWidth = function () {
-	return dojo.html._callDeprecated("getContentBoxWidth", "getContentBox", arguments, null, "width");
-};
-dojo.html.getContentBoxHeight = dojo.html.getContentHeight = function () {
-	return dojo.html._callDeprecated("getContentBoxHeight", "getContentBox", arguments, null, "height");
-};
-dojo.html.setContentBoxWidth = dojo.html.setContentWidth = function (node, width) {
-	return dojo.html._callDeprecated("setContentBoxWidth", "setContentBox", arguments, "width");
-};
-dojo.html.setContentBoxHeight = dojo.html.setContentHeight = function (node, height) {
-	return dojo.html._callDeprecated("setContentBoxHeight", "setContentBox", arguments, "height");
-};
-
+dojo.provide("dojo.html.layout");
+
+dojo.require("dojo.lang");
+dojo.require("dojo.string");
+dojo.require("dojo.style");
+dojo.require("dojo.html");
+
+/**
+ * Layout a bunch of child dom nodes within a parent dom node
+ * Input is an array of objects like:
+ * @ container - parent node
+ * @ layoutPriority - "top-bottom" or "left-right"
+ * @ children an array like [ {domNode: foo, layoutAlign: "bottom" }, {domNode: bar, layoutAlign: "client"} ]
+ */
+dojo.html.layout = function(container, children, layoutPriority) {
+	dojo.html.addClass(container, "dojoLayoutContainer");
+
+	// Copy children array and remove elements w/out layout.
+	// Also record each child's position in the input array, for sorting purposes.
+	children = dojo.lang.filter(children, function(child, idx){
+		child.idx = idx;
+		return dojo.lang.inArray(["top","bottom","left","right","client","flood"], child.layoutAlign)
+	});
+
+	// Order the children according to layoutPriority.
+	// Multiple children w/the same layoutPriority will be sorted by their position in the input array.
+	if(layoutPriority && layoutPriority!="none"){
+		var rank = function(child){
+			switch(child.layoutAlign){
+				case "flood":
+					return 1;
+				case "left":
+				case "right":
+					return (layoutPriority=="left-right") ? 2 : 3;
+				case "top":
+				case "bottom":
+					return (layoutPriority=="left-right") ? 3 : 2;
+				default:
+					return 4;
+			}
+		};
+		children.sort(function(a,b){
+			return (rank(a)-rank(b)) || (a.idx - b.idx);
+		});
+	}
+
+	// remaining space (blank area where nothing has been written)
+	var f={
+		top: dojo.style.getPixelValue(container, "padding-top", true),
+		left: dojo.style.getPixelValue(container, "padding-left", true),
+		height: dojo.style.getContentHeight(container),
+		width: dojo.style.getContentWidth(container)
+	};
+
+	// set positions/sizes
+	dojo.lang.forEach(children, function(child){
+		var elm=child.domNode;
+		var pos=child.layoutAlign;
+		// set elem to upper left corner of unused space; may move it later
+		with(elm.style){
+			left = f.left+"px";
+			top = f.top+"px";
+			bottom = "auto";
+			right = "auto";
+		}
+		dojo.html.addClass(elm, "dojoAlign" + dojo.string.capitalize(pos));
+
+		// set size && adjust record of remaining space.
+		// note that setting the width of a <div> may affect it's height.
+		// TODO: same is true for widgets but need to implement API to support that
+		if ( (pos=="top")||(pos=="bottom") ) {
+			dojo.style.setOuterWidth(elm, f.width);
+			var h = dojo.style.getOuterHeight(elm);
+			f.height -= h;
+			if(pos=="top"){
+				f.top += h;
+			}else{
+				elm.style.top = f.top + f.height + "px";
+			}
+		}else if(pos=="left" || pos=="right"){
+			dojo.style.setOuterHeight(elm, f.height);
+			var w = dojo.style.getOuterWidth(elm);
+			f.width -= w;
+			if(pos=="left"){
+				f.left += w;
+			}else{
+				elm.style.left = f.left + f.width + "px";
+			}
+		} else if(pos=="flood" || pos=="client"){
+			dojo.style.setOuterWidth(elm, f.width);
+			dojo.style.setOuterHeight(elm, f.height);
+		}
+		
+		// TODO: for widgets I want to call resizeTo(), but for top/bottom
+		// alignment I only want to set the width, and have the size determined
+		// dynamically.  (The thinner you make a div, the more height it consumes.)
+		if(child.onResized){
+			child.onResized();
+		}
+	});
+};
+
+// This is essential CSS to make layout work (it isn't "styling" CSS)
+// make sure that the position:absolute in dojoAlign* overrides other classes
+dojo.style.insertCssText(
+	".dojoLayoutContainer{ position: relative; display: block; }\n" +
+	"body .dojoAlignTop, body .dojoAlignBottom, body .dojoAlignLeft, body .dojoAlignRight { position: absolute; overflow: hidden; }\n" +
+	"body .dojoAlignClient { position: absolute }\n" +
+	".dojoAlignClient { overflow: auto; }\n"
+);
+

Deleted: tags/parley-0.53/root/static/magic/src/html/metrics.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/metrics.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/metrics.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,215 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.html.metrics");
-dojo.require("dojo.html.layout");
-dojo.html.getScrollbar = function () {
-	var scroll = document.createElement("div");
-	scroll.style.width = "100px";
-	scroll.style.height = "100px";
-	scroll.style.overflow = "scroll";
-	scroll.style.position = "absolute";
-	scroll.style.top = "-300px";
-	scroll.style.left = "0px";
-	var test = document.createElement("div");
-	test.style.width = "400px";
-	test.style.height = "400px";
-	scroll.appendChild(test);
-	dojo.body().appendChild(scroll);
-	var width = scroll.offsetWidth - scroll.clientWidth;
-	dojo.body().removeChild(scroll);
-	scroll.removeChild(test);
-	scroll = test = null;
-	return {width:width};
-};
-dojo.html.getFontMeasurements = function () {
-	var heights = {"1em":0, "1ex":0, "100%":0, "12pt":0, "16px":0, "xx-small":0, "x-small":0, "small":0, "medium":0, "large":0, "x-large":0, "xx-large":0};
-	if (dojo.render.html.ie) {
-		document.documentElement.style.fontSize = "100%";
-	}
-	var div = document.createElement("div");
-	div.style.position = "absolute";
-	div.style.left = "-100px";
-	div.style.top = "0";
-	div.style.width = "30px";
-	div.style.height = "1000em";
-	div.style.border = "0";
-	div.style.margin = "0";
-	div.style.padding = "0";
-	div.style.outline = "0";
-	div.style.lineHeight = "1";
-	div.style.overflow = "hidden";
-	dojo.body().appendChild(div);
-	for (var p in heights) {
-		div.style.fontSize = p;
-		heights[p] = Math.round(div.offsetHeight * 12 / 16) * 16 / 12 / 1000;
-	}
-	dojo.body().removeChild(div);
-	div = null;
-	return heights;
-};
-dojo.html._fontMeasurements = null;
-dojo.html.getCachedFontMeasurements = function (recalculate) {
-	if (recalculate || !dojo.html._fontMeasurements) {
-		dojo.html._fontMeasurements = dojo.html.getFontMeasurements();
-	}
-	return dojo.html._fontMeasurements;
-};
-dojo.html.measureFragment = function (node, html, boxType) {
-	var clone = node.cloneNode(true);
-	clone.innerHTML = html;
-	node.parentNode.appendChild(clone);
-	var ret = dojo.html.getElementBox(clone, boxType);
-	node.parentNode.removeChild(clone);
-	clone = null;
-	return ret;
-};
-dojo.html.getFittedFragment = function (node, html) {
-	function cl(node) {
-		var element = document.createElement(node.tagName);
-		element.id = node.id + "-clone";
-		element.className = node.className;
-		for (var j = 0; j < node.attributes.length; j++) {
-			if (node.attributes[j].specified) {
-				if (node.attributes[j].nodeName.toLowerCase() != "style" && node.attributes[j].nodeName.toLowerCase() != "edited" && node.attributes[j].nodeName.toLowerCase() != "contenteditable" && node.attributes[j].nodeName.toLowerCase() != "id" && node.attributes[j].nodeName.toLowerCase() != "class") {
-					element.setAttribute(node.attributes[j].nodeName.toLowerCase(), node.attributes[j].nodeValue);
-				}
-			}
-		}
-		return element;
-	}
-	var height = dojo.html.getFontMeasurements()["16px"];
-	var n = cl(node);
-	n.style.width = dojo.html.getBorderBox(node).width + "px";
-	n.style.height = (height + 4) + "px";
-	node.parentNode.appendChild(n);
-	var rem = dojo.html.fitToElement(n, html);
-	var ret = n.innerHTML;
-	n.parentNode.removeChild(n);
-	return ret;
-};
-dojo.html.fitToElement = function (node, html) {
-	function cl(node) {
-		var element = document.createElement(node.tagName);
-		element.id = node.id + "-clone";
-		element.className = node.className;
-		for (var j = 0; j < node.attributes.length; j++) {
-			if (node.attributes[j].specified) {
-				if (node.attributes[j].nodeName.toLowerCase() != "style" && node.attributes[j].nodeName.toLowerCase() != "edited" && node.attributes[j].nodeName.toLowerCase() != "contenteditable" && node.attributes[j].nodeName.toLowerCase() != "id" && node.attributes[j].nodeName.toLowerCase() != "class") {
-					element.setAttribute(node.attributes[j].nodeName.toLowerCase(), node.attributes[j].nodeValue);
-				}
-			}
-		}
-		return element;
-	}
-	var clone = cl(node);
-	node.parentNode.appendChild(clone);
-	var t = dojo.html.getBorderBox(node);
-	clone.style.width = t.width + "px";
-	var singletons = ["br", "img", "hr", "input", "!--"];
-	var chop = ["<BR>", "<br>", "<br/>", "<br />", "<p></p>", "<P></P>"];
-	var openTags = [];
-	var str = html;
-	var i = 0;
-	var limit = str.length;
-	var add = 0;
-	var doLoop = true;
-	clone.innerHTML = str;
-	while (doLoop) {
-		add = Math.round((limit - i) / 2);
-		if (add <= 1) {
-			doLoop = false;
-		}
-		i += add;
-		clone.innerHTML = str.substr(0, i);
-		if (clone.offsetHeight > t.height) {
-			limit = i;
-			i -= add;
-		}
-	}
-	if (str.substr(0, i) != str) {
-		var lastSpace = str.substr(0, i).lastIndexOf(" ");
-		var lastNewLine = str.substr(0, i).lastIndexOf("\n");
-		var lastGreater = str.substr(0, i).lastIndexOf(">");
-		var lastLess = str.substr(0, i).lastIndexOf("<");
-		if (lastLess <= lastGreater && lastNewLine == i - 1) {
-			i = i;
-		} else {
-			if (lastSpace != -1 && lastSpace > lastGreater && lastGreater > lastLess) {
-				i = lastSpace + 1;
-			} else {
-				if (lastLess > lastGreater) {
-					i = lastLess;
-				} else {
-					if (lastGreater != -1) {
-						i = lastGreater + 1;
-					}
-				}
-			}
-		}
-	}
-	str = str.substr(0, i);
-	var ret = html.substr(str.length);
-	var doPush = true;
-	var tags = str.split("<");
-	tags.shift();
-	for (var j = 0; j < tags.length; j++) {
-		tags[j] = tags[j].split(">")[0];
-		if (tags[j].charAt(tags[j].length - 1) == "/") {
-			continue;
-		}
-		if (tags[j].charAt(0) != "/") {
-			for (var k = 0; k < singletons.length; k++) {
-				if (tags[j].split(" ")[0].toLowerCase() == singletons[k]) {
-					doPush = false;
-				}
-			}
-			if (doPush) {
-				openTags.push(tags[j]);
-			}
-			doPush = true;
-		} else {
-			openTags.pop();
-		}
-	}
-	for (var j = 0; j < chop.length; j++) {
-		if (ret.charAt(0) == "\n") {
-			ret = ret.substr(1);
-		}
-		while (ret.indexOf(chop[j]) == 0) {
-			ret = ret.substr(chop[j].length);
-		}
-	}
-	for (var j = openTags.length - 1; j >= 0; j--) {
-		if (str.lastIndexOf(openTags[j]) == (str.length - openTags[j].length - 1)) {
-			str = str.substring(0, str.lastIndexOf(openTags[j]));
-		} else {
-			str += "</" + openTags[j] + ">";
-		}
-		if (ret.length > 0) {
-			ret = "<" + openTags[j] + ">" + ret;
-		}
-	}
-	for (var j = 0; j < chop.length; j++) {
-		if (ret.charAt(0) == "\n") {
-			ret = ret.substr(1);
-		}
-		while (ret.indexOf(chop[j]) == 0) {
-			ret = ret.substr(chop[j].length);
-		}
-	}
-	node.innerHTML = str;
-	clone.parentNode.removeChild(clone);
-	clone = null;
-	return ret;
-};
-

Deleted: tags/parley-0.53/root/static/magic/src/html/selection.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/selection.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/selection.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,339 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.require("dojo.html.common");
-dojo.provide("dojo.html.selection");
-dojo.require("dojo.dom");
-dojo.require("dojo.lang.common");
-dojo.html.selectionType = {NONE:0, TEXT:1, CONTROL:2};
-dojo.html.clearSelection = function () {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	try {
-		if (_window["getSelection"]) {
-			if (dojo.render.html.safari) {
-				_window.getSelection().collapse();
-			} else {
-				_window.getSelection().removeAllRanges();
-			}
-		} else {
-			if (_document.selection) {
-				if (_document.selection.empty) {
-					_document.selection.empty();
-				} else {
-					if (_document.selection.clear) {
-						_document.selection.clear();
-					}
-				}
-			}
-		}
-		return true;
-	}
-	catch (e) {
-		dojo.debug(e);
-		return false;
-	}
-};
-dojo.html.disableSelection = function (element) {
-	element = dojo.byId(element) || dojo.body();
-	var h = dojo.render.html;
-	if (h.mozilla) {
-		element.style.MozUserSelect = "none";
-	} else {
-		if (h.safari) {
-			element.style.KhtmlUserSelect = "none";
-		} else {
-			if (h.ie) {
-				element.unselectable = "on";
-			} else {
-				return false;
-			}
-		}
-	}
-	return true;
-};
-dojo.html.enableSelection = function (element) {
-	element = dojo.byId(element) || dojo.body();
-	var h = dojo.render.html;
-	if (h.mozilla) {
-		element.style.MozUserSelect = "";
-	} else {
-		if (h.safari) {
-			element.style.KhtmlUserSelect = "";
-		} else {
-			if (h.ie) {
-				element.unselectable = "off";
-			} else {
-				return false;
-			}
-		}
-	}
-	return true;
-};
-dojo.html.selectElement = function (element) {
-	dojo.deprecated("dojo.html.selectElement", "replaced by dojo.html.selection.selectElementChildren", 0.5);
-};
-dojo.html.selectInputText = function (element) {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	element = dojo.byId(element);
-	if (_document["selection"] && dojo.body()["createTextRange"]) {
-		var range = element.createTextRange();
-		range.moveStart("character", 0);
-		range.moveEnd("character", element.value.length);
-		range.select();
-	} else {
-		if (_window["getSelection"]) {
-			var selection = _window.getSelection();
-			element.setSelectionRange(0, element.value.length);
-		}
-	}
-	element.focus();
-};
-dojo.html.isSelectionCollapsed = function () {
-	dojo.deprecated("dojo.html.isSelectionCollapsed", "replaced by dojo.html.selection.isCollapsed", 0.5);
-	return dojo.html.selection.isCollapsed();
-};
-dojo.lang.mixin(dojo.html.selection, {getType:function () {
-	if (dojo.doc()["selection"]) {
-		return dojo.html.selectionType[dojo.doc().selection.type.toUpperCase()];
-	} else {
-		var stype = dojo.html.selectionType.TEXT;
-		var oSel;
-		try {
-			oSel = dojo.global().getSelection();
-		}
-		catch (e) {
-		}
-		if (oSel && oSel.rangeCount == 1) {
-			var oRange = oSel.getRangeAt(0);
-			if (oRange.startContainer == oRange.endContainer && (oRange.endOffset - oRange.startOffset) == 1 && oRange.startContainer.nodeType != dojo.dom.TEXT_NODE) {
-				stype = dojo.html.selectionType.CONTROL;
-			}
-		}
-		return stype;
-	}
-}, isCollapsed:function () {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	if (_document["selection"]) {
-		return _document.selection.createRange().text == "";
-	} else {
-		if (_window["getSelection"]) {
-			var selection = _window.getSelection();
-			if (dojo.lang.isString(selection)) {
-				return selection == "";
-			} else {
-				return selection.isCollapsed || selection.toString() == "";
-			}
-		}
-	}
-}, getSelectedElement:function () {
-	if (dojo.html.selection.getType() == dojo.html.selectionType.CONTROL) {
-		if (dojo.doc()["selection"]) {
-			var range = dojo.doc().selection.createRange();
-			if (range && range.item) {
-				return dojo.doc().selection.createRange().item(0);
-			}
-		} else {
-			var selection = dojo.global().getSelection();
-			return selection.anchorNode.childNodes[selection.anchorOffset];
-		}
-	}
-}, getParentElement:function () {
-	if (dojo.html.selection.getType() == dojo.html.selectionType.CONTROL) {
-		var p = dojo.html.selection.getSelectedElement();
-		if (p) {
-			return p.parentNode;
-		}
-	} else {
-		if (dojo.doc()["selection"]) {
-			return dojo.doc().selection.createRange().parentElement();
-		} else {
-			var selection = dojo.global().getSelection();
-			if (selection) {
-				var node = selection.anchorNode;
-				while (node && node.nodeType != dojo.dom.ELEMENT_NODE) {
-					node = node.parentNode;
-				}
-				return node;
-			}
-		}
-	}
-}, getSelectedText:function () {
-	if (dojo.doc()["selection"]) {
-		if (dojo.html.selection.getType() == dojo.html.selectionType.CONTROL) {
-			return null;
-		}
-		return dojo.doc().selection.createRange().text;
-	} else {
-		var selection = dojo.global().getSelection();
-		if (selection) {
-			return selection.toString();
-		}
-	}
-}, getSelectedHtml:function () {
-	if (dojo.doc()["selection"]) {
-		if (dojo.html.selection.getType() == dojo.html.selectionType.CONTROL) {
-			return null;
-		}
-		return dojo.doc().selection.createRange().htmlText;
-	} else {
-		var selection = dojo.global().getSelection();
-		if (selection && selection.rangeCount) {
-			var frag = selection.getRangeAt(0).cloneContents();
-			var div = document.createElement("div");
-			div.appendChild(frag);
-			return div.innerHTML;
-		}
-		return null;
-	}
-}, hasAncestorElement:function (tagName) {
-	return (dojo.html.selection.getAncestorElement.apply(this, arguments) != null);
-}, getAncestorElement:function (tagName) {
-	var node = dojo.html.selection.getSelectedElement() || dojo.html.selection.getParentElement();
-	while (node) {
-		if (dojo.html.selection.isTag(node, arguments).length > 0) {
-			return node;
-		}
-		node = node.parentNode;
-	}
-	return null;
-}, isTag:function (node, tags) {
-	if (node && node.tagName) {
-		for (var i = 0; i < tags.length; i++) {
-			if (node.tagName.toLowerCase() == String(tags[i]).toLowerCase()) {
-				return String(tags[i]).toLowerCase();
-			}
-		}
-	}
-	return "";
-}, selectElement:function (element) {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	element = dojo.byId(element);
-	if (_document.selection && dojo.body().createTextRange) {
-		try {
-			var range = dojo.body().createControlRange();
-			range.addElement(element);
-			range.select();
-		}
-		catch (e) {
-			dojo.html.selection.selectElementChildren(element);
-		}
-	} else {
-		if (_window["getSelection"]) {
-			var selection = _window.getSelection();
-			if (selection["removeAllRanges"]) {
-				var range = _document.createRange();
-				range.selectNode(element);
-				selection.removeAllRanges();
-				selection.addRange(range);
-			}
-		}
-	}
-}, selectElementChildren:function (element) {
-	var _window = dojo.global();
-	var _document = dojo.doc();
-	element = dojo.byId(element);
-	if (_document.selection && dojo.body().createTextRange) {
-		var range = dojo.body().createTextRange();
-		range.moveToElementText(element);
-		range.select();
-	} else {
-		if (_window["getSelection"]) {
-			var selection = _window.getSelection();
-			if (selection["setBaseAndExtent"]) {
-				selection.setBaseAndExtent(element, 0, element, element.innerText.length - 1);
-			} else {
-				if (selection["selectAllChildren"]) {
-					selection.selectAllChildren(element);
-				}
-			}
-		}
-	}
-}, getBookmark:function () {
-	var bookmark;
-	var _document = dojo.doc();
-	if (_document["selection"]) {
-		var range = _document.selection.createRange();
-		bookmark = range.getBookmark();
-	} else {
-		var selection;
-		try {
-			selection = dojo.global().getSelection();
-		}
-		catch (e) {
-		}
-		if (selection) {
-			var range = selection.getRangeAt(0);
-			bookmark = range.cloneRange();
-		} else {
-			dojo.debug("No idea how to store the current selection for this browser!");
-		}
-	}
-	return bookmark;
-}, moveToBookmark:function (bookmark) {
-	var _document = dojo.doc();
-	if (_document["selection"]) {
-		var range = _document.selection.createRange();
-		range.moveToBookmark(bookmark);
-		range.select();
-	} else {
-		var selection;
-		try {
-			selection = dojo.global().getSelection();
-		}
-		catch (e) {
-		}
-		if (selection && selection["removeAllRanges"]) {
-			selection.removeAllRanges();
-			selection.addRange(bookmark);
-		} else {
-			dojo.debug("No idea how to restore selection for this browser!");
-		}
-	}
-}, collapse:function (beginning) {
-	if (dojo.global()["getSelection"]) {
-		var selection = dojo.global().getSelection();
-		if (selection.removeAllRanges) {
-			if (beginning) {
-				selection.collapseToStart();
-			} else {
-				selection.collapseToEnd();
-			}
-		} else {
-			dojo.global().getSelection().collapse(beginning);
-		}
-	} else {
-		if (dojo.doc().selection) {
-			var range = dojo.doc().selection.createRange();
-			range.collapse(beginning);
-			range.select();
-		}
-	}
-}, remove:function () {
-	if (dojo.doc().selection) {
-		var selection = dojo.doc().selection;
-		if (selection.type.toUpperCase() != "NONE") {
-			selection.clear();
-		}
-		return selection;
-	} else {
-		var selection = dojo.global().getSelection();
-		for (var i = 0; i < selection.rangeCount; i++) {
-			selection.getRangeAt(i).deleteContents();
-		}
-		return selection;
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/html/shadow.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/shadow.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/shadow.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,10 +8,72 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.html.shadow");
-dojo.require("dojo.lfx.shadow");
-dojo.deprecated("dojo.html.shadow has been moved to dojo.lfx.", "0.5");
-dojo.html.shadow = dojo.lfx.shadow;
-
+dojo.provide("dojo.html.shadow");
+
+dojo.require("dojo.lang");
+dojo.require("dojo.uri");
+
+dojo.html.shadow = function(node) {
+	this.init(node);
+}
+
+dojo.lang.extend(dojo.html.shadow, {
+
+	shadowPng: dojo.uri.dojoUri("src/html/images/shadow"),
+	shadowThickness: 8,
+	shadowOffset: 15,
+
+	init: function(node){
+		this.node=node;
+
+		// make all the pieces of the shadow, and position/size them as much
+		// as possible (but a lot of the coordinates are set in sizeShadow
+		this.pieces={};
+		var x1 = -1 * this.shadowThickness;
+		var y0 = this.shadowOffset;
+		var y1 = this.shadowOffset + this.shadowThickness;
+		this._makePiece("tl", "top", y0, "left", x1);
+		this._makePiece("l", "top", y1, "left", x1, "scale");
+		this._makePiece("tr", "top", y0, "left", 0);
+		this._makePiece("r", "top", y1, "left", 0, "scale");
+		this._makePiece("bl", "top", 0, "left", x1);
+		this._makePiece("b", "top", 0, "left", 0, "crop");
+		this._makePiece("br", "top", 0, "left", 0);
+	},
+
+	_makePiece: function(name, vertAttach, vertCoord, horzAttach, horzCoord, sizing){
+		var img;
+		var url = this.shadowPng + name.toUpperCase() + ".png";
+		if(dojo.render.html.ie){
+			img=document.createElement("div");
+			img.style.filter="progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+url+"'"+
+			(sizing?", sizingMethod='"+sizing+"'":"") + ")";
+		}else{
+			img=document.createElement("img");
+			img.src=url;
+		}
+		img.style.position="absolute";
+		img.style[vertAttach]=vertCoord+"px";
+		img.style[horzAttach]=horzCoord+"px";
+		img.style.width=this.shadowThickness+"px";
+		img.style.height=this.shadowThickness+"px";
+		this.pieces[name]=img;
+		this.node.appendChild(img);
+	},
+
+	size: function(width, height){
+		var sideHeight = height - (this.shadowOffset+this.shadowThickness+1);
+		with(this.pieces){
+			l.style.height = sideHeight+"px";
+			r.style.height = sideHeight+"px";
+			b.style.width = (width-1)+"px";
+			bl.style.top = (height-1)+"px";
+			b.style.top = (height-1)+"px";
+			br.style.top = (height-1)+"px";
+			tr.style.left = (width-1)+"px";
+			r.style.left = (width-1)+"px";
+			br.style.left = (width-1)+"px";
+		}
+	}
+});
+

Deleted: tags/parley-0.53/root/static/magic/src/html/style.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/style.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/style.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,483 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.html.style");
-dojo.require("dojo.html.common");
-dojo.require("dojo.uri.Uri");
-dojo.html.getClass = function (node) {
-	node = dojo.byId(node);
-	if (!node) {
-		return "";
-	}
-	var cs = "";
-	if (node.className) {
-		cs = node.className;
-	} else {
-		if (dojo.html.hasAttribute(node, "class")) {
-			cs = dojo.html.getAttribute(node, "class");
-		}
-	}
-	return cs.replace(/^\s+|\s+$/g, "");
-};
-dojo.html.getClasses = function (node) {
-	var c = dojo.html.getClass(node);
-	return (c == "") ? [] : c.split(/\s+/g);
-};
-dojo.html.hasClass = function (node, classname) {
-	return (new RegExp("(^|\\s+)" + classname + "(\\s+|$)")).test(dojo.html.getClass(node));
-};
-dojo.html.prependClass = function (node, classStr) {
-	classStr += " " + dojo.html.getClass(node);
-	return dojo.html.setClass(node, classStr);
-};
-dojo.html.addClass = function (node, classStr) {
-	if (dojo.html.hasClass(node, classStr)) {
-		return false;
-	}
-	classStr = (dojo.html.getClass(node) + " " + classStr).replace(/^\s+|\s+$/g, "");
-	return dojo.html.setClass(node, classStr);
-};
-dojo.html.setClass = function (node, classStr) {
-	node = dojo.byId(node);
-	var cs = new String(classStr);
-	try {
-		if (typeof node.className == "string") {
-			node.className = cs;
-		} else {
-			if (node.setAttribute) {
-				node.setAttribute("class", classStr);
-				node.className = cs;
-			} else {
-				return false;
-			}
-		}
-	}
-	catch (e) {
-		dojo.debug("dojo.html.setClass() failed", e);
-	}
-	return true;
-};
-dojo.html.removeClass = function (node, classStr, allowPartialMatches) {
-	try {
-		if (!allowPartialMatches) {
-			var newcs = dojo.html.getClass(node).replace(new RegExp("(^|\\s+)" + classStr + "(\\s+|$)"), "$1$2");
-		} else {
-			var newcs = dojo.html.getClass(node).replace(classStr, "");
-		}
-		dojo.html.setClass(node, newcs);
-	}
-	catch (e) {
-		dojo.debug("dojo.html.removeClass() failed", e);
-	}
-	return true;
-};
-dojo.html.replaceClass = function (node, newClass, oldClass) {
-	dojo.html.removeClass(node, oldClass);
-	dojo.html.addClass(node, newClass);
-};
-dojo.html.classMatchType = {ContainsAll:0, ContainsAny:1, IsOnly:2};
-dojo.html.getElementsByClass = function (classStr, parent, nodeType, classMatchType, useNonXpath) {
-	useNonXpath = false;
-	var _document = dojo.doc();
-	parent = dojo.byId(parent) || _document;
-	var classes = classStr.split(/\s+/g);
-	var nodes = [];
-	if (classMatchType != 1 && classMatchType != 2) {
-		classMatchType = 0;
-	}
-	var reClass = new RegExp("(\\s|^)((" + classes.join(")|(") + "))(\\s|$)");
-	var srtLength = classes.join(" ").length;
-	var candidateNodes = [];
-	if (!useNonXpath && _document.evaluate) {
-		var xpath = ".//" + (nodeType || "*") + "[contains(";
-		if (classMatchType != dojo.html.classMatchType.ContainsAny) {
-			xpath += "concat(' ', at class,' '), ' " + classes.join(" ') and contains(concat(' ', at class,' '), ' ") + " ')";
-			if (classMatchType == 2) {
-				xpath += " and string-length(@class)=" + srtLength + "]";
-			} else {
-				xpath += "]";
-			}
-		} else {
-			xpath += "concat(' ', at class,' '), ' " + classes.join(" ') or contains(concat(' ', at class,' '), ' ") + " ')]";
-		}
-		var xpathResult = _document.evaluate(xpath, parent, null, XPathResult.ANY_TYPE, null);
-		var result = xpathResult.iterateNext();
-		while (result) {
-			try {
-				candidateNodes.push(result);
-				result = xpathResult.iterateNext();
-			}
-			catch (e) {
-				break;
-			}
-		}
-		return candidateNodes;
-	} else {
-		if (!nodeType) {
-			nodeType = "*";
-		}
-		candidateNodes = parent.getElementsByTagName(nodeType);
-		var node, i = 0;
-	outer:
-		while (node = candidateNodes[i++]) {
-			var nodeClasses = dojo.html.getClasses(node);
-			if (nodeClasses.length == 0) {
-				continue outer;
-			}
-			var matches = 0;
-			for (var j = 0; j < nodeClasses.length; j++) {
-				if (reClass.test(nodeClasses[j])) {
-					if (classMatchType == dojo.html.classMatchType.ContainsAny) {
-						nodes.push(node);
-						continue outer;
-					} else {
-						matches++;
-					}
-				} else {
-					if (classMatchType == dojo.html.classMatchType.IsOnly) {
-						continue outer;
-					}
-				}
-			}
-			if (matches == classes.length) {
-				if ((classMatchType == dojo.html.classMatchType.IsOnly) && (matches == nodeClasses.length)) {
-					nodes.push(node);
-				} else {
-					if (classMatchType == dojo.html.classMatchType.ContainsAll) {
-						nodes.push(node);
-					}
-				}
-			}
-		}
-		return nodes;
-	}
-};
-dojo.html.getElementsByClassName = dojo.html.getElementsByClass;
-dojo.html.toCamelCase = function (selector) {
-	var arr = selector.split("-"), cc = arr[0];
-	for (var i = 1; i < arr.length; i++) {
-		cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
-	}
-	return cc;
-};
-dojo.html.toSelectorCase = function (selector) {
-	return selector.replace(/([A-Z])/g, "-$1").toLowerCase();
-};
-if (dojo.render.html.ie) {
-	dojo.html.getComputedStyle = function (node, property, value) {
-		node = dojo.byId(node);
-		if (!node || !node.currentStyle) {
-			return value;
-		}
-		return node.currentStyle[dojo.html.toCamelCase(property)];
-	};
-	dojo.html.getComputedStyles = function (node) {
-		return node.currentStyle;
-	};
-} else {
-	dojo.html.getComputedStyle = function (node, property, value) {
-		node = dojo.byId(node);
-		if (!node || !node.style) {
-			return value;
-		}
-		var s = document.defaultView.getComputedStyle(node, null);
-		return (s && s[dojo.html.toCamelCase(property)]) || "";
-	};
-	dojo.html.getComputedStyles = function (node) {
-		return document.defaultView.getComputedStyle(node, null);
-	};
-}
-dojo.html.getStyleProperty = function (node, cssSelector) {
-	node = dojo.byId(node);
-	return (node && node.style ? node.style[dojo.html.toCamelCase(cssSelector)] : undefined);
-};
-dojo.html.getStyle = function (node, cssSelector) {
-	var value = dojo.html.getStyleProperty(node, cssSelector);
-	return (value ? value : dojo.html.getComputedStyle(node, cssSelector));
-};
-dojo.html.setStyle = function (node, cssSelector, value) {
-	node = dojo.byId(node);
-	if (node && node.style) {
-		var camelCased = dojo.html.toCamelCase(cssSelector);
-		node.style[camelCased] = value;
-	}
-};
-dojo.html.setStyleText = function (target, text) {
-	try {
-		target.style.cssText = text;
-	}
-	catch (e) {
-		target.setAttribute("style", text);
-	}
-};
-dojo.html.copyStyle = function (target, source) {
-	if (!source.style.cssText) {
-		target.setAttribute("style", source.getAttribute("style"));
-	} else {
-		target.style.cssText = source.style.cssText;
-	}
-	dojo.html.addClass(target, dojo.html.getClass(source));
-};
-dojo.html.getUnitValue = function (node, cssSelector, autoIsZero) {
-	var s = dojo.html.getComputedStyle(node, cssSelector);
-	if ((!s) || ((s == "auto") && (autoIsZero))) {
-		return {value:0, units:"px"};
-	}
-	var match = s.match(/(\-?[\d.]+)([a-z%]*)/i);
-	if (!match) {
-		return dojo.html.getUnitValue.bad;
-	}
-	return {value:Number(match[1]), units:match[2].toLowerCase()};
-};
-dojo.html.getUnitValue.bad = {value:NaN, units:""};
-if (dojo.render.html.ie) {
-	dojo.html.toPixelValue = function (element, styleValue) {
-		if (!styleValue) {
-			return 0;
-		}
-		if (styleValue.slice(-2) == "px") {
-			return parseFloat(styleValue);
-		}
-		var pixelValue = 0;
-		with (element) {
-			var sLeft = style.left;
-			var rsLeft = runtimeStyle.left;
-			runtimeStyle.left = currentStyle.left;
-			try {
-				style.left = styleValue || 0;
-				pixelValue = style.pixelLeft;
-				style.left = sLeft;
-				runtimeStyle.left = rsLeft;
-			}
-			catch (e) {
-			}
-		}
-		return pixelValue;
-	};
-} else {
-	dojo.html.toPixelValue = function (element, styleValue) {
-		return (styleValue && (styleValue.slice(-2) == "px") ? parseFloat(styleValue) : 0);
-	};
-}
-dojo.html.getPixelValue = function (node, styleProperty, autoIsZero) {
-	return dojo.html.toPixelValue(node, dojo.html.getComputedStyle(node, styleProperty));
-};
-dojo.html.setPositivePixelValue = function (node, selector, value) {
-	if (isNaN(value)) {
-		return false;
-	}
-	node.style[selector] = Math.max(0, value) + "px";
-	return true;
-};
-dojo.html.styleSheet = null;
-dojo.html.insertCssRule = function (selector, declaration, index) {
-	if (!dojo.html.styleSheet) {
-		if (document.createStyleSheet) {
-			dojo.html.styleSheet = document.createStyleSheet();
-		} else {
-			if (document.styleSheets[0]) {
-				dojo.html.styleSheet = document.styleSheets[0];
-			} else {
-				return null;
-			}
-		}
-	}
-	if (arguments.length < 3) {
-		if (dojo.html.styleSheet.cssRules) {
-			index = dojo.html.styleSheet.cssRules.length;
-		} else {
-			if (dojo.html.styleSheet.rules) {
-				index = dojo.html.styleSheet.rules.length;
-			} else {
-				return null;
-			}
-		}
-	}
-	if (dojo.html.styleSheet.insertRule) {
-		var rule = selector + " { " + declaration + " }";
-		return dojo.html.styleSheet.insertRule(rule, index);
-	} else {
-		if (dojo.html.styleSheet.addRule) {
-			return dojo.html.styleSheet.addRule(selector, declaration, index);
-		} else {
-			return null;
-		}
-	}
-};
-dojo.html.removeCssRule = function (index) {
-	if (!dojo.html.styleSheet) {
-		dojo.debug("no stylesheet defined for removing rules");
-		return false;
-	}
-	if (dojo.render.html.ie) {
-		if (!index) {
-			index = dojo.html.styleSheet.rules.length;
-			dojo.html.styleSheet.removeRule(index);
-		}
-	} else {
-		if (document.styleSheets[0]) {
-			if (!index) {
-				index = dojo.html.styleSheet.cssRules.length;
-			}
-			dojo.html.styleSheet.deleteRule(index);
-		}
-	}
-	return true;
-};
-dojo.html._insertedCssFiles = [];
-dojo.html.insertCssFile = function (URI, doc, checkDuplicates, fail_ok) {
-	if (!URI) {
-		return;
-	}
-	if (!doc) {
-		doc = document;
-	}
-	var cssStr = dojo.hostenv.getText(URI, false, fail_ok);
-	if (cssStr === null) {
-		return;
-	}
-	cssStr = dojo.html.fixPathsInCssText(cssStr, URI);
-	if (checkDuplicates) {
-		var idx = -1, node, ent = dojo.html._insertedCssFiles;
-		for (var i = 0; i < ent.length; i++) {
-			if ((ent[i].doc == doc) && (ent[i].cssText == cssStr)) {
-				idx = i;
-				node = ent[i].nodeRef;
-				break;
-			}
-		}
-		if (node) {
-			var styles = doc.getElementsByTagName("style");
-			for (var i = 0; i < styles.length; i++) {
-				if (styles[i] == node) {
-					return;
-				}
-			}
-			dojo.html._insertedCssFiles.shift(idx, 1);
-		}
-	}
-	var style = dojo.html.insertCssText(cssStr, doc);
-	dojo.html._insertedCssFiles.push({"doc":doc, "cssText":cssStr, "nodeRef":style});
-	if (style && djConfig.isDebug) {
-		style.setAttribute("dbgHref", URI);
-	}
-	return style;
-};
-dojo.html.insertCssText = function (cssStr, doc, URI) {
-	if (!cssStr) {
-		return;
-	}
-	if (!doc) {
-		doc = document;
-	}
-	if (URI) {
-		cssStr = dojo.html.fixPathsInCssText(cssStr, URI);
-	}
-	var style = doc.createElement("style");
-	style.setAttribute("type", "text/css");
-	var head = doc.getElementsByTagName("head")[0];
-	if (!head) {
-		dojo.debug("No head tag in document, aborting styles");
-		return;
-	} else {
-		head.appendChild(style);
-	}
-	if (style.styleSheet) {
-		var setFunc = function () {
-			try {
-				style.styleSheet.cssText = cssStr;
-			}
-			catch (e) {
-				dojo.debug(e);
-			}
-		};
-		if (style.styleSheet.disabled) {
-			setTimeout(setFunc, 10);
-		} else {
-			setFunc();
-		}
-	} else {
-		var cssText = doc.createTextNode(cssStr);
-		style.appendChild(cssText);
-	}
-	return style;
-};
-dojo.html.fixPathsInCssText = function (cssStr, URI) {
-	if (!cssStr || !URI) {
-		return;
-	}
-	var match, str = "", url = "", urlChrs = "[\\t\\s\\w\\(\\)\\/\\.\\\\'\"-:#=&?~]+";
-	var regex = new RegExp("url\\(\\s*(" + urlChrs + ")\\s*\\)");
-	var regexProtocol = /(file|https?|ftps?):\/\//;
-	regexTrim = new RegExp("^[\\s]*(['\"]?)(" + urlChrs + ")\\1[\\s]*?$");
-	if (dojo.render.html.ie55 || dojo.render.html.ie60) {
-		var regexIe = new RegExp("AlphaImageLoader\\((.*)src=['\"](" + urlChrs + ")['\"]");
-		while (match = regexIe.exec(cssStr)) {
-			url = match[2].replace(regexTrim, "$2");
-			if (!regexProtocol.exec(url)) {
-				url = (new dojo.uri.Uri(URI, url).toString());
-			}
-			str += cssStr.substring(0, match.index) + "AlphaImageLoader(" + match[1] + "src='" + url + "'";
-			cssStr = cssStr.substr(match.index + match[0].length);
-		}
-		cssStr = str + cssStr;
-		str = "";
-	}
-	while (match = regex.exec(cssStr)) {
-		url = match[1].replace(regexTrim, "$2");
-		if (!regexProtocol.exec(url)) {
-			url = (new dojo.uri.Uri(URI, url).toString());
-		}
-		str += cssStr.substring(0, match.index) + "url(" + url + ")";
-		cssStr = cssStr.substr(match.index + match[0].length);
-	}
-	return str + cssStr;
-};
-dojo.html.setActiveStyleSheet = function (title) {
-	var i = 0, a, els = dojo.doc().getElementsByTagName("link");
-	while (a = els[i++]) {
-		if (a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")) {
-			a.disabled = true;
-			if (a.getAttribute("title") == title) {
-				a.disabled = false;
-			}
-		}
-	}
-};
-dojo.html.getActiveStyleSheet = function () {
-	var i = 0, a, els = dojo.doc().getElementsByTagName("link");
-	while (a = els[i++]) {
-		if (a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title") && !a.disabled) {
-			return a.getAttribute("title");
-		}
-	}
-	return null;
-};
-dojo.html.getPreferredStyleSheet = function () {
-	var i = 0, a, els = dojo.doc().getElementsByTagName("link");
-	while (a = els[i++]) {
-		if (a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("rel").indexOf("alt") == -1 && a.getAttribute("title")) {
-			return a.getAttribute("title");
-		}
-	}
-	return null;
-};
-dojo.html.applyBrowserClass = function (node) {
-	var drh = dojo.render.html;
-	var classes = {dj_ie:drh.ie, dj_ie55:drh.ie55, dj_ie6:drh.ie60, dj_ie7:drh.ie70, dj_iequirks:drh.ie && drh.quirks, dj_opera:drh.opera, dj_opera8:drh.opera && (Math.floor(dojo.render.version) == 8), dj_opera9:drh.opera && (Math.floor(dojo.render.version) == 9), dj_khtml:drh.khtml, dj_safari:drh.safari, dj_gecko:drh.mozilla};
-	for (var p in classes) {
-		if (classes[p]) {
-			dojo.html.addClass(node, p);
-		}
-	}
-};
-

Deleted: tags/parley-0.53/root/static/magic/src/html/util.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html/util.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html/util.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,356 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.html.util");
-dojo.require("dojo.html.layout");
-dojo.html.getElementWindow = function (element) {
-	return dojo.html.getDocumentWindow(element.ownerDocument);
-};
-dojo.html.getDocumentWindow = function (doc) {
-	if (dojo.render.html.safari && !doc._parentWindow) {
-		var fix = function (win) {
-			win.document._parentWindow = win;
-			for (var i = 0; i < win.frames.length; i++) {
-				fix(win.frames[i]);
-			}
-		};
-		fix(window.top);
-	}
-	if (dojo.render.html.ie && window !== document.parentWindow && !doc._parentWindow) {
-		doc.parentWindow.execScript("document._parentWindow = window;", "Javascript");
-		var win = doc._parentWindow;
-		doc._parentWindow = null;
-		return win;
-	}
-	return doc._parentWindow || doc.parentWindow || doc.defaultView;
-};
-dojo.html.gravity = function (node, e) {
-	node = dojo.byId(node);
-	var mouse = dojo.html.getCursorPosition(e);
-	with (dojo.html) {
-		var absolute = getAbsolutePosition(node, true);
-		var bb = getBorderBox(node);
-		var nodecenterx = absolute.x + (bb.width / 2);
-		var nodecentery = absolute.y + (bb.height / 2);
-	}
-	with (dojo.html.gravity) {
-		return ((mouse.x < nodecenterx ? WEST : EAST) | (mouse.y < nodecentery ? NORTH : SOUTH));
-	}
-};
-dojo.html.gravity.NORTH = 1;
-dojo.html.gravity.SOUTH = 1 << 1;
-dojo.html.gravity.EAST = 1 << 2;
-dojo.html.gravity.WEST = 1 << 3;
-dojo.html.overElement = function (element, e) {
-	element = dojo.byId(element);
-	var mouse = dojo.html.getCursorPosition(e);
-	var bb = dojo.html.getBorderBox(element);
-	var absolute = dojo.html.getAbsolutePosition(element, true, dojo.html.boxSizing.BORDER_BOX);
-	var top = absolute.y;
-	var bottom = top + bb.height;
-	var left = absolute.x;
-	var right = left + bb.width;
-	return (mouse.x >= left && mouse.x <= right && mouse.y >= top && mouse.y <= bottom);
-};
-dojo.html.renderedTextContent = function (node) {
-	node = dojo.byId(node);
-	var result = "";
-	if (node == null) {
-		return result;
-	}
-	for (var i = 0; i < node.childNodes.length; i++) {
-		switch (node.childNodes[i].nodeType) {
-		  case 1:
-		  case 5:
-			var display = "unknown";
-			try {
-				display = dojo.html.getStyle(node.childNodes[i], "display");
-			}
-			catch (E) {
-			}
-			switch (display) {
-			  case "block":
-			  case "list-item":
-			  case "run-in":
-			  case "table":
-			  case "table-row-group":
-			  case "table-header-group":
-			  case "table-footer-group":
-			  case "table-row":
-			  case "table-column-group":
-			  case "table-column":
-			  case "table-cell":
-			  case "table-caption":
-				result += "\n";
-				result += dojo.html.renderedTextContent(node.childNodes[i]);
-				result += "\n";
-				break;
-			  case "none":
-				break;
-			  default:
-				if (node.childNodes[i].tagName && node.childNodes[i].tagName.toLowerCase() == "br") {
-					result += "\n";
-				} else {
-					result += dojo.html.renderedTextContent(node.childNodes[i]);
-				}
-				break;
-			}
-			break;
-		  case 3:
-		  case 2:
-		  case 4:
-			var text = node.childNodes[i].nodeValue;
-			var textTransform = "unknown";
-			try {
-				textTransform = dojo.html.getStyle(node, "text-transform");
-			}
-			catch (E) {
-			}
-			switch (textTransform) {
-			  case "capitalize":
-				var words = text.split(" ");
-				for (var i = 0; i < words.length; i++) {
-					words[i] = words[i].charAt(0).toUpperCase() + words[i].substring(1);
-				}
-				text = words.join(" ");
-				break;
-			  case "uppercase":
-				text = text.toUpperCase();
-				break;
-			  case "lowercase":
-				text = text.toLowerCase();
-				break;
-			  default:
-				break;
-			}
-			switch (textTransform) {
-			  case "nowrap":
-				break;
-			  case "pre-wrap":
-				break;
-			  case "pre-line":
-				break;
-			  case "pre":
-				break;
-			  default:
-				text = text.replace(/\s+/, " ");
-				if (/\s$/.test(result)) {
-					text.replace(/^\s/, "");
-				}
-				break;
-			}
-			result += text;
-			break;
-		  default:
-			break;
-		}
-	}
-	return result;
-};
-dojo.html.createNodesFromText = function (txt, trim) {
-	if (trim) {
-		txt = txt.replace(/^\s+|\s+$/g, "");
-	}
-	var tn = dojo.doc().createElement("div");
-	tn.style.visibility = "hidden";
-	dojo.body().appendChild(tn);
-	var tableType = "none";
-	if ((/^<t[dh][\s\r\n>]/i).test(txt.replace(/^\s+/))) {
-		txt = "<table><tbody><tr>" + txt + "</tr></tbody></table>";
-		tableType = "cell";
-	} else {
-		if ((/^<tr[\s\r\n>]/i).test(txt.replace(/^\s+/))) {
-			txt = "<table><tbody>" + txt + "</tbody></table>";
-			tableType = "row";
-		} else {
-			if ((/^<(thead|tbody|tfoot)[\s\r\n>]/i).test(txt.replace(/^\s+/))) {
-				txt = "<table>" + txt + "</table>";
-				tableType = "section";
-			}
-		}
-	}
-	tn.innerHTML = txt;
-	if (tn["normalize"]) {
-		tn.normalize();
-	}
-	var parent = null;
-	switch (tableType) {
-	  case "cell":
-		parent = tn.getElementsByTagName("tr")[0];
-		break;
-	  case "row":
-		parent = tn.getElementsByTagName("tbody")[0];
-		break;
-	  case "section":
-		parent = tn.getElementsByTagName("table")[0];
-		break;
-	  default:
-		parent = tn;
-		break;
-	}
-	var nodes = [];
-	for (var x = 0; x < parent.childNodes.length; x++) {
-		nodes.push(parent.childNodes[x].cloneNode(true));
-	}
-	tn.style.display = "none";
-	dojo.html.destroyNode(tn);
-	return nodes;
-};
-dojo.html.placeOnScreen = function (node, desiredX, desiredY, padding, hasScroll, corners, tryOnly) {
-	if (desiredX instanceof Array || typeof desiredX == "array") {
-		tryOnly = corners;
-		corners = hasScroll;
-		hasScroll = padding;
-		padding = desiredY;
-		desiredY = desiredX[1];
-		desiredX = desiredX[0];
-	}
-	if (corners instanceof String || typeof corners == "string") {
-		corners = corners.split(",");
-	}
-	if (!isNaN(padding)) {
-		padding = [Number(padding), Number(padding)];
-	} else {
-		if (!(padding instanceof Array || typeof padding == "array")) {
-			padding = [0, 0];
-		}
-	}
-	var scroll = dojo.html.getScroll().offset;
-	var view = dojo.html.getViewport();
-	node = dojo.byId(node);
-	var oldDisplay = node.style.display;
-	node.style.display = "";
-	var bb = dojo.html.getBorderBox(node);
-	var w = bb.width;
-	var h = bb.height;
-	node.style.display = oldDisplay;
-	if (!(corners instanceof Array || typeof corners == "array")) {
-		corners = ["TL"];
-	}
-	var bestx, besty, bestDistance = Infinity, bestCorner;
-	for (var cidex = 0; cidex < corners.length; ++cidex) {
-		var corner = corners[cidex];
-		var match = true;
-		var tryX = desiredX - (corner.charAt(1) == "L" ? 0 : w) + padding[0] * (corner.charAt(1) == "L" ? 1 : -1);
-		var tryY = desiredY - (corner.charAt(0) == "T" ? 0 : h) + padding[1] * (corner.charAt(0) == "T" ? 1 : -1);
-		if (hasScroll) {
-			tryX -= scroll.x;
-			tryY -= scroll.y;
-		}
-		if (tryX < 0) {
-			tryX = 0;
-			match = false;
-		}
-		if (tryY < 0) {
-			tryY = 0;
-			match = false;
-		}
-		var x = tryX + w;
-		if (x > view.width) {
-			x = view.width - w;
-			match = false;
-		} else {
-			x = tryX;
-		}
-		x = Math.max(padding[0], x) + scroll.x;
-		var y = tryY + h;
-		if (y > view.height) {
-			y = view.height - h;
-			match = false;
-		} else {
-			y = tryY;
-		}
-		y = Math.max(padding[1], y) + scroll.y;
-		if (match) {
-			bestx = x;
-			besty = y;
-			bestDistance = 0;
-			bestCorner = corner;
-			break;
-		} else {
-			var dist = Math.pow(x - tryX - scroll.x, 2) + Math.pow(y - tryY - scroll.y, 2);
-			if (bestDistance > dist) {
-				bestDistance = dist;
-				bestx = x;
-				besty = y;
-				bestCorner = corner;
-			}
-		}
-	}
-	if (!tryOnly) {
-		node.style.left = bestx + "px";
-		node.style.top = besty + "px";
-	}
-	return {left:bestx, top:besty, x:bestx, y:besty, dist:bestDistance, corner:bestCorner};
-};
-dojo.html.placeOnScreenPoint = function (node, desiredX, desiredY, padding, hasScroll) {
-	dojo.deprecated("dojo.html.placeOnScreenPoint", "use dojo.html.placeOnScreen() instead", "0.5");
-	return dojo.html.placeOnScreen(node, desiredX, desiredY, padding, hasScroll, ["TL", "TR", "BL", "BR"]);
-};
-dojo.html.placeOnScreenAroundElement = function (node, aroundNode, padding, aroundType, aroundCorners, tryOnly) {
-	var best, bestDistance = Infinity;
-	aroundNode = dojo.byId(aroundNode);
-	var oldDisplay = aroundNode.style.display;
-	aroundNode.style.display = "";
-	var mb = dojo.html.getElementBox(aroundNode, aroundType);
-	var aroundNodeW = mb.width;
-	var aroundNodeH = mb.height;
-	var aroundNodePos = dojo.html.getAbsolutePosition(aroundNode, true, aroundType);
-	aroundNode.style.display = oldDisplay;
-	for (var nodeCorner in aroundCorners) {
-		var pos, desiredX, desiredY;
-		var corners = aroundCorners[nodeCorner];
-		desiredX = aroundNodePos.x + (nodeCorner.charAt(1) == "L" ? 0 : aroundNodeW);
-		desiredY = aroundNodePos.y + (nodeCorner.charAt(0) == "T" ? 0 : aroundNodeH);
-		pos = dojo.html.placeOnScreen(node, desiredX, desiredY, padding, true, corners, true);
-		if (pos.dist == 0) {
-			best = pos;
-			break;
-		} else {
-			if (bestDistance > pos.dist) {
-				bestDistance = pos.dist;
-				best = pos;
-			}
-		}
-	}
-	if (!tryOnly) {
-		node.style.left = best.left + "px";
-		node.style.top = best.top + "px";
-	}
-	return best;
-};
-dojo.html.scrollIntoView = function (node) {
-	if (!node) {
-		return;
-	}
-	if (dojo.render.html.ie) {
-		if (dojo.html.getBorderBox(node.parentNode).height <= node.parentNode.scrollHeight) {
-			node.scrollIntoView(false);
-		}
-	} else {
-		if (dojo.render.html.mozilla) {
-			node.scrollIntoView(false);
-		} else {
-			var parent = node.parentNode;
-			var parentBottom = parent.scrollTop + dojo.html.getBorderBox(parent).height;
-			var nodeBottom = node.offsetTop + dojo.html.getMarginBox(node).height;
-			if (parentBottom < nodeBottom) {
-				parent.scrollTop += (nodeBottom - parentBottom);
-			} else {
-				if (parent.scrollTop > node.offsetTop) {
-					parent.scrollTop -= (parent.scrollTop - node.offsetTop);
-				}
-			}
-		}
-	}
-};
-

Modified: tags/parley-0.53/root/static/magic/src/html.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/html.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/html.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,588 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.html");
 
+dojo.require("dojo.lang.func");
+dojo.require("dojo.dom");
+dojo.require("dojo.style");
+dojo.require("dojo.string");
 
-dojo.provide("dojo.html");
-dojo.require("dojo.html.*");
-dojo.deprecated("dojo.html", "replaced by dojo.html.*", "0.5");
+dojo.lang.mixin(dojo.html, dojo.dom);
+dojo.lang.mixin(dojo.html, dojo.style);
 
+// FIXME: we are going to assume that we can throw any and every rendering
+// engine into the IE 5.x box model. In Mozilla, we do this w/ CSS.
+// Need to investigate for KHTML and Opera
+
+dojo.html.clearSelection = function(){
+	try{
+		if(window["getSelection"]){ 
+			if(dojo.render.html.safari){
+				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
+				window.getSelection().collapse();
+			}else{
+				window.getSelection().removeAllRanges();
+			}
+		}else if(document.selection){
+			if(document.selection.empty){
+				document.selection.empty();
+			}else if(document.selection.clear){
+				document.selection.clear();
+			}
+		}
+		return true;
+	}catch(e){
+		dojo.debug(e);
+		return false;
+	}
+}
+
+dojo.html.disableSelection = function(element){
+	element = dojo.byId(element)||document.body;
+	var h = dojo.render.html;
+	
+	if(h.mozilla){
+		element.style.MozUserSelect = "none";
+	}else if(h.safari){
+		element.style.KhtmlUserSelect = "none"; 
+	}else if(h.ie){
+		element.unselectable = "on";
+	}else{
+		return false;
+	}
+	return true;
+}
+
+dojo.html.enableSelection = function(element){
+	element = dojo.byId(element)||document.body;
+	
+	var h = dojo.render.html;
+	if(h.mozilla){ 
+		element.style.MozUserSelect = ""; 
+	}else if(h.safari){
+		element.style.KhtmlUserSelect = "";
+	}else if(h.ie){
+		element.unselectable = "off";
+	}else{
+		return false;
+	}
+	return true;
+}
+
+dojo.html.selectElement = function(element){
+	element = dojo.byId(element);
+	if(document.selection && document.body.createTextRange){ // IE
+		var range = document.body.createTextRange();
+		range.moveToElementText(element);
+		range.select();
+	}else if(window["getSelection"]){
+		var selection = window.getSelection();
+		// FIXME: does this work on Safari?
+		if(selection["selectAllChildren"]){ // Mozilla
+			selection.selectAllChildren(element);
+		}
+	}
+}
+
+dojo.html.selectInputText = function(element){
+	element = dojo.byId(element);
+	if(document.selection && document.body.createTextRange){ // IE
+		var range = element.createTextRange();
+		range.moveStart("character", 0);
+		range.moveEnd("character", element.value.length);
+		range.select();
+	}else if(window["getSelection"]){
+		var selection = window.getSelection();
+		// FIXME: does this work on Safari?
+		element.setSelectionRange(0, element.value.length);
+	}
+	element.focus();
+}
+
+
+dojo.html.isSelectionCollapsed = function(){
+	if(document["selection"]){ // IE
+		return document.selection.createRange().text == "";
+	}else if(window["getSelection"]){
+		var selection = window.getSelection();
+		if(dojo.lang.isString(selection)){ // Safari
+			return selection == "";
+		}else{ // Mozilla/W3
+			return selection.isCollapsed;
+		}
+	}
+}
+
+dojo.html.getEventTarget = function(evt){
+	if(!evt) { evt = window.event || {} };
+	var t = (evt.srcElement ? evt.srcElement : (evt.target ? evt.target : null));
+	while((t)&&(t.nodeType!=1)){ t = t.parentNode; }
+	return t;
+}
+
+dojo.html.getDocumentWidth = function(){
+	dojo.deprecated("dojo.html.getDocument*", "replaced by dojo.html.getViewport*", "0.4");
+	return dojo.html.getViewportWidth();
+}
+
+dojo.html.getDocumentHeight = function(){
+	dojo.deprecated("dojo.html.getDocument*", "replaced by dojo.html.getViewport*", "0.4");
+	return dojo.html.getViewportHeight();
+}
+
+dojo.html.getDocumentSize = function(){
+	dojo.deprecated("dojo.html.getDocument*", "replaced of dojo.html.getViewport*", "0.4");
+	return dojo.html.getViewportSize();
+}
+
+dojo.html.getViewportWidth = function(){
+	var w = 0;
+
+	if(window.innerWidth){
+		w = window.innerWidth;
+	}
+
+	if(dojo.exists(document, "documentElement.clientWidth")){
+		// IE6 Strict
+		var w2 = document.documentElement.clientWidth;
+		// this lets us account for scrollbars
+		if(!w || w2 && w2 < w) {
+			w = w2;
+		}
+		return w;
+	}
+
+	if(document.body){
+		// IE
+		return document.body.clientWidth;
+	}
+
+	return 0;
+}
+
+dojo.html.getViewportHeight = function(){
+	if (window.innerHeight){
+		return window.innerHeight;
+	}
+
+	if (dojo.exists(document, "documentElement.clientHeight")){
+		// IE6 Strict
+		return document.documentElement.clientHeight;
+	}
+
+	if (document.body){
+		// IE
+		return document.body.clientHeight;
+	}
+
+	return 0;
+}
+
+dojo.html.getViewportSize = function(){
+	var ret = [dojo.html.getViewportWidth(), dojo.html.getViewportHeight()];
+	ret.w = ret[0];
+	ret.h = ret[1];
+	return ret;
+}
+
+dojo.html.getScrollTop = function(){
+	return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
+}
+
+dojo.html.getScrollLeft = function(){
+	return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
+}
+
+dojo.html.getScrollOffset = function(){
+	var off = [dojo.html.getScrollLeft(), dojo.html.getScrollTop()];
+	off.x = off[0];
+	off.y = off[1];
+	return off;
+}
+
+dojo.html.getParentOfType = function(node, type){
+	dojo.deprecated("dojo.html.getParentOfType", "replaced by dojo.html.getParentByType*", "0.4");
+	return dojo.html.getParentByType(node, type);
+}
+
+dojo.html.getParentByType = function(node, type) {
+	var parent = dojo.byId(node);
+	type = type.toLowerCase();
+	while((parent)&&(parent.nodeName.toLowerCase()!=type)){
+		if(parent==(document["body"]||document["documentElement"])){
+			return null;
+		}
+		parent = parent.parentNode;
+	}
+	return parent;
+}
+
+// RAR: this function comes from nwidgets and is more-or-less unmodified.
+// We should probably look ant Burst and f(m)'s equivalents
+dojo.html.getAttribute = function(node, attr){
+	node = dojo.byId(node);
+	// FIXME: need to add support for attr-specific accessors
+	if((!node)||(!node.getAttribute)){
+		// if(attr !== 'nwType'){
+		//	alert("getAttr of '" + attr + "' with bad node"); 
+		// }
+		return null;
+	}
+	var ta = typeof attr == 'string' ? attr : new String(attr);
+
+	// first try the approach most likely to succeed
+	var v = node.getAttribute(ta.toUpperCase());
+	if((v)&&(typeof v == 'string')&&(v!="")){ return v; }
+
+	// try returning the attributes value, if we couldn't get it as a string
+	if(v && v.value){ return v.value; }
+
+	// this should work on Opera 7, but it's a little on the crashy side
+	if((node.getAttributeNode)&&(node.getAttributeNode(ta))){
+		return (node.getAttributeNode(ta)).value;
+	}else if(node.getAttribute(ta)){
+		return node.getAttribute(ta);
+	}else if(node.getAttribute(ta.toLowerCase())){
+		return node.getAttribute(ta.toLowerCase());
+	}
+	return null;
+}
+	
+/**
+ *	Determines whether or not the specified node carries a value for the
+ *	attribute in question.
+ */
+dojo.html.hasAttribute = function(node, attr){
+	node = dojo.byId(node);
+	return dojo.html.getAttribute(node, attr) ? true : false;
+}
+	
+/**
+ * Returns the string value of the list of CSS classes currently assigned
+ * directly to the node in question. Returns an empty string if no class attribute
+ * is found;
+ */
+dojo.html.getClass = function(node){
+	node = dojo.byId(node);
+	if(!node){ return ""; }
+	var cs = "";
+	if(node.className){
+		cs = node.className;
+	}else if(dojo.html.hasAttribute(node, "class")){
+		cs = dojo.html.getAttribute(node, "class");
+	}
+	return dojo.string.trim(cs);
+}
+
+/**
+ * Returns an array of CSS classes currently assigned
+ * directly to the node in question. Returns an empty array if no classes
+ * are found;
+ */
+dojo.html.getClasses = function(node) {
+	var c = dojo.html.getClass(node);
+	return (c == "") ? [] : c.split(/\s+/g);
+}
+
+/**
+ * Returns whether or not the specified classname is a portion of the
+ * class list currently applied to the node. Does not cover cascaded
+ * styles, only classes directly applied to the node.
+ */
+dojo.html.hasClass = function(node, classname){
+	return dojo.lang.inArray(dojo.html.getClasses(node), classname);
+}
+
+/**
+ * Adds the specified class to the beginning of the class list on the
+ * passed node. This gives the specified class the highest precidence
+ * when style cascading is calculated for the node. Returns true or
+ * false; indicating success or failure of the operation, respectively.
+ */
+dojo.html.prependClass = function(node, classStr){
+	classStr += " " + dojo.html.getClass(node);
+	return dojo.html.setClass(node, classStr);
+}
+
+/**
+ * Adds the specified class to the end of the class list on the
+ *	passed &node;. Returns &true; or &false; indicating success or failure.
+ */
+dojo.html.addClass = function(node, classStr){
+	if (dojo.html.hasClass(node, classStr)) {
+	  return false;
+	}
+	classStr = dojo.string.trim(dojo.html.getClass(node) + " " + classStr);
+	return dojo.html.setClass(node, classStr);
+}
+
+/**
+ *	Clobbers the existing list of classes for the node, replacing it with
+ *	the list given in the 2nd argument. Returns true or false
+ *	indicating success or failure.
+ */
+dojo.html.setClass = function(node, classStr){
+	node = dojo.byId(node);
+	var cs = new String(classStr);
+	try{
+		if(typeof node.className == "string"){
+			node.className = cs;
+		}else if(node.setAttribute){
+			node.setAttribute("class", classStr);
+			node.className = cs;
+		}else{
+			return false;
+		}
+	}catch(e){
+		dojo.debug("dojo.html.setClass() failed", e);
+	}
+	return true;
+}
+
+/**
+ * Removes the className from the node;. Returns
+ * true or false indicating success or failure.
+ */ 
+dojo.html.removeClass = function(node, classStr, allowPartialMatches){
+	var classStr = dojo.string.trim(new String(classStr));
+
+	try{
+		var cs = dojo.html.getClasses(node);
+		var nca	= [];
+		if(allowPartialMatches){
+			for(var i = 0; i<cs.length; i++){
+				if(cs[i].indexOf(classStr) == -1){ 
+					nca.push(cs[i]);
+				}
+			}
+		}else{
+			for(var i=0; i<cs.length; i++){
+				if(cs[i] != classStr){ 
+					nca.push(cs[i]);
+				}
+			}
+		}
+		dojo.html.setClass(node, nca.join(" "));
+	}catch(e){
+		dojo.debug("dojo.html.removeClass() failed", e);
+	}
+
+	return true;
+}
+
+/**
+ * Replaces 'oldClass' and adds 'newClass' to node
+ */
+dojo.html.replaceClass = function(node, newClass, oldClass) {
+	dojo.html.removeClass(node, oldClass);
+	dojo.html.addClass(node, newClass);
+}
+
+// Enum type for getElementsByClass classMatchType arg:
+dojo.html.classMatchType = {
+	ContainsAll : 0, // all of the classes are part of the node's class (default)
+	ContainsAny : 1, // any of the classes are part of the node's class
+	IsOnly : 2 // only all of the classes are part of the node's class
+}
+
+
+/**
+ * Returns an array of nodes for the given classStr, children of a
+ * parent, and optionally of a certain nodeType
+ */
+dojo.html.getElementsByClass = function(classStr, parent, nodeType, classMatchType, useNonXpath){
+	parent = dojo.byId(parent) || document;
+	var classes = classStr.split(/\s+/g);
+	var nodes = [];
+	if( classMatchType != 1 && classMatchType != 2 ) classMatchType = 0; // make it enum
+	var reClass = new RegExp("(\\s|^)((" + classes.join(")|(") + "))(\\s|$)");
+	var candidateNodes = [];
+	
+	if(!useNonXpath && document.evaluate) { // supports dom 3 xpath
+		var xpath = "//" + (nodeType || "*") + "[contains(";
+		if(classMatchType != dojo.html.classMatchType.ContainsAny){
+			xpath += "concat(' ', at class,' '), ' " +
+			classes.join(" ') and contains(concat(' ', at class,' '), ' ") +
+			" ')]";
+		}else{
+			xpath += "concat(' ', at class,' '), ' " +
+			classes.join(" ')) or contains(concat(' ', at class,' '), ' ") +
+			" ')]";
+		}
+		var xpathResult = document.evaluate(xpath, parent, null, XPathResult.ANY_TYPE, null);
+		var result = xpathResult.iterateNext();
+		while(result){
+			try{
+				candidateNodes.push(result);
+				result = xpathResult.iterateNext();
+			}catch(e){ break; }
+		}
+		return candidateNodes;
+	}else{
+		if(!nodeType){
+			nodeType = "*";
+		}
+		candidateNodes = parent.getElementsByTagName(nodeType);
+
+		var node, i = 0;
+		outer:
+		while(node = candidateNodes[i++]){
+			var nodeClasses = dojo.html.getClasses(node);
+			if(nodeClasses.length == 0){ continue outer; }
+			var matches = 0;
+	
+			for(var j = 0; j < nodeClasses.length; j++){
+				if(reClass.test(nodeClasses[j])){
+					if(classMatchType == dojo.html.classMatchType.ContainsAny){
+						nodes.push(node);
+						continue outer;
+					}else{
+						matches++;
+					}
+				}else{
+					if(classMatchType == dojo.html.classMatchType.IsOnly){
+						continue outer;
+					}
+				}
+			}
+	
+			if(matches == classes.length){
+				if(	(classMatchType == dojo.html.classMatchType.IsOnly)&&
+					(matches == nodeClasses.length)){
+					nodes.push(node);
+				}else if(classMatchType == dojo.html.classMatchType.ContainsAll){
+					nodes.push(node);
+				}
+			}
+		}
+		return nodes;
+	}
+}
+
+dojo.html.getElementsByClassName = dojo.html.getElementsByClass;
+
+/**
+ * Returns the mouse position relative to the document (not the viewport).
+ * For example, if you have a document that is 10000px tall,
+ * but your browser window is only 100px tall,
+ * if you scroll to the bottom of the document and call this function it
+ * will return {x: 0, y: 10000}
+ */
+dojo.html.getCursorPosition = function(e){
+	e = e || window.event;
+	var cursor = {x:0, y:0};
+	if(e.pageX || e.pageY){
+		cursor.x = e.pageX;
+		cursor.y = e.pageY;
+	}else{
+		var de = document.documentElement;
+		var db = document.body;
+		cursor.x = e.clientX + ((de||db)["scrollLeft"]) - ((de||db)["clientLeft"]);
+		cursor.y = e.clientY + ((de||db)["scrollTop"]) - ((de||db)["clientTop"]);
+	}
+	return cursor;
+}
+
+dojo.html.overElement = function(element, e){
+	element = dojo.byId(element);
+	var mouse = dojo.html.getCursorPosition(e);
+
+	with(dojo.html){
+		var top = getAbsoluteY(element, true);
+		var bottom = top + getInnerHeight(element);
+		var left = getAbsoluteX(element, true);
+		var right = left + getInnerWidth(element);
+	}
+	
+	return (mouse.x >= left && mouse.x <= right &&
+		mouse.y >= top && mouse.y <= bottom);
+}
+
+dojo.html.setActiveStyleSheet = function(title){
+	var i = 0, a, els = document.getElementsByTagName("link");
+	while (a = els[i++]) {
+		if(a.getAttribute("rel").indexOf("style") != -1 && a.getAttribute("title")){
+			a.disabled = true;
+			if (a.getAttribute("title") == title) { a.disabled = false; }
+		}
+	}
+}
+
+dojo.html.getActiveStyleSheet = function(){
+	var i = 0, a, els = document.getElementsByTagName("link");
+	while (a = els[i++]) {
+		if (a.getAttribute("rel").indexOf("style") != -1 &&
+			a.getAttribute("title") && !a.disabled) { return a.getAttribute("title"); }
+	}
+	return null;
+}
+
+dojo.html.getPreferredStyleSheet = function(){
+	var i = 0, a, els = document.getElementsByTagName("link");
+	while (a = els[i++]) {
+		if(a.getAttribute("rel").indexOf("style") != -1
+			&& a.getAttribute("rel").indexOf("alt") == -1
+			&& a.getAttribute("title")) { return a.getAttribute("title"); }
+	}
+	return null;
+}
+
+dojo.html.body = function(){
+	// Note: document.body is not defined for a strict xhtml document
+	return document.body || document.getElementsByTagName("body")[0];
+}
+
+/**
+ * Like dojo.dom.isTag, except case-insensitive
+**/
+dojo.html.isTag = function(node /* ... */) {
+	node = dojo.byId(node);
+	if(node && node.tagName) {
+		var arr = dojo.lang.map(dojo.lang.toArray(arguments, 1),
+			function(a) { return String(a).toLowerCase(); });
+		return arr[ dojo.lang.find(node.tagName.toLowerCase(), arr) ] || "";
+	}
+	return "";
+}
+
+dojo.html.copyStyle = function(target, source){
+	// work around for opera which doesn't have cssText, and for IE which fails on setAttribute 
+	if(dojo.lang.isUndefined(source.style.cssText)){ 
+		target.setAttribute("style", source.getAttribute("style")); 
+	}else{
+		target.style.cssText = source.style.cssText; 
+	}
+	dojo.html.addClass(target, dojo.html.getClass(source));
+}
+
+dojo.html._callExtrasDeprecated = function(inFunc, args) {
+	var module = "dojo.html.extras";
+	dojo.deprecated("dojo.html." + inFunc, "moved to " + module, "0.4");
+	dojo["require"](module); // weird syntax to fool list-profile-deps (build)
+	return dojo.html[inFunc].apply(dojo.html, args);
+}
+
+dojo.html.createNodesFromText = function() {
+	return dojo.html._callExtrasDeprecated('createNodesFromText', arguments);
+}
+
+dojo.html.gravity = function() {
+	return dojo.html._callExtrasDeprecated('gravity', arguments);
+}
+
+dojo.html.placeOnScreen = function() {
+	return dojo.html._callExtrasDeprecated('placeOnScreen', arguments);
+}
+
+dojo.html.placeOnScreenPoint = function() {
+	return dojo.html._callExtrasDeprecated('placeOnScreenPoint', arguments);
+}
+
+dojo.html.renderedTextContent = function() {
+	return dojo.html._callExtrasDeprecated('renderedTextContent', arguments);
+}
+
+dojo.html.BackgroundIframe = function() {
+	return dojo.html._callExtrasDeprecated('BackgroundIframe', arguments);
+}

Modified: tags/parley-0.53/root/static/magic/src/i18n/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/i18n/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/i18n/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,37 +8,53 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.i18n.common");
+dojo.require("dojo.lang");
 
+dojo.require("dojo.experimental");
+dojo.experimental("dojo.i18n.common");
 
-dojo.provide("dojo.i18n.common");
-dojo.i18n.getLocalization = function (packageName, bundleName, locale) {
-	dojo.hostenv.preloadLocalizations();
-	locale = dojo.hostenv.normalizeLocale(locale);
-	var elements = locale.split("-");
-	var module = [packageName, "nls", bundleName].join(".");
-	var bundle = dojo.hostenv.findModule(module, true);
-	var localization;
-	for (var i = elements.length; i > 0; i--) {
-		var loc = elements.slice(0, i).join("_");
-		if (bundle[loc]) {
-			localization = bundle[loc];
-			break;
+
+/**
+ * Gets a reference to a hash containing the localization for a given bundle in a package, matching the specified
+ * locale.  Bundle must have already been loaded by dojo.requireLocalization() or by a build optimization step.
+ *
+ * @param modulename package in which the bundle is found
+ * @param bundlename the filename in the directory structure without the ".js" suffix
+ * @param locale the variant to load (optional).  By default, the locale defined by the
+ *   host environment: dojo.locale
+ * @return a hash containing name/value pairs.  Throws an exception if the bundle is not found.
+ */
+dojo.i18n.getLocalization = function(modulename, bundlename, locale /*optional*/){
+	locale = dojo.normalizeLocale(locale);
+
+	// look for nearest locale match
+	var elements = locale.split('-');
+	var bundle = dojo.hostenv.findModule([modulename,"_nls",bundlename].join('.'), true);
+
+	for(var i = elements.length; i > 0; i--){
+		var loc = elements.slice(0, i).join('-');
+		if(bundle[loc]){
+			return bundle[loc];
 		}
 	}
-	if (!localization) {
-		localization = bundle.ROOT;
+
+	if(bundle[dojo.fallback_locale]){
+		return bundle[dojo.fallback_locale];
 	}
-	if (localization) {
-		var clazz = function () {
-		};
-		clazz.prototype = localization;
-		return new clazz();
-	}
-	dojo.raise("Bundle not found: " + bundleName + " in " + packageName + " , locale=" + locale);
+
+	dojo.raise("Bundle not found " + [modulename,"_nls",bundlename,locale].join('.'));
 };
-dojo.i18n.isLTR = function (locale) {
-	var lang = dojo.hostenv.normalizeLocale(locale).split("-")[0];
-	var RTL = {ar:true, fa:true, he:true, ur:true, yi:true};
+
+/**
+ * Is the language read left-to-right?  Most exceptions are for middle eastern languages.
+ *
+ * @param locale a string representing the locale.  By default, the locale defined by the
+ *   host environment: dojo.locale
+ * @return true if language is read left to right; false otherwise
+ */
+dojo.i18n.isLTR = function(locale /*optional*/){
+	var lang = dojo.normalizeLocale(locale).split('-')[0];
+	var RTL = {ar:true,fa:true,he:true,ur:true,yi:true};
 	return !RTL[lang];
-};
-
+}

Deleted: tags/parley-0.53/root/static/magic/src/i18n/currency.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/i18n/currency.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/i18n/currency.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,138 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.i18n.currency");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.i18n.currency");
-dojo.require("dojo.regexp");
-dojo.require("dojo.i18n.common");
-dojo.require("dojo.i18n.number");
-dojo.require("dojo.lang.common");
-dojo.i18n.currency.format = function (value, iso, flags, locale) {
-	flags = (typeof flags == "object") ? flags : {};
-	var formatData = dojo.i18n.currency._mapToLocalizedFormatData(dojo.i18n.currency.FORMAT_TABLE, iso, locale);
-	if (typeof flags.places == "undefined") {
-		flags.places = formatData.places;
-	}
-	if (typeof flags.places == "undefined") {
-		flags.places = 2;
-	}
-	flags.signed = false;
-	var result = dojo.i18n.number.format(value, flags, locale);
-	var sym = formatData.symbol;
-	if (formatData.adjSpace == "symbol") {
-		if (formatData.placement == "after") {
-			sym = " " + sym;
-		} else {
-			sym = sym + " ";
-		}
-	}
-	if (value < 0) {
-		if (formatData.signPlacement == "before") {
-			sym = "-" + sym;
-		} else {
-			if (formatData.signPlacement == "after") {
-				sym = sym + "-";
-			}
-		}
-	}
-	var spc = (formatData.adjSpace == "number") ? " " : "";
-	if (formatData.placement == "after") {
-		result = result + spc + sym;
-	} else {
-		result = sym + spc + result;
-	}
-	if (value < 0) {
-		if (formatData.signPlacement == "around") {
-			result = "(" + result + ")";
-		} else {
-			if (formatData.signPlacement == "end") {
-				result = result + "-";
-			} else {
-				if (!formatData.signPlacement || formatData.signPlacement == "begin") {
-					result = "-" + result;
-				}
-			}
-		}
-	}
-	return result;
-};
-dojo.i18n.currency.parse = function (value, iso, locale, flags) {
-	if (typeof flags.validate == "undefined") {
-		flags.validate = true;
-	}
-	if (flags.validate && !dojo.i18n.number.isCurrency(value, iso, locale, flags)) {
-		return Number.NaN;
-	}
-	var sign = (value.indexOf("-") != -1);
-	var abs = abs.replace(/\-/, "");
-	var formatData = dojo.i18n.currency._mapToLocalizedFormatData(dojo.i18n.currency.FORMAT_TABLE, iso, locale);
-	abs = abs.replace(new RegExp("\\" + formatData.symbol), "");
-	var number = dojo.i18n.number.parse(abs, locale, flags);
-	if (sign) {
-		number = number * -1;
-	}
-	return number;
-};
-dojo.i18n.currency.isCurrency = function (value, iso, locale, flags) {
-	flags = (typeof flags == "object") ? flags : {};
-	var numberFormatData = dojo.i18n.number._mapToLocalizedFormatData(dojo.i18n.number.FORMAT_TABLE, locale);
-	if (typeof flags.separator == "undefined") {
-		flags.separator = numberFormatData[0];
-	} else {
-		if (dojo.lang.isArray(flags.separator) && flags.separator.length == 0) {
-			flags.separator = [numberFormatData[0], ""];
-		}
-	}
-	if (typeof flags.decimal == "undefined") {
-		flags.decimal = numberFormatData[2];
-	}
-	if (typeof flags.groupSize == "undefined") {
-		flags.groupSize = numberFormatData[3];
-	}
-	if (typeof flags.groupSize2 == "undefined") {
-		flags.groupSize2 = numberFormatData[4];
-	}
-	var formatData = dojo.i18n.currency._mapToLocalizedFormatData(dojo.i18n.currency.FORMAT_TABLE, iso, locale);
-	if (typeof flags.places == "undefined") {
-		flags.places = formatData.places;
-	}
-	if (typeof flags.places == "undefined") {
-		flags.places = 2;
-	}
-	if (typeof flags.symbol == "undefined") {
-		flags.symbol = formatData.symbol;
-	} else {
-		if (dojo.lang.isArray(flags.symbol) && flags.symbol.length == 0) {
-			flags.symbol = [formatData.symbol, ""];
-		}
-	}
-	if (typeof flags.placement == "undefined") {
-		flags.placement = formatData.placement;
-	}
-	var re = new RegExp("^" + dojo.regexp.currency(flags) + "$");
-	return re.test(value);
-};
-dojo.i18n.currency._mapToLocalizedFormatData = function (table, iso, locale) {
-	var formatData = dojo.i18n.currency.FORMAT_TABLE[iso];
-	if (!dojo.lang.isArray(formatData)) {
-		return formatData;
-	}
-	return dojo.i18n.number._mapToLocalizedFormatData(formatData[0], locale);
-};
-(function () {
-	var arabic = {symbol:"\u062c", placement:"after", htmlSymbol:"?"};
-	var euro = {symbol:"\u20ac", placement:"before", adjSpace:"symbol", htmlSymbol:"&euro;"};
-	var euroAfter = {symbol:"\u20ac", placement:"after", htmlSymbol:"&euro;"};
-	dojo.i18n.currency.FORMAT_TABLE = {AED:{symbol:"\u062c", placement:"after"}, ARS:{symbol:"$", signPlacement:"after"}, ATS:{symbol:"\u20ac", adjSpace:"number", signPlacement:"after", htmlSymbol:"&euro;"}, AUD:{symbol:"$"}, BOB:{symbol:"$b"}, BRL:{symbol:"R$", adjSpace:"symbol"}, BEF:euroAfter, BHD:arabic, CAD:[{"*":{symbol:"$"}, "fr-ca":{symbol:"$", placement:"after", signPlacement:"around"}}], CHF:{symbol:"CHF", adjSpace:"symbol", signPlacement:"after"}, CLP:{symbol:"$"}, COP:{symbol:"$", signPlacement:"around"}, CNY:{symbol:"\xa5", htmlSymbol:"&yen;"}, CRC:{symbol:"\u20a1", signPlacement:"after", htmlSymbol:"?"}, CZK:{symbol:"Kc", adjSpace:"symbol", signPlacement:"after"}, DEM:euroAfter, DKK:{symbol:"kr.", adjSpace:"symbol", signPlacement:"after"}, DOP:{symbol:"$"}, DZD:arabic, ECS:{symbol:"$", signPlacement:"after"}, EGP:arabic, ESP:euroAfter, EUR:euro, FIM:euroAfter, FRF:euroAfter, GBP:{symbol:"\xa3", htmlSymbol:"&pound;"}, GRD:{symbol:"\u20ac", signPlacement:"end", htm!
 lSymbol:"&euro;"}, GTQ:{symbol:"Q", signPlacement:"after"}, HKD:{symbol:"HK$"}, HNL:{symbol:"L.", signPlacement:"end"}, HUF:{symbol:"Ft", placement:"after", adjSpace:"symbol"}, IEP:{symbol:"\u20ac", htmlSymbol:"&euro;"}, ILS:{symbol:"\u05e9\"\u05d7", placement:"after", htmlSymbol:"?"}, INR:{symbol:"Rs."}, ITL:{symbol:"\u20ac", signPlacement:"after", htmlSymbol:"&euro;"}, JOD:arabic, JPY:{symbol:"\xa5", places:0, htmlSymbol:"&yen;"}, KRW:{symbol:"\u20a9", places:0, htmlSymbol:"?"}, KWD:arabic, LBP:arabic, LUF:euroAfter, MAD:arabic, MXN:{symbol:"$", signPlacement:"around"}, NIO:{symbol:"C$", adjSpace:"symbol", signPlacement:"after"}, NLG:{symbol:"\u20ac", signPlacement:"end", htmlSymbol:"&euro;"}, NOK:{symbol:"kr", adjSpace:"symbol", signPlacement:"after"}, NZD:{symbol:"$"}, OMR:arabic, PAB:{symbol:"B/", adjSpace:"symbol", signPlacement:"after"}, PEN:{symbol:"S/", signPlacement:"after"}, PLN:{symbol:"z", placement:"after"}, PTE:euroAfter, PYG:{symbol:"Gs.", signPlacement:"aft!
 er"}, QAR:arabic, RUR:{symbol:"rub.", placement:"after"}, SAR:!
 arabic, 
SEK:{symbol:"kr", placement:"after", adjSpace:"symbol"}, SGD:{symbol:"$"}, SVC:{symbol:"\u20a1", signPlacement:"after", adjSpace:"symbol"}, SYP:arabic, TND:arabic, TRL:{symbol:"TL", placement:"after"}, TWD:{symbol:"NT$"}, USD:{symbol:"$"}, UYU:{symbol:"$U", signplacement:"after", adjSpace:"symbol"}, VEB:{symbol:"Bs", signplacement:"after", adjSpace:"symbol"}, YER:arabic, ZAR:{symbol:"R", signPlacement:"around"}};
-})();
-

Deleted: tags/parley-0.53/root/static/magic/src/i18n/number.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/i18n/number.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/i18n/number.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,151 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.i18n.number");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.i18n.number");
-dojo.require("dojo.regexp");
-dojo.require("dojo.i18n.common");
-dojo.require("dojo.lang.common");
-dojo.i18n.number.format = function (value, flags, locale) {
-	flags = (typeof flags == "object") ? flags : {};
-	var formatData = dojo.i18n.number._mapToLocalizedFormatData(dojo.i18n.number.FORMAT_TABLE, locale);
-	if (typeof flags.separator == "undefined") {
-		flags.separator = formatData[1];
-	}
-	if (typeof flags.decimal == "undefined") {
-		flags.decimal = formatData[2];
-	}
-	if (typeof flags.groupSize == "undefined") {
-		flags.groupSize = formatData[3];
-	}
-	if (typeof flags.groupSize2 == "undefined") {
-		flags.groupSize2 = formatData[4];
-	}
-	if (typeof flags.round == "undefined") {
-		flags.round = true;
-	}
-	if (typeof flags.signed == "undefined") {
-		flags.signed = true;
-	}
-	var output = (flags.signed && (value < 0)) ? "-" : "";
-	value = Math.abs(value);
-	var whole = String((((flags.places > 0) || !flags.round) ? Math.floor : Math.round)(value));
-	function splitSubstrings(str, count) {
-		for (var subs = []; str.length >= count; str = str.substr(0, str.length - count)) {
-			subs.push(str.substr(-count));
-		}
-		if (str.length > 0) {
-			subs.push(str);
-		}
-		return subs.reverse();
-	}
-	if (flags.groupSize2 && (whole.length > flags.groupSize)) {
-		var groups = splitSubstrings(whole.substr(0, whole.length - flags.groupSize), flags.groupSize2);
-		groups.push(whole.substr(-flags.groupSize));
-		output = output + groups.join(flags.separator);
-	} else {
-		if (flags.groupSize) {
-			output = output + splitSubstrings(whole, flags.groupSize).join(flags.separator);
-		} else {
-			output = output + whole;
-		}
-	}
-	if (flags.places > 0) {
-		var fract = value - Math.floor(value);
-		fract = (flags.round ? Math.round : Math.floor)(fract * Math.pow(10, flags.places));
-		output = output + flags.decimal + fract;
-	}
-	return output;
-};
-dojo.i18n.number.parse = function (value, locale, flags) {
-	flags = (typeof flags == "object") ? flags : {};
-	var formatData = dojo.i18n.number._mapToLocalizedFormatData(dojo.i18n.number.FORMAT_TABLE, locale);
-	if (typeof flags.separator == "undefined") {
-		flags.separator = formatData[1];
-	}
-	if (typeof flags.decimal == "undefined") {
-		flags.decimal = formatData[2];
-	}
-	if (typeof flags.groupSize == "undefined") {
-		flags.groupSize = formatData[3];
-	}
-	if (typeof flags.groupSize2 == "undefined") {
-		flags.groupSize2 = formatData[4];
-	}
-	if (typeof flags.validate == "undefined") {
-		flags.validate = true;
-	}
-	if (flags.validate && !dojo.i18n.number.isReal(value, locale, flags)) {
-		return Number.NaN;
-	}
-	var numbers = value.split(flags.decimal);
-	if (numbers.length > 2) {
-		return Number.NaN;
-	}
-	var whole = Number(numbers[0].replace(new RegExp("\\" + flags.separator, "g"), ""));
-	var fract = (numbers.length == 1) ? 0 : Number(numbers[1]) / Math.pow(10, String(numbers[1]).length);
-	return whole + fract;
-};
-dojo.i18n.number.isInteger = function (value, locale, flags) {
-	flags = (typeof flags == "object") ? flags : {};
-	var formatData = dojo.i18n.number._mapToLocalizedFormatData(dojo.i18n.number.FORMAT_TABLE, locale);
-	if (typeof flags.separator == "undefined") {
-		flags.separator = formatData[1];
-	} else {
-		if (dojo.lang.isArray(flags.separator) && flags.separator.length === 0) {
-			flags.separator = [formatData[1], ""];
-		}
-	}
-	if (typeof flags.groupSize == "undefined") {
-		flags.groupSize = formatData[3];
-	}
-	if (typeof flags.groupSize2 == "undefined") {
-		flags.groupSize2 = formatData[4];
-	}
-	var re = new RegExp("^" + dojo.regexp.integer(flags) + "$");
-	return re.test(value);
-};
-dojo.i18n.number.isReal = function (value, locale, flags) {
-	flags = (typeof flags == "object") ? flags : {};
-	var formatData = dojo.i18n.number._mapToLocalizedFormatData(dojo.i18n.number.FORMAT_TABLE, locale);
-	if (typeof flags.separator == "undefined") {
-		flags.separator = formatData[1];
-	} else {
-		if (dojo.lang.isArray(flags.separator) && flags.separator.length === 0) {
-			flags.separator = [formatData[1], ""];
-		}
-	}
-	if (typeof flags.decimal == "undefined") {
-		flags.decimal = formatData[2];
-	}
-	if (typeof flags.groupSize == "undefined") {
-		flags.groupSize = formatData[3];
-	}
-	if (typeof flags.groupSize2 == "undefined") {
-		flags.groupSize2 = formatData[4];
-	}
-	var re = new RegExp("^" + dojo.regexp.realNumber(flags) + "$");
-	return re.test(value);
-};
-(function () {
-	dojo.i18n.number.FORMAT_TABLE = {"ar-ae":["", "", ",", 1], "ar-bh":["", "", ",", 1], "ar-dz":["", "", ",", 1], "ar-eg":["", "", ",", 1], "ar-jo":["", "", ",", 1], "ar-kw":["", "", ",", 1], "ar-lb":["", "", ",", 1], "ar-ma":["", "", ",", 1], "ar-om":["", "", ",", 1], "ar-qa":["", "", ",", 1], "ar-sa":["", "", ",", 1], "ar-sy":["", "", ",", 1], "ar-tn":["", "", ",", 1], "ar-ye":["", "", ",", 1], "cs-cz":[".", ".", ",", 3], "da-dk":[".", ".", ",", 3], "de-at":[".", ".", ",", 3], "de-de":[".", ".", ",", 3], "de-lu":[".", ".", ",", 3], "de-ch":["'", "'", ".", 3], "el-gr":[".", ".", ",", 3], "en-au":[",", ",", ".", 3], "en-ca":[",", ",", ".", 3], "en-gb":[",", ",", ".", 3], "en-hk":[",", ",", ".", 3], "en-ie":[",", ",", ".", 3], "en-in":[",", ",", ".", 3, 2], "en-nz":[",", ",", ".", 3], "en-us":[",", ",", ".", 3], "en-za":[",", ",", ".", 3], "es-ar":[".", ".", ",", 3], "es-bo":[".", ".", ",", 3], "es-cl":[".", ".", ",", 3], "es-co":[".", ".", ",", 3], "es-cr":[".", ".", ",", 3],!
  "es-do":[".", ".", ",", 3], "es-ec":[".", ".", ",", 3], "es-es":[".", ".", ",", 3], "es-gt":[",", ",", ".", 3], "es-hn":[",", ",", ".", 3], "es-mx":[",", ",", ".", 3], "es-ni":[",", ",", ".", 3], "es-pa":[",", ",", ".", 3], "es-pe":[",", ",", ".", 3], "es-pr":[",", ",", ".", 3], "es-py":[".", ".", ",", 3], "es-sv":[",", ",", ".", 3], "es-uy":[".", ".", ",", 3], "es-ve":[".", ".", ",", 3], "fi-fi":[" ", " ", ",", 3], "fr-be":[".", ".", ",", 3], "fr-ca":[" ", " ", ",", 3], "fr-ch":[" ", " ", ".", 3], "fr-fr":[" ", " ", ",", 3], "fr-lu":[".", ".", ",", 3], "he-il":[",", ",", ".", 3], "hu-hu":[" ", " ", ",", 3], "it-ch":[" ", " ", ".", 3], "it-it":[".", ".", ",", 3], "ja-jp":[",", ",", ".", 3], "ko-kr":[",", ",", ".", 3], "no-no":[".", ".", ",", 3], "nl-be":[" ", " ", ",", 3], "nl-nl":[".", ".", ",", 3], "pl-pl":[".", ".", ",", 3], "pt-br":[".", ".", ",", 3], "pt-pt":[".", ".", "$", 3], "ru-ru":[" ", " ", ",", 3], "sv-se":[".", " ", ",", 3], "tr-tr":[".", ".", ",", 3], "zh-cn"!
 :[",", ",", ".", 3], "zh-hk":[",", ",", ".", 3], "zh-tw":[",",!
  ",", ".
", 3], "*":[",", ",", ".", 3]};
-})();
-dojo.i18n.number._mapToLocalizedFormatData = function (table, locale) {
-	locale = dojo.hostenv.normalizeLocale(locale);
-	var data = table[locale];
-	if (typeof data == "undefined") {
-		data = table["*"];
-	}
-	return data;
-};
-

Modified: tags/parley-0.53/root/static/magic/src/iCalendar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/iCalendar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/iCalendar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,807 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.iCalendar");
+dojo.require("dojo.text.textDirectory");
+dojo.require("dojo.date");
+dojo.require("dojo.lang");
 
 
-dojo.require("dojo.cal.iCalendar");
-dojo.deprecated("dojo.icalendar", "use dojo.cal.iCalendar isntead", "0.5");
+dojo.iCalendar.fromText =  function (/* string */text) {
+	// summary
+	// Parse text of an iCalendar and return an array of iCalendar objects
 
+	var properties = dojo.textDirectoryTokeniser.tokenise(text);
+	var calendars = [];
+
+	//dojo.debug("Parsing iCal String");
+	for (var i = 0, begun = false; i < properties.length; i++) {
+		var prop = properties[i];
+		if (!begun) {
+			if (prop.name == 'BEGIN' && prop.value == 'VCALENDAR') {
+				begun = true;
+				var calbody = [];
+			}
+		} else if (prop.name == 'END' && prop.value == 'VCALENDAR') {
+			calendars.push(new dojo.iCalendar.VCalendar(calbody));
+			begun = false;
+		} else {
+			calbody.push(prop);
+		}
+	}
+	return /* array */calendars;
+}
+
+
+dojo.iCalendar.Component = function (/* string */ body ) {
+	// summary
+	// A component is the basic container of all this stuff. 
+
+	if (!this.name) {
+		this.name = "COMPONENT"
+	}
+
+	this.properties = [];
+	this.components = [];
+
+	if (body) {
+		for (var i = 0, context = ''; i < body.length; i++) {
+			if (context == '') {
+				if (body[i].name == 'BEGIN') {
+					context = body[i].value;
+					var childprops = [];
+				} else {
+					this.addProperty(new dojo.iCalendar.Property(body[i]));
+				}
+			} else if (body[i].name == 'END' && body[i].value == context) {
+				if (context=="VEVENT") {
+					this.addComponent(new dojo.iCalendar.VEvent(childprops));
+				} else if (context=="VTIMEZONE") {
+					this.addComponent(new dojo.iCalendar.VTimeZone(childprops));
+				} else if (context=="VTODO") {
+					this.addComponent(new dojo.iCalendar.VTodo(childprops));
+				} else if (context=="VJOURNAL") {
+					this.addComponent(new dojo.iCalendar.VJournal(childprops));
+				} else if (context=="VFREEBUSY") {
+					this.addComponent(new dojo.iCalendar.VFreeBusy(childprops));
+				} else if (context=="STANDARD") {
+					this.addComponent(new dojo.iCalendar.Standard(childprops));
+				} else if (context=="DAYLIGHT") {
+					this.addComponent(new dojo.iCalendar.Daylight(childprops));
+				} else if (context=="VALARM") {
+					this.addComponent(new dojo.iCalendar.VAlarm(childprops));
+				}else {
+					dojo.unimplemented("dojo.iCalendar." + context);
+				}
+				context = '';
+			} else {
+				childprops.push(body[i]);
+			}
+		}
+
+		if (this._ValidProperties) {
+			this.postCreate();
+		}
+	}
+}
+
+dojo.lang.extend(dojo.iCalendar.Component, {
+
+	addProperty: function (prop) {
+		// summary
+		// push a new property onto a component.
+		this.properties.push(prop);
+		this[prop.name.toLowerCase()] = prop;
+	},
+
+	addComponent: function (prop) {
+		// summary
+		// add a component to this components list of children.
+		this.components.push(prop);
+	},
+
+	postCreate: function() {
+		for (var x=0; x<this._ValidProperties.length; x++) {
+			var evtProperty = this._ValidProperties[x];
+			var found = false;
+	
+			for (var y=0; y<this.properties.length; y++) {	
+				var prop = this.properties[y];
+				var propName = prop.name.toLowerCase();
+				if (dojo.lang.isArray(evtProperty)) {
+
+					var alreadySet = false;
+					for (var z=0; z<evtProperty.length; z++) {
+						var evtPropertyName = evtProperty[z].name.toLowerCase();
+						if((this[evtPropertyName])  && (evtPropertyName != propName )) {
+							alreadySet=true;
+						} 
+					}
+					if (!alreadySet) {
+						this[propName] = prop;
+					}
+				} else {
+					if (propName == evtProperty.name.toLowerCase()) {
+						found = true;
+						if (evtProperty.occurance == 1){
+							this[propName] = prop;
+						} else {
+							found = true;
+							if (!dojo.lang.isArray(this[propName])) {
+							 	this[propName] = [];
+							}
+							this[propName].push(prop);
+						}
+					}
+				}
+			}
+
+			if (evtProperty.required && !found) {	
+				dojo.debug("iCalendar - " + this.name + ": Required Property not found: " + evtProperty.name);
+			}
+		}
+
+		// parse any rrules		
+		if (dojo.lang.isArray(this.rrule)) {
+			for(var x=0; x<this.rrule.length; x++) {
+				var rule = this.rrule[x].value;
+
+				//add a place to cache dates we have checked for recurrance
+				this.rrule[x].cache = function() {};
+				
+				var temp = rule.split(";");
+				for (var y=0; y<temp.length; y++) {
+					var pair = temp[y].split("=");
+					var key = pair[0].toLowerCase();
+					var val = pair[1];
+
+					if ((key == "freq") || (key=="interval") || (key=="until")) {
+						this.rrule[x][key]= val;
+					} else {
+						var valArray = val.split(",");
+						this.rrule[x][key] = valArray; 
+					}
+				}	
+			}
+			this.recurring = true;
+		}
+
+	}, 
+
+	toString: function () {
+		// summary
+		// output a string representation of this component.
+		return "[iCalendar.Component; " + this.name + ", " + this.properties.length +
+			" properties, " + this.components.length + " components]";
+	}
+});
+
+dojo.iCalendar.Property = function (prop) {
+	// summary
+	// A single property of a component.
+
+	// unpack the values
+	this.name = prop.name;
+	this.group = prop.group;
+	this.params = prop.params;
+	this.value = prop.value;
+
+}
+
+dojo.lang.extend(dojo.iCalendar.Property, {
+	toString: function () {	
+		// summary
+		// output a string reprensentation of this component.
+		return "[iCalenday.Property; " + this.name + ": " + this.value + "]";
+	}
+});
+
+// This is just a little helper function for the Component Properties
+var _P = function (n, oc, req) {
+	return {name: n, required: (req) ? true : false,
+		occurance: (oc == '*' || !oc) ? -1 : oc}
+}
+
+/*
+ * VCALENDAR
+ */
+
+dojo.iCalendar.VCalendar = function (/* string */ calbody) {
+	// summary
+	// VCALENDAR Component
+
+	this.name = "VCALENDAR";
+	this.recurring = [];
+	this.nonRecurringEvents = function(){};
+	dojo.iCalendar.Component.call(this, calbody);
+}
+
+dojo.inherits(dojo.iCalendar.VCalendar, dojo.iCalendar.Component);
+
+dojo.lang.extend(dojo.iCalendar.VCalendar, {
+
+	addComponent: function (prop) {
+		// summary
+		// add component to the calenadar that makes it easy to pull them out again later.
+		this.components.push(prop);
+		if (prop.name.toLowerCase() == "vevent") {
+			if (prop.rrule) {
+				this.recurring.push(prop);
+			} else {
+				var startDate = prop.getDate();
+				var month = startDate.getMonth() + 1;
+				var dateString= month + "-" + startDate.getDate() + "-" + startDate.getFullYear();
+				if (!dojo.lang.isArray(this[dateString])) {
+					this.nonRecurringEvents[dateString] = [];
+				}
+				this.nonRecurringEvents[dateString].push(prop);
+			}
+		}
+	},
+
+	preComputeRecurringEvents: function(until) {
+		var calculatedEvents = function(){};
+
+		for(var x=0; x<this.recurring.length; x++) {
+			var dates = this.recurring[x].getDates(until);
+			for (var y=0; y<dates.length;y++) {
+				var month = dates[y].getMonth() + 1;
+				var dateStr = month + "-" + dates[y].getDate() + "-" + dates[y].getFullYear();
+				if (!dojo.lang.isArray(calculatedEvents[dateStr])) {
+					calculatedEvents[dateStr] = [];
+				}
+
+				if (!dojo.lang.inArray(calculatedEvents[dateStr], this.recurring[x])) { 
+					calculatedEvents[dateStr].push(this.recurring[x]);
+				} 
+			}
+		}
+		this.recurringEvents = calculatedEvents;
+	
+	},
+
+	getEvents: function(/* Date */ date) {
+		// summary
+		// Gets all events occuring on a particular date
+		var events = [];
+		var recur = [];
+		var nonRecur = [];
+		var month = date.getMonth() + 1;
+		var dateStr= month + "-" + date.getDate() + "-" + date.getFullYear();
+		if (dojo.lang.isArray(this.nonRecurringEvents[dateStr])) {
+			nonRecur= this.nonRecurringEvents[dateStr];
+			dojo.debug("Number of nonRecurring Events: " + nonRecur.length);
+		} 
+		
+
+		if (dojo.lang.isArray(this.recurringEvents[dateStr])) {
+			recur= this.recurringEvents[dateStr];
+		} 
+
+		events = recur.concat(nonRecur);
+
+		if (events.length > 0) {
+			return events;
+		} 
+
+		return null;			
+	}
+});
+
+/*
+ * STANDARD
+ */
+
+var StandardProperties = [
+	_P("dtstart", 1, true), _P("tzoffsetto", 1, true), _P("tzoffsetfrom", 1, true),
+	_P("comment"), _P("rdate"), _P("rrule"), _P("tzname")
+];
+
+
+dojo.iCalendar.Standard = function (/* string */ body) {
+	// summary
+	// STANDARD Component
+
+	this.name = "STANDARD";
+	this._ValidProperties = StandardProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.Standard, dojo.iCalendar.Component);
+
+/*
+ * DAYLIGHT
+ */
+
+var DaylightProperties = [
+	_P("dtstart", 1, true), _P("tzoffsetto", 1, true), _P("tzoffsetfrom", 1, true),
+	_P("comment"), _P("rdate"), _P("rrule"), _P("tzname")
+];
+
+dojo.iCalendar.Daylight = function (/* string */ body) {
+	// summary
+	// Daylight Component
+	this.name = "DAYLIGHT";
+	this._ValidProperties = DaylightProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.Daylight, dojo.iCalendar.Component);
+
+/*
+ * VEVENT
+ */
+
+var VEventProperties = [
+	// these can occur once only
+	_P("class", 1), _P("created", 1), _P("description", 1), _P("dtstart", 1),
+	_P("geo", 1), _P("last-mod", 1), _P("location", 1), _P("organizer", 1),
+	_P("priority", 1), _P("dtstamp", 1), _P("seq", 1), _P("status", 1),
+	_P("summary", 1), _P("transp", 1), _P("uid", 1), _P("url", 1), _P("recurid", 1),
+	// these two are exclusive
+	[_P("dtend", 1), _P("duration", 1)],
+	// these can occur many times over
+	_P("attach"), _P("attendee"), _P("categories"), _P("comment"), _P("contact"),
+	_P("exdate"), _P("exrule"), _P("rstatus"), _P("related"), _P("resources"),
+	_P("rdate"), _P("rrule")
+];
+
+dojo.iCalendar.VEvent = function (/* string */ body) {
+	// summary 
+	// VEVENT Component
+	this._ValidProperties = VEventProperties;
+	this.name = "VEVENT";
+	dojo.iCalendar.Component.call(this, body);
+	this.recurring = false;
+	this.startDate = dojo.date.fromIso8601(this.dtstart.value);
+}
+
+dojo.inherits(dojo.iCalendar.VEvent, dojo.iCalendar.Component);
+
+dojo.lang.extend(dojo.iCalendar.VEvent, {
+		getDates: function(until) {
+			var dtstart = this.getDate();
+
+			var recurranceSet = [];
+			var weekdays=["su","mo","tu","we","th","fr","sa"];
+			var order = { 
+				"daily": 1, "weekly": 2, "monthly": 3, "yearly": 4,
+				"byday": 1, "bymonthday": 1, "byweekno": 2, "bymonth": 3, "byyearday": 4};
+
+			// expand rrules into the recurrance 
+			for (var x=0; x<this.rrule.length; x++) {
+				var rrule = this.rrule[x];
+				var freq = rrule.freq.toLowerCase();
+				var interval = 1;
+
+				if (rrule.interval > interval) {
+					interval = rrule.interval;
+				}
+
+				var set = [];
+				var freqInt = order[freq];
+
+				if (rrule.until) {
+					var tmpUntil = dojo.date.fromIso8601(rrule.until);
+				} else {
+					var tmpUntil = until
+				}
+
+				if (tmpUntil > until) {
+					tmpUntil = until
+				}
+
+
+				if (dtstart<tmpUntil) {
+
+					var expandingRules = function(){};
+					var cullingRules = function(){};
+					expandingRules.length=0;
+					cullingRules.length =0;
+
+					switch(freq) {
+						case "yearly":
+							var nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate < tmpUntil) {
+								nextDate.setYear(nextDate.getFullYear()+interval);
+								tmpDate = new Date(nextDate);
+								if(tmpDate < tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;
+						case "monthly":
+							nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate < tmpUntil) {
+								nextDate.setMonth(nextDate.getMonth()+interval);
+								var tmpDate = new Date(nextDate);
+								if (tmpDate < tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;
+						case "weekly":
+							nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate < tmpUntil) {
+								nextDate.setDate(nextDate.getDate()+(7*interval));
+								var tmpDate = new Date(nextDate);
+								if (tmpDate < tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;	
+						case "daily":
+							nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate < tmpUntil) {
+								nextDate.setDate(nextDate.getDate()+interval);
+								var tmpDate = new Date(nextDate);
+								if (tmpDate < tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;
+	
+					}
+
+					if ((rrule["bymonth"]) && (order["bymonth"]<freqInt))	{
+						for (var z=0; z<rrule["bymonth"].length; z++) {
+							if (z==0) {
+								for (var zz=0; zz < set.length; zz++) {
+									set[zz].setMonth(rrule["bymonth"][z]-1);
+								}
+							} else {
+								var subset=[];
+								for (var zz=0; zz < set.length; zz++) {
+									var newDate = new Date(set[zz]);
+									newDate.setMonth(rrule[z]);
+									subset.push(newDate);
+								}
+								tmp = set.concat(subset);
+								set = tmp;
+							}
+						}
+					}
+
+					
+					// while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time
+					// and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web
+					if (rrule["byweekno"] && !rrule["bymonth"]) {	
+						dojo.debug("TODO: no support for byweekno yet");
+					}
+
+
+					// while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time
+					// and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web
+					if (rrule["byyearday"] && !rrule["bymonth"] && !rrule["byweekno"] ) {	
+						if (rrule["byyearday"].length > 1) {
+							var regex = "([+-]?)([0-9]{1,3})";
+							for (var z=1; x<rrule["byyearday"].length; z++) {
+								var regexResult = rrule["byyearday"][z].match(regex);
+								if (z==1) {
+									for (var zz=0; zz < set.length; zz++) {
+										if (regexResult[1] == "-") {
+											dojo.date.setDayOfYear(set[zz],366-regexResult[2]);
+										} else {
+											dojo.date.setDayOfYear(set[zz],regexResult[2]);
+										}
+									}
+								}	else {
+									var subset=[];
+									for (var zz=0; zz < set.length; zz++) {
+										var newDate = new Date(set[zz]);
+										if (regexResult[1] == "-") {
+											dojo.date.setDayOfYear(newDate,366-regexResult[2]);
+										} else {
+											dojo.date.setDayOfYear(newDate,regexResult[2]);
+										}
+										subset.push(newDate);
+									}
+									tmp = set.concat(subset);
+									set = tmp;
+								}
+							}
+						}
+					}
+
+					if (rrule["bymonthday"]  && (order["bymonthday"]<freqInt)) {	
+						if (rrule["bymonthday"].length > 0) {
+							var regex = "([+-]?)([0-9]{1,3})";
+							for (var z=0; z<rrule["bymonthday"].length; z++) {
+								var regexResult = rrule["bymonthday"][z].match(regex);
+								if (z==0) {
+									for (var zz=0; zz < set.length; zz++) {
+										if (regexResult[1] == "-") {
+											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
+												set[zz].setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
+											}
+										} else {
+											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
+												set[zz].setDate(regexResult[2]);
+											}
+										}
+									}
+								}	else {
+									var subset=[];
+									for (var zz=0; zz < set.length; zz++) {
+										var newDate = new Date(set[zz]);
+										if (regexResult[1] == "-") {
+											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
+												newDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
+											}
+										} else {
+											if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
+												newDate.setDate(regexResult[2]);
+											}
+										}
+										subset.push(newDate);
+									}
+									tmp = set.concat(subset);
+									set = tmp;
+								}
+							}
+						}
+					}
+
+					if (rrule["byday"]  && (order["byday"]<freqInt)) {	
+						if (rrule["bymonth"]) {
+							if (rrule["byday"].length > 0) {
+								var regex = "([+-]?)([0-9]{0,1}?)([A-Za-z]{1,2})";
+								for (var z=0; z<rrule["byday"].length; z++) {
+									var regexResult = rrule["byday"][z].match(regex);
+									var occurance = regexResult[2];
+									var day = regexResult[3].toLowerCase();
+
+
+									if (z==0) {
+										for (var zz=0; zz < set.length; zz++) {
+											if (regexResult[1] == "-") {
+												//find the nth to last occurance of date 
+												var numDaysFound = 0;
+												var lastDayOfMonth = dojo.date.getDaysInMonth(set[zz]);
+												var daysToSubtract = 1;
+												set[zz].setDate(lastDayOfMonth); 
+												if (weekdays[set[zz].getDay()] == day) {
+													numDaysFound++;
+													daysToSubtract=7;
+												}
+												daysToSubtract = 1;
+												while (numDaysFound < occurance) {
+													set[zz].setDate(set[zz].getDate()-daysToSubtract);	
+													if (weekdays[set[zz].getDay()] == day) {
+														numDaysFound++;
+														daysToSubtract=7;	
+													}
+												}
+											} else {
+												if (occurance) {
+													var numDaysFound=0;
+													set[zz].setDate(1);
+													var daysToAdd=1;
+
+													if(weekdays[set[zz].getDay()] == day) {
+														numDaysFound++;
+														daysToAdd=7;
+													}
+
+													while(numDaysFound < occurance) {
+														set[zz].setDate(set[zz].getDate()+daysToAdd);
+														if(weekdays[set[zz].getDay()] == day) {
+															numDaysFound++;
+															daysToAdd=7;
+														}
+													}
+												} else {
+													//we're gonna expand here to add a date for each of the specified days for each month
+													var numDaysFound=0;
+													var subset = [];
+
+													lastDayOfMonth = new Date(set[zz]);
+													var daysInMonth = dojo.date.getDaysInMonth(set[zz]);
+													lastDayOfMonth.setDate(daysInMonth);
+
+													set[zz].setDate(1);
+												
+													if (weekdays[set[zz].getDay()] == day) {
+														numDaysFound++;
+													}
+													var tmpDate = new Date(set[zz]);
+													daysToAdd = 1;
+													while(tmpDate.getDate() < lastDayOfMonth) {
+														if (weekdays[tmpDate.getDay()] == day) {
+															numDaysFound++;
+															if (numDaysFound==1) {
+																set[zz] = tmpDate;
+															} else {
+																subset.push(tmpDate);
+																tmpDate = new Date(tmpDate);
+																daysToAdd=7;	
+																tmpDate.setDate(tmpDate.getDate() + daysToAdd);
+															}
+														} else {
+															tmpDate.setDate(tmpDate.getDate() + daysToAdd);
+														}
+													}
+													var t = set.concat(subset);
+													set = t; 
+												}
+											}
+										}
+									}	else {
+										var subset=[];
+										for (var zz=0; zz < set.length; zz++) {
+											var newDate = new Date(set[zz]);
+											if (regexResult[1] == "-") {
+												if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
+													newDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
+												}
+											} else {
+												if (regexResult[2] < dojo.date.getDaysInMonth(set[zz])) {
+													newDate.setDate(regexResult[2]);
+												}
+											}
+											subset.push(newDate);
+										}
+										tmp = set.concat(subset);
+										set = tmp;
+									}
+								}
+							}
+						} else {
+							dojo.debug("TODO: byday within a yearly rule without a bymonth");
+						}
+					}
+
+					dojo.debug("TODO: Process BYrules for units larger than frequency");
+			
+					//add this set of events to the complete recurranceSet	
+					var tmp = recurranceSet.concat(set);
+					recurranceSet = tmp;
+				}
+			}
+
+			// TODO: add rdates to the recurrance set here
+
+			// TODO: subtract exdates from the recurrance set here
+
+			//TODO:  subtract dates generated by exrules from recurranceSet here
+
+			recurranceSet.push(dtstart);
+			return recurranceSet;
+		},
+
+		getDate: function() {
+			return dojo.date.fromIso8601(this.dtstart.value);
+		}
+});
+
+/*
+ * VTIMEZONE
+ */
+
+var VTimeZoneProperties = [
+	_P("tzid", 1, true), _P("last-mod", 1), _P("tzurl", 1)
+
+	// one of 'standardc' or 'daylightc' must occur
+	// and each may occur more than once.
+];
+
+dojo.iCalendar.VTimeZone = function (/* string */ body) {
+	// summary
+	// VTIMEZONE Component
+	this.name = "VTIMEZONE";
+	this._ValidProperties = VTimeZoneProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VTimeZone, dojo.iCalendar.Component);
+
+/*
+ * VTODO
+ */
+
+var VTodoProperties = [
+	// these can occur once only
+	_P("class", 1), _P("completed", 1), _P("created", 1), _P("description", 1),
+	_P("dtstart", 1), _P("geo", 1), _P("last-mod", 1), _P("location", 1),
+	_P("organizer", 1), _P("percent", 1), _P("priority", 1), _P("dtstamp", 1),
+	_P("seq", 1), _P("status", 1), _P("summary", 1), _P("uid", 1), _P("url", 1),
+	_P("recurid", 1),
+	// these two are exclusive
+	[_P("due", 1), _P("duration", 1)],
+	// these can occur many times over
+	_P("attach"), _P("attendee"), _P("categories"), _P("comment"), _P("contact"),
+	_P("exdate"), _P("exrule"), _P("rstatus"), _P("related"), _P("resources"),
+	_P("rdate"), _P("rrule")
+];
+
+dojo.iCalendar.VTodo= function (/* string */ body) {
+	// summary
+	// VTODO Componenet
+	this.name = "VTODO";
+	this._ValidProperties = VTodoProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VTodo, dojo.iCalendar.Component);
+
+/*
+ * VJOURNAL
+ */
+
+var VJournalProperties = [
+	// these can occur once only
+	_P("class", 1), _P("created", 1), _P("description", 1), _P("dtstart", 1),
+	_P("last-mod", 1), _P("organizer", 1), _P("dtstamp", 1), _P("seq", 1),
+	_P("status", 1), _P("summary", 1), _P("uid", 1), _P("url", 1), _P("recurid", 1),
+	// these can occur many times over
+	_P("attach"), _P("attendee"), _P("categories"), _P("comment"), _P("contact"),
+	_P("exdate"), _P("exrule"), _P("related"), _P("rstatus"), _P("rdate"), _P("rrule")
+];
+
+dojo.iCalendar.VJournal= function (/* string */ body) {
+	// summary
+	// VJOURNAL Component
+	this.name = "VJOURNAL";
+	this._ValidProperties = VJournalProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VJournal, dojo.iCalendar.Component);
+
+/*
+ * VFREEBUSY
+ */
+
+var VFreeBusyProperties = [
+	// these can occur once only
+	_P("contact"), _P("dtstart", 1), _P("dtend"), _P("duration"),
+	_P("organizer", 1), _P("dtstamp", 1), _P("uid", 1), _P("url", 1),
+	// these can occur many times over
+	_P("attendee"), _P("comment"), _P("freebusy"), _P("rstatus")
+];
+
+dojo.iCalendar.VFreeBusy= function (/* string */ body) {
+	// summary
+	// VFREEBUSY Component
+	this.name = "VFREEBUSY";
+	this._ValidProperties = VFreeBusyProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VFreeBusy, dojo.iCalendar.Component);
+
+/*
+ * VALARM
+ */
+
+var VAlarmProperties = [
+	[_P("action", 1, true), _P("trigger", 1, true), [_P("duration", 1), _P("repeat", 1)],
+	_P("attach", 1)],
+
+	[_P("action", 1, true), _P("description", 1, true), _P("trigger", 1, true),
+	[_P("duration", 1), _P("repeat", 1)]],
+
+	[_P("action", 1, true), _P("description", 1, true), _P("trigger", 1, true),
+	_P("summary", 1, true), _P("attendee", "*", true),
+	[_P("duration", 1), _P("repeat", 1)],
+	_P("attach", 1)],
+
+	[_P("action", 1, true), _P("attach", 1, true), _P("trigger", 1, true),
+	[_P("duration", 1), _P("repeat", 1)],
+	_P("description", 1)],
+];
+
+dojo.iCalendar.VAlarm= function (/* string */ body) {
+	// summary
+	// VALARM Component
+	this.name = "VALARM";
+	this._ValidProperties = VAlarmProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VAlarm, dojo.iCalendar.Component);
+

Modified: tags/parley-0.53/root/static/magic/src/io/BrowserIO.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/BrowserIO.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/BrowserIO.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,488 +8,550 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.io.BrowserIO");
 
-
-dojo.provide("dojo.io.BrowserIO");
-dojo.require("dojo.io.common");
+dojo.require("dojo.io");
 dojo.require("dojo.lang.array");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.string.extras");
 dojo.require("dojo.dom");
 dojo.require("dojo.undo.browser");
-if (!dj_undef("window")) {
-	dojo.io.checkChildrenForFile = function (node) {
-		var hasFile = false;
-		var inputs = node.getElementsByTagName("input");
-		dojo.lang.forEach(inputs, function (input) {
-			if (hasFile) {
-				return;
+
+dojo.io.checkChildrenForFile = function(node){
+	var hasFile = false;
+	var inputs = node.getElementsByTagName("input");
+	dojo.lang.forEach(inputs, function(input){
+		if(hasFile){ return; }
+		if(input.getAttribute("type")=="file"){
+			hasFile = true;
+		}
+	});
+	return hasFile;
+}
+
+dojo.io.formHasFile = function(formNode){
+	return dojo.io.checkChildrenForFile(formNode);
+}
+
+dojo.io.updateNode = function(node, urlOrArgs){
+	node = dojo.byId(node);
+	var args = urlOrArgs;
+	if(dojo.lang.isString(urlOrArgs)){
+		args = { url: urlOrArgs };
+	}
+	args.mimetype = "text/html";
+	args.load = function(t, d, e){
+		while(node.firstChild){
+			if(dojo["event"]){
+				try{
+					dojo.event.browser.clean(node.firstChild);
+				}catch(e){}
 			}
-			if (input.getAttribute("type") == "file") {
-				hasFile = true;
-			}
-		});
-		return hasFile;
-	};
-	dojo.io.formHasFile = function (formNode) {
-		return dojo.io.checkChildrenForFile(formNode);
-	};
-	dojo.io.updateNode = function (node, urlOrArgs) {
-		node = dojo.byId(node);
-		var args = urlOrArgs;
-		if (dojo.lang.isString(urlOrArgs)) {
-			args = {url:urlOrArgs};
+			node.removeChild(node.firstChild);
 		}
-		args.mimetype = "text/html";
-		args.load = function (t, d, e) {
-			while (node.firstChild) {
-				dojo.dom.destroyNode(node.firstChild);
-			}
-			node.innerHTML = d;
-		};
-		dojo.io.bind(args);
+		node.innerHTML = d;
 	};
-	dojo.io.formFilter = function (node) {
-		var type = (node.type || "").toLowerCase();
-		return !node.disabled && node.name && !dojo.lang.inArray(["file", "submit", "image", "reset", "button"], type);
-	};
-	dojo.io.encodeForm = function (formNode, encoding, formFilter) {
-		if ((!formNode) || (!formNode.tagName) || (!formNode.tagName.toLowerCase() == "form")) {
-			dojo.raise("Attempted to encode a non-form element.");
-		}
-		if (!formFilter) {
-			formFilter = dojo.io.formFilter;
-		}
-		var enc = /utf/i.test(encoding || "") ? encodeURIComponent : dojo.string.encodeAscii;
-		var values = [];
-		for (var i = 0; i < formNode.elements.length; i++) {
-			var elm = formNode.elements[i];
-			if (!elm || elm.tagName.toLowerCase() == "fieldset" || !formFilter(elm)) {
-				continue;
-			}
-			var name = enc(elm.name);
-			var type = elm.type.toLowerCase();
-			if (type == "select-multiple") {
-				for (var j = 0; j < elm.options.length; j++) {
-					if (elm.options[j].selected) {
-						values.push(name + "=" + enc(elm.options[j].value));
-					}
+	dojo.io.bind(args);
+}
+
+dojo.io.formFilter = function(node) {
+	var type = (node.type||"").toLowerCase();
+	return !node.disabled && node.name
+		&& !dojo.lang.inArray(type, ["file", "submit", "image", "reset", "button"]);
+}
+
+// TODO: Move to htmlUtils
+dojo.io.encodeForm = function(formNode, encoding, formFilter){
+	if((!formNode)||(!formNode.tagName)||(!formNode.tagName.toLowerCase() == "form")){
+		dojo.raise("Attempted to encode a non-form element.");
+	}
+	if(!formFilter) { formFilter = dojo.io.formFilter; }
+	var enc = /utf/i.test(encoding||"") ? encodeURIComponent : dojo.string.encodeAscii;
+	var values = [];
+
+	for(var i = 0; i < formNode.elements.length; i++){
+		var elm = formNode.elements[i];
+		if(!elm || elm.tagName.toLowerCase() == "fieldset" || !formFilter(elm)) { continue; }
+		var name = enc(elm.name);
+		var type = elm.type.toLowerCase();
+
+		if(type == "select-multiple"){
+			for(var j = 0; j < elm.options.length; j++){
+				if(elm.options[j].selected) {
+					values.push(name + "=" + enc(elm.options[j].value));
 				}
-			} else {
-				if (dojo.lang.inArray(["radio", "checkbox"], type)) {
-					if (elm.checked) {
-						values.push(name + "=" + enc(elm.value));
-					}
-				} else {
-					values.push(name + "=" + enc(elm.value));
-				}
 			}
-		}
-		var inputs = formNode.getElementsByTagName("input");
-		for (var i = 0; i < inputs.length; i++) {
-			var input = inputs[i];
-			if (input.type.toLowerCase() == "image" && input.form == formNode && formFilter(input)) {
-				var name = enc(input.name);
-				values.push(name + "=" + enc(input.value));
-				values.push(name + ".x=0");
-				values.push(name + ".y=0");
+		}else if(dojo.lang.inArray(type, ["radio", "checkbox"])){
+			if(elm.checked){
+				values.push(name + "=" + enc(elm.value));
 			}
+		}else{
+			values.push(name + "=" + enc(elm.value));
 		}
-		return values.join("&") + "&";
-	};
-	dojo.io.FormBind = function (args) {
-		this.bindArgs = {};
-		if (args && args.formNode) {
-			this.init(args);
-		} else {
-			if (args) {
-				this.init({formNode:args});
-			}
+	}
+
+	// now collect input type="image", which doesn't show up in the elements array
+	var inputs = formNode.getElementsByTagName("input");
+	for(var i = 0; i < inputs.length; i++) {
+		var input = inputs[i];
+		if(input.type.toLowerCase() == "image" && input.form == formNode
+			&& formFilter(input)) {
+			var name = enc(input.name);
+			values.push(name + "=" + enc(input.value));
+			values.push(name + ".x=0");
+			values.push(name + ".y=0");
 		}
-	};
-	dojo.lang.extend(dojo.io.FormBind, {form:null, bindArgs:null, clickedButton:null, init:function (args) {
+	}
+	return values.join("&") + "&";
+}
+
+dojo.io.FormBind = function(args) {
+	this.bindArgs = {};
+
+	if(args && args.formNode) {
+		this.init(args);
+	} else if(args) {
+		this.init({formNode: args});
+	}
+}
+dojo.lang.extend(dojo.io.FormBind, {
+	form: null,
+
+	bindArgs: null,
+
+	clickedButton: null,
+
+	init: function(args) {
 		var form = dojo.byId(args.formNode);
-		if (!form || !form.tagName || form.tagName.toLowerCase() != "form") {
+
+		if(!form || !form.tagName || form.tagName.toLowerCase() != "form") {
 			throw new Error("FormBind: Couldn't apply, invalid form");
-		} else {
-			if (this.form == form) {
-				return;
-			} else {
-				if (this.form) {
-					throw new Error("FormBind: Already applied to a form");
-				}
-			}
+		} else if(this.form == form) {
+			return;
+		} else if(this.form) {
+			throw new Error("FormBind: Already applied to a form");
 		}
+
 		dojo.lang.mixin(this.bindArgs, args);
 		this.form = form;
+
 		this.connect(form, "onsubmit", "submit");
-		for (var i = 0; i < form.elements.length; i++) {
+
+		for(var i = 0; i < form.elements.length; i++) {
 			var node = form.elements[i];
-			if (node && node.type && dojo.lang.inArray(["submit", "button"], node.type.toLowerCase())) {
+			if(node && node.type && dojo.lang.inArray(node.type.toLowerCase(), ["submit", "button"])) {
 				this.connect(node, "onclick", "click");
 			}
 		}
+
 		var inputs = form.getElementsByTagName("input");
-		for (var i = 0; i < inputs.length; i++) {
+		for(var i = 0; i < inputs.length; i++) {
 			var input = inputs[i];
-			if (input.type.toLowerCase() == "image" && input.form == form) {
+			if(input.type.toLowerCase() == "image" && input.form == form) {
 				this.connect(input, "onclick", "click");
 			}
 		}
-	}, onSubmit:function (form) {
+	},
+
+	onSubmit: function(form) {
 		return true;
-	}, submit:function (e) {
+	},
+
+	submit: function(e) {
 		e.preventDefault();
-		if (this.onSubmit(this.form)) {
-			dojo.io.bind(dojo.lang.mixin(this.bindArgs, {formFilter:dojo.lang.hitch(this, "formFilter")}));
+		if(this.onSubmit(this.form)) {
+			dojo.io.bind(dojo.lang.mixin(this.bindArgs, {
+				formFilter: dojo.lang.hitch(this, "formFilter")
+			}));
 		}
-	}, click:function (e) {
+	},
+
+	click: function(e) {
 		var node = e.currentTarget;
-		if (node.disabled) {
-			return;
-		}
+		if(node.disabled) { return; }
 		this.clickedButton = node;
-	}, formFilter:function (node) {
-		var type = (node.type || "").toLowerCase();
+	},
+
+	formFilter: function(node) {
+		var type = (node.type||"").toLowerCase();
 		var accept = false;
-		if (node.disabled || !node.name) {
+		if(node.disabled || !node.name) {
 			accept = false;
+		} else if(dojo.lang.inArray(type, ["submit", "button", "image"])) {
+			if(!this.clickedButton) { this.clickedButton = node; }
+			accept = node == this.clickedButton;
 		} else {
-			if (dojo.lang.inArray(["submit", "button", "image"], type)) {
-				if (!this.clickedButton) {
-					this.clickedButton = node;
-				}
-				accept = node == this.clickedButton;
-			} else {
-				accept = !dojo.lang.inArray(["file", "submit", "reset", "button"], type);
-			}
+			accept = !dojo.lang.inArray(type, ["file", "submit", "reset", "button"]);
 		}
 		return accept;
-	}, connect:function (srcObj, srcFcn, targetFcn) {
-		if (dojo.evalObjPath("dojo.event.connect")) {
+	},
+
+	// in case you don't have dojo.event.* pulled in
+	connect: function(srcObj, srcFcn, targetFcn) {
+		if(dojo.evalObjPath("dojo.event.connect")) {
 			dojo.event.connect(srcObj, srcFcn, this, targetFcn);
 		} else {
 			var fcn = dojo.lang.hitch(this, targetFcn);
-			srcObj[srcFcn] = function (e) {
-				if (!e) {
-					e = window.event;
-				}
-				if (!e.currentTarget) {
-					e.currentTarget = e.srcElement;
-				}
-				if (!e.preventDefault) {
-					e.preventDefault = function () {
-						window.event.returnValue = false;
-					};
-				}
+			srcObj[srcFcn] = function(e) {
+				if(!e) { e = window.event; }
+				if(!e.currentTarget) { e.currentTarget = e.srcElement; }
+				if(!e.preventDefault) { e.preventDefault = function() { window.event.returnValue = false; } }
 				fcn(e);
-			};
+			}
 		}
-	}});
-	dojo.io.XMLHTTPTransport = new function () {
-		var _this = this;
-		var _cache = {};
-		this.useCache = false;
-		this.preventCache = false;
-		function getCacheKey(url, query, method) {
-			return url + "|" + query + "|" + method.toLowerCase();
-		}
-		function addToCache(url, query, method, http) {
-			_cache[getCacheKey(url, query, method)] = http;
-		}
-		function getFromCache(url, query, method) {
-			return _cache[getCacheKey(url, query, method)];
-		}
-		this.clearCache = function () {
-			_cache = {};
-		};
-		function doLoad(kwArgs, http, url, query, useCache) {
-			if (((http.status >= 200) && (http.status < 300)) || (http.status == 304) || (http.status == 1223) || (location.protocol == "file:" && (http.status == 0 || http.status == undefined)) || (location.protocol == "chrome:" && (http.status == 0 || http.status == undefined))) {
-				var ret;
-				if (kwArgs.method.toLowerCase() == "head") {
-					var headers = http.getAllResponseHeaders();
-					ret = {};
-					ret.toString = function () {
-						return headers;
-					};
-					var values = headers.split(/[\r\n]+/g);
-					for (var i = 0; i < values.length; i++) {
-						var pair = values[i].match(/^([^:]+)\s*:\s*(.+)$/i);
-						if (pair) {
-							ret[pair[1]] = pair[2];
-						}
+	}
+});
+
+dojo.io.XMLHTTPTransport = new function(){
+	var _this = this;
+
+	var _cache = {}; // FIXME: make this public? do we even need to?
+	this.useCache = false; // if this is true, we'll cache unless kwArgs.useCache = false
+	this.preventCache = false; // if this is true, we'll always force GET requests to cache
+
+	// FIXME: Should this even be a function? or do we just hard code it in the next 2 functions?
+	function getCacheKey(url, query, method) {
+		return url + "|" + query + "|" + method.toLowerCase();
+	}
+
+	function addToCache(url, query, method, http) {
+		_cache[getCacheKey(url, query, method)] = http;
+	}
+
+	function getFromCache(url, query, method) {
+		return _cache[getCacheKey(url, query, method)];
+	}
+
+	this.clearCache = function() {
+		_cache = {};
+	}
+
+	// moved successful load stuff here
+	function doLoad(kwArgs, http, url, query, useCache) {
+		if(	((http.status>=200)&&(http.status<300))|| 	// allow any 2XX response code
+			(http.status==304)|| 						// get it out of the cache
+			(location.protocol=="file:" && (http.status==0 || http.status==undefined))||
+			(location.protocol=="chrome:" && (http.status==0 || http.status==undefined))
+		){
+			var ret;
+			if(kwArgs.method.toLowerCase() == "head"){
+				var headers = http.getAllResponseHeaders();
+				ret = {};
+				ret.toString = function(){ return headers; }
+				var values = headers.split(/[\r\n]+/g);
+				for(var i = 0; i < values.length; i++) {
+					var pair = values[i].match(/^([^:]+)\s*:\s*(.+)$/i);
+					if(pair) {
+						ret[pair[1]] = pair[2];
 					}
-				} else {
-					if (kwArgs.mimetype == "text/javascript") {
-						try {
-							ret = dj_eval(http.responseText);
-						}
-						catch (e) {
-							dojo.debug(e);
-							dojo.debug(http.responseText);
-							ret = null;
-						}
-					} else {
-						if (kwArgs.mimetype.substr(0, 9) == "text/json" || kwArgs.mimetype.substr(0, 16) == "application/json") {
-							try {
-								ret = dj_eval("(" + kwArgs.jsonFilter(http.responseText) + ")");
-							}
-							catch (e) {
-								dojo.debug(e);
-								dojo.debug(http.responseText);
-								ret = false;
-							}
-						} else {
-							if ((kwArgs.mimetype == "application/xml") || (kwArgs.mimetype == "text/xml")) {
-								ret = http.responseXML;
-								if (!ret || typeof ret == "string" || !http.getResponseHeader("Content-Type")) {
-									ret = dojo.dom.createDocumentFromText(http.responseText);
-								}
-							} else {
-								ret = http.responseText;
-							}
-						}
-					}
 				}
-				if (useCache) {
-					addToCache(url, query, kwArgs.method, http);
+			}else if(kwArgs.mimetype == "text/javascript"){
+				try{
+					ret = dj_eval(http.responseText);
+				}catch(e){
+					dojo.debug(e);
+					dojo.debug(http.responseText);
+					ret = null;
 				}
-				kwArgs[(typeof kwArgs.load == "function") ? "load" : "handle"]("load", ret, http, kwArgs);
-			} else {
-				var errObj = new dojo.io.Error("XMLHttpTransport Error: " + http.status + " " + http.statusText);
-				kwArgs[(typeof kwArgs.error == "function") ? "error" : "handle"]("error", errObj, http, kwArgs);
+			}else if(kwArgs.mimetype == "text/json"){
+				try{
+					ret = dj_eval("("+http.responseText+")");
+				}catch(e){
+					dojo.debug(e);
+					dojo.debug(http.responseText);
+					ret = false;
+				}
+			}else if((kwArgs.mimetype == "application/xml")||
+						(kwArgs.mimetype == "text/xml")){
+				ret = http.responseXML;
+				if(!ret || typeof ret == "string" || !http.getResponseHeader("Content-Type")) {
+					ret = dojo.dom.createDocumentFromText(http.responseText);
+				}
+			}else{
+				ret = http.responseText;
 			}
+
+			if(useCache){ // only cache successful responses
+				addToCache(url, query, kwArgs.method, http);
+			}
+			kwArgs[(typeof kwArgs.load == "function") ? "load" : "handle"]("load", ret, http, kwArgs);
+		}else{
+			var errObj = new dojo.io.Error("XMLHttpTransport Error: "+http.status+" "+http.statusText);
+			kwArgs[(typeof kwArgs.error == "function") ? "error" : "handle"]("error", errObj, http, kwArgs);
 		}
-		function setHeaders(http, kwArgs) {
-			if (kwArgs["headers"]) {
-				for (var header in kwArgs["headers"]) {
-					if (header.toLowerCase() == "content-type" && !kwArgs["contentType"]) {
-						kwArgs["contentType"] = kwArgs["headers"][header];
-					} else {
-						http.setRequestHeader(header, kwArgs["headers"][header]);
-					}
+	}
+
+	// set headers (note: Content-Type will get overriden if kwArgs.contentType is set)
+	function setHeaders(http, kwArgs){
+		if(kwArgs["headers"]) {
+			for(var header in kwArgs["headers"]) {
+				if(header.toLowerCase() == "content-type" && !kwArgs["contentType"]) {
+					kwArgs["contentType"] = kwArgs["headers"][header];
+				} else {
+					http.setRequestHeader(header, kwArgs["headers"][header]);
 				}
 			}
 		}
-		this.inFlight = [];
-		this.inFlightTimer = null;
-		this.startWatchingInFlight = function () {
-			if (!this.inFlightTimer) {
-				this.inFlightTimer = setTimeout("dojo.io.XMLHTTPTransport.watchInFlight();", 10);
-			}
-		};
-		this.watchInFlight = function () {
-			var now = null;
-			if (!dojo.hostenv._blockAsync && !_this._blockAsync) {
-				for (var x = this.inFlight.length - 1; x >= 0; x--) {
-					try {
-						var tif = this.inFlight[x];
-						if (!tif || tif.http._aborted || !tif.http.readyState) {
-							this.inFlight.splice(x, 1);
-							continue;
-						}
-						if (4 == tif.http.readyState) {
-							this.inFlight.splice(x, 1);
-							doLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);
-						} else {
-							if (tif.startTime) {
-								if (!now) {
-									now = (new Date()).getTime();
-								}
-								if (tif.startTime + (tif.req.timeoutSeconds * 1000) < now) {
-									if (typeof tif.http.abort == "function") {
-										tif.http.abort();
-									}
-									this.inFlight.splice(x, 1);
-									tif.req[(typeof tif.req.timeout == "function") ? "timeout" : "handle"]("timeout", null, tif.http, tif.req);
-								}
-							}
-						}
+	}
+
+	this.inFlight = [];
+	this.inFlightTimer = null;
+
+	this.startWatchingInFlight = function(){
+		if(!this.inFlightTimer){
+			this.inFlightTimer = setInterval("dojo.io.XMLHTTPTransport.watchInFlight();", 10);
+		}
+	}
+
+	this.watchInFlight = function(){
+		var now = null;
+		for(var x=this.inFlight.length-1; x>=0; x--){
+			var tif = this.inFlight[x];
+			if(!tif){ this.inFlight.splice(x, 1); continue; }
+			if(4==tif.http.readyState){
+				// remove it so we can clean refs
+				this.inFlight.splice(x, 1);
+				doLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);
+			}else if (tif.startTime){
+				//See if this is a timeout case.
+				if(!now){
+					now = (new Date()).getTime();
+				}
+				if(tif.startTime + (tif.req.timeoutSeconds * 1000) < now){
+					//Stop the request.
+					if(typeof tif.http.abort == "function"){
+						tif.http.abort();
 					}
-					catch (e) {
-						try {
-							var errObj = new dojo.io.Error("XMLHttpTransport.watchInFlight Error: " + e);
-							tif.req[(typeof tif.req.error == "function") ? "error" : "handle"]("error", errObj, tif.http, tif.req);
-						}
-						catch (e2) {
-							dojo.debug("XMLHttpTransport error callback failed: " + e2);
-						}
-					}
+
+					// remove it so we can clean refs
+					this.inFlight.splice(x, 1);
+					tif.req[(typeof tif.req.timeout == "function") ? "timeout" : "handle"]("timeout", null, tif.http, tif.req);
 				}
 			}
-			clearTimeout(this.inFlightTimer);
-			if (this.inFlight.length == 0) {
-				this.inFlightTimer = null;
-				return;
+		}
+
+		if(this.inFlight.length == 0){
+			clearInterval(this.inFlightTimer);
+			this.inFlightTimer = null;
+		}
+	}
+
+	var hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;
+	this.canHandle = function(kwArgs){
+		// canHandle just tells dojo.io.bind() if this is a good transport to
+		// use for the particular type of request.
+
+		// FIXME: we need to determine when form values need to be
+		// multi-part mime encoded and avoid using this transport for those
+		// requests.
+		return hasXmlHttp
+			&& dojo.lang.inArray((kwArgs["mimetype"].toLowerCase()||""), ["text/plain", "text/html", "application/xml", "text/xml", "text/javascript", "text/json"])
+			&& !( kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]) );
+	}
+
+	this.multipartBoundary = "45309FFF-BD65-4d50-99C9-36986896A96F";	// unique guid as a boundary value for multipart posts
+
+	this.bind = function(kwArgs){
+		if(!kwArgs["url"]){
+			// are we performing a history action?
+			if( !kwArgs["formNode"]
+				&& (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"] || kwArgs["watchForURL"])
+				&& (!djConfig.preventBackButtonFix)) {
+        dojo.deprecated("Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request",
+        				"Use dojo.undo.browser.addToHistory() instead.", "0.4");
+				dojo.undo.browser.addToHistory(kwArgs);
+				return true;
 			}
-			this.inFlightTimer = setTimeout("dojo.io.XMLHTTPTransport.watchInFlight();", 10);
-		};
-		var hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;
-		this.canHandle = function (kwArgs) {
-			var mlc = kwArgs["mimetype"].toLowerCase() || "";
-			return hasXmlHttp && ((dojo.lang.inArray(["text/plain", "text/html", "application/xml", "text/xml", "text/javascript"], mlc)) || (mlc.substr(0, 9) == "text/json" || mlc.substr(0, 16) == "application/json")) && !(kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]));
-		};
-		this.multipartBoundary = "45309FFF-BD65-4d50-99C9-36986896A96F";
-		this.bind = function (kwArgs) {
-			if (!kwArgs["url"]) {
-				if (!kwArgs["formNode"] && (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"] || kwArgs["watchForURL"]) && (!djConfig.preventBackButtonFix)) {
-					dojo.deprecated("Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request", "Use dojo.undo.browser.addToHistory() instead.", "0.4");
-					dojo.undo.browser.addToHistory(kwArgs);
-					return true;
-				}
+		}
+
+		// build this first for cache purposes
+		var url = kwArgs.url;
+		var query = "";
+		if(kwArgs["formNode"]){
+			var ta = kwArgs.formNode.getAttribute("action");
+			if((ta)&&(!kwArgs["url"])){ url = ta; }
+			var tp = kwArgs.formNode.getAttribute("method");
+			if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
+			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
+		}
+
+		if(url.indexOf("#") > -1) {
+			dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
+			url = url.split("#")[0];
+		}
+
+		if(kwArgs["file"]){
+			// force post for file transfer
+			kwArgs.method = "post";
+		}
+
+		if(!kwArgs["method"]){
+			kwArgs.method = "get";
+		}
+
+		// guess the multipart value		
+		if(kwArgs.method.toLowerCase() == "get"){
+			// GET cannot use multipart
+			kwArgs.multipart = false;
+		}else{
+			if(kwArgs["file"]){
+				// enforce multipart when sending files
+				kwArgs.multipart = true;
+			}else if(!kwArgs["multipart"]){
+				// default 
+				kwArgs.multipart = false;
 			}
-			var url = kwArgs.url;
-			var query = "";
-			if (kwArgs["formNode"]) {
-				var ta = kwArgs.formNode.getAttribute("action");
-				if ((ta) && (!kwArgs["url"])) {
-					url = ta;
-				}
-				var tp = kwArgs.formNode.getAttribute("method");
-				if ((tp) && (!kwArgs["method"])) {
-					kwArgs.method = tp;
-				}
-				query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
+		}
+
+		if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
+			dojo.undo.browser.addToHistory(kwArgs);
+		}
+
+		var content = kwArgs["content"] || {};
+
+		if(kwArgs.sendTransport) {
+			content["dojo.transport"] = "xmlhttp";
+		}
+
+		do { // break-block
+			if(kwArgs.postContent){
+				query = kwArgs.postContent;
+				break;
 			}
-			if (url.indexOf("#") > -1) {
-				dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
-				url = url.split("#")[0];
+
+			if(content) {
+				query += dojo.io.argsFromMap(content, kwArgs.encoding);
 			}
-			if (kwArgs["file"]) {
-				kwArgs.method = "post";
+			
+			if(kwArgs.method.toLowerCase() == "get" || !kwArgs.multipart){
+				break;
 			}
-			if (!kwArgs["method"]) {
-				kwArgs.method = "get";
+
+			var	t = [];
+			if(query.length){
+				var q = query.split("&");
+				for(var i = 0; i < q.length; ++i){
+					if(q[i].length){
+						var p = q[i].split("=");
+						t.push(	"--" + this.multipartBoundary,
+								"Content-Disposition: form-data; name=\"" + p[0] + "\"", 
+								"",
+								p[1]);
+					}
+				}
 			}
-			if (kwArgs.method.toLowerCase() == "get") {
-				kwArgs.multipart = false;
-			} else {
-				if (kwArgs["file"]) {
-					kwArgs.multipart = true;
-				} else {
-					if (!kwArgs["multipart"]) {
-						kwArgs.multipart = false;
+
+			if(kwArgs.file){
+				if(dojo.lang.isArray(kwArgs.file)){
+					for(var i = 0; i < kwArgs.file.length; ++i){
+						var o = kwArgs.file[i];
+						t.push(	"--" + this.multipartBoundary,
+								"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
+								"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
+								"",
+								o.content);
 					}
+				}else{
+					var o = kwArgs.file;
+					t.push(	"--" + this.multipartBoundary,
+							"Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"",
+							"Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"),
+							"",
+							o.content);
 				}
 			}
-			if (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]) {
-				dojo.undo.browser.addToHistory(kwArgs);
+
+			if(t.length){
+				t.push("--"+this.multipartBoundary+"--", "");
+				query = t.join("\r\n");
 			}
-			var content = kwArgs["content"] || {};
-			if (kwArgs.sendTransport) {
-				content["dojo.transport"] = "xmlhttp";
+		}while(false);
+
+		// kwArgs.Connection = "close";
+
+		var async = kwArgs["sync"] ? false : true;
+
+		var preventCache = kwArgs["preventCache"] ||
+			(this.preventCache == true && kwArgs["preventCache"] != false);
+		var useCache = kwArgs["useCache"] == true ||
+			(this.useCache == true && kwArgs["useCache"] != false );
+
+		// preventCache is browser-level (add query string junk), useCache
+		// is for the local cache. If we say preventCache, then don't attempt
+		// to look in the cache, but if useCache is true, we still want to cache
+		// the response
+		if(!preventCache && useCache){
+			var cachedHttp = getFromCache(url, query, kwArgs.method);
+			if(cachedHttp){
+				doLoad(kwArgs, cachedHttp, url, query, false);
+				return;
 			}
-			do {
-				if (kwArgs.postContent) {
-					query = kwArgs.postContent;
-					break;
+		}
+
+		// much of this is from getText, but reproduced here because we need
+		// more flexibility
+		var http = dojo.hostenv.getXmlhttpObject(kwArgs);	
+		var received = false;
+
+		// build a handler function that calls back to the handler obj
+		if(async){
+			var startTime = 
+			// FIXME: setting up this callback handler leaks on IE!!!
+			this.inFlight.push({
+				"req":		kwArgs,
+				"http":		http,
+				"url":	 	url,
+				"query":	query,
+				"useCache":	useCache,
+				"startTime": kwArgs.timeoutSeconds ? (new Date()).getTime() : 0
+			});
+			this.startWatchingInFlight();
+		}
+
+		if(kwArgs.method.toLowerCase() == "post"){
+			// FIXME: need to hack in more flexible Content-Type setting here!
+			http.open("POST", url, async);
+			setHeaders(http, kwArgs);
+			http.setRequestHeader("Content-Type", kwArgs.multipart ? ("multipart/form-data; boundary=" + this.multipartBoundary) : 
+				(kwArgs.contentType || "application/x-www-form-urlencoded"));
+			try{
+				http.send(query);
+			}catch(e){
+				if(typeof http.abort == "function"){
+					http.abort();
 				}
-				if (content) {
-					query += dojo.io.argsFromMap(content, kwArgs.encoding);
-				}
-				if (kwArgs.method.toLowerCase() == "get" || !kwArgs.multipart) {
-					break;
-				}
-				var t = [];
-				if (query.length) {
-					var q = query.split("&");
-					for (var i = 0; i < q.length; ++i) {
-						if (q[i].length) {
-							var p = q[i].split("=");
-							t.push("--" + this.multipartBoundary, "Content-Disposition: form-data; name=\"" + p[0] + "\"", "", p[1]);
-						}
-					}
-				}
-				if (kwArgs.file) {
-					if (dojo.lang.isArray(kwArgs.file)) {
-						for (var i = 0; i < kwArgs.file.length; ++i) {
-							var o = kwArgs.file[i];
-							t.push("--" + this.multipartBoundary, "Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"", "Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"), "", o.content);
-						}
-					} else {
-						var o = kwArgs.file;
-						t.push("--" + this.multipartBoundary, "Content-Disposition: form-data; name=\"" + o.name + "\"; filename=\"" + ("fileName" in o ? o.fileName : o.name) + "\"", "Content-Type: " + ("contentType" in o ? o.contentType : "application/octet-stream"), "", o.content);
-					}
-				}
-				if (t.length) {
-					t.push("--" + this.multipartBoundary + "--", "");
-					query = t.join("\r\n");
-				}
-			} while (false);
-			var async = kwArgs["sync"] ? false : true;
-			var preventCache = kwArgs["preventCache"] || (this.preventCache == true && kwArgs["preventCache"] != false);
-			var useCache = kwArgs["useCache"] == true || (this.useCache == true && kwArgs["useCache"] != false);
-			if (!preventCache && useCache) {
-				var cachedHttp = getFromCache(url, query, kwArgs.method);
-				if (cachedHttp) {
-					doLoad(kwArgs, cachedHttp, url, query, false);
-					return;
-				}
+				doLoad(kwArgs, {status: 404}, url, query, useCache);
 			}
-			var http = dojo.hostenv.getXmlhttpObject(kwArgs);
-			var received = false;
-			if (async) {
-				var startTime = this.inFlight.push({"req":kwArgs, "http":http, "url":url, "query":query, "useCache":useCache, "startTime":kwArgs.timeoutSeconds ? (new Date()).getTime() : 0});
-				this.startWatchingInFlight();
-			} else {
-				_this._blockAsync = true;
+		}else{
+			var tmpUrl = url;
+			if(query != "") {
+				tmpUrl += (tmpUrl.indexOf("?") > -1 ? "&" : "?") + query;
 			}
-			if (kwArgs.method.toLowerCase() == "post") {
-				if (!kwArgs.user) {
-					http.open("POST", url, async);
-				} else {
-					http.open("POST", url, async, kwArgs.user, kwArgs.password);
+			if(preventCache) {
+				tmpUrl += (dojo.string.endsWithAny(tmpUrl, "?", "&")
+					? "" : (tmpUrl.indexOf("?") > -1 ? "&" : "?")) + "dojo.preventCache=" + new Date().valueOf();
+			}
+			http.open(kwArgs.method.toUpperCase(), tmpUrl, async);
+			setHeaders(http, kwArgs);
+			try {
+				http.send(null);
+			}catch(e)	{
+				if(typeof http.abort == "function"){
+					http.abort();
 				}
-				setHeaders(http, kwArgs);
-				http.setRequestHeader("Content-Type", kwArgs.multipart ? ("multipart/form-data; boundary=" + this.multipartBoundary) : (kwArgs.contentType || "application/x-www-form-urlencoded"));
-				try {
-					http.send(query);
-				}
-				catch (e) {
-					if (typeof http.abort == "function") {
-						http.abort();
-					}
-					doLoad(kwArgs, {status:404}, url, query, useCache);
-				}
-			} else {
-				var tmpUrl = url;
-				if (query != "") {
-					tmpUrl += (tmpUrl.indexOf("?") > -1 ? "&" : "?") + query;
-				}
-				if (preventCache) {
-					tmpUrl += (dojo.string.endsWithAny(tmpUrl, "?", "&") ? "" : (tmpUrl.indexOf("?") > -1 ? "&" : "?")) + "dojo.preventCache=" + new Date().valueOf();
-				}
-				if (!kwArgs.user) {
-					http.open(kwArgs.method.toUpperCase(), tmpUrl, async);
-				} else {
-					http.open(kwArgs.method.toUpperCase(), tmpUrl, async, kwArgs.user, kwArgs.password);
-				}
-				setHeaders(http, kwArgs);
-				try {
-					http.send(null);
-				}
-				catch (e) {
-					if (typeof http.abort == "function") {
-						http.abort();
-					}
-					doLoad(kwArgs, {status:404}, url, query, useCache);
-				}
+				doLoad(kwArgs, {status: 404}, url, query, useCache);
 			}
-			if (!async) {
-				doLoad(kwArgs, http, url, query, useCache);
-				_this._blockAsync = false;
-			}
-			kwArgs.abort = function () {
-				try {
-					http._aborted = true;
-				}
-				catch (e) {
-				}
-				return http.abort();
-			};
-			return;
-		};
-		dojo.io.transports.addTransport("XMLHTTPTransport");
-	};
+		}
+
+		if( !async ) {
+			doLoad(kwArgs, http, url, query, useCache);
+		}
+
+		kwArgs.abort = function(){
+			return http.abort();
+		}
+
+		return;
+	}
+	dojo.io.transports.addTransport("XMLHTTPTransport");
 }
-

Modified: tags/parley-0.53/root/static/magic/src/io/IframeIO.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/IframeIO.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/IframeIO.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,207 +8,246 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.io.IframeIO");
 dojo.require("dojo.io.BrowserIO");
 dojo.require("dojo.uri.*");
-dojo.io.createIFrame = function (fname, onloadstr, uri) {
-	if (window[fname]) {
-		return window[fname];
-	}
-	if (window.frames[fname]) {
-		return window.frames[fname];
-	}
+
+// FIXME: is it possible to use the Google htmlfile hack to prevent the
+// background click with this transport?
+
+dojo.io.createIFrame = function(fname, onloadstr){
+	if(window[fname]){ return window[fname]; }
+	if(window.frames[fname]){ return window.frames[fname]; }
 	var r = dojo.render.html;
 	var cframe = null;
-	var turi = uri;
-	if (!turi) {
-		if (djConfig["useXDomain"] && !djConfig["dojoIframeHistoryUrl"]) {
-			dojo.debug("dojo.io.createIFrame: When using cross-domain Dojo builds," + " please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl" + " to the path on your domain to iframe_history.html");
-		}
-		turi = (djConfig["dojoIframeHistoryUrl"] || dojo.uri.moduleUri("dojo", "../iframe_history.html")) + "#noInit=true";
-	}
-	var ifrstr = ((r.ie) && (dojo.render.os.win)) ? "<iframe name=\"" + fname + "\" src=\"" + turi + "\" onload=\"" + onloadstr + "\">" : "iframe";
+	var turi = dojo.uri.dojoUri("iframe_history.html?noInit=true");
+	var ifrstr = ((r.ie)&&(dojo.render.os.win)) ? "<iframe name='"+fname+"' src='"+turi+"' onload='"+onloadstr+"'>" : "iframe";
 	cframe = document.createElement(ifrstr);
-	with (cframe) {
+	with(cframe){
 		name = fname;
 		setAttribute("name", fname);
 		id = fname;
 	}
-	dojo.body().appendChild(cframe);
+	(document.body||document.getElementsByTagName("body")[0]).appendChild(cframe);
 	window[fname] = cframe;
-	with (cframe.style) {
-		if (!r.safari) {
-			position = "absolute";
-		}
+	with(cframe.style){
+		position = "absolute";
 		left = top = "0px";
 		height = width = "1px";
 		visibility = "hidden";
+		/*
+		if(djConfig.isDebug){
+			position = "relative";
+			height = "300px";
+			width = "600px";
+			visibility = "visible";
+		}
+		*/
 	}
-	if (!r.ie) {
+
+	if(!r.ie){
 		dojo.io.setIFrameSrc(cframe, turi, true);
 		cframe.onload = new Function(onloadstr);
 	}
 	return cframe;
-};
-dojo.io.IframeTransport = new function () {
+}
+
+// thanks burstlib!
+dojo.io.iframeContentWindow = function(iframe_el) {
+	var win = iframe_el.contentWindow || // IE
+		dojo.io.iframeContentDocument(iframe_el).defaultView || // Moz, opera
+		// Moz. TODO: is this available when defaultView isn't?
+		dojo.io.iframeContentDocument(iframe_el).__parent__ || 
+		(iframe_el.name && document.frames[iframe_el.name]) || null;
+	return win;
+}
+
+dojo.io.iframeContentDocument = function(iframe_el){
+	var doc = iframe_el.contentDocument || // W3
+		(
+			(iframe_el.contentWindow)&&(iframe_el.contentWindow.document)
+		) ||  // IE
+		(
+			(iframe_el.name)&&(document.frames[iframe_el.name])&&
+			(document.frames[iframe_el.name].document)
+		) || null;
+	return doc;
+}
+
+dojo.io.IframeTransport = new function(){
 	var _this = this;
 	this.currentRequest = null;
 	this.requestQueue = [];
 	this.iframeName = "dojoIoIframe";
-	this.fireNextRequest = function () {
-		try {
-			if ((this.currentRequest) || (this.requestQueue.length == 0)) {
-				return;
-			}
-			var cr = this.currentRequest = this.requestQueue.shift();
-			cr._contentToClean = [];
-			var fn = cr["formNode"];
-			var content = cr["content"] || {};
-			if (cr.sendTransport) {
-				content["dojo.transport"] = "iframe";
-			}
-			if (fn) {
-				if (content) {
-					for (var x in content) {
-						if (!fn[x]) {
-							var tn;
-							if (dojo.render.html.ie) {
-								tn = document.createElement("<input type='hidden' name='" + x + "' value='" + content[x] + "'>");
-								fn.appendChild(tn);
-							} else {
-								tn = document.createElement("input");
-								fn.appendChild(tn);
-								tn.type = "hidden";
-								tn.name = x;
-								tn.value = content[x];
-							}
-							cr._contentToClean.push(x);
-						} else {
-							fn[x].value = content[x];
+
+	this.fireNextRequest = function(){
+		if((this.currentRequest)||(this.requestQueue.length == 0)){ return; }
+		// dojo.debug("fireNextRequest");
+		var cr = this.currentRequest = this.requestQueue.shift();
+		cr._contentToClean = [];
+		var fn = cr["formNode"];
+		var content = cr["content"] || {};
+		if(cr.sendTransport) {
+			content["dojo.transport"] = "iframe";
+		}
+		if(fn){
+			if(content){
+				// if we have things in content, we need to add them to the form
+				// before submission
+				for(var x in content){
+					if(!fn[x]){
+						var tn;
+						if(dojo.render.html.ie){
+							tn = document.createElement("<input type='hidden' name='"+x+"' value='"+content[x]+"'>");
+							fn.appendChild(tn);
+						}else{
+							tn = document.createElement("input");
+							fn.appendChild(tn);
+							tn.type = "hidden";
+							tn.name = x;
+							tn.value = content[x];
 						}
+						cr._contentToClean.push(x);
+					}else{
+						fn[x].value = content[x];
 					}
 				}
-				if (cr["url"]) {
-					cr._originalAction = fn.getAttribute("action");
-					fn.setAttribute("action", cr.url);
-				}
-				if (!fn.getAttribute("method")) {
-					fn.setAttribute("method", (cr["method"]) ? cr["method"] : "post");
-				}
-				cr._originalTarget = fn.getAttribute("target");
-				fn.setAttribute("target", this.iframeName);
-				fn.target = this.iframeName;
-				fn.submit();
-			} else {
-				var query = dojo.io.argsFromMap(this.currentRequest.content);
-				var tmpUrl = cr.url + (cr.url.indexOf("?") > -1 ? "&" : "?") + query;
-				dojo.io.setIFrameSrc(this.iframe, tmpUrl, true);
 			}
+			if(cr["url"]){
+				cr._originalAction = fn.getAttribute("action");
+				fn.setAttribute("action", cr.url);
+			}
+			if(!fn.getAttribute("method")){
+				fn.setAttribute("method", (cr["method"]) ? cr["method"] : "post");
+			}
+			cr._originalTarget = fn.getAttribute("target");
+			fn.setAttribute("target", this.iframeName);
+			fn.target = this.iframeName;
+			fn.submit();
+		}else{
+			// otherwise we post a GET string by changing URL location for the
+			// iframe
+			var query = dojo.io.argsFromMap(this.currentRequest.content);
+			var tmpUrl = (cr.url.indexOf("?") > -1 ? "&" : "?") + query;
+			dojo.io.setIFrameSrc(this.iframe, tmpUrl, true);
 		}
-		catch (e) {
-			this.iframeOnload(e);
-		}
-	};
-	this.canHandle = function (kwArgs) {
-		return ((dojo.lang.inArray(["text/plain", "text/html", "text/javascript", "text/json", "application/json"], kwArgs["mimetype"])) && (dojo.lang.inArray(["post", "get"], kwArgs["method"].toLowerCase())) && (!((kwArgs["sync"]) && (kwArgs["sync"] == true))));
-	};
-	this.bind = function (kwArgs) {
-		if (!this["iframe"]) {
-			this.setUpIframe();
-		}
+	}
+
+	this.canHandle = function(kwArgs){
+		return (
+			(
+				// FIXME: can we really handle text/plain and
+				// text/javascript requests?
+				dojo.lang.inArray(kwArgs["mimetype"], 
+				[	"text/plain", "text/html", 
+					"text/javascript", "text/json"])
+			)&&(
+				// make sur we really only get used in file upload cases	
+				(kwArgs["formNode"])&&(dojo.io.checkChildrenForFile(kwArgs["formNode"]))
+			)&&(
+				dojo.lang.inArray(kwArgs["method"].toLowerCase(), ["post", "get"])
+			)&&(
+				// never handle a sync request
+				!  ((kwArgs["sync"])&&(kwArgs["sync"] == true))
+			)
+		);
+	}
+
+	this.bind = function(kwArgs){
+		if(!this["iframe"]){ this.setUpIframe(); }
 		this.requestQueue.push(kwArgs);
 		this.fireNextRequest();
 		return;
-	};
-	this.setUpIframe = function () {
+	}
+
+	this.setUpIframe = function(){
+
+		// NOTE: IE 5.0 and earlier Mozilla's don't support an onload event for
+		//       iframes. OTOH, we don't care.
 		this.iframe = dojo.io.createIFrame(this.iframeName, "dojo.io.IframeTransport.iframeOnload();");
-	};
-	this.iframeOnload = function (errorObject) {
-		if (!_this.currentRequest) {
+	}
+
+	this.iframeOnload = function(){
+		if(!_this.currentRequest){
 			_this.fireNextRequest();
 			return;
 		}
+
 		var req = _this.currentRequest;
-		if (req.formNode) {
-			var toClean = req._contentToClean;
-			for (var i = 0; i < toClean.length; i++) {
-				var key = toClean[i];
-				if (dojo.render.html.safari) {
-					var fNode = req.formNode;
-					for (var j = 0; j < fNode.childNodes.length; j++) {
-						var chNode = fNode.childNodes[j];
-						if (chNode.name == key) {
-							var pNode = chNode.parentNode;
-							pNode.removeChild(chNode);
-							break;
-						}
+
+		// remove all the hidden content inputs
+		var toClean = req._contentToClean;
+		for(var i = 0; i < toClean.length; i++) {
+			var key = toClean[i];
+			if(dojo.render.html.safari){
+				//In Safari (at least 2.0.3), can't use formNode[key] syntax to find the node,
+				//for nodes that were dynamically added.
+				var fNode = req.formNode;
+				for(var j = 0; j < fNode.childNodes.length; j++){
+					var chNode = fNode.childNodes[j];
+					if(chNode.name == key){
+						var pNode = chNode.parentNode;
+						pNode.removeChild(chNode);
+						break;
 					}
-				} else {
-					var input = req.formNode[key];
-					req.formNode.removeChild(input);
-					req.formNode[key] = null;
 				}
+			}else{
+				var input = req.formNode[key];
+				req.formNode.removeChild(input);
+				req.formNode[key] = null;
 			}
-			if (req["_originalAction"]) {
-				req.formNode.setAttribute("action", req._originalAction);
-			}
-			if (req["_originalTarget"]) {
-				req.formNode.setAttribute("target", req._originalTarget);
-				req.formNode.target = req._originalTarget;
-			}
 		}
-		var contentDoc = function (iframe_el) {
-			var doc = iframe_el.contentDocument || ((iframe_el.contentWindow) && (iframe_el.contentWindow.document)) || ((iframe_el.name) && (document.frames[iframe_el.name]) && (document.frames[iframe_el.name].document)) || null;
-			return doc;
-		};
+
+		// restore original action + target
+		if(req["_originalAction"]){
+			req.formNode.setAttribute("action", req._originalAction);
+		}
+		req.formNode.setAttribute("target", req._originalTarget);
+		req.formNode.target = req._originalTarget;
+
+		var ifd = dojo.io.iframeContentDocument(_this.iframe);
+		// handle successful returns
+		// FIXME: how do we determine success for iframes? Is there an equiv of
+		// the "status" property?
 		var value;
 		var success = false;
-		if (errorObject) {
-			this._callError(req, "IframeTransport Request Error: " + errorObject);
-		} else {
-			var ifd = contentDoc(_this.iframe);
-			try {
-				var cmt = req.mimetype;
-				if ((cmt == "text/javascript") || (cmt == "text/json") || (cmt == "application/json")) {
-					var js = ifd.getElementsByTagName("textarea")[0].value;
-					if (cmt == "text/json" || cmt == "application/json") {
-						js = "(" + js + ")";
-					}
-					value = dj_eval(js);
-				} else {
-					if (cmt == "text/html") {
-						value = ifd;
-					} else {
-						value = ifd.getElementsByTagName("textarea")[0].value;
-					}
-				}
-				success = true;
+
+		try{
+			var cmt = req.mimetype;
+			if((cmt == "text/javascript")||(cmt == "text/json")){
+				// FIXME: not sure what to do here? try to pull some evalulable
+				// text from a textarea or cdata section? 
+				// how should we set up the contract for that?
+				var js = ifd.getElementsByTagName("textarea")[0].value;
+				if(cmt == "text/json") { js = "(" + js + ")"; }
+				value = dj_eval(js);
+			}else if(cmt == "text/html"){
+				value = ifd;
+			}else{ // text/plain
+				value = ifd.getElementsByTagName("textarea")[0].value;
 			}
-			catch (e) {
-				this._callError(req, "IframeTransport Error: " + e);
+			success = true;
+		}catch(e){ 
+			// looks like we didn't get what we wanted!
+			var errObj = new dojo.io.Error("IframeTransport Error");
+			if(dojo.lang.isFunction(req["error"])){
+				req.error("error", errObj, req);
 			}
 		}
+
+		// don't want to mix load function errors with processing errors, thus
+		// a separate try..catch
 		try {
-			if (success && dojo.lang.isFunction(req["load"])) {
+			if(success && dojo.lang.isFunction(req["load"])){
 				req.load("load", value, req);
 			}
-		}
-		catch (e) {
+		} catch(e) {
 			throw e;
-		}
-		finally {
+		} finally {
 			_this.currentRequest = null;
 			_this.fireNextRequest();
 		}
-	};
-	this._callError = function (req, message) {
-		var errObj = new dojo.io.Error(message);
-		if (dojo.lang.isFunction(req["error"])) {
-			req.error("error", errObj, req);
-		}
-	};
+	}
+
 	dojo.io.transports.addTransport("IframeTransport");
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/io/RepubsubIO.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/RepubsubIO.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/RepubsubIO.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,44 +1,69 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
+//	Copyright (c) 2004 Friendster Inc., Licensed under the Academic Free
+//	License version 2.0 or later 
 
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
+dojo.require("dojo.event.Event");
+dojo.require("dojo.event.BrowserEvent");
+dojo.require("dojo.io.BrowserIO");
 
-		http://dojotoolkit.org/community/licensing.shtml
-*/
+dojo.provide("dojo.io.RepubsubIO");
+dojo.provide("dojo.io.repubsub");
+dojo.provide("dojo.io.repubsubTransport");
 
-
-
-dojo.require("dojo.event.*");
-dojo.require("dojo.io.BrowserIO");
-dojo.provide("dojo.io.RepubsubIO");
-dojo.io.repubsubTranport = new function () {
+dojo.io.repubsubTranport = new function(){
 	var rps = dojo.io.repubsub;
-	this.canHandle = function (kwArgs) {
-		if ((kwArgs["mimetype"] == "text/javascript") && (kwArgs["method"] == "repubsub")) {
+	this.canHandle = function(kwArgs){
+		if((kwArgs["mimetype"] == "text/javascript")&&(kwArgs["method"] == "repubsub")){
 			return true;
 		}
 		return false;
-	};
-	this.bind = function (kwArgs) {
-		if (!rps.isInitialized) {
+	}
+
+	this.bind = function(kwArgs){
+		if(!rps.isInitialized){
+			// open up our tunnel, queue up requests anyway
 			rps.init();
 		}
-		if (!rps.topics[kwArgs.url]) {
-			kwArgs.rpsLoad = function (evt) {
+		// FIXME: we need to turn this into a topic subscription
+		// var tgtURL = kwArgs.url+"?"+dojo.io.argsFromMap(kwArgs.content);
+		// sampleTransport.sendRequest(tgtURL, hdlrFunc);
+
+		// a normal "bind()" call in a request-response transport layer is
+		// something that (usually) encodes most of it's payload with the
+		// request. Multi-event systems like repubsub are a bit more complex,
+		// and repubsub in particular distinguishes the publish and subscribe
+		// portions of thep rocess with different method calls to handle each.
+		// Therefore, a "bind" in the sense of repubsub must first determine if
+		// we have an open subscription to a channel provided by the server,
+		// and then "publish" the request payload if there is any. We therefore
+		// must take care not to incorrectly or too agressively register or
+		// file event handlers which are provided with the kwArgs method.
+
+		// NOTE: we ONLY pay attention to those event handlers that are
+		// registered with the bind request that subscribes to the channel. If
+		// event handlers are provided with subsequent requests, we might in
+		// the future support some additive or replacement syntax, but for now
+		// they get dropped on the floor.
+
+		// NOTE: in this case, url MUST be the "topic" to which we
+		// subscribe/publish for this channel
+		if(!rps.topics[kwArgs.url]){
+			kwArgs.rpsLoad = function(evt){
 				kwArgs.load("load", evt);
-			};
+			}
 			rps.subscribe(kwArgs.url, kwArgs, "rpsLoad");
 		}
-		if (kwArgs["content"]) {
+
+		if(kwArgs["content"]){
+			// what we wanted to send
 			var cEvt = dojo.io.repubsubEvent.initFromProperties(kwArgs.content);
 			rps.publish(kwArgs.url, cEvt);
 		}
-	};
+	}
+
 	dojo.io.transports.addTransport("repubsubTranport");
-};
-dojo.io.repubsub = new function () {
+}
+
+dojo.io.repubsub = new function(){
 	this.initDoc = "init.html";
 	this.isInitialized = false;
 	this.subscriptionBacklog = [];
@@ -55,283 +80,438 @@
 	this.backlog = [];
 	this.tunnelInitCount = 0;
 	this.tunnelFrameKey = "tunnel_frame";
-	this.serverBaseURL = location.protocol + "//" + location.host + location.pathname;
+	this.serverBaseURL = location.protocol+"//"+location.host+location.pathname;
 	this.logBacklog = [];
-	this.getRandStr = function () {
+	this.getRandStr = function(){
 		return Math.random().toString().substring(2, 10);
-	};
+	}
 	this.userid = "guest";
 	this.tunnelID = this.getRandStr();
 	this.attachPathList = [];
-	this.topics = [];
-	this.parseGetStr = function () {
+	this.topics = []; // list of topics we have listeners to
+
+	// actually, now that I think about it a little bit more, it would sure be
+	// useful to parse out the <script> src attributes. We're looking for
+	// something with a "do_method=lib", since that's what would have included
+	// us in the first place (in the common case).
+	this.parseGetStr = function(){
 		var baseUrl = document.location.toString();
 		var params = baseUrl.split("?", 2);
-		if (params.length > 1) {
+		if(params.length > 1){
 			var paramStr = params[1];
 			var pairs = paramStr.split("&");
 			var opts = [];
-			for (var x in pairs) {
+			for(var x in pairs){
 				var sp = pairs[x].split("=");
-				try {
-					opts[sp[0]] = eval(sp[1]);
+				// FIXME: is this eval dangerous?
+				try{
+					opts[sp[0]]=eval(sp[1]);
+				}catch(e){
+					opts[sp[0]]=sp[1];
 				}
-				catch (e) {
-					opts[sp[0]] = sp[1];
-				}
 			}
 			return opts;
-		} else {
+		}else{
 			return [];
 		}
-	};
+	}
+
+	// parse URL params and use them as default vals
 	var getOpts = this.parseGetStr();
-	for (var x in getOpts) {
+	for(var x in getOpts){
+		// FIXME: should I be checking for undefined here before setting? Does
+		//        that buy me anything?
 		this[x] = getOpts[x];
 	}
-	if (!this["tunnelURI"]) {
-		this.tunnelURI = ["/who/", escape(this.userid), "/s/", this.getRandStr(), "/kn_journal"].join("");
+
+	if(!this["tunnelURI"]){
+		this.tunnelURI = [	"/who/", escape(this.userid), "/s/", 
+							this.getRandStr(), "/kn_journal"].join("");
+		// this.tunnelURI = this.absoluteTopicURI(this.tunnelURI);
 	}
-	if (window["repubsubOpts"] || window["rpsOpts"]) {
-		var optObj = window["repubsubOpts"] || window["rpsOpts"];
-		for (var x in optObj) {
-			this[x] = optObj[x];
+
+	/*
+	if (self.kn_tunnelID) kn.tunnelID = self.kn_tunnelID; // the server says
+	if (kn._argv.kn_tunnelID) kn.tunnelID = kn._argv.kn_tunnelID; // the url says
+	*/
+
+	// check the options object if it exists and use its properties as an
+	// over-ride
+	if(window["repubsubOpts"]||window["rpsOpts"]){
+		var optObj = window["repubsubOpts"]||window["rpsOpts"];
+		for(var x in optObj){
+			this[x] = optObj[x]; // copy the option object properties
 		}
 	}
-	this.tunnelCloseCallback = function () {
-		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc + "?callback=repubsub.rcvNodeReady&domain=" + document.domain);
-	};
-	this.receiveEventFromTunnel = function (evt, srcWindow) {
-		if (!evt["elements"]) {
+
+	// things that get called directly from our iframe to inform us of events
+	this.tunnelCloseCallback = function(){
+		// when we get this callback, we should immediately attempt to re-start
+		// our tunnel connection
+		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc+"?callback=repubsub.rcvNodeReady&domain="+document.domain);
+	}
+
+	this.receiveEventFromTunnel = function(evt, srcWindow){
+		// we should never be getting events from windows we didn't create
+		// NOTE: events sourced from the local window are also supported for
+		// 		 debugging purposes
+
+		// any event object MUST have a an "elements" property
+		if(!evt["elements"]){
 			this.log("bailing! event received without elements!", "error");
 			return;
 		}
+
+		// if the event passes some minimal sanity tests, we need to attempt to
+		// dispatch it!
+
+		// first, it seems we have to munge the event object a bit
 		var e = {};
-		for (var i = 0; i < evt.elements.length; i++) {
+		for(var i=0; i<evt.elements.length; i++){
 			var ee = evt.elements[i];
-			e[ee.name || ee.nameU] = (ee.value || ee.valueU);
-			this.log("[event]: " + (ee.name || ee.nameU) + ": " + e[ee.name || ee.nameU]);
+			e[ee.name||ee.nameU] = (ee.value||ee.valueU);
+			// FIXME: need to enable this only in some extreme debugging mode!
+			this.log("[event]: "+(ee.name||ee.nameU)+": "+e[ee.name||ee.nameU]);
 		}
+
+		// NOTE: the previous version of this library put a bunch of code here
+		// to manage state that tried to make sure that we never, ever, lost
+		// any info about an event. If we unload RIGHT HERE, I don't think it's
+		// going to make a huge difference one way or another. Time will tell.
+
+		// and with THAT out of the way, dispatch it!
 		this.dispatch(e);
-	};
-	this.widenDomain = function (domainStr) {
-		var cd = domainStr || document.domain;
-		if (cd.indexOf(".") == -1) {
-			return;
-		}
+
+		// TODO: remove the script block that created the event obj to save
+		// memory, etc.
+	}
+
+	this.widenDomain = function(domainStr){
+		// the purpose of this is to set the most liberal domain policy
+		// available
+		var cd = domainStr||document.domain;
+		if(cd.indexOf(".")==-1){ return; } // probably file:/// or localhost
 		var dps = cd.split(".");
-		if (dps.length <= 2) {
-			return;
-		}
-		dps = dps.slice(dps.length - 2);
+		if(dps.length<=2){ return; } // probably file:/// or an RFC 1918 address
+		dps = dps.slice(dps.length-2);
 		document.domain = dps.join(".");
-	};
-	this.parseCookie = function () {
+	}
+
+	// FIXME: parseCookie and setCookie should be methods that are more broadly
+	// available. Perhaps in htmlUtils?
+
+	this.parseCookie = function(){
 		var cs = document.cookie;
 		var keypairs = cs.split(";");
-		for (var x = 0; x < keypairs.length; x++) {
+		for(var x=0; x<keypairs.length; x++){
 			keypairs[x] = keypairs[x].split("=");
-			if (x != keypairs.length - 1) {
-				cs += ";";
-			}
+			if(x!=keypairs.length-1){ cs+=";"; }
 		}
 		return keypairs;
-	};
-	this.setCookie = function (keypairs, clobber) {
-		if ((clobber) && (clobber == true)) {
-			document.cookie = "";
-		}
+	}
+
+	this.setCookie = function(keypairs, clobber){
+		// NOTE: we want to only ever set session cookies, so never provide an
+		// 		 expires date
+		if((clobber)&&(clobber==true)){ document.cookie = ""; }
 		var cs = "";
-		for (var x = 0; x < keypairs.length; x++) {
-			cs += keypairs[x][0] + "=" + keypairs[x][1];
-			if (x != keypairs.length - 1) {
-				cs += ";";
-			}
+		for(var x=0; x<keypairs.length; x++){
+			cs += keypairs[x][0]+"="+keypairs[x][1];
+			if(x!=keypairs.length-1){ cs+=";"; }
 		}
 		document.cookie = cs;
-	};
-	this.log = function (str, lvl) {
-		if (!this.debug) {
-			return;
-		}
-		while (this.logBacklog.length > 0) {
-			if (!this.canLog) {
-				break;
-			}
+	}
+
+	// FIXME: need to replace w/ dojo.log.*
+	this.log = function(str, lvl){
+		if(!this.debug){ return; } // we of course only care if we're in debug mode
+		while(this.logBacklog.length>0){
+			if(!this.canLog){ break; }
 			var blo = this.logBacklog.shift();
-			this.writeLog("[" + blo[0] + "]: " + blo[1], blo[2]);
+			this.writeLog("["+blo[0]+"]: "+blo[1], blo[2]);
 		}
 		this.writeLog(str, lvl);
-	};
-	this.writeLog = function (str, lvl) {
-		dojo.debug(((new Date()).toLocaleTimeString()) + ": " + str);
-	};
-	this.init = function () {
+	}
+
+	this.writeLog = function(str, lvl){
+		dojo.debug(((new Date()).toLocaleTimeString())+": "+str);
+	}
+
+	this.init = function(){
 		this.widenDomain();
+		// this.findPeers();
 		this.openTunnel();
 		this.isInitialized = true;
-		while (this.subscriptionBacklog.length) {
+		// FIXME: this seems like entirely the wrong place to replay the backlog
+		while(this.subscriptionBacklog.length){
 			this.subscribe.apply(this, this.subscriptionBacklog.shift());
 		}
-	};
-	this.clobber = function () {
-		if (this.rcvNode) {
-			this.setCookie([[this.tunnelFrameKey, "closed"], ["path", "/"]], false);
+	}
+
+	this.clobber = function(){
+		if(this.rcvNode){
+			this.setCookie( [
+					[this.tunnelFrameKey,"closed"],
+					["path","/"]
+				], false 
+			);
 		}
-	};
-	this.openTunnel = function () {
-		this.rcvNodeName = "rcvIFrame_" + this.getRandStr();
-		this.setCookie([[this.tunnelFrameKey, this.rcvNodeName], ["path", "/"]], false);
+	}
+
+	this.openTunnel = function(){
+		// We create two iframes here:
+
+		// one for getting data
+		this.rcvNodeName = "rcvIFrame_"+this.getRandStr();
+		// set cookie that can be used to find the receiving iframe
+		this.setCookie( [
+				[this.tunnelFrameKey,this.rcvNodeName],
+				["path","/"]
+			], false
+		);
+
 		this.rcvNode = dojo.io.createIFrame(this.rcvNodeName);
-		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc + "?callback=repubsub.rcvNodeReady&domain=" + document.domain);
-		this.sndNodeName = "sndIFrame_" + this.getRandStr();
+		// FIXME: set the src attribute here to the initialization URL
+		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc+"?callback=repubsub.rcvNodeReady&domain="+document.domain);
+
+		// the other for posting data in reply
+
+		this.sndNodeName = "sndIFrame_"+this.getRandStr();
 		this.sndNode = dojo.io.createIFrame(this.sndNodeName);
-		dojo.io.setIFrameSrc(this.sndNode, this.initDoc + "?callback=repubsub.sndNodeReady&domain=" + document.domain);
-	};
-	this.rcvNodeReady = function () {
-		var statusURI = [this.tunnelURI, "/kn_status/", this.getRandStr(), "_", String(this.tunnelInitCount++)].join("");
+		// FIXME: set the src attribute here to the initialization URL
+		dojo.io.setIFrameSrc(this.sndNode, this.initDoc+"?callback=repubsub.sndNodeReady&domain="+document.domain);
+
+	}
+
+	this.rcvNodeReady = function(){
+		// FIXME: why is this sequence number needed? Why isn't the UID gen
+		// 		  function enough?
+        var statusURI = [this.tunnelURI, '/kn_status/', this.getRandStr(), '_', 
+						 String(this.tunnelInitCount++)].join(""); 
+            // (kn._seqNum++); // FIXME: !!!!
+		// this.canRcv = true;
 		this.log("rcvNodeReady");
-		var initURIArr = [this.serverBaseURL, "/kn?kn_from=", escape(this.tunnelURI), "&kn_id=", escape(this.tunnelID), "&kn_status_from=", escape(statusURI)];
+		// FIXME: initialize receiver and request the base topic
+		// dojo.io.setIFrameSrc(this.rcvNode, this.serverBaseURL+"/kn?do_method=blank");
+		var initURIArr = [	this.serverBaseURL, "/kn?kn_from=", escape(this.tunnelURI),
+							"&kn_id=", escape(this.tunnelID), "&kn_status_from=", 
+							escape(statusURI)];
+		// FIXME: does the above really need a kn_response_flush? won't the
+		// 		  server already know? If not, what good is it anyway?
 		dojo.io.setIFrameSrc(this.rcvNode, initURIArr.join(""));
+
+		// setup a status path listener, but don't tell the server about it,
+		// since it already knows we're itnerested in our own tunnel status
 		this.subscribe(statusURI, this, "statusListener", true);
+
 		this.log(initURIArr.join(""));
-	};
-	this.sndNodeReady = function () {
+	}
+
+	this.sndNodeReady = function(){
 		this.canSnd = true;
 		this.log("sndNodeReady");
 		this.log(this.backlog.length);
-		if (this.backlog.length > 0) {
+		// FIXME: handle any pent-up send commands
+		if(this.backlog.length > 0){
 			this.dequeueEvent();
 		}
-	};
-	this.statusListener = function (evt) {
+	}
+
+	this.statusListener = function(evt){
 		this.log("status listener called");
 		this.log(evt.status, "info");
-	};
-	this.dispatch = function (evt) {
-		if (evt["to"] || evt["kn_routed_from"]) {
-			var rf = evt["to"] || evt["kn_routed_from"];
+	}
+
+	// this handles local event propigation
+	this.dispatch = function(evt){
+		// figure out what topic it came from
+		if(evt["to"]||evt["kn_routed_from"]){
+			var rf = evt["to"]||evt["kn_routed_from"];
+			// split off the base server URL
 			var topic = rf.split(this.serverBaseURL, 2)[1];
-			if (!topic) {
+			if(!topic){
+				// FIXME: how do we recover when we don't get a sane "from"? Do
+				// we try to route to it anyway?
 				topic = rf;
 			}
-			this.log("[topic] " + topic);
-			if (topic.length > 3) {
-				if (topic.slice(0, 3) == "/kn") {
+			this.log("[topic] "+topic);
+			if(topic.length>3){
+				if(topic.slice(0, 3)=="/kn"){
 					topic = topic.slice(3);
 				}
 			}
-			if (this.attachPathList[topic]) {
+			if(this.attachPathList[topic]){
 				this.attachPathList[topic](evt);
 			}
 		}
-	};
-	this.subscribe = function (topic, toObj, toFunc, dontTellServer) {
-		if (!this.isInitialized) {
+	}
+
+	this.subscribe = function(	topic /* kn_from in the old terminilogy */, 
+								toObj, toFunc, dontTellServer){
+		if(!this.isInitialized){
 			this.subscriptionBacklog.push([topic, toObj, toFunc, dontTellServer]);
 			return;
 		}
-		if (!this.attachPathList[topic]) {
-			this.attachPathList[topic] = function () {
-				return true;
-			};
-			this.log("subscribing to: " + topic);
+		if(!this.attachPathList[topic]){
+			this.attachPathList[topic] = function(){ return true; }
+			this.log("subscribing to: "+topic);
 			this.topics.push(topic);
 		}
 		var revt = new dojo.io.repubsubEvent(this.tunnelURI, topic, "route");
-		var rstr = [this.serverBaseURL + "/kn", revt.toGetString()].join("");
-		dojo.event.kwConnect({once:true, srcObj:this.attachPathList, srcFunc:topic, adviceObj:toObj, adviceFunc:toFunc});
-		if (!this.rcvNode) {
-		}
-		if (dontTellServer) {
+		var rstr = [this.serverBaseURL+"/kn", revt.toGetString()].join("");
+		dojo.event.kwConnect({
+			once: true,
+			srcObj: this.attachPathList, 
+			srcFunc: topic, 
+			adviceObj: toObj, 
+			adviceFunc: toFunc
+		});
+		// NOTE: the above is a local mapping, if we're not the leader, we
+		// 		 should connect our mapping to the topic handler of the peer
+		// 		 leader, this ensures that not matter what happens to the
+		// 		 leader, we don't really loose our heads if/when the leader
+		// 		 goes away.
+		if(!this.rcvNode){ /* this should be an error! */ }
+		if(dontTellServer){
 			return;
 		}
-		this.log("sending subscription to: " + topic);
+		this.log("sending subscription to: "+topic);
+		// create a subscription event object and give it all the props we need
+		// to updates on the specified topic
+
+		// FIXME: we should only enqueue if this is our first subscription!
 		this.sendTopicSubToServer(topic, rstr);
-	};
-	this.sendTopicSubToServer = function (topic, str) {
-		if (!this.attachPathList[topic]["subscriptions"]) {
+	}
+
+	this.sendTopicSubToServer = function(topic, str){
+		if(!this.attachPathList[topic]["subscriptions"]){
 			this.enqueueEventStr(str);
 			this.attachPathList[topic].subscriptions = 0;
 		}
 		this.attachPathList[topic].subscriptions++;
-	};
-	this.unSubscribe = function (topic, toObj, toFunc) {
-		dojo.event.kwDisconnect({srcObj:this.attachPathList, srcFunc:topic, adviceObj:toObj, adviceFunc:toFunc});
-	};
-	this.publish = function (topic, event) {
+	}
+
+	this.unSubscribe = function(topic, toObj, toFunc){
+		// first, locally disconnect
+		dojo.event.kwDisconnect({
+			srcObj: this.attachPathList, 
+			srcFunc: topic, 
+			adviceObj: toObj, 
+			adviceFunc: toFunc
+		});
+		
+		// FIXME: figure out if there are any remaining listeners to the topic,
+		// 		  and if not, inform the server of our desire not to be
+		// 		  notified of updates to the topic
+	}
+
+	// the "publish" method is really a misnomer, since it really means "take
+	// this event and send it to the server". Note that the "dispatch" method
+	// handles local event promigulation, and therefore we emulate both sides
+	// of a real event router without having to swallow all of the complexity.
+	this.publish = function(topic, event){
 		var evt = dojo.io.repubsubEvent.initFromProperties(event);
+		// FIXME: need to make sure we have from and to set correctly
+		// 		  before we serialize and send off to the great blue
+		// 		  younder.
 		evt.to = topic;
+		// evt.from = this.tunnelURI;
+
 		var evtURLParts = [];
-		evtURLParts.push(this.serverBaseURL + "/kn");
+		evtURLParts.push(this.serverBaseURL+"/kn");
+
+		// serialize the event to a string and then post it to the correct
+		// topic
 		evtURLParts.push(evt.toGetString());
 		this.enqueueEventStr(evtURLParts.join(""));
-	};
-	this.enqueueEventStr = function (evtStr) {
+	}
+
+	this.enqueueEventStr = function(evtStr){
 		this.log("enqueueEventStr");
 		this.backlog.push(evtStr);
 		this.dequeueEvent();
-	};
-	this.dequeueEvent = function (force) {
+	}
+
+	this.dequeueEvent = function(force){
 		this.log("dequeueEvent");
-		if (this.backlog.length <= 0) {
-			return;
-		}
-		if ((this.canSnd) || (force)) {
-			dojo.io.setIFrameSrc(this.sndNode, this.backlog.shift() + "&callback=repubsub.sndNodeReady");
+		if(this.backlog.length <= 0){ return; }
+		if((this.canSnd)||(force)){
+			dojo.io.setIFrameSrc(this.sndNode, this.backlog.shift()+"&callback=repubsub.sndNodeReady");
 			this.canSnd = false;
-		} else {
+		}else{
 			this.log("sndNode not available yet!", "debug");
 		}
-	};
-};
-dojo.io.repubsubEvent = function (to, from, method, id, routeURI, payload, dispname, uid) {
+	}
+}
+
+dojo.io.repubsubEvent = function(to, from, method, id, routeURI, payload, dispname, uid){
 	this.to = to;
 	this.from = from;
-	this.method = method || "route";
-	this.id = id || repubsub.getRandStr();
+	this.method = method||"route";
+	this.id = id||repubsub.getRandStr();
 	this.uri = routeURI;
-	this.displayname = dispname || repubsub.displayname;
-	this.userid = uid || repubsub.userid;
-	this.payload = payload || "";
+	this.displayname = dispname||repubsub.displayname;
+	this.userid = uid||repubsub.userid;
+	this.payload = payload||"";
 	this.flushChars = 4096;
-	this.initFromProperties = function (evt) {
-		if (evt.constructor = dojo.io.repubsubEvent) {
-			for (var x in evt) {
+
+	this.initFromProperties = function(evt){
+		if(evt.constructor = dojo.io.repubsubEvent){ 
+			for(var x in evt){
 				this[x] = evt[x];
 			}
-		} else {
-			for (var x in evt) {
-				if (typeof this.forwardPropertiesMap[x] == "string") {
+		}else{
+			// we want to copy all the properties of the evt object, and transform
+			// those that are "stock" properties of dojo.io.repubsubEvent. All others should
+			// be copied as-is
+			for(var x in evt){
+				if(typeof this.forwardPropertiesMap[x] == "string"){
 					this[this.forwardPropertiesMap[x]] = evt[x];
-				} else {
+				}else{
 					this[x] = evt[x];
 				}
 			}
 		}
-	};
-	this.toGetString = function (noQmark) {
-		var qs = [((noQmark) ? "" : "?")];
-		for (var x = 0; x < this.properties.length; x++) {
+	}
+
+	this.toGetString = function(noQmark){
+		var qs = [ ((noQmark) ? "" : "?") ];
+		for(var x=0; x<this.properties.length; x++){
 			var tp = this.properties[x];
-			if (this[tp[0]]) {
-				qs.push(tp[1] + "=" + encodeURIComponent(String(this[tp[0]])));
+			if(this[tp[0]]){
+				qs.push(tp[1]+"="+encodeURIComponent(String(this[tp[0]])));
 			}
+			// FIXME: we need to be able to serialize non-stock properties!!!
 		}
 		return qs.join("&");
-	};
-};
-dojo.io.repubsubEvent.prototype.properties = [["from", "kn_from"], ["to", "kn_to"], ["method", "do_method"], ["id", "kn_id"], ["uri", "kn_uri"], ["displayname", "kn_displayname"], ["userid", "kn_userid"], ["payload", "kn_payload"], ["flushChars", "kn_response_flush"], ["responseFormat", "kn_response_format"]];
+	}
+
+}
+
+dojo.io.repubsubEvent.prototype.properties = [["from", "kn_from"], ["to", "kn_to"], 
+									["method", "do_method"], ["id", "kn_id"], 
+									["uri", "kn_uri"], 
+									["displayname", "kn_displayname"], 
+									["userid", "kn_userid"], 
+									["payload", "kn_payload"],
+									["flushChars", "kn_response_flush"],
+									["responseFormat", "kn_response_format"] ];
+
+// maps properties from their old names to their new names...
 dojo.io.repubsubEvent.prototype.forwardPropertiesMap = {};
+// ...and vice versa...
 dojo.io.repubsubEvent.prototype.reversePropertiesMap = {};
-for (var x = 0; x < dojo.io.repubsubEvent.prototype.properties.length; x++) {
+
+// and we then populate them both from the properties list
+for(var x=0; x<dojo.io.repubsubEvent.prototype.properties.length; x++){
 	var tp = dojo.io.repubsubEvent.prototype.properties[x];
 	dojo.io.repubsubEvent.prototype.reversePropertiesMap[tp[0]] = tp[1];
 	dojo.io.repubsubEvent.prototype.forwardPropertiesMap[tp[1]] = tp[0];
 }
-dojo.io.repubsubEvent.initFromProperties = function (evt) {
+// static version of initFromProperties, creates new event and object and
+// returns it after init
+dojo.io.repubsubEvent.initFromProperties = function(evt){
 	var eventObj = new dojo.io.repubsubEvent();
 	eventObj.initFromProperties(evt);
 	return eventObj;
-};
-
+}


Property changes on: tags/parley-0.53/root/static/magic/src/io/RepubsubIO.js
___________________________________________________________________
Name: svn:mime-type
   + text/cpp

Modified: tags/parley-0.53/root/static/magic/src/io/RhinoIO.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/RhinoIO.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/RhinoIO.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,109 +8,15 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.io.RhinoIO");
 
+// TODO: this doesn't execute
+/*dojo.io.SyncHTTPRequest = function(){
+	dojo.io.SyncRequest.call(this);
 
-dojo.provide("dojo.io.RhinoIO");
-dojo.require("dojo.io.common");
-dojo.require("dojo.lang.func");
-dojo.require("dojo.lang.array");
-dojo.require("dojo.string.extras");
-dojo.io.RhinoHTTPTransport = new function () {
-	this.canHandle = function (req) {
-		if (dojo.lang.find(["text/plain", "text/html", "text/xml", "text/javascript", "text/json", "application/json"], (req.mimetype.toLowerCase() || "")) < 0) {
-			return false;
-		}
-		if (req.url.substr(0, 7) != "http://") {
-			return false;
-		}
-		return true;
-	};
-	function doLoad(req, conn) {
-		var ret;
-		if (req.method.toLowerCase() == "head") {
-		} else {
-			var stream = conn.getContent();
-			var reader = new java.io.BufferedReader(new java.io.InputStreamReader(stream));
-			var text = "";
-			var line = null;
-			while ((line = reader.readLine()) != null) {
-				text += line;
-			}
-			if (req.mimetype == "text/javascript") {
-				try {
-					ret = dj_eval(text);
-				}
-				catch (e) {
-					dojo.debug(e);
-					dojo.debug(text);
-					ret = null;
-				}
-			} else {
-				if (req.mimetype == "text/json" || req.mimetype == "application/json") {
-					try {
-						ret = dj_eval("(" + text + ")");
-					}
-					catch (e) {
-						dojo.debug(e);
-						dojo.debug(text);
-						ret = false;
-					}
-				} else {
-					ret = text;
-				}
-			}
-		}
-		req.load("load", ret, req);
+	this.send = function(URI){
 	}
-	function connect(req) {
-		var content = req.content || {};
-		var query;
-		if (req.sendTransport) {
-			content["dojo.transport"] = "rhinohttp";
-		}
-		if (req.postContent) {
-			query = req.postContent;
-		} else {
-			query = dojo.io.argsFromMap(content, req.encoding);
-		}
-		var url_text = req.url;
-		if (req.method.toLowerCase() == "get" && query != "") {
-			url_text = url_text + "?" + query;
-		}
-		var url = new java.net.URL(url_text);
-		var conn = url.openConnection();
-		conn.setRequestMethod(req.method.toUpperCase());
-		if (req.headers) {
-			for (var header in req.headers) {
-				if (header.toLowerCase() == "content-type" && !req.contentType) {
-					req.contentType = req.headers[header];
-				} else {
-					conn.setRequestProperty(header, req.headers[header]);
-				}
-			}
-		}
-		if (req.contentType) {
-			conn.setRequestProperty("Content-Type", req.contentType);
-		}
-		if (req.method.toLowerCase() == "post") {
-			conn.setDoOutput(true);
-			var output_stream = conn.getOutputStream();
-			var byte_array = (new java.lang.String(query)).getBytes();
-			output_stream.write(byte_array, 0, byte_array.length);
-		}
-		conn.connect();
-		doLoad(req, conn);
-	}
-	this.bind = function (req) {
-		var async = req["sync"] ? false : true;
-		if (async) {
-			setTimeout(dojo.lang.hitch(this, function () {
-				connect(req);
-			}), 1);
-		} else {
-			connect(req);
-		}
-	};
-	dojo.io.transports.addTransport("RhinoHTTPTransport");
-};
+}
 
+dojo.inherits(dojo.io.SyncHTTPRequest, dojo.io.SyncRequest);
+*/

Modified: tags/parley-0.53/root/static/magic/src/io/ScriptSrcIO.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/ScriptSrcIO.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/ScriptSrcIO.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,310 +8,445 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.io.ScriptSrcIO");
 dojo.require("dojo.io.BrowserIO");
 dojo.require("dojo.undo.browser");
-dojo.io.ScriptSrcTransport = new function () {
-	this.preventCache = false;
-	this.maxUrlLength = 1000;
+
+//FIXME: should constantParams be JS object?
+//FIXME: check dojo.io calls. Can we move the BrowserIO defined calls somewhere
+//       else so that we don't depend on BrowserIO at all? The dependent calls
+//       have to do with dealing with forms and making query params from JS object.
+/**
+ * See test_ScriptSrcIO.html for usage information.
+ * Notes:
+ * - The watchInFlight timer is set to 100 ms instead of 10ms (which is what BrowserIO.js uses).
+ */
+dojo.io.ScriptSrcTransport = new function(){
+	this.preventCache = false; // if this is true, we'll always force GET requests to not cache
+	this.maxUrlLength = 1000; //Used to calculate if script request should be multipart.
 	this.inFlightTimer = null;
-	this.DsrStatusCodes = {Continue:100, Ok:200, Error:500};
-	this.startWatchingInFlight = function () {
-		if (!this.inFlightTimer) {
+
+	this.DsrStatusCodes = {
+		Continue: 100,
+		Ok: 200,
+		Error: 500
+	};
+
+	this.startWatchingInFlight = function(){
+		if(!this.inFlightTimer){
 			this.inFlightTimer = setInterval("dojo.io.ScriptSrcTransport.watchInFlight();", 100);
 		}
-	};
-	this.watchInFlight = function () {
+	}
+
+	this.watchInFlight = function(){
 		var totalCount = 0;
 		var doneCount = 0;
-		for (var param in this._state) {
+		for(var param in this._state){
 			totalCount++;
 			var currentState = this._state[param];
-			if (currentState.isDone) {
+			if(currentState.isDone){
 				doneCount++;
 				delete this._state[param];
-			} else {
-				if (!currentState.isFinishing) {
-					var listener = currentState.kwArgs;
-					try {
-						if (currentState.checkString && eval("typeof(" + currentState.checkString + ") != 'undefined'")) {
-							currentState.isFinishing = true;
-							this._finish(currentState, "load");
+			}else{
+				var listener = currentState.kwArgs;
+				try{
+					if(currentState.checkString && eval("typeof(" + currentState.checkString + ") != 'undefined'")){
+						this._finish(currentState, "load");
+						doneCount++;
+						delete this._state[param];
+					}else if(listener.timeoutSeconds && listener.timeout){
+						if(currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()){
+							this._finish(currentState, "timeout");
 							doneCount++;
 							delete this._state[param];
-						} else {
-							if (listener.timeoutSeconds && listener.timeout) {
-								if (currentState.startTime + (listener.timeoutSeconds * 1000) < (new Date()).getTime()) {
-									currentState.isFinishing = true;
-									this._finish(currentState, "timeout");
-									doneCount++;
-									delete this._state[param];
-								}
-							} else {
-								if (!listener.timeoutSeconds) {
-									doneCount++;
-								}
-							}
 						}
+					}else if(!listener.timeoutSeconds){
+						//Increment the done count if no timeout is specified, so
+						//that we turn off the timer if all that is left in the state
+						//list are things we can't clean up because they fail without
+						//getting a callback.
+						doneCount++;
 					}
-					catch (e) {
-						currentState.isFinishing = true;
-						this._finish(currentState, "error", {status:this.DsrStatusCodes.Error, response:e});
-					}
+				}catch(e){
+					this._finish(currentState, "error", {status: this.DsrStatusCodes.Error, response: e});
 				}
 			}
 		}
-		if (doneCount >= totalCount) {
+	
+		if(doneCount == totalCount){
 			clearInterval(this.inFlightTimer);
 			this.inFlightTimer = null;
 		}
-	};
-	this.canHandle = function (kwArgs) {
-		return dojo.lang.inArray(["text/javascript", "text/json", "application/json"], (kwArgs["mimetype"].toLowerCase())) && (kwArgs["method"].toLowerCase() == "get") && !(kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"])) && (!kwArgs["sync"] || kwArgs["sync"] == false) && !kwArgs["file"] && !kwArgs["multipart"];
-	};
-	this.removeScripts = function () {
+	}
+
+	this.canHandle = function(kwArgs){
+		return dojo.lang.inArray((kwArgs["mimetype"].toLowerCase()), ["text/javascript", "text/json"])
+			&& (kwArgs["method"].toLowerCase() == "get")
+			&& !(kwArgs["formNode"] && dojo.io.formHasFile(kwArgs["formNode"]))
+			&& (!kwArgs["sync"] || kwArgs["sync"] == false)
+			&& !kwArgs["file"]
+			&& !kwArgs["multipart"];
+	}
+
+	/**
+	 * Removes any script tags from the DOM that may have been added by ScriptSrcTransport.
+	 * Be careful though, by removing them from the script, you may invalidate some
+	 * script objects that were defined by the js file that was pulled in as the
+	 * src of the script tag. Test carefully if you decide to call this method.
+	 * 
+	 * In MSIE 6 (and probably 5.x), if you removed the script element while 
+	 * part of the script is still executing, the browser will crash.
+	 */
+	this.removeScripts = function(){
 		var scripts = document.getElementsByTagName("script");
-		for (var i = 0; scripts && i < scripts.length; i++) {
+		for(var i = 0; scripts && i < scripts.length; i++){
 			var scriptTag = scripts[i];
-			if (scriptTag.className == "ScriptSrcTransport") {
+			if(scriptTag.className == "ScriptSrcTransport"){
 				var parent = scriptTag.parentNode;
 				parent.removeChild(scriptTag);
-				i--;
+				i--; //Set the index back one since we removed an item.
 			}
 		}
-	};
-	this.bind = function (kwArgs) {
+	}
+
+	this.bind = function(kwArgs){
+		//START duplication from BrowserIO.js (some changes made)
 		var url = kwArgs.url;
 		var query = "";
-		if (kwArgs["formNode"]) {
+		
+		if(kwArgs["formNode"]){
 			var ta = kwArgs.formNode.getAttribute("action");
-			if ((ta) && (!kwArgs["url"])) {
-				url = ta;
-			}
+			if((ta)&&(!kwArgs["url"])){ url = ta; }
 			var tp = kwArgs.formNode.getAttribute("method");
-			if ((tp) && (!kwArgs["method"])) {
-				kwArgs.method = tp;
-			}
+			if((tp)&&(!kwArgs["method"])){ kwArgs.method = tp; }
 			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs["formFilter"]);
 		}
-		if (url.indexOf("#") > -1) {
+
+		if(url.indexOf("#") > -1) {
 			dojo.debug("Warning: dojo.io.bind: stripping hash values from url:", url);
 			url = url.split("#")[0];
 		}
+
+		//Break off the domain/path of the URL.
 		var urlParts = url.split("?");
-		if (urlParts && urlParts.length == 2) {
+		if(urlParts && urlParts.length == 2){
 			url = urlParts[0];
 			query += (query ? "&" : "") + urlParts[1];
 		}
-		if (kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]) {
+
+		if(kwArgs["backButton"] || kwArgs["back"] || kwArgs["changeUrl"]){
 			dojo.undo.browser.addToHistory(kwArgs);
 		}
+
+		//Create an ID for the request.
 		var id = kwArgs["apiId"] ? kwArgs["apiId"] : "id" + this._counter++;
+
+		//Fill out any other content pieces.
 		var content = kwArgs["content"];
 		var jsonpName = kwArgs.jsonParamName;
-		if (kwArgs.sendTransport || jsonpName) {
-			if (!content) {
+		if(kwArgs.sendTransport || jsonpName) {
+			if (!content){
 				content = {};
 			}
-			if (kwArgs.sendTransport) {
+			if(kwArgs.sendTransport){
 				content["dojo.transport"] = "scriptsrc";
 			}
-			if (jsonpName) {
+
+			if(jsonpName){
 				content[jsonpName] = "dojo.io.ScriptSrcTransport._state." + id + ".jsonpCall";
 			}
 		}
-		if (kwArgs.postContent) {
+
+		if(kwArgs.postContent){
 			query = kwArgs.postContent;
-		} else {
-			if (content) {
-				query += ((query) ? "&" : "") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);
-			}
+		}else if(content){
+			query += ((query) ? "&" : "") + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);
 		}
-		if (kwArgs["apiId"]) {
+		//END duplication from BrowserIO.js
+
+		//START DSR
+
+		//If an apiId is specified, then we want to make sure useRequestId is true.
+		if(kwArgs["apiId"]){
 			kwArgs["useRequestId"] = true;
 		}
-		var state = {"id":id, "idParam":"_dsrid=" + id, "url":url, "query":query, "kwArgs":kwArgs, "startTime":(new Date()).getTime(), "isFinishing":false};
-		if (!url) {
-			this._finish(state, "error", {status:this.DsrStatusCodes.Error, statusText:"url.none"});
+
+		//Set up the state for this request.
+		var state = {
+			"id": id,
+			"idParam": "_dsrid=" + id,
+			"url": url,
+			"query": query,
+			"kwArgs": kwArgs,
+			"startTime": (new Date()).getTime()
+		};
+
+		if(!url){
+			//Error. An URL is needed.
+			this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.none"});
 			return;
 		}
-		if (content && content[jsonpName]) {
+
+		//If this is a jsonp request, intercept the jsonp callback
+		if(content && content[jsonpName]){
 			state.jsonp = content[jsonpName];
-			state.jsonpCall = function (data) {
-				if (data["Error"] || data["error"]) {
-					if (dojo["json"] && dojo["json"]["serialize"]) {
-						dojo.debug(dojo.json.serialize(data));
-					}
+			state.jsonpCall = function(data){
+				if(data["Error"]||data["error"]){
+					dojo.debug(dojo.json.serialize(data));
 					dojo.io.ScriptSrcTransport._finish(this, "error", data);
-				} else {
+				}else{
 					dojo.io.ScriptSrcTransport._finish(this, "load", data);
 				}
 			};
 		}
-		if (kwArgs["useRequestId"] || kwArgs["checkString"] || state["jsonp"]) {
+
+		//Only store the request state on the state tracking object if a callback
+		//is expected or if polling on a checkString will be done.
+		if(kwArgs["useRequestId"] || kwArgs["checkString"] || state["jsonp"]){
 			this._state[id] = state;
 		}
-		if (kwArgs["checkString"]) {
+
+		//A checkstring is a string that if evaled will not be undefined once the
+		//script src loads. Used as an alternative to depending on a callback from
+		//the script file. If this is set, then multipart is not assumed to be used,
+		//since multipart requires a specific callback. With checkString we will be doing
+		//polling.
+		if(kwArgs["checkString"]){
 			state.checkString = kwArgs["checkString"];
 		}
+
+		//Constant params are parameters that should always be sent with each
+		//part of a multipart URL.
 		state.constantParams = (kwArgs["constantParams"] == null ? "" : kwArgs["constantParams"]);
-		if (kwArgs["preventCache"] || (this.preventCache == true && kwArgs["preventCache"] != false)) {
+	
+		if(kwArgs["preventCache"] ||
+			(this.preventCache == true && kwArgs["preventCache"] != false)){
 			state.nocacheParam = "dojo.preventCache=" + new Date().valueOf();
-		} else {
+		}else{
 			state.nocacheParam = "";
 		}
-		var urlLength = state.url.length + state.query.length + state.constantParams.length + state.nocacheParam.length + this._extraPaddingLength;
-		if (kwArgs["useRequestId"]) {
+
+		//Get total length URL, if we were to do it as one URL.
+		//Add some padding, extra & separators.
+		var urlLength = state.url.length + state.query.length + state.constantParams.length 
+				+ state.nocacheParam.length + this._extraPaddingLength;
+
+		if(kwArgs["useRequestId"]){
 			urlLength += state.idParam.length;
 		}
-		if (!kwArgs["checkString"] && kwArgs["useRequestId"] && !state["jsonp"] && !kwArgs["forceSingleRequest"] && urlLength > this.maxUrlLength) {
-			if (url > this.maxUrlLength) {
-				this._finish(state, "error", {status:this.DsrStatusCodes.Error, statusText:"url.tooBig"});
+		
+		if(!kwArgs["checkString"] && kwArgs["useRequestId"] 
+			&& !state["jsonp"] && !kwArgs["forceSingleRequest"]
+			&& urlLength > this.maxUrlLength){
+			if(url > this.maxUrlLength){
+				//Error. The URL domain and path are too long. We can't
+				//segment that, so return an error.
+				this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "url.tooBig"});
 				return;
-			} else {
+			}else{
+				//Start the multiple requests.
 				this._multiAttach(state, 1);
 			}
-		} else {
+		}else{
+			//Send one URL.
 			var queryParams = [state.constantParams, state.nocacheParam, state.query];
-			if (kwArgs["useRequestId"] && !state["jsonp"]) {
+			if(kwArgs["useRequestId"] && !state["jsonp"]){
 				queryParams.unshift(state.idParam);
 			}
 			var finalUrl = this._buildUrl(state.url, queryParams);
+
+			//Track the final URL in case we need to use that instead of api ID when receiving
+			//the load callback.
 			state.finalUrl = finalUrl;
+			
 			this._attach(state.id, finalUrl);
 		}
+		//END DSR
+
 		this.startWatchingInFlight();
-	};
+	}
+	
+	//Private properties/methods
 	this._counter = 1;
 	this._state = {};
 	this._extraPaddingLength = 16;
-	this._buildUrl = function (url, nameValueArray) {
+
+	//Is there a dojo function for this already?
+	this._buildUrl = function(url, nameValueArray){
 		var finalUrl = url;
 		var joiner = "?";
-		for (var i = 0; i < nameValueArray.length; i++) {
-			if (nameValueArray[i]) {
+		for(var i = 0; i < nameValueArray.length; i++){
+			if(nameValueArray[i]){
 				finalUrl += joiner + nameValueArray[i];
 				joiner = "&";
 			}
 		}
+
 		return finalUrl;
-	};
-	this._attach = function (id, url) {
+	}
+
+	this._attach = function(id, url){
+		//Attach the script to the DOM.
 		var element = document.createElement("script");
 		element.type = "text/javascript";
 		element.src = url;
 		element.id = id;
 		element.className = "ScriptSrcTransport";
 		document.getElementsByTagName("head")[0].appendChild(element);
-	};
-	this._multiAttach = function (state, part) {
-		if (state.query == null) {
-			this._finish(state, "error", {status:this.DsrStatusCodes.Error, statusText:"query.null"});
+	}
+
+	this._multiAttach = function(state, part){
+		//Check to make sure we still have a query to send up. This is mostly
+		//a protection from a goof on the server side when it sends a part OK
+		//response instead of a final response.
+		if(state.query == null){
+			this._finish(state, "error", {status: this.DsrStatusCodes.Error, statusText: "query.null"});
 			return;
 		}
-		if (!state.constantParams) {
+
+		if(!state.constantParams){
 			state.constantParams = "";
 		}
-		var queryMax = this.maxUrlLength - state.idParam.length - state.constantParams.length - state.url.length - state.nocacheParam.length - this._extraPaddingLength;
+
+		//How much of the query can we take?
+		//Add a padding constant to account for _part and a couple extra amperstands.
+		//Also add space for id since we'll need it now.
+		var queryMax = this.maxUrlLength - state.idParam.length
+					 - state.constantParams.length - state.url.length
+					 - state.nocacheParam.length - this._extraPaddingLength;
+		
+		//Figure out if this is the last part.
 		var isDone = state.query.length < queryMax;
+	
+		//Break up the query string if necessary.
 		var currentQuery;
-		if (isDone) {
+		if(isDone){
 			currentQuery = state.query;
 			state.query = null;
-		} else {
+		}else{
+			//Find the & or = nearest the max url length.
 			var ampEnd = state.query.lastIndexOf("&", queryMax - 1);
 			var eqEnd = state.query.lastIndexOf("=", queryMax - 1);
-			if (ampEnd > eqEnd || eqEnd == queryMax - 1) {
+
+			//See if & is closer, or if = is right at the edge,
+			//which means we should put it on the next URL.
+			if(ampEnd > eqEnd || eqEnd == queryMax - 1){
+				//& is nearer the end. So just chop off from there.
 				currentQuery = state.query.substring(0, ampEnd);
-				state.query = state.query.substring(ampEnd + 1, state.query.length);
-			} else {
+				state.query = state.query.substring(ampEnd + 1, state.query.length) //strip off amperstand with the + 1.
+			}else{
+				//= is nearer the end. Take the max amount possible. 
 				currentQuery = state.query.substring(0, queryMax);
+			 
+				//Find the last query name in the currentQuery so we can prepend it to
+				//ampEnd. Could be -1 (not there), so account for that.
 				var queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);
 				state.query = queryName + "=" + state.query.substring(queryMax, state.query.length);
 			}
 		}
+		
+		//Now send a part of the script
 		var queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];
-		if (!isDone) {
+		if(!isDone){
 			queryParams.push("_part=" + part);
 		}
+
 		var url = this._buildUrl(state.url, queryParams);
+
 		this._attach(state.id + "_" + part, url);
-	};
-	this._finish = function (state, callback, event) {
-		if (callback != "partOk" && !state.kwArgs[callback] && !state.kwArgs["handle"]) {
-			if (callback == "error") {
+	}
+
+	this._finish = function(state, callback, event){
+		if(callback != "partOk" && !state.kwArgs[callback] && !state.kwArgs["handle"]){
+			//Ignore "partOk" because that is an internal callback.
+			if(callback == "error"){
 				state.isDone = true;
 				throw event;
 			}
-		} else {
-			switch (callback) {
-			  case "load":
-				var response = event ? event.response : null;
-				if (!response) {
-					response = event;
-				}
-				state.kwArgs[(typeof state.kwArgs.load == "function") ? "load" : "handle"]("load", response, event, state.kwArgs);
-				state.isDone = true;
-				break;
-			  case "partOk":
-				var part = parseInt(event.response.part, 10) + 1;
-				if (event.response.constantParams) {
-					state.constantParams = event.response.constantParams;
-				}
-				this._multiAttach(state, part);
-				state.isDone = false;
-				break;
-			  case "error":
-				state.kwArgs[(typeof state.kwArgs.error == "function") ? "error" : "handle"]("error", event.response, event, state.kwArgs);
-				state.isDone = true;
-				break;
-			  default:
-				state.kwArgs[(typeof state.kwArgs[callback] == "function") ? callback : "handle"](callback, event, event, state.kwArgs);
-				state.isDone = true;
+		}else{
+			switch(callback){
+				case "load":
+					var response = event ? event.response : null;
+					if(!response){
+						response = event;
+					}
+					state.kwArgs[(typeof state.kwArgs.load == "function") ? "load" : "handle"]("load", response, event, state.kwArgs);
+					state.isDone = true;
+					break;
+				case "partOk":
+					var part = parseInt(event.response.part, 10) + 1;
+					//Update the constant params, if any.
+					if(event.response.constantParams){
+						state.constantParams = event.response.constantParams;
+					}
+					this._multiAttach(state, part);
+					state.isDone = false;
+					break;
+				case "error":
+					state.kwArgs[(typeof state.kwArgs.error == "function") ? "error" : "handle"]("error", event.response, event, state.kwArgs);
+					state.isDone = true;
+					break;
+				default:
+					state.kwArgs[(typeof state.kwArgs[callback] == "function") ? callback : "handle"](callback, event, event, state.kwArgs);
+					state.isDone = true;
 			}
 		}
-	};
+	}
+
 	dojo.io.transports.addTransport("ScriptSrcTransport");
-};
-window.onscriptload = function (event) {
+}
+
+//Define callback handler.
+window.onscriptload = function(event){
 	var state = null;
 	var transport = dojo.io.ScriptSrcTransport;
-	if (transport._state[event.id]) {
+	
+	//Find the matching state object for event ID.
+	if(transport._state[event.id]){
 		state = transport._state[event.id];
-	} else {
+	}else{
+		//The ID did not match directly to an entry in the state list.
+		//Try searching the state objects for a matching original URL.
 		var tempState;
-		for (var param in transport._state) {
+		for(var param in transport._state){
 			tempState = transport._state[param];
-			if (tempState.finalUrl && tempState.finalUrl == event.id) {
+			if(tempState.finalUrl && tempState.finalUrl == event.id){
 				state = tempState;
 				break;
 			}
 		}
-		if (state == null) {
+
+		//If no matching original URL is found, then use the URL that was actually used
+		//in the SCRIPT SRC attribute.
+		if(state == null){
 			var scripts = document.getElementsByTagName("script");
-			for (var i = 0; scripts && i < scripts.length; i++) {
+			for(var i = 0; scripts && i < scripts.length; i++){
 				var scriptTag = scripts[i];
-				if (scriptTag.getAttribute("class") == "ScriptSrcTransport" && scriptTag.src == event.id) {
+				if(scriptTag.getAttribute("class") == "ScriptSrcTransport"
+					&& scriptTag.src == event.id){
 					state = transport._state[scriptTag.id];
 					break;
 				}
 			}
 		}
-		if (state == null) {
+		
+		//If state is still null, then throw an error.
+		if(state == null){
 			throw "No matching state for onscriptload event.id: " + event.id;
 		}
 	}
+
 	var callbackName = "error";
-	switch (event.status) {
-	  case dojo.io.ScriptSrcTransport.DsrStatusCodes.Continue:
-		callbackName = "partOk";
-		break;
-	  case dojo.io.ScriptSrcTransport.DsrStatusCodes.Ok:
-		callbackName = "load";
-		break;
+	switch(event.status){
+		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Continue:
+			//A part of a multipart request.
+			callbackName = "partOk";
+			break;
+		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Ok:
+			//Successful reponse.
+			callbackName = "load";
+			break;
 	}
+
 	transport._finish(state, callbackName, event);
 };
-

Added: tags/parley-0.53/root/static/magic/src/io/ShortBusIO.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/ShortBusIO.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/ShortBusIO.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,171 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.io.ShortBusIO");
+dojo.require("dojo.io"); // io.js provides setIFrameSrc
+// FIXME: determine if we can use XMLHTTP to make x-domain posts despite not
+//        being able to hear back about the result
+dojo.require("dojo.io.IframeIO"); // for posting across domains
+dojo.require("dojo.io.cookie"); // for peering
+dojo.require("dojo.event.*");
+
+/*
+ * this file defines a "forever-frame" style Comet client. It passes opaque
+ * JSON data structures to/from the client. Both styles of request provide a
+ * topic for the event to be sent to and a payload object to be acted upon.
+ *
+ * All outbound events are sent via dojo.io.bind() and all inbound requests are
+ * processed by Dojo topic dispatch.
+ *
+ * ShortBusIO packets have the basic format:
+ *
+ *	{
+ *	 	topic: "/destination/topic/name",
+ *		body: {
+ * 			// ...
+ *		}
+ * 	}
+ * 
+ * Packets bound for the event router (not one of it's clients) or generated
+ * from it are prefixed with the special "/meta" topic. Meta-topic events
+ * either inform the client to take an action or inform the server of a system
+ * event.
+ *
+ * Upon tunnel creation, the server might therefore send the following meta
+ * topic packet to the client to inform the client of it's assigned identity:
+ *
+ *	// client <-- server
+ *	{
+ *	 	topic: "/meta",
+ *		body: {
+ * 			action: "setClientId",
+ *			clientId: "fooBar23",
+ *			tunnelId: "fooBarTunnel4",
+ *			tunnelExpiration: "...", // some date in the future
+ *		}
+ * 	}
+ *
+ * The client may then respond with a confirmation:
+ * 
+ *	// client --> server
+ *	{
+ *	 	topic: "/meta",
+ *		body: {
+ * 			action: "confirmClientId",
+ *			from: "fooBar23"
+ *		}
+ * 	}
+ *
+ * The client must implement a basic vocabulary of /meta topic verbs in order
+ * to participate as a ShortBus endpoint. These are TBD.
+ *
+ * NOTE: this example elides any authentication or authorization steps the
+ * client and server may have undertaken prior to tunnel setup.
+ */
+
+// TODO: unlike repubsubio we don't handle any sort of connection
+// subscription/publishing backlog. Should we?
+
+dojo.io.ShortBusTransport = new function(){
+
+	var initialized = false;
+	var connected = false;
+
+	// this class is similar to RepubsubIO save that we don't have the
+	// externalized protocol handler code. Our messages are simpler so our code
+	// can be as well.
+
+	this.rcvNode = null;
+	this.rcvNodeName = "";
+	this.topicRoot = null;
+
+	this.getRandStr = function(){
+		return Math.random().toString().substring(2, 10);
+	}
+
+	this.widenDomain = function(domainStr){
+		// allow us to make reqests to the TLD
+		var cd = domainStr||document.domain;
+		if(cd.indexOf(".")==-1){ return; } // probably file:/// or localhost
+		var dps = cd.split(".");
+		if(dps.length<=2){ return; } // probably file:/// or an RFC 1918 address
+		dps = dps.slice(dps.length-2);
+		document.domain = dps.join(".");
+	}
+
+	this.canHandle = function(kwArgs){
+		return (
+			(connected)			&&
+			(kwArgs["topic"])	&&
+			(! // async only!
+				((kwArgs["sync"])&&(kwArgs["sync"] == true))
+			)
+		);
+	}
+
+	this.buildConnection = function(){
+		// NOTE: we require the server to cooperate by hosting
+		// ShortBusInit.html at the designated endpoint
+		this.rcvNodeName = "ShortBusRcv_"+this.getRandStr();
+		// the "forever frame" approach
+		if(dojo.render.html.ie){
+			// use the "htmlfile hack" to prevent the background click junk
+			this.rcvNode = new ActiveXObject("htmlfile");
+			this.rcvNode.open();
+			this.rcvNode.write("<html>");
+			this.rcvNode.write("<script>document.domain = '"+document.domain+"'");
+			this.rcvNode.write("</html>");
+			this.rcvNode.close();
+
+			var ifrDiv = this.rcvNode.createElement("div");
+			this.rcvNode.appendChild(ifrDiv);
+			this.rcvNode.parentWindow.dojo = dojo;
+			ifrDiv.innerHTML = "<iframe src='"+this.topicRoot+"/?tunntelType=htmlfile'></iframe>"
+			// and we're ready to go!
+			connected = true;
+		}else{
+			this.rcvNode = dojo.io.createIFrame(this.rcvNodeName);
+			dojo.io.setIFrameSrc(this.rcvNode, this.topicRoot+"/?tunnelType=iframe");
+			// we're still waiting on this one to call back up and advertise
+			// that it's been initialized
+		}
+	}
+
+	this.iframeConnectionInit = function(){
+		connected = true;
+	}
+
+	this.dispatchServerEvent = function(eObj){
+		// FIXME: implement basic /meta topic semantics here!
+	}
+
+	this.init = function(){
+		if(initialized){
+			return;
+		}
+		initialized = true;
+
+		this.widenDomain();
+
+		// we want to set up a connection to the designated server. Grab the
+		// server location out of djConfig.
+		this.topicRoot = djConfig["ShortBusRoot"];
+		if(!this.topicRoot){
+			dojo.debug("no topic root specified in djConfig.ShortBusRoot");
+			return;
+		}
+	}
+
+	this.dispatch = function(evt){
+		// dipatch events along the specified path
+	}
+
+    dojo.io.transports.addTransport("ShortBusTransport");
+}

Added: tags/parley-0.53/root/static/magic/src/io/ShortBusInit.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/ShortBusInit.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/ShortBusInit.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,75 @@
+<html>
+<!--
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+	http://dojotoolkit.org/community/licensing.shtml
+-->
+<script type="text/javascript">
+	if(window!=window.parent){
+		function callByDeRef(fname){
+			if(!fname){ return null; }
+			// if someone inadvertently passed in "foo(...)", we make it "foo"
+			fname = String(fname).split("(")[0];
+			// get a real array of arguments
+			var aa = [];
+			for(var x=1; x<arguments.length; x++){
+				aa.push(arguments[x]);
+			}
+
+			var parts = String(fname).split(".");
+			var obj = window;
+			for(var x=0; x<parts.length-1; x++){
+				obj = obj[parts[x]];
+			}
+			var fn = parts.pop(); // the last element is the function name
+			// exec the function in the specified namespace
+			return obj[fn].apply(obj, aa);
+		}
+
+		function widenDomain(domainStr){
+			// the purpose of this is to set the most liberal domain policy
+			var cd = domainStr||document.domain;
+			if(cd.indexOf(".")==-1){ 
+				document.domain = cd;
+				return;
+			}
+			var dps = cd.split(".");
+			if(dps.length>2){ 
+				dps = dps.slice(dps.length-2);
+			}
+			document.domain = dps.join(".");
+		}
+
+		function doInit(){
+
+			widenDomain();
+
+			var baseUrl = document.location.toString();
+			var params = baseUrl.split("?", 2);
+			if(params.length > 1){
+				var paramStr = params[1];
+				var pairs = paramStr.split("&");
+				var opts = [];
+				for(var x in pairs){
+					// alert(pairs[x]);
+					var sp = pairs[x].split("=");
+					opts[sp[0]]=sp[1];
+					if(sp[0]=="true"){
+						sp[0] = true;
+					}else if(sp[0]=="false"){
+						sp[0] = false;
+					}
+				}
+				if(opts["callback"]){
+					callByDeRef("parent."+opts["callback"]);
+				}
+			}
+		}
+		doInit();
+	}
+</script>
+</html>


Property changes on: tags/parley-0.53/root/static/magic/src/io/ShortBusInit.html
___________________________________________________________________
Name: svn:mime-type
   + text/html

Deleted: tags/parley-0.53/root/static/magic/src/io/XhrIframeProxy.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/XhrIframeProxy.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/XhrIframeProxy.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,152 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.io.XhrIframeProxy");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.io.XhrIframeProxy");
-dojo.require("dojo.io.IframeIO");
-dojo.require("dojo.dom");
-dojo.require("dojo.uri.Uri");
-dojo.io.XhrIframeProxy = {xipClientUrl:djConfig["xipClientUrl"] || dojo.uri.moduleUri("dojo.io", "xip_client.html"), _state:{}, _stateIdCounter:0, needFrameRecursion:function () {
-	return (true == dojo.render.html.ie70);
-}, send:function (facade) {
-	var stateId = "XhrIframeProxy" + (this._stateIdCounter++);
-	facade._stateId = stateId;
-	var frameUrl = this.xipClientUrl + "#0:init:id=" + stateId + "&server=" + encodeURIComponent(facade._ifpServerUrl) + "&fr=false";
-	if (this.needFrameRecursion()) {
-		var fullClientUrl = window.location.href;
-		if ((this.xipClientUrl + "").charAt(0) == "/") {
-			var endIndex = fullClientUrl.indexOf("://");
-			endIndex = fullClientUrl.indexOf("/", endIndex + 1);
-			fullClientUrl = fullClientUrl.substring(0, endIndex);
-		} else {
-			fullClientUrl = fullClientUrl.substring(0, fullClientUrl.lastIndexOf("/") + 1);
-		}
-		fullClientUrl += this.xipClientUrl;
-		var serverUrl = facade._ifpServerUrl + (facade._ifpServerUrl.indexOf("?") == -1 ? "?" : "&") + "dojo.fr=1";
-		frameUrl = serverUrl + "#0:init:id=" + stateId + "&client=" + encodeURIComponent(fullClientUrl) + "&fr=" + this.needFrameRecursion();
-	}
-	this._state[stateId] = {facade:facade, stateId:stateId, clientFrame:dojo.io.createIFrame(stateId, "", frameUrl)};
-	return stateId;
-}, receive:function (stateId, urlEncodedData) {
-	var response = {};
-	var nvPairs = urlEncodedData.split("&");
-	for (var i = 0; i < nvPairs.length; i++) {
-		if (nvPairs[i]) {
-			var nameValue = nvPairs[i].split("=");
-			response[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);
-		}
-	}
-	var state = this._state[stateId];
-	var facade = state.facade;
-	facade._setResponseHeaders(response.responseHeaders);
-	if (response.status == 0 || response.status) {
-		facade.status = parseInt(response.status, 10);
-	}
-	if (response.statusText) {
-		facade.statusText = response.statusText;
-	}
-	if (response.responseText) {
-		facade.responseText = response.responseText;
-		var contentType = facade.getResponseHeader("Content-Type");
-		if (contentType && (contentType == "application/xml" || contentType == "text/xml")) {
-			facade.responseXML = dojo.dom.createDocumentFromText(response.responseText, contentType);
-		}
-	}
-	facade.readyState = 4;
-	this.destroyState(stateId);
-}, clientFrameLoaded:function (stateId) {
-	var state = this._state[stateId];
-	var facade = state.facade;
-	if (this.needFrameRecursion()) {
-		var clientWindow = window.open("", state.stateId + "_clientEndPoint");
-	} else {
-		var clientWindow = state.clientFrame.contentWindow;
-	}
-	var reqHeaders = [];
-	for (var param in facade._requestHeaders) {
-		reqHeaders.push(param + ": " + facade._requestHeaders[param]);
-	}
-	var requestData = {uri:facade._uri};
-	if (reqHeaders.length > 0) {
-		requestData.requestHeaders = reqHeaders.join("\r\n");
-	}
-	if (facade._method) {
-		requestData.method = facade._method;
-	}
-	if (facade._bodyData) {
-		requestData.data = facade._bodyData;
-	}
-	clientWindow.send(dojo.io.argsFromMap(requestData, "utf8"));
-}, destroyState:function (stateId) {
-	var state = this._state[stateId];
-	if (state) {
-		delete this._state[stateId];
-		var parentNode = state.clientFrame.parentNode;
-		parentNode.removeChild(state.clientFrame);
-		state.clientFrame = null;
-		state = null;
-	}
-}, createFacade:function () {
-	if (arguments && arguments[0] && arguments[0]["iframeProxyUrl"]) {
-		return new dojo.io.XhrIframeFacade(arguments[0]["iframeProxyUrl"]);
-	} else {
-		return dojo.io.XhrIframeProxy.oldGetXmlhttpObject.apply(dojo.hostenv, arguments);
-	}
-}};
-dojo.io.XhrIframeProxy.oldGetXmlhttpObject = dojo.hostenv.getXmlhttpObject;
-dojo.hostenv.getXmlhttpObject = dojo.io.XhrIframeProxy.createFacade;
-dojo.io.XhrIframeFacade = function (ifpServerUrl) {
-	this._requestHeaders = {};
-	this._allResponseHeaders = null;
-	this._responseHeaders = {};
-	this._method = null;
-	this._uri = null;
-	this._bodyData = null;
-	this.responseText = null;
-	this.responseXML = null;
-	this.status = null;
-	this.statusText = null;
-	this.readyState = 0;
-	this._ifpServerUrl = ifpServerUrl;
-	this._stateId = null;
-};
-dojo.lang.extend(dojo.io.XhrIframeFacade, {open:function (method, uri) {
-	this._method = method;
-	this._uri = uri;
-	this.readyState = 1;
-}, setRequestHeader:function (header, value) {
-	this._requestHeaders[header] = value;
-}, send:function (stringData) {
-	this._bodyData = stringData;
-	this._stateId = dojo.io.XhrIframeProxy.send(this);
-	this.readyState = 2;
-}, abort:function () {
-	dojo.io.XhrIframeProxy.destroyState(this._stateId);
-}, getAllResponseHeaders:function () {
-	return this._allResponseHeaders;
-}, getResponseHeader:function (header) {
-	return this._responseHeaders[header];
-}, _setResponseHeaders:function (allHeaders) {
-	if (allHeaders) {
-		this._allResponseHeaders = allHeaders;
-		allHeaders = allHeaders.replace(/\r/g, "");
-		var nvPairs = allHeaders.split("\n");
-		for (var i = 0; i < nvPairs.length; i++) {
-			if (nvPairs[i]) {
-				var nameValue = nvPairs[i].split(": ");
-				this._responseHeaders[nameValue[0]] = nameValue[1];
-			}
-		}
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/io/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,10 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.io.common"], rhino:["dojo.io.RhinoIO"], browser:["dojo.io.BrowserIO", "dojo.io.cookie"], dashboard:["dojo.io.BrowserIO", "dojo.io.cookie"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.io"],
+	rhino: ["dojo.io.RhinoIO"],
+	browser: ["dojo.io.BrowserIO", "dojo.io.cookie"],
+	dashboard: ["dojo.io.BrowserIO", "dojo.io.cookie"]
+});
 dojo.provide("dojo.io.*");
-

Deleted: tags/parley-0.53/root/static/magic/src/io/cometd.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/cometd.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/cometd.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,530 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.require("dojo.io.common");
-dojo.provide("dojo.io.cometd");
-dojo.require("dojo.AdapterRegistry");
-dojo.require("dojo.json");
-dojo.require("dojo.io.BrowserIO");
-dojo.require("dojo.io.IframeIO");
-dojo.require("dojo.io.ScriptSrcIO");
-dojo.require("dojo.io.cookie");
-dojo.require("dojo.event.*");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.func");
-cometd = new function () {
-	this.initialized = false;
-	this.connected = false;
-	this.connectionTypes = new dojo.AdapterRegistry(true);
-	this.version = 0.1;
-	this.minimumVersion = 0.1;
-	this.clientId = null;
-	this._isXD = false;
-	this.handshakeReturn = null;
-	this.currentTransport = null;
-	this.url = null;
-	this.lastMessage = null;
-	this.globalTopicChannels = {};
-	this.backlog = [];
-	this.tunnelInit = function (childLocation, childDomain) {
-	};
-	this.tunnelCollapse = function () {
-		dojo.debug("tunnel collapsed!");
-	};
-	this.init = function (props, root, bargs) {
-		props = props || {};
-		props.version = this.version;
-		props.minimumVersion = this.minimumVersion;
-		props.channel = "/meta/handshake";
-		this.url = root || djConfig["cometdRoot"];
-		if (!this.url) {
-			dojo.debug("no cometd root specified in djConfig and no root passed");
-			return;
-		}
-		var bindArgs = {url:this.url, method:"POST", mimetype:"text/json", load:dojo.lang.hitch(this, "finishInit"), content:{"message":dojo.json.serialize([props])}};
-		var regexp = "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
-		var r = ("" + window.location).match(new RegExp(regexp));
-		if (r[4]) {
-			var tmp = r[4].split(":");
-			var thisHost = tmp[0];
-			var thisPort = tmp[1] || "80";
-			r = this.url.match(new RegExp(regexp));
-			if (r[4]) {
-				tmp = r[4].split(":");
-				var urlHost = tmp[0];
-				var urlPort = tmp[1] || "80";
-				if ((urlHost != thisHost) || (urlPort != thisPort)) {
-					dojo.debug(thisHost, urlHost);
-					dojo.debug(thisPort, urlPort);
-					this._isXD = true;
-					bindArgs.transport = "ScriptSrcTransport";
-					bindArgs.jsonParamName = "jsonp";
-					bindArgs.method = "GET";
-				}
-			}
-		}
-		if (bargs) {
-			dojo.lang.mixin(bindArgs, bargs);
-		}
-		return dojo.io.bind(bindArgs);
-	};
-	this.finishInit = function (type, data, evt, request) {
-		data = data[0];
-		this.handshakeReturn = data;
-		if (data["authSuccessful"] == false) {
-			dojo.debug("cometd authentication failed");
-			return;
-		}
-		if (data.version < this.minimumVersion) {
-			dojo.debug("cometd protocol version mismatch. We wanted", this.minimumVersion, "but got", data.version);
-			return;
-		}
-		this.currentTransport = this.connectionTypes.match(data.supportedConnectionTypes, data.version, this._isXD);
-		this.currentTransport.version = data.version;
-		this.clientId = data.clientId;
-		this.tunnelInit = dojo.lang.hitch(this.currentTransport, "tunnelInit");
-		this.tunnelCollapse = dojo.lang.hitch(this.currentTransport, "tunnelCollapse");
-		this.initialized = true;
-		this.currentTransport.startup(data);
-		while (this.backlog.length != 0) {
-			var cur = this.backlog.shift();
-			var fn = cur.shift();
-			this[fn].apply(this, cur);
-		}
-	};
-	this._getRandStr = function () {
-		return Math.random().toString().substring(2, 10);
-	};
-	this.deliver = function (messages) {
-		dojo.lang.forEach(messages, this._deliver, this);
-	};
-	this._deliver = function (message) {
-		if (!message["channel"]) {
-			dojo.debug("cometd error: no channel for message!");
-			return;
-		}
-		if (!this.currentTransport) {
-			this.backlog.push(["deliver", message]);
-			return;
-		}
-		this.lastMessage = message;
-		if ((message.channel.length > 5) && (message.channel.substr(0, 5) == "/meta")) {
-			switch (message.channel) {
-			  case "/meta/subscribe":
-				if (!message.successful) {
-					dojo.debug("cometd subscription error for channel", message.channel, ":", message.error);
-					return;
-				}
-				this.subscribed(message.subscription, message);
-				break;
-			  case "/meta/unsubscribe":
-				if (!message.successful) {
-					dojo.debug("cometd unsubscription error for channel", message.channel, ":", message.error);
-					return;
-				}
-				this.unsubscribed(message.subscription, message);
-				break;
-			}
-		}
-		this.currentTransport.deliver(message);
-		if (message.data) {
-			var tname = (this.globalTopicChannels[message.channel]) ? message.channel : "/cometd" + message.channel;
-			dojo.event.topic.publish(tname, message);
-		}
-	};
-	this.disconnect = function () {
-		if (!this.currentTransport) {
-			dojo.debug("no current transport to disconnect from");
-			return;
-		}
-		this.currentTransport.disconnect();
-	};
-	this.publish = function (channel, data, properties) {
-		if (!this.currentTransport) {
-			this.backlog.push(["publish", channel, data, properties]);
-			return;
-		}
-		var message = {data:data, channel:channel};
-		if (properties) {
-			dojo.lang.mixin(message, properties);
-		}
-		return this.currentTransport.sendMessage(message);
-	};
-	this.subscribe = function (channel, useLocalTopics, objOrFunc, funcName) {
-		if (!this.currentTransport) {
-			this.backlog.push(["subscribe", channel, useLocalTopics, objOrFunc, funcName]);
-			return;
-		}
-		if (objOrFunc) {
-			var tname = (useLocalTopics) ? channel : "/cometd" + channel;
-			if (useLocalTopics) {
-				this.globalTopicChannels[channel] = true;
-			}
-			dojo.event.topic.subscribe(tname, objOrFunc, funcName);
-		}
-		return this.currentTransport.sendMessage({channel:"/meta/subscribe", subscription:channel});
-	};
-	this.subscribed = function (channel, message) {
-		dojo.debug(channel);
-		dojo.debugShallow(message);
-	};
-	this.unsubscribe = function (channel, useLocalTopics, objOrFunc, funcName) {
-		if (!this.currentTransport) {
-			this.backlog.push(["unsubscribe", channel, useLocalTopics, objOrFunc, funcName]);
-			return;
-		}
-		if (objOrFunc) {
-			var tname = (useLocalTopics) ? channel : "/cometd" + channel;
-			dojo.event.topic.unsubscribe(tname, objOrFunc, funcName);
-		}
-		return this.currentTransport.sendMessage({channel:"/meta/unsubscribe", subscription:channel});
-	};
-	this.unsubscribed = function (channel, message) {
-		dojo.debug(channel);
-		dojo.debugShallow(message);
-	};
-};
-cometd.iframeTransport = new function () {
-	this.connected = false;
-	this.connectionId = null;
-	this.rcvNode = null;
-	this.rcvNodeName = "";
-	this.phonyForm = null;
-	this.authToken = null;
-	this.lastTimestamp = null;
-	this.lastId = null;
-	this.backlog = [];
-	this.check = function (types, version, xdomain) {
-		return ((!xdomain) && (!dojo.render.html.safari) && (dojo.lang.inArray(types, "iframe")));
-	};
-	this.tunnelInit = function () {
-		this.postToIframe({message:dojo.json.serialize([{channel:"/meta/connect", clientId:cometd.clientId, connectionType:"iframe"}])});
-	};
-	this.tunnelCollapse = function () {
-		if (this.connected) {
-			this.connected = false;
-			this.postToIframe({message:dojo.json.serialize([{channel:"/meta/reconnect", clientId:cometd.clientId, connectionId:this.connectionId, timestamp:this.lastTimestamp, id:this.lastId}])});
-		}
-	};
-	this.deliver = function (message) {
-		if (message["timestamp"]) {
-			this.lastTimestamp = message.timestamp;
-		}
-		if (message["id"]) {
-			this.lastId = message.id;
-		}
-		if ((message.channel.length > 5) && (message.channel.substr(0, 5) == "/meta")) {
-			switch (message.channel) {
-			  case "/meta/connect":
-				if (!message.successful) {
-					dojo.debug("cometd connection error:", message.error);
-					return;
-				}
-				this.connectionId = message.connectionId;
-				this.connected = true;
-				this.processBacklog();
-				break;
-			  case "/meta/reconnect":
-				if (!message.successful) {
-					dojo.debug("cometd reconnection error:", message.error);
-					return;
-				}
-				this.connected = true;
-				break;
-			  case "/meta/subscribe":
-				if (!message.successful) {
-					dojo.debug("cometd subscription error for channel", message.channel, ":", message.error);
-					return;
-				}
-				dojo.debug(message.channel);
-				break;
-			}
-		}
-	};
-	this.widenDomain = function (domainStr) {
-		var cd = domainStr || document.domain;
-		if (cd.indexOf(".") == -1) {
-			return;
-		}
-		var dps = cd.split(".");
-		if (dps.length <= 2) {
-			return;
-		}
-		dps = dps.slice(dps.length - 2);
-		document.domain = dps.join(".");
-		return document.domain;
-	};
-	this.postToIframe = function (content, url) {
-		if (!this.phonyForm) {
-			if (dojo.render.html.ie) {
-				this.phonyForm = document.createElement("<form enctype='application/x-www-form-urlencoded' method='POST' style='display: none;'>");
-				dojo.body().appendChild(this.phonyForm);
-			} else {
-				this.phonyForm = document.createElement("form");
-				this.phonyForm.style.display = "none";
-				dojo.body().appendChild(this.phonyForm);
-				this.phonyForm.enctype = "application/x-www-form-urlencoded";
-				this.phonyForm.method = "POST";
-			}
-		}
-		this.phonyForm.action = url || cometd.url;
-		this.phonyForm.target = this.rcvNodeName;
-		this.phonyForm.setAttribute("target", this.rcvNodeName);
-		while (this.phonyForm.firstChild) {
-			this.phonyForm.removeChild(this.phonyForm.firstChild);
-		}
-		for (var x in content) {
-			var tn;
-			if (dojo.render.html.ie) {
-				tn = document.createElement("<input type='hidden' name='" + x + "' value='" + content[x] + "'>");
-				this.phonyForm.appendChild(tn);
-			} else {
-				tn = document.createElement("input");
-				this.phonyForm.appendChild(tn);
-				tn.type = "hidden";
-				tn.name = x;
-				tn.value = content[x];
-			}
-		}
-		this.phonyForm.submit();
-	};
-	this.processBacklog = function () {
-		while (this.backlog.length > 0) {
-			this.sendMessage(this.backlog.shift(), true);
-		}
-	};
-	this.sendMessage = function (message, bypassBacklog) {
-		if ((bypassBacklog) || (this.connected)) {
-			message.connectionId = this.connectionId;
-			message.clientId = cometd.clientId;
-			var bindArgs = {url:cometd.url || djConfig["cometdRoot"], method:"POST", mimetype:"text/json", content:{message:dojo.json.serialize([message])}};
-			return dojo.io.bind(bindArgs);
-		} else {
-			this.backlog.push(message);
-		}
-	};
-	this.startup = function (handshakeData) {
-		dojo.debug("startup!");
-		dojo.debug(dojo.json.serialize(handshakeData));
-		if (this.connected) {
-			return;
-		}
-		this.rcvNodeName = "cometdRcv_" + cometd._getRandStr();
-		var initUrl = cometd.url + "/?tunnelInit=iframe";
-		if (false && dojo.render.html.ie) {
-			this.rcvNode = new ActiveXObject("htmlfile");
-			this.rcvNode.open();
-			this.rcvNode.write("<html>");
-			this.rcvNode.write("<script>document.domain = '" + document.domain + "'");
-			this.rcvNode.write("</html>");
-			this.rcvNode.close();
-			var ifrDiv = this.rcvNode.createElement("div");
-			this.rcvNode.appendChild(ifrDiv);
-			this.rcvNode.parentWindow.dojo = dojo;
-			ifrDiv.innerHTML = "<iframe src='" + initUrl + "'></iframe>";
-		} else {
-			this.rcvNode = dojo.io.createIFrame(this.rcvNodeName, "", initUrl);
-		}
-	};
-};
-cometd.mimeReplaceTransport = new function () {
-	this.connected = false;
-	this.connectionId = null;
-	this.xhr = null;
-	this.authToken = null;
-	this.lastTimestamp = null;
-	this.lastId = null;
-	this.backlog = [];
-	this.check = function (types, version, xdomain) {
-		return ((!xdomain) && (dojo.render.html.mozilla) && (dojo.lang.inArray(types, "mime-message-block")));
-	};
-	this.tunnelInit = function () {
-		if (this.connected) {
-			return;
-		}
-		this.openTunnelWith({message:dojo.json.serialize([{channel:"/meta/connect", clientId:cometd.clientId, connectionType:"mime-message-block"}])});
-		this.connected = true;
-	};
-	this.tunnelCollapse = function () {
-		if (this.connected) {
-			this.connected = false;
-			this.openTunnelWith({message:dojo.json.serialize([{channel:"/meta/reconnect", clientId:cometd.clientId, connectionId:this.connectionId, timestamp:this.lastTimestamp, id:this.lastId}])});
-		}
-	};
-	this.deliver = cometd.iframeTransport.deliver;
-	this.handleOnLoad = function (resp) {
-		cometd.deliver(dojo.json.evalJson(this.xhr.responseText));
-	};
-	this.openTunnelWith = function (content, url) {
-		this.xhr = dojo.hostenv.getXmlhttpObject();
-		this.xhr.multipart = true;
-		if (dojo.render.html.mozilla) {
-			this.xhr.addEventListener("load", dojo.lang.hitch(this, "handleOnLoad"), false);
-		} else {
-			if (dojo.render.html.safari) {
-				dojo.debug("Webkit is broken with multipart responses over XHR = (");
-				this.xhr.onreadystatechange = dojo.lang.hitch(this, "handleOnLoad");
-			} else {
-				this.xhr.onload = dojo.lang.hitch(this, "handleOnLoad");
-			}
-		}
-		this.xhr.open("POST", (url || cometd.url), true);
-		this.xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
-		dojo.debug(dojo.json.serialize(content));
-		this.xhr.send(dojo.io.argsFromMap(content, "utf8"));
-	};
-	this.processBacklog = function () {
-		while (this.backlog.length > 0) {
-			this.sendMessage(this.backlog.shift(), true);
-		}
-	};
-	this.sendMessage = function (message, bypassBacklog) {
-		if ((bypassBacklog) || (this.connected)) {
-			message.connectionId = this.connectionId;
-			message.clientId = cometd.clientId;
-			var bindArgs = {url:cometd.url || djConfig["cometdRoot"], method:"POST", mimetype:"text/json", content:{message:dojo.json.serialize([message])}};
-			return dojo.io.bind(bindArgs);
-		} else {
-			this.backlog.push(message);
-		}
-	};
-	this.startup = function (handshakeData) {
-		dojo.debugShallow(handshakeData);
-		if (this.connected) {
-			return;
-		}
-		this.tunnelInit();
-	};
-};
-cometd.longPollTransport = new function () {
-	this.connected = false;
-	this.connectionId = null;
-	this.authToken = null;
-	this.lastTimestamp = null;
-	this.lastId = null;
-	this.backlog = [];
-	this.check = function (types, version, xdomain) {
-		return ((!xdomain) && (dojo.lang.inArray(types, "long-polling")));
-	};
-	this.tunnelInit = function () {
-		if (this.connected) {
-			return;
-		}
-		this.openTunnelWith({message:dojo.json.serialize([{channel:"/meta/connect", clientId:cometd.clientId, connectionType:"long-polling"}])});
-		this.connected = true;
-	};
-	this.tunnelCollapse = function () {
-		if (!this.connected) {
-			this.connected = false;
-			dojo.debug("clientId:", cometd.clientId);
-			this.openTunnelWith({message:dojo.json.serialize([{channel:"/meta/reconnect", connectionType:"long-polling", clientId:cometd.clientId, connectionId:this.connectionId, timestamp:this.lastTimestamp, id:this.lastId}])});
-		}
-	};
-	this.deliver = cometd.iframeTransport.deliver;
-	this.openTunnelWith = function (content, url) {
-		dojo.io.bind({url:(url || cometd.url), method:"post", content:content, mimetype:"text/json", load:dojo.lang.hitch(this, function (type, data, evt, args) {
-			cometd.deliver(data);
-			this.connected = false;
-			this.tunnelCollapse();
-		}), error:function () {
-			dojo.debug("tunnel opening failed");
-		}});
-		this.connected = true;
-	};
-	this.processBacklog = function () {
-		while (this.backlog.length > 0) {
-			this.sendMessage(this.backlog.shift(), true);
-		}
-	};
-	this.sendMessage = function (message, bypassBacklog) {
-		if ((bypassBacklog) || (this.connected)) {
-			message.connectionId = this.connectionId;
-			message.clientId = cometd.clientId;
-			var bindArgs = {url:cometd.url || djConfig["cometdRoot"], method:"post", mimetype:"text/json", content:{message:dojo.json.serialize([message])}, load:dojo.lang.hitch(this, function (type, data, evt, args) {
-				cometd.deliver(data);
-			})};
-			return dojo.io.bind(bindArgs);
-		} else {
-			this.backlog.push(message);
-		}
-	};
-	this.startup = function (handshakeData) {
-		if (this.connected) {
-			return;
-		}
-		this.tunnelInit();
-	};
-};
-cometd.callbackPollTransport = new function () {
-	this.connected = false;
-	this.connectionId = null;
-	this.authToken = null;
-	this.lastTimestamp = null;
-	this.lastId = null;
-	this.backlog = [];
-	this.check = function (types, version, xdomain) {
-		return dojo.lang.inArray(types, "callback-polling");
-	};
-	this.tunnelInit = function () {
-		if (this.connected) {
-			return;
-		}
-		this.openTunnelWith({message:dojo.json.serialize([{channel:"/meta/connect", clientId:cometd.clientId, connectionType:"callback-polling"}])});
-		this.connected = true;
-	};
-	this.tunnelCollapse = function () {
-		if (!this.connected) {
-			this.connected = false;
-			this.openTunnelWith({message:dojo.json.serialize([{channel:"/meta/reconnect", connectionType:"long-polling", clientId:cometd.clientId, connectionId:this.connectionId, timestamp:this.lastTimestamp, id:this.lastId}])});
-		}
-	};
-	this.deliver = cometd.iframeTransport.deliver;
-	this.openTunnelWith = function (content, url) {
-		var req = dojo.io.bind({url:(url || cometd.url), content:content, mimetype:"text/json", transport:"ScriptSrcTransport", jsonParamName:"jsonp", load:dojo.lang.hitch(this, function (type, data, evt, args) {
-			cometd.deliver(data);
-			this.connected = false;
-			this.tunnelCollapse();
-		}), error:function () {
-			dojo.debug("tunnel opening failed");
-		}});
-		this.connected = true;
-	};
-	this.processBacklog = function () {
-		while (this.backlog.length > 0) {
-			this.sendMessage(this.backlog.shift(), true);
-		}
-	};
-	this.sendMessage = function (message, bypassBacklog) {
-		if ((bypassBacklog) || (this.connected)) {
-			message.connectionId = this.connectionId;
-			message.clientId = cometd.clientId;
-			var bindArgs = {url:cometd.url || djConfig["cometdRoot"], mimetype:"text/json", transport:"ScriptSrcTransport", jsonParamName:"jsonp", content:{message:dojo.json.serialize([message])}, load:dojo.lang.hitch(this, function (type, data, evt, args) {
-				cometd.deliver(data);
-			})};
-			return dojo.io.bind(bindArgs);
-		} else {
-			this.backlog.push(message);
-		}
-	};
-	this.startup = function (handshakeData) {
-		if (this.connected) {
-			return;
-		}
-		this.tunnelInit();
-	};
-};
-cometd.connectionTypes.register("mime-message-block", cometd.mimeReplaceTransport.check, cometd.mimeReplaceTransport);
-cometd.connectionTypes.register("long-polling", cometd.longPollTransport.check, cometd.longPollTransport);
-cometd.connectionTypes.register("callback-polling", cometd.callbackPollTransport.check, cometd.callbackPollTransport);
-cometd.connectionTypes.register("iframe", cometd.iframeTransport.check, cometd.iframeTransport);
-dojo.io.cometd = cometd;
-

Deleted: tags/parley-0.53/root/static/magic/src/io/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,232 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.io.common");
-dojo.require("dojo.string");
-dojo.require("dojo.lang.extras");
-dojo.io.transports = [];
-dojo.io.hdlrFuncNames = ["load", "error", "timeout"];
-dojo.io.Request = function (url, mimetype, transport, changeUrl) {
-	if ((arguments.length == 1) && (arguments[0].constructor == Object)) {
-		this.fromKwArgs(arguments[0]);
-	} else {
-		this.url = url;
-		if (mimetype) {
-			this.mimetype = mimetype;
-		}
-		if (transport) {
-			this.transport = transport;
-		}
-		if (arguments.length >= 4) {
-			this.changeUrl = changeUrl;
-		}
-	}
-};
-dojo.lang.extend(dojo.io.Request, {url:"", mimetype:"text/plain", method:"GET", content:undefined, transport:undefined, changeUrl:undefined, formNode:undefined, sync:false, bindSuccess:false, useCache:false, preventCache:false, jsonFilter:function (value) {
-	if ((this.mimetype == "text/json-comment-filtered") || (this.mimetype == "application/json-comment-filtered")) {
-		var cStartIdx = value.indexOf("/*");
-		var cEndIdx = value.lastIndexOf("*/");
-		if ((cStartIdx == -1) || (cEndIdx == -1)) {
-			dojo.debug("your JSON wasn't comment filtered!");
-			return "";
-		}
-		return value.substring(cStartIdx + 2, cEndIdx);
-	}
-	dojo.debug("please consider using a mimetype of text/json-comment-filtered to avoid potential security issues with JSON endpoints");
-	return value;
-}, load:function (type, data, transportImplementation, kwArgs) {
-}, error:function (type, error, transportImplementation, kwArgs) {
-}, timeout:function (type, empty, transportImplementation, kwArgs) {
-}, handle:function (type, data, transportImplementation, kwArgs) {
-}, timeoutSeconds:0, abort:function () {
-}, fromKwArgs:function (kwArgs) {
-	if (kwArgs["url"]) {
-		kwArgs.url = kwArgs.url.toString();
-	}
-	if (kwArgs["formNode"]) {
-		kwArgs.formNode = dojo.byId(kwArgs.formNode);
-	}
-	if (!kwArgs["method"] && kwArgs["formNode"] && kwArgs["formNode"].method) {
-		kwArgs.method = kwArgs["formNode"].method;
-	}
-	if (!kwArgs["handle"] && kwArgs["handler"]) {
-		kwArgs.handle = kwArgs.handler;
-	}
-	if (!kwArgs["load"] && kwArgs["loaded"]) {
-		kwArgs.load = kwArgs.loaded;
-	}
-	if (!kwArgs["changeUrl"] && kwArgs["changeURL"]) {
-		kwArgs.changeUrl = kwArgs.changeURL;
-	}
-	kwArgs.encoding = dojo.lang.firstValued(kwArgs["encoding"], djConfig["bindEncoding"], "");
-	kwArgs.sendTransport = dojo.lang.firstValued(kwArgs["sendTransport"], djConfig["ioSendTransport"], false);
-	var isFunction = dojo.lang.isFunction;
-	for (var x = 0; x < dojo.io.hdlrFuncNames.length; x++) {
-		var fn = dojo.io.hdlrFuncNames[x];
-		if (kwArgs[fn] && isFunction(kwArgs[fn])) {
-			continue;
-		}
-		if (kwArgs["handle"] && isFunction(kwArgs["handle"])) {
-			kwArgs[fn] = kwArgs.handle;
-		}
-	}
-	dojo.lang.mixin(this, kwArgs);
-}});
-dojo.io.Error = function (msg, type, num) {
-	this.message = msg;
-	this.type = type || "unknown";
-	this.number = num || 0;
-};
-dojo.io.transports.addTransport = function (name) {
-	this.push(name);
-	this[name] = dojo.io[name];
-};
-dojo.io.bind = function (request) {
-	if (!(request instanceof dojo.io.Request)) {
-		try {
-			request = new dojo.io.Request(request);
-		}
-		catch (e) {
-			dojo.debug(e);
-		}
-	}
-	var tsName = "";
-	if (request["transport"]) {
-		tsName = request["transport"];
-		if (!this[tsName]) {
-			dojo.io.sendBindError(request, "No dojo.io.bind() transport with name '" + request["transport"] + "'.");
-			return request;
-		}
-		if (!this[tsName].canHandle(request)) {
-			dojo.io.sendBindError(request, "dojo.io.bind() transport with name '" + request["transport"] + "' cannot handle this type of request.");
-			return request;
-		}
-	} else {
-		for (var x = 0; x < dojo.io.transports.length; x++) {
-			var tmp = dojo.io.transports[x];
-			if ((this[tmp]) && (this[tmp].canHandle(request))) {
-				tsName = tmp;
-				break;
-			}
-		}
-		if (tsName == "") {
-			dojo.io.sendBindError(request, "None of the loaded transports for dojo.io.bind()" + " can handle the request.");
-			return request;
-		}
-	}
-	this[tsName].bind(request);
-	request.bindSuccess = true;
-	return request;
-};
-dojo.io.sendBindError = function (request, message) {
-	if ((typeof request.error == "function" || typeof request.handle == "function") && (typeof setTimeout == "function" || typeof setTimeout == "object")) {
-		var errorObject = new dojo.io.Error(message);
-		setTimeout(function () {
-			request[(typeof request.error == "function") ? "error" : "handle"]("error", errorObject, null, request);
-		}, 50);
-	} else {
-		dojo.raise(message);
-	}
-};
-dojo.io.queueBind = function (request) {
-	if (!(request instanceof dojo.io.Request)) {
-		try {
-			request = new dojo.io.Request(request);
-		}
-		catch (e) {
-			dojo.debug(e);
-		}
-	}
-	var oldLoad = request.load;
-	request.load = function () {
-		dojo.io._queueBindInFlight = false;
-		var ret = oldLoad.apply(this, arguments);
-		dojo.io._dispatchNextQueueBind();
-		return ret;
-	};
-	var oldErr = request.error;
-	request.error = function () {
-		dojo.io._queueBindInFlight = false;
-		var ret = oldErr.apply(this, arguments);
-		dojo.io._dispatchNextQueueBind();
-		return ret;
-	};
-	dojo.io._bindQueue.push(request);
-	dojo.io._dispatchNextQueueBind();
-	return request;
-};
-dojo.io._dispatchNextQueueBind = function () {
-	if (!dojo.io._queueBindInFlight) {
-		dojo.io._queueBindInFlight = true;
-		if (dojo.io._bindQueue.length > 0) {
-			dojo.io.bind(dojo.io._bindQueue.shift());
-		} else {
-			dojo.io._queueBindInFlight = false;
-		}
-	}
-};
-dojo.io._bindQueue = [];
-dojo.io._queueBindInFlight = false;
-dojo.io.argsFromMap = function (map, encoding, last) {
-	var enc = /utf/i.test(encoding || "") ? encodeURIComponent : dojo.string.encodeAscii;
-	var mapped = [];
-	var control = new Object();
-	for (var name in map) {
-		var domap = function (elt) {
-			var val = enc(name) + "=" + enc(elt);
-			mapped[(last == name) ? "push" : "unshift"](val);
-		};
-		if (!control[name]) {
-			var value = map[name];
-			if (dojo.lang.isArray(value)) {
-				dojo.lang.forEach(value, domap);
-			} else {
-				domap(value);
-			}
-		}
-	}
-	return mapped.join("&");
-};
-dojo.io.setIFrameSrc = function (iframe, src, replace) {
-	try {
-		var r = dojo.render.html;
-		if (!replace) {
-			if (r.safari) {
-				iframe.location = src;
-			} else {
-				frames[iframe.name].location = src;
-			}
-		} else {
-			var idoc;
-			if (r.ie) {
-				idoc = iframe.contentWindow.document;
-			} else {
-				if (r.safari) {
-					idoc = iframe.document;
-				} else {
-					idoc = iframe.contentWindow;
-				}
-			}
-			if (!idoc) {
-				iframe.location = src;
-				return;
-			} else {
-				idoc.location.replace(src);
-			}
-		}
-	}
-	catch (e) {
-		dojo.debug(e);
-		dojo.debug("setIFrameSrc: " + e);
-	}
-};
-

Modified: tags/parley-0.53/root/static/magic/src/io/cookie.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/cookie.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/cookie.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,97 +8,101 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.io.cookie");
 
-
-dojo.provide("dojo.io.cookie");
-dojo.io.cookie.setCookie = function (name, value, days, path, domain, secure) {
+dojo.io.cookie.setCookie = function(name, value, days, path, domain, secure) {
 	var expires = -1;
-	if ((typeof days == "number") && (days >= 0)) {
+	if(typeof days == "number" && days >= 0) {
 		var d = new Date();
-		d.setTime(d.getTime() + (days * 24 * 60 * 60 * 1000));
+		d.setTime(d.getTime()+(days*24*60*60*1000));
 		expires = d.toGMTString();
 	}
 	value = escape(value);
-	document.cookie = name + "=" + value + ";" + (expires != -1 ? " expires=" + expires + ";" : "") + (path ? "path=" + path : "") + (domain ? "; domain=" + domain : "") + (secure ? "; secure" : "");
-};
+	document.cookie = name + "=" + value + ";"
+		+ (expires != -1 ? " expires=" + expires + ";" : "")
+		+ (path ? "path=" + path : "")
+		+ (domain ? "; domain=" + domain : "")
+		+ (secure ? "; secure" : "");
+}
+
 dojo.io.cookie.set = dojo.io.cookie.setCookie;
-dojo.io.cookie.getCookie = function (name) {
-	var idx = document.cookie.lastIndexOf(name + "=");
-	if (idx == -1) {
-		return null;
-	}
-	var value = document.cookie.substring(idx + name.length + 1);
-	var end = value.indexOf(";");
-	if (end == -1) {
-		end = value.length;
-	}
+
+dojo.io.cookie.getCookie = function(name) {
+	// FIXME: Which cookie should we return?
+	//        If there are cookies set for different sub domains in the current
+	//        scope there could be more than one cookie with the same name.
+	//        I think taking the last one in the list takes the one from the
+	//        deepest subdomain, which is what we're doing here.
+	var idx = document.cookie.lastIndexOf(name+'=');
+	if(idx == -1) { return null; }
+	var value = document.cookie.substring(idx+name.length+1);
+	var end = value.indexOf(';');
+	if(end == -1) { end = value.length; }
 	value = value.substring(0, end);
 	value = unescape(value);
 	return value;
-};
+}
+
 dojo.io.cookie.get = dojo.io.cookie.getCookie;
-dojo.io.cookie.deleteCookie = function (name) {
+
+dojo.io.cookie.deleteCookie = function(name) {
 	dojo.io.cookie.setCookie(name, "-", 0);
-};
-dojo.io.cookie.setObjectCookie = function (name, obj, days, path, domain, secure, clearCurrent) {
-	if (arguments.length == 5) {
+}
+
+dojo.io.cookie.setObjectCookie = function(name, obj, days, path, domain, secure, clearCurrent) {
+	if(arguments.length == 5) { // for backwards compat
 		clearCurrent = domain;
 		domain = null;
 		secure = null;
 	}
 	var pairs = [], cookie, value = "";
-	if (!clearCurrent) {
-		cookie = dojo.io.cookie.getObjectCookie(name);
-	}
-	if (days >= 0) {
-		if (!cookie) {
-			cookie = {};
-		}
-		for (var prop in obj) {
-			if (obj[prop] == null) {
+	if(!clearCurrent) { cookie = dojo.io.cookie.getObjectCookie(name); }
+	if(days >= 0) {
+		if(!cookie) { cookie = {}; }
+		for(var prop in obj) {
+			if(prop == null) {
 				delete cookie[prop];
-			} else {
-				if ((typeof obj[prop] == "string") || (typeof obj[prop] == "number")) {
-					cookie[prop] = obj[prop];
-				}
+			} else if(typeof obj[prop] == "string" || typeof obj[prop] == "number") {
+				cookie[prop] = obj[prop];
 			}
 		}
 		prop = null;
-		for (var prop in cookie) {
+		for(var prop in cookie) {
 			pairs.push(escape(prop) + "=" + escape(cookie[prop]));
 		}
 		value = pairs.join("&");
 	}
 	dojo.io.cookie.setCookie(name, value, days, path, domain, secure);
-};
-dojo.io.cookie.getObjectCookie = function (name) {
+}
+
+dojo.io.cookie.getObjectCookie = function(name) {
 	var values = null, cookie = dojo.io.cookie.getCookie(name);
-	if (cookie) {
+	if(cookie) {
 		values = {};
 		var pairs = cookie.split("&");
-		for (var i = 0; i < pairs.length; i++) {
+		for(var i = 0; i < pairs.length; i++) {
 			var pair = pairs[i].split("=");
 			var value = pair[1];
-			if (isNaN(value)) {
-				value = unescape(pair[1]);
-			}
-			values[unescape(pair[0])] = value;
+			if( isNaN(value) ) { value = unescape(pair[1]); }
+			values[ unescape(pair[0]) ] = value;
 		}
 	}
 	return values;
-};
-dojo.io.cookie.isSupported = function () {
-	if (typeof navigator.cookieEnabled != "boolean") {
-		dojo.io.cookie.setCookie("__TestingYourBrowserForCookieSupport__", "CookiesAllowed", 90, null);
+}
+
+dojo.io.cookie.isSupported = function() {
+	if(typeof navigator.cookieEnabled != "boolean") {
+		dojo.io.cookie.setCookie("__TestingYourBrowserForCookieSupport__",
+			"CookiesAllowed", 90, null);
 		var cookieVal = dojo.io.cookie.getCookie("__TestingYourBrowserForCookieSupport__");
 		navigator.cookieEnabled = (cookieVal == "CookiesAllowed");
-		if (navigator.cookieEnabled) {
+		if(navigator.cookieEnabled) {
+			// FIXME: should we leave this around?
 			this.deleteCookie("__TestingYourBrowserForCookieSupport__");
 		}
 	}
 	return navigator.cookieEnabled;
-};
-if (!dojo.io.cookies) {
-	dojo.io.cookies = dojo.io.cookie;
 }
 
+// need to leave this in for backwards-compat from 0.1 for when it gets pulled in by dojo.io.*
+if(!dojo.io.cookies) { dojo.io.cookies = dojo.io.cookie; }

Added: tags/parley-0.53/root/static/magic/src/io/cookies.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/cookies.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/cookies.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.deprecated("dojo.io.cookies", "replaced by dojo.io.cookie", "0.4");
+dojo.require("dojo.io.cookie");
+if(!dojo.io.cookies) { dojo.io.cookies = dojo.io.cookie; }
+dojo.provide("dojo.io.cookies");

Deleted: tags/parley-0.53/root/static/magic/src/io/xip_client.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/xip_client.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/xip_client.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,267 +0,0 @@
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
-	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
-
-<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
-<head>
-	<title></title>
-	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
-	<!-- Security protection: uncomment the script tag to enable. -->
-	<!-- script type="text/javascript" -->
-	// <!--
-	/*
-	This file is really focused on just sending one message to the server, and
-	receiving one response. The code does not expect to be re-used for multiple messages.
-	This might be reworked later if performance indicates a need for it.
-	
-	xip fragment identifier/hash values have the form:
-	#id:cmd:realEncodedMessage
-
-	id: some ID that should be unique among messages. No inherent meaning,
-	        just something to make sure the hash value is unique so the message
-	        receiver knows a new message is available.
-	        
-	cmd: command to the receiver. Valid values are:
-	         - init: message used to init the frame. Sent as the first URL when loading
-	                 the page. Contains some config parameters.
-	         - loaded: the remote frame is loaded. Only sent from server to client.
-	         - ok: the message that this page sent was received OK. The next message may
-	               now be sent.
-	         - start: the start message of a block of messages (a complete message may
-	                  need to be segmented into many messages to get around the limitiations
-	                  of the size of an URL that a browser accepts.
-	         - part: indicates this is a part of a message.
-	         - end: the end message of a block of messages. The message can now be acted upon.
-	                If the message is small enough that it doesn't need to be segmented, then
-	                just one hash value message can be sent with "end" as the command.
-	
-	To reassemble a segmented message, the realEncodedMessage parts just have to be concatenated
-	together.
-	*/
-
-	//MSIE has the lowest limit for URLs with fragment identifiers,
-	//at around 4K. Choosing a slightly smaller number for good measure.
-	xipUrlLimit = 4000;
-	xipIdCounter = 1;
-
-	function xipInit(){
-		xipStateId = "";
-		xipIsSending = false;
-		xipServerUrl = null;
-		xipStateId = null;
-		xipRequestData = null;
-		xipCurrentHash = "";
-		xipResponseMessage = "";
-		xipRequestParts = [];
-		xipPartIndex = 0;
-		xipServerWindow = null;
-		xipUseFrameRecursion = false;
-	}
-	xipInit();
-	
-	function send(encodedData){
-		if(xipUseFrameRecursion == "true"){
-			var clientEndPoint = window.open(xipStateId + "_clientEndPoint");
-			clientEndPoint.send(encodedData);
-		}else{
-			if(!xipIsSending){
-				xipIsSending = true;
-	
-				xipRequestData = encodedData || "";
-
-				//Get a handle to the server iframe.
-				xipServerWindow = frames[xipStateId + "_frame"];
-				if (!xipServerWindow){
-					xipServerWindow = document.getElementById(xipStateId + "_frame").contentWindow;
-				}
-	
-				sendRequestStart();
-			}
-		}
-	}
-
-	//Modify the server URL if it is a local path and 
-	//This is done for local/same domain testing.
-	function fixServerUrl(ifpServerUrl){
-		if(ifpServerUrl.indexOf("..") == 0){
-			var parts = ifpServerUrl.split("/");
-			ifpServerUrl = parts[parts.length - 1];
-		}
-		return ifpServerUrl;
-	}
-	
-	
-	function pollHash(){
-		//Can't use location.hash because at least Firefox does a decodeURIComponent on it.
-		var urlParts = window.location.href.split("#");
-		if(urlParts.length == 2){
-			var newHash = urlParts[1];
-			if(newHash != xipCurrentHash){
-				try{
-					messageReceived(newHash);
-				}catch(e){
-					//Make sure to not keep processing the error hash value.
-					xipCurrentHash = newHash;
-					throw e;
-				}
-				xipCurrentHash = newHash;
-			}
-		}
-	}
-
-	function messageReceived(encodedData){
-		var msg = unpackMessage(encodedData);
-
-		switch(msg.command){
-			case "loaded":
-				xipMasterFrame.dojo.io.XhrIframeProxy.clientFrameLoaded(xipStateId);
-				break;
-			case "ok":
-				sendRequestPart();
-				break;
-			case "start":
-				xipResponseMessage = "";
-				xipResponseMessage += msg.message;
-				setServerUrl("ok");
-				break;
-			case "part":
-				xipResponseMessage += msg.message;			
-				setServerUrl("ok");
-				break;
-			case "end":
-				setServerUrl("ok");
-				xipResponseMessage += msg.message;
-				xipMasterFrame.dojo.io.XhrIframeProxy.receive(xipStateId, xipResponseMessage);
-				break;
-		}
-	}
-	
-	function sendRequestStart(){
-		//Break the message into parts, if necessary.
-		xipRequestParts = [];
-		var reqData = xipRequestData;
-		var urlLength = xipServerUrl.length;
-		var partLength = xipUrlLimit - urlLength;
-		var reqIndex = 0;
-
-		while((reqData.length - reqIndex) + urlLength > xipUrlLimit){
-			var part = reqData.substring(reqIndex, reqIndex + partLength);
-			//Safari will do some extra hex escaping unless we keep the original hex
-			//escaping complete.
-			var percentIndex = part.lastIndexOf("%");
-			if(percentIndex == part.length - 1 || percentIndex == part.length - 2){
-				part = part.substring(0, percentIndex);
-			}
-			xipRequestParts.push(part);
-			reqIndex += part.length;
-		}
-		xipRequestParts.push(reqData.substring(reqIndex, reqData.length));
-		
-		xipPartIndex = 0;
-		sendRequestPart();
-		
-	}
-	
-	function sendRequestPart(){
-		if(xipPartIndex < xipRequestParts.length){
-			//Get the message part.
-			var partData = xipRequestParts[xipPartIndex];
-
-			//Get the command.
-			var cmd = "part";
-			if(xipPartIndex + 1 == xipRequestParts.length){
-				cmd = "end";
-			}else if (xipPartIndex == 0){
-				cmd = "start";
-			}
-			
-			setServerUrl(cmd, partData);
-			xipPartIndex++;
-		}
-	}
-	
-	function setServerUrl(cmd, message){
-		var serverUrl = makeServerUrl(cmd, message);
-
-		//Safari won't let us replace across domains.
-		if(navigator.userAgent.indexOf("Safari") == -1){
-			xipServerWindow.location.replace(serverUrl);
-		}else{
-			xipServerWindow.location = serverUrl;
-		}
-	}
-	
-	function makeServerUrl(cmd, message){
-		var serverUrl = xipServerUrl + "#" + (xipIdCounter++) + ":" + cmd;
-		if(message){
-			serverUrl += ":" + message;
-		}
-		return serverUrl;
-	}
-
-	function unpackMessage(encodedMessage){
-		var parts = encodedMessage.split(":");
-		var command = parts[1];
-		encodedMessage = parts[2] || "";
-
-		var config = null;
-		if(command == "init"){
-			var configParts = encodedMessage.split("&");
-			config = {};
-			for(var i = 0; i < configParts.length; i++){
-				var nameValue = configParts[i].split("=");
-				config[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);
-			}
-		}
-		return {command: command, message: encodedMessage, config: config};
-	}
-
-	function onClientLoad(){
-		//Decode the init params
-		var config = unpackMessage(window.location.href.split("#")[1]).config;
-
-		xipStateId = config.id;
-
-		//Remove the query param for the IE7 recursive case.
-		xipServerUrl = fixServerUrl(config.server).replace(/(\?|\&)dojo\.fr\=1/, "");
-		
-		//Make sure we don't have a javascript: url, just for good measure.
-		if(xipServerUrl.split(":")[0].match(/javascript/i)){
-			throw "Invalid server URL";
-		}
-
-		xipUseFrameRecursion = config["fr"];
-		
-		if(xipUseFrameRecursion == "endpoint"){
-			xipMasterFrame = parent.parent;
-		}else{
-			xipMasterFrame = parent;
-		}
-		
-		//Start counter to inspect hash value.
-		setInterval(pollHash, 10);
-
-		var clientUrl = window.location.href.split("#")[0];
-		var iframeNode = document.getElementsByTagName("iframe")[0];
-		iframeNode.id = xipStateId + "_frame";
-		iframeNode.src = makeServerUrl("init", 'id=' + xipStateId + '&client='
-			+ encodeURIComponent(clientUrl) + '&fr=' + xipUseFrameRecursion);
-	}
-
-	if(typeof(window.addEventListener) == "undefined"){
-		window.attachEvent("onload", onClientLoad);
-	}else{
-		window.addEventListener('load', onClientLoad, false);
-	}
-	
-	// -->
-	</script>
-</head>
-<body>
-	<h4>The Dojo Toolkit -- xip_client.html</h4>
-
-	<p>This file is used for Dojo's XMLHttpRequest Iframe Proxy. This is the "client" file used
-	internally by dojo.io.XhrIframeProxy.</p>
-	
-	<iframe src="javascript:false"></iframe>
-</body>
-</html>

Deleted: tags/parley-0.53/root/static/magic/src/io/xip_server.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/io/xip_server.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io/xip_server.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,386 +0,0 @@
-<!--
-	/*
-		Copyright (c) 2004-2006, The Dojo Foundation
-		All Rights Reserved.
-	
-		Licensed under the Academic Free License version 2.1 or above OR the
-		modified BSD license. For more information on Dojo licensing, see:
-	
-			http://dojotoolkit.org/community/licensing.shtml
-	*/
-	Pieces taken from Dojo source to make this file stand-alone
--->
-<html>
-<head>
-	<title></title>
-	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"></meta>
-	<script type="text/javascript" src="isAllowed.js"></script>
-	<!--
-	BY DEFAULT THIS FILE DOES NOT WORK SO THAT YOU DON'T ACCIDENTALLY EXPOSE
-	ALL OF YOUR XHR-ENABLED SERVICES ON YOUR SITE. 
-	
-	In order for this file to work, you need to uncomment the script element,
-	and you should define a function with the following signature:
-	
-	function isAllowedRequest(request){
-		return false;	
-	}
-	
-	Return true out of the function if you want to allow the cross-domain request.
-	
-	DON'T DEFINE THIS FUNCTION IN THIS FILE! Define it in a separate file called isAllowed.js
-	and include it in this page with a script tag that has a src attribute pointing to the file.
-	See the very first script tag in this file for an example. You do not have to place the
-	script file in the same directory as this file, just update the path above if you move it
-	somewhere else.
-	
-	Customize the isAllowedRequest function to restrict what types of requests are allowed
-	for this server. The request object has the following properties:
-	- requestHeaders: an object with the request headers that are to be added to
-	                  the XHR request.
-	- method: the HTTP method (GET, POST, etc...)
-	- uri: The URI for the request.
-	- data: The URL-encoded data for the request. For a GET request, this would
-	        be the querystring parameters. For a POST request, it wll be the
-	        body data.
-	        
-	See xip_client.html for more info on the xip fragment identifier protocol.	
-	-->
-	
-	<!-- Security protection: uncomment the script tag to enable. -->
-	<!-- script type="text/javascript" -->
-	// <!--
-		//Core XHR handling taken from Dojo IO code.
-		dojo = {};
-		dojo.hostenv = {};
-		// These are in order of decreasing likelihood; this will change in time.
-		dojo.hostenv._XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
-		
-		dojo.hostenv.getXmlhttpObject = function(){
-				var http = null;
-			var last_e = null;
-			try{ http = new XMLHttpRequest(); }catch(e){}
-				if(!http){
-				for(var i=0; i<3; ++i){
-					var progid = dojo.hostenv._XMLHTTP_PROGIDS[i];
-					try{
-						http = new ActiveXObject(progid);
-					}catch(e){
-						last_e = e;
-					}
-		
-					if(http){
-						dojo.hostenv._XMLHTTP_PROGIDS = [progid];  // so faster next time
-						break;
-					}
-				}
-		
-				/*if(http && !http.toString) {
-					http.toString = function() { "[object XMLHttpRequest]"; }
-				}*/
-			}
-		
-			if(!http){
-				throw "xip_server.html: XMLHTTP not available: " + last_e;
-			}
-		
-			return http;
-		}
-
-		dojo.setHeaders = function(http, headers){
-			if(headers) {
-				for(var header in headers) {
-					var headerValue = headers[header];
-					http.setRequestHeader(header, headerValue);
-				}
-			}
-		}
-
-	//MSIE has the lowest limit for URLs with fragment identifiers,
-	//at around 4K. Choosing a slightly smaller number for good measure.
-	xipUrlLimit = 4000;
-	xipIdCounter = 1;
-
-	function xipServerInit(){
-		xipStateId = "";
-		xipCurrentHash = "";
-		xipRequestMessage = "";
-		xipResponseParts = [];
-		xipPartIndex = 0;
-	}
-
-	function pollHash(){
-		//Can't use location.hash because at least Firefox does a decodeURIComponent on it.
-		var urlParts = window.location.href.split("#");
-		if(urlParts.length == 2){
-			var newHash = urlParts[1];
-			if(newHash != xipCurrentHash){
-				try{
-					messageReceived(newHash);
-				}catch(e){
-					//Make sure to not keep processing the error hash value.
-					xipCurrentHash = newHash;
-					throw e;
-				}
-				xipCurrentHash = newHash;
-			}
-		}
-	}
-
-	function messageReceived(encodedData){
-		var msg = unpackMessage(encodedData);
-		
-		switch(msg.command){
-			case "ok":
-				sendResponsePart();
-				break;
-			case "start":
-				xipRequestMessage = "";
-				xipRequestMessage += msg.message;
-				setClientUrl("ok");
-				break;
-			case "part":
-				xipRequestMessage += msg.message;			
-				setClientUrl("ok");
-				break;
-			case "end":
-				setClientUrl("ok");
-				xipRequestMessage += msg.message;
-				sendXhr();
-				break;
-		}
-	}
-
-	function sendResponse(encodedData){
-		//Break the message into parts, if necessary.
-		xipResponseParts = [];
-		var resData = encodedData;
-		var urlLength = xipClientUrl.length;
-		var partLength = xipUrlLimit - urlLength;
-		var resIndex = 0;
-
-		while((resData.length - resIndex) + urlLength > xipUrlLimit){
-			var part = resData.substring(resIndex, resIndex + partLength);
-			//Safari will do some extra hex escaping unless we keep the original hex
-			//escaping complete.
-			var percentIndex = part.lastIndexOf("%");
-			if(percentIndex == part.length - 1 || percentIndex == part.length - 2){
-				part = part.substring(0, percentIndex);
-			}
-			xipResponseParts.push(part);
-			resIndex += part.length;
-		}
-		xipResponseParts.push(resData.substring(resIndex, resData.length));
-		
-		xipPartIndex = 0;
-		sendResponsePart();
-	}
-	
-	function sendResponsePart(){
-		if(xipPartIndex < xipResponseParts.length){
-			//Get the message part.
-			var partData = xipResponseParts[xipPartIndex];
-			
-			//Get the command.
-			var cmd = "part";
-			if(xipPartIndex + 1 == xipResponseParts.length){
-				cmd = "end";
-			}else if (xipPartIndex == 0){
-				cmd = "start";
-			}
-
-			setClientUrl(cmd, partData);
-			xipPartIndex++;
-		}else{
-			xipServerInit();
-		}
-	}
-
-	function setClientUrl(cmd, message){
-		var clientUrl = makeClientUrl(cmd, message);
-		//Safari won't let us replace across domains.
-		if(navigator.userAgent.indexOf("Safari") == -1){
-			parent.location.replace(clientUrl);
-		}else{
-			parent.location = clientUrl;
-		}
-	}
-
-	function makeClientUrl(cmd, message){
-		var clientUrl = xipClientUrl + "#" + (xipIdCounter++) + ":" + cmd;
-		if(message){
-			clientUrl += ":" + message;
-		}
-		return clientUrl
-	}
-
-	function xhrDone(xhr){
-		/* Need to pull off and return the following data:
-			- responseHeaders
-			- status
-			- statusText
-			- responseText
-		*/
-		var response = {};
-	
-		if(typeof(xhr.getAllResponseHeaders) != "undefined"){
-			var allHeaders = xhr.getAllResponseHeaders();
-			if(allHeaders){
-				response.responseHeaders = allHeaders;
-			}
-		}
-		
-		if(xhr.status == 0 || xhr.status){
-			response.status = xhr.status;
-		}
-		
-		if(xhr.statusText){
-			response.statusText = xhr.statusText;
-		}
-		
-		if(xhr.responseText){
-			response.responseText = xhr.responseText;
-		}
-	
-		//Build a string of the response object.
-		var result = "";
-		var isFirst = true;
-		for (var param in response){
-			if(isFirst){
-				isFirst = false;
-			}else{
-				result += "&";
-			}
-			result += param + "=" + encodeURIComponent(response[param]);
-		}
-		sendResponse(result);
-	}
-
-	function sendXhr(){
-		var request = {};
-		var nvPairs = xipRequestMessage.split("&");
-		var i = 0;
-		var nameValue = null;
-		for(i = 0; i < nvPairs.length; i++){
-			if(nvPairs[i]){
-				var nameValue = nvPairs[i].split("=");
-				request[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);
-			}
-		}
-
-		//Split up the request headers, if any.
-		var headers = {};
-		if(request.requestHeaders){
-			nvPairs = request.requestHeaders.split("\r\n");
-			for(i = 0; i < nvPairs.length; i++){
-				if(nvPairs[i]){
-					nameValue = nvPairs[i].split(": ");
-					headers[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);
-				}
-			}
-
-			request.requestHeaders = headers;
-		}
-		
-		if(isAllowedRequest(request)){
-		
-			//The request is allowed, so set up the XHR object.
-			var xhr = dojo.hostenv.getXmlhttpObject();
-			
-			//Start timer to look for readyState.
-			var xhrIntervalId = setInterval(function(){
-			
-				if(xhr.readyState == 4){
-					clearInterval(xhrIntervalId);
-					xhrDone(xhr);
-				}
-			}, 10);
-
-			//Actually start up the XHR request.
-			xhr.open(request.method, request.uri, true);
-			dojo.setHeaders(xhr, request.requestHeaders);
-			
-			var content = "";
-			if(request.data){
-				content = request.data;
-			}
-
-			try{
-				xhr.send(content);
-			}catch(e){
-				if(typeof xhr.abort == "function"){
-					xhr.abort();
-					xhrDone({status: 404, statusText: "xip_server.html error: " + e});
-				}
-			}
-		}
-	}
-
-	function unpackMessage(encodedMessage){
-		var parts = encodedMessage.split(":");
-		var command = parts[1];
-		encodedMessage = parts[2] || "";
-
-		var config = null;
-		if(command == "init"){
-			var configParts = encodedMessage.split("&");
-			config = {};
-			for(var i = 0; i < configParts.length; i++){
-				var nameValue = configParts[i].split("=");
-				config[decodeURIComponent(nameValue[0])] = decodeURIComponent(nameValue[1]);
-			}
-		}
-		return {command: command, message: encodedMessage, config: config};
-	}
-
-	function onServerLoad(){
-		xipServerInit();
-
-		//Decode the init params
-		var config = unpackMessage(window.location.href.split("#")[1]).config;
-
-		xipStateId = config.id;
-		xipClientUrl = config.client;
-		
-		//Make sure we don't have a javascript: url, just for good measure.
-		if(xipClientUrl.split(":")[0].match(/javascript/i)){
-			throw "Invalid client URL";
-		}
-		if(!xipStateId.match(/^XhrIframeProxy[0-9]+$/)){
-			throw "Invalid state ID";
-		}
-
-		xipUseFrameRecursion = config["fr"];
-
-		setInterval(pollHash, 10);
-		
-		if(xipUseFrameRecursion == "true"){
-			var serverUrl = window.location.href.split("#")[0];
-			document.getElementById("iframeHolder").innerHTML = '<iframe name="'
-				+ xipStateId + '_clientEndPoint'
-				+ '" src="javascript:false">'
-				+ '</iframe>';
-			var iframeNode = document.getElementsByTagName("iframe")[0];
-			iframeNode.src = makeClientUrl("init", 'id=' + xipStateId + '&server='
-				+ encodeURIComponent(serverUrl) + '&fr=endpoint');
-		}else{
-			setClientUrl("loaded");
-		}
-	}
-
-	if(typeof(window.addEventListener) == "undefined"){
-		window.attachEvent("onload", onServerLoad);
-	}else{
-		window.addEventListener('load', onServerLoad, false);
-	}
-	// -->
-	</script>
-</head>
-<body>
-	<h4>The Dojo Toolkit -- xip_server.html</h4>
-
-	<p>This file is used for Dojo's XMLHttpRequest Iframe Proxy. This is the the file
-	that should go on the server that will actually be doing the XHR request.</p>
-	<div id="iframeHolder"></div>
-</body>
-</html>

Modified: tags/parley-0.53/root/static/magic/src/io.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/io.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/io.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,369 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.io.IO");
+dojo.require("dojo.string");
+dojo.require("dojo.lang.extras");
 
+/******************************************************************************
+ *	Notes about dojo.io design:
+ *	
+ *	The dojo.io.* package has the unenviable task of making a lot of different
+ *	types of I/O feel natural, despite a universal lack of good (or even
+ *	reasonable!) I/O capability in the host environment. So lets pin this down
+ *	a little bit further.
+ *
+ *	Rhino:
+ *		perhaps the best situation anywhere. Access to Java classes allows you
+ *		to do anything one might want in terms of I/O, both synchronously and
+ *		async. Can open TCP sockets and perform low-latency client/server
+ *		interactions. HTTP transport is available through Java HTTP client and
+ *		server classes. Wish it were always this easy.
+ *
+ *	xpcshell:
+ *		XPCOM for I/O. A cluster-fuck to be sure.
+ *
+ *	spidermonkey:
+ *		S.O.L.
+ *
+ *	Browsers:
+ *		Browsers generally do not provide any useable filesystem access. We are
+ *		therefore limited to HTTP for moving information to and from Dojo
+ *		instances living in a browser.
+ *
+ *		XMLHTTP:
+ *			Sync or async, allows reading of arbitrary text files (including
+ *			JS, which can then be eval()'d), writing requires server
+ *			cooperation and is limited to HTTP mechanisms (POST and GET).
+ *
+ *		<iframe> hacks:
+ *			iframe document hacks allow browsers to communicate asynchronously
+ *			with a server via HTTP POST and GET operations. With significant
+ *			effort and server cooperation, low-latency data transit between
+ *			client and server can be acheived via iframe mechanisms (repubsub).
+ *
+ *		SVG:
+ *			Adobe's SVG viewer implements helpful primitives for XML-based
+ *			requests, but receipt of arbitrary text data seems unlikely w/o
+ *			<![CDATA[]]> sections.
+ *
+ *
+ *	A discussion between Dylan, Mark, Tom, and Alex helped to lay down a lot
+ *	the IO API interface. A transcript of it can be found at:
+ *		http://dojotoolkit.org/viewcvs/viewcvs.py/documents/irc/irc_io_api_log.txt?rev=307&view=auto
+ *	
+ *	Also referenced in the design of the API was the DOM 3 L&S spec:
+ *		http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html
+ ******************************************************************************/
 
-dojo.provide("dojo.io");
-dojo.require("dojo.io.*");
-dojo.deprecated("dojo.io", "replaced by dojo.io.*", "0.5");
+// a map of the available transport options. Transports should add themselves
+// by calling add(name)
+dojo.io.transports = [];
+dojo.io.hdlrFuncNames = [ "load", "error", "timeout" ]; // we're omitting a progress() event for now
 
+dojo.io.Request = function(url, mimetype, transport, changeUrl){
+	if((arguments.length == 1)&&(arguments[0].constructor == Object)){
+		this.fromKwArgs(arguments[0]);
+	}else{
+		this.url = url;
+		if(mimetype){ this.mimetype = mimetype; }
+		if(transport){ this.transport = transport; }
+		if(arguments.length >= 4){ this.changeUrl = changeUrl; }
+	}
+}
+
+dojo.lang.extend(dojo.io.Request, {
+
+	/** The URL to hit */
+	url: "",
+	
+	/** The mime type used to interrpret the response body */
+	mimetype: "text/plain",
+	
+	/** The HTTP method to use */
+	method: "GET",
+	
+	/** An Object containing key-value pairs to be included with the request */
+	content: undefined, // Object
+	
+	/** The transport medium to use */
+	transport: undefined, // String
+	
+	/** If defined the URL of the page is physically changed */
+	changeUrl: undefined, // String
+	
+	/** A form node to use in the request */
+	formNode: undefined, // HTMLFormElement
+	
+	/** Whether the request should be made synchronously */
+	sync: false,
+	
+	bindSuccess: false,
+
+	/** Cache/look for the request in the cache before attempting to request?
+	 *  NOTE: this isn't a browser cache, this is internal and would only cache in-page
+	 */
+	useCache: false,
+
+	/** Prevent the browser from caching this by adding a query string argument to the URL */
+	preventCache: false,
+	
+	// events stuff
+	load: function(type, data, evt){ },
+	error: function(type, error){ },
+	timeout: function(type){ },
+	handle: function(){ },
+
+	//FIXME: change BrowserIO.js to use timeouts? IframeIO?
+	// The number of seconds to wait until firing a timeout callback.
+	// If it is zero, that means, don't do a timeout check.
+	timeoutSeconds: 0,
+	
+	// the abort method needs to be filled in by the transport that accepts the
+	// bind() request
+	abort: function(){ },
+	
+	// backButton: function(){ },
+	// forwardButton: function(){ },
+
+	fromKwArgs: function(kwArgs){
+		// normalize args
+		if(kwArgs["url"]){ kwArgs.url = kwArgs.url.toString(); }
+		if(kwArgs["formNode"]) { kwArgs.formNode = dojo.byId(kwArgs.formNode); }
+		if(!kwArgs["method"] && kwArgs["formNode"] && kwArgs["formNode"].method) {
+			kwArgs.method = kwArgs["formNode"].method;
+		}
+		
+		// backwards compatibility
+		if(!kwArgs["handle"] && kwArgs["handler"]){ kwArgs.handle = kwArgs.handler; }
+		if(!kwArgs["load"] && kwArgs["loaded"]){ kwArgs.load = kwArgs.loaded; }
+		if(!kwArgs["changeUrl"] && kwArgs["changeURL"]) { kwArgs.changeUrl = kwArgs.changeURL; }
+
+		// encoding fun!
+		kwArgs.encoding = dojo.lang.firstValued(kwArgs["encoding"], djConfig["bindEncoding"], "");
+
+		kwArgs.sendTransport = dojo.lang.firstValued(kwArgs["sendTransport"], djConfig["ioSendTransport"], false);
+
+		var isFunction = dojo.lang.isFunction;
+		for(var x=0; x<dojo.io.hdlrFuncNames.length; x++){
+			var fn = dojo.io.hdlrFuncNames[x];
+			if(isFunction(kwArgs[fn])){ continue; }
+			if(isFunction(kwArgs["handle"])){
+				kwArgs[fn] = kwArgs.handle;
+			}
+			// handler is aliased above, shouldn't need this check
+			/* else if(dojo.lang.isObject(kwArgs.handler)){
+				if(isFunction(kwArgs.handler[fn])){
+					kwArgs[fn] = kwArgs.handler[fn]||kwArgs.handler["handle"]||function(){};
+				}
+			}*/
+		}
+		dojo.lang.mixin(this, kwArgs);
+	}
+
+});
+
+dojo.io.Error = function(msg, type, num){
+	this.message = msg;
+	this.type =  type || "unknown"; // must be one of "io", "parse", "unknown"
+	this.number = num || 0; // per-substrate error number, not normalized
+}
+
+dojo.io.transports.addTransport = function(name){
+	this.push(name);
+	// FIXME: do we need to handle things that aren't direct children of the
+	// dojo.io namespace? (say, dojo.io.foo.fooTransport?)
+	this[name] = dojo.io[name];
+}
+
+// binding interface, the various implementations register their capabilities
+// and the bind() method dispatches
+dojo.io.bind = function(request){
+	// if the request asks for a particular implementation, use it
+	if(!(request instanceof dojo.io.Request)){
+		try{
+			request = new dojo.io.Request(request);
+		}catch(e){ dojo.debug(e); }
+	}
+	var tsName = "";
+	if(request["transport"]){
+		tsName = request["transport"];
+		// FIXME: it would be good to call the error handler, although we'd
+		// need to use setTimeout or similar to accomplish this and we can't
+		// garuntee that this facility is available.
+		if(!this[tsName]){ return request; }
+	}else{
+		// otherwise we do our best to auto-detect what available transports
+		// will handle 
+		for(var x=0; x<dojo.io.transports.length; x++){
+			var tmp = dojo.io.transports[x];
+			if((this[tmp])&&(this[tmp].canHandle(request))){
+				tsName = tmp;
+			}
+		}
+		if(tsName == ""){ return request; }
+	}
+	this[tsName].bind(request);
+	request.bindSuccess = true;
+	return request;
+}
+
+dojo.io.queueBind = function(request){
+	if(!(request instanceof dojo.io.Request)){
+		try{
+			request = new dojo.io.Request(request);
+		}catch(e){ dojo.debug(e); }
+	}
+
+	// make sure we get called if/when we get a response
+	var oldLoad = request.load;
+	request.load = function(){
+		dojo.io._queueBindInFlight = false;
+		var ret = oldLoad.apply(this, arguments);
+		dojo.io._dispatchNextQueueBind();
+		return ret;
+	}
+
+	var oldErr = request.error;
+	request.error = function(){
+		dojo.io._queueBindInFlight = false;
+		var ret = oldErr.apply(this, arguments);
+		dojo.io._dispatchNextQueueBind();
+		return ret;
+	}
+
+	dojo.io._bindQueue.push(request);
+	dojo.io._dispatchNextQueueBind();
+	return request;
+}
+
+dojo.io._dispatchNextQueueBind = function(){
+	if(!dojo.io._queueBindInFlight){
+		dojo.io._queueBindInFlight = true;
+		if(dojo.io._bindQueue.length > 0){
+			dojo.io.bind(dojo.io._bindQueue.shift());
+		}else{
+			dojo.io._queueBindInFlight = false;
+		}
+	}
+}
+dojo.io._bindQueue = [];
+dojo.io._queueBindInFlight = false;
+
+dojo.io.argsFromMap = function(map, encoding, last){
+	var enc = /utf/i.test(encoding||"") ? encodeURIComponent : dojo.string.encodeAscii;
+	var mapped = [];
+	var control = new Object();
+	for(var name in map){
+		var domap = function(elt){
+			var val = enc(name)+"="+enc(elt);
+			mapped[(last == name) ? "push" : "unshift"](val);
+		}
+		if(!control[name]){
+			var value = map[name];
+			// FIXME: should be isArrayLike?
+			if (dojo.lang.isArray(value)){
+				dojo.lang.forEach(value, domap);
+			}else{
+				domap(value);
+			}
+		}
+	}
+	return mapped.join("&");
+}
+
+dojo.io.setIFrameSrc = function(iframe, src, replace){
+	try{
+		var r = dojo.render.html;
+		// dojo.debug(iframe);
+		if(!replace){
+			if(r.safari){
+				iframe.location = src;
+			}else{
+				frames[iframe.name].location = src;
+			}
+		}else{
+			// Fun with DOM 0 incompatibilities!
+			var idoc;
+			if(r.ie){
+				idoc = iframe.contentWindow.document;
+			}else if(r.safari){
+				idoc = iframe.document;
+			}else{ //  if(r.moz){
+				idoc = iframe.contentWindow;
+			}
+
+			//For Safari (at least 2.0.3) and Opera, if the iframe
+			//has just been created but it doesn't have content
+			//yet, then iframe.document may be null. In that case,
+			//use iframe.location and return.
+			if(!idoc){
+				iframe.location = src;
+				return;
+			}else{
+				idoc.location.replace(src);
+			}
+		}
+	}catch(e){ 
+		dojo.debug(e); 
+		dojo.debug("setIFrameSrc: "+e); 
+	}
+}
+
+/*
+dojo.io.sampleTranport = new function(){
+	this.canHandle = function(kwArgs){
+		// canHandle just tells dojo.io.bind() if this is a good transport to
+		// use for the particular type of request.
+		if(	
+			(
+				(kwArgs["mimetype"] == "text/plain") ||
+				(kwArgs["mimetype"] == "text/html") ||
+				(kwArgs["mimetype"] == "text/javascript")
+			)&&(
+				(kwArgs["method"] == "get") ||
+				( (kwArgs["method"] == "post") && (!kwArgs["formNode"]) )
+			)
+		){
+			return true;
+		}
+
+		return false;
+	}
+
+	this.bind = function(kwArgs){
+		var hdlrObj = {};
+
+		// set up a handler object
+		for(var x=0; x<dojo.io.hdlrFuncNames.length; x++){
+			var fn = dojo.io.hdlrFuncNames[x];
+			if(typeof kwArgs.handler == "object"){
+				if(typeof kwArgs.handler[fn] == "function"){
+					hdlrObj[fn] = kwArgs.handler[fn]||kwArgs.handler["handle"];
+				}
+			}else if(typeof kwArgs[fn] == "function"){
+				hdlrObj[fn] = kwArgs[fn];
+			}else{
+				hdlrObj[fn] = kwArgs["handle"]||function(){};
+			}
+		}
+
+		// build a handler function that calls back to the handler obj
+		var hdlrFunc = function(evt){
+			if(evt.type == "onload"){
+				hdlrObj.load("load", evt.data, evt);
+			}else if(evt.type == "onerr"){
+				var errObj = new dojo.io.Error("sampleTransport Error: "+evt.msg);
+				hdlrObj.error("error", errObj);
+			}
+		}
+
+		// the sample transport would attach the hdlrFunc() when sending the
+		// request down the pipe at this point
+		var tgtURL = kwArgs.url+"?"+dojo.io.argsFromMap(kwArgs.content);
+		// sampleTransport.sendRequest(tgtURL, hdlrFunc);
+	}
+
+	dojo.io.transports.addTransport("sampleTranport");
+}
+*/

Modified: tags/parley-0.53/root/static/magic/src/json.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/json.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/json.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,91 +8,128 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.json");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.string.extras");
 dojo.require("dojo.AdapterRegistry");
-dojo.json = {jsonRegistry:new dojo.AdapterRegistry(), register:function (name, check, wrap, override) {
-	dojo.json.jsonRegistry.register(name, check, wrap, override);
-}, evalJson:function (json) {
-	try {
-		return eval("(" + json + ")");
-	}
-	catch (e) {
-		dojo.debug(e);
-		return json;
-	}
-}, serialize:function (o) {
-	var objtype = typeof (o);
-	if (objtype == "undefined") {
-		return "undefined";
-	} else {
-		if ((objtype == "number") || (objtype == "boolean")) {
+
+dojo.json = {
+	jsonRegistry: new dojo.AdapterRegistry(),
+
+	register: function(name, check, wrap, /*optional*/ override){
+		/***
+
+			Register a JSON serialization function.	 JSON serialization 
+			functions should take one argument and return an object
+			suitable for JSON serialization:
+
+			- string
+			- number
+			- boolean
+			- undefined
+			- object
+				- null
+				- Array-like (length property that is a number)
+				- Objects with a "json" method will have this method called
+				- Any other object will be used as {key:value, ...} pairs
+			
+			If override is given, it is used as the highest priority
+			JSON serialization, otherwise it will be used as the lowest.
+		***/
+
+		dojo.json.jsonRegistry.register(name, check, wrap, override);
+	},
+
+	evalJson: function(/* jsonString */ json){
+		// FIXME: should this accept mozilla's optional second arg?
+		try {
+			return eval("(" + json + ")");
+		}catch(e){
+			dojo.debug(e);
+			return json;
+		}
+	},
+
+	evalJSON: function (json) {
+		dojo.deprecated("dojo.json.evalJSON", "use dojo.json.evalJson", "0.4");
+		return this.evalJson(json);
+	},
+
+	serialize: function(o){
+		/***
+			Create a JSON serialization of an object, note that this doesn't
+			check for infinite recursion, so don't do that!
+		***/
+
+		var objtype = typeof(o);
+		if(objtype == "undefined"){
+			return "undefined";
+		}else if((objtype == "number")||(objtype == "boolean")){
 			return o + "";
-		} else {
-			if (o === null) {
-				return "null";
+		}else if(o === null){
+			return "null";
+		}
+		if (objtype == "string") { return dojo.string.escapeString(o); }
+		// recurse
+		var me = arguments.callee;
+		// short-circuit for objects that support "json" serialization
+		// if they return "self" then just pass-through...
+		var newObj;
+		if(typeof(o.__json__) == "function"){
+			newObj = o.__json__();
+			if(o !== newObj){
+				return me(newObj);
 			}
 		}
-	}
-	if (objtype == "string") {
-		return dojo.string.escapeString(o);
-	}
-	var me = arguments.callee;
-	var newObj;
-	if (typeof (o.__json__) == "function") {
-		newObj = o.__json__();
-		if (o !== newObj) {
-			return me(newObj);
+		if(typeof(o.json) == "function"){
+			newObj = o.json();
+			if (o !== newObj) {
+				return me(newObj);
+			}
 		}
-	}
-	if (typeof (o.json) == "function") {
-		newObj = o.json();
-		if (o !== newObj) {
+		// array
+		if(objtype != "function" && typeof(o.length) == "number"){
+			var res = [];
+			for(var i = 0; i < o.length; i++){
+				var val = me(o[i]);
+				if(typeof(val) != "string"){
+					val = "undefined";
+				}
+				res.push(val);
+			}
+			return "[" + res.join(",") + "]";
+		}
+		// look in the registry
+		try {
+			window.o = o;
+			newObj = dojo.json.jsonRegistry.match(o);
 			return me(newObj);
+		}catch(e){
+			// dojo.debug(e);
 		}
-	}
-	if (objtype != "function" && typeof (o.length) == "number") {
-		var res = [];
-		for (var i = 0; i < o.length; i++) {
-			var val = me(o[i]);
-			if (typeof (val) != "string") {
-				val = "undefined";
-			}
-			res.push(val);
+		// it's a function with no adapter, bad
+		if(objtype == "function"){
+			return null;
 		}
-		return "[" + res.join(",") + "]";
-	}
-	try {
-		window.o = o;
-		newObj = dojo.json.jsonRegistry.match(o);
-		return me(newObj);
-	}
-	catch (e) {
-	}
-	if (objtype == "function") {
-		return null;
-	}
-	res = [];
-	for (var k in o) {
-		var useKey;
-		if (typeof (k) == "number") {
-			useKey = "\"" + k + "\"";
-		} else {
-			if (typeof (k) == "string") {
+		// generic object code path
+		res = [];
+		for (var k in o){
+			var useKey;
+			if (typeof(k) == "number"){
+				useKey = '"' + k + '"';
+			}else if (typeof(k) == "string"){
 				useKey = dojo.string.escapeString(k);
-			} else {
+			}else{
+				// skip non-string or number keys
 				continue;
 			}
+			val = me(o[k]);
+			if(typeof(val) != "string"){
+				// skip non-serializable values
+				continue;
+			}
+			res.push(useKey + ":" + val);
 		}
-		val = me(o[k]);
-		if (typeof (val) != "string") {
-			continue;
-		}
-		res.push(useKey + ":" + val);
+		return "{" + res.join(",") + "}";
 	}
-	return "{" + res.join(",") + "}";
-}};
-
+};

Added: tags/parley-0.53/root/static/magic/src/lang/Lang.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/Lang.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/Lang.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.require("dojo.lang");
+dojo.deprecated("dojo.lang.Lang", "use dojo.lang instead", "0.4");

Modified: tags/parley-0.53/root/static/magic/src/lang/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,17 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.lang.common", "dojo.lang.assert", "dojo.lang.array", "dojo.lang.type", "dojo.lang.func", "dojo.lang.extras", "dojo.lang.repr", "dojo.lang.declare"]});
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.lang",
+		"dojo.lang.common",
+		"dojo.lang.assert",
+		"dojo.lang.array",
+		"dojo.lang.type",
+		"dojo.lang.func",
+		"dojo.lang.extras",
+		"dojo.lang.repr",
+		"dojo.lang.declare"
+	]
+});
 dojo.provide("dojo.lang.*");
-

Modified: tags/parley-0.53/root/static/magic/src/lang/array.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/array.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/array.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,157 +8,148 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.lang.array");
+
 dojo.require("dojo.lang.common");
-dojo.lang.mixin(dojo.lang, {has:function (obj, name) {
-	try {
-		return typeof obj[name] != "undefined";
-	}
-	catch (e) {
-		return false;
-	}
-}, isEmpty:function (obj) {
-	if (dojo.lang.isObject(obj)) {
+
+// FIXME: Is this worthless since you can do: if(name in obj)
+// is this the right place for this?
+dojo.lang.has = function(obj, name){
+	try{
+		return (typeof obj[name] != "undefined");
+	}catch(e){ return false; }
+}
+
+dojo.lang.isEmpty = function(obj) {
+	if(dojo.lang.isObject(obj)) {
 		var tmp = {};
 		var count = 0;
-		for (var x in obj) {
-			if (obj[x] && (!tmp[x])) {
+		for(var x in obj){
+			if(obj[x] && (!tmp[x])){
 				count++;
 				break;
-			}
+			} 
 		}
-		return count == 0;
-	} else {
-		if (dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)) {
-			return obj.length == 0;
-		}
+		return (count == 0);
+	} else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)) {
+		return obj.length == 0;
 	}
-}, map:function (arr, obj, unary_func) {
+}
+
+dojo.lang.map = function(arr, obj, unary_func){
 	var isString = dojo.lang.isString(arr);
-	if (isString) {
+	if(isString){
 		arr = arr.split("");
 	}
-	if (dojo.lang.isFunction(obj) && (!unary_func)) {
+	if(dojo.lang.isFunction(obj)&&(!unary_func)){
 		unary_func = obj;
 		obj = dj_global;
-	} else {
-		if (dojo.lang.isFunction(obj) && unary_func) {
-			var tmpObj = obj;
-			obj = unary_func;
-			unary_func = tmpObj;
-		}
+	}else if(dojo.lang.isFunction(obj) && unary_func){
+		// ff 1.5 compat
+		var tmpObj = obj;
+		obj = unary_func;
+		unary_func = tmpObj;
 	}
-	if (Array.map) {
-		var outArr = Array.map(arr, unary_func, obj);
-	} else {
+	if(Array.map){
+	 	var outArr = Array.map(arr, unary_func, obj);
+	}else{
 		var outArr = [];
-		for (var i = 0; i < arr.length; ++i) {
+		for(var i=0;i<arr.length;++i){
 			outArr.push(unary_func.call(obj, arr[i]));
 		}
 	}
-	if (isString) {
+	if(isString) {
 		return outArr.join("");
 	} else {
 		return outArr;
 	}
-}, reduce:function (arr, initialValue, obj, binary_func) {
-	var reducedValue = initialValue;
-	if (arguments.length == 2) {
-		binary_func = initialValue;
-		reducedValue = arr[0];
-		arr = arr.slice(1);
-	} else {
-		if (arguments.length == 3) {
-			if (dojo.lang.isFunction(obj)) {
-				binary_func = obj;
-				obj = null;
-			}
-		} else {
-			if (dojo.lang.isFunction(obj)) {
-				var tmp = binary_func;
-				binary_func = obj;
-				obj = tmp;
-			}
-		}
+}
+
+// http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach
+dojo.lang.forEach = function(anArray /* Array */, callback /* Function */, thisObject /* Object */){
+	if(dojo.lang.isString(anArray)){ 
+		anArray = anArray.split(""); 
 	}
-	var ob = obj || dj_global;
-	dojo.lang.map(arr, function (val) {
-		reducedValue = binary_func.call(ob, reducedValue, val);
-	});
-	return reducedValue;
-}, forEach:function (anArray, callback, thisObject) {
-	if (dojo.lang.isString(anArray)) {
-		anArray = anArray.split("");
-	}
-	if (Array.forEach) {
+	if(Array.forEach){
 		Array.forEach(anArray, callback, thisObject);
-	} else {
-		if (!thisObject) {
-			thisObject = dj_global;
+	}else{
+		// FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?
+		if(!thisObject){
+			thisObject=dj_global;
 		}
-		for (var i = 0, l = anArray.length; i < l; i++) {
+		for(var i=0,l=anArray.length; i<l; i++){ 
 			callback.call(thisObject, anArray[i], i, anArray);
 		}
 	}
-}, _everyOrSome:function (every, arr, callback, thisObject) {
-	if (dojo.lang.isString(arr)) {
-		arr = arr.split("");
+}
+
+dojo.lang._everyOrSome = function(every, arr, callback, thisObject){
+	if(dojo.lang.isString(arr)){ 
+		arr = arr.split(""); 
 	}
-	if (Array.every) {
-		return Array[every ? "every" : "some"](arr, callback, thisObject);
-	} else {
-		if (!thisObject) {
+	if(Array.every){
+		return Array[ (every) ? "every" : "some" ](arr, callback, thisObject);
+	}else{
+		if(!thisObject){
 			thisObject = dj_global;
 		}
-		for (var i = 0, l = arr.length; i < l; i++) {
+		for(var i=0,l=arr.length; i<l; i++){
 			var result = callback.call(thisObject, arr[i], i, arr);
-			if (every && !result) {
+			if((every)&&(!result)){
 				return false;
-			} else {
-				if ((!every) && (result)) {
-					return true;
-				}
+			}else if((!every)&&(result)){
+				return true;
 			}
 		}
-		return Boolean(every);
+		return (every) ? true : false;
 	}
-}, every:function (arr, callback, thisObject) {
+}
+
+dojo.lang.every = function(arr, callback, thisObject){
 	return this._everyOrSome(true, arr, callback, thisObject);
-}, some:function (arr, callback, thisObject) {
+}
+
+dojo.lang.some = function(arr, callback, thisObject){
 	return this._everyOrSome(false, arr, callback, thisObject);
-}, filter:function (arr, callback, thisObject) {
+}
+
+dojo.lang.filter = function(arr, callback, thisObject) {
 	var isString = dojo.lang.isString(arr);
-	if (isString) {
-		arr = arr.split("");
-	}
-	var outArr;
-	if (Array.filter) {
-		outArr = Array.filter(arr, callback, thisObject);
+	if(isString) { arr = arr.split(""); }
+	if(Array.filter) {
+		var outArr = Array.filter(arr, callback, thisObject);
 	} else {
-		if (!thisObject) {
-			if (arguments.length >= 3) {
-				dojo.raise("thisObject doesn't exist!");
-			}
+		if(!thisObject) {
+			if(arguments.length >= 3) { dojo.raise("thisObject doesn't exist!"); }
 			thisObject = dj_global;
 		}
-		outArr = [];
-		for (var i = 0; i < arr.length; i++) {
-			if (callback.call(thisObject, arr[i], i, arr)) {
+
+		var outArr = [];
+		for(var i = 0; i < arr.length; i++) {
+			if(callback.call(thisObject, arr[i], i, arr)) {
 				outArr.push(arr[i]);
 			}
 		}
 	}
-	if (isString) {
+	if(isString) {
 		return outArr.join("");
 	} else {
 		return outArr;
 	}
-}, unnest:function () {
+}
+
+/**
+ * Creates a 1-D array out of all the arguments passed,
+ * unravelling any array-like objects in the process
+ *
+ * Ex:
+ * unnest(1, 2, 3) ==> [1, 2, 3]
+ * unnest(1, [2, [3], [[[4]]]]) ==> [1, 2, 3, 4]
+ */
+dojo.lang.unnest = function(/* ... */) {
 	var out = [];
-	for (var i = 0; i < arguments.length; i++) {
-		if (dojo.lang.isArrayLike(arguments[i])) {
+	for(var i = 0; i < arguments.length; i++) {
+		if(dojo.lang.isArrayLike(arguments[i])) {
 			var add = dojo.lang.unnest.apply(this, arguments[i]);
 			out = out.concat(add);
 		} else {
@@ -166,11 +157,16 @@
 		}
 	}
 	return out;
-}, toArray:function (arrayLike, startOffset) {
+}
+
+/**
+ * Converts an array-like object (i.e. arguments, DOMCollection)
+ * to an array
+**/
+dojo.lang.toArray = function(arrayLike, startOffset) {
 	var array = [];
-	for (var i = startOffset || 0; i < arrayLike.length; i++) {
+	for(var i = startOffset||0; i < arrayLike.length; i++) {
 		array.push(arrayLike[i]);
 	}
 	return array;
-}});
-
+}

Modified: tags/parley-0.53/root/static/magic/src/lang/assert.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/assert.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/assert.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,52 +8,114 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.assert");
 
-
-dojo.provide("dojo.lang.assert");
 dojo.require("dojo.lang.common");
 dojo.require("dojo.lang.array");
 dojo.require("dojo.lang.type");
-dojo.lang.assert = function (booleanValue, message) {
-	if (!booleanValue) {
-		var errorMessage = "An assert statement failed.\n" + "The method dojo.lang.assert() was called with a 'false' value.\n";
-		if (message) {
+
+// -------------------------------------------------------------------
+// Assertion methods
+// -------------------------------------------------------------------
+
+/**
+ * Throws an exception if the assertion fails.
+ *
+ * If the asserted condition is true, this method does nothing. If the
+ * condition is false, we throw an error with a error message.  
+ *
+ * @param	booleanValue	A boolean value, which needs to be true for the assertion to succeed.
+ * @param	message	Optional. A string describing the assertion.
+ * @throws	Throws an Error if 'booleanValue' is false.
+ */
+dojo.lang.assert = function(booleanValue, message){
+	if(!booleanValue){
+		var errorMessage = "An assert statement failed.\n" +
+			"The method dojo.lang.assert() was called with a 'false' value.\n";
+		if(message){
 			errorMessage += "Here's the assert message:\n" + message + "\n";
 		}
+		// Use throw instead of dojo.raise, until bug #264 is fixed:
+		// dojo.raise(errorMessage);
 		throw new Error(errorMessage);
 	}
-};
-dojo.lang.assertType = function (value, type, keywordParameters) {
-	if (dojo.lang.isString(keywordParameters)) {
-		dojo.deprecated("dojo.lang.assertType(value, type, \"message\")", "use dojo.lang.assertType(value, type) instead", "0.5");
-	}
-	if (!dojo.lang.isOfType(value, type, keywordParameters)) {
-		if (!dojo.lang.assertType._errorMessage) {
-			dojo.lang.assertType._errorMessage = "Type mismatch: dojo.lang.assertType() failed.";
+}
+
+/**
+ * Given a value and a data type, this method checks the type of the value
+ * to make sure it matches the data type, and throws an exception if there
+ * is a mismatch.
+ *
+ * Examples:
+ * <pre>
+ *   dojo.lang.assertType("foo", String);
+ *   dojo.lang.assertType(12345, Number);
+ *   dojo.lang.assertType(false, Boolean);
+ *   dojo.lang.assertType([6, 8], Array);
+ *   dojo.lang.assertType(dojo.lang.assertType, Function);
+ *   dojo.lang.assertType({foo: "bar"}, Object);
+ *   dojo.lang.assertType(new Date(), Date);
+ * </pre>
+ *
+ * @scope	public function
+ * @param	value	Any literal value or object instance.
+ * @param	type	A class of object, or a literal type, or the string name of a type, or an array with a list of types.
+ * @param	message	Optional. A string describing the assertion.
+ * @throws	Throws an Error if 'value' is not of type 'type'.
+ */
+dojo.lang.assertType = function(value, type, message){
+	if(!dojo.lang.isOfType(value, type)){
+		if(!message){
+			if(!dojo.lang.assertType._errorMessage){
+				dojo.lang.assertType._errorMessage = "Type mismatch: dojo.lang.assertType() failed.";
+			}
+			message = dojo.lang.assertType._errorMessage;
 		}
-		dojo.lang.assert(false, dojo.lang.assertType._errorMessage);
+		dojo.lang.assert(false, message);
 	}
-};
-dojo.lang.assertValidKeywords = function (object, expectedProperties, message) {
+}
+
+/**
+ * Given an anonymous object and a list of expected property names, this
+ * method check to make sure the object does not have any properties
+ * that aren't on the list of expected properties, and throws an Error
+ * if there are unexpected properties. This is useful for doing error
+ * checking on keyword arguments, to make sure there aren't typos.
+ *
+ * Examples:
+ * <pre>
+ *   dojo.lang.assertValidKeywords({a: 1, b: 2}, ["a", "b"]);
+ *   dojo.lang.assertValidKeywords({a: 1, b: 2}, ["a", "b", "c"]);
+ *   dojo.lang.assertValidKeywords({foo: "iggy"}, ["foo"]);
+ *   dojo.lang.assertValidKeywords({foo: "iggy"}, ["foo", "bar"]);
+ *   dojo.lang.assertValidKeywords({foo: "iggy"}, {foo: null, bar: null});
+ * </pre>
+ *
+ * @scope	public function
+ * @param	object	An anonymous object.
+ * @param	expectedProperties	An array of strings (or an object with all the expected properties).
+ * @param	message	Optional. A string describing the assertion.
+ * @throws	Throws an Error if 'value' is not of type 'type'.
+ */
+dojo.lang.assertValidKeywords = function(object, expectedProperties, message){
 	var key;
-	if (!message) {
-		if (!dojo.lang.assertValidKeywords._errorMessage) {
+	if(!message){
+		if(!dojo.lang.assertValidKeywords._errorMessage){
 			dojo.lang.assertValidKeywords._errorMessage = "In dojo.lang.assertValidKeywords(), found invalid keyword:";
 		}
 		message = dojo.lang.assertValidKeywords._errorMessage;
 	}
-	if (dojo.lang.isArray(expectedProperties)) {
-		for (key in object) {
-			if (!dojo.lang.inArray(expectedProperties, key)) {
+	if(dojo.lang.isArray(expectedProperties)){
+		for(key in object){
+			if(!dojo.lang.inArray(expectedProperties, key)){
 				dojo.lang.assert(false, message + " " + key);
 			}
 		}
-	} else {
-		for (key in object) {
-			if (!(key in expectedProperties)) {
+	}else{
+		for(key in object){
+			if(!(key in expectedProperties)){
 				dojo.lang.assert(false, message + " " + key);
 			}
 		}
 	}
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/lang/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,149 +8,183 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.common");
+dojo.require("dojo.lang");
 
-
-dojo.provide("dojo.lang.common");
-dojo.lang.inherits = function (subclass, superclass) {
-	if (!dojo.lang.isFunction(superclass)) {
-		dojo.raise("dojo.inherits: superclass argument [" + superclass + "] must be a function (subclass: [" + subclass + "']");
-	}
-	subclass.prototype = new superclass();
-	subclass.prototype.constructor = subclass;
-	subclass.superclass = superclass.prototype;
-	subclass["super"] = superclass.prototype;
-};
-dojo.lang._mixin = function (obj, props) {
+/*
+ * Adds the given properties/methods to the specified object
+ */
+dojo.lang._mixin = function(obj, props){
 	var tobj = {};
-	for (var x in props) {
-		if ((typeof tobj[x] == "undefined") || (tobj[x] != props[x])) {
+	for(var x in props){
+		// the "tobj" condition avoid copying properties in "props"
+		// inherited from Object.prototype.  For example, if obj has a custom
+		// toString() method, don't overwrite it with the toString() method
+		// that props inherited from Object.protoype
+		if(typeof tobj[x] == "undefined" || tobj[x] != props[x]) {
 			obj[x] = props[x];
 		}
 	}
-	if (dojo.render.html.ie && (typeof (props["toString"]) == "function") && (props["toString"] != obj["toString"]) && (props["toString"] != tobj["toString"])) {
+	// IE doesn't recognize custom toStrings in for..in
+	if(dojo.render.html.ie && dojo.lang.isFunction(props["toString"]) && props["toString"] != obj["toString"]) {
 		obj.toString = props.toString;
 	}
 	return obj;
-};
-dojo.lang.mixin = function (obj, props) {
-	for (var i = 1, l = arguments.length; i < l; i++) {
+}
+
+/*
+ * Adds the properties/methods of argument Objects to obj
+ */
+dojo.lang.mixin = function(obj, props /*, props, ..., props */){
+	for(var i=1, l=arguments.length; i<l; i++){
 		dojo.lang._mixin(obj, arguments[i]);
 	}
 	return obj;
-};
-dojo.lang.extend = function (constructor, props) {
-	for (var i = 1, l = arguments.length; i < l; i++) {
-		dojo.lang._mixin(constructor.prototype, arguments[i]);
+}
+
+/*
+ * Adds the properties/methods of argument Objects to ctor's prototype
+ */
+dojo.lang.extend = function(ctor /*function*/, props /*, props, ..., props */){
+	for(var i=1, l=arguments.length; i<l; i++){
+		dojo.lang._mixin(ctor.prototype, arguments[i]);
 	}
-	return constructor;
-};
-dojo.inherits = dojo.lang.inherits;
-dojo.mixin = dojo.lang.mixin;
-dojo.extend = dojo.lang.extend;
-dojo.lang.find = function (array, value, identity, findLast) {
-	if (!dojo.lang.isArrayLike(array) && dojo.lang.isArrayLike(value)) {
-		dojo.deprecated("dojo.lang.find(value, array)", "use dojo.lang.find(array, value) instead", "0.5");
-		var temp = array;
-		array = value;
-		value = temp;
+	return ctor;
+}
+
+/**
+ * See if val is in arr. Call signatures:
+ *  find(array, value, identity) // recommended
+ *  find(value, array, identity)
+**/
+dojo.lang.find = function(	/*Array*/	arr, 
+							/*Object*/	val,
+							/*boolean*/	identity,
+							/*boolean*/	findLast){
+	// support both (arr, val) and (val, arr)
+	if(!dojo.lang.isArrayLike(arr) && dojo.lang.isArrayLike(val)) {
+		var a = arr;
+		arr = val;
+		val = a;
 	}
-	var isString = dojo.lang.isString(array);
-	if (isString) {
-		array = array.split("");
-	}
-	if (findLast) {
+	var isString = dojo.lang.isString(arr);
+	if(isString) { arr = arr.split(""); }
+
+	if(findLast) {
 		var step = -1;
-		var i = array.length - 1;
+		var i = arr.length - 1;
 		var end = -1;
 	} else {
 		var step = 1;
 		var i = 0;
-		var end = array.length;
+		var end = arr.length;
 	}
-	if (identity) {
-		while (i != end) {
-			if (array[i] === value) {
-				return i;
-			}
+	if(identity){
+		while(i != end) {
+			if(arr[i] === val){ return i; }
 			i += step;
 		}
-	} else {
-		while (i != end) {
-			if (array[i] == value) {
-				return i;
-			}
+	}else{
+		while(i != end) {
+			if(arr[i] == val){ return i; }
 			i += step;
 		}
 	}
 	return -1;
-};
+}
+
 dojo.lang.indexOf = dojo.lang.find;
-dojo.lang.findLast = function (array, value, identity) {
-	return dojo.lang.find(array, value, identity, true);
-};
+
+dojo.lang.findLast = function(/*Array*/ arr, /*Object*/ val, /*boolean*/ identity){
+	return dojo.lang.find(arr, val, identity, true);
+}
+
 dojo.lang.lastIndexOf = dojo.lang.findLast;
-dojo.lang.inArray = function (array, value) {
-	return dojo.lang.find(array, value) > -1;
-};
-dojo.lang.isObject = function (it) {
-	if (typeof it == "undefined") {
-		return false;
-	}
-	return (typeof it == "object" || it === null || dojo.lang.isArray(it) || dojo.lang.isFunction(it));
-};
-dojo.lang.isArray = function (it) {
-	return (it && it instanceof Array || typeof it == "array");
-};
-dojo.lang.isArrayLike = function (it) {
-	if ((!it) || (dojo.lang.isUndefined(it))) {
-		return false;
-	}
-	if (dojo.lang.isString(it)) {
-		return false;
-	}
-	if (dojo.lang.isFunction(it)) {
-		return false;
-	}
-	if (dojo.lang.isArray(it)) {
-		return true;
-	}
-	if ((it.tagName) && (it.tagName.toLowerCase() == "form")) {
-		return false;
-	}
-	if (dojo.lang.isNumber(it.length) && isFinite(it.length)) {
-		return true;
-	}
+
+dojo.lang.inArray = function(arr /*Array*/, val /*Object*/){
+	return dojo.lang.find(arr, val) > -1; // return: boolean
+}
+
+/**
+ * Partial implmentation of is* functions from
+ * http://www.crockford.com/javascript/recommend.html
+ * NOTE: some of these may not be the best thing to use in all situations
+ * as they aren't part of core JS and therefore can't work in every case.
+ * See WARNING messages inline for tips.
+ *
+ * The following is* functions are fairly "safe"
+ */
+
+dojo.lang.isObject = function(wh){
+	if(typeof wh == "undefined"){ return false; }
+	return (typeof wh == "object" || wh === null || dojo.lang.isArray(wh) || dojo.lang.isFunction(wh));
+}
+
+dojo.lang.isArray = function(wh){
+	return (wh instanceof Array || typeof wh == "array");
+}
+
+dojo.lang.isArrayLike = function(wh){
+	if(dojo.lang.isString(wh)){ return false; }
+	if(dojo.lang.isFunction(wh)){ return false; } // keeps out built-in ctors (Number, String, ...) which have length properties
+	if(dojo.lang.isArray(wh)){ return true; }
+	if(typeof wh != "undefined" && wh
+		&& dojo.lang.isNumber(wh.length) && isFinite(wh.length)){ return true; }
 	return false;
-};
-dojo.lang.isFunction = function (it) {
-	return (it instanceof Function || typeof it == "function");
-};
-(function () {
-	if ((dojo.render.html.capable) && (dojo.render.html["safari"])) {
-		dojo.lang.isFunction = function (it) {
-			if ((typeof (it) == "function") && (it == "[object NodeList]")) {
-				return false;
-			}
-			return (it instanceof Function || typeof it == "function");
-		};
-	}
-})();
-dojo.lang.isString = function (it) {
-	return (typeof it == "string" || it instanceof String);
-};
-dojo.lang.isAlien = function (it) {
-	if (!it) {
-		return false;
-	}
-	return !dojo.lang.isFunction(it) && /\{\s*\[native code\]\s*\}/.test(String(it));
-};
-dojo.lang.isBoolean = function (it) {
-	return (it instanceof Boolean || typeof it == "boolean");
-};
-dojo.lang.isNumber = function (it) {
-	return (it instanceof Number || typeof it == "number");
-};
-dojo.lang.isUndefined = function (it) {
-	return ((typeof (it) == "undefined") && (it == undefined));
-};
+}
 
+dojo.lang.isFunction = function(wh){
+	if(!wh){ return false; }
+	return (wh instanceof Function || typeof wh == "function");
+}
+
+dojo.lang.isString = function(wh){
+	return (wh instanceof String || typeof wh == "string");
+}
+
+dojo.lang.isAlien = function(wh){
+	if(!wh){ return false; }
+	return !dojo.lang.isFunction() && /\{\s*\[native code\]\s*\}/.test(String(wh));
+}
+
+dojo.lang.isBoolean = function(wh){
+	return (wh instanceof Boolean || typeof wh == "boolean");
+}
+
+/**
+ * The following is***() functions are somewhat "unsafe". Fortunately,
+ * there are workarounds the the language provides and are mentioned
+ * in the WARNING messages.
+ *
+ * WARNING: In most cases, isNaN(wh) is sufficient to determine whether or not
+ * something is a number or can be used as such. For example, a number or string
+ * can be used interchangably when accessing array items (arr["1"] is the same as
+ * arr[1]) and isNaN will return false for both values ("1" and 1). Should you
+ * use isNumber("1"), that will return false, which is generally not too useful.
+ * Also, isNumber(NaN) returns true, again, this isn't generally useful, but there
+ * are corner cases (like when you want to make sure that two things are really
+ * the same type of thing). That is really where isNumber "shines".
+ *
+ * RECOMMENDATION: Use isNaN(wh) when possible
+ */
+dojo.lang.isNumber = function(wh){
+	return (wh instanceof Number || typeof wh == "number");
+}
+
+/**
+ * WARNING: In some cases, isUndefined will not behave as you
+ * might expect. If you do isUndefined(foo) and there is no earlier
+ * reference to foo, an error will be thrown before isUndefined is
+ * called. It behaves correctly if you scope yor object first, i.e.
+ * isUndefined(foo.bar) where foo is an object and bar isn't a
+ * property of the object.
+ *
+ * RECOMMENDATION: Use `typeof foo == "undefined"` when possible
+ *
+ * FIXME: Should isUndefined go away since it is error prone?
+ */
+dojo.lang.isUndefined = function(wh){
+	return ((wh == undefined)&&(typeof wh == "undefined"));
+}
+
+// end Crockford functions

Modified: tags/parley-0.53/root/static/magic/src/lang/declare.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/declare.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/declare.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,102 +8,149 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.declare");
 
-
-dojo.provide("dojo.lang.declare");
 dojo.require("dojo.lang.common");
 dojo.require("dojo.lang.extras");
-dojo.lang.declare = function (className, superclass, init, props) {
-	if ((dojo.lang.isFunction(props)) || ((!props) && (!dojo.lang.isFunction(init)))) {
+
+/*
+ * Creates a constructor: inherit and extend
+ *
+ * - inherits from "superclass(es)" 
+ *
+ *   "superclass" argument may be a Function, or an array of 
+ *   Functions. 
+ *
+ *   If "superclass" is an array, the first element is used 
+ *   as the prototypical ancestor and any following Functions 
+ *   become mixin ancestors. 
+ * 
+ *   All "superclass(es)" must be Functions (not mere Objects).
+ *
+ *   Using mixin ancestors provides a type of multiple
+ *   inheritance. Mixin ancestors prototypical 
+ *   properties are copied to the subclass, and any 
+ *   inializater/constructor is invoked. 
+ *
+ * - "props" are copied to the constructor prototype
+ *
+ * - name of the class ("className" argument) is stored in 
+ *   "declaredClass" property
+ * 
+ * - An initializer function can be specified in the "init" 
+ *   argument, or by including a function called "initializer" 
+ *   in "props".
+ * 
+ * - Superclass methods (inherited methods) can be invoked using "inherited" method:
+ *
+ * this.inherited(<method name>[, <argument array>]);
+ * 
+ * - inherited will continue up the prototype chain until it finds an implementation of method
+ * - nested calls to inherited are supported (i.e. inherited method "A" can succesfully call inherited("A"), and so on)
+ *
+ * Aliased as "dojo.declare"
+ *
+ * Usage:
+ *
+ * dojo.declare("my.classes.bar", my.classes.foo, {
+ *	initializer: function() {
+ *		this.myComplicatedObject = new ReallyComplicatedObject(); 
+ *	},
+ *	someValue: 2,
+ *	aMethod: function() { doStuff(); }
+ * });
+ *
+ */
+dojo.lang.declare = function(className /*string*/, superclass /*function || array*/, init /*function*/, props /*object*/){
+	// FIXME: parameter juggling for backward compat ... deprecate and remove after 0.3.*
+	// new sig: (className (string)[, superclass (function || array)[, init (function)][, props (object)]])
+	// old sig: (className (string)[, superclass (function || array), props (object), init (function)])
+	if ((dojo.lang.isFunction(props))||((!props)&&(!dojo.lang.isFunction(init)))){ 
 		var temp = props;
 		props = init;
 		init = temp;
-	}
-	var mixins = [];
+	}	
+	var mixins = [ ];
 	if (dojo.lang.isArray(superclass)) {
 		mixins = superclass;
 		superclass = mixins.shift();
 	}
-	if (!init) {
+	if(!init){
 		init = dojo.evalObjPath(className, false);
-		if ((init) && (!dojo.lang.isFunction(init))) {
-			init = null;
-		}
+		if ((init)&&(!dojo.lang.isFunction(init))){ init = null };
 	}
 	var ctor = dojo.lang.declare._makeConstructor();
 	var scp = (superclass ? superclass.prototype : null);
-	if (scp) {
+	if(scp){
 		scp.prototyping = true;
 		ctor.prototype = new superclass();
-		scp.prototyping = false;
+		scp.prototyping = false; 
 	}
 	ctor.superclass = scp;
 	ctor.mixins = mixins;
-	for (var i = 0, l = mixins.length; i < l; i++) {
+	for(var i=0,l=mixins.length; i<l; i++){
 		dojo.lang.extend(ctor, mixins[i].prototype);
 	}
 	ctor.prototype.initializer = null;
 	ctor.prototype.declaredClass = className;
-	if (dojo.lang.isArray(props)) {
+	if(dojo.lang.isArray(props)){
 		dojo.lang.extend.apply(dojo.lang, [ctor].concat(props));
-	} else {
-		dojo.lang.extend(ctor, (props) || {});
+	}else{
+		dojo.lang.extend(ctor, (props)||{});
 	}
-	dojo.lang.extend(ctor, dojo.lang.declare._common);
+	dojo.lang.extend(ctor, dojo.lang.declare.base);
 	ctor.prototype.constructor = ctor;
-	ctor.prototype.initializer = (ctor.prototype.initializer) || (init) || (function () {
-	});
-	var created = dojo.parseObjPath(className, null, true);
-	created.obj[created.prop] = ctor;
-	return ctor;
-};
-dojo.lang.declare._makeConstructor = function () {
-	return function () {
+	ctor.prototype.initializer=(ctor.prototype.initializer)||(init)||(function(){});
+	dojo.lang.setObjPathValue(className, ctor, null, true);
+}
+
+dojo.lang.declare._makeConstructor = function() {
+	return function(){ 
+		// get the generational context (which object [or prototype] should be constructed)
 		var self = this._getPropContext();
 		var s = self.constructor.superclass;
-		if ((s) && (s.constructor)) {
-			if (s.constructor == arguments.callee) {
-				this._inherited("constructor", arguments);
-			} else {
-				this._contextMethod(s, "constructor", arguments);
+		if((s)&&(s.constructor)){
+			if(s.constructor==arguments.callee){
+				// if this constructor is invoked directly (my.ancestor.call(this))
+				this.inherited("constructor", arguments);
+			}else{
+				this._inherited(s, "constructor", arguments);
 			}
 		}
-		var ms = (self.constructor.mixins) || ([]);
-		for (var i = 0, m; (m = ms[i]); i++) {
-			(((m.prototype) && (m.prototype.initializer)) || (m)).apply(this, arguments);
+		var m = (self.constructor.mixins)||([]);
+		for(var i=0,l=m.length; i<l; i++) {
+			(((m[i].prototype)&&(m[i].prototype.initializer))||(m[i])).apply(this, arguments);
 		}
-		if ((!this.prototyping) && (self.initializer)) {
+		if((!this.prototyping)&&(self.initializer)){
 			self.initializer.apply(this, arguments);
 		}
-	};
-};
-dojo.lang.declare._common = {_getPropContext:function () {
-	return (this.___proto || this);
-}, _contextMethod:function (ptype, method, args) {
-	var result, stack = this.___proto;
-	this.___proto = ptype;
-	try {
-		result = ptype[method].apply(this, (args || []));
 	}
-	catch (e) {
-		throw e;
-	}
-	finally {
+}
+
+dojo.lang.declare.base = {
+	_getPropContext: function() { return (this.___proto||this); },
+	// caches ptype context and calls method on it
+	_inherited: function(ptype, method, args){
+		var stack = this.___proto;
+		this.___proto = ptype;
+		var result = ptype[method].apply(this,(args||[]));
 		this.___proto = stack;
+		return result;
+	},
+	// invokes ctor.prototype.method, with args, in our context 
+	inheritedFrom: function(ctor, prop, args){
+		var p = ((ctor)&&(ctor.prototype)&&(ctor.prototype[prop]));
+		return (dojo.lang.isFunction(p) ? p.apply(this, (args||[])) : p);
+	},
+	// searches backward thru prototype chain to find nearest ancestral instance of prop
+	inherited: function(prop, args){
+		var p = this._getPropContext();
+		do{
+			if((!p.constructor)||(!p.constructor.superclass)){return;}
+			p = p.constructor.superclass;
+		}while(!(prop in p));
+		return (dojo.lang.isFunction(p[prop]) ? this._inherited(p, prop, args) : p[prop]);
 	}
-	return result;
-}, _inherited:function (prop, args) {
-	var p = this._getPropContext();
-	do {
-		if ((!p.constructor) || (!p.constructor.superclass)) {
-			return;
-		}
-		p = p.constructor.superclass;
-	} while (!(prop in p));
-	return (dojo.lang.isFunction(p[prop]) ? this._contextMethod(p, prop, args) : p[prop]);
-}, inherited:function (prop, args) {
-	dojo.deprecated("'inherited' method is dangerous, do not up-call! 'inherited' is slated for removal in 0.5; name your super class (or use superclass property) instead.", "0.5");
-	this._inherited(prop, args);
-}};
-dojo.declare = dojo.lang.declare;
+}
 
+dojo.declare = dojo.lang.declare;
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/lang/extras.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/extras.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/extras.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,89 +8,101 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.extras");
 
+dojo.require("dojo.lang.common");
 
-dojo.provide("dojo.lang.extras");
-dojo.require("dojo.lang.common");
-dojo.lang.setTimeout = function (func, delay) {
+/**
+ * Sets a timeout in milliseconds to execute a function in a given context
+ * with optional arguments.
+ *
+ * setTimeout (Object context, function func, number delay[, arg1[, ...]]);
+ * setTimeout (function func, number delay[, arg1[, ...]]);
+ */
+dojo.lang.setTimeout = function(func, delay){
 	var context = window, argsStart = 2;
-	if (!dojo.lang.isFunction(func)) {
+	if(!dojo.lang.isFunction(func)){
 		context = func;
 		func = delay;
 		delay = arguments[2];
 		argsStart++;
 	}
-	if (dojo.lang.isString(func)) {
+
+	if(dojo.lang.isString(func)){
 		func = context[func];
 	}
+	
 	var args = [];
 	for (var i = argsStart; i < arguments.length; i++) {
 		args.push(arguments[i]);
 	}
-	return dojo.global().setTimeout(function () {
-		func.apply(context, args);
-	}, delay);
-};
-dojo.lang.clearTimeout = function (timer) {
-	dojo.global().clearTimeout(timer);
-};
-dojo.lang.getNameInObj = function (ns, item) {
-	if (!ns) {
-		ns = dj_global;
-	}
-	for (var x in ns) {
-		if (ns[x] === item) {
+	return setTimeout(function () { func.apply(context, args); }, delay);
+}
+
+dojo.lang.getNameInObj = function(ns, item){
+	if(!ns){ ns = dj_global; }
+
+	for(var x in ns){
+		if(ns[x] === item){
 			return new String(x);
 		}
 	}
 	return null;
-};
-dojo.lang.shallowCopy = function (obj, deep) {
-	var i, ret;
-	if (obj === null) {
-		return null;
-	}
-	if (dojo.lang.isObject(obj)) {
-		ret = new obj.constructor();
-		for (i in obj) {
-			if (dojo.lang.isUndefined(ret[i])) {
-				ret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];
-			}
+}
+
+dojo.lang.shallowCopy = function(obj) {
+	var ret = {}, key;
+	for(key in obj) {
+		if(dojo.lang.isUndefined(ret[key])) {
+			ret[key] = obj[key];
 		}
-	} else {
-		if (dojo.lang.isArray(obj)) {
-			ret = [];
-			for (i = 0; i < obj.length; i++) {
-				ret[i] = deep ? dojo.lang.shallowCopy(obj[i], deep) : obj[i];
-			}
-		} else {
-			ret = obj;
-		}
 	}
 	return ret;
-};
-dojo.lang.firstValued = function () {
-	for (var i = 0; i < arguments.length; i++) {
-		if (typeof arguments[i] != "undefined") {
+}
+
+/**
+ * Return the first argument that isn't undefined
+ */
+dojo.lang.firstValued = function(/* ... */) {
+	for(var i = 0; i < arguments.length; i++) {
+		if(typeof arguments[i] != "undefined") {
 			return arguments[i];
 		}
 	}
 	return undefined;
-};
-dojo.lang.getObjPathValue = function (objpath, context, create) {
-	with (dojo.parseObjPath(objpath, context, create)) {
+}
+
+/**
+ * Get a value from a reference specified as a string descriptor,
+ * (e.g. "A.B") in the given context.
+ * 
+ * getObjPathValue(String objpath [, Object context, Boolean create])
+ *
+ * If context is not specified, dj_global is used
+ * If create is true, undefined objects in the path are created.
+ */
+dojo.lang.getObjPathValue = function(objpath, context, create){
+	with(dojo.parseObjPath(objpath, context, create)){
 		return dojo.evalProp(prop, obj, create);
 	}
-};
-dojo.lang.setObjPathValue = function (objpath, value, context, create) {
-	dojo.deprecated("dojo.lang.setObjPathValue", "use dojo.parseObjPath and the '=' operator", "0.6");
-	if (arguments.length < 4) {
+}
+
+/**
+ * Set a value on a reference specified as a string descriptor. 
+ * (e.g. "A.B") in the given context.
+ * 
+ * setObjPathValue(String objpath, value [, Object context, Boolean create])
+ *
+ * If context is not specified, dj_global is used
+ * If create is true, undefined objects in the path are created.
+ */
+dojo.lang.setObjPathValue = function(objpath, value, context, create){
+	if(arguments.length < 4){
 		create = true;
 	}
-	with (dojo.parseObjPath(objpath, context, create)) {
-		if (obj && (create || (prop in obj))) {
+	with(dojo.parseObjPath(objpath, context, create)){
+		if(obj && (create || (prop in obj))){
 			obj[prop] = value;
 		}
 	}
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/lang/func.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/func.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/func.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,128 +8,143 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.func");
 
+dojo.require("dojo.lang.common");
 
-dojo.provide("dojo.lang.func");
-dojo.require("dojo.lang.common");
-dojo.lang.hitch = function (thisObject, method) {
-	var args = [];
-	for (var x = 2; x < arguments.length; x++) {
-		args.push(arguments[x]);
+/**
+ * Runs a function in a given scope (thisObject), can
+ * also be used to preserve scope.
+ *
+ * hitch(foo, "bar"); // runs foo.bar() in the scope of foo
+ * hitch(foo, myFunction); // runs myFunction in the scope of foo
+ */
+dojo.lang.hitch = function(thisObject, method) {
+	if(dojo.lang.isString(method)) {
+		var fcn = thisObject[method];
+	} else {
+		var fcn = method;
 	}
-	var fcn = (dojo.lang.isString(method) ? thisObject[method] : method) || function () {
-	};
-	return function () {
-		var ta = args.concat([]);
-		for (var x = 0; x < arguments.length; x++) {
-			ta.push(arguments[x]);
-		}
-		return fcn.apply(thisObject, ta);
-	};
-};
+
+	return function() {
+		return fcn.apply(thisObject, arguments);
+	}
+}
+
 dojo.lang.anonCtr = 0;
 dojo.lang.anon = {};
-dojo.lang.nameAnonFunc = function (anonFuncPtr, thisObj, searchForNames) {
-	var nso = (thisObj || dojo.lang.anon);
-	if ((searchForNames) || ((dj_global["djConfig"]) && (djConfig["slowAnonFuncLookups"] == true))) {
-		for (var x in nso) {
-			try {
-				if (nso[x] === anonFuncPtr) {
-					return x;
-				}
+dojo.lang.nameAnonFunc = function(anonFuncPtr, namespaceObj, searchForNames){
+	var nso = (namespaceObj || dojo.lang.anon);
+	if( (searchForNames) ||
+		((dj_global["djConfig"])&&(djConfig["slowAnonFuncLookups"] == true)) ){
+		for(var x in nso){
+			if(nso[x] === anonFuncPtr){
+				return x;
 			}
-			catch (e) {
-			}
 		}
 	}
-	var ret = "__" + dojo.lang.anonCtr++;
-	while (typeof nso[ret] != "undefined") {
-		ret = "__" + dojo.lang.anonCtr++;
+	var ret = "__"+dojo.lang.anonCtr++;
+	while(typeof nso[ret] != "undefined"){
+		ret = "__"+dojo.lang.anonCtr++;
 	}
 	nso[ret] = anonFuncPtr;
 	return ret;
-};
-dojo.lang.forward = function (funcName) {
-	return function () {
+}
+
+dojo.lang.forward = function(funcName){
+	// Returns a function that forwards a method call to this.func(...)
+	return function(){
 		return this[funcName].apply(this, arguments);
 	};
-};
-dojo.lang.curry = function (thisObj, func) {
+}
+
+dojo.lang.curry = function(ns, func /* args ... */){
 	var outerArgs = [];
-	thisObj = thisObj || dj_global;
-	if (dojo.lang.isString(func)) {
-		func = thisObj[func];
+	ns = ns||dj_global;
+	if(dojo.lang.isString(func)){
+		func = ns[func];
 	}
-	for (var x = 2; x < arguments.length; x++) {
+	for(var x=2; x<arguments.length; x++){
 		outerArgs.push(arguments[x]);
 	}
-	var ecount = (func["__preJoinArity"] || func.length) - outerArgs.length;
-	function gather(nextArgs, innerArgs, expected) {
+	// since the event system replaces the original function with a new
+	// join-point runner with an arity of 0, we check to see if it's left us
+	// any clues about the original arity in lieu of the function's actual
+	// length property
+	var ecount = (func["__preJoinArity"]||func.length) - outerArgs.length;
+	// borrowed from svend tofte
+	function gather(nextArgs, innerArgs, expected){
 		var texpected = expected;
-		var totalArgs = innerArgs.slice(0);
-		for (var x = 0; x < nextArgs.length; x++) {
+		var totalArgs = innerArgs.slice(0); // copy
+		for(var x=0; x<nextArgs.length; x++){
 			totalArgs.push(nextArgs[x]);
 		}
-		expected = expected - nextArgs.length;
-		if (expected <= 0) {
-			var res = func.apply(thisObj, totalArgs);
+		// check the list of provided nextArgs to see if it, plus the
+		// number of innerArgs already supplied, meets the total
+		// expected.
+		expected = expected-nextArgs.length;
+		if(expected<=0){
+			var res = func.apply(ns, totalArgs);
 			expected = texpected;
 			return res;
-		} else {
-			return function () {
-				return gather(arguments, totalArgs, expected);
-			};
+		}else{
+			return function(){
+				return gather(arguments,// check to see if we've been run
+										// with enough args
+							totalArgs,	// a copy
+							expected);	// how many more do we need to run?;
+			}
 		}
 	}
 	return gather([], outerArgs, ecount);
-};
-dojo.lang.curryArguments = function (thisObj, func, args, offset) {
+}
+
+dojo.lang.curryArguments = function(ns, func, args, offset){
 	var targs = [];
-	var x = offset || 0;
-	for (x = offset; x < args.length; x++) {
-		targs.push(args[x]);
+	var x = offset||0;
+	for(x=offset; x<args.length; x++){
+		targs.push(args[x]); // ensure that it's an arr
 	}
-	return dojo.lang.curry.apply(dojo.lang, [thisObj, func].concat(targs));
-};
-dojo.lang.tryThese = function () {
-	for (var x = 0; x < arguments.length; x++) {
-		try {
-			if (typeof arguments[x] == "function") {
+	return dojo.lang.curry.apply(dojo.lang, [ns, func].concat(targs));
+}
+
+dojo.lang.tryThese = function(){
+	for(var x=0; x<arguments.length; x++){
+		try{
+			if(typeof arguments[x] == "function"){
 				var ret = (arguments[x]());
-				if (ret) {
+				if(ret){
 					return ret;
 				}
 			}
-		}
-		catch (e) {
+		}catch(e){
 			dojo.debug(e);
 		}
 	}
-};
-dojo.lang.delayThese = function (farr, cb, delay, onend) {
-	if (!farr.length) {
-		if (typeof onend == "function") {
+}
+
+dojo.lang.delayThese = function(farr, cb, delay, onend){
+	/**
+	 * alternate: (array funcArray, function callback, function onend)
+	 * alternate: (array funcArray, function callback)
+	 * alternate: (array funcArray)
+	 */
+	if(!farr.length){ 
+		if(typeof onend == "function"){
 			onend();
 		}
 		return;
 	}
-	if ((typeof delay == "undefined") && (typeof cb == "number")) {
+	if((typeof delay == "undefined")&&(typeof cb == "number")){
 		delay = cb;
-		cb = function () {
-		};
-	} else {
-		if (!cb) {
-			cb = function () {
-			};
-			if (!delay) {
-				delay = 0;
-			}
-		}
+		cb = function(){};
+	}else if(!cb){
+		cb = function(){};
+		if(!delay){ delay = 0; }
 	}
-	setTimeout(function () {
+	setTimeout(function(){
 		(farr.shift())();
 		cb();
 		dojo.lang.delayThese(farr, cb, delay, onend);
 	}, delay);
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/lang/repr.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/repr.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/repr.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,61 +8,83 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.repr");
 
-
-dojo.provide("dojo.lang.repr");
 dojo.require("dojo.lang.common");
 dojo.require("dojo.AdapterRegistry");
 dojo.require("dojo.string.extras");
+
 dojo.lang.reprRegistry = new dojo.AdapterRegistry();
-dojo.lang.registerRepr = function (name, check, wrap, override) {
-	dojo.lang.reprRegistry.register(name, check, wrap, override);
-};
-dojo.lang.repr = function (obj) {
-	if (typeof (obj) == "undefined") {
+dojo.lang.registerRepr = function(name, check, wrap, /*optional*/ override){
+        /***
+			Register a repr function.  repr functions should take
+			one argument and return a string representation of it
+			suitable for developers, primarily used when debugging.
+
+			If override is given, it is used as the highest priority
+			repr, otherwise it will be used as the lowest.
+        ***/
+        dojo.lang.reprRegistry.register(name, check, wrap, override);
+    };
+
+dojo.lang.repr = function(obj){
+	/***
+		Return a "programmer representation" for an object
+	***/
+	if(typeof(obj) == "undefined"){
 		return "undefined";
-	} else {
-		if (obj === null) {
-			return "null";
-		}
+	}else if(obj === null){
+		return "null";
 	}
-	try {
-		if (typeof (obj["__repr__"]) == "function") {
+
+	try{
+		if(typeof(obj["__repr__"]) == 'function'){
 			return obj["__repr__"]();
-		} else {
-			if ((typeof (obj["repr"]) == "function") && (obj.repr != arguments.callee)) {
-				return obj["repr"]();
-			}
+		}else if((typeof(obj["repr"]) == 'function')&&(obj.repr != arguments.callee)){
+			return obj["repr"]();
 		}
 		return dojo.lang.reprRegistry.match(obj);
-	}
-	catch (e) {
-		if (typeof (obj.NAME) == "string" && (obj.toString == Function.prototype.toString || obj.toString == Object.prototype.toString)) {
-			return obj.NAME;
+	}catch(e){
+		if(typeof(obj.NAME) == 'string' && (
+				obj.toString == Function.prototype.toString ||
+				obj.toString == Object.prototype.toString
+			)){
+			return o.NAME;
 		}
 	}
-	if (typeof (obj) == "function") {
+
+	if(typeof(obj) == "function"){
 		obj = (obj + "").replace(/^\s+/, "");
 		var idx = obj.indexOf("{");
-		if (idx != -1) {
+		if(idx != -1){
 			obj = obj.substr(0, idx) + "{...}";
 		}
 	}
 	return obj + "";
-};
-dojo.lang.reprArrayLike = function (arr) {
-	try {
+}
+
+dojo.lang.reprArrayLike = function(arr){
+	try{
 		var na = dojo.lang.map(arr, dojo.lang.repr);
 		return "[" + na.join(", ") + "]";
-	}
-	catch (e) {
-	}
+	}catch(e){ }
 };
-(function () {
+
+dojo.lang.reprString = function(str){ 
+	dojo.deprecated("dojo.lang.reprNumber", "use `String(num)` instead", "0.4");
+	return dojo.string.escapeString(str);
+};
+
+dojo.lang.reprNumber = function(num){
+	dojo.deprecated("dojo.lang.reprNumber", "use `String(num)` instead", "0.4");
+	return num + "";
+};
+
+(function(){
 	var m = dojo.lang;
 	m.registerRepr("arrayLike", m.isArrayLike, m.reprArrayLike);
 	m.registerRepr("string", m.isString, m.reprString);
 	m.registerRepr("numbers", m.isNumber, m.reprNumber);
 	m.registerRepr("boolean", m.isBoolean, m.reprNumber);
+	// m.registerRepr("numbers", m.typeMatcher("number", "boolean"), m.reprNumber);
 })();
-

Modified: tags/parley-0.53/root/static/magic/src/lang/type.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang/type.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang/type.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,138 +8,219 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lang.type");
 
+dojo.require("dojo.lang.common");
 
-dojo.provide("dojo.lang.type");
-dojo.require("dojo.lang.common");
-dojo.lang.whatAmI = function (value) {
-	dojo.deprecated("dojo.lang.whatAmI", "use dojo.lang.getType instead", "0.5");
-	return dojo.lang.getType(value);
-};
-dojo.lang.whatAmI.custom = {};
-dojo.lang.getType = function (value) {
+dojo.lang.whatAmI = function(wh) {
 	try {
-		if (dojo.lang.isArray(value)) {
-			return "array";
-		}
-		if (dojo.lang.isFunction(value)) {
-			return "function";
-		}
-		if (dojo.lang.isString(value)) {
-			return "string";
-		}
-		if (dojo.lang.isNumber(value)) {
-			return "number";
-		}
-		if (dojo.lang.isBoolean(value)) {
-			return "boolean";
-		}
-		if (dojo.lang.isAlien(value)) {
-			return "alien";
-		}
-		if (dojo.lang.isUndefined(value)) {
-			return "undefined";
-		}
-		for (var name in dojo.lang.whatAmI.custom) {
-			if (dojo.lang.whatAmI.custom[name](value)) {
+		if(dojo.lang.isArray(wh)) { return "array"; }
+		if(dojo.lang.isFunction(wh)) { return "function"; }
+		if(dojo.lang.isString(wh)) { return "string"; }
+		if(dojo.lang.isNumber(wh)) { return "number"; }
+		if(dojo.lang.isBoolean(wh)) { return "boolean"; }
+		if(dojo.lang.isAlien(wh)) { return "alien"; }
+		if(dojo.lang.isUndefined(wh)) { return "undefined"; }
+		// FIXME: should this go first?
+		for(var name in dojo.lang.whatAmI.custom) {
+			if(dojo.lang.whatAmI.custom[name](wh)) {
 				return name;
 			}
 		}
-		if (dojo.lang.isObject(value)) {
-			return "object";
-		}
-	}
-	catch (e) {
-	}
+		if(dojo.lang.isObject(wh)) { return "object"; }
+	} catch(E) {}
 	return "unknown";
-};
-dojo.lang.isNumeric = function (value) {
-	return (!isNaN(value) && isFinite(value) && (value != null) && !dojo.lang.isBoolean(value) && !dojo.lang.isArray(value) && !/^\s*$/.test(value));
-};
-dojo.lang.isBuiltIn = function (value) {
-	return (dojo.lang.isArray(value) || dojo.lang.isFunction(value) || dojo.lang.isString(value) || dojo.lang.isNumber(value) || dojo.lang.isBoolean(value) || (value == null) || (value instanceof Error) || (typeof value == "error"));
-};
-dojo.lang.isPureObject = function (value) {
-	return ((value != null) && dojo.lang.isObject(value) && value.constructor == Object);
-};
-dojo.lang.isOfType = function (value, type, keywordParameters) {
-	var optional = false;
-	if (keywordParameters) {
-		optional = keywordParameters["optional"];
-	}
-	if (optional && ((value === null) || dojo.lang.isUndefined(value))) {
-		return true;
-	}
-	if (dojo.lang.isArray(type)) {
+}
+/*
+ * dojo.lang.whatAmI.custom[typeName] = someFunction
+ * will return typeName is someFunction(wh) returns true
+ */
+dojo.lang.whatAmI.custom = {};
+
+/**
+ * Returns true for values that commonly represent numbers.
+ *
+ * Examples:
+ * <pre>
+ *   dojo.lang.isNumeric(3);                 // returns true
+ *   dojo.lang.isNumeric("3");               // returns true
+ *   dojo.lang.isNumeric(new Number(3));     // returns true
+ *   dojo.lang.isNumeric(new String("3"));   // returns true
+ *
+ *   dojo.lang.isNumeric(3/0);               // returns false
+ *   dojo.lang.isNumeric("foo");             // returns false
+ *   dojo.lang.isNumeric(new Number("foo")); // returns false
+ *   dojo.lang.isNumeric(false);             // returns false
+ *   dojo.lang.isNumeric(true);              // returns false
+ * </pre>
+ */
+dojo.lang.isNumeric = function(wh){
+	return (!isNaN(wh) && isFinite(wh) && (wh != null) &&
+			!dojo.lang.isBoolean(wh) && !dojo.lang.isArray(wh));
+}
+
+/**
+ * Returns true for any literal, and for any object that is an 
+ * instance of a built-in type like String, Number, Boolean, 
+ * Array, Function, or Error.
+ */
+dojo.lang.isBuiltIn = function(wh){
+	return (dojo.lang.isArray(wh)		|| 
+			dojo.lang.isFunction(wh)	|| 
+			dojo.lang.isString(wh)		|| 
+			dojo.lang.isNumber(wh)		|| 
+			dojo.lang.isBoolean(wh)		|| 
+			(wh == null)				|| 
+			(wh instanceof Error)		|| 
+			(typeof wh == "error") );
+}
+
+/**
+ * Returns true for any object where the value of the 
+ * property 'constructor' is 'Object'.  
+ * 
+ * Examples:
+ * <pre>
+ *   dojo.lang.isPureObject(new Object()); // returns true
+ *   dojo.lang.isPureObject({a: 1, b: 2}); // returns true
+ * 
+ *   dojo.lang.isPureObject(new Date());   // returns false
+ *   dojo.lang.isPureObject([11, 2, 3]);   // returns false
+ * </pre>
+ */
+dojo.lang.isPureObject = function(wh){
+	return ((wh != null) && dojo.lang.isObject(wh) && wh.constructor == Object);
+}
+
+/**
+ * Given a value and a datatype, this method returns true if the
+ * type of the value matches the datatype. The datatype parameter
+ * can be an array of datatypes, in which case the method returns
+ * true if the type of the value matches any of the datatypes.
+ *
+ * Examples:
+ * <pre>
+ *   dojo.lang.isOfType("foo", String);                // returns true
+ *   dojo.lang.isOfType(12345, Number);                // returns true
+ *   dojo.lang.isOfType(false, Boolean);               // returns true
+ *   dojo.lang.isOfType([6, 8], Array);                // returns true
+ *   dojo.lang.isOfType(dojo.lang.isOfType, Function); // returns true
+ *   dojo.lang.isOfType({foo: "bar"}, Object);         // returns true
+ *   dojo.lang.isOfType(new Date(), Date);             // returns true
+ *   dojo.lang.isOfType(xxxxx, Date);                  // returns true
+ *
+ *   dojo.lang.isOfType("foo", "string");                // returns true
+ *   dojo.lang.isOfType(12345, "number");                // returns true
+ *   dojo.lang.isOfType(false, "boolean");               // returns true
+ *   dojo.lang.isOfType([6, 8], "array");                // returns true
+ *   dojo.lang.isOfType(dojo.lang.isOfType, "function"); // returns true
+ *   dojo.lang.isOfType({foo: "bar"}, "object");         // returns true
+ *   dojo.lang.isOfType(xxxxx, "undefined");             // returns true
+ *   dojo.lang.isOfType(null, "null");                   // returns true
+
+ *   dojo.lang.isOfType("foo", [Number, String, Boolean]); // returns true
+ *   dojo.lang.isOfType(12345, [Number, String, Boolean]); // returns true
+ *   dojo.lang.isOfType(false, [Number, String, Boolean]); // returns true
+ *   dojo.lang.isOfType(xxxxx, "undefined");               // returns true
+ * </pre>
+ *
+ * @param	value	Any literal value or object instance.
+ * @param	type	A class of object, or a literal type, or the string name of a type, or an array with a list of types.
+ * @return	Returns a boolean
+ */
+dojo.lang.isOfType = function(value, type) {
+	if(dojo.lang.isArray(type)){
 		var arrayOfTypes = type;
-		for (var i in arrayOfTypes) {
+		for(var i in arrayOfTypes){
 			var aType = arrayOfTypes[i];
-			if (dojo.lang.isOfType(value, aType)) {
+			if(dojo.lang.isOfType(value, aType)) {
 				return true;
 			}
 		}
 		return false;
-	} else {
-		if (dojo.lang.isString(type)) {
+	}else{
+		if(dojo.lang.isString(type)){
 			type = type.toLowerCase();
 		}
 		switch (type) {
-		  case Array:
-		  case "array":
-			return dojo.lang.isArray(value);
-		  case Function:
-		  case "function":
-			return dojo.lang.isFunction(value);
-		  case String:
-		  case "string":
-			return dojo.lang.isString(value);
-		  case Number:
-		  case "number":
-			return dojo.lang.isNumber(value);
-		  case "numeric":
-			return dojo.lang.isNumeric(value);
-		  case Boolean:
-		  case "boolean":
-			return dojo.lang.isBoolean(value);
-		  case Object:
-		  case "object":
-			return dojo.lang.isObject(value);
-		  case "pureobject":
-			return dojo.lang.isPureObject(value);
-		  case "builtin":
-			return dojo.lang.isBuiltIn(value);
-		  case "alien":
-			return dojo.lang.isAlien(value);
-		  case "undefined":
-			return dojo.lang.isUndefined(value);
-		  case null:
-		  case "null":
-			return (value === null);
-		  case "optional":
-			dojo.deprecated("dojo.lang.isOfType(value, [type, \"optional\"])", "use dojo.lang.isOfType(value, type, {optional: true} ) instead", "0.5");
-			return ((value === null) || dojo.lang.isUndefined(value));
-		  default:
-			if (dojo.lang.isFunction(type)) {
-				return (value instanceof type);
-			} else {
-				dojo.raise("dojo.lang.isOfType() was passed an invalid type");
-			}
+			case Array:
+			case "array":
+				return dojo.lang.isArray(value);
+				break;
+			case Function:
+			case "function":
+				return dojo.lang.isFunction(value);
+				break;
+			case String:
+			case "string":
+				return dojo.lang.isString(value);
+				break;
+			case Number:
+			case "number":
+				return dojo.lang.isNumber(value);
+				break;
+			case "numeric":
+				return dojo.lang.isNumeric(value);
+				break;
+			case Boolean:
+			case "boolean":
+				return dojo.lang.isBoolean(value);
+				break;
+			case Object:
+			case "object":
+				return dojo.lang.isObject(value);
+				break;
+			case "pureobject":
+				return dojo.lang.isPureObject(value);
+				break;
+			case "builtin":
+				return dojo.lang.isBuiltIn(value);
+				break;
+			case "alien":
+				return dojo.lang.isAlien(value);
+				break;
+			case "undefined":
+				return dojo.lang.isUndefined(value);
+				break;
+			case null:
+			case "null":
+				return (value === null);
+				break;
+			case "optional":
+				return ((value === null) || dojo.lang.isUndefined(value));
+				break;
+			default:
+				if (dojo.lang.isFunction(type)) {
+					return (value instanceof type);
+				} else {
+					dojo.raise("dojo.lang.isOfType() was passed an invalid type");
+				}
+				break;
 		}
 	}
 	dojo.raise("If we get here, it means a bug was introduced above.");
-};
-dojo.lang.getObject = function (str) {
-	var parts = str.split("."), i = 0, obj = dj_global;
-	do {
-		obj = obj[parts[i++]];
-	} while (i < parts.length && obj);
-	return (obj != dj_global) ? obj : null;
-};
-dojo.lang.doesObjectExist = function (str) {
-	var parts = str.split("."), i = 0, obj = dj_global;
-	do {
-		obj = obj[parts[i++]];
-	} while (i < parts.length && obj);
-	return (obj && obj != dj_global);
-};
+}
 
+/*
+ * 	From reflection code, part of merge.
+ *	TRT 2006-02-01
+ */
+dojo.lang.getObject=function(/* String */ str){
+	//	summary
+	//	Will return an object, if it exists, based on the name in the passed string.
+	var parts=str.split("."), i=0, obj=dj_global; 
+	do{ 
+		obj=obj[parts[i++]]; 
+	}while(i<parts.length&&obj); 
+	return (obj!=dj_global)?obj:null;	//	Object
+}
+
+dojo.lang.doesObjectExist=function(/* String */ str){
+	//	summary
+	//	Check to see if object [str] exists, based on the passed string.
+	var parts=str.split("."), i=0, obj=dj_global; 
+	do{ 
+		obj=obj[parts[i++]]; 
+	}while(i<parts.length&&obj); 
+	return (obj&&obj!=dj_global);	//	boolean
+}

Modified: tags/parley-0.53/root/static/magic/src/lang.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lang.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lang.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,7 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.lang");
-dojo.require("dojo.lang.common");
-dojo.deprecated("dojo.lang", "replaced by dojo.lang.common", "0.5");
+dojo.provide("dojo.lang.Lang");
 
+dojo.require("dojo.lang.common");

Modified: tags/parley-0.53/root/static/magic/src/lfx/Animation.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/Animation.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/Animation.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,397 +8,469 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lfx.Animation");
+dojo.provide("dojo.lfx.Line");
 
+dojo.require("dojo.lang.func");
 
-dojo.provide("dojo.lfx.Animation");
-dojo.require("dojo.lang.func");
-dojo.lfx.Line = function (start, end) {
+/*
+	Animation package based on Dan Pupius' work: http://pupius.co.uk/js/Toolkit.Drawing.js
+*/
+dojo.lfx.Line = function(start, end){
 	this.start = start;
 	this.end = end;
-	if (dojo.lang.isArray(start)) {
+	if(dojo.lang.isArray(start)){
 		var diff = [];
-		dojo.lang.forEach(this.start, function (s, i) {
+		dojo.lang.forEach(this.start, function(s,i){
 			diff[i] = this.end[i] - s;
 		}, this);
-		this.getValue = function (n) {
+		
+		this.getValue = function(/*float*/ n){
 			var res = [];
-			dojo.lang.forEach(this.start, function (s, i) {
+			dojo.lang.forEach(this.start, function(s, i){
 				res[i] = (diff[i] * n) + s;
 			}, this);
 			return res;
-		};
-	} else {
+		}
+	}else{
 		var diff = end - start;
-		this.getValue = function (n) {
+			
+		this.getValue = function(/*float*/ n){
+			//	summary: returns the point on the line
+			//	n: a floating point number greater than 0 and less than 1
 			return (diff * n) + this.start;
-		};
+		}
 	}
-};
-if ((dojo.render.html.khtml) && (!dojo.render.html.safari)) {
-	dojo.lfx.easeDefault = function (n) {
-		return (parseFloat("0.5") + ((Math.sin((n + parseFloat("1.5")) * Math.PI)) / 2));
-	};
-} else {
-	dojo.lfx.easeDefault = function (n) {
-		return (0.5 + ((Math.sin((n + 1.5) * Math.PI)) / 2));
-	};
 }
-dojo.lfx.easeIn = function (n) {
+
+dojo.lfx.easeIn = function(n){
+	//	summary: returns the point on an easing curve
+	//	n: a floating point number greater than 0 and less than 1
 	return Math.pow(n, 3);
-};
-dojo.lfx.easeOut = function (n) {
-	return (1 - Math.pow(1 - n, 3));
-};
-dojo.lfx.easeInOut = function (n) {
-	return ((3 * Math.pow(n, 2)) - (2 * Math.pow(n, 3)));
-};
-dojo.lfx.IAnimation = function () {
-};
-dojo.lang.extend(dojo.lfx.IAnimation, {curve:null, duration:1000, easing:null, repeatCount:0, rate:10, handler:null, beforeBegin:null, onBegin:null, onAnimate:null, onEnd:null, onPlay:null, onPause:null, onStop:null, play:null, pause:null, stop:null, connect:function (evt, scope, newFunc) {
-	if (!newFunc) {
-		newFunc = scope;
-		scope = this;
-	}
-	newFunc = dojo.lang.hitch(scope, newFunc);
-	var oldFunc = this[evt] || function () {
-	};
-	this[evt] = function () {
-		var ret = oldFunc.apply(this, arguments);
-		newFunc.apply(this, arguments);
-		return ret;
-	};
-	return this;
-}, fire:function (evt, args) {
-	if (this[evt]) {
-		this[evt].apply(this, (args || []));
-	}
-	return this;
-}, repeat:function (count) {
-	this.repeatCount = count;
-	return this;
-}, _active:false, _paused:false});
-dojo.lfx.Animation = function (handlers, duration, curve, easing, repeatCount, rate) {
+}
+
+dojo.lfx.easeOut = function(n){
+	//	summary: returns the point on the line
+	//	n: a floating point number greater than 0 and less than 1
+	return ( 1 - Math.pow(1 - n, 3) );
+}
+
+dojo.lfx.easeInOut = function(n){
+	//	summary: returns the point on the line
+	//	n: a floating point number greater than 0 and less than 1
+	return ( (3 * Math.pow(n, 2)) - (2 * Math.pow(n, 3)) );
+}
+
+dojo.lfx.IAnimation = function(){}
+dojo.lang.extend(dojo.lfx.IAnimation, {
+	// public properties
+	curve: null,
+	duration: 1000,
+	easing: null,
+	repeatCount: 0,
+	rate: 25,
+	
+	// events
+	handler: null,
+	beforeBegin: null,
+	onBegin: null,
+	onAnimate: null,
+	onEnd: null,
+	onPlay: null,
+	onPause: null,
+	onStop: null,
+	
+	// public methods
+	play: null,
+	pause: null,
+	stop: null,
+	
+	fire: function(evt, args){
+		if(this[evt]){
+			this[evt].apply(this, (args||[]));
+		}
+	},
+	
+	// private properties
+	_active: false,
+	_paused: false
+});
+
+dojo.lfx.Animation = function(/*Object*/ handlers, /*int*/ duration, /*Array*/ curve, /*function*/ easing, /*int*/ repeatCount, /*int*/ rate){
+	//	summary
+	//		a generic animation object that fires callbacks into it's handlers
+	//		object at various states
+	//	handlers
+	//		object { 
+	//			handler: function(){}, 
+	//			onstart: function(){}, 
+	//			onstop: function(){}, 
+	//			onanimate: function(){}
+	//		}
 	dojo.lfx.IAnimation.call(this);
-	if (dojo.lang.isNumber(handlers) || (!handlers && duration.getValue)) {
+	if(dojo.lang.isNumber(handlers)||(!handlers && duration.getValue)){
+		// no handlers argument:
 		rate = repeatCount;
 		repeatCount = easing;
 		easing = curve;
 		curve = duration;
 		duration = handlers;
 		handlers = null;
-	} else {
-		if (handlers.getValue || dojo.lang.isArray(handlers)) {
-			rate = easing;
-			repeatCount = curve;
-			easing = duration;
-			curve = handlers;
-			duration = null;
-			handlers = null;
-		}
+	}else if(handlers.getValue||dojo.lang.isArray(handlers)){
+		// no handlers or duration:
+		rate = easing;
+		repeatCount = curve;
+		easing = duration;
+		curve = handlers;
+		duration = null;
+		handlers = null;
 	}
-	if (dojo.lang.isArray(curve)) {
+	if(dojo.lang.isArray(curve)){
 		this.curve = new dojo.lfx.Line(curve[0], curve[1]);
-	} else {
+	}else{
 		this.curve = curve;
 	}
-	if (duration != null && duration > 0) {
-		this.duration = duration;
+	if(duration != null && duration > 0){ this.duration = duration; }
+	if(repeatCount){ this.repeatCount = repeatCount; }
+	if(rate){ this.rate = rate; }
+	if(handlers){
+		this.handler = handlers.handler;
+		this.beforeBegin = handlers.beforeBegin;
+		this.onBegin = handlers.onBegin;
+		this.onEnd = handlers.onEnd;
+		this.onPlay = handlers.onPlay;
+		this.onPause = handlers.onPause;
+		this.onStop = handlers.onStop;
+		this.onAnimate = handlers.onAnimate;
 	}
-	if (repeatCount) {
-		this.repeatCount = repeatCount;
+	if(easing && dojo.lang.isFunction(easing)){
+		this.easing=easing;
 	}
-	if (rate) {
-		this.rate = rate;
-	}
-	if (handlers) {
-		dojo.lang.forEach(["handler", "beforeBegin", "onBegin", "onEnd", "onPlay", "onStop", "onAnimate"], function (item) {
-			if (handlers[item]) {
-				this.connect(item, handlers[item]);
-			}
-		}, this);
-	}
-	if (easing && dojo.lang.isFunction(easing)) {
-		this.easing = easing;
-	}
-};
+}
 dojo.inherits(dojo.lfx.Animation, dojo.lfx.IAnimation);
-dojo.lang.extend(dojo.lfx.Animation, {_startTime:null, _endTime:null, _timer:null, _percent:0, _startRepeatCount:0, play:function (delay, gotoStart) {
-	if (gotoStart) {
-		clearTimeout(this._timer);
-		this._active = false;
-		this._paused = false;
-		this._percent = 0;
-	} else {
-		if (this._active && !this._paused) {
+dojo.lang.extend(dojo.lfx.Animation, {
+	// "private" properties
+	_startTime: null,
+	_endTime: null,
+	_timer: null,
+	_percent: 0,
+	_startRepeatCount: 0,
+
+	// public methods
+	play: function(delay, gotoStart){
+		if(gotoStart){
+			clearTimeout(this._timer);
+			this._active = false;
+			this._paused = false;
+			this._percent = 0;
+		}else if(this._active && !this._paused){
 			return this;
 		}
-	}
-	this.fire("handler", ["beforeBegin"]);
-	this.fire("beforeBegin");
-	if (delay > 0) {
-		setTimeout(dojo.lang.hitch(this, function () {
-			this.play(null, gotoStart);
-		}), delay);
-		return this;
-	}
-	this._startTime = new Date().valueOf();
-	if (this._paused) {
-		this._startTime -= (this.duration * this._percent / 100);
-	}
-	this._endTime = this._startTime + this.duration;
-	this._active = true;
-	this._paused = false;
-	var step = this._percent / 100;
-	var value = this.curve.getValue(step);
-	if (this._percent == 0) {
-		if (!this._startRepeatCount) {
-			this._startRepeatCount = this.repeatCount;
+		
+		this.fire("handler", ["beforeBegin"]);
+		this.fire("beforeBegin");
+
+		if(delay > 0){
+			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
+			return this;
 		}
-		this.fire("handler", ["begin", value]);
-		this.fire("onBegin", [value]);
-	}
-	this.fire("handler", ["play", value]);
-	this.fire("onPlay", [value]);
-	this._cycle();
-	return this;
-}, pause:function () {
-	clearTimeout(this._timer);
-	if (!this._active) {
+		
+		this._startTime = new Date().valueOf();
+		if(this._paused){
+			this._startTime -= (this.duration * this._percent / 100);
+		}
+		this._endTime = this._startTime + this.duration;
+
+		this._active = true;
+		this._paused = false;
+		
+		var step = this._percent / 100;
+		var value = this.curve.getValue(step);
+		if( this._percent == 0 ) {
+			if(!this._startRepeatCount) {
+				this._startRepeatCount = this.repeatCount;
+			}
+			this.fire("handler", ["begin", value]);
+			this.fire("onBegin", [value]);
+		}
+
+		this.fire("handler", ["play", value]);
+		this.fire("onPlay", [value]);
+
+		this._cycle();
 		return this;
-	}
-	this._paused = true;
-	var value = this.curve.getValue(this._percent / 100);
-	this.fire("handler", ["pause", value]);
-	this.fire("onPause", [value]);
-	return this;
-}, gotoPercent:function (pct, andPlay) {
-	clearTimeout(this._timer);
-	this._active = true;
-	this._paused = true;
-	this._percent = pct;
-	if (andPlay) {
-		this.play();
-	}
-	return this;
-}, stop:function (gotoEnd) {
-	clearTimeout(this._timer);
-	var step = this._percent / 100;
-	if (gotoEnd) {
-		step = 1;
-	}
-	var value = this.curve.getValue(step);
-	this.fire("handler", ["stop", value]);
-	this.fire("onStop", [value]);
-	this._active = false;
-	this._paused = false;
-	return this;
-}, status:function () {
-	if (this._active) {
-		return this._paused ? "paused" : "playing";
-	} else {
-		return "stopped";
-	}
-	return this;
-}, _cycle:function () {
-	clearTimeout(this._timer);
-	if (this._active) {
-		var curr = new Date().valueOf();
-		var step = (curr - this._startTime) / (this._endTime - this._startTime);
-		if (step >= 1) {
+	},
+
+	pause: function() {
+		clearTimeout(this._timer);
+		if(!this._active){ return this; }
+		this._paused = true;
+		var value = this.curve.getValue(this._percent / 100);
+		this.fire("handler", ["pause", value]);
+		this.fire("onPause", [value]);
+		return this;
+	},
+
+	gotoPercent: function(pct, andPlay) {
+		clearTimeout(this._timer);
+		this._active = true;
+		this._paused = true;
+		this._percent = pct;
+		if( andPlay ) { this.play(); }
+	},
+
+	stop: function(gotoEnd) {
+		clearTimeout(this._timer);
+		var step = this._percent / 100;
+		if( gotoEnd ) {
 			step = 1;
-			this._percent = 100;
-		} else {
-			this._percent = step * 100;
 		}
-		if ((this.easing) && (dojo.lang.isFunction(this.easing))) {
-			step = this.easing(step);
-		}
 		var value = this.curve.getValue(step);
-		this.fire("handler", ["animate", value]);
-		this.fire("onAnimate", [value]);
-		if (step < 1) {
-			this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
+		this.fire("handler", ["stop", value]);
+		this.fire("onStop", [value]);
+		this._active = false;
+		this._paused = false;
+		return this;
+	},
+
+	status: function() {
+		if( this._active ) {
+			return this._paused ? "paused" : "playing";
 		} else {
-			this._active = false;
-			this.fire("handler", ["end"]);
-			this.fire("onEnd");
-			if (this.repeatCount > 0) {
-				this.repeatCount--;
-				this.play(null, true);
+			return "stopped";
+		}
+	},
+
+	// "private" methods
+	_cycle: function() {
+		clearTimeout(this._timer);
+		if(this._active){
+			var curr = new Date().valueOf();
+			var step = (curr - this._startTime) / (this._endTime - this._startTime);
+
+			if(step >= 1){
+				step = 1;
+				this._percent = 100;
+			}else{
+				this._percent = step * 100;
+			}
+			
+			// Perform easing
+			if((this.easing)&&(dojo.lang.isFunction(this.easing))){
+				step = this.easing(step);
+			}
+
+			var value = this.curve.getValue(step);
+			this.fire("handler", ["animate", value]);
+			this.fire("onAnimate", [value]);
+
+			if( step < 1 ) {
+				this._timer = setTimeout(dojo.lang.hitch(this, "_cycle"), this.rate);
 			} else {
-				if (this.repeatCount == -1) {
+				this._active = false;
+				this.fire("handler", ["end"]);
+				this.fire("onEnd");
+
+				if( this.repeatCount > 0 ) {
+					this.repeatCount--;
 					this.play(null, true);
+				} else if( this.repeatCount == -1 ) {
+					this.play(null, true);
 				} else {
-					if (this._startRepeatCount) {
+					if(this._startRepeatCount) {
 						this.repeatCount = this._startRepeatCount;
 						this._startRepeatCount = 0;
 					}
 				}
 			}
 		}
+		return this;
 	}
-	return this;
-}});
-dojo.lfx.Combine = function (animations) {
+});
+
+dojo.lfx.Combine = function(){
 	dojo.lfx.IAnimation.call(this);
 	this._anims = [];
 	this._animsEnded = 0;
+	
 	var anims = arguments;
-	if (anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))) {
+	if(anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
 		anims = anims[0];
 	}
-	dojo.lang.forEach(anims, function (anim) {
-		this._anims.push(anim);
-		anim.connect("onEnd", dojo.lang.hitch(this, "_onAnimsEnded"));
-	}, this);
-};
+	
+	var _this = this;
+	dojo.lang.forEach(anims, function(anim){
+		_this._anims.push(anim);
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ oldOnEnd(); _this._onAnimsEnded(); };
+	});
+}
 dojo.inherits(dojo.lfx.Combine, dojo.lfx.IAnimation);
-dojo.lang.extend(dojo.lfx.Combine, {_animsEnded:0, play:function (delay, gotoStart) {
-	if (!this._anims.length) {
+dojo.lang.extend(dojo.lfx.Combine, {
+	// private members
+	_animsEnded: 0,
+	
+	// public methods
+	play: function(delay, gotoStart){
+		if( !this._anims.length ){ return this; }
+
+		this.fire("beforeBegin");
+
+		if(delay > 0){
+			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
+			return this;
+		}
+		
+		if(gotoStart || this._anims[0].percent == 0){
+			this.fire("onBegin");
+		}
+		this.fire("onPlay");
+		this._animsCall("play", null, gotoStart);
 		return this;
-	}
-	this.fire("beforeBegin");
-	if (delay > 0) {
-		setTimeout(dojo.lang.hitch(this, function () {
-			this.play(null, gotoStart);
-		}), delay);
+	},
+	
+	pause: function(){
+		this.fire("onPause");
+		this._animsCall("pause"); 
 		return this;
-	}
-	if (gotoStart || this._anims[0].percent == 0) {
-		this.fire("onBegin");
-	}
-	this.fire("onPlay");
-	this._animsCall("play", null, gotoStart);
-	return this;
-}, pause:function () {
-	this.fire("onPause");
-	this._animsCall("pause");
-	return this;
-}, stop:function (gotoEnd) {
-	this.fire("onStop");
-	this._animsCall("stop", gotoEnd);
-	return this;
-}, _onAnimsEnded:function () {
-	this._animsEnded++;
-	if (this._animsEnded >= this._anims.length) {
-		this.fire("onEnd");
-	}
-	return this;
-}, _animsCall:function (funcName) {
-	var args = [];
-	if (arguments.length > 1) {
-		for (var i = 1; i < arguments.length; i++) {
-			args.push(arguments[i]);
+	},
+	
+	stop: function(gotoEnd){
+		this.fire("onStop");
+		this._animsCall("stop", gotoEnd);
+		return this;
+	},
+	
+	// private methods
+	_onAnimsEnded: function(){
+		this._animsEnded++;
+		if(this._animsEnded >= this._anims.length){
+			this.fire("onEnd");
 		}
+		return this;
+	},
+	
+	_animsCall: function(funcName){
+		var args = [];
+		if(arguments.length > 1){
+			for(var i = 1 ; i < arguments.length ; i++){
+				args.push(arguments[i]);
+			}
+		}
+		var _this = this;
+		dojo.lang.forEach(this._anims, function(anim){
+			anim[funcName](args);
+		}, _this);
+		return this;
 	}
-	var _this = this;
-	dojo.lang.forEach(this._anims, function (anim) {
-		anim[funcName](args);
-	}, _this);
-	return this;
-}});
-dojo.lfx.Chain = function (animations) {
+});
+
+dojo.lfx.Chain = function() {
 	dojo.lfx.IAnimation.call(this);
 	this._anims = [];
 	this._currAnim = -1;
+	
 	var anims = arguments;
-	if (anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))) {
+	if(anims.length == 1 && (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
 		anims = anims[0];
 	}
+	
 	var _this = this;
-	dojo.lang.forEach(anims, function (anim, i, anims_arr) {
-		this._anims.push(anim);
-		if (i < anims_arr.length - 1) {
-			anim.connect("onEnd", dojo.lang.hitch(this, "_playNext"));
-		} else {
-			anim.connect("onEnd", dojo.lang.hitch(this, function () {
-				this.fire("onEnd");
-			}));
+	dojo.lang.forEach(anims, function(anim, i, anims_arr){
+		_this._anims.push(anim);
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		if(i < anims_arr.length - 1){
+			anim.onEnd = function(){ oldOnEnd(); _this._playNext(); };
+		}else{
+			anim.onEnd = function(){ oldOnEnd(); _this.fire("onEnd"); };
 		}
-	}, this);
-};
+	}, _this);
+}
 dojo.inherits(dojo.lfx.Chain, dojo.lfx.IAnimation);
-dojo.lang.extend(dojo.lfx.Chain, {_currAnim:-1, play:function (delay, gotoStart) {
-	if (!this._anims.length) {
+dojo.lang.extend(dojo.lfx.Chain, {
+	// private members
+	_currAnim: -1,
+	
+	// public methods
+	play: function(delay, gotoStart){
+		if( !this._anims.length ) { return this; }
+		if( gotoStart || !this._anims[this._currAnim] ) {
+			this._currAnim = 0;
+		}
+
+		var currentAnimation = this._anims[this._currAnim];
+
+		this.fire("beforeBegin");
+		if(delay > 0){
+			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
+			return this;
+		}
+		
+		if(currentAnimation){
+			if(this._currAnim == 0){
+				this.fire("handler", ["begin", this._currAnim]);
+				this.fire("onBegin", [this._currAnim]);
+			}
+			this.fire("onPlay", [this._currAnim]);
+			currentAnimation.play(null, gotoStart);
+		}
 		return this;
-	}
-	if (gotoStart || !this._anims[this._currAnim]) {
-		this._currAnim = 0;
-	}
-	var currentAnimation = this._anims[this._currAnim];
-	this.fire("beforeBegin");
-	if (delay > 0) {
-		setTimeout(dojo.lang.hitch(this, function () {
-			this.play(null, gotoStart);
-		}), delay);
+	},
+	
+	pause: function(){
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].pause();
+			this.fire("onPause", [this._currAnim]);
+		}
 		return this;
-	}
-	if (currentAnimation) {
-		if (this._currAnim == 0) {
-			this.fire("handler", ["begin", this._currAnim]);
-			this.fire("onBegin", [this._currAnim]);
+	},
+	
+	playPause: function(){
+		if(this._anims.length == 0){ return this; }
+		if(this._currAnim == -1){ this._currAnim = 0; }
+		var currAnim = this._anims[this._currAnim];
+		if( currAnim ) {
+			if( !currAnim._active || currAnim._paused ) {
+				this.play();
+			} else {
+				this.pause();
+			}
 		}
-		this.fire("onPlay", [this._currAnim]);
-		currentAnimation.play(null, gotoStart);
-	}
-	return this;
-}, pause:function () {
-	if (this._anims[this._currAnim]) {
-		this._anims[this._currAnim].pause();
-		this.fire("onPause", [this._currAnim]);
-	}
-	return this;
-}, playPause:function () {
-	if (this._anims.length == 0) {
 		return this;
-	}
-	if (this._currAnim == -1) {
-		this._currAnim = 0;
-	}
-	var currAnim = this._anims[this._currAnim];
-	if (currAnim) {
-		if (!currAnim._active || currAnim._paused) {
-			this.play();
-		} else {
-			this.pause();
+	},
+	
+	stop: function(){
+		var currAnim = this._anims[this._currAnim];
+		if(currAnim){
+			currAnim.stop();
+			this.fire("onStop", [this._currAnim]);
 		}
-	}
-	return this;
-}, stop:function () {
-	var currAnim = this._anims[this._currAnim];
-	if (currAnim) {
-		currAnim.stop();
-		this.fire("onStop", [this._currAnim]);
-	}
-	return currAnim;
-}, _playNext:function () {
-	if (this._currAnim == -1 || this._anims.length == 0) {
+		return currAnim;
+	},
+	
+	// private methods
+	_playNext: function(){
+		if( this._currAnim == -1 || this._anims.length == 0 ) { return this; }
+		this._currAnim++;
+		if( this._anims[this._currAnim] ){
+			this._anims[this._currAnim].play(null, true);
+		}
 		return this;
 	}
-	this._currAnim++;
-	if (this._anims[this._currAnim]) {
-		this._anims[this._currAnim].play(null, true);
-	}
-	return this;
-}});
-dojo.lfx.combine = function (animations) {
+});
+
+dojo.lfx.combine = function(){
 	var anims = arguments;
-	if (dojo.lang.isArray(arguments[0])) {
+	if(dojo.lang.isArray(arguments[0])){
 		anims = arguments[0];
 	}
-	if (anims.length == 1) {
-		return anims[0];
-	}
 	return new dojo.lfx.Combine(anims);
-};
-dojo.lfx.chain = function (animations) {
+}
+
+dojo.lfx.chain = function(){
 	var anims = arguments;
-	if (dojo.lang.isArray(arguments[0])) {
+	if(dojo.lang.isArray(arguments[0])){
 		anims = arguments[0];
 	}
-	if (anims.length == 1) {
-		return anims[0];
-	}
 	return new dojo.lfx.Chain(anims);
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/lfx/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,8 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({browser:["dojo.lfx.html"], dashboard:["dojo.lfx.html"]});
-dojo.provide("dojo.lfx.*");
-
+dojo.kwCompoundRequire({
+	browser: ["dojo.lfx.html"],
+	dashboard: ["dojo.lfx.html"]
+});
+dojo.provide("dojo.lfx.*");
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/lfx/extras.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/extras.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/extras.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,73 +8,112 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lfx.extras");
 
-
-dojo.provide("dojo.lfx.extras");
 dojo.require("dojo.lfx.html");
 dojo.require("dojo.lfx.Animation");
-dojo.lfx.html.fadeWipeIn = function (nodes, duration, easing, callback) {
+
+dojo.lfx.html.fadeWipeIn = function(nodes, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
-	var anim = dojo.lfx.combine(dojo.lfx.fadeIn(nodes, duration, easing), dojo.lfx.wipeIn(nodes, duration, easing));
-	if (callback) {
-		anim.connect("onEnd", function () {
+	var anim = dojo.lfx.combine(
+		dojo.lfx.wipeIn(nodes, duration, easing),
+		dojo.lfx.fadeIn(nodes, duration, easing));
+	
+	if(callback){
+		dojo.event.connect(anim, "onEnd", function(){
 			callback(nodes, anim);
 		});
 	}
+	
 	return anim;
-};
-dojo.lfx.html.fadeWipeOut = function (nodes, duration, easing, callback) {
+}
+
+dojo.lfx.html.fadeWipeOut = function(nodes, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
-	var anim = dojo.lfx.combine(dojo.lfx.fadeOut(nodes, duration, easing), dojo.lfx.wipeOut(nodes, duration, easing));
-	if (callback) {
-		anim.connect("onEnd", function () {
+	var anim = dojo.lfx.combine(
+		dojo.lfx.wipeOut(nodes, duration, easing),
+		dojo.lfx.fadeOut(nodes, duration, easing));
+	
+	if(callback){
+		dojo.event.connect(anim, "onEnd", function(){
 			callback(nodes, anim);
 		});
 	}
+
 	return anim;
-};
-dojo.lfx.html.scale = function (nodes, percentage, scaleContent, fromCenter, duration, easing, callback) {
+}
+
+dojo.lfx.html.scale = function(nodes, percentage, scaleContent, fromCenter, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	dojo.lang.forEach(nodes, function (node) {
-		var outer = dojo.html.getMarginBox(node);
-		var actualPct = percentage / 100;
-		var props = [{property:"width", start:outer.width, end:outer.width * actualPct}, {property:"height", start:outer.height, end:outer.height * actualPct}];
-		if (scaleContent) {
-			var fontSize = dojo.html.getStyle(node, "font-size");
+
+	dojo.lang.forEach(nodes, function(node){
+		var origWidth = dojo.style.getOuterWidth(node);
+		var origHeight = dojo.style.getOuterHeight(node);
+
+		var actualPct = percentage/100.0;
+		var props = [
+			{	property: "width",
+				start: origWidth,
+				end: origWidth * actualPct
+			},
+			{	property: "height",
+				start: origHeight,
+				end: origHeight * actualPct
+			}];
+		
+		if(scaleContent){
+			var fontSize = dojo.style.getStyle(node, 'font-size');
 			var fontSizeType = null;
-			if (!fontSize) {
-				fontSize = parseFloat("100%");
-				fontSizeType = "%";
-			} else {
-				dojo.lang.some(["em", "px", "%"], function (item, index, arr) {
-					if (fontSize.indexOf(item) > 0) {
+			if(!fontSize){
+				fontSize = parseFloat('100%');
+				fontSizeType = '%';
+			}else{
+				dojo.lang.some(['em','px','%'], function(item, index, arr){
+					if(fontSize.indexOf(item)>0){
 						fontSize = parseFloat(fontSize);
 						fontSizeType = item;
 						return true;
 					}
 				});
 			}
-			props.push({property:"font-size", start:fontSize, end:fontSize * actualPct, units:fontSizeType});
+			props.push({
+				property: "font-size",
+				start: fontSize,
+				end: fontSize * actualPct,
+				units: fontSizeType });
 		}
-		if (fromCenter) {
-			var positioning = dojo.html.getStyle(node, "position");
+		
+		if(fromCenter){
+			var positioning = dojo.style.getStyle(node, "position");
 			var originalTop = node.offsetTop;
 			var originalLeft = node.offsetLeft;
-			var endTop = ((outer.height * actualPct) - outer.height) / 2;
-			var endLeft = ((outer.width * actualPct) - outer.width) / 2;
-			props.push({property:"top", start:originalTop, end:(positioning == "absolute" ? originalTop - endTop : (-1 * endTop))});
-			props.push({property:"left", start:originalLeft, end:(positioning == "absolute" ? originalLeft - endLeft : (-1 * endLeft))});
+			var endTop = ((origHeight * actualPct) - origHeight)/2;
+			var endLeft = ((origWidth * actualPct) - origWidth)/2;
+			props.push({
+				property: "top",
+				start: originalTop,
+				end: (positioning == "absolute" ? originalTop - endTop : (-1*endTop))
+			});
+			props.push({
+				property: "left",
+				start: originalLeft,
+				end: (positioning == "absolute" ? originalLeft - endLeft : (-1*endLeft))
+			});
 		}
+		
 		var anim = dojo.lfx.propertyAnimation(node, props, duration, easing);
-		if (callback) {
-			anim.connect("onEnd", function () {
+		if(callback){
+			dojo.event.connect(anim, "onEnd", function(){
 				callback(node, anim);
 			});
 		}
+
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
+	
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
 dojo.lang.mixin(dojo.lfx, dojo.lfx.html);
-

Modified: tags/parley-0.53/root/static/magic/src/lfx/html.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/html.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/html.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,502 +8,528 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.lfx.html");
+dojo.require("dojo.lfx.Animation");
 
+dojo.require("dojo.html");
 
-dojo.provide("dojo.lfx.html");
-dojo.require("dojo.gfx.color");
-dojo.require("dojo.lfx.Animation");
-dojo.require("dojo.lang.array");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.color");
-dojo.require("dojo.html.layout");
-dojo.lfx.html._byId = function (nodes) {
-	if (!nodes) {
-		return [];
-	}
-	if (dojo.lang.isArrayLike(nodes)) {
-		if (!nodes.alreadyChecked) {
+dojo.lfx.html._byId = function(nodes){
+	if(!nodes){ return []; }
+	if(dojo.lang.isArray(nodes)){
+		if(!nodes.alreadyChecked){
 			var n = [];
-			dojo.lang.forEach(nodes, function (node) {
+			dojo.lang.forEach(nodes, function(node){
 				n.push(dojo.byId(node));
 			});
 			n.alreadyChecked = true;
 			return n;
-		} else {
+		}else{
 			return nodes;
 		}
-	} else {
+	}else{
 		var n = [];
 		n.push(dojo.byId(nodes));
 		n.alreadyChecked = true;
 		return n;
 	}
-};
-dojo.lfx.html.propertyAnimation = function (nodes, propertyMap, duration, easing, handlers) {
+}
+
+dojo.lfx.html.propertyAnimation = function(	/*DOMNode*/ nodes, 
+											/*Array*/ propertyMap, 
+											/*int*/ duration,
+											/*function*/ easing){
 	nodes = dojo.lfx.html._byId(nodes);
-	var targs = {"propertyMap":propertyMap, "nodes":nodes, "duration":duration, "easing":easing || dojo.lfx.easeDefault};
-	var setEmUp = function (args) {
-		if (args.nodes.length == 1) {
-			var pm = args.propertyMap;
-			if (!dojo.lang.isArray(args.propertyMap)) {
-				var parr = [];
-				for (var pname in pm) {
-					pm[pname].property = pname;
-					parr.push(pm[pname]);
+	
+	if(nodes.length==1){
+		// FIXME: we're only supporting start-value filling when one node is
+		// passed
+		
+		dojo.lang.forEach(propertyMap, function(prop){
+			if(typeof prop["start"] == "undefined"){
+				if(prop.property != "opacity"){
+					prop.start = parseInt(dojo.style.getComputedStyle(nodes[0], prop.property));
+				}else{
+					prop.start = dojo.style.getOpacity(nodes[0]);
 				}
-				pm = args.propertyMap = parr;
 			}
-			dojo.lang.forEach(pm, function (prop) {
-				if (dj_undef("start", prop)) {
-					if (prop.property != "opacity") {
-						prop.start = parseInt(dojo.html.getComputedStyle(args.nodes[0], prop.property));
-					} else {
-						prop.start = dojo.html.getOpacity(args.nodes[0]);
-					}
-				}
-			});
+		});
+	}
+
+	var coordsAsInts = function(coords){
+		var cints = new Array(coords.length);
+		for(var i = 0; i < coords.length; i++){
+			cints[i] = Math.round(coords[i]);
 		}
-	};
-	var coordsAsInts = function (coords) {
-		var cints = [];
-		dojo.lang.forEach(coords, function (c) {
-			cints.push(Math.round(c));
-		});
 		return cints;
-	};
-	var setStyle = function (n, style) {
+	}
+	var setStyle = function(n, style){
 		n = dojo.byId(n);
-		if (!n || !n.style) {
-			return;
-		}
-		for (var s in style) {
-			try {
-				if (s == "opacity") {
-					dojo.html.setOpacity(n, style[s]);
-				} else {
-					n.style[s] = style[s];
-				}
+		if(!n || !n.style){ return; }
+		for(var s in style){
+			if(s == "opacity"){
+				dojo.style.setOpacity(n, style[s]);
+			}else{
+				n.style[s] = style[s];
 			}
-			catch (e) {
-				dojo.debug(e);
-			}
 		}
-	};
-	var propLine = function (properties) {
+	}
+	var propLine = function(properties){
 		this._properties = properties;
 		this.diffs = new Array(properties.length);
-		dojo.lang.forEach(properties, function (prop, i) {
-			if (dojo.lang.isFunction(prop.start)) {
-				prop.start = prop.start(prop, i);
-			}
-			if (dojo.lang.isFunction(prop.end)) {
-				prop.end = prop.end(prop, i);
-			}
-			if (dojo.lang.isArray(prop.start)) {
+		dojo.lang.forEach(properties, function(prop, i){
+			// calculate the end - start to optimize a bit
+			if(dojo.lang.isArray(prop.start)){
+				// don't loop through the arrays
 				this.diffs[i] = null;
-			} else {
-				if (prop.start instanceof dojo.gfx.color.Color) {
-					prop.startRgb = prop.start.toRgb();
-					prop.endRgb = prop.end.toRgb();
-				} else {
-					this.diffs[i] = prop.end - prop.start;
-				}
+			}else if(prop.start instanceof dojo.graphics.color.Color){
+				// save these so we don't have to call toRgb() every getValue() call
+				prop.startRgb = prop.start.toRgb();
+				prop.endRgb = prop.end.toRgb();
+			}else{
+				this.diffs[i] = prop.end - prop.start;
 			}
 		}, this);
-		this.getValue = function (n) {
+		this.getValue = function(n){
 			var ret = {};
-			dojo.lang.forEach(this._properties, function (prop, i) {
+			dojo.lang.forEach(this._properties, function(prop, i){
 				var value = null;
-				if (dojo.lang.isArray(prop.start)) {
-				} else {
-					if (prop.start instanceof dojo.gfx.color.Color) {
-						value = (prop.units || "rgb") + "(";
-						for (var j = 0; j < prop.startRgb.length; j++) {
-							value += Math.round(((prop.endRgb[j] - prop.startRgb[j]) * n) + prop.startRgb[j]) + (j < prop.startRgb.length - 1 ? "," : "");
-						}
-						value += ")";
-					} else {
-						value = ((this.diffs[i]) * n) + prop.start + (prop.property != "opacity" ? prop.units || "px" : "");
+				if(dojo.lang.isArray(prop.start)){
+					// FIXME: what to do here?
+				}else if(prop.start instanceof dojo.graphics.color.Color){
+					value = (prop.units||"rgb") + "(";
+					for(var j = 0 ; j < prop.startRgb.length ; j++){
+						value += Math.round(((prop.endRgb[j] - prop.startRgb[j]) * n) + prop.startRgb[j]) + (j < prop.startRgb.length - 1 ? "," : "");
 					}
+					value += ")";
+				}else{
+					value = ((this.diffs[i]) * n) + prop.start + (prop.property != "opacity" ? prop.units||"px" : "");
 				}
-				ret[dojo.html.toCamelCase(prop.property)] = value;
+				ret[dojo.style.toCamelCase(prop.property)] = value;
 			}, this);
 			return ret;
-		};
-	};
-	var anim = new dojo.lfx.Animation({beforeBegin:function () {
-		setEmUp(targs);
-		anim.curve = new propLine(targs.propertyMap);
-	}, onAnimate:function (propValues) {
-		dojo.lang.forEach(targs.nodes, function (node) {
-			setStyle(node, propValues);
-		});
-	}}, targs.duration, null, targs.easing);
-	if (handlers) {
-		for (var x in handlers) {
-			if (dojo.lang.isFunction(handlers[x])) {
-				anim.connect(x, anim, handlers[x]);
-			}
 		}
 	}
+	
+	var anim = new dojo.lfx.Animation({
+		onAnimate: function(propValues){
+			dojo.lang.forEach(nodes, function(node){
+				setStyle(node, propValues);
+			});
+		} }, duration, new propLine(propertyMap), easing);
+	
 	return anim;
-};
-dojo.lfx.html._makeFadeable = function (nodes) {
-	var makeFade = function (node) {
-		if (dojo.render.html.ie) {
-			if ((node.style.zoom.length == 0) && (dojo.html.getStyle(node, "zoom") == "normal")) {
+}
+
+dojo.lfx.html._makeFadeable = function(nodes){
+	var makeFade = function(node){
+		if(dojo.render.html.ie){
+			// only set the zoom if the "tickle" value would be the same as the
+			// default
+			if( (node.style.zoom.length == 0) &&
+				(dojo.style.getStyle(node, "zoom") == "normal") ){
+				// make sure the node "hasLayout"
+				// NOTE: this has been tested with larger and smaller user-set text
+				// sizes and works fine
 				node.style.zoom = "1";
+				// node.style.zoom = "normal";
 			}
-			if ((node.style.width.length == 0) && (dojo.html.getStyle(node, "width") == "auto")) {
+			// don't set the width to auto if it didn't already cascade that way.
+			// We don't want to f anyones designs
+			if(	(node.style.width.length == 0) &&
+				(dojo.style.getStyle(node, "width") == "auto") ){
 				node.style.width = "auto";
 			}
 		}
-	};
-	if (dojo.lang.isArrayLike(nodes)) {
+	}
+	if(dojo.lang.isArrayLike(nodes)){
 		dojo.lang.forEach(nodes, makeFade);
-	} else {
+	}else{
 		makeFade(nodes);
 	}
-};
-dojo.lfx.html.fade = function (nodes, values, duration, easing, callback) {
+}
+
+dojo.lfx.html.fadeIn = function(nodes, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
-	var props = {property:"opacity"};
-	if (!dj_undef("start", values)) {
-		props.start = values.start;
-	} else {
-		props.start = function () {
-			return dojo.html.getOpacity(nodes[0]);
-		};
+	dojo.lfx.html._makeFadeable(nodes);
+	var anim = dojo.lfx.propertyAnimation(nodes, [
+		{	property: "opacity",
+			start: dojo.style.getOpacity(nodes[0]),
+			end: 1 } ], duration, easing);
+	if(callback){
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
 	}
-	if (!dj_undef("end", values)) {
-		props.end = values.end;
-	} else {
-		dojo.raise("dojo.lfx.html.fade needs an end value");
+
+	return anim;
+}
+
+dojo.lfx.html.fadeOut = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	dojo.lfx.html._makeFadeable(nodes);
+	var anim = dojo.lfx.propertyAnimation(nodes, [
+		{	property: "opacity",
+			start: dojo.style.getOpacity(nodes[0]),
+			end: 0 } ], duration, easing);
+	if(callback){
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
 	}
-	var anim = dojo.lfx.propertyAnimation(nodes, [props], duration, easing);
-	anim.connect("beforeBegin", function () {
-		dojo.lfx.html._makeFadeable(nodes);
-	});
-	if (callback) {
-		anim.connect("onEnd", function () {
-			callback(nodes, anim);
-		});
-	}
+
 	return anim;
-};
-dojo.lfx.html.fadeIn = function (nodes, duration, easing, callback) {
-	return dojo.lfx.html.fade(nodes, {end:1}, duration, easing, callback);
-};
-dojo.lfx.html.fadeOut = function (nodes, duration, easing, callback) {
-	return dojo.lfx.html.fade(nodes, {end:0}, duration, easing, callback);
-};
-dojo.lfx.html.fadeShow = function (nodes, duration, easing, callback) {
-	nodes = dojo.lfx.html._byId(nodes);
-	dojo.lang.forEach(nodes, function (node) {
-		dojo.html.setOpacity(node, 0);
-	});
+}
+
+dojo.lfx.html.fadeShow = function(nodes, duration, easing, callback){
 	var anim = dojo.lfx.html.fadeIn(nodes, duration, easing, callback);
-	anim.connect("beforeBegin", function () {
-		if (dojo.lang.isArrayLike(nodes)) {
-			dojo.lang.forEach(nodes, dojo.html.show);
-		} else {
-			dojo.html.show(nodes);
+	var oldBb = (anim["beforeBegin"]) ? dojo.lang.hitch(anim, "beforeBegin") : function(){};
+	anim.beforeBegin = function(){ 
+		oldBb();
+		if(dojo.lang.isArrayLike(nodes)){
+			dojo.lang.forEach(nodes, dojo.style.show);
+		}else{
+			dojo.style.show(nodes);
 		}
-	});
+	};
+	
 	return anim;
-};
-dojo.lfx.html.fadeHide = function (nodes, duration, easing, callback) {
-	var anim = dojo.lfx.html.fadeOut(nodes, duration, easing, function () {
-		if (dojo.lang.isArrayLike(nodes)) {
-			dojo.lang.forEach(nodes, dojo.html.hide);
-		} else {
-			dojo.html.hide(nodes);
+}
+
+dojo.lfx.html.fadeHide = function(nodes, duration, easing, callback){
+	var anim = dojo.lfx.html.fadeOut(nodes, duration, easing, function(){
+		if(dojo.lang.isArrayLike(nodes)){
+			dojo.lang.forEach(nodes, dojo.style.hide);
+		}else{
+			dojo.style.hide(nodes);
 		}
-		if (callback) {
-			callback(nodes, anim);
-		}
+		if(callback){ callback(nodes, anim); }
 	});
+	
 	return anim;
-};
-dojo.lfx.html.wipeIn = function (nodes, duration, easing, callback) {
+}
+
+dojo.lfx.html.wipeIn = function(nodes, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	dojo.lang.forEach(nodes, function (node) {
-		var oprop = {};
-		var origTop, origLeft, origPosition;
-		with (node.style) {
-			origTop = top;
-			origLeft = left;
-			origPosition = position;
-			top = "-9999px";
-			left = "-9999px";
-			position = "absolute";
-			display = "";
+
+	dojo.lang.forEach(nodes, function(node){
+		var overflow = dojo.style.getStyle(node, "overflow");
+		if(overflow == "visible") {
+			node.style.overflow = "hidden";
 		}
-		var nodeHeight = dojo.html.getBorderBox(node).height;
-		with (node.style) {
-			top = origTop;
-			left = origLeft;
-			position = origPosition;
-			display = "none";
-		}
-		var anim = dojo.lfx.propertyAnimation(node, {"height":{start:1, end:function () {
-			return nodeHeight;
-		}}}, duration, easing);
-		anim.connect("beforeBegin", function () {
-			oprop.overflow = node.style.overflow;
-			oprop.height = node.style.height;
-			with (node.style) {
-				overflow = "hidden";
-				height = "1px";
-			}
-			dojo.html.show(node);
-		});
-		anim.connect("onEnd", function () {
-			with (node.style) {
-				overflow = oprop.overflow;
-				height = oprop.height;
-			}
-			if (callback) {
-				callback(node, anim);
-			}
-		});
+		node.style.height = "0px";
+		dojo.style.show(node);
+		
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: "height",
+				start: 0,
+				end: node.scrollHeight }], duration, easing);
+		
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd(); 
+			node.style.overflow = overflow;
+			node.style.height = "auto";
+			if(callback){ callback(node, anim); }
+		};
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
-dojo.lfx.html.wipeOut = function (nodes, duration, easing, callback) {
+	
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.wipeOut = function(nodes, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	dojo.lang.forEach(nodes, function (node) {
-		var oprop = {};
-		var anim = dojo.lfx.propertyAnimation(node, {"height":{start:function () {
-			return dojo.html.getContentBox(node).height;
-		}, end:1}}, duration, easing, {"beforeBegin":function () {
-			oprop.overflow = node.style.overflow;
-			oprop.height = node.style.height;
-			with (node.style) {
-				overflow = "hidden";
-			}
-			dojo.html.show(node);
-		}, "onEnd":function () {
-			dojo.html.hide(node);
-			with (node.style) {
-				overflow = oprop.overflow;
-				height = oprop.height;
-			}
-			if (callback) {
-				callback(node, anim);
-			}
-		}});
+	
+	dojo.lang.forEach(nodes, function(node){
+		var overflow = dojo.style.getStyle(node, "overflow");
+		if(overflow == "visible") {
+			node.style.overflow = "hidden";
+		}
+		dojo.style.show(node);
+
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: "height",
+				start: dojo.style.getContentBoxHeight(node),
+				end: 0 } ], duration, easing);
+		
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd(); 
+			dojo.style.hide(node);
+			node.style.overflow = overflow;
+			if(callback){ callback(node, anim); }
+		};
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
-dojo.lfx.html.slideTo = function (nodes, coords, duration, easing, callback) {
+
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else { return anims[0]; }
+}
+
+dojo.lfx.html.slideTo = function(nodes, coords, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	var compute = dojo.html.getComputedStyle;
-	if (dojo.lang.isArray(coords)) {
-		dojo.deprecated("dojo.lfx.html.slideTo(node, array)", "use dojo.lfx.html.slideTo(node, {top: value, left: value});", "0.5");
-		coords = {top:coords[0], left:coords[1]};
-	}
-	dojo.lang.forEach(nodes, function (node) {
+
+	dojo.lang.forEach(nodes, function(node){
 		var top = null;
 		var left = null;
-		var init = (function () {
+		
+		var init = (function(){
 			var innerNode = node;
-			return function () {
-				var pos = compute(innerNode, "position");
-				top = (pos == "absolute" ? node.offsetTop : parseInt(compute(node, "top")) || 0);
-				left = (pos == "absolute" ? node.offsetLeft : parseInt(compute(node, "left")) || 0);
-				if (!dojo.lang.inArray(["absolute", "relative"], pos)) {
-					var ret = dojo.html.abs(innerNode, true);
-					dojo.html.setStyleAttributes(innerNode, "position:absolute;top:" + ret.y + "px;left:" + ret.x + "px;");
+			return function(){
+				top = innerNode.offsetTop;
+				left = innerNode.offsetLeft;
+
+				if (!dojo.style.isPositionAbsolute(innerNode)) {
+					var ret = dojo.style.abs(innerNode, true);
+					dojo.style.setStyleAttributes(innerNode, "position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
 					top = ret.y;
 					left = ret.x;
 				}
-			};
+			}
 		})();
 		init();
-		var anim = dojo.lfx.propertyAnimation(node, {"top":{start:top, end:(coords.top || 0)}, "left":{start:left, end:(coords.left || 0)}}, duration, easing, {"beforeBegin":init});
-		if (callback) {
-			anim.connect("onEnd", function () {
-				callback(nodes, anim);
-			});
+		
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: "top",
+				start: top,
+				end: coords[0] },
+			{	property: "left",
+				start: left,
+				end: coords[1] }], duration, easing);
+		
+		var oldBb = (anim["beforeBegin"]) ? dojo.lang.hitch(anim, "beforeBegin") : function(){};
+		anim.beforeBegin = function(){ oldBb(); init(); };
+
+		if(callback){
+			var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+			anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
 		}
+
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
-dojo.lfx.html.slideBy = function (nodes, coords, duration, easing, callback) {
+	
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.slideBy = function(nodes, coords, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	var compute = dojo.html.getComputedStyle;
-	if (dojo.lang.isArray(coords)) {
-		dojo.deprecated("dojo.lfx.html.slideBy(node, array)", "use dojo.lfx.html.slideBy(node, {top: value, left: value});", "0.5");
-		coords = {top:coords[0], left:coords[1]};
-	}
-	dojo.lang.forEach(nodes, function (node) {
+
+	dojo.lang.forEach(nodes, function(node){
 		var top = null;
 		var left = null;
-		var init = (function () {
+		
+		var init = (function(){
 			var innerNode = node;
-			return function () {
-				var pos = compute(innerNode, "position");
-				top = (pos == "absolute" ? node.offsetTop : parseInt(compute(node, "top")) || 0);
-				left = (pos == "absolute" ? node.offsetLeft : parseInt(compute(node, "left")) || 0);
-				if (!dojo.lang.inArray(["absolute", "relative"], pos)) {
-					var ret = dojo.html.abs(innerNode, true);
-					dojo.html.setStyleAttributes(innerNode, "position:absolute;top:" + ret.y + "px;left:" + ret.x + "px;");
+			return function(){
+				top = node.offsetTop;
+				left = node.offsetLeft;
+
+				if (!dojo.style.isPositionAbsolute(innerNode)) {
+					var ret = dojo.style.abs(innerNode);
+					dojo.style.setStyleAttributes(innerNode, "position:absolute;top:"+ret.y+"px;left:"+ret.x+"px;");
 					top = ret.y;
 					left = ret.x;
 				}
-			};
+			}
 		})();
 		init();
-		var anim = dojo.lfx.propertyAnimation(node, {"top":{start:top, end:top + (coords.top || 0)}, "left":{start:left, end:left + (coords.left || 0)}}, duration, easing).connect("beforeBegin", init);
-		if (callback) {
-			anim.connect("onEnd", function () {
-				callback(nodes, anim);
-			});
+		
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: "top",
+				start: top,
+				end: top+coords[0] },
+			{	property: "left",
+				start: left,
+				end: left+coords[1] }], duration, easing);
+
+		var oldBb = (anim["beforeBegin"]) ? dojo.lang.hitch(anim, "beforeBegin") : function(){};
+		anim.beforeBegin = function(){ oldBb(); init(); };
+
+		if(callback){
+			var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+			anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
 		}
+
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
-dojo.lfx.html.explode = function (start, endNode, duration, easing, callback) {
-	var h = dojo.html;
+
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.explode = function(start, endNode, duration, easing, callback){
 	start = dojo.byId(start);
 	endNode = dojo.byId(endNode);
-	var startCoords = h.toCoordinateObject(start, true);
+	var startCoords = dojo.style.toCoordinateArray(start, true);
 	var outline = document.createElement("div");
-	h.copyStyle(outline, endNode);
-	if (endNode.explodeClassName) {
-		outline.className = endNode.explodeClassName;
-	}
-	with (outline.style) {
+	dojo.html.copyStyle(outline, endNode);
+	with(outline.style){
 		position = "absolute";
 		display = "none";
-		var backgroundStyle = h.getStyle(start, "background-color");
-		backgroundColor = backgroundStyle ? backgroundStyle.toLowerCase() : "transparent";
-		backgroundColor = (backgroundColor == "transparent") ? "rgb(221, 221, 221)" : backgroundColor;
 	}
-	dojo.body().appendChild(outline);
-	with (endNode.style) {
+	document.body.appendChild(outline);
+
+	with(endNode.style){
 		visibility = "hidden";
 		display = "block";
 	}
-	var endCoords = h.toCoordinateObject(endNode, true);
-	with (endNode.style) {
+	var endCoords = dojo.style.toCoordinateArray(endNode, true);
+	with(endNode.style){
 		display = "none";
 		visibility = "visible";
 	}
-	var props = {opacity:{start:0.5, end:1}};
-	dojo.lang.forEach(["height", "width", "top", "left"], function (type) {
-		props[type] = {start:startCoords[type], end:endCoords[type]};
-	});
-	var anim = new dojo.lfx.propertyAnimation(outline, props, duration, easing, {"beforeBegin":function () {
-		h.setDisplay(outline, "block");
-	}, "onEnd":function () {
-		h.setDisplay(endNode, "block");
+
+	var anim = new dojo.lfx.propertyAnimation(outline, [
+		{ property: "height", start: startCoords[3], end: endCoords[3] },
+		{ property: "width", start: startCoords[2], end: endCoords[2] },
+		{ property: "top", start: startCoords[1], end: endCoords[1] },
+		{ property: "left", start: startCoords[0], end: endCoords[0] },
+		{ property: "opacity", start: 0.3, end: 1.0 }
+	], duration, easing);
+	
+	anim.beforeBegin = function(){
+		dojo.style.setDisplay(outline, "block");
+	};
+	anim.onEnd = function(){
+		dojo.style.setDisplay(endNode, "block");
 		outline.parentNode.removeChild(outline);
-	}});
-	if (callback) {
-		anim.connect("onEnd", function () {
-			callback(endNode, anim);
-		});
+	};
+	if(callback){
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(endNode, anim); };
 	}
 	return anim;
-};
-dojo.lfx.html.implode = function (startNode, end, duration, easing, callback) {
-	var h = dojo.html;
+}
+
+dojo.lfx.html.implode = function(startNode, end, duration, easing, callback){
 	startNode = dojo.byId(startNode);
 	end = dojo.byId(end);
-	var startCoords = dojo.html.toCoordinateObject(startNode, true);
-	var endCoords = dojo.html.toCoordinateObject(end, true);
+	var startCoords = dojo.style.toCoordinateArray(startNode, true);
+	var endCoords = dojo.style.toCoordinateArray(end, true);
+
 	var outline = document.createElement("div");
 	dojo.html.copyStyle(outline, startNode);
-	if (startNode.explodeClassName) {
-		outline.className = startNode.explodeClassName;
-	}
-	dojo.html.setOpacity(outline, 0.3);
-	with (outline.style) {
+	dojo.style.setOpacity(outline, 0.3);
+	with(outline.style){
 		position = "absolute";
 		display = "none";
-		backgroundColor = h.getStyle(startNode, "background-color").toLowerCase();
 	}
-	dojo.body().appendChild(outline);
-	var props = {opacity:{start:1, end:0.5}};
-	dojo.lang.forEach(["height", "width", "top", "left"], function (type) {
-		props[type] = {start:startCoords[type], end:endCoords[type]};
-	});
-	var anim = new dojo.lfx.propertyAnimation(outline, props, duration, easing, {"beforeBegin":function () {
-		dojo.html.hide(startNode);
-		dojo.html.show(outline);
-	}, "onEnd":function () {
+	document.body.appendChild(outline);
+
+	var anim = new dojo.lfx.propertyAnimation(outline, [
+		{ property: "height", start: startCoords[3], end: endCoords[3] },
+		{ property: "width", start: startCoords[2], end: endCoords[2] },
+		{ property: "top", start: startCoords[1], end: endCoords[1] },
+		{ property: "left", start: startCoords[0], end: endCoords[0] },
+		{ property: "opacity", start: 1.0, end: 0.3 }
+	], duration, easing);
+	
+	anim.beforeBegin = function(){
+		dojo.style.hide(startNode);
+		dojo.style.show(outline);
+	};
+	anim.onEnd = function(){
 		outline.parentNode.removeChild(outline);
-	}});
-	if (callback) {
-		anim.connect("onEnd", function () {
-			callback(startNode, anim);
-		});
+	};
+	if(callback){
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(startNode, anim); };
 	}
 	return anim;
-};
-dojo.lfx.html.highlight = function (nodes, startColor, duration, easing, callback) {
+}
+
+dojo.lfx.html.highlight = function(nodes, startColor, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	dojo.lang.forEach(nodes, function (node) {
-		var color = dojo.html.getBackgroundColor(node);
-		var bg = dojo.html.getStyle(node, "background-color").toLowerCase();
-		var bgImage = dojo.html.getStyle(node, "background-image");
+
+	dojo.lang.forEach(nodes, function(node){
+		var color = dojo.style.getBackgroundColor(node);
+		var bg = dojo.style.getStyle(node, "background-color").toLowerCase();
+		var bgImage = dojo.style.getStyle(node, "background-image");
 		var wasTransparent = (bg == "transparent" || bg == "rgba(0, 0, 0, 0)");
-		while (color.length > 3) {
-			color.pop();
-		}
-		var rgb = new dojo.gfx.color.Color(startColor);
-		var endRgb = new dojo.gfx.color.Color(color);
-		var anim = dojo.lfx.propertyAnimation(node, {"background-color":{start:rgb, end:endRgb}}, duration, easing, {"beforeBegin":function () {
-			if (bgImage) {
+		while(color.length > 3) { color.pop(); }
+
+		var rgb = new dojo.graphics.color.Color(startColor);
+		var endRgb = new dojo.graphics.color.Color(color);
+
+		var anim = dojo.lfx.propertyAnimation(node, [{
+			property: "background-color",
+			start: rgb,
+			end: endRgb
+		}], duration, easing);
+
+		var oldbb = (anim["beforeBegin"]) ? dojo.lang.hitch(anim, "beforeBegin") : function(){};
+		anim.beforeBegin = function(){ 
+			oldbb();
+			if(bgImage){
 				node.style.backgroundImage = "none";
 			}
 			node.style.backgroundColor = "rgb(" + rgb.toRgb().join(",") + ")";
-		}, "onEnd":function () {
-			if (bgImage) {
+		};
+
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd();
+			if(bgImage){
 				node.style.backgroundImage = bgImage;
 			}
-			if (wasTransparent) {
+			if(wasTransparent){
 				node.style.backgroundColor = "transparent";
 			}
-			if (callback) {
+			if(callback){
 				callback(node, anim);
 			}
-		}});
+		};
+
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
-dojo.lfx.html.unhighlight = function (nodes, endColor, duration, easing, callback) {
+
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.unhighlight = function(nodes, endColor, duration, easing, callback){
 	nodes = dojo.lfx.html._byId(nodes);
 	var anims = [];
-	dojo.lang.forEach(nodes, function (node) {
-		var color = new dojo.gfx.color.Color(dojo.html.getBackgroundColor(node));
-		var rgb = new dojo.gfx.color.Color(endColor);
-		var bgImage = dojo.html.getStyle(node, "background-image");
-		var anim = dojo.lfx.propertyAnimation(node, {"background-color":{start:color, end:rgb}}, duration, easing, {"beforeBegin":function () {
-			if (bgImage) {
+
+	dojo.lang.forEach(nodes, function(node){
+		var color = new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node));
+		var rgb = new dojo.graphics.color.Color(endColor);
+
+		var bgImage = dojo.style.getStyle(node, "background-image");
+		
+		var anim = dojo.lfx.propertyAnimation(node, [{
+			property: "background-color",
+			start: color,
+			end: rgb
+		}], duration, easing);
+
+		var oldbb = (anim["beforeBegin"]) ? dojo.lang.hitch(anim, "beforeBegin") : function(){};
+		anim.beforeBegin = function(){ 
+			oldbb();
+			if(bgImage){
 				node.style.backgroundImage = "none";
 			}
 			node.style.backgroundColor = "rgb(" + color.toRgb().join(",") + ")";
-		}, "onEnd":function () {
-			if (callback) {
+		};
+
+		var oldOnEnd = (anim["onEnd"]) ? dojo.lang.hitch(anim, "onEnd") : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd();
+			if(callback){
 				callback(node, anim);
 			}
-		}});
+		};
+
 		anims.push(anim);
 	});
-	return dojo.lfx.combine(anims);
-};
+
+	if(nodes.length > 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
 dojo.lang.mixin(dojo.lfx, dojo.lfx.html);
-

Deleted: tags/parley-0.53/root/static/magic/src/lfx/rounded.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/rounded.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/rounded.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,444 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.lfx.rounded");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.html.common");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.layout");
-dojo.lfx.rounded = function (settings) {
-	var options = {validTags:settings.validTags || ["div"], autoPad:settings.autoPad != null ? settings.autoPad : true, antiAlias:settings.antiAlias != null ? settings.antiAlias : true, radii:{tl:(settings.tl && settings.tl.radius != null) ? settings.tl.radius : 5, tr:(settings.tr && settings.tr.radius != null) ? settings.tr.radius : 5, bl:(settings.bl && settings.bl.radius != null) ? settings.bl.radius : 5, br:(settings.br && settings.br.radius != null) ? settings.br.radius : 5}};
-	var nodes;
-	if (typeof (arguments[1]) == "string") {
-		nodes = dojo.html.getElementsByClass(arguments[1]);
-	} else {
-		if (dojo.lang.isArrayLike(arguments[1])) {
-			nodes = arguments[1];
-			for (var i = 0; i < nodes.length; i++) {
-				nodes[i] = dojo.byId(nodes[i]);
-			}
-		}
-	}
-	if (nodes.length == 0) {
-		return;
-	}
-	for (var i = 0; i < nodes.length; i++) {
-		dojo.lfx.rounded.applyCorners(options, nodes[i]);
-	}
-};
-dojo.lfx.rounded.applyCorners = function (options, node) {
-	var top = null;
-	var bottom = null;
-	var contentNode = null;
-	var fns = dojo.lfx.rounded._fns;
-	var width = node.offsetWidth;
-	var height = node.offsetHeight;
-	var borderWidth = parseInt(dojo.html.getComputedStyle(node, "border-top-width"));
-	var borderColor = dojo.html.getComputedStyle(node, "border-top-color");
-	var color = dojo.html.getComputedStyle(node, "background-color");
-	var bgImage = dojo.html.getComputedStyle(node, "background-image");
-	var position = dojo.html.getComputedStyle(node, "position");
-	var padding = parseInt(dojo.html.getComputedStyle(node, "padding-top"));
-	var format = {height:height, width:width, borderWidth:borderWidth, color:fns.getRGB(color), padding:padding, borderColor:fns.getRGB(borderColor), borderString:borderWidth + "px" + " solid " + fns.getRGB(borderColor), bgImage:((bgImage != "none") ? bgImage : ""), content:node.innerHTML};
-	if (!dojo.html.isPositionAbsolute(node)) {
-		node.style.position = "relative";
-	}
-	node.style.padding = "0px";
-	if (dojo.render.html.ie && width == "auto" && height == "auto") {
-		node.style.width = "100%";
-	}
-	if (options.autoPad && format.padding > 0) {
-		node.innerHTML = "";
-	}
-	var topHeight = Math.max(options.radii.tl, options.radii.tr);
-	var bottomHeight = Math.max(options.radii.bl, options.radii.br);
-	if (options.radii.tl || options.radii.tr) {
-		top = document.createElement("div");
-		top.style.width = "100%";
-		top.style.fontSize = "1px";
-		top.style.overflow = "hidden";
-		top.style.position = "absolute";
-		top.style.paddingLeft = format.borderWidth + "px";
-		top.style.paddingRight = format.borderWidth + "px";
-		top.style.height = topHeight + "px";
-		top.style.top = (0 - topHeight) + "px";
-		top.style.left = (0 - format.borderWidth) + "px";
-		node.appendChild(top);
-	}
-	if (options.radii.bl || options.radii.br) {
-		bottom = document.createElement("div");
-		bottom.style.width = "100%";
-		bottom.style.fontSize = "1px";
-		bottom.style.overflow = "hidden";
-		bottom.style.position = "absolute";
-		bottom.style.paddingLeft = format.borderWidth + "px";
-		bottom.style.paddingRight = format.borderWidth + "px";
-		bottom.style.height = bottomHeight + "px";
-		bottom.style.bottom = (0 - bottomHeight) + "px";
-		bottom.style.left = (0 - format.borderWidth) + "px";
-		node.appendChild(bottom);
-	}
-	if (top) {
-		node.style.borderTopWidth = "0px";
-	}
-	if (bottom) {
-		node.style.borderBottomWidth = "0px";
-	}
-	var corners = ["tr", "tl", "br", "bl"];
-	for (var i = 0; i < corners.length; i++) {
-		var cc = corners[i];
-		if (options.radii[cc] == 0) {
-			if ((cc.charAt(0) == "t" && top) || (cc.charAt(0) == "b" && bottom)) {
-				var corner = document.createElement("div");
-				corner.style.position = "relative";
-				corner.style.fontSize = "1px;";
-				corner.style.overflow = "hidden";
-				if (format.bgImage == "") {
-					corner.style.backgroundColor = format.color;
-				} else {
-					corner.style.backgroundImage = format.bgImage;
-				}
-				switch (cc) {
-				  case "tl":
-					corner.style.height = topHeight - format.borderWidth + "px";
-					corner.style.marginRight = options.radii[cc] - (format.borderWidth * 2) + "px";
-					corner.style.borderLeft = format.borderString;
-					corner.style.borderTop = format.borderString;
-					corner.style.left = -format.borderWidth + "px";
-					break;
-				  case "tr":
-					corner.style.height = topHeight - format.borderWidth + "px";
-					corner.style.marginLeft = options.radii[cc] - (format.borderWidth * 2) + "px";
-					corner.style.borderRight = format.borderString;
-					corner.style.borderTop = format.borderString;
-					corner.style.backgroundPosition = "-" + (topHeight - format.borderWidth) + "px 0px";
-					corner.style.left = format.borderWidth + "px";
-					break;
-				  case "bl":
-					corner.style.height = bottomHeight - format.borderWidth + "px";
-					corner.style.marginRight = options.radii[cc] - (format.borderWidth * 2) + "px";
-					corner.style.borderLeft = format.borderString;
-					corner.style.borderBottom = format.borderString;
-					corner.style.left = format.borderWidth + "px";
-					corner.style.backgroundPosition = "-" + format.borderWidth + "px -" + (format.height + (bottomHeight + format.borderWidth)) + "px";
-					break;
-				  case "br":
-					corner.style.height = bottomHeight - format.borderWidth + "px";
-					corner.style.marginLeft = options.radii[cc] - (format.borderWidth * 2) + "px";
-					corner.style.borderRight = format.borderString;
-					corner.style.borderBottom = format.borderString;
-					corner.style.left = format.borderWidth + "px";
-					corner.style.backgroundPosition = "-" + (bottomHeight + format.borderWidth) + "px -" + (format.height + (bottomHeight + format.borderWidth)) + "px";
-					break;
-				}
-			}
-		} else {
-			var corner = document.createElement("div");
-			corner.style.height = options.radii[cc] + "px";
-			corner.style.width = options.radii[cc] + "px";
-			corner.style.position = "absolute";
-			corner.style.fontSize = "1px";
-			corner.style.overflow = "hidden";
-			var borderRadius = Math.floor(options.radii[cc] - format.borderWidth);
-			for (var x = 0, j = options.radii[cc]; x < j; x++) {
-				var y1 = Math.floor(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow((x + 1), 2))) - 1;
-				if ((x + 1) >= borderRadius) {
-					var y1 = -1;
-				}
-				var y2 = Math.ceil(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow(x, 2)));
-				if (x >= borderRadius) {
-					y2 = -1;
-				}
-				var y3 = Math.floor(Math.sqrt(Math.pow(j, 2) - Math.pow((x + 1), 2))) - 1;
-				if ((x + 1) >= j) {
-					y3 = -1;
-				}
-				var y4 = Math.ceil(Math.sqrt(Math.pow(j, 2) - Math.pow(x, 2)));
-				if (x >= j) {
-					y4 = -1;
-				}
-				if (y1 > -1) {
-					fns.draw(x, 0, format.color, 100, (y1 + 1), corner, -1, j, topHeight, format);
-				}
-				for (var y = (y1 + 1); y < y2; y++) {
-					if (options.antiAlias) {
-						if (format.bgImage != "") {
-							var fract = fns.fraction(x, y, borderRadius) * 100;
-							if (fract < 30) {
-								fns.draw(x, y, format.borderColor, 100, 1, corner, 0, options.radii[cc], topHeight, format);
-							} else {
-								fns.draw(x, y, format.borderColor, 100, 1, corner, -1, options.radii[cc], topHeight, format);
-							}
-						} else {
-							var clr = fns.blend(format.color, format.borderColor, fns.fraction(x, y, borderRadius));
-							fns.draw(x, y, clr, 100, 1, corner, 0, options.radii[cc], topHeight, format);
-						}
-					}
-				}
-				if (options.antiAlias) {
-					if (y3 >= y2) {
-						if (y2 == -1) {
-							y2 = 0;
-						}
-						fns.draw(x, y2, format.borderColor, 100, (y3 - y2 + 1), corner, 0, 0, topHeight, format);
-					} else {
-						if (y3 >= y1) {
-							fns.draw(x, (y1 + 1), format.borderColor, 100, (y3 - y1), corner, 0, 0, topHeight, format);
-						}
-					}
-					for (var y = (y3 + 1); y < y4; y++) {
-						fns.draw(x, y, format.borderColor, (fns.fraction(x, y, j) * 100), 1, corner, (format.borderWidth > 0 ? 0 : -1), options.radii[cc], topHeight, format);
-					}
-				} else {
-					y3 = y1;
-				}
-			}
-			if (cc != "br") {
-				for (var t = 0, k = corner.childNodes.length; t < k; t++) {
-					var bar = corner.childNodes[t];
-					var barTop = parseInt(dojo.html.getComputedStyle(bar, "top"));
-					var barLeft = parseInt(dojo.html.getComputedStyle(bar, "left"));
-					var barHeight = parseInt(dojo.html.getComputedStyle(bar, "height"));
-					if (cc.charAt(1) == "l") {
-						bar.style.left = (options.radii[cc] - barLeft - 1) + "px";
-					}
-					if (cc == "tr") {
-						bar.style.top = (options.radii[cc] - barHeight - barTop) + "px";
-						bar.style.backgroundPosition = "-" + Math.abs((format.width - options.radii[cc] + format.borderWidth) + barLeft) + "px -" + Math.abs(options.radii[cc] - barHeight - barTop - format.borderWidth) + "px";
-					} else {
-						if (cc == "tl") {
-							bar.style.top = (options.radii[cc] - barHeight - barTop) + "px";
-							bar.style.backgroundPosition = "-" + Math.abs((options.radii[cc] - barLeft - 1) - format.borderWidth) + "px -" + Math.abs(options.radii[cc] - barHeight - barTop - format.borderWidth) + "px";
-						} else {
-							bar.style.backgroundPosition = "-" + Math.abs((options.radii[cc] + barLeft) + format.borderWidth) + "px -" + Math.abs((format.height + options.radii[cc] + barTop) - format.borderWidth) + "px";
-						}
-					}
-				}
-			}
-		}
-		if (corner) {
-			var psn = [];
-			if (cc.charAt(0) == "t") {
-				psn.push("top");
-			} else {
-				psn.push("bottom");
-			}
-			if (cc.charAt(1) == "l") {
-				psn.push("left");
-			} else {
-				psn.push("right");
-			}
-			if (corner.style.position == "absolute") {
-				for (var z = 0; z < psn.length; z++) {
-					corner.style[psn[z]] = "0px";
-				}
-			}
-			if (psn[0] == "top") {
-				if (top) {
-					top.appendChild(corner);
-				}
-			} else {
-				if (bottom) {
-					bottom.appendChild(corner);
-				}
-			}
-		}
-	}
-	var diff = {t:Math.abs(options.radii.tl - options.radii.tr), b:Math.abs(options.radii.bl - options.radii.br)};
-	for (var z in diff) {
-		var smaller = (options.radii[z + "l"] < options.radii[z + "r"] ? z + "l" : z + "r");
-		var filler = document.createElement("div");
-		filler.style.height = diff[z] + "px";
-		filler.style.width = options.radii[smaller] + "px";
-		filler.style.position = "absolute";
-		filler.style.fontSize = "1px";
-		filler.style.overflow = "hidden";
-		filler.style.backgroundColor = format.color;
-		switch (smaller) {
-		  case "tl":
-			filler.style.bottom = "0px";
-			filler.style.left = "0px";
-			filler.style.borderLeft = format.borderString;
-			top.appendChild(filler);
-			break;
-		  case "tr":
-			filler.style.bottom = "0px";
-			filler.style.right = "0px";
-			filler.style.borderRight = format.borderString;
-			top.appendChild(filler);
-			break;
-		  case "bl":
-			filler.style.top = "0px";
-			filler.style.left = "0px";
-			filler.style.borderLeft = format.borderString;
-			bottom.appendChild(filler);
-			break;
-		  case "br":
-			filler.style.top = "0px";
-			filler.style.right = "0px";
-			filler.style.borderRight = format.borderString;
-			bottom.appendChild(filler);
-			break;
-		}
-		var fillBar = document.createElement("div");
-		fillBar.style.position = "relative";
-		fillBar.style.fontSize = "1px";
-		fillBar.style.overflow = "hidden";
-		fillBar.style.backgroundColor = format.color;
-		fillBar.style.backgroundImage = format.bgImage;
-		if (z == "t") {
-			if (top) {
-				if (options.radii.tl && options.radii.tr) {
-					fillBar.style.height = (topHeight - format.borderWidth) + "px";
-					fillBar.style.marginLeft = (options.radii.tl - format.borderWidth) + "px";
-					fillBar.style.marginRight = (options.radii.tr - format.borderWidth) + "px";
-					fillBar.style.borderTop = format.borderString;
-					if (format.bgImage != "") {
-						fillBar.style.backgroundPosition = "-" + (topHeight + format.borderWidth) + "px 0px";
-					}
-				}
-				top.appendChild(fillBar);
-			}
-		} else {
-			if (bottom) {
-				if (options.radii.bl && options.radii.br) {
-					fillBar.style.height = (bottomHeight - format.borderWidth) + "px";
-					fillBar.style.marginLeft = (options.radii.bl - format.borderWidth) + "px";
-					fillBar.style.marginRight = (options.radii.br - format.borderWidth) + "px";
-					fillBar.style.borderBottom = format.borderString;
-					if (format.bgImage != "") {
-						fillBar.style.backgroundPosition = "-" + (bottomHeight + format.borderWidth) + "px -" + (format.height + (topHeight + format.borderWidth)) + "px";
-					}
-				}
-				bottom.appendChild(fillBar);
-			}
-		}
-	}
-	if (options.autoPad && format.padding > 0) {
-		var content = document.createElement("div");
-		content.style.position = "relative";
-		content.innerHTML = format.content;
-		content.className = "autoPadDiv";
-		if (topHeight < format.padding) {
-			content.style.paddingTop = Math.abs(topHeight - format.padding) + "px";
-		}
-		if (bottomHeight < format.padding) {
-			content.style.paddingBottom = Math.abs(bottomHeight - format.padding) + "px";
-		}
-		content.style.paddingLeft = format.padding + "px";
-		content.style.paddingRight = format.padding + "px";
-		node.appendChild(content);
-	}
-};
-var count = 0;
-dojo.lfx.rounded._fns = {blend:function (clr1, clr2, frac) {
-	var c1 = {r:parseInt(clr1.substr(1, 2), 16), g:parseInt(clr1.substr(3, 2), 16), b:parseInt(clr1.substr(5, 2), 16)};
-	var c2 = {r:parseInt(clr2.substr(1, 2), 16), g:parseInt(clr2.substr(3, 2), 16), b:parseInt(clr2.substr(5, 2), 16)};
-	if (frac > 1 || frac < 0) {
-		frac = 1;
-	}
-	var ret = [Math.min(Math.max(Math.round((c1.r * frac) + (c2.r * (1 - frac))), 0), 255), Math.min(Math.max(Math.round((c1.g * frac) + (c2.g * (1 - frac))), 0), 255), Math.min(Math.max(Math.round((c1.b * frac) + (c2.b * (1 - frac))), 0), 255)];
-	for (var i = 0; i < ret.length; i++) {
-		var n = ret[i].toString(16);
-		if (n.length < 2) {
-			n = "0" + n;
-		}
-		ret[i] = n;
-	}
-	return "#" + ret.join("");
-}, fraction:function (x, y, r) {
-	var frac = 0;
-	var xval = [];
-	var yval = [];
-	var point = 0;
-	var whatsides = "";
-	var intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(x, 2)));
-	if (intersect >= y && intersect < (y + 1)) {
-		whatsides = "Left";
-		xval[point] = 0;
-		yval[point++] = intersect - y;
-	}
-	intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(y + 1, 2)));
-	if (intersect >= x && intersect < (x + 1)) {
-		whatsides += "Top";
-		xval[point] = intersect - x;
-		yval[point++] = 1;
-	}
-	intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(x + 1, 2)));
-	if (intersect >= y && intersect < (y + 1)) {
-		whatsides += "Right";
-		xval[point] = 1;
-		yval[point++] = intersect - y;
-	}
-	intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(y, 2)));
-	if (intersect >= x && intersect < (x + 1)) {
-		whatsides += "Bottom";
-		xval[point] = intersect - x;
-		yval[point] = 1;
-	}
-	switch (whatsides) {
-	  case "LeftRight":
-		return Math.min(yval[0], yval[1]) + ((Math.max(yval[0], yval[1]) - Math.min(yval[0], yval[1])) / 2);
-	  case "TopRight":
-		return 1 - (((1 - xval[0]) * (1 - yval[1])) / 2);
-	  case "TopBottom":
-		return Math.min(xval[0], xval[1]) + ((Math.max(xval[0], xval[1]) - Math.min(xval[0], xval[1])) / 2);
-	  case "LeftBottom":
-		return (yval[0] * xval[1]) / 2;
-	  default:
-		return 1;
-	}
-}, draw:function (x, y, color, opac, height, corner, image, radius, top, format) {
-	var px = document.createElement("div");
-	px.style.height = height + "px";
-	px.style.width = "1px";
-	px.style.position = "absolute";
-	px.style.fontSize = "1px";
-	px.style.overflow = "hidden";
-	if (image == -1 && format.bgImage != "") {
-		px.style.backgroundImage = format.bgImage;
-		px.style.backgroundPosition = "-" + (format.width - (radius - x) + format.borderWidth) + "px -" + ((format.height + top + y) - format.borderWidth) + "px";
-	} else {
-		px.style.backgroundColor = color;
-	}
-	if (opac != 100) {
-		dojo.html.setOpacity(px, (opac / 100));
-	}
-	px.style.top = y + "px";
-	px.style.left = x + "px";
-	corner.appendChild(px);
-}, getRGB:function (clr) {
-	var ret = "#ffffff";
-	if (clr != "" && clr != "transparent") {
-		if (clr.substr(0, 3) == "rgb") {
-			var t = clr.substring(4, clr.indexOf(")"));
-			t = t.split(",");
-			for (var i = 0; i < t.length; i++) {
-				var n = parseInt(t[i]).toString(16);
-				if (n.length < 2) {
-					n = "0" + n;
-				}
-				t[i] = n;
-			}
-			ret = "#" + t.join("");
-		} else {
-			if (clr.length == 4) {
-				ret = "#" + clr.substring(1, 2) + clr.substring(1, 2) + clr.substring(2, 3) + clr.substring(2, 3) + clr.substring(3, 4) + clr.substring(3, 4);
-			} else {
-				ret = clr;
-			}
-		}
-	}
-	return ret;
-}};
-

Deleted: tags/parley-0.53/root/static/magic/src/lfx/shadow.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/shadow.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/shadow.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,75 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.lfx.shadow");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.uri.Uri");
-dojo.lfx.shadow = function (node) {
-	this.shadowPng = dojo.uri.moduleUri("dojo.html", "images/shadow");
-	this.shadowThickness = 8;
-	this.shadowOffset = 15;
-	this.init(node);
-};
-dojo.extend(dojo.lfx.shadow, {init:function (node) {
-	this.node = node;
-	this.pieces = {};
-	var x1 = -1 * this.shadowThickness;
-	var y0 = this.shadowOffset;
-	var y1 = this.shadowOffset + this.shadowThickness;
-	this._makePiece("tl", "top", y0, "left", x1);
-	this._makePiece("l", "top", y1, "left", x1, "scale");
-	this._makePiece("tr", "top", y0, "left", 0);
-	this._makePiece("r", "top", y1, "left", 0, "scale");
-	this._makePiece("bl", "top", 0, "left", x1);
-	this._makePiece("b", "top", 0, "left", 0, "crop");
-	this._makePiece("br", "top", 0, "left", 0);
-}, _makePiece:function (name, vertAttach, vertCoord, horzAttach, horzCoord, sizing) {
-	var img;
-	var url = this.shadowPng + name.toUpperCase() + ".png";
-	if (dojo.render.html.ie55 || dojo.render.html.ie60) {
-		img = dojo.doc().createElement("div");
-		img.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + url + "'" + (sizing ? ", sizingMethod='" + sizing + "'" : "") + ")";
-	} else {
-		img = dojo.doc().createElement("img");
-		img.src = url;
-	}
-	img.style.position = "absolute";
-	img.style[vertAttach] = vertCoord + "px";
-	img.style[horzAttach] = horzCoord + "px";
-	img.style.width = this.shadowThickness + "px";
-	img.style.height = this.shadowThickness + "px";
-	this.pieces[name] = img;
-	this.node.appendChild(img);
-}, size:function (width, height) {
-	var sideHeight = height - (this.shadowOffset + this.shadowThickness + 1);
-	if (sideHeight < 0) {
-		sideHeight = 0;
-	}
-	if (height < 1) {
-		height = 1;
-	}
-	if (width < 1) {
-		width = 1;
-	}
-	with (this.pieces) {
-		l.style.height = sideHeight + "px";
-		r.style.height = sideHeight + "px";
-		b.style.width = (width - 1) + "px";
-		bl.style.top = (height - 1) + "px";
-		b.style.top = (height - 1) + "px";
-		br.style.top = (height - 1) + "px";
-		tr.style.left = (width - 1) + "px";
-		r.style.left = (width - 1) + "px";
-		br.style.left = (width - 1) + "px";
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/lfx/toggle.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/lfx/toggle.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/lfx/toggle.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,34 +8,47 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.lfx.toggle");
 dojo.require("dojo.lfx.*");
-dojo.lfx.toggle.plain = {show:function (node, duration, easing, callback) {
-	dojo.html.show(node);
-	if (dojo.lang.isFunction(callback)) {
-		callback();
+
+dojo.lfx.toggle.plain = {
+	show: function(node, duration, easing, callback){
+		dojo.style.show(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	},
+	
+	hide: function(node, duration, easing, callback){
+		dojo.style.hide(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
 	}
-}, hide:function (node, duration, easing, callback) {
-	dojo.html.hide(node);
-	if (dojo.lang.isFunction(callback)) {
-		callback();
+}
+
+dojo.lfx.toggle.fade = {
+	show: function(node, duration, easing, callback){
+		dojo.lfx.fadeShow(node, duration, easing, callback).play();
+	},
+
+	hide: function(node, duration, easing, callback){
+		dojo.lfx.fadeHide(node, duration, easing, callback).play();
 	}
-}};
-dojo.lfx.toggle.fade = {show:function (node, duration, easing, callback) {
-	dojo.lfx.fadeShow(node, duration, easing, callback).play();
-}, hide:function (node, duration, easing, callback) {
-	dojo.lfx.fadeHide(node, duration, easing, callback).play();
-}};
-dojo.lfx.toggle.wipe = {show:function (node, duration, easing, callback) {
-	dojo.lfx.wipeIn(node, duration, easing, callback).play();
-}, hide:function (node, duration, easing, callback) {
-	dojo.lfx.wipeOut(node, duration, easing, callback).play();
-}};
-dojo.lfx.toggle.explode = {show:function (node, duration, easing, callback, explodeSrc) {
-	dojo.lfx.explode(explodeSrc || {x:0, y:0, width:0, height:0}, node, duration, easing, callback).play();
-}, hide:function (node, duration, easing, callback, explodeSrc) {
-	dojo.lfx.implode(node, explodeSrc || {x:0, y:0, width:0, height:0}, duration, easing, callback).play();
-}};
+}
 
+dojo.lfx.toggle.wipe = {
+	show: function(node, duration, easing, callback){
+		dojo.lfx.wipeIn(node, duration, easing, callback).play();
+	},
+
+	hide: function(node, duration, easing, callback){
+		dojo.lfx.wipeOut(node, duration, easing, callback).play();
+	}
+}
+
+dojo.lfx.toggle.explode = {
+	show: function(node, duration, easing, callback, explodeSrc){
+		dojo.lfx.explode(explodeSrc||[0,0,0,0], node, duration, easing, callback).play();
+	},
+
+	hide: function(node, duration, easing, callback, explodeSrc){
+		dojo.lfx.implode(node, explodeSrc||[0,0,0,0], duration, easing, callback).play();
+	}
+}

Modified: tags/parley-0.53/root/static/magic/src/loader.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/loader.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/loader.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,441 +8,443 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/*
+ * loader.js - runs before the hostenv_*.js file. Contains all of the package loading methods.
+ */
 
+//A semi-colon is at the start of the line because after doing a build, this function definition
+//get compressed onto the same line as the last line in bootstrap1.js. That list line is just a
+//curly bracket, and the browser complains about that syntax. The semicolon fixes it. Putting it
+//here instead of at the end of bootstrap1.js, since it is more of an issue for this file, (using
+//the closure), and bootstrap1.js could change in the future.
+;(function(){
+	//Additional properties for dojo.hostenv
+	var _addHostEnv = {
+		pkgFileName: "__package__",
+	
+		// for recursion protection
+		loading_modules_: {},
+		loaded_modules_: {},
+		addedToLoadingCount: [],
+		removedFromLoadingCount: [],
+	
+		inFlightCount: 0,
+	
+		// FIXME: it should be possible to pull module prefixes in from djConfig
+		modulePrefixes_: {
+			dojo: {name: "dojo", value: "src"}
+		},
+	
+	
+		setModulePrefix: function(module, prefix){
+			this.modulePrefixes_[module] = {name: module, value: prefix};
+		},
+	
+		getModulePrefix: function(module){
+			var mp = this.modulePrefixes_;
+			if((mp[module])&&(mp[module]["name"])){
+				return mp[module].value;
+			}
+			return module;
+		},
 
-(function () {
-	var _addHostEnv = {pkgFileName:"__package__", loading_modules_:{}, loaded_modules_:{}, addedToLoadingCount:[], removedFromLoadingCount:[], inFlightCount:0, modulePrefixes_:{dojo:{name:"dojo", value:"src"}}, setModulePrefix:function (module, prefix) {
-		this.modulePrefixes_[module] = {name:module, value:prefix};
-	}, moduleHasPrefix:function (module) {
-		var mp = this.modulePrefixes_;
-		return Boolean(mp[module] && mp[module].value);
-	}, getModulePrefix:function (module) {
-		if (this.moduleHasPrefix(module)) {
-			return this.modulePrefixes_[module].value;
-		}
-		return module;
-	}, getTextStack:[], loadUriStack:[], loadedUris:[], post_load_:false, modulesLoadedListeners:[], unloadListeners:[], loadNotifying:false};
-	for (var param in _addHostEnv) {
+		getTextStack: [],
+		loadUriStack: [],
+		loadedUris: [],
+	
+		//WARNING: This variable is referenced by packages outside of bootstrap: FloatingPane.js and undo/browser.js
+		post_load_: false,
+		
+		//Egad! Lots of test files push on this directly instead of using dojo.addOnLoad.
+		modulesLoadedListeners: [],
+		unloadListeners: [],
+		loadNotifying: false
+	};
+	
+	//Add all of these properties to dojo.hostenv
+	for(var param in _addHostEnv){
 		dojo.hostenv[param] = _addHostEnv[param];
 	}
 })();
-dojo.hostenv.loadPath = function (relpath, module, cb) {
+
+/**
+ * Loads and interprets the script located at relpath, which is relative to the
+ * script root directory.  If the script is found but its interpretation causes
+ * a runtime exception, that exception is not caught by us, so the caller will
+ * see it.  We return a true value if and only if the script is found.
+ *
+ * For now, we do not have an implementation of a true search path.  We
+ * consider only the single base script uri, as returned by getBaseScriptUri().
+ *
+ * @param relpath A relative path to a script (no leading '/', and typically
+ * ending in '.js').
+ * @param module A module whose existance to check for after loading a path.
+ * Can be used to determine success or failure of the load.
+ * @param cb a function to pass the result of evaluating the script (optional)
+ */
+dojo.hostenv.loadPath = function(relpath, module /*optional*/, cb /*optional*/){
 	var uri;
-	if (relpath.charAt(0) == "/" || relpath.match(/^\w+:/)) {
+	if((relpath.charAt(0) == '/')||(relpath.match(/^\w+:/))){
+		// dojo.raise("relpath '" + relpath + "'; must be relative");
 		uri = relpath;
-	} else {
+	}else{
 		uri = this.getBaseScriptUri() + relpath;
 	}
-	if (djConfig.cacheBust && dojo.render.html.capable) {
-		uri += "?" + String(djConfig.cacheBust).replace(/\W+/g, "");
+	if(djConfig.cacheBust && dojo.render.html.capable){
+		uri += "?" + String(djConfig.cacheBust).replace(/\W+/g,"");
 	}
-	try {
-		return !module ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb);
-	}
-	catch (e) {
+	try{
+		return ((!module) ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb));
+	}catch(e){
 		dojo.debug(e);
 		return false;
 	}
-};
-dojo.hostenv.loadUri = function (uri, cb) {
-	if (this.loadedUris[uri]) {
-		return true;
+}
+
+/**
+ * Reads the contents of the URI, and evaluates the contents.
+ * Returns true if it succeeded. Returns false if the URI reading failed.
+ * Throws if the evaluation throws.
+ * The result of the eval is not available to the caller TODO: now it is; was this a deliberate restriction?
+ *
+ * @param uri a uri which points at the script to be loaded
+ * @param cb a function to process the result of evaluating the script as an expression (optional)
+ */
+dojo.hostenv.loadUri = function(uri, cb /*optional*/){
+	if(this.loadedUris[uri]){
+		return 1;
 	}
 	var contents = this.getText(uri, null, true);
-	if (!contents) {
-		return false;
-	}
+	if(contents == null){ return 0; }
 	this.loadedUris[uri] = true;
-	if (cb) {
-		contents = "(" + contents + ")";
-	}
+	if(cb){ contents = '('+contents+')'; }
 	var value = dj_eval(contents);
-	if (cb) {
+	if(cb){
 		cb(value);
 	}
-	return true;
-};
-dojo.hostenv.loadUriAndCheck = function (uri, moduleName, cb) {
+	return 1;
+}
+
+// FIXME: probably need to add logging to this method
+dojo.hostenv.loadUriAndCheck = function(uri, module, cb){
 	var ok = true;
-	try {
+	try{
 		ok = this.loadUri(uri, cb);
-	}
-	catch (e) {
+	}catch(e){
 		dojo.debug("failed loading ", uri, " with error: ", e);
 	}
-	return Boolean(ok && this.findModule(moduleName, false));
-};
-dojo.loaded = function () {
-};
-dojo.unloaded = function () {
-};
-dojo.hostenv.loaded = function () {
+	return ((ok)&&(this.findModule(module, false))) ? true : false;
+}
+
+dojo.loaded = function(){ }
+dojo.unloaded = function(){ }
+
+dojo.hostenv.loaded = function(){
 	this.loadNotifying = true;
 	this.post_load_ = true;
 	var mll = this.modulesLoadedListeners;
-	for (var x = 0; x < mll.length; x++) {
+	for(var x=0; x<mll.length; x++){
 		mll[x]();
 	}
+
+	//Clear listeners so new ones can be added
+	//For other xdomain package loads after the initial load.
 	this.modulesLoadedListeners = [];
 	this.loadNotifying = false;
+
 	dojo.loaded();
-};
-dojo.hostenv.unloaded = function () {
+}
+
+dojo.hostenv.unloaded = function(){
 	var mll = this.unloadListeners;
-	while (mll.length) {
+	while(mll.length){
 		(mll.pop())();
 	}
 	dojo.unloaded();
-};
-dojo.addOnLoad = function (obj, functionName) {
+}
+
+/*
+Call styles:
+	dojo.addOnLoad(functionPointer)
+	dojo.addOnLoad(object, "functionName")
+*/
+dojo.addOnLoad = function(obj, fcnName) {
 	var dh = dojo.hostenv;
-	if (arguments.length == 1) {
+	if(arguments.length == 1) {
 		dh.modulesLoadedListeners.push(obj);
-	} else {
-		if (arguments.length > 1) {
-			dh.modulesLoadedListeners.push(function () {
-				obj[functionName]();
-			});
-		}
+	} else if(arguments.length > 1) {
+		dh.modulesLoadedListeners.push(function() {
+			obj[fcnName]();
+		});
 	}
-	if (dh.post_load_ && dh.inFlightCount == 0 && !dh.loadNotifying) {
+
+	//Added for xdomain loading. dojo.addOnLoad is used to
+	//indicate callbacks after doing some dojo.require() statements.
+	//In the xdomain case, if all the requires are loaded (after initial
+	//page load), then immediately call any listeners.
+	if(dh.post_load_ && dh.inFlightCount == 0 && !dh.loadNotifying){
 		dh.callLoaded();
 	}
-};
-dojo.addOnUnload = function (obj, functionName) {
+}
+
+dojo.addOnUnload = function(obj, fcnName){
 	var dh = dojo.hostenv;
-	if (arguments.length == 1) {
+	if(arguments.length == 1){
 		dh.unloadListeners.push(obj);
-	} else {
-		if (arguments.length > 1) {
-			dh.unloadListeners.push(function () {
-				obj[functionName]();
-			});
-		}
+	} else if(arguments.length > 1) {
+		dh.unloadListeners.push(function() {
+			obj[fcnName]();
+		});
 	}
-};
-dojo.hostenv.modulesLoaded = function () {
-	if (this.post_load_) {
-		return;
-	}
-	if (this.loadUriStack.length == 0 && this.getTextStack.length == 0) {
-		if (this.inFlightCount > 0) {
+}
+
+dojo.hostenv.modulesLoaded = function(){
+	if(this.post_load_){ return; }
+	if((this.loadUriStack.length==0)&&(this.getTextStack.length==0)){
+		if(this.inFlightCount > 0){ 
 			dojo.debug("files still in flight!");
 			return;
 		}
 		dojo.hostenv.callLoaded();
 	}
-};
-dojo.hostenv.callLoaded = function () {
-	if (typeof setTimeout == "object" || (djConfig["useXDomain"] && dojo.render.html.opera)) {
+}
+
+dojo.hostenv.callLoaded = function(){
+	if(typeof setTimeout == "object"){
 		setTimeout("dojo.hostenv.loaded();", 0);
-	} else {
+	}else{
 		dojo.hostenv.loaded();
 	}
-};
-dojo.hostenv.getModuleSymbols = function (modulename) {
+}
+
+dojo.hostenv.getModuleSymbols = function(modulename) {
 	var syms = modulename.split(".");
-	for (var i = syms.length; i > 0; i--) {
+	for(var i = syms.length - 1; i > 0; i--){
 		var parentModule = syms.slice(0, i).join(".");
-		if ((i == 1) && !this.moduleHasPrefix(parentModule)) {
-			syms[0] = "../" + syms[0];
-		} else {
-			var parentModulePath = this.getModulePrefix(parentModule);
-			if (parentModulePath != parentModule) {
-				syms.splice(0, i, parentModulePath);
-				break;
-			}
+		var parentModulePath = this.getModulePrefix(parentModule);
+		if(parentModulePath != parentModule){
+			syms.splice(0, i, parentModulePath);
+			break;
 		}
 	}
 	return syms;
-};
+}
+
+/**
+* loadModule("A.B") first checks to see if symbol A.B is defined. 
+* If it is, it is simply returned (nothing to do).
+*
+* If it is not defined, it will look for "A/B.js" in the script root directory,
+* followed by "A.js".
+*
+* It throws if it cannot find a file to load, or if the symbol A.B is not
+* defined after loading.
+*
+* It returns the object A.B.
+*
+* This does nothing about importing symbols into the current package.
+* It is presumed that the caller will take care of that. For example, to import
+* all symbols:
+*
+*    with (dojo.hostenv.loadModule("A.B")) {
+*       ...
+*    }
+*
+* And to import just the leaf symbol:
+*
+*    var B = dojo.hostenv.loadModule("A.B");
+*    ...
+*
+* dj_load is an alias for dojo.hostenv.loadModule
+*/
 dojo.hostenv._global_omit_module_check = false;
-dojo.hostenv.loadModule = function (moduleName, exactOnly, omitModuleCheck) {
-	if (!moduleName) {
-		return;
-	}
-	omitModuleCheck = this._global_omit_module_check || omitModuleCheck;
-	var module = this.findModule(moduleName, false);
-	if (module) {
+dojo.hostenv.loadModule = function(modulename, exact_only, omit_module_check){
+	if(!modulename){ return; }
+	omit_module_check = this._global_omit_module_check || omit_module_check;
+	var module = this.findModule(modulename, false);
+	if(module){
 		return module;
 	}
-	if (dj_undef(moduleName, this.loading_modules_)) {
-		this.addedToLoadingCount.push(moduleName);
+
+	// protect against infinite recursion from mutual dependencies
+	if(dj_undef(modulename, this.loading_modules_)){
+		this.addedToLoadingCount.push(modulename);
 	}
-	this.loading_modules_[moduleName] = 1;
-	var relpath = moduleName.replace(/\./g, "/") + ".js";
-	var nsyms = moduleName.split(".");
-	var syms = this.getModuleSymbols(moduleName);
-	var startedRelative = ((syms[0].charAt(0) != "/") && !syms[0].match(/^\w+:/));
+	this.loading_modules_[modulename] = 1;
+
+	// convert periods to slashes
+	var relpath = modulename.replace(/\./g, '/') + '.js';
+
+	var syms = this.getModuleSymbols(modulename);
+	var startedRelative = ((syms[0].charAt(0) != '/')&&(!syms[0].match(/^\w+:/)));
 	var last = syms[syms.length - 1];
-	var ok;
-	if (last == "*") {
-		moduleName = nsyms.slice(0, -1).join(".");
-		while (syms.length) {
+	// figure out if we're looking for a full package, if so, we want to do
+	// things slightly diffrently
+	var nsyms = modulename.split(".");
+	if(last=="*"){
+		modulename = (nsyms.slice(0, -1)).join('.');
+
+		while(syms.length){
 			syms.pop();
 			syms.push(this.pkgFileName);
-			relpath = syms.join("/") + ".js";
-			if (startedRelative && relpath.charAt(0) == "/") {
+			relpath = syms.join("/") + '.js';
+			if(startedRelative && (relpath.charAt(0)=="/")){
 				relpath = relpath.slice(1);
 			}
-			ok = this.loadPath(relpath, !omitModuleCheck ? moduleName : null);
-			if (ok) {
-				break;
-			}
+			ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+			if(ok){ break; }
 			syms.pop();
 		}
-	} else {
-		relpath = syms.join("/") + ".js";
-		moduleName = nsyms.join(".");
-		var modArg = !omitModuleCheck ? moduleName : null;
-		ok = this.loadPath(relpath, modArg);
-		if (!ok && !exactOnly) {
+	}else{
+		relpath = syms.join("/") + '.js';
+		modulename = nsyms.join('.');
+		var ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+		if((!ok)&&(!exact_only)){
 			syms.pop();
-			while (syms.length) {
-				relpath = syms.join("/") + ".js";
-				ok = this.loadPath(relpath, modArg);
-				if (ok) {
-					break;
-				}
+			while(syms.length){
+				relpath = syms.join('/') + '.js';
+				ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+				if(ok){ break; }
 				syms.pop();
-				relpath = syms.join("/") + "/" + this.pkgFileName + ".js";
-				if (startedRelative && relpath.charAt(0) == "/") {
+				relpath = syms.join('/') + '/'+this.pkgFileName+'.js';
+				if(startedRelative && (relpath.charAt(0)=="/")){
 					relpath = relpath.slice(1);
 				}
-				ok = this.loadPath(relpath, modArg);
-				if (ok) {
-					break;
-				}
+				ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+				if(ok){ break; }
 			}
 		}
-		if (!ok && !omitModuleCheck) {
-			dojo.raise("Could not load '" + moduleName + "'; last tried '" + relpath + "'");
+
+		if((!ok)&&(!omit_module_check)){
+			dojo.raise("Could not load '" + modulename + "'; last tried '" + relpath + "'");
 		}
 	}
-	if (!omitModuleCheck && !this["isXDomain"]) {
-		module = this.findModule(moduleName, false);
-		if (!module) {
-			dojo.raise("symbol '" + moduleName + "' is not defined after loading '" + relpath + "'");
+
+	// check that the symbol was defined
+	//Don't bother if we're doing xdomain (asynchronous) loading.
+	if(!omit_module_check && !this["isXDomain"]){
+		// pass in false so we can give better error
+		module = this.findModule(modulename, false);
+		if(!module){
+			dojo.raise("symbol '" + modulename + "' is not defined after loading '" + relpath + "'"); 
 		}
 	}
+
 	return module;
-};
-dojo.hostenv.startPackage = function (packageName) {
-	var fullPkgName = String(packageName);
-	var strippedPkgName = fullPkgName;
-	var syms = packageName.split(/\./);
-	if (syms[syms.length - 1] == "*") {
+}
+
+/**
+* startPackage("A.B") follows the path, and at each level creates a new empty
+* object or uses what already exists. It returns the result.
+*/
+dojo.hostenv.startPackage = function(packname){
+	var modref = dojo.evalObjPath((packname.split(".").slice(0, -1)).join('.'));
+	this.loaded_modules_[(new String(packname)).toLowerCase()] = modref;
+
+	var syms = packname.split(/\./);
+	if(syms[syms.length-1]=="*"){
 		syms.pop();
-		strippedPkgName = syms.join(".");
 	}
-	var evaledPkg = dojo.evalObjPath(strippedPkgName, true);
-	this.loaded_modules_[fullPkgName] = evaledPkg;
-	this.loaded_modules_[strippedPkgName] = evaledPkg;
-	return evaledPkg;
-};
-dojo.hostenv.findModule = function (moduleName, mustExist) {
-	var lmn = String(moduleName);
-	if (this.loaded_modules_[lmn]) {
+	return dojo.evalObjPath(syms.join("."), true);
+}
+
+/**
+ * findModule("A.B") returns the object A.B if it exists, otherwise null.
+ * @param modulename A string like 'A.B'.
+ * @param must_exist Optional, defualt false. throw instead of returning null
+ * if the module does not currently exist.
+ */
+dojo.hostenv.findModule = function(modulename, must_exist){
+	// check cache
+	/*
+	if(!dj_undef(modulename, this.modules_)){
+		return this.modules_[modulename];
+	}
+	*/
+
+	var lmn = (new String(modulename)).toLowerCase();
+
+	if(this.loaded_modules_[lmn]){
 		return this.loaded_modules_[lmn];
 	}
-	if (mustExist) {
-		dojo.raise("no loaded module named '" + moduleName + "'");
+
+	// see if symbol is defined anyway
+	var module = dojo.evalObjPath(modulename);
+	if((modulename)&&(typeof module != 'undefined')&&(module)){
+		this.loaded_modules_[lmn] = module;
+		return module;
 	}
+
+	if(must_exist){
+		dojo.raise("no loaded module named '" + modulename + "'");
+	}
 	return null;
-};
-dojo.kwCompoundRequire = function (modMap) {
-	var common = modMap["common"] || [];
-	var result = modMap[dojo.hostenv.name_] ? common.concat(modMap[dojo.hostenv.name_] || []) : common.concat(modMap["default"] || []);
-	for (var x = 0; x < result.length; x++) {
+}
+
+//Start of old bootstrap2:
+
+/*
+ * This method taks a "map" of arrays which one can use to optionally load dojo
+ * modules. The map is indexed by the possible dojo.hostenv.name_ values, with
+ * two additional values: "default" and "common". The items in the "default"
+ * array will be loaded if none of the other items have been choosen based on
+ * the hostenv.name_ item. The items in the "common" array will _always_ be
+ * loaded, regardless of which list is chosen.  Here's how it's normally
+ * called:
+ *
+ *	dojo.kwCompoundRequire({
+ *		browser: [
+ *			["foo.bar.baz", true, true], // an example that passes multiple args to loadModule()
+ *			"foo.sample.*",
+ *			"foo.test,
+ *		],
+ *		default: [ "foo.sample.*" ],
+ *		common: [ "really.important.module.*" ]
+ *	});
+ */
+dojo.kwCompoundRequire = function(modMap){
+	var common = modMap["common"]||[];
+	var result = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap["default"]||[]);
+
+	for(var x=0; x<result.length; x++){
 		var curr = result[x];
-		if (curr.constructor == Array) {
+		if(curr.constructor == Array){
 			dojo.hostenv.loadModule.apply(dojo.hostenv, curr);
-		} else {
+		}else{
 			dojo.hostenv.loadModule(curr);
 		}
 	}
-};
-dojo.require = function (resourceName) {
+}
+
+dojo.require = function(){
 	dojo.hostenv.loadModule.apply(dojo.hostenv, arguments);
-};
-dojo.requireIf = function (condition, resourceName) {
-	var arg0 = arguments[0];
-	if ((arg0 === true) || (arg0 == "common") || (arg0 && dojo.render[arg0].capable)) {
+}
+
+dojo.requireIf = function(){
+	if((arguments[0] === true)||(arguments[0]=="common")||(arguments[0] && dojo.render[arguments[0]].capable)){
 		var args = [];
-		for (var i = 1; i < arguments.length; i++) {
-			args.push(arguments[i]);
-		}
+		for (var i = 1; i < arguments.length; i++) { args.push(arguments[i]); }
 		dojo.require.apply(dojo, args);
 	}
-};
+}
+
 dojo.requireAfterIf = dojo.requireIf;
-dojo.provide = function (resourceName) {
+
+dojo.provide = function(){
 	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
-};
-dojo.registerModulePath = function (module, prefix) {
+}
+
+dojo.setModulePrefix = function(module, prefix){
 	return dojo.hostenv.setModulePrefix(module, prefix);
-};
-if (djConfig["modulePaths"]) {
-	for (var param in djConfig["modulePaths"]) {
-		dojo.registerModulePath(param, djConfig["modulePaths"][param]);
-	}
 }
-dojo.setModulePrefix = function (module, prefix) {
-	dojo.deprecated("dojo.setModulePrefix(\"" + module + "\", \"" + prefix + "\")", "replaced by dojo.registerModulePath", "0.5");
-	return dojo.registerModulePath(module, prefix);
-};
-dojo.exists = function (obj, name) {
+
+// determine if an object supports a given method
+// useful for longer api chains where you have to test each object in the chain
+dojo.exists = function(obj, name){
 	var p = name.split(".");
-	for (var i = 0; i < p.length; i++) {
-		if (!obj[p[i]]) {
-			return false;
-		}
+	for(var i = 0; i < p.length; i++){
+	if(!(obj[p[i]])) return false;
 		obj = obj[p[i]];
 	}
 	return true;
-};
-dojo.hostenv.normalizeLocale = function (locale) {
-	var result = locale ? locale.toLowerCase() : dojo.locale;
-	if (result == "root") {
-		result = "ROOT";
-	}
-	return result;
-};
-dojo.hostenv.searchLocalePath = function (locale, down, searchFunc) {
-	locale = dojo.hostenv.normalizeLocale(locale);
-	var elements = locale.split("-");
-	var searchlist = [];
-	for (var i = elements.length; i > 0; i--) {
-		searchlist.push(elements.slice(0, i).join("-"));
-	}
-	searchlist.push(false);
-	if (down) {
-		searchlist.reverse();
-	}
-	for (var j = searchlist.length - 1; j >= 0; j--) {
-		var loc = searchlist[j] || "ROOT";
-		var stop = searchFunc(loc);
-		if (stop) {
-			break;
-		}
-	}
-};
-dojo.hostenv.localesGenerated;
-dojo.hostenv.registerNlsPrefix = function () {
-	dojo.registerModulePath("nls", "nls");
-};
-dojo.hostenv.preloadLocalizations = function () {
-	if (dojo.hostenv.localesGenerated) {
-		dojo.hostenv.registerNlsPrefix();
-		function preload(locale) {
-			locale = dojo.hostenv.normalizeLocale(locale);
-			dojo.hostenv.searchLocalePath(locale, true, function (loc) {
-				for (var i = 0; i < dojo.hostenv.localesGenerated.length; i++) {
-					if (dojo.hostenv.localesGenerated[i] == loc) {
-						dojo["require"]("nls.dojo_" + loc);
-						return true;
-					}
-				}
-				return false;
-			});
-		}
-		preload();
-		var extra = djConfig.extraLocale || [];
-		for (var i = 0; i < extra.length; i++) {
-			preload(extra[i]);
-		}
-	}
-	dojo.hostenv.preloadLocalizations = function () {
-	};
-};
-dojo.requireLocalization = function (moduleName, bundleName, locale, availableFlatLocales) {
-	dojo.hostenv.preloadLocalizations();
-	var targetLocale = dojo.hostenv.normalizeLocale(locale);
-	var bundlePackage = [moduleName, "nls", bundleName].join(".");
-	var bestLocale = "";
-	if (availableFlatLocales) {
-		var flatLocales = availableFlatLocales.split(",");
-		for (var i = 0; i < flatLocales.length; i++) {
-			if (targetLocale.indexOf(flatLocales[i]) == 0) {
-				if (flatLocales[i].length > bestLocale.length) {
-					bestLocale = flatLocales[i];
-				}
-			}
-		}
-		if (!bestLocale) {
-			bestLocale = "ROOT";
-		}
-	}
-	var tempLocale = availableFlatLocales ? bestLocale : targetLocale;
-	var bundle = dojo.hostenv.findModule(bundlePackage);
-	var localizedBundle = null;
-	if (bundle) {
-		if (djConfig.localizationComplete && bundle._built) {
-			return;
-		}
-		var jsLoc = tempLocale.replace("-", "_");
-		var translationPackage = bundlePackage + "." + jsLoc;
-		localizedBundle = dojo.hostenv.findModule(translationPackage);
-	}
-	if (!localizedBundle) {
-		bundle = dojo.hostenv.startPackage(bundlePackage);
-		var syms = dojo.hostenv.getModuleSymbols(moduleName);
-		var modpath = syms.concat("nls").join("/");
-		var parent;
-		dojo.hostenv.searchLocalePath(tempLocale, availableFlatLocales, function (loc) {
-			var jsLoc = loc.replace("-", "_");
-			var translationPackage = bundlePackage + "." + jsLoc;
-			var loaded = false;
-			if (!dojo.hostenv.findModule(translationPackage)) {
-				dojo.hostenv.startPackage(translationPackage);
-				var module = [modpath];
-				if (loc != "ROOT") {
-					module.push(loc);
-				}
-				module.push(bundleName);
-				var filespec = module.join("/") + ".js";
-				loaded = dojo.hostenv.loadPath(filespec, null, function (hash) {
-					var clazz = function () {
-					};
-					clazz.prototype = parent;
-					bundle[jsLoc] = new clazz();
-					for (var j in hash) {
-						bundle[jsLoc][j] = hash[j];
-					}
-				});
-			} else {
-				loaded = true;
-			}
-			if (loaded && bundle[jsLoc]) {
-				parent = bundle[jsLoc];
-			} else {
-				bundle[jsLoc] = parent;
-			}
-			if (availableFlatLocales) {
-				return true;
-			}
-		});
-	}
-	if (availableFlatLocales && targetLocale != bestLocale) {
-		bundle[targetLocale.replace("-", "_")] = bundle[bestLocale.replace("-", "_")];
-	}
-};
-(function () {
-	var extra = djConfig.extraLocale;
-	if (extra) {
-		if (!extra instanceof Array) {
-			extra = [extra];
-		}
-		var req = dojo.requireLocalization;
-		dojo.requireLocalization = function (m, b, locale, availableFlatLocales) {
-			req(m, b, locale, availableFlatLocales);
-			if (locale) {
-				return;
-			}
-			for (var i = 0; i < extra.length; i++) {
-				req(m, b, extra[i], availableFlatLocales);
-			}
-		};
-	}
-})();
-
+}

Modified: tags/parley-0.53/root/static/magic/src/loader_xd.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/loader_xd.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/loader_xd.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,401 +8,407 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+//Cross-domain package loader.
 
+//FIXME: How will xd loading work with debugAtAllCosts? Any bad interactions?
+//FIXME: widgets won't work fully (HTML/CSS) and also because of the requireIf() thing.
 
-dojo.hostenv.resetXd = function () {
-	this.isXDomain = djConfig.useXDomain || false;
+dojo.hostenv.resetXd = function(){
+	//This flag indicates where or not we have crossed into xdomain territory. Once any package says
+	//it is cross domain, then the rest of the packages have to be treated as xdomain because we need
+	//to evaluate packages in order. If there is a xdomain package followed by a xhr package, we can't load
+	//the xhr package until the one before it finishes loading. The text of the xhr package will be converted
+	//to match the format for a xd package and put in the xd load queue.
+	//You can force all packages to be treated as xd by setting the djConfig.forceXDomain.
+	this.isXDomain = djConfig.forceXDomain || false;
+
 	this.xdTimer = 0;
 	this.xdInFlight = {};
 	this.xdOrderedReqs = [];
 	this.xdDepMap = {};
 	this.xdContents = [];
-	this.xdDefList = [];
-};
+}
+
+//Call reset immediately to set the state.
 dojo.hostenv.resetXd();
-dojo.hostenv.createXdPackage = function (contents, resourceName, resourcePath) {
+
+dojo.hostenv.createXdPackage = function(contents){
+	//Find dependencies.
 	var deps = [];
-	var depRegExp = /dojo.(requireLocalization|require|requireIf|requireAll|provide|requireAfterIf|requireAfter|kwCompoundRequire|conditionalRequire|hostenv\.conditionalLoadModule|.hostenv\.loadModule|hostenv\.moduleLoaded)\(([\w\W]*?)\)/mg;
-	var match;
-	while ((match = depRegExp.exec(contents)) != null) {
-		if (match[1] == "requireLocalization") {
-			eval(match[0]);
-		} else {
-			deps.push("\"" + match[1] + "\", " + match[2]);
-		}
+    var depRegExp = /dojo.(require|requireIf|requireAll|provide|requireAfterIf|requireAfter|kwCompoundRequire|conditionalRequire|hostenv\.conditionalLoadModule|.hostenv\.loadModule|hostenv\.moduleLoaded)\(([\w\W]*?)\)/mg;
+    var match;
+	while((match = depRegExp.exec(contents)) != null){
+		deps.push("\"" + match[1] + "\", " + match[2]);
 	}
+
+	//Create package object and the call to packageLoaded.
 	var output = [];
 	output.push("dojo.hostenv.packageLoaded({\n");
-	if (deps.length > 0) {
+
+	//Add dependencies
+	if(deps.length > 0){
 		output.push("depends: [");
-		for (var i = 0; i < deps.length; i++) {
-			if (i > 0) {
+		for(var i = 0; i < deps.length; i++){
+			if(i > 0){
 				output.push(",\n");
 			}
 			output.push("[" + deps[i] + "]");
 		}
 		output.push("],");
 	}
+
+	//Add the contents of the file inside a function.
+	//Pass in dojo as an argument to the function to help with
+	//allowing multiple versions of dojo in a page.
 	output.push("\ndefinePackage: function(dojo){");
 	output.push(contents);
-	output.push("\n}, resourceName: '" + resourceName + "', resourcePath: '" + resourcePath + "'});");
+	output.push("\n}});");
+	
 	return output.join("");
-};
-dojo.hostenv.loadPath = function (relpath, module, cb) {
+}
+
+dojo.hostenv.loadPath = function(relpath, module /*optional*/, cb /*optional*/){
+	//Only do getBaseScriptUri if path does not start with a URL with a protocol.
+	//If there is a colon before the first / then, we have a URL with a protocol.
 	var colonIndex = relpath.indexOf(":");
 	var slashIndex = relpath.indexOf("/");
 	var uri;
 	var currentIsXDomain = false;
-	if (colonIndex > 0 && colonIndex < slashIndex) {
+	if(colonIndex > 0 && colonIndex < slashIndex){
 		uri = relpath;
 		this.isXDomain = currentIsXDomain = true;
-	} else {
+	}else{
 		uri = this.getBaseScriptUri() + relpath;
+
+		//Is ithe base script URI-based URL a cross domain URL?
 		colonIndex = uri.indexOf(":");
 		slashIndex = uri.indexOf("/");
-		if (colonIndex > 0 && colonIndex < slashIndex && (!location.host || uri.indexOf("http://" + location.host) != 0)) {
+		if(colonIndex > 0 && colonIndex < slashIndex && (!location.host || uri.indexOf("http://" + location.host) != 0)){
 			this.isXDomain = currentIsXDomain = true;
 		}
 	}
-	if (djConfig.cacheBust && dojo.render.html.capable) {
-		uri += "?" + String(djConfig.cacheBust).replace(/\W+/g, "");
-	}
-	try {
+
+	if(djConfig.cacheBust && dojo.render.html.capable) { uri += "?" + String(djConfig.cacheBust).replace(/\W+/g,""); }
+	try{
 		return ((!module || this.isXDomain) ? this.loadUri(uri, cb, currentIsXDomain, module) : this.loadUriAndCheck(uri, module, cb));
-	}
-	catch (e) {
+	}catch(e){
 		dojo.debug(e);
 		return false;
 	}
-};
-dojo.hostenv.loadUri = function (uri, cb, currentIsXDomain, module) {
-	if (this.loadedUris[uri]) {
+}
+
+//Overriding loadUri for now. Wanted to override getText(), but it is used by
+//the widget code in too many, synchronous ways right now. This means the xd stuff
+//is not suitable for widgets yet.
+dojo.hostenv.loadUri = function(uri, cb, currentIsXDomain, module){
+	if(this.loadedUris[uri]){
 		return 1;
 	}
-	if (this.isXDomain && module) {
-		if (uri.indexOf("__package__") != -1) {
+
+	//Add the module (package) to the list of modules.
+	if(this.isXDomain){
+		//Curious: is this array going to get whacked with multiple access since scripts
+		//load asynchronously and may be accessing the array at the same time?
+		//JS is single-threaded supposedly, so it should be ok. And we don't need
+		//a precise ordering.
+		this.xdOrderedReqs.push(module);
+
+		//Add to waiting packages.
+		//If this is a __package__.js file, then this must be
+		//a package.* request (since xdomain can only work with the first
+		//path in a package search list. However, .* module names are not
+		//passed to this function, so do an adjustment here.
+		if(uri.indexOf("__package__") != -1){
 			module += ".*";
 		}
-		this.xdOrderedReqs.push(module);
-		if (currentIsXDomain || uri.indexOf("/nls/") == -1) {
-			this.xdInFlight[module] = true;
-			this.inFlightCount++;
-		}
-		if (!this.xdTimer) {
+
+		this.xdInFlight[module] = true;
+
+		//Increment inFlightCount
+		//This will stop the modulesLoaded from firing all the way.
+		this.inFlightCount++;
+				
+		//Start timer
+		if(!this.xdTimer){
 			this.xdTimer = setInterval("dojo.hostenv.watchInFlightXDomain();", 100);
 		}
 		this.xdStartTime = (new Date()).getTime();
 	}
-	if (currentIsXDomain) {
-		var lastIndex = uri.lastIndexOf(".");
-		if (lastIndex <= 0) {
+
+	if (currentIsXDomain){
+		//Fix name to be a .xd.fileextension name.
+		var lastIndex = uri.lastIndexOf('.');
+		if(lastIndex <= 0){
 			lastIndex = uri.length - 1;
 		}
+
 		var xdUri = uri.substring(0, lastIndex) + ".xd";
-		if (lastIndex != uri.length - 1) {
+		if(lastIndex != uri.length - 1){
 			xdUri += uri.substring(lastIndex, uri.length);
 		}
+
+		//Add to script src
 		var element = document.createElement("script");
 		element.type = "text/javascript";
 		element.src = xdUri;
-		if (!this.headElement) {
+		if(!this.headElement){
 			this.headElement = document.getElementsByTagName("head")[0];
-			if (!this.headElement) {
-				this.headElement = document.getElementsByTagName("html")[0];
-			}
 		}
 		this.headElement.appendChild(element);
-	} else {
+	}else{
 		var contents = this.getText(uri, null, true);
-		if (contents == null) {
-			return 0;
-		}
-		if (this.isXDomain && uri.indexOf("/nls/") == -1) {
-			var pkg = this.createXdPackage(contents, module, uri);
+		if(contents == null){ return 0; }
+		
+		if(this.isXDomain){
+			var pkg = this.createXdPackage(contents);
 			dj_eval(pkg);
-		} else {
-			if (cb) {
-				contents = "(" + contents + ")";
-			}
+		}else{
+			if(cb){ contents = '('+contents+')'; }
 			var value = dj_eval(contents);
-			if (cb) {
+			if(cb){
 				cb(value);
 			}
 		}
 	}
+
+	//These steps are done in the non-xd loader version of this function.
+	//Maintain these steps to fit in with the existing system.
 	this.loadedUris[uri] = true;
 	return 1;
-};
-dojo.hostenv.packageLoaded = function (pkg) {
+}
+
+dojo.hostenv.packageLoaded = function(pkg){
 	var deps = pkg.depends;
 	var requireList = null;
 	var requireAfterList = null;
 	var provideList = [];
-	if (deps && deps.length > 0) {
+	if(deps && deps.length > 0){
 		var dep = null;
 		var insertHint = 0;
 		var attachedPackage = false;
-		for (var i = 0; i < deps.length; i++) {
+		for(var i = 0; i < deps.length; i++){
 			dep = deps[i];
-			if (dep[0] == "provide" || dep[0] == "hostenv.moduleLoaded") {
+
+			//Look for specific dependency indicators.
+			if (dep[0] == "provide" || dep[0] == "hostenv.moduleLoaded"){
 				provideList.push(dep[1]);
-			} else {
-				if (!requireList) {
+			}else{
+				if(!requireList){
 					requireList = [];
 				}
-				if (!requireAfterList) {
+				if(!requireAfterList){
 					requireAfterList = [];
 				}
+
 				var unpackedDeps = this.unpackXdDependency(dep);
-				if (unpackedDeps.requires) {
+				if(unpackedDeps.requires){
 					requireList = requireList.concat(unpackedDeps.requires);
 				}
-				if (unpackedDeps.requiresAfter) {
+				if(unpackedDeps.requiresAfter){
 					requireAfterList = requireAfterList.concat(unpackedDeps.requiresAfter);
 				}
 			}
+
+			//Call the dependency indicator to allow for the normal dojo setup.
+			//Only allow for one dot reference, for the hostenv.* type calls.
 			var depType = dep[0];
 			var objPath = depType.split(".");
-			if (objPath.length == 2) {
+			if(objPath.length == 2){
 				dojo[objPath[0]][objPath[1]].apply(dojo[objPath[0]], dep.slice(1));
-			} else {
+			}else{
 				dojo[depType].apply(dojo, dep.slice(1));
 			}
 		}
-		var contentIndex = this.xdContents.push({content:pkg.definePackage, resourceName:pkg["resourceName"], resourcePath:pkg["resourcePath"], isDefined:false}) - 1;
-		for (var i = 0; i < provideList.length; i++) {
-			this.xdDepMap[provideList[i]] = {requires:requireList, requiresAfter:requireAfterList, contentIndex:contentIndex};
+
+		//Save off the package contents for definition later.
+		var contentIndex = this.xdContents.push({content: pkg.definePackage, isDefined: false}) - 1;
+
+		//Add provide/requires to dependency map.
+		for(var i = 0; i < provideList.length; i++){
+			this.xdDepMap[provideList[i]] = { requires: requireList, requiresAfter: requireAfterList, contentIndex: contentIndex };
 		}
-		for (var i = 0; i < provideList.length; i++) {
+
+		//Now update the inflight status for any provided packages in this loaded package.
+		//Do this at the very end (in a *separate* for loop) to avoid shutting down the 
+		//inflight timer check too soon.
+		for(var i = 0; i < provideList.length; i++){
 			this.xdInFlight[provideList[i]] = false;
 		}
 	}
-};
-dojo.hostenv.xdLoadFlattenedBundle = function (moduleName, bundleName, locale, bundleData) {
-	locale = locale || "root";
-	var jsLoc = dojo.hostenv.normalizeLocale(locale).replace("-", "_");
-	var bundlePackage = [moduleName, "nls", bundleName].join(".");
-	var bundle = dojo.hostenv.startPackage(bundlePackage);
-	bundle[jsLoc] = bundleData;
-	var mapName = [moduleName, jsLoc, bundleName].join(".");
-	var bundleMap = dojo.hostenv.xdBundleMap[mapName];
-	if (bundleMap) {
-		for (var param in bundleMap) {
-			bundle[param] = bundleData;
-		}
-	}
-};
-dojo.hostenv.xdBundleMap = {};
-dojo.xdRequireLocalization = function (moduleName, bundleName, locale, availableFlatLocales) {
-	var locales = availableFlatLocales.split(",");
-	var jsLoc = dojo.hostenv.normalizeLocale(locale);
-	var bestLocale = "";
-	for (var i = 0; i < locales.length; i++) {
-		if (jsLoc.indexOf(locales[i]) == 0) {
-			if (locales[i].length > bestLocale.length) {
-				bestLocale = locales[i];
-			}
-		}
-	}
-	var fixedBestLocale = bestLocale.replace("-", "_");
-	var bundlePackage = dojo.evalObjPath([moduleName, "nls", bundleName].join("."));
-	if (bundlePackage && bundlePackage[fixedBestLocale]) {
-		bundle[jsLoc.replace("-", "_")] = bundlePackage[fixedBestLocale];
-	} else {
-		var mapName = [moduleName, (fixedBestLocale || "root"), bundleName].join(".");
-		var bundleMap = dojo.hostenv.xdBundleMap[mapName];
-		if (!bundleMap) {
-			bundleMap = dojo.hostenv.xdBundleMap[mapName] = {};
-		}
-		bundleMap[jsLoc.replace("-", "_")] = true;
-		dojo.require(moduleName + ".nls" + (bestLocale ? "." + bestLocale : "") + "." + bundleName);
-	}
-};
-(function () {
-	var extra = djConfig.extraLocale;
-	if (extra) {
-		if (!extra instanceof Array) {
-			extra = [extra];
-		}
-		dojo._xdReqLoc = dojo.xdRequireLocalization;
-		dojo.xdRequireLocalization = function (m, b, locale, fLocales) {
-			dojo._xdReqLoc(m, b, locale, fLocales);
-			if (locale) {
-				return;
-			}
-			for (var i = 0; i < extra.length; i++) {
-				dojo._xdReqLoc(m, b, extra[i], fLocales);
-			}
-		};
-	}
-})();
-dojo.hostenv.unpackXdDependency = function (dep) {
+}
+
+//This is a bit brittle: it has to know about the dojo methods that deal with dependencies
+//It would be ideal to intercept the actual methods and do something fancy at that point,
+//but I have concern about knowing which provide to match to the dependency in that case,
+//since scripts can load whenever they want, and trigger new calls to dojo.hostenv.packageLoaded().
+dojo.hostenv.unpackXdDependency = function(dep){
+	//Extract the dependency(ies).
 	var newDeps = null;
 	var newAfterDeps = null;
-	switch (dep[0]) {
-	  case "requireIf":
-	  case "requireAfterIf":
-	  case "conditionalRequire":
-		if ((dep[1] === true) || (dep[1] == "common") || (dep[1] && dojo.render[dep[1]].capable)) {
-			newDeps = [{name:dep[2], content:null}];
-		}
-		break;
-	  case "requireAll":
-		dep.shift();
-		newDeps = dep;
-		dojo.hostenv.flattenRequireArray(newDeps);
-		break;
-	  case "kwCompoundRequire":
-	  case "hostenv.conditionalLoadModule":
-		var modMap = dep[1];
-		var common = modMap["common"] || [];
-		var newDeps = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_] || []) : common.concat(modMap["default"] || []);
-		dojo.hostenv.flattenRequireArray(newDeps);
-		break;
-	  case "require":
-	  case "requireAfter":
-	  case "hostenv.loadModule":
-		newDeps = [{name:dep[1], content:null}];
-		break;
+	switch(dep[0]){
+		case "requireIf":
+		case "requireAfterIf":
+		case "conditionalRequire":
+			//First arg (dep[1]) is the test. Depedency is dep[2].
+			if((dep[1] === true)||(dep[1]=="common")||(dep[1] && dojo.render[dep[1]].capable)){
+				newDeps = [{name: dep[2], content: null}];
+			}
+			break;
+		case "requireAll":
+			//the arguments are an array, each element a call to require.
+			//Get rid of first item, which is "requireAll".
+			dep.shift();
+			newDeps = dep;
+			dojo.hostenv.flattenRequireArray(newDeps);
+			break;
+		case "kwCompoundRequire":
+		case "hostenv.conditionalLoadModule":
+			var modMap = dep[1];
+			var common = modMap["common"]||[];
+			var newDeps = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap["default"]||[]);	
+			dojo.hostenv.flattenRequireArray(newDeps);
+			break;
+		case "require":
+		case "requireAfter":
+		case "hostenv.loadModule":
+			//Just worry about dep[1]
+			newDeps = [{name: dep[1], content: null}];
+			break;
 	}
-	if (dep[0] == "requireAfterIf" || dep[0] == "requireIf") {
+
+	//The requireAfterIf or requireAfter needs to be evaluated after the current package is evaluated.
+	if(dep[0] == "requireAfterIf"){
 		newAfterDeps = newDeps;
 		newDeps = null;
 	}
-	return {requires:newDeps, requiresAfter:newAfterDeps};
-};
-dojo.hostenv.xdWalkReqs = function () {
+	return {requires: newDeps, requiresAfter: newAfterDeps};
+}
+
+//Walks the requires and evaluates package contents in
+//the right order.
+dojo.hostenv.xdWalkReqs = function(){
 	var reqChain = null;
 	var req;
-	for (var i = 0; i < this.xdOrderedReqs.length; i++) {
+	for(var i = 0; i < this.xdOrderedReqs.length; i++){
 		req = this.xdOrderedReqs[i];
-		if (this.xdDepMap[req]) {
+		if(this.xdDepMap[req]){
 			reqChain = [req];
-			reqChain[req] = true;
+			reqChain[req] = true; //Allow for fast lookup of the req in the array
 			this.xdEvalReqs(reqChain);
 		}
 	}
-};
-dojo.hostenv.xdEvalReqs = function (reqChain) {
-	while (reqChain.length > 0) {
+}
+
+//Trace down any requires.
+dojo.hostenv.xdTraceReqs = function(reqs, reqChain){
+	if(reqs && reqs.length > 0){
+		var nextReq;
+		for(var i = 0; i < reqs.length; i++){
+			nextReq = reqs[i].name;
+			if(nextReq && !reqChain[nextReq]){
+				//New req depedency. Follow it down.
+				reqChain.push(nextReq);
+				reqChain[nextReq] = true;
+				this.xdEvalReqs(reqChain);
+			}
+		}
+	}
+}
+
+//Do a depth first, breadth second search and eval or reqs.
+dojo.hostenv.xdEvalReqs = function(reqChain){
+	if(reqChain.length > 0){
 		var req = reqChain[reqChain.length - 1];
 		var pkg = this.xdDepMap[req];
-		if (pkg) {
-			var reqs = pkg.requires;
-			if (reqs && reqs.length > 0) {
-				var nextReq;
-				for (var i = 0; i < reqs.length; i++) {
-					nextReq = reqs[i].name;
-					if (nextReq && !reqChain[nextReq]) {
-						reqChain.push(nextReq);
-						reqChain[nextReq] = true;
-						this.xdEvalReqs(reqChain);
-					}
-				}
-			}
+		if(pkg){
+			//Trace down any requires for this package.
+			this.xdTraceReqs(pkg.requires, reqChain);
+
+			//Evaluate the package.
 			var contents = this.xdContents[pkg.contentIndex];
-			if (!contents.isDefined) {
-				var content = contents.content;
-				content["resourceName"] = contents["resourceName"];
-				content["resourcePath"] = contents["resourcePath"];
-				this.xdDefList.push(content);
+			if(!contents.isDefined){
+				//Evaluate the package to bring it into being.
+				//Pass dojo in so that later, to support multiple versions of dojo
+				//in a page, we can pass which version of dojo to use.
+				contents.content(dojo);
 				contents.isDefined = true;
 			}
 			this.xdDepMap[req] = null;
-			var reqs = pkg.requiresAfter;
-			if (reqs && reqs.length > 0) {
-				var nextReq;
-				for (var i = 0; i < reqs.length; i++) {
-					nextReq = reqs[i].name;
-					if (nextReq && !reqChain[nextReq]) {
-						reqChain.push(nextReq);
-						reqChain[nextReq] = true;
-						this.xdEvalReqs(reqChain);
-					}
-				}
-			}
+
+			//Trace down any requireAfters for this package..
+			this.xdTraceReqs(pkg.requiresAfter, reqChain);
 		}
+
+		//Done with that require. Remove it and go to the next one.
 		reqChain.pop();
+		this.xdEvalReqs(reqChain);
 	}
-};
-dojo.hostenv.clearXdInterval = function () {
+}
+
+dojo.hostenv.clearXdInterval = function(){
 	clearInterval(this.xdTimer);
 	this.xdTimer = 0;
-};
-dojo.hostenv.watchInFlightXDomain = function () {
-	var waitInterval = (djConfig.xdWaitSeconds || 15) * 1000;
-	if (this.xdStartTime + waitInterval < (new Date()).getTime()) {
+}
+
+dojo.hostenv.watchInFlightXDomain = function(){
+	//Make sure we haven't waited timed out.
+	var waitInterval = (djConfig.xdWaitSeconds || 30) * 1000;
+
+	if(this.xdStartTime + waitInterval < (new Date()).getTime()){
 		this.clearXdInterval();
 		var noLoads = "";
-		for (var param in this.xdInFlight) {
-			if (this.xdInFlight[param]) {
+		for(var param in this.xdInFlight){
+			if(this.xdInFlight[param]){
 				noLoads += param + " ";
 			}
 		}
 		dojo.raise("Could not load cross-domain packages: " + noLoads);
 	}
-	for (var param in this.xdInFlight) {
-		if (this.xdInFlight[param]) {
+
+	//If any are true, then still waiting.
+	//Come back later.	
+	for(var param in this.xdInFlight){
+		if(this.xdInFlight[param]){
 			return;
 		}
 	}
+
+	//All done loading. Clean up and notify that we are loaded.
 	this.clearXdInterval();
+
 	this.xdWalkReqs();
-	var defLength = this.xdDefList.length;
-	for (var i = 0; i < defLength; i++) {
-		var content = dojo.hostenv.xdDefList[i];
-		if (djConfig["debugAtAllCosts"] && content["resourceName"]) {
-			if (!this["xdDebugQueue"]) {
-				this.xdDebugQueue = [];
-			}
-			this.xdDebugQueue.push({resourceName:content.resourceName, resourcePath:content.resourcePath});
-		} else {
-			content(dojo);
-		}
-	}
-	for (var i = 0; i < this.xdContents.length; i++) {
+
+	//Evaluate any packages that were not evaled before.
+	//This normally shouldn't happen with proper dojo.provide and dojo.require
+	//usage, but providing it just in case. Note that these may not be executed
+	//in the original order that the developer intended.
+	//Pass dojo in so that later, to support multiple versions of dojo
+	//in a page, we can pass which version of dojo to use.
+	for(var i = 0; i < this.xdContents.length; i++){
 		var current = this.xdContents[i];
-		if (current.content && !current.isDefined) {
+		if(current.content && !current.isDefined){
 			current.content(dojo);
 		}
 	}
+
+	//Clean up for the next round of xd loading.
 	this.resetXd();
-	if (this["xdDebugQueue"] && this.xdDebugQueue.length > 0) {
-		this.xdDebugFileLoaded();
-	} else {
-		this.xdNotifyLoaded();
-	}
-};
-dojo.hostenv.xdNotifyLoaded = function () {
-	this.inFlightCount = 0;
-	if (this._djInitFired && !this.loadNotifying) {
-		this.callLoaded();
-	}
-};
-dojo.hostenv.flattenRequireArray = function (target) {
-	if (target) {
-		for (var i = 0; i < target.length; i++) {
-			if (target[i] instanceof Array) {
-				target[i] = {name:target[i][0], content:null};
-			} else {
-				target[i] = {name:target[i], content:null};
+
+	//Clear inflight count so we will finally do finish work.
+	this.inFlightCount = 0; 
+	this.callLoaded();
+}
+
+dojo.hostenv.flattenRequireArray = function(target){
+	//Each result could be an array of 3 elements  (the 3 arguments to dojo.require).
+	//We only need the first one.
+	if(target){
+		for(var i = 0; i < target.length; i++){
+			if(target[i] instanceof Array){
+				target[i] = {name: target[i][0], content: null};
+			}else{
+				target[i] = {name: target[i], content: null};
 			}
 		}
 	}
-};
-dojo.hostenv.xdHasCalledPreload = false;
-dojo.hostenv.xdRealCallLoaded = dojo.hostenv.callLoaded;
-dojo.hostenv.callLoaded = function () {
-	if (this.xdHasCalledPreload || dojo.hostenv.getModulePrefix("dojo") == "src" || !this.localesGenerated) {
-		this.xdRealCallLoaded();
-	} else {
-		if (this.localesGenerated) {
-			this.registerNlsPrefix = function () {
-				dojo.registerModulePath("nls", dojo.hostenv.getModulePrefix("dojo") + "/../nls");
-			};
-			this.preloadLocalizations();
-		}
-	}
-	this.xdHasCalledPreload = true;
-};
-
+}

Deleted: tags/parley-0.53/root/static/magic/src/logging/ConsoleLogger.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/logging/ConsoleLogger.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/logging/ConsoleLogger.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,86 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.logging.ConsoleLogger");
-dojo.require("dojo.logging.Logger");
-dojo.lang.extend(dojo.logging.MemoryLogHandler, {debug:function () {
-	dojo.hostenv.println.apply(this, arguments);
-}, info:function () {
-	dojo.hostenv.println.apply(this, arguments);
-}, warn:function () {
-	dojo.hostenv.println.apply(this, arguments);
-}, error:function () {
-	dojo.hostenv.println.apply(this, arguments);
-}, critical:function () {
-	dojo.hostenv.println.apply(this, arguments);
-}, emit:function (record) {
-	if (!djConfig.isDebug) {
-		return;
-	}
-	var funcName = null;
-	switch (record.level) {
-	  case 1:
-		funcName = "debug";
-		break;
-	  case 2:
-		funcName = "info";
-		break;
-	  case 3:
-		funcName = "warn";
-		break;
-	  case 4:
-		funcName = "error";
-		break;
-	  case 5:
-		funcName = "critical";
-		break;
-	  default:
-		funcName = "debug";
-	}
-	var logStr = String(dojo.log.getLevelName(record.level) + ": " + record.time.toLocaleTimeString()) + ": " + record.message;
-	if (record.msgArgs && record.msgArgs.length > 0) {
-		this[funcName].call(this, logStr, record.msgArgs);
-	} else {
-		this[funcName].call(this, logStr);
-	}
-	this.data.push(record);
-	if (this.numRecords != -1) {
-		while (this.data.length > this.numRecords) {
-			this.data.shift();
-		}
-	}
-}});
-if (!dj_undef("console") && !dj_undef("info", console)) {
-	dojo.lang.extend(dojo.logging.MemoryLogHandler, {debug:function () {
-		console.debug.apply(this, arguments);
-	}, info:function () {
-		console.info.apply(this, arguments);
-	}, warn:function () {
-		console.warn.apply(this, arguments);
-	}, error:function () {
-		console.error.apply(this, arguments);
-	}, critical:function () {
-		console.error.apply(this, arguments);
-	}});
-	dojo.lang.extend(dojo.logging.Logger, {exception:function (msg, e, squelch) {
-		var args = [msg];
-		if (e) {
-			msg += " : " + e.name + " " + (e.description || e.message);
-			args.push(e);
-		}
-		this.logType("ERROR", args);
-		if (!squelch) {
-			throw e;
-		}
-	}});
-}
-

Modified: tags/parley-0.53/root/static/magic/src/logging/Logger.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/logging/Logger.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/logging/Logger.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,209 +8,401 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/*		This is the dojo logging facility, which is imported from nWidgets
+		(written by Alex Russell, CLA on file), which is patterned on the
+		Python logging module, which in turn has been heavily influenced by
+		log4j (execpt with some more pythonic choices, which we adopt as well).
 
+		While the dojo logging facilities do provide a set of familiar
+		interfaces, many of the details are changed to reflect the constraints
+		of the browser environment. Mainly, file and syslog-style logging
+		facilites are not provided, with HTTP POST and GET requests being the
+		only ways of getting data from the browser back to a server. Minimal
+		support for this (and XML serialization of logs) is provided, but may
+		not be of practical use in a deployment environment.
 
+		The Dojo logging classes are agnostic of any environment, and while
+		default loggers are provided for browser-based interpreter
+		environments, this file and the classes it define are explicitly
+		designed to be portable to command-line interpreters and other
+		ECMA-262v3 envrionments.
+
+	the logger needs to accomidate:
+		log "levels"
+		type identifiers
+		file?
+		message
+		tic/toc?
+
+	The logger should ALWAYS record:
+		time/date logged
+		message
+		type
+		level
+*/
+// TODO: conver documentation to javadoc style once we confirm that is our choice
+// TODO: define DTD for XML-formatted log messages
+// TODO: write XML Formatter class
+// TODO: write HTTP Handler which uses POST to send log lines/sections
+
+// Filename:	LogCore.js
+// Purpose:		a common logging infrastructure for dojo
+// Classes:		dojo.logging, dojo.logging.Logger, dojo.logging.Record, dojo.logging.LogFilter
+// Global Objects:	dojo.logging
+// Dependencies:	none
+
 dojo.provide("dojo.logging.Logger");
-dojo.provide("dojo.logging.LogFilter");
-dojo.provide("dojo.logging.Record");
 dojo.provide("dojo.log");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.declare");
-dojo.logging.Record = function (logLevel, message) {
-	this.level = logLevel;
-	this.message = "";
-	this.msgArgs = [];
+dojo.require("dojo.lang");
+
+/*
+	A simple data structure class that stores information for and about
+	a logged event. Objects of this type are created automatically when
+	an event is logged and are the internal format in which information
+	about log events is kept.
+*/
+
+dojo.logging.Record = function(lvl, msg){
+	this.level = lvl;
+	this.message = msg;
 	this.time = new Date();
-	if (dojo.lang.isArray(message)) {
-		if (message.length > 0 && dojo.lang.isString(message[0])) {
-			this.message = message.shift();
-		}
-		this.msgArgs = message;
-	} else {
-		this.message = message;
+	// FIXME: what other information can we receive/discover here?
+}
+
+// an empty parent (abstract) class which concrete filters should inherit from.
+dojo.logging.LogFilter = function(loggerChain){
+	this.passChain = loggerChain || "";
+	this.filter = function(record){
+		// FIXME: need to figure out a way to enforce the loggerChain
+		// restriction
+		return true; // pass all records
 	}
-};
-dojo.logging.LogFilter = function (loggerChain) {
-	this.passChain = loggerChain || "";
-	this.filter = function (record) {
-		return true;
-	};
-};
-dojo.logging.Logger = function () {
+}
+
+dojo.logging.Logger = function(){
 	this.cutOffLevel = 0;
 	this.propagate = true;
 	this.parent = null;
+	// storage for dojo.logging.Record objects seen and accepted by this logger
 	this.data = [];
 	this.filters = [];
 	this.handlers = [];
-};
-dojo.extend(dojo.logging.Logger, {_argsToArr:function (args) {
-	var ret = [];
-	for (var x = 0; x < args.length; x++) {
-		ret.push(args[x]);
-	}
-	return ret;
-}, setLevel:function (lvl) {
-	this.cutOffLevel = parseInt(lvl);
-}, isEnabledFor:function (lvl) {
-	return parseInt(lvl) >= this.cutOffLevel;
-}, getEffectiveLevel:function () {
-	if ((this.cutOffLevel == 0) && (this.parent)) {
-		return this.parent.getEffectiveLevel();
-	}
-	return this.cutOffLevel;
-}, addFilter:function (flt) {
-	this.filters.push(flt);
-	return this.filters.length - 1;
-}, removeFilterByIndex:function (fltIndex) {
-	if (this.filters[fltIndex]) {
-		delete this.filters[fltIndex];
-		return true;
-	}
-	return false;
-}, removeFilter:function (fltRef) {
-	for (var x = 0; x < this.filters.length; x++) {
-		if (this.filters[x] === fltRef) {
-			delete this.filters[x];
+}
+
+dojo.lang.extend(dojo.logging.Logger, {
+	argsToArr: function(args){
+		// utility function, reproduced from __util__ here to remove dependency
+		var ret = [];
+		for(var x=0; x<args.length; x++){
+			ret.push(args[x]);
+		}
+		return ret;
+	},
+
+	setLevel: function(lvl){
+		this.cutOffLevel = parseInt(lvl);
+	},
+
+	isEnabledFor: function(lvl){
+		return parseInt(lvl) >= this.cutOffLevel;
+	},
+
+	getEffectiveLevel: function(){
+		if((this.cutOffLevel==0)&&(this.parent)){
+			return this.parent.getEffectiveLevel();
+		}
+		return this.cutOffLevel;
+	},
+
+	addFilter: function(flt){
+		this.filters.push(flt);
+		return this.filters.length-1;
+	},
+
+	removeFilterByIndex: function(fltIndex){
+		if(this.filters[fltIndex]){
+			delete this.filters[fltIndex];
 			return true;
 		}
-	}
-	return false;
-}, removeAllFilters:function () {
-	this.filters = [];
-}, filter:function (rec) {
-	for (var x = 0; x < this.filters.length; x++) {
-		if ((this.filters[x]["filter"]) && (!this.filters[x].filter(rec)) || (rec.level < this.cutOffLevel)) {
-			return false;
-		}
-	}
-	return true;
-}, addHandler:function (hdlr) {
-	this.handlers.push(hdlr);
-	return this.handlers.length - 1;
-}, handle:function (rec) {
-	if ((!this.filter(rec)) || (rec.level < this.cutOffLevel)) {
 		return false;
-	}
-	for (var x = 0; x < this.handlers.length; x++) {
-		if (this.handlers[x]["handle"]) {
-			this.handlers[x].handle(rec);
+	},
+
+	removeFilter: function(fltRef){
+		for(var x=0; x<this.filters.length; x++){
+			if(this.filters[x]===fltRef){
+				delete this.filters[x];
+				return true;
+			}
 		}
-	}
-	return true;
-}, log:function (lvl, msg) {
-	if ((this.propagate) && (this.parent) && (this.parent.rec.level >= this.cutOffLevel)) {
-		this.parent.log(lvl, msg);
 		return false;
-	}
-	this.handle(new dojo.logging.Record(lvl, msg));
-	return true;
-}, debug:function (msg) {
-	return this.logType("DEBUG", this._argsToArr(arguments));
-}, info:function (msg) {
-	return this.logType("INFO", this._argsToArr(arguments));
-}, warning:function (msg) {
-	return this.logType("WARNING", this._argsToArr(arguments));
-}, error:function (msg) {
-	return this.logType("ERROR", this._argsToArr(arguments));
-}, critical:function (msg) {
-	return this.logType("CRITICAL", this._argsToArr(arguments));
-}, exception:function (msg, e, squelch) {
-	if (e) {
-		var eparts = [e.name, (e.description || e.message)];
-		if (e.fileName) {
-			eparts.push(e.fileName);
-			eparts.push("line " + e.lineNumber);
+	},
+
+	removeAllFilters: function(){
+		this.filters = []; // clobber all of them
+	},
+
+	filter: function(rec){
+		for(var x=0; x<this.filters.length; x++){
+			if((this.filters[x]["filter"])&&
+			   (!this.filters[x].filter(rec))||
+			   (rec.level<this.cutOffLevel)){
+				return false;
+			}
 		}
-		msg += " " + eparts.join(" : ");
+		return true;
+	},
+
+	addHandler: function(hdlr){
+		this.handlers.push(hdlr);
+		return this.handlers.length-1;
+	},
+
+	handle: function(rec){
+		if((!this.filter(rec))||(rec.level<this.cutOffLevel)){ return false; }
+		for(var x=0; x<this.handlers.length; x++){
+			if(this.handlers[x]["handle"]){
+			   this.handlers[x].handle(rec);
+			}
+		}
+		// FIXME: not sure what to do about records to be propagated that may have
+		// been modified by the handlers or the filters at this logger. Should
+		// parents always have pristine copies? or is passing the modified record
+		// OK?
+		// if((this.propagate)&&(this.parent)){ this.parent.handle(rec); }
+		return true;
+	},
+
+	// the heart and soul of the logging system
+	log: function(lvl, msg){
+		if(	(this.propagate)&&(this.parent)&&
+			(this.parent.rec.level>=this.cutOffLevel)){
+			this.parent.log(lvl, msg);
+			return false;
+		}
+		// FIXME: need to call logging providers here!
+		this.handle(new dojo.logging.Record(lvl, msg));
+		return true;
+	},
+
+	// logger helpers
+	debug:function(msg){
+		return this.logType("DEBUG", this.argsToArr(arguments));
+	},
+
+	info: function(msg){
+		return this.logType("INFO", this.argsToArr(arguments));
+	},
+
+	warning: function(msg){
+		return this.logType("WARNING", this.argsToArr(arguments));
+	},
+
+	error: function(msg){
+		return this.logType("ERROR", this.argsToArr(arguments));
+	},
+
+	critical: function(msg){
+		return this.logType("CRITICAL", this.argsToArr(arguments));
+	},
+
+	exception: function(msg, e, squelch){
+		// FIXME: this needs to be modified to put the exception in the msg
+		// if we're on Moz, we can get the following from the exception object:
+		//		lineNumber
+		//		message
+		//		fileName
+		//		stack
+		//		name
+		// on IE, we get:
+		//		name
+		//		message (from MDA?)
+		//		number
+		//		description (same as message!)
+		if(e){
+			var eparts = [e.name, (e.description||e.message)];
+			if(e.fileName){
+				eparts.push(e.fileName);
+				eparts.push("line "+e.lineNumber);
+				// eparts.push(e.stack);
+			}
+			msg += " "+eparts.join(" : ");
+		}
+
+		this.logType("ERROR", msg);
+		if(!squelch){
+			throw e;
+		}
+	},
+
+	logType: function(type, args){
+		var na = [dojo.logging.log.getLevel(type)];
+		if(typeof args == "array"){
+			na = na.concat(args);
+		}else if((typeof args == "object")&&(args["length"])){
+			na = na.concat(this.argsToArr(args));
+			/* for(var x=0; x<args.length; x++){
+				na.push(args[x]);
+			} */
+		}else{
+			na = na.concat(this.argsToArr(arguments).slice(1));
+			/* for(var x=1; x<arguments.length; x++){
+				na.push(arguments[x]);
+			} */
+		}
+		return this.log.apply(this, na);
 	}
-	this.logType("ERROR", msg);
-	if (!squelch) {
-		throw e;
-	}
-}, logType:function (type, args) {
-	return this.log.apply(this, [dojo.logging.log.getLevel(type), args]);
-}, warn:function () {
-	this.warning.apply(this, arguments);
-}, err:function () {
-	this.error.apply(this, arguments);
-}, crit:function () {
-	this.critical.apply(this, arguments);
-}});
-dojo.logging.LogHandler = function (level) {
+});
+
+void(function(){
+	var ptype = dojo.logging.Logger.prototype;
+	ptype.warn = ptype.warning;
+	ptype.err = ptype.error;
+	ptype.crit = ptype.critical;
+})();
+
+// the Handler class
+dojo.logging.LogHandler = function(level){
 	this.cutOffLevel = (level) ? level : 0;
-	this.formatter = null;
+	this.formatter = null; // FIXME: default formatter?
 	this.data = [];
 	this.filters = [];
-};
-dojo.lang.extend(dojo.logging.LogHandler, {setFormatter:function (formatter) {
+}
+
+dojo.logging.LogHandler.prototype.setFormatter = function(fmtr){
+	// FIXME: need to vet that it is indeed a formatter object
 	dojo.unimplemented("setFormatter");
-}, flush:function () {
-}, close:function () {
-}, handleError:function () {
-	dojo.deprecated("dojo.logging.LogHandler.handleError", "use handle()", "0.6");
-}, handle:function (record) {
-	if ((this.filter(record)) && (record.level >= this.cutOffLevel)) {
+}
+
+dojo.logging.LogHandler.prototype.flush = function(){
+	dojo.unimplemented("flush");
+}
+
+dojo.logging.LogHandler.prototype.close = function(){
+	dojo.unimplemented("close");
+}
+
+dojo.logging.LogHandler.prototype.handleError = function(){
+	dojo.unimplemented("handleError");
+}
+
+dojo.logging.LogHandler.prototype.handle = function(record){
+	// emits the passed record if it passes this object's filters
+	if((this.filter(record))&&(record.level>=this.cutOffLevel)){
 		this.emit(record);
 	}
-}, emit:function (record) {
+}
+
+dojo.logging.LogHandler.prototype.emit = function(record){
+	// do whatever is necessaray to actually log the record
 	dojo.unimplemented("emit");
-}});
-void (function () {
-	var names = ["setLevel", "addFilter", "removeFilterByIndex", "removeFilter", "removeAllFilters", "filter"];
+}
+
+// set aliases since we don't want to inherit from dojo.logging.Logger
+void(function(){ // begin globals protection closure
+	var names = [
+		"setLevel", "addFilter", "removeFilterByIndex", "removeFilter",
+		"removeAllFilters", "filter"
+	];
 	var tgt = dojo.logging.LogHandler.prototype;
 	var src = dojo.logging.Logger.prototype;
-	for (var x = 0; x < names.length; x++) {
+	for(var x=0; x<names.length; x++){
 		tgt[names[x]] = src[names[x]];
 	}
-})();
+})(); // end globals protection closure
+
 dojo.logging.log = new dojo.logging.Logger();
-dojo.logging.log.levels = [{"name":"DEBUG", "level":1}, {"name":"INFO", "level":2}, {"name":"WARNING", "level":3}, {"name":"ERROR", "level":4}, {"name":"CRITICAL", "level":5}];
+
+// an associative array of logger objects. This object inherits from
+// a list of level names with their associated numeric levels
+dojo.logging.log.levels = [ {"name": "DEBUG", "level": 1},
+						   {"name": "INFO", "level": 2},
+						   {"name": "WARNING", "level": 3},
+						   {"name": "ERROR", "level": 4},
+						   {"name": "CRITICAL", "level": 5} ];
+
 dojo.logging.log.loggers = {};
-dojo.logging.log.getLogger = function (name) {
-	if (!this.loggers[name]) {
+
+dojo.logging.log.getLogger = function(name){
+	if(!this.loggers[name]){
 		this.loggers[name] = new dojo.logging.Logger();
 		this.loggers[name].parent = this;
 	}
 	return this.loggers[name];
-};
-dojo.logging.log.getLevelName = function (lvl) {
-	for (var x = 0; x < this.levels.length; x++) {
-		if (this.levels[x].level == lvl) {
+}
+
+dojo.logging.log.getLevelName = function(lvl){
+	for(var x=0; x<this.levels.length; x++){
+		if(this.levels[x].level == lvl){
 			return this.levels[x].name;
 		}
 	}
 	return null;
-};
-dojo.logging.log.getLevel = function (name) {
-	for (var x = 0; x < this.levels.length; x++) {
-		if (this.levels[x].name.toUpperCase() == name.toUpperCase()) {
+}
+
+dojo.logging.log.addLevelName = function(name, lvl){
+	if(this.getLevelName(name)){
+		this.err("could not add log level "+name+" because a level with that name already exists");
+		return false;
+	}
+	this.levels.append({"name": name, "level": parseInt(lvl)});
+	return true;
+}
+
+dojo.logging.log.getLevel = function(name){
+	for(var x=0; x<this.levels.length; x++){
+		if(this.levels[x].name.toUpperCase() == name.toUpperCase()){
 			return this.levels[x].level;
 		}
 	}
 	return null;
-};
-dojo.declare("dojo.logging.MemoryLogHandler", dojo.logging.LogHandler, {initializer:function (level, recordsToKeep, postType, postInterval) {
+}
+
+// a default handler class, it simply saves all of the handle()'d records in
+// memory. Useful for attaching to with dojo.event.connect()
+dojo.logging.MemoryLogHandler = function(level, recordsToKeep, postType, postInterval){
+	// mixin style inheritance
 	dojo.logging.LogHandler.call(this, level);
-	this.numRecords = (typeof djConfig["loggingNumRecords"] != "undefined") ? djConfig["loggingNumRecords"] : ((recordsToKeep) ? recordsToKeep : -1);
-	this.postType = (typeof djConfig["loggingPostType"] != "undefined") ? djConfig["loggingPostType"] : (postType || -1);
-	this.postInterval = (typeof djConfig["loggingPostInterval"] != "undefined") ? djConfig["loggingPostInterval"] : (postType || -1);
-}, emit:function (record) {
-	if (!djConfig.isDebug) {
-		return;
+	// default is unlimited
+	this.numRecords = (typeof djConfig['loggingNumRecords'] != 'undefined') ? djConfig['loggingNumRecords'] : ((recordsToKeep) ? recordsToKeep : -1);
+	// 0=count, 1=time, -1=don't post TODO: move this to a better location for prefs
+	this.postType = (typeof djConfig['loggingPostType'] != 'undefined') ? djConfig['loggingPostType'] : ( postType || -1);
+	// milliseconds for time, interger for number of records, -1 for non-posting,
+	this.postInterval = (typeof djConfig['loggingPostInterval'] != 'undefined') ? djConfig['loggingPostInterval'] : ( postType || -1);
+	
+}
+// prototype inheritance
+dojo.logging.MemoryLogHandler.prototype = new dojo.logging.LogHandler();
+
+// FIXME
+// dojo.inherits(dojo.logging.MemoryLogHandler, 
+
+// over-ride base-class
+dojo.logging.MemoryLogHandler.prototype.emit = function(record){
+	this.data.push(record);
+	if(this.numRecords != -1){
+		while(this.data.length>this.numRecords){
+			this.data.shift();
+		}
 	}
-	var logStr = String(dojo.log.getLevelName(record.level) + ": " + record.time.toLocaleTimeString()) + ": " + record.message;
-	if (!dj_undef("println", dojo.hostenv)) {
-		dojo.hostenv.println(logStr, record.msgArgs);
+}
+
+dojo.logging.logQueueHandler = new dojo.logging.MemoryLogHandler(0,50,0,10000);
+// actual logging event handler
+dojo.logging.logQueueHandler.emit = function(record){
+	// we should probably abstract this in the future
+	var logStr = String(dojo.log.getLevelName(record.level)+": "+record.time.toLocaleTimeString())+": "+record.message;
+	if(!dj_undef("debug", dj_global)){
+		dojo.debug(logStr);
+	}else if((typeof dj_global["print"] == "function")&&(!dojo.render.html.capable)){
+		print(logStr);
 	}
 	this.data.push(record);
-	if (this.numRecords != -1) {
-		while (this.data.length > this.numRecords) {
+	if(this.numRecords != -1){
+		while(this.data.length>this.numRecords){
 			this.data.shift();
 		}
 	}
-}});
-dojo.logging.logQueueHandler = new dojo.logging.MemoryLogHandler(0, 50, 0, 10000);
+}
+
 dojo.logging.log.addHandler(dojo.logging.logQueueHandler);
 dojo.log = dojo.logging.log;
-

Modified: tags/parley-0.53/root/static/magic/src/logging/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/logging/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/logging/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,8 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:[["dojo.logging.Logger", false, false]], rhino:["dojo.logging.RhinoLogger"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.logging.Logger", false, false],
+	rhino: ["dojo.logging.RhinoLogger"]
+});
 dojo.provide("dojo.logging.*");
-

Added: tags/parley-0.53/root/static/magic/src/math/Math.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/math/Math.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/math/Math.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.deprecated("dojo.math.Math", "include dojo.math instead", "0.4");
+dojo.require("dojo.math");

Modified: tags/parley-0.53/root/static/magic/src/math/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/math/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/math/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,11 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:[["dojo.math", false, false], ["dojo.math.curves", false, false], ["dojo.math.points", false, false]]});
+dojo.kwCompoundRequire({
+	common: [
+		["dojo.math", false, false],
+		["dojo.math.curves", false, false],
+		["dojo.math.points", false, false]
+	]
+});
 dojo.provide("dojo.math.*");
-

Modified: tags/parley-0.53/root/static/magic/src/math/curves.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/math/curves.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/math/curves.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,177 +8,215 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.math.curves");
 
+dojo.require("dojo.math");
 
-dojo.provide("dojo.math.curves");
-dojo.require("dojo.math");
-dojo.math.curves = {Line:function (start, end) {
-	this.start = start;
-	this.end = end;
-	this.dimensions = start.length;
-	for (var i = 0; i < start.length; i++) {
-		start[i] = Number(start[i]);
-	}
-	for (var i = 0; i < end.length; i++) {
-		end[i] = Number(end[i]);
-	}
-	this.getValue = function (n) {
-		var retVal = new Array(this.dimensions);
-		for (var i = 0; i < this.dimensions; i++) {
-			retVal[i] = ((this.end[i] - this.start[i]) * n) + this.start[i];
+/* Curves from Dan's 13th lib stuff.
+ * See: http://pupius.co.uk/js/Toolkit.Drawing.js
+ *      http://pupius.co.uk/dump/dojo/Dojo.Math.js
+ */
+
+dojo.math.curves = {
+	//Creates a straight line object
+	Line: function(start, end) {
+		this.start = start;
+		this.end = end;
+		this.dimensions = start.length;
+
+		for(var i = 0; i < start.length; i++) {
+			start[i] = Number(start[i]);
 		}
-		return retVal;
-	};
-	return this;
-}, Bezier:function (pnts) {
-	this.getValue = function (step) {
-		if (step >= 1) {
-			return this.p[this.p.length - 1];
+
+		for(var i = 0; i < end.length; i++) {
+			end[i] = Number(end[i]);
 		}
-		if (step <= 0) {
-			return this.p[0];
+
+		//simple function to find point on an n-dimensional, straight line
+		this.getValue = function(n) {
+			var retVal = new Array(this.dimensions);
+			for(var i=0;i<this.dimensions;i++)
+				retVal[i] = ((this.end[i] - this.start[i]) * n) + this.start[i];
+			return retVal;
 		}
-		var retVal = new Array(this.p[0].length);
-		for (var k = 0; j < this.p[0].length; k++) {
-			retVal[k] = 0;
+
+		return this;
+	},
+
+
+	//Takes an array of points, the first is the start point, the last is end point and the ones in
+	//between are the Bezier control points.
+	Bezier: function(pnts) {
+		this.getValue = function(step) {
+			if(step >= 1) return this.p[this.p.length-1];	// if step>=1 we must be at the end of the curve
+			if(step <= 0) return this.p[0];					// if step<=0 we must be at the start of the curve
+			var retVal = new Array(this.p[0].length);
+			for(var k=0;j<this.p[0].length;k++) { retVal[k]=0; }
+			for(var j=0;j<this.p[0].length;j++) {
+				var C=0; var D=0;
+				for(var i=0;i<this.p.length;i++) {
+					C += this.p[i][j] * this.p[this.p.length-1][0]
+						* dojo.math.bernstein(step,this.p.length,i);
+				}
+				for(var l=0;l<this.p.length;l++) {
+					D += this.p[this.p.length-1][0] * dojo.math.bernstein(step,this.p.length,l);
+				}
+				retVal[j] = C/D;
+			}
+			return retVal;
 		}
-		for (var j = 0; j < this.p[0].length; j++) {
-			var C = 0;
-			var D = 0;
-			for (var i = 0; i < this.p.length; i++) {
-				C += this.p[i][j] * this.p[this.p.length - 1][0] * dojo.math.bernstein(step, this.p.length, i);
+		this.p = pnts;
+		return this;
+	},
+
+
+	//Catmull-Rom Spline - allows you to interpolate a smooth curve through a set of points in n-dimensional space
+	CatmullRom : function(pnts,c) {
+		this.getValue = function(step) {
+			var percent = step * (this.p.length-1);
+			var node = Math.floor(percent);
+			var progress = percent - node;
+
+			var i0 = node-1; if(i0 < 0) i0 = 0;
+			var i = node;
+			var i1 = node+1; if(i1 >= this.p.length) i1 = this.p.length-1;
+			var i2 = node+2; if(i2 >= this.p.length) i2 = this.p.length-1;
+
+			var u = progress;
+			var u2 = progress*progress;
+			var u3 = progress*progress*progress;
+
+			var retVal = new Array(this.p[0].length);
+			for(var k=0;k<this.p[0].length;k++) {
+				var x1 = ( -this.c * this.p[i0][k] ) + ( (2 - this.c) * this.p[i][k] ) + ( (this.c-2) * this.p[i1][k] ) + ( this.c * this.p[i2][k] );
+				var x2 = ( 2 * this.c * this.p[i0][k] ) + ( (this.c-3) * this.p[i][k] ) + ( (3 - 2 * this.c) * this.p[i1][k] ) + ( -this.c * this.p[i2][k] );
+				var x3 = ( -this.c * this.p[i0][k] ) + ( this.c * this.p[i1][k] );
+				var x4 = this.p[i][k];
+
+				retVal[k] = x1*u3 + x2*u2 + x3*u + x4;
 			}
-			for (var l = 0; l < this.p.length; l++) {
-				D += this.p[this.p.length - 1][0] * dojo.math.bernstein(step, this.p.length, l);
-			}
-			retVal[j] = C / D;
+			return retVal;
+
 		}
-		return retVal;
-	};
-	this.p = pnts;
-	return this;
-}, CatmullRom:function (pnts, c) {
-	this.getValue = function (step) {
-		var percent = step * (this.p.length - 1);
-		var node = Math.floor(percent);
-		var progress = percent - node;
-		var i0 = node - 1;
-		if (i0 < 0) {
-			i0 = 0;
+
+
+		if(!c) this.c = 0.7;
+		else this.c = c;
+		this.p = pnts;
+
+		return this;
+	},
+
+	// FIXME: This is the bad way to do a partial-arc with 2 points. We need to have the user
+	// supply the radius, otherwise we always get a half-circle between the two points.
+	Arc : function(start, end, ccw) {
+		var center = dojo.math.points.midpoint(start, end);
+		var sides = dojo.math.points.translate(dojo.math.points.invert(center), start);
+		var rad = Math.sqrt(Math.pow(sides[0], 2) + Math.pow(sides[1], 2));
+		var theta = dojo.math.radToDeg(Math.atan(sides[1]/sides[0]));
+		if( sides[0] < 0 ) {
+			theta -= 90;
+		} else {
+			theta += 90;
 		}
-		var i = node;
-		var i1 = node + 1;
-		if (i1 >= this.p.length) {
-			i1 = this.p.length - 1;
+		dojo.math.curves.CenteredArc.call(this, center, rad, theta, theta+(ccw?-180:180));
+	},
+
+	// Creates an arc object, with center and radius (Top of arc = 0 degrees, increments clockwise)
+	//  center => 2D point for center of arc
+	//  radius => scalar quantity for radius of arc
+	//  start  => to define an arc specify start angle (default: 0)
+	//  end    => to define an arc specify start angle
+	CenteredArc : function(center, radius, start, end) {
+		this.center = center;
+		this.radius = radius;
+		this.start = start || 0;
+		this.end = end;
+
+		this.getValue = function(n) {
+			var retVal = new Array(2);
+			var theta = dojo.math.degToRad(this.start+((this.end-this.start)*n));
+
+			retVal[0] = this.center[0] + this.radius*Math.sin(theta);
+			retVal[1] = this.center[1] - this.radius*Math.cos(theta);
+
+			return retVal;
 		}
-		var i2 = node + 2;
-		if (i2 >= this.p.length) {
-			i2 = this.p.length - 1;
+
+		return this;
+	},
+
+	// Special case of Arc (start = 0, end = 360)
+	Circle : function(center, radius) {
+		dojo.math.curves.CenteredArc.call(this, center, radius, 0, 360);
+		return this;
+	},
+
+	Path : function() {
+		var curves = [];
+		var weights = [];
+		var ranges = [];
+		var totalWeight = 0;
+
+		this.add = function(curve, weight) {
+			if( weight < 0 ) { dojo.raise("dojo.math.curves.Path.add: weight cannot be less than 0"); }
+			curves.push(curve);
+			weights.push(weight);
+			totalWeight += weight;
+			computeRanges();
 		}
-		var u = progress;
-		var u2 = progress * progress;
-		var u3 = progress * progress * progress;
-		var retVal = new Array(this.p[0].length);
-		for (var k = 0; k < this.p[0].length; k++) {
-			var x1 = (-this.c * this.p[i0][k]) + ((2 - this.c) * this.p[i][k]) + ((this.c - 2) * this.p[i1][k]) + (this.c * this.p[i2][k]);
-			var x2 = (2 * this.c * this.p[i0][k]) + ((this.c - 3) * this.p[i][k]) + ((3 - 2 * this.c) * this.p[i1][k]) + (-this.c * this.p[i2][k]);
-			var x3 = (-this.c * this.p[i0][k]) + (this.c * this.p[i1][k]);
-			var x4 = this.p[i][k];
-			retVal[k] = x1 * u3 + x2 * u2 + x3 * u + x4;
+
+		this.remove = function(curve) {
+			for(var i = 0; i < curves.length; i++) {
+				if( curves[i] == curve ) {
+					curves.splice(i, 1);
+					totalWeight -= weights.splice(i, 1)[0];
+					break;
+				}
+			}
+			computeRanges();
 		}
-		return retVal;
-	};
-	if (!c) {
-		this.c = 0.7;
-	} else {
-		this.c = c;
-	}
-	this.p = pnts;
-	return this;
-}, Arc:function (start, end, ccw) {
-	var center = dojo.math.points.midpoint(start, end);
-	var sides = dojo.math.points.translate(dojo.math.points.invert(center), start);
-	var rad = Math.sqrt(Math.pow(sides[0], 2) + Math.pow(sides[1], 2));
-	var theta = dojo.math.radToDeg(Math.atan(sides[1] / sides[0]));
-	if (sides[0] < 0) {
-		theta -= 90;
-	} else {
-		theta += 90;
-	}
-	dojo.math.curves.CenteredArc.call(this, center, rad, theta, theta + (ccw ? -180 : 180));
-}, CenteredArc:function (center, radius, start, end) {
-	this.center = center;
-	this.radius = radius;
-	this.start = start || 0;
-	this.end = end;
-	this.getValue = function (n) {
-		var retVal = new Array(2);
-		var theta = dojo.math.degToRad(this.start + ((this.end - this.start) * n));
-		retVal[0] = this.center[0] + this.radius * Math.sin(theta);
-		retVal[1] = this.center[1] - this.radius * Math.cos(theta);
-		return retVal;
-	};
-	return this;
-}, Circle:function (center, radius) {
-	dojo.math.curves.CenteredArc.call(this, center, radius, 0, 360);
-	return this;
-}, Path:function () {
-	var curves = [];
-	var weights = [];
-	var ranges = [];
-	var totalWeight = 0;
-	this.add = function (curve, weight) {
-		if (weight < 0) {
-			dojo.raise("dojo.math.curves.Path.add: weight cannot be less than 0");
+
+		this.removeAll = function() {
+			curves = [];
+			weights = [];
+			totalWeight = 0;
 		}
-		curves.push(curve);
-		weights.push(weight);
-		totalWeight += weight;
-		computeRanges();
-	};
-	this.remove = function (curve) {
-		for (var i = 0; i < curves.length; i++) {
-			if (curves[i] == curve) {
-				curves.splice(i, 1);
-				totalWeight -= weights.splice(i, 1)[0];
-				break;
+
+		this.getValue = function(n) {
+			var found = false, value = 0;
+			for(var i = 0; i < ranges.length; i++) {
+				var r = ranges[i];
+				//w(r.join(" ... "));
+				if( n >= r[0] && n < r[1] ) {
+					var subN = (n - r[0]) / r[2];
+					value = curves[i].getValue(subN);
+					found = true;
+					break;
+				}
 			}
+
+			// FIXME: Do we want to assume we're at the end?
+			if( !found ) {
+				value = curves[curves.length-1].getValue(1);
+			}
+
+			for(var j = 0; j < i; j++) {
+				value = dojo.math.points.translate(value, curves[j].getValue(1));
+			}
+			return value;
 		}
-		computeRanges();
-	};
-	this.removeAll = function () {
-		curves = [];
-		weights = [];
-		totalWeight = 0;
-	};
-	this.getValue = function (n) {
-		var found = false, value = 0;
-		for (var i = 0; i < ranges.length; i++) {
-			var r = ranges[i];
-			if (n >= r[0] && n < r[1]) {
-				var subN = (n - r[0]) / r[2];
-				value = curves[i].getValue(subN);
-				found = true;
-				break;
+
+		function computeRanges() {
+			var start = 0;
+			for(var i = 0; i < weights.length; i++) {
+				var end = start + weights[i] / totalWeight;
+				var len = end - start;
+				ranges[i] = [start, end, len];
+				start = end;
 			}
 		}
-		if (!found) {
-			value = curves[curves.length - 1].getValue(1);
-		}
-		for (var j = 0; j < i; j++) {
-			value = dojo.math.points.translate(value, curves[j].getValue(1));
-		}
-		return value;
-	};
-	function computeRanges() {
-		var start = 0;
-		for (var i = 0; i < weights.length; i++) {
-			var end = start + weights[i] / totalWeight;
-			var len = end - start;
-			ranges[i] = [start, end, len];
-			start = end;
-		}
+
+		return this;
 	}
-	return this;
-}};
-
+};

Modified: tags/parley-0.53/root/static/magic/src/math/matrix.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/math/matrix.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/math/matrix.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,296 +8,298 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.math.matrix");
 
+//
+// some of this code is based on
+// http://www.mkaz.com/math/MatrixCalculator.java
+// (published under a BSD Open Source License)
+//
+// the rest is from my vague memory of matricies in school [cal]
+//
+// the copying of arguments is a little excessive, and could be trimmed back in
+// the case where a function doesn't modify them at all (but some do!)
+//
 
-dojo.provide("dojo.math.matrix");
 dojo.math.matrix.iDF = 0;
-dojo.math.matrix.ALMOST_ZERO = 1e-10;
-dojo.math.matrix.multiply = function (a, b) {
+
+dojo.math.matrix.multiply = function(a, b){
+
+	a = dojo.math.matrix.copy(a);
+	b = dojo.math.matrix.copy(b);
+
+	var ax = a[0].length;
 	var ay = a.length;
-	var ax = a[0].length;
+	var bx = b[0].length;
 	var by = b.length;
-	var bx = b[0].length;
-	if (ax != by) {
-		dojo.debug("Can't multiply matricies of sizes " + ax + "," + ay + " and " + bx + "," + by);
+
+	if (ax != by){
+		dojo.debug("Can't multiply matricies of sizes "+ax+','+ay+' and '+bx+','+by);
 		return [[0]];
 	}
+
 	var c = [];
-	for (var k = 0; k < ay; k++) {
+
+	for(var k=0; k<ay; k++){
 		c[k] = [];
-		for (var i = 0; i < bx; i++) {
+		for(var i=0; i<bx; i++){
+
 			c[k][i] = 0;
-			for (var m = 0; m < ax; m++) {
-				c[k][i] += a[k][m] * b[m][i];
+
+			for(var m=0; m<ax; m++){
+
+				c[k][i] += a[k][m]*b[m][i];
 			}
 		}
 	}
+
 	return c;
-};
-dojo.math.matrix.product = function () {
-	if (arguments.length == 0) {
-		dojo.debug("can't multiply 0 matrices!");
-		return 1;
-	}
-	var result = arguments[0];
-	for (var i = 1; i < arguments.length; i++) {
-		result = dojo.math.matrix.multiply(result, arguments[i]);
-	}
-	return result;
-};
-dojo.math.matrix.sum = function () {
-	if (arguments.length == 0) {
-		dojo.debug("can't sum 0 matrices!");
-		return 0;
-	}
-	var result = dojo.math.matrix.copy(arguments[0]);
-	var rows = result.length;
-	if (rows == 0) {
-		dojo.debug("can't deal with matrices of 0 rows!");
-		return 0;
-	}
-	var cols = result[0].length;
-	if (cols == 0) {
-		dojo.debug("can't deal with matrices of 0 cols!");
-		return 0;
-	}
-	for (var i = 1; i < arguments.length; ++i) {
-		var arg = arguments[i];
-		if (arg.length != rows || arg[0].length != cols) {
-			dojo.debug("can't add matrices of different dimensions: first dimensions were " + rows + "x" + cols + ", current dimensions are " + arg.length + "x" + arg[0].length);
-			return 0;
-		}
-		for (var r = 0; r < rows; r++) {
-			for (var c = 0; c < cols; c++) {
-				result[r][c] += arg[r][c];
-			}
-		}
-	}
-	return result;
-};
-dojo.math.matrix.inverse = function (a) {
-	if (a.length == 1 && a[0].length == 1) {
-		return [[1 / a[0][0]]];
-	}
+}
+
+dojo.math.matrix.inverse = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
+	// Formula used to Calculate Inverse:
+	// inv(A) = 1/det(A) * adj(A)
+
 	var tms = a.length;
+
 	var m = dojo.math.matrix.create(tms, tms);
 	var mm = dojo.math.matrix.adjoint(a);
+
 	var det = dojo.math.matrix.determinant(a);
 	var dd = 0;
-	if (det == 0) {
+
+	if (det == 0){
 		dojo.debug("Determinant Equals 0, Not Invertible.");
 		return [[0]];
-	} else {
+	}else{
 		dd = 1 / det;
 	}
-	for (var i = 0; i < tms; i++) {
+
+	for (var i = 0; i < tms; i++)
 		for (var j = 0; j < tms; j++) {
 			m[i][j] = dd * mm[i][j];
 		}
-	}
+
 	return m;
-};
-dojo.math.matrix.determinant = function (a) {
-	if (a.length != a[0].length) {
+}
+
+dojo.math.matrix.determinant = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
+	if (a.length != a[0].length){
 		dojo.debug("Can't calculate the determiant of a non-squre matrix!");
 		return 0;
 	}
+
 	var tms = a.length;
 	var det = 1;
+
 	var b = dojo.math.matrix.upperTriangle(a);
-	for (var i = 0; i < tms; i++) {
-		var bii = b[i][i];
-		if (Math.abs(bii) < dojo.math.matrix.ALMOST_ZERO) {
-			return 0;
-		}
-		det *= bii;
+
+	for (var i=0; i < tms; i++){
+		det *= b[i][i];
 	}
+
 	det = det * dojo.math.matrix.iDF;
+
 	return det;
-};
-dojo.math.matrix.upperTriangle = function (m) {
+}
+
+dojo.math.matrix.upperTriangle = function(m){
+
 	m = dojo.math.matrix.copy(m);
+
 	var f1 = 0;
 	var temp = 0;
 	var tms = m.length;
 	var v = 1;
+
 	dojo.math.matrix.iDF = 1;
+
 	for (var col = 0; col < tms - 1; col++) {
-		if (typeof m[col][col] != "number") {
-			dojo.debug("non-numeric entry found in a numeric matrix: m[" + col + "][" + col + "]=" + m[col][col]);
-		}
-		v = 1;
-		var stop_loop = 0;
-		while ((m[col][col] == 0) && !stop_loop) {
-			if (col + v >= tms) {
-				dojo.math.matrix.iDF = 0;
-				stop_loop = 1;
-			} else {
-				for (var r = 0; r < tms; r++) {
-					temp = m[col][r];
-					m[col][r] = m[col + v][r];
-					m[col + v][r] = temp;
+		for (var row = col + 1; row < tms; row++) {
+			v = 1;
+
+			var stop_loop = 0;
+
+			// check if 0 in diagonal
+ 			while ((m[col][col] == 0) && !stop_loop){
+
+				// if so switch until not
+				if (col + v >= tms){
+
+					// check if switched all rows
+					dojo.math.matrix.iDF = 0;
+					stop_loop = 1;
+				}else{
+					for (var c = 0; c < tms; c++) {
+						temp = m[col][c];
+						m[col][c] = m[col + v][c]; // switch rows
+						m[col + v][c] = temp;
+					}
+					v++; // count row switchs
+					dojo.math.matrix.iDF *= -1; // each switch changes determinant factor
 				}
-				v++;
-				dojo.math.matrix.iDF *= -1;
 			}
-		}
-		for (var row = col + 1; row < tms; row++) {
-			if (typeof m[row][col] != "number") {
-				dojo.debug("non-numeric entry found in a numeric matrix: m[" + row + "][" + col + "]=" + m[row][col]);
-			}
-			if (typeof m[col][row] != "number") {
-				dojo.debug("non-numeric entry found in a numeric matrix: m[" + col + "][" + row + "]=" + m[col][row]);
-			}
+
 			if (m[col][col] != 0) {
-				var f1 = (-1) * m[row][col] / m[col][col];
+				f1 = (-1) * m[row][col] / m[col][col];
 				for (var i = col; i < tms; i++) {
 					m[row][i] = f1 * m[col][i] + m[row][i];
 				}
 			}
 		}
 	}
+
 	return m;
-};
-dojo.math.matrix.create = function (a, b, value) {
-	if (!value) {
-		value = 0;
-	}
+}
+
+dojo.math.matrix.create = function(a, b){
 	var m = [];
-	for (var i = 0; i < b; i++) {
+	for(var i=0; i<b; i++){
 		m[i] = [];
-		for (var j = 0; j < a; j++) {
-			m[i][j] = value;
+		for(var j=0; j<a; j++){
+			m[i][j] = 0;
 		}
 	}
 	return m;
-};
-dojo.math.matrix.ones = function (a, b) {
-	return dojo.math.matrix.create(a, b, 1);
-};
-dojo.math.matrix.zeros = function (a, b) {
-	return dojo.math.matrix.create(a, b, 0);
-};
-dojo.math.matrix.identity = function (size, scale) {
-	if (!scale) {
-		scale = 1;
-	}
-	var m = [];
-	for (var i = 0; i < size; i++) {
-		m[i] = [];
-		for (var j = 0; j < size; j++) {
-			m[i][j] = (i == j ? scale : 0);
-		}
-	}
-	return m;
-};
-dojo.math.matrix.adjoint = function (a) {
+}
+
+dojo.math.matrix.adjoint = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
 	var tms = a.length;
-	if (tms <= 1) {
-		dojo.debug("Can't find the adjoint of a matrix with a dimension less than 2");
+
+	if (a.length != a[0].length){
+		dojo.debug("Can't find the adjoint of a non-square matrix");
 		return [[0]];
 	}
-	if (a.length != a[0].length) {
-		dojo.debug("Can't find the adjoint of a non-square matrix");
+
+	if (tms == 1){
+		dojo.debug("Can't find the adjoint of a 1x1 matrix");
 		return [[0]];
 	}
+
 	var m = dojo.math.matrix.create(tms, tms);
+
 	var ii = 0;
 	var jj = 0;
 	var ia = 0;
 	var ja = 0;
 	var det = 0;
-	var ap = dojo.math.matrix.create(tms - 1, tms - 1);
-	for (var i = 0; i < tms; i++) {
-		for (var j = 0; j < tms; j++) {
+
+	for (var i = 0; i < tms; i++){
+		for (var j = 0; j < tms; j++){
+
 			ia = 0;
+			ja = 0;
+
+			var ap = dojo.math.matrix.create(tms-1, tms-1);
+
 			for (ii = 0; ii < tms; ii++) {
-				if (ii == i) {
-					continue;
-				}
-				ja = 0;
 				for (jj = 0; jj < tms; jj++) {
-					if (jj == j) {
-						continue;
+
+					if ((ii != i) && (jj != j)) {
+						ap[ia][ja] = a[ii][jj];
+						ja++;
 					}
-					ap[ia][ja] = a[ii][jj];
-					ja++;
+
 				}
-				ia++;
+
+				if ((ii != i) && (jj != j)) {
+					ia++;
+				}
+				ja = 0;
 			}
+
 			det = dojo.math.matrix.determinant(ap);
-			m[i][j] = Math.pow(-1, (i + j)) * det;
+			m[i][j] = Math.pow(-1 , (i + j)) * det;
 		}
 	}
+
 	m = dojo.math.matrix.transpose(m);
+
 	return m;
-};
-dojo.math.matrix.transpose = function (a) {
+}
+
+dojo.math.matrix.transpose = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
 	var m = dojo.math.matrix.create(a.length, a[0].length);
-	for (var i = 0; i < a.length; i++) {
-		for (var j = 0; j < a[i].length; j++) {
+
+	for (var i = 0; i < a.length; i++)
+		for (var j = 0; j < a[i].length; j++)
 			m[j][i] = a[i][j];
-		}
-	}
 	return m;
-};
-dojo.math.matrix.format = function (a, decimal_points) {
-	if (arguments.length <= 1) {
-		decimal_points = 5;
-	}
-	function format_int(x, dp) {
-		var fac = Math.pow(10, dp);
-		var a = Math.round(x * fac) / fac;
+}
+
+dojo.math.matrix.format = function(a){
+
+	function format_int(x){
+		var dp = 5;
+		var fac = Math.pow(10 , dp);
+		var a = Math.round(x*fac)/fac;
 		var b = a.toString();
-		if (b.charAt(0) != "-") {
-			b = " " + b;
-		}
+		if (b.charAt(0) != '-'){ b = ' ' + b;}
 		var has_dp = 0;
-		for (var i = 1; i < b.length; i++) {
-			if (b.charAt(i) == ".") {
-				has_dp = 1;
-			}
+		for(var i=1; i<b.length; i++){
+			if (b.charAt(i) == '.'){ has_dp = 1; }
 		}
-		if (!has_dp) {
-			b += ".";
-		}
-		while (b.length < dp + 3) {
-			b += "0";
-		}
+		if (!has_dp){ b += '.'; }
+		while(b.length < dp+3){ b += '0'; }
 		return b;
 	}
+
 	var ya = a.length;
-	var xa = ya > 0 ? a[0].length : 0;
-	var buffer = "";
-	for (var y = 0; y < ya; y++) {
-		buffer += "| ";
-		for (var x = 0; x < xa; x++) {
-			buffer += format_int(a[y][x], decimal_points) + " ";
+	var xa = a[0].length;
+
+	var buffer = '';
+
+	for (var y=0; y<ya; y++){
+		buffer += '| ';
+		for (var x=0; x<xa; x++){
+			buffer += format_int(a[y][x]) + ' ';
 		}
-		buffer += "|\n";
+		buffer += '|\n';
 	}
+
 	return buffer;
-};
-dojo.math.matrix.copy = function (a) {
+}
+
+dojo.math.matrix.copy = function(a){
+
 	var ya = a.length;
 	var xa = a[0].length;
+
 	var m = dojo.math.matrix.create(xa, ya);
-	for (var y = 0; y < ya; y++) {
-		for (var x = 0; x < xa; x++) {
+
+	for (var y=0; y<ya; y++){
+		for (var x=0; x<xa; x++){
 			m[y][x] = a[y][x];
 		}
 	}
+
 	return m;
-};
-dojo.math.matrix.scale = function (k, a) {
+}
+
+dojo.math.matrix.scale = function(k, a){
+
 	a = dojo.math.matrix.copy(a);
+
 	var ya = a.length;
 	var xa = a[0].length;
-	for (var y = 0; y < ya; y++) {
-		for (var x = 0; x < xa; x++) {
+
+	for (var y=0; y<ya; y++){
+		for (var x=0; x<xa; x++){
 			a[y][x] *= k;
 		}
 	}
+
 	return a;
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/math/points.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/math/points.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/math/points.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,35 +8,40 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.math.points");
+dojo.require("dojo.math");
 
+// TODO: add a Point class?
+dojo.math.points = {
+	translate: function(a, b) {
+		if( a.length != b.length ) {
+			dojo.raise("dojo.math.translate: points not same size (a:[" + a + "], b:[" + b + "])");
+		}
+		var c = new Array(a.length);
+		for(var i = 0; i < a.length; i++) {
+			c[i] = a[i] + b[i];
+		}
+		return c;
+	},
 
-dojo.provide("dojo.math.points");
-dojo.require("dojo.math");
-dojo.math.points = {translate:function (a, b) {
-	if (a.length != b.length) {
-		dojo.raise("dojo.math.translate: points not same size (a:[" + a + "], b:[" + b + "])");
+	midpoint: function(a, b) {
+		if( a.length != b.length ) {
+			dojo.raise("dojo.math.midpoint: points not same size (a:[" + a + "], b:[" + b + "])");
+		}
+		var c = new Array(a.length);
+		for(var i = 0; i < a.length; i++) {
+			c[i] = (a[i] + b[i]) / 2;
+		}
+		return c;
+	},
+
+	invert: function(a) {
+		var b = new Array(a.length);
+		for(var i = 0; i < a.length; i++) { b[i] = -a[i]; }
+		return b;
+	},
+
+	distance: function(a, b) {
+		return Math.sqrt(Math.pow(b[0]-a[0], 2) + Math.pow(b[1]-a[1], 2));
 	}
-	var c = new Array(a.length);
-	for (var i = 0; i < a.length; i++) {
-		c[i] = a[i] + b[i];
-	}
-	return c;
-}, midpoint:function (a, b) {
-	if (a.length != b.length) {
-		dojo.raise("dojo.math.midpoint: points not same size (a:[" + a + "], b:[" + b + "])");
-	}
-	var c = new Array(a.length);
-	for (var i = 0; i < a.length; i++) {
-		c[i] = (a[i] + b[i]) / 2;
-	}
-	return c;
-}, invert:function (a) {
-	var b = new Array(a.length);
-	for (var i = 0; i < a.length; i++) {
-		b[i] = -a[i];
-	}
-	return b;
-}, distance:function (a, b) {
-	return Math.sqrt(Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2));
-}};
-
+};

Modified: tags/parley-0.53/root/static/magic/src/math.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/math.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/math.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,40 +8,40 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.math");
 
+dojo.math.degToRad = function (x) { return (x*Math.PI) / 180; }
+dojo.math.radToDeg = function (x) { return (x*180) / Math.PI; }
 
-dojo.provide("dojo.math");
-dojo.math.degToRad = function (x) {
-	return (x * Math.PI) / 180;
-};
-dojo.math.radToDeg = function (x) {
-	return (x * 180) / Math.PI;
-};
 dojo.math.factorial = function (n) {
-	if (n < 1) {
-		return 0;
-	}
+	if(n<1){ return 0; }
 	var retVal = 1;
-	for (var i = 1; i <= n; i++) {
-		retVal *= i;
-	}
+	for(var i=1;i<=n;i++){ retVal *= i; }
 	return retVal;
-};
-dojo.math.permutations = function (n, k) {
-	if (n == 0 || k == 0) {
-		return 1;
-	}
-	return (dojo.math.factorial(n) / dojo.math.factorial(n - k));
-};
-dojo.math.combinations = function (n, r) {
-	if (n == 0 || r == 0) {
-		return 1;
-	}
-	return (dojo.math.factorial(n) / (dojo.math.factorial(n - r) * dojo.math.factorial(r)));
-};
-dojo.math.bernstein = function (t, n, i) {
-	return (dojo.math.combinations(n, i) * Math.pow(t, i) * Math.pow(1 - t, n - i));
-};
+}
+
+//The number of ways of obtaining an ordered subset of k elements from a set of n elements
+dojo.math.permutations = function (n,k) {
+	if(n==0 || k==0) return 1;
+	return (dojo.math.factorial(n) / dojo.math.factorial(n-k));
+}
+
+//The number of ways of picking n unordered outcomes from r possibilities
+dojo.math.combinations = function (n,r) {
+	if(n==0 || r==0) return 1;
+	return (dojo.math.factorial(n) / (dojo.math.factorial(n-r) * dojo.math.factorial(r)));
+}
+
+dojo.math.bernstein = function (t,n,i) {
+	return (dojo.math.combinations(n,i) * Math.pow(t,i) * Math.pow(1-t,n-i));
+}
+
+/**
+ * Returns random numbers with a Gaussian distribution, with the mean set at
+ * 0 and the variance set at 1.
+ *
+ * @return A random number from a Gaussian distribution
+ */
 dojo.math.gaussianRandom = function () {
 	var k = 2;
 	do {
@@ -51,27 +51,50 @@
 	} while (k >= 1);
 	k = Math.sqrt((-2 * Math.log(k)) / k);
 	return i * k;
-};
+}
+
+/**
+ * Calculates the mean of an Array of numbers.
+ *
+ * @return The mean of the numbers in the Array
+ */
 dojo.math.mean = function () {
 	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
 	var mean = 0;
-	for (var i = 0; i < array.length; i++) {
-		mean += array[i];
-	}
+	for (var i = 0; i < array.length; i++) { mean += array[i]; }
 	return mean / array.length;
-};
+}
+
+/**
+ * Extends Math.round by adding a second argument specifying the number of
+ * decimal places to round to.
+ *
+ * @param number The number to round
+ * @param places The number of decimal places to round to
+ * @return The rounded number
+ */
+// TODO: add support for significant figures
 dojo.math.round = function (number, places) {
-	if (!places) {
-		var shift = 1;
-	} else {
-		var shift = Math.pow(10, places);
-	}
+	if (!places) { var shift = 1; }
+	else { var shift = Math.pow(10, places); }
 	return Math.round(number * shift) / shift;
-};
-dojo.math.sd = dojo.math.standardDeviation = function () {
+}
+
+/**
+ * Calculates the standard deviation of an Array of numbers
+ *
+ * @return The standard deviation of the numbers
+ */
+dojo.math.sd = function () {
 	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
 	return Math.sqrt(dojo.math.variance(array));
-};
+}
+
+/**
+ * Calculates the variance of an Array of numbers
+ *
+ * @return The variance of the numbers
+ */
 dojo.math.variance = function () {
 	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
 	var mean = 0, squares = 0;
@@ -79,30 +102,33 @@
 		mean += array[i];
 		squares += Math.pow(array[i], 2);
 	}
-	return (squares / array.length) - Math.pow(mean / array.length, 2);
-};
-dojo.math.range = function (a, b, step) {
-	if (arguments.length < 2) {
-		b = a;
-		a = 0;
-	}
-	if (arguments.length < 3) {
-		step = 1;
-	}
-	var range = [];
-	if (step > 0) {
-		for (var i = a; i < b; i += step) {
-			range.push(i);
-		}
-	} else {
-		if (step < 0) {
-			for (var i = a; i > b; i += step) {
-				range.push(i);
-			}
-		} else {
-			throw new Error("dojo.math.range: step must be non-zero");
-		}
-	}
-	return range;
-};
+	return (squares / array.length)
+		- Math.pow(mean / array.length, 2);
+}
 
+/**
+ * Like range() in python
+**/
+dojo.math.range = function(a, b, step) {
+    if(arguments.length < 2) {
+        b = a;
+        a = 0;
+    }
+    if(arguments.length < 3) {
+        step = 1;
+    }
+
+    var range = [];
+    if(step > 0) {
+        for(var i = a; i < b; i += step) {
+            range.push(i);
+        }
+    } else if(step < 0) {
+        for(var i = a; i > b; i += step) {
+            range.push(i);
+        }
+    } else {
+        throw new Error("dojo.math.range: step must be non-zero");
+    }
+    return range;
+}

Deleted: tags/parley-0.53/root/static/magic/src/ns.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/ns.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/ns.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,100 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.ns");
-dojo.ns = {namespaces:{}, failed:{}, loading:{}, loaded:{}, register:function (name, module, resolver, noOverride) {
-	if (!noOverride || !this.namespaces[name]) {
-		this.namespaces[name] = new dojo.ns.Ns(name, module, resolver);
-	}
-}, allow:function (name) {
-	if (this.failed[name]) {
-		return false;
-	}
-	if ((djConfig.excludeNamespace) && (dojo.lang.inArray(djConfig.excludeNamespace, name))) {
-		return false;
-	}
-	return ((name == this.dojo) || (!djConfig.includeNamespace) || (dojo.lang.inArray(djConfig.includeNamespace, name)));
-}, get:function (name) {
-	return this.namespaces[name];
-}, require:function (name) {
-	var ns = this.namespaces[name];
-	if ((ns) && (this.loaded[name])) {
-		return ns;
-	}
-	if (!this.allow(name)) {
-		return false;
-	}
-	if (this.loading[name]) {
-		dojo.debug("dojo.namespace.require: re-entrant request to load namespace \"" + name + "\" must fail.");
-		return false;
-	}
-	var req = dojo.require;
-	this.loading[name] = true;
-	try {
-		if (name == "dojo") {
-			req("dojo.namespaces.dojo");
-		} else {
-			if (!dojo.hostenv.moduleHasPrefix(name)) {
-				dojo.registerModulePath(name, "../" + name);
-			}
-			req([name, "manifest"].join("."), false, true);
-		}
-		if (!this.namespaces[name]) {
-			this.failed[name] = true;
-		}
-	}
-	finally {
-		this.loading[name] = false;
-	}
-	return this.namespaces[name];
-}};
-dojo.ns.Ns = function (name, module, resolver) {
-	this.name = name;
-	this.module = module;
-	this.resolver = resolver;
-	this._loaded = [];
-	this._failed = [];
-};
-dojo.ns.Ns.prototype.resolve = function (name, domain, omitModuleCheck) {
-	if (!this.resolver || djConfig["skipAutoRequire"]) {
-		return false;
-	}
-	var fullName = this.resolver(name, domain);
-	if ((fullName) && (!this._loaded[fullName]) && (!this._failed[fullName])) {
-		var req = dojo.require;
-		req(fullName, false, true);
-		if (dojo.hostenv.findModule(fullName, false)) {
-			this._loaded[fullName] = true;
-		} else {
-			if (!omitModuleCheck) {
-				dojo.raise("dojo.ns.Ns.resolve: module '" + fullName + "' not found after loading via namespace '" + this.name + "'");
-			}
-			this._failed[fullName] = true;
-		}
-	}
-	return Boolean(this._loaded[fullName]);
-};
-dojo.registerNamespace = function (name, module, resolver) {
-	dojo.ns.register.apply(dojo.ns, arguments);
-};
-dojo.registerNamespaceResolver = function (name, resolver) {
-	var n = dojo.ns.namespaces[name];
-	if (n) {
-		n.resolver = resolver;
-	}
-};
-dojo.registerNamespaceManifest = function (module, path, name, widgetModule, resolver) {
-	dojo.registerModulePath(name, path);
-	dojo.registerNamespace(name, widgetModule, resolver);
-};
-dojo.registerNamespace("dojo", "dojo.widget");
-

Modified: tags/parley-0.53/root/static/magic/src/profile.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/profile.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/profile.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,97 +8,110 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.profile");
 
+dojo.profile = new function(){
+	var profiles = {};
+	var pns = [];
 
-dojo.provide("dojo.profile");
-dojo.profile = {_profiles:{}, _pns:[], start:function (name) {
-	if (!this._profiles[name]) {
-		this._profiles[name] = {iters:0, total:0};
-		this._pns[this._pns.length] = name;
-	} else {
-		if (this._profiles[name]["start"]) {
-			this.end(name);
+	this.start = function(name){
+		if(!profiles[name]){
+			profiles[name] = {iters: 0, total: 0};
+			pns[pns.length] = name;
+		}else{
+			if(profiles[name]["start"]){
+				this.end(name);
+			}
 		}
+		profiles[name].end = null;
+		profiles[name].start = new Date();
 	}
-	this._profiles[name].end = null;
-	this._profiles[name].start = new Date();
-}, end:function (name) {
-	var ed = new Date();
-	if ((this._profiles[name]) && (this._profiles[name]["start"])) {
-		with (this._profiles[name]) {
-			end = ed;
-			total += (end - start);
-			start = null;
-			iters++;
+
+	this.end = function(name){
+		var ed = new Date();
+		if((profiles[name])&&(profiles[name]["start"])){
+			with(profiles[name]){
+				end = ed;
+				total += (end - start);
+				start = null;
+				iters++;
+			}
+		}else{
+			// oops! bad call to end(), what should we do here?
+			return true;
 		}
-	} else {
-		return true;
 	}
-}, dump:function (appendToDoc) {
-	var tbl = document.createElement("table");
-	with (tbl.style) {
-		border = "1px solid black";
-		borderCollapse = "collapse";
-	}
-	var hdr = tbl.createTHead();
-	var hdrtr = hdr.insertRow(0);
-	var cols = ["Identifier", "Calls", "Total", "Avg"];
-	for (var x = 0; x < cols.length; x++) {
-		var ntd = hdrtr.insertCell(x);
-		with (ntd.style) {
-			backgroundColor = "#225d94";
-			color = "white";
-			borderBottom = "1px solid black";
-			borderRight = "1px solid black";
-			fontFamily = "tahoma";
-			fontWeight = "bolder";
-			paddingLeft = paddingRight = "5px";
+
+	this.stop = this.end;
+
+	this.dump = function(appendToDoc){
+		var tbl = document.createElement("table");
+		with(tbl.style){
+			border = "1px solid black";
+			borderCollapse = "collapse";
 		}
-		ntd.appendChild(document.createTextNode(cols[x]));
-	}
-	for (var x = 0; x < this._pns.length; x++) {
-		var prf = this._profiles[this._pns[x]];
-		this.end(this._pns[x]);
-		if (prf.iters > 0) {
-			var bdytr = tbl.insertRow(true);
-			var vals = [this._pns[x], prf.iters, prf.total, parseInt(prf.total / prf.iters)];
-			for (var y = 0; y < vals.length; y++) {
-				var cc = bdytr.insertCell(y);
-				cc.appendChild(document.createTextNode(vals[y]));
-				with (cc.style) {
-					borderBottom = "1px solid gray";
-					paddingLeft = paddingRight = "5px";
-					if (x % 2) {
-						backgroundColor = "#e1f1ff";
+		var hdr = tbl.createTHead();
+		var hdrtr = hdr.insertRow(0);
+		// document.createElement("tr");
+		var cols = ["Identifier","Calls","Total","Avg"];
+		for(var x=0; x<cols.length; x++){
+			var ntd = hdrtr.insertCell(x);
+			with(ntd.style){
+				backgroundColor = "#225d94";
+				color = "white";
+				borderBottom = "1px solid black";
+				borderRight = "1px solid black";
+				fontFamily = "tahoma";
+				fontWeight = "bolder";
+				paddingLeft = paddingRight = "5px";
+			}
+			ntd.appendChild(document.createTextNode(cols[x]));
+		}
+
+		for(var x=0; x < pns.length; x++){
+			var prf = profiles[pns[x]];
+			this.end(pns[x]);
+			if(prf.iters>0){
+				var bdytr = tbl.insertRow(true);
+				var vals = [pns[x], prf.iters, prf.total, parseInt(prf.total/prf.iters)];
+				for(var y=0; y<vals.length; y++){
+					var cc = bdytr.insertCell(y);
+					cc.appendChild(document.createTextNode(vals[y]));
+					with(cc.style){
+						borderBottom = "1px solid gray";
+						paddingLeft = paddingRight = "5px";
+						if(x%2){
+							backgroundColor = "#e1f1ff";
+						}
+						if(y>0){
+							textAlign = "right";
+							borderRight = "1px solid gray";
+						}else{
+							borderRight = "1px solid black";
+						}
 					}
-					if (y > 0) {
-						textAlign = "right";
-						borderRight = "1px solid gray";
-					} else {
-						borderRight = "1px solid black";
-					}
 				}
 			}
 		}
-	}
-	if (appendToDoc) {
-		var ne = document.createElement("div");
-		ne.id = "profileOutputTable";
-		with (ne.style) {
-			fontFamily = "Courier New, monospace";
-			fontSize = "12px";
-			lineHeight = "16px";
-			borderTop = "1px solid black";
-			padding = "10px";
+
+		if(appendToDoc){
+			var ne = document.createElement("div");
+			ne.id = "profileOutputTable";
+			with(ne.style){
+				fontFamily = "Courier New, monospace";
+				fontSize = "12px";
+				lineHeight = "16px";
+				borderTop = "1px solid black";
+				padding = "10px";
+			}
+			if(document.getElementById("profileOutputTable")){
+				document.body.replaceChild(ne, document.getElementById("profileOutputTable"));
+			}else{
+				document.body.appendChild(ne);
+			}
+			ne.appendChild(tbl);
 		}
-		if (document.getElementById("profileOutputTable")) {
-			dojo.body().replaceChild(ne, document.getElementById("profileOutputTable"));
-		} else {
-			dojo.body().appendChild(ne);
-		}
-		ne.appendChild(tbl);
+
+		return tbl;
 	}
-	return tbl;
-}};
-dojo.profile.stop = dojo.profile.end;
-
+}

Added: tags/parley-0.53/root/static/magic/src/reflect/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/reflect/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/reflect/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.deprecated("dojo.reflect", "merged into dojo.lang (dojo.lang[type]).", "0.4");
+dojo.kwCompoundRequire({
+	common: ["dojo.reflect.reflection"]
+});
+dojo.provide("dojo.reflect.*");

Added: tags/parley-0.53/root/static/magic/src/reflect/reflection.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/reflect/reflection.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/reflect/reflection.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,198 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.deprecated("dojo.reflect", "merged into dojo.lang (dojo.lang[type])", "0.4");
+dojo.provide("dojo.reflect");
+
+/*****************************************************************
+	reflect.js
+	v.1.5.0
+	(c) 2003-2004 Thomas R. Trenka, Ph.D.
+
+	Derived from the reflection functions of f(m).
+	http://dojotoolkit.org
+	http://fm.dept-z.com
+
+	There is a dependency on the variable dJ_global, which
+	should always refer to the global object.
+******************************************************************/
+if(!dj_global){ var dj_global = this; }
+
+dojo.reflect = {} ;
+dojo.reflect.$unknownType = function(){ } ;
+dojo.reflect.ParameterInfo = function(name, type){ 
+	this.name = name ;
+	this.type = (type) ? type : dojo.reflect.$unknownType ;
+} ;
+dojo.reflect.PropertyInfo = function(name, type) { 
+	this.name = name ;
+	this.type = (type) ? type : dojo.reflect.$unknownType ;
+} ;
+dojo.reflect.MethodInfo = function(name, fn){
+	var parse = function(f) {
+		var o = {} ; 
+		var s = f.toString() ;
+		var param = ((s.substring(s.indexOf('(')+1, s.indexOf(')'))).replace(/\s+/g, "")).split(",") ;
+		o.parameters = [] ;
+		for (var i = 0; i < param.length; i++) {
+			o.parameters.push(new dojo.reflect.ParameterInfo(param[i])) ;
+		}
+		o.body = (s.substring(s.indexOf('{')+1, s.lastIndexOf('}'))).replace(/(^\s*)|(\s*$)/g, "") ;
+		return o ;
+	} ;
+
+	var tmp = parse(fn) ;
+	var p = tmp.parameters ;
+	var body = tmp.body ;
+	
+	this.name = (name) ? name : "anonymous" ;
+	this.getParameters = function(){ return p ; } ;
+	this.getNullArgumentsObject = function() {
+		var a = [] ;
+		for (var i = 0; i < p.length; i++){
+			a.push(null);
+		}
+		return a ;
+	} ;
+	this.getBody = function() { return body ; } ;
+	this.type = Function ;
+	this.invoke = function(src, args){ return fn.apply(src, args) ; } ;
+} ;
+
+//	Static object that can activate instances of the passed type.
+dojo.reflect.Activator = new (function(){
+	this.createInstance = function(type, args) {
+		switch (typeof(type)) {
+			case "function" : { 
+				var o = {} ;
+				type.apply(o, args) ;
+				return o ;
+			} ;
+			case "string" : {
+				var o = {} ;
+				(dojo.reflect.Reflector.getTypeFromString(type)).apply(o, args) ;
+				return o ;
+			} ;
+		}
+		throw new Error("dojo.reflect.Activator.createInstance(): no such type exists.");
+	}
+})() ;
+
+dojo.reflect.Reflector = new (function(){
+	this.getTypeFromString = function(s) {
+		var parts = s.split("."), i = 0, obj = dj_global ; 
+		do { obj = obj[parts[i++]] ; } while (i < parts.length && obj) ; 
+		return (obj != dj_global) ? obj : null ;
+	}; 
+
+	this.typeExists = function(s) {
+		var parts = s.split("."), i = 0, obj = dj_global ; 
+		do { obj = obj[parts[i++]] ; } while (i < parts.length && obj) ; 
+		return (obj && obj != dj_global) ;
+	}; 
+
+	this.getFieldsFromType = function(s) { 
+		var type = s ;
+		if (typeof(s) == "string") {
+			type = this.getTypeFromString(s) ;
+		}
+		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
+		return this.getFields(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
+	};
+
+	this.getPropertiesFromType = function(s) { 
+		var type = s ;
+		if (typeof(s) == "string") {
+			type = this.getTypeFromString(s);
+		}
+		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
+		return this.getProperties(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
+	};
+
+	this.getMethodsFromType = function(s) { 
+		var type = s ;
+		if (typeof(s) == "string") {
+			type = this.getTypeFromString(s) ;
+		}
+		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
+		return this.getMethods(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
+	};
+
+	this.getType = function(o) { return o.constructor ; } ;
+
+	this.getFields = function(obj) {
+		var arr = [] ;
+		for (var p in obj) { 
+			if(this.getType(obj[p]) != Function){
+				arr.push(new dojo.reflect.PropertyInfo(p, this.getType(obj[p]))) ;
+			}else{
+				arr.push(new dojo.reflect.MethodInfo(p, obj[p]));
+			}
+		}
+		return arr ;
+	};
+
+	this.getProperties = function(obj) {
+		var arr = [] ;
+		var fi = this.getFields(obj) ;
+		for (var i = 0; i < fi.length; i++){
+			if (this.isInstanceOf(fi[i], dojo.reflect.PropertyInfo)){
+				arr.push(fi[i]) ;
+			}
+		}
+		return arr ;
+	};
+
+	this.getMethods = function(obj) {
+		var arr = [] ;
+		var fi = this.getFields(obj) ;
+		for (var i = 0; i < fi.length; i++){
+			if (this.isInstanceOf(fi[i], dojo.reflect.MethodInfo)){
+				arr.push(fi[i]) ;
+			}
+		}
+		return arr ;
+	};
+
+	/*
+	this.implements = function(o, type) {
+		if (this.isSubTypeOf(o, type)) return false ;
+		var f = this.getFieldsFromType(type) ;
+		for (var i = 0; i < f.length; i++) {
+			if (typeof(o[(f[i].name)]) == "undefined"){
+				return false;
+			}
+		}
+		return true ;
+	};
+	*/
+
+	this.getBaseClass = function(o) {
+		if (o.getType().prototype.prototype.constructor){
+			return (o.getType()).prototype.prototype.constructor ;
+		}
+		return Object ;
+	} ;
+
+	this.isInstanceOf = function(o, type) { 
+		return (this.getType(o) == type) ; 
+	};
+
+	this.isSubTypeOf = function(o, type) { 
+		return (o instanceof type) ; 
+	};
+
+	this.isBaseTypeOf = function(o, type) { 
+		return (type instanceof o); 
+	};
+})();
+
+// back-compat
+dojo.provide("dojo.reflect.reflection");

Modified: tags/parley-0.53/root/static/magic/src/regexp.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/regexp.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/regexp.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,324 +8,474 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.regexp");
+dojo.provide("dojo.regexp.us");
 
+// *** Regular Expression Generators ***
 
-dojo.provide("dojo.regexp");
-dojo.evalObjPath("dojo.regexp.us", true);
-dojo.regexp.tld = function (flags) {
+/**
+  Builds a RE that matches a top-level domain.
+
+  @param flags  An object.
+    flags.allowCC  Include 2 letter country code domains.  Default is true.
+    flags.allowGeneric  Include the generic domains.  Default is true.
+    flags.allowInfra  Include infrastructure domains.  Default is true.
+
+  @return  A string for a regular expression for a top-level domain.
+*/
+dojo.regexp.tld = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.allowCC != "boolean") {
-		flags.allowCC = true;
-	}
-	if (typeof flags.allowInfra != "boolean") {
-		flags.allowInfra = true;
-	}
-	if (typeof flags.allowGeneric != "boolean") {
-		flags.allowGeneric = true;
-	}
+	if (typeof flags.allowCC != "boolean") { flags.allowCC = true; }
+	if (typeof flags.allowInfra != "boolean") { flags.allowInfra = true; }
+	if (typeof flags.allowGeneric != "boolean") { flags.allowGeneric = true; }
+
+	// Infrastructure top-level domain - only one at present
 	var infraRE = "arpa";
-	var genericRE = "aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|xxx|jobs|mobi|post";
-	var ccRE = "ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|" + "bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|" + "ec|ee|eg|er|eu|es|et|fi|fj|fk|fm|fo|fr|ga|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|" + "gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kr|kw|ky|kz|" + "la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|" + "my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|" + "re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sk|sl|sm|sn|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|" + "tn|to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw";
+
+	// Generic top-level domains RE.
+	var genericRE = 
+		"aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|xxx|jobs|mobi|post";
+	
+	// Country Code top-level domains RE
+	var ccRE = 
+		"ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|" +
+		"bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|" +
+		"ec|ee|eg|er|es|et|fi|fj|fk|fm|fo|fr|ga|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|" +
+		"hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kr|kw|ky|kz|la|" +
+		"lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|" +
+		"mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|" +
+		"ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sk|sl|sm|sn|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|" +
+		"to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw";
+
+	// Build top-level domain RE
 	var a = [];
-	if (flags.allowInfra) {
-		a.push(infraRE);
-	}
-	if (flags.allowGeneric) {
-		a.push(genericRE);
-	}
-	if (flags.allowCC) {
-		a.push(ccRE);
-	}
+	if (flags.allowInfra) { a.push(infraRE); }
+	if (flags.allowGeneric) { a.push(genericRE); }
+	if (flags.allowCC) { a.push(ccRE); }
+
 	var tldRE = "";
 	if (a.length > 0) {
 		tldRE = "(" + a.join("|") + ")";
 	}
+
 	return tldRE;
-};
-dojo.regexp.ipAddress = function (flags) {
+}
+
+/**
+  Builds a RE that matches an IP Address.
+  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
+  Supports 2 formats for Ipv6.
+
+  @param flags  An object.  All flags are boolean with default = true.
+    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
+    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
+    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
+    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
+    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
+      Case insensitive.  Zero padding allowed.
+    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
+    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
+      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d
+
+  @return  A string for a regular expression for an IP address.
+*/
+dojo.regexp.ipAddress = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.allowDottedDecimal != "boolean") {
-		flags.allowDottedDecimal = true;
-	}
-	if (typeof flags.allowDottedHex != "boolean") {
-		flags.allowDottedHex = true;
-	}
-	if (typeof flags.allowDottedOctal != "boolean") {
-		flags.allowDottedOctal = true;
-	}
-	if (typeof flags.allowDecimal != "boolean") {
-		flags.allowDecimal = true;
-	}
-	if (typeof flags.allowHex != "boolean") {
-		flags.allowHex = true;
-	}
-	if (typeof flags.allowIPv6 != "boolean") {
-		flags.allowIPv6 = true;
-	}
-	if (typeof flags.allowHybrid != "boolean") {
-		flags.allowHybrid = true;
-	}
-	var dottedDecimalRE = "((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
+	if (typeof flags.allowDottedDecimal != "boolean") { flags.allowDottedDecimal = true; }
+	if (typeof flags.allowDottedHex != "boolean") { flags.allowDottedHex = true; }
+	if (typeof flags.allowDottedOctal != "boolean") { flags.allowDottedOctal = true; }
+	if (typeof flags.allowDecimal != "boolean") { flags.allowDecimal = true; }
+	if (typeof flags.allowHex != "boolean") { flags.allowHex = true; }
+	if (typeof flags.allowIPv6 != "boolean") { flags.allowIPv6 = true; }
+	if (typeof flags.allowHybrid != "boolean") { flags.allowHybrid = true; }
+
+	// decimal-dotted IP address RE.
+	var dottedDecimalRE = 
+		// Each number is between 0-255.  Zero padding is not allowed.
+		"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
+
+	// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
 	var dottedHexRE = "(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]";
+
+	// dotted octal IP address RE.  Each number is between 0000-0377.  
+	// Zero padding is allowed, but each number must have at least 4 characters.
 	var dottedOctalRE = "(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]";
-	var decimalRE = "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" + "4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";
+
+	// decimal IP address RE.  A decimal number between 0-4294967295.  
+	var decimalRE =  "(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|" +
+		"4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])";
+
+	// hexadecimal IP address RE. 
+	// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
 	var hexRE = "0[xX]0*[\\da-fA-F]{1,8}";
+
+	// IPv6 address RE. 
+	// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
+	// where x is between 0000-ffff. Zero padding is optional. Case insensitive. 
 	var ipv6RE = "([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}";
-	var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" + "((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
+
+	// IPv6/IPv4 Hybrid address RE. 
+	// The format is written as six groups of four hexadecimal digits, 
+	// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
+	var hybridRE = "([\\da-fA-F]{1,4}\\:){6}" + 
+		"((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])";
+
+	// Build IP Address RE
 	var a = [];
-	if (flags.allowDottedDecimal) {
-		a.push(dottedDecimalRE);
-	}
-	if (flags.allowDottedHex) {
-		a.push(dottedHexRE);
-	}
-	if (flags.allowDottedOctal) {
-		a.push(dottedOctalRE);
-	}
-	if (flags.allowDecimal) {
-		a.push(decimalRE);
-	}
-	if (flags.allowHex) {
-		a.push(hexRE);
-	}
-	if (flags.allowIPv6) {
-		a.push(ipv6RE);
-	}
-	if (flags.allowHybrid) {
-		a.push(hybridRE);
-	}
+	if (flags.allowDottedDecimal) { a.push(dottedDecimalRE); }
+	if (flags.allowDottedHex) { a.push(dottedHexRE); }
+	if (flags.allowDottedOctal) { a.push(dottedOctalRE); }
+	if (flags.allowDecimal) { a.push(decimalRE); }
+	if (flags.allowHex) { a.push(hexRE); }
+	if (flags.allowIPv6) { a.push(ipv6RE); }
+	if (flags.allowHybrid) { a.push(hybridRE); }
+
 	var ipAddressRE = "";
 	if (a.length > 0) {
 		ipAddressRE = "(" + a.join("|") + ")";
 	}
+
 	return ipAddressRE;
-};
-dojo.regexp.host = function (flags) {
+}
+
+/**
+  Builds a RE that matches a host.
+	A host is a domain name or an IP address, possibly followed by a port number.
+
+  @param flags  An object.
+    flags.allowIP  Allow an IP address for hostname.  Default is true.
+    flags.allowLocal  Allow the host to be "localhost".  Default is false.
+    flags.allowPort  Allow a port number to be present.  Default is true.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for a host.
+*/
+dojo.regexp.host = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.allowIP != "boolean") {
-		flags.allowIP = true;
-	}
-	if (typeof flags.allowLocal != "boolean") {
-		flags.allowLocal = false;
-	}
-	if (typeof flags.allowPort != "boolean") {
-		flags.allowPort = true;
-	}
+	if (typeof flags.allowIP != "boolean") { flags.allowIP = true; }
+	if (typeof flags.allowLocal != "boolean") { flags.allowLocal = false; }
+	if (typeof flags.allowPort != "boolean") { flags.allowPort = true; }
+
+	// Domain names can not end with a dash.
 	var domainNameRE = "([0-9a-zA-Z]([-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?\\.)+" + dojo.regexp.tld(flags);
-	var portRE = (flags.allowPort) ? "(\\:" + dojo.regexp.integer({signed:false}) + ")?" : "";
+
+	// port number RE
+	var portRE = ( flags.allowPort ) ? "(\\:" + dojo.regexp.integer({signed: false}) + ")?" : "";
+
+	// build host RE
 	var hostNameRE = domainNameRE;
-	if (flags.allowIP) {
-		hostNameRE += "|" + dojo.regexp.ipAddress(flags);
-	}
-	if (flags.allowLocal) {
-		hostNameRE += "|localhost";
-	}
+	if (flags.allowIP) { hostNameRE += "|" +  dojo.regexp.ipAddress(flags); }
+	if (flags.allowLocal) { hostNameRE += "|localhost"; }
+
 	return "(" + hostNameRE + ")" + portRE;
-};
-dojo.regexp.url = function (flags) {
+}
+
+/**
+  Builds a regular expression that matches a URL.
+
+  @param flags  An object.
+    flags.scheme  Can be true, false, or [true, false]. 
+      This means: required, not allowed, or match either one.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for a URL.
+*/
+dojo.regexp.url = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.scheme == "undefined") {
-		flags.scheme = [true, false];
-	}
-	var protocolRE = dojo.regexp.buildGroupRE(flags.scheme, function (q) {
-		if (q) {
-			return "(https?|ftps?)\\://";
-		}
-		return "";
-	});
+	if (typeof flags.scheme == "undefined") { flags.scheme = [true, false]; }
+
+	// Scheme RE
+	var protocalRE = dojo.regexp.buildGroupRE(flags.scheme,
+		function(q) { if (q) { return "(https?|ftps?)\\://"; }  return ""; }
+	);
+
+	// Path and query and anchor RE
 	var pathRE = "(/([^?#\\s/]+/)*)?([^?#\\s/]+(\\?[^?#\\s/]*)?(#[A-Za-z][\\w.:-]*)?)?";
-	return protocolRE + dojo.regexp.host(flags) + pathRE;
-};
-dojo.regexp.emailAddress = function (flags) {
+
+	return (protocalRE + dojo.regexp.host(flags) + pathRE);
+}
+
+/**
+  Builds a regular expression that matches an email address.
+
+  @param flags  An object.
+    flags.allowCruft  Allow address like <mailto:foo at yahoo.com>.  Default is false.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for an email address.
+*/
+dojo.regexp.emailAddress = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.allowCruft != "boolean") {
-		flags.allowCruft = false;
-	}
-	flags.allowPort = false;
+	if (typeof flags.allowCruft != "boolean") { flags.allowCruft = false; }
+	flags.allowPort = false; // invalid in email addresses
+
+	// user name RE - apostrophes are valid if there's not 2 in a row
 	var usernameRE = "([\\da-z]+[-._+&'])*[\\da-z]+";
+
+	// build emailAddress RE
 	var emailAddressRE = usernameRE + "@" + dojo.regexp.host(flags);
-	if (flags.allowCruft) {
+
+	// Allow email addresses with cruft
+	if ( flags.allowCruft ) {
 		emailAddressRE = "<?(mailto\\:)?" + emailAddressRE + ">?";
 	}
+
 	return emailAddressRE;
-};
-dojo.regexp.emailAddressList = function (flags) {
+}
+
+/**
+  Builds a regular expression that matches a list of email addresses.
+
+  @param flags  An object.
+    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
+    flags in regexp.emailAddress can be applied.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for an email address list.
+*/
+dojo.regexp.emailAddressList = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.listSeparator != "string") {
-		flags.listSeparator = "\\s;,";
-	}
+	if (typeof flags.listSeparator != "string") { flags.listSeparator = "\\s;,"; }
+
+	// build a RE for an Email Address List
 	var emailAddressRE = dojo.regexp.emailAddress(flags);
-	var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" + emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";
+	var emailAddressListRE = "(" + emailAddressRE + "\\s*[" + flags.listSeparator + "]\\s*)*" + 
+		emailAddressRE + "\\s*[" + flags.listSeparator + "]?\\s*";
+
 	return emailAddressListRE;
-};
-dojo.regexp.integer = function (flags) {
+}
+
+/**
+  Builds a regular expression that matches an integer.
+
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if it is signed or unsigned).
+    flags.separator  The character used as the thousands separator.  Default is no separator.
+      For more than one symbol use an array, e.g. [",", ""], makes ',' optional.
+
+  @return  A string for a regular expression for an integer.
+*/
+dojo.regexp.integer = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.signed == "undefined") {
-		flags.signed = [true, false];
-	}
-	if (typeof flags.separator == "undefined") {
-		flags.separator = "";
-	} else {
-		if (typeof flags.groupSize == "undefined") {
-			flags.groupSize = 3;
+	if (typeof flags.signed == "undefined") { flags.signed = [true, false]; }
+	if (typeof flags.separator == "undefined") { flags.separator = ""; }
+
+	// build sign RE
+	var signRE = dojo.regexp.buildGroupRE(flags.signed,
+		function(q) { if (q) { return "[-+]"; }  return ""; }
+	);
+
+	// number RE
+	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
+		function(sep) { 
+			if ( sep == "" ) { 
+				return "(0|[1-9]\\d*)"; 
+			}
+			return "(0|[1-9]\\d{0,2}([" + sep + "]\\d{3})*)"; 
 		}
-	}
-	var signRE = dojo.regexp.buildGroupRE(flags.signed, function (q) {
-		return q ? "[-+]" : "";
-	});
-	var numberRE = dojo.regexp.buildGroupRE(flags.separator, function (sep) {
-		if (sep == "") {
-			return "(0|[1-9]\\d*)";
-		}
-		var grp = flags.groupSize, grp2 = flags.groupSize2;
-		if (typeof grp2 != "undefined") {
-			var grp2RE = "(0|[1-9]\\d{0," + (grp2 - 1) + "}([" + sep + "]\\d{" + grp2 + "})*[" + sep + "]\\d{" + grp + "})";
-			return ((grp - grp2) > 0) ? "(" + grp2RE + "|(0|[1-9]\\d{0," + (grp - 1) + "}))" : grp2RE;
-		}
-		return "(0|[1-9]\\d{0," + (grp - 1) + "}([" + sep + "]\\d{" + grp + "})*)";
-	});
-	return signRE + numberRE;
-};
-dojo.regexp.realNumber = function (flags) {
+	);
+	var numberRE;
+
+	// integer RE
+	return (signRE + numberRE);
+}
+
+/**
+  Builds a regular expression to match a real number in exponential notation.
+
+  @param flags  An object.
+    flags.places  The integer number of decimal places.
+      If not given, the decimal part is optional and the number of places is unlimited.
+    flags.decimal  A string for the character used as the decimal point.  Default is ".".
+    flags.exponent  Express in exponential notation.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if the exponential part is present are not).
+    flags.eSigned  The leading plus-or-minus sign on the exponent.  Can be true, false, 
+      or [true, false].  Default is [true, false], (i.e. will match if it is signed or unsigned).
+    flags in regexp.integer can be applied.
+
+  @return  A string for a regular expression for a real number.
+*/
+dojo.regexp.realNumber = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.places != "number") {
-		flags.places = Infinity;
+	if (typeof flags.places != "number") { flags.places = Infinity; }
+	if (typeof flags.decimal != "string") { flags.decimal = "."; }
+	if (typeof flags.exponent == "undefined") { flags.exponent = [true, false]; }
+	if (typeof flags.eSigned == "undefined") { flags.eSigned = [true, false]; }
+
+	// integer RE
+	var integerRE = dojo.regexp.integer(flags);
+
+	// decimal RE
+	var decimalRE = "";
+	if ( flags.places == Infinity) { 
+		decimalRE = "(\\" + flags.decimal + "\\d+)?"; 
 	}
-	if (typeof flags.decimal != "string") {
-		flags.decimal = ".";
+	else if ( flags.places > 0) { 
+		decimalRE = "\\" + flags.decimal + "\\d{" + flags.places + "}"; 
 	}
-	if (typeof flags.fractional == "undefined") {
-		flags.fractional = [true, false];
-	}
-	if (typeof flags.exponent == "undefined") {
-		flags.exponent = [true, false];
-	}
-	if (typeof flags.eSigned == "undefined") {
-		flags.eSigned = [true, false];
-	}
-	var integerRE = dojo.regexp.integer(flags);
-	var decimalRE = dojo.regexp.buildGroupRE(flags.fractional, function (q) {
-		var re = "";
-		if (q && (flags.places > 0)) {
-			re = "\\" + flags.decimal;
-			if (flags.places == Infinity) {
-				re = "(" + re + "\\d+)?";
-			} else {
-				re = re + "\\d{" + flags.places + "}";
-			}
+
+	// exponent RE
+	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
+		function(q) { 
+			if (q) { return "([eE]" + dojo.regexp.integer({signed: flags.eSigned}) + ")"; }
+			return ""; 
 		}
-		return re;
-	});
-	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent, function (q) {
-		if (q) {
-			return "([eE]" + dojo.regexp.integer({signed:flags.eSigned}) + ")";
-		}
-		return "";
-	});
-	return integerRE + decimalRE + exponentRE;
-};
-dojo.regexp.currency = function (flags) {
+	);
+
+	// real number RE
+	return (integerRE + decimalRE + exponentRE);
+}
+
+/**
+  Builds a regular expression to match a monetary value.
+
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if it is signed or unsigned).
+    flags.symbol  A currency symbol such as Yen "?", Pound "?", or the Euro sign "?".  
+      Default is "$".  For more than one symbol use an array, e.g. ["$", ""], makes $ optional.
+    flags.placement  The symbol can come "before" the number or "after".  Default is "before".
+    flags.separator  The character used as the thousands separator. The default is ",".
+    flags.cents  The two decimal places for cents.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if cents are present are not).
+    flags.decimal  A string for the character used as the decimal point.  Default is ".".
+
+  @return  A string for a regular expression for a monetary value.
+*/
+dojo.regexp.currency = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.signed == "undefined") {
-		flags.signed = [true, false];
-	}
-	if (typeof flags.symbol == "undefined") {
-		flags.symbol = "$";
-	}
-	if (typeof flags.placement != "string") {
-		flags.placement = "before";
-	}
-	if (typeof flags.signPlacement != "string") {
-		flags.signPlacement = "before";
-	}
-	if (typeof flags.separator == "undefined") {
-		flags.separator = ",";
-	}
-	if (typeof flags.fractional == "undefined" && typeof flags.cents != "undefined") {
-		dojo.deprecated("dojo.regexp.currency: flags.cents", "use flags.fractional instead", "0.5");
-		flags.fractional = flags.cents;
-	}
-	if (typeof flags.decimal != "string") {
-		flags.decimal = ".";
-	}
-	var signRE = dojo.regexp.buildGroupRE(flags.signed, function (q) {
-		if (q) {
-			return "[-+]";
+	if (typeof flags.signed == "undefined") { flags.signed = [true, false]; }
+	if (typeof flags.symbol == "undefined") { flags.symbol = "$"; }
+	if (typeof flags.placement != "string") { flags.placement = "before"; }
+	if (typeof flags.separator != "string") { flags.separator = ","; }
+	if (typeof flags.cents == "undefined") { flags.cents = [true, false]; }
+	if (typeof flags.decimal != "string") { flags.decimal = "."; }
+
+	// build sign RE
+	var signRE = dojo.regexp.buildGroupRE(flags.signed,
+		function(q) { if (q) { return "[-+]"; }  return ""; }
+	);
+
+	// build symbol RE
+	var symbolRE = dojo.regexp.buildGroupRE(flags.symbol,
+		function(symbol) { 
+			// escape all special characters
+			return "\\s?" + symbol.replace( /([.$?*!=:|\\\/^])/g, "\\$1") + "\\s?";
 		}
-		return "";
-	});
-	var symbolRE = dojo.regexp.buildGroupRE(flags.symbol, function (symbol) {
-		return "\\s?" + symbol.replace(/([.$?*!=:|\\\/^])/g, "\\$1") + "\\s?";
-	});
-	switch (flags.signPlacement) {
-	  case "before":
-		symbolRE = signRE + symbolRE;
-		break;
-	  case "after":
-		symbolRE = symbolRE + signRE;
-		break;
-	}
-	var flagsCopy = flags;
-	flagsCopy.signed = false;
-	flagsCopy.exponent = false;
-	var numberRE = dojo.regexp.realNumber(flagsCopy);
+	);
+
+	// number RE
+	var numberRE = dojo.regexp.integer( {signed: false, separator: flags.separator} );
+
+	// build cents RE
+	var centsRE = dojo.regexp.buildGroupRE(flags.cents,
+		function(q) { if (q) { return "(\\" + flags.decimal + "\\d\\d)"; }  return ""; }
+	);
+
+	// build currency RE
 	var currencyRE;
-	switch (flags.placement) {
-	  case "before":
-		currencyRE = symbolRE + numberRE;
-		break;
-	  case "after":
-		currencyRE = numberRE + symbolRE;
-		break;
+	if (flags.placement == "before") {
+		currencyRE = signRE + symbolRE + numberRE + centsRE;
 	}
-	switch (flags.signPlacement) {
-	  case "around":
-		currencyRE = "(" + currencyRE + "|" + "\\(" + currencyRE + "\\)" + ")";
-		break;
-	  case "begin":
-		currencyRE = signRE + currencyRE;
-		break;
-	  case "end":
-		currencyRE = currencyRE + signRE;
-		break;
+	else {
+		currencyRE = signRE + numberRE + centsRE + symbolRE;
 	}
+
 	return currencyRE;
-};
-dojo.regexp.us.state = function (flags) {
+}
+
+/**
+  A regular expression to match US state and territory abbreviations.
+
+  @param flags  An object.
+    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
+    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.
+
+  @return  A string for a regular expression for a US state.
+*/
+dojo.regexp.us.state = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.allowTerritories != "boolean") {
-		flags.allowTerritories = true;
-	}
-	if (typeof flags.allowMilitary != "boolean") {
-		flags.allowMilitary = true;
-	}
-	var statesRE = "AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" + "NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";
+	if (typeof flags.allowTerritories != "boolean") { flags.allowTerritories = true; }
+	if (typeof flags.allowMilitary != "boolean") { flags.allowMilitary = true; }
+
+	// state RE
+	var statesRE = 
+		"AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|" + 
+		"NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY";
+
+	// territories RE
 	var territoriesRE = "AS|FM|GU|MH|MP|PW|PR|VI";
+
+	// military states RE
 	var militaryRE = "AA|AE|AP";
-	if (flags.allowTerritories) {
-		statesRE += "|" + territoriesRE;
-	}
-	if (flags.allowMilitary) {
-		statesRE += "|" + militaryRE;
-	}
+
+	// Build states and territories RE
+	if (flags.allowTerritories) { statesRE += "|" + territoriesRE; }
+	if (flags.allowMilitary) { statesRE += "|" + militaryRE; }
+
 	return "(" + statesRE + ")";
-};
-dojo.regexp.time = function (flags) {
-	dojo.deprecated("dojo.regexp.time", "Use dojo.date.parse instead", "0.5");
+}
+
+/**
+  Builds a regular expression to match any International format for time.
+  The RE can match one format or one of multiple formats.
+
+  Format
+  h        12 hour, no zero padding.
+  hh       12 hour, has leading zero.
+  H        24 hour, no zero padding.
+  HH       24 hour, has leading zero.
+  m        minutes, no zero padding.
+  mm       minutes, has leading zero.
+  s        seconds, no zero padding.
+  ss       seconds, has leading zero.
+  t        am or pm, case insensitive.
+  All other characters must appear literally in the expression.
+
+  Example
+    "h:m:s t"  ->   2:5:33 PM
+    "HH:mm:ss" ->  14:05:33
+
+  @param flags  An object.
+    flags.format  A string or an array of strings.  Default is "h:mm:ss t".
+    flags.amSymbol  The symbol used for AM.  Default is "AM".
+    flags.pmSymbol  The symbol used for PM.  Default is "PM".
+
+  @return  A string for a regular expression for a time value.
+*/
+dojo.regexp.time = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.format == "undefined") {
-		flags.format = "h:mm:ss t";
-	}
-	if (typeof flags.amSymbol != "string") {
-		flags.amSymbol = "AM";
-	}
-	if (typeof flags.pmSymbol != "string") {
-		flags.pmSymbol = "PM";
-	}
-	var timeRE = function (format) {
-		format = format.replace(/([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
-		var amRE = flags.amSymbol.replace(/([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
-		var pmRE = flags.pmSymbol.replace(/([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
+	if (typeof flags.format == "undefined") { flags.format = "h:mm:ss t"; }
+	if (typeof flags.amSymbol != "string") { flags.amSymbol = "AM"; }
+	if (typeof flags.pmSymbol != "string") { flags.pmSymbol = "PM"; }
+
+	// Converts a time format to a RE
+	var timeRE = function(format) {
+		// escape all special characters
+		format = format.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
+		var amRE = flags.amSymbol.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
+		var pmRE = flags.pmSymbol.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
+
+		// replace tokens with Regular Expressions
 		format = format.replace("hh", "(0[1-9]|1[0-2])");
 		format = format.replace("h", "([1-9]|1[0-2])");
 		format = format.replace("HH", "([01][0-9]|2[0-3])");
@@ -334,32 +484,83 @@
 		format = format.replace("m", "([1-5][0-9]|[0-9])");
 		format = format.replace("ss", "([0-5][0-9])");
 		format = format.replace("s", "([1-5][0-9]|[0-9])");
-		format = format.replace("t", "\\s?(" + amRE + "|" + pmRE + ")\\s?");
+		format = format.replace("t", "\\s?(" + amRE + "|" + pmRE + ")\\s?" );
+
 		return format;
 	};
+
+	// build RE for multiple time formats
 	return dojo.regexp.buildGroupRE(flags.format, timeRE);
-};
-dojo.regexp.numberFormat = function (flags) {
+}
+
+/**
+  Builds a regular expression to match any sort of number based format.
+  Use it for phone numbers, social security numbers, zip-codes, etc.
+  The RE can match one format or one of multiple formats.
+
+  Format
+    #        Stands for a digit, 0-9.
+    ?        Stands for an optional digit, 0-9 or nothing.
+    All other characters must appear literally in the expression.
+
+  Example   
+    "(###) ###-####"       ->   (510) 542-9742
+    "(###) ###-#### x#???" ->   (510) 542-9742 x153
+    "###-##-####"          ->   506-82-1089       i.e. social security number
+    "#####-####"           ->   98225-1649        i.e. zip code
+
+  @param flags  An object.
+    flags.format  A string or an Array of strings for multiple formats.
+  @return  A string for a regular expression for the number format(s).
+*/
+dojo.regexp.numberFormat = function(flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
-	if (typeof flags.format == "undefined") {
-		flags.format = "###-###-####";
-	}
-	var digitRE = function (format) {
-		format = format.replace(/([.$*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
+	if (typeof flags.format == "undefined") { flags.format = "###-###-####"; }
+
+	// Converts a number format to RE.
+	var digitRE = function(format) {
+		// escape all special characters, except '?'
+		format = format.replace( /([.$*!=:|{}\(\)\[\]\\\/^])/g, "\\$1");
+
+		// Now replace '?' with Regular Expression
 		format = format.replace(/\?/g, "\\d?");
+
+		// replace # with Regular Expression
 		format = format.replace(/#/g, "\\d");
+
 		return format;
 	};
+
+	// build RE for multiple number formats
 	return dojo.regexp.buildGroupRE(flags.format, digitRE);
-};
-dojo.regexp.buildGroupRE = function (a, re) {
-	if (!(a instanceof Array)) {
+}
+
+
+/**
+  This is basically a utility function used by some of the RE generators.
+  Builds a regular expression that groups subexpressions.
+  The subexpressions are constructed by the function, re, in the second parameter.
+  re builds one subexpression for each elem in the array a, in the first parameter.
+
+  @param a  A single value or an array of values.
+  @param re  A function.  Takes one parameter and converts it to a regular expression. 
+  @return  A string for a regular expression that groups all the subexpressions.
+*/
+dojo.regexp.buildGroupRE = function(a, re) {
+
+	// case 1: a is a single value.
+	if ( !( a instanceof Array ) ) { 
 		return re(a);
 	}
+
+	// case 2: a is an array
 	var b = [];
 	for (var i = 0; i < a.length; i++) {
+		// convert each elem to a RE
 		b.push(re(a[i]));
 	}
+
+	 // join the REs as alternatives in a RE group.
 	return "(" + b.join("|") + ")";
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/rpc/Deferred.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/Deferred.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/Deferred.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,11 +8,8 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.rpc.Deferred");
 dojo.require("dojo.Deferred");
-dojo.deprecated("dojo.rpc.Deferred", "replaced by dojo.Deferred", "0.6");
+
 dojo.rpc.Deferred = dojo.Deferred;
 dojo.rpc.Deferred.prototype = dojo.Deferred.prototype;
-

Modified: tags/parley-0.53/root/static/magic/src/rpc/JotService.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/JotService.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/JotService.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,20 +8,34 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.rpc.JotService");
 dojo.require("dojo.rpc.RpcService");
 dojo.require("dojo.rpc.JsonService");
 dojo.require("dojo.json");
-dojo.rpc.JotService = function () {
+
+dojo.rpc.JotService = function(){
 	this.serviceUrl = "/_/jsonrpc";
-};
+}
+
 dojo.inherits(dojo.rpc.JotService, dojo.rpc.JsonService);
-dojo.lang.extend(dojo.rpc.JotService, {bind:function (method, parameters, deferredRequestHandler, url) {
-	dojo.io.bind({url:url || this.serviceUrl, content:{json:this.createRequest(method, parameters)}, method:"POST", mimetype:"text/json", load:this.resultCallback(deferredRequestHandler), error:this.errorCallback(deferredRequestHandler), preventCache:true});
-}, createRequest:function (method, params) {
-	var req = {"params":params, "method":method, "id":this.lastSubmissionId++};
-	return dojo.json.serialize(req);
-}});
 
+dojo.lang.extend(dojo.rpc.JotService, {
+	bind: function(method, parameters, deferredRequestHandler, url){
+		dojo.io.bind({
+			url: url||this.serviceUrl,
+			content: {
+				json: this.createRequest(method, parameters)
+			},
+			method: "POST",
+			mimetype: "text/json",
+			load: this.resultCallback(deferredRequestHandler),
+			error: this.errorCallback(deferredRequestHandler),
+			preventCache: true
+		});
+	},
+
+	createRequest: function(method, params){
+		var req = { "params": params, "method": method, "id": this.lastSubmissionId++ };
+		return dojo.json.serialize(req);
+	}
+});

Modified: tags/parley-0.53/root/static/magic/src/rpc/JsonService.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/JsonService.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/JsonService.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,64 +8,96 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.rpc.JsonService");
 dojo.require("dojo.rpc.RpcService");
 dojo.require("dojo.io.*");
 dojo.require("dojo.json");
-dojo.require("dojo.lang.common");
-dojo.rpc.JsonService = function (args) {
-	if (args) {
-		if (dojo.lang.isString(args)) {
+dojo.require("dojo.lang");
+
+dojo.rpc.JsonService = function(args){
+	// passing just the URL isn't terribly useful. It's expected that at
+	// various times folks will want to specify:
+	//	- just the serviceUrl (for use w/ remoteCall())
+	//	- the text of the SMD to evaluate
+	// 	- a raw SMD object
+	//	- the SMD URL
+	if(args){
+		if(dojo.lang.isString(args)){
+			// we assume it's an SMD file to be processed, since this was the
+			// earlier function signature
+
+			// FIXME: also accept dojo.uri.Uri objects?
 			this.connect(args);
-		} else {
-			if (args["smdUrl"]) {
+		}else{
+			// otherwise we assume it's an arguments object with the following
+			// (optional) properties:
+			//	- serviceUrl
+			//	- strictArgChecks
+			//	- smdUrl
+			//	- smdStr
+			//	- smdObj
+			if(args["smdUrl"]){
 				this.connect(args.smdUrl);
 			}
-			if (args["smdStr"]) {
-				this.processSmd(dj_eval("(" + args.smdStr + ")"));
+			if(args["smdStr"]){
+				this.processSmd(dj_eval("("+args.smdStr+")"));
 			}
-			if (args["smdObj"]) {
+			if(args["smdObj"]){
 				this.processSmd(args.smdObj);
 			}
-			if (args["serviceUrl"]) {
+			if(args["serviceUrl"]){
 				this.serviceUrl = args.serviceUrl;
 			}
-			if (typeof args["strictArgChecks"] != "undefined") {
+			if(typeof args["strictArgChecks"] != "undefined"){
 				this.strictArgChecks = args.strictArgChecks;
 			}
 		}
 	}
-};
+}
+
 dojo.inherits(dojo.rpc.JsonService, dojo.rpc.RpcService);
-dojo.extend(dojo.rpc.JsonService, {bustCache:false, contentType:"application/json-rpc", lastSubmissionId:0, callRemote:function (method, params) {
-	var deferred = new dojo.Deferred();
-	this.bind(method, params, deferred);
-	return deferred;
-}, bind:function (method, parameters, deferredRequestHandler, url) {
-	dojo.io.bind({url:url || this.serviceUrl, postContent:this.createRequest(method, parameters), method:"POST", contentType:this.contentType, mimetype:"text/json", load:this.resultCallback(deferredRequestHandler), error:this.errorCallback(deferredRequestHandler), preventCache:this.bustCache});
-}, createRequest:function (method, params) {
-	var req = {"params":params, "method":method, "id":++this.lastSubmissionId};
-	var data = dojo.json.serialize(req);
-	dojo.debug("JsonService: JSON-RPC Request: " + data);
-	return data;
-}, parseResults:function (obj) {
-	if (!obj) {
-		return;
-	}
-	if (obj["Result"] != null) {
-		return obj["Result"];
-	} else {
-		if (obj["result"] != null) {
-			return obj["result"];
-		} else {
-			if (obj["ResultSet"]) {
-				return obj["ResultSet"];
-			} else {
-				return obj;
-			}
+
+dojo.lang.extend(dojo.rpc.JsonService, {
+
+	bustCache: false,
+	
+	contentType: "application/json-rpc",
+
+	lastSubmissionId: 0,
+
+	callRemote: function(method, params){
+		var deferred = new dojo.rpc.Deferred();
+		this.bind(method, params, deferred);
+		return deferred;
+	},
+
+	bind: function(method, parameters, deferredRequestHandler, url){
+		dojo.io.bind({
+			url: url||this.serviceUrl,
+			postContent: this.createRequest(method, parameters),
+			method: "POST",
+			contentType: this.contentType,
+			mimetype: "text/json",
+			load: this.resultCallback(deferredRequestHandler),
+			preventCache:this.bustCache 
+		});
+	},
+
+	createRequest: function(method, params){
+		var req = { "params": params, "method": method, "id": ++this.lastSubmissionId };
+		var data = dojo.json.serialize(req);
+		dojo.debug("JsonService: JSON-RPC Request: " + data);
+		return data;
+	},
+
+	parseResults: function(obj){
+		if(!obj){ return; }
+		if(obj["Result"]||obj["result"]){
+			return obj["result"]||obj["Result"];
+		}else if(obj["ResultSet"]){
+			return obj["ResultSet"];
+		}else{
+			return obj;
 		}
 	}
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/rpc/RpcService.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/RpcService.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/RpcService.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,67 +8,109 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.rpc.RpcService");
 dojo.require("dojo.io.*");
 dojo.require("dojo.json");
 dojo.require("dojo.lang.func");
-dojo.require("dojo.Deferred");
-dojo.rpc.RpcService = function (url) {
-	if (url) {
+dojo.require("dojo.rpc.Deferred");
+
+dojo.rpc.RpcService = function(url){
+	// summary
+	// constructor for rpc base class
+	if(url){
 		this.connect(url);
 	}
-};
-dojo.lang.extend(dojo.rpc.RpcService, {strictArgChecks:true, serviceUrl:"", parseResults:function (obj) {
-	return obj;
-}, errorCallback:function (deferredRequestHandler) {
-	return function (type, e) {
-		deferredRequestHandler.errback(new Error(e.message));
-	};
-}, resultCallback:function (deferredRequestHandler) {
-	var tf = dojo.lang.hitch(this, function (type, obj, e) {
-		if (obj["error"] != null) {
-			var err = new Error(obj.error);
-			err.id = obj.id;
-			deferredRequestHandler.errback(err);
-		} else {
-			var results = this.parseResults(obj);
-			deferredRequestHandler.callback(results);
+}
+
+dojo.lang.extend(dojo.rpc.RpcService, {
+
+	strictArgChecks: true,
+	serviceUrl: "",
+
+	parseResults: function(obj){
+		// summary
+		// parse the results coming back from an rpc request.  
+   		// this base implementation, just returns the full object
+		// subclasses should parse and only return the actual results
+		return obj;
+	},
+
+	errorCallback: function(/* dojo.rpc.Deferred */ deferredRequestHandler){
+		// summary
+		// create callback that calls the Deferres errback method
+		return function(type, obj, e){
+			deferredRequestHandler.errback(e);
 		}
-	});
-	return tf;
-}, generateMethod:function (method, parameters, url) {
-	return dojo.lang.hitch(this, function () {
-		var deferredRequestHandler = new dojo.Deferred();
-		if ((this.strictArgChecks) && (parameters != null) && (arguments.length != parameters.length)) {
-			dojo.raise("Invalid number of parameters for remote method.");
-		} else {
-			this.bind(method, arguments, deferredRequestHandler, url);
+	},
+
+	resultCallback: function(/* dojo.rpc.Deferred */ deferredRequestHandler){
+		// summary
+		// create callback that calls the Deferred's callback method
+		var tf = dojo.lang.hitch(this, 
+			function(type, obj, e){
+				var results = this.parseResults(obj||e);
+				deferredRequestHandler.callback(results); 
+			}
+		);
+		return tf;
+	},
+
+
+	generateMethod: function(/*string*/ method, /*array*/ parameters, /*string*/ url){
+		// summary
+		// generate the local bind methods for the remote object
+		return dojo.lang.hitch(this, function(){
+			var deferredRequestHandler = new dojo.rpc.Deferred();
+
+			// if params weren't specified, then we can assume it's varargs
+			if( (this.strictArgChecks) &&
+				(parameters != null) &&
+				(arguments.length != parameters.length)
+			){
+				// put error stuff here, no enough params
+				dojo.raise("Invalid number of parameters for remote method.");
+			} else {
+				this.bind(method, arguments, deferredRequestHandler, url);
+			}
+
+			return deferredRequestHandler;
+		});
+	},
+
+	processSmd: function(/*json*/ object){
+		// summary
+		// callback method for reciept of a smd object.  Parse the smd and
+		// generate functions based on the description
+		dojo.debug("RpcService: Processing returned SMD.");
+		if(object.methods){
+			dojo.lang.forEach(object.methods, function(m){
+				if(m && m["name"]){
+					dojo.debug("RpcService: Creating Method: this.", m.name, "()");
+					this[m.name] = this.generateMethod(	m.name,
+														m.parameters, 
+														m["url"]||m["serviceUrl"]||m["serviceURL"]);
+					if(dojo.lang.isFunction(this[m.name])){
+						dojo.debug("RpcService: Successfully created", m.name, "()");
+					}else{
+						dojo.debug("RpcService: Failed to create", m.name, "()");
+					}
+				}
+			}, this);
 		}
-		return deferredRequestHandler;
-	});
-}, processSmd:function (object) {
-	dojo.debug("RpcService: Processing returned SMD.");
-	if (object.methods) {
-		dojo.lang.forEach(object.methods, function (m) {
-			if (m && m["name"]) {
-				dojo.debug("RpcService: Creating Method: this.", m.name, "()");
-				this[m.name] = this.generateMethod(m.name, m.parameters, m["url"] || m["serviceUrl"] || m["serviceURL"]);
-				if (dojo.lang.isFunction(this[m.name])) {
-					dojo.debug("RpcService: Successfully created", m.name, "()");
-				} else {
-					dojo.debug("RpcService: Failed to create", m.name, "()");
-				}
-			}
-		}, this);
+
+		this.serviceUrl = object.serviceUrl||object.serviceURL;
+		dojo.debug("RpcService: Dojo RpcService is ready for use.");
+	},
+
+	connect: function(/*String*/ smdUrl){
+		// summary
+		// connect to a remote url and retrieve a smd object
+		dojo.debug("RpcService: Attempting to load SMD document from:", smdUrl);
+		dojo.io.bind({
+			url: smdUrl,
+			mimetype: "text/json",
+			load: dojo.lang.hitch(this, function(type, object, e){ return this.processSmd(object); }),
+			sync: true
+		});		
 	}
-	this.serviceUrl = object.serviceUrl || object.serviceURL;
-	dojo.debug("RpcService: Dojo RpcService is ready for use.");
-}, connect:function (smdUrl) {
-	dojo.debug("RpcService: Attempting to load SMD document from:", smdUrl);
-	dojo.io.bind({url:smdUrl, mimetype:"text/json", load:dojo.lang.hitch(this, function (type, object, e) {
-		return this.processSmd(object);
-	}), sync:true});
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/rpc/YahooService.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/YahooService.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/YahooService.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,34 +8,48 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.rpc.YahooService");
 dojo.require("dojo.rpc.RpcService");
 dojo.require("dojo.rpc.JsonService");
 dojo.require("dojo.json");
 dojo.require("dojo.uri.*");
 dojo.require("dojo.io.ScriptSrcIO");
-dojo.rpc.YahooService = function (appId) {
+
+dojo.rpc.YahooService = function(appId){
 	this.appId = appId;
-	if (!appId) {
+	if(!appId){
 		this.appId = "dojotoolkit";
-		dojo.debug("please initialize the YahooService class with your own", "application ID. Using the default may cause problems during", "deployment of your application");
+		dojo.debug(	"please initializae the YahooService class with your own",
+					"application ID. Using the default may cause problems during",
+					"deployment of your application");
 	}
-	if (djConfig["useXDomain"] && !djConfig["yahooServiceSmdUrl"]) {
-		dojo.debug("dojo.rpc.YahooService: When using cross-domain Dojo builds," + " please save yahoo.smd to your domain and set djConfig.yahooServiceSmdUrl" + " to the path on your domain to yahoo.smd");
-	}
-	this.connect(djConfig["yahooServiceSmdUrl"] || dojo.uri.moduleUri("dojo.rpc", "yahoo.smd"));
-	this.strictArgChecks = false;
-};
+	this.connect(dojo.uri.dojoUri("src/rpc/yahoo.smd"));
+	this.scrictArgChecks = false;
+}
+
 dojo.inherits(dojo.rpc.YahooService, dojo.rpc.JsonService);
-dojo.lang.extend(dojo.rpc.YahooService, {strictArgChecks:false, bind:function (method, parameters, deferredRequestHandler, url) {
-	var params = parameters;
-	if ((dojo.lang.isArrayLike(parameters)) && (parameters.length == 1)) {
-		params = parameters[0];
+
+dojo.lang.extend(dojo.rpc.YahooService, {
+	strictArgChecks: false,
+
+	bind: function(method, parameters, deferredRequestHandler, url){
+		var params = parameters;
+		if(	(dojo.lang.isArrayLike(parameters))&&
+			(parameters.length == 1)){
+			params = parameters[0];
+		}
+		params.output = "json";
+		params.appid= this.appId;
+		dojo.io.bind({
+			url: url||this.serviceUrl,
+			transport: "ScriptSrcTransport",
+			// FIXME: need to get content interpolation fixed
+			content: params,
+			jsonParamName: "callback",
+			mimetype: "text/json",
+			load: this.resultCallback(deferredRequestHandler),
+			error: this.errorCallback(deferredRequestHandler),
+			preventCache: true
+		});
 	}
-	params.output = "json";
-	params.appid = this.appId;
-	dojo.io.bind({url:url || this.serviceUrl, transport:"ScriptSrcTransport", content:params, jsonParamName:"callback", mimetype:"text/json", load:this.resultCallback(deferredRequestHandler), error:this.errorCallback(deferredRequestHandler), preventCache:true});
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/rpc/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,7 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:[["dojo.rpc.JsonService", false, false]]});
+dojo.kwCompoundRequire({
+	common: ["dojo.rpc.JsonService", false, false]
+});
 dojo.provide("dojo.rpc.*");
-

Modified: tags/parley-0.53/root/static/magic/src/rpc/yahoo.smd
===================================================================
--- tags/parley-0.53/root/static/magic/src/rpc/yahoo.smd	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/rpc/yahoo.smd	2008-10-08 11:42:12 UTC (rev 952)
@@ -86,6 +86,9 @@
 		//
 		// WEB SEARCH
 		//
+
+		// NOTE: contextual search and term extraction are not stubbed out
+		// becaues I'm not sure if we can POST via script src inclusion method
 		{
 			// http://developer.yahoo.com/search/web/V1/webSearch.html 
 			"name":"webSearch",
@@ -121,35 +124,6 @@
 				{ "name":"results", "type":"INTEGER" } // 1-50, defaults to 10
 			]
 		},
-		{
-			// http://developer.yahoo.com/search/content/V1/termExtraction.html
-			"name":"termExtraction",
-			"serviceURL": "http://search.yahooapis.com/ContentAnalysisService/V1/termExtraction",
-			"parameters":[
-				{ "name":"query", "type":"STRING" },
-				{ "name":"context", "type":"STRING" },
-				{ "name":"results", "type":"INTEGER" } // 1-50, defaults to 10
-			]
-		},
-		{
-			// http://developer.yahoo.com/search/web/V1/contextSearch.html
-			"name":"contextSearch",
-			"serviceURL": "http://search.yahooapis.com/WebSearchService/V1/contextSearch",
-			"parameters":[
-				{ "name":"query", "type":"STRING" },
-				{ "name":"context", "type":"STRING" },
-				{ "name":"type", "type":"STRING" }, // defaults to "all"
-				{ "name":"results", "type":"INTEGER" }, // defaults to 10
-				{ "name":"start", "type":"INTEGER" }, // defaults to 1
-				{ "name":"format", "type":"STRING" }, // defaults to "any", can be "html", "msword", "pdf", "ppt", "rst", "txt", or "xls"
-				{ "name":"adult_ok", "type":"INTEGER" }, // defaults to null
-				{ "name":"similar_ok", "type":"INTEGER" }, // defaults to null
-				{ "name":"language", "type":"STRING" }, // defaults to null
-				{ "name":"country", "type":"STRING" }, // defaults to null
-				{ "name":"site", "type":"STRING" }, // defaults to null
-				{ "name":"license", "type":"STRING" } // defaults to "any", could be "cc_any", "cc_commercial", "cc_modifiable"
-			]
-		},
 		//
 		// IMAGE SEARCH
 		//

Modified: tags/parley-0.53/root/static/magic/src/selection/Selection.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/selection/Selection.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/selection/Selection.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,309 +8,418 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.selection.Selection");
 dojo.require("dojo.lang.array");
 dojo.require("dojo.lang.func");
-dojo.require("dojo.lang.common");
 dojo.require("dojo.math");
-dojo.declare("dojo.selection.Selection", null, {initializer:function (items, isCollection) {
+
+dojo.selection.Selection = function(items, isCollection) {
 	this.items = [];
 	this.selection = [];
 	this._pivotItems = [];
 	this.clearItems();
-	if (items) {
-		if (isCollection) {
+
+	if(items) {
+		if(isCollection) {
 			this.setItemsCollection(items);
 		} else {
 			this.setItems(items);
 		}
 	}
-}, items:null, selection:null, lastSelected:null, allowImplicit:true, length:0, isGrowable:true, _pivotItems:null, _pivotItem:null, onSelect:function (item) {
-}, onDeselect:function (item) {
-}, onSelectChange:function (item, selected) {
-}, _find:function (item, inSelection) {
-	if (inSelection) {
-		return dojo.lang.find(this.selection, item);
-	} else {
-		return dojo.lang.find(this.items, item);
-	}
-}, isSelectable:function (item) {
-	return true;
-}, setItems:function () {
-	this.clearItems();
-	this.addItems.call(this, arguments);
-}, setItemsCollection:function (collection) {
-	this.items = collection;
-}, addItems:function () {
-	var args = dojo.lang.unnest(arguments);
-	for (var i = 0; i < args.length; i++) {
-		this.items.push(args[i]);
-	}
-}, addItemsAt:function (item, before) {
-	if (this.items.length == 0) {
-		return this.addItems(dojo.lang.toArray(arguments, 2));
-	}
-	if (!this.isItem(item)) {
-		item = this.items[item];
-	}
-	if (!item) {
-		throw new Error("addItemsAt: item doesn't exist");
-	}
-	var idx = this._find(item);
-	if (idx > 0 && before) {
-		idx--;
-	}
-	for (var i = 2; i < arguments.length; i++) {
-		if (!this.isItem(arguments[i])) {
-			this.items.splice(idx++, 0, arguments[i]);
+}
+dojo.lang.extend(dojo.selection.Selection, {
+	items: null, // items to select from, order matters for growable selections
+
+	selection: null, // items selected, aren't stored in order (see sorted())
+	lastSelected: null, // last item selected
+
+	allowImplicit: true, // if true, grow selection will start from 0th item when nothing is selected
+	length: 0, // number of *selected* items
+
+	// if true, the selection is treated as an in-order and can grow by ranges, not just by single item
+	isGrowable: true,
+
+	_pivotItems: null, // stack of pivot items
+	_pivotItem: null, // item we grow selections from, top of stack
+
+	// event handlers
+	onSelect: function(item) {},
+	onDeselect: function(item) {},
+	onSelectChange: function(item, selected) {},
+
+	_find: function(item, inSelection) {
+		if(inSelection) {
+			return dojo.lang.find(item, this.selection);
+		} else {
+			return dojo.lang.find(item, this.items);
 		}
-	}
-}, removeItem:function (item) {
-	var idx = this._find(item);
-	if (idx > -1) {
-		this.items.splice(idx, 1);
-	}
-	idx = this._find(item, true);
-	if (idx > -1) {
-		this.selection.splice(idx, 1);
-	}
-}, clearItems:function () {
-	this.items = [];
-	this.deselectAll();
-}, isItem:function (item) {
-	return this._find(item) > -1;
-}, isSelected:function (item) {
-	return this._find(item, true) > -1;
-}, selectFilter:function (item, selection, add, grow) {
-	return true;
-}, update:function (item, add, grow, noToggle) {
-	if (!this.isItem(item)) {
-		return false;
-	}
-	if (this.isGrowable && grow) {
-		if ((!this.isSelected(item)) && this.selectFilter(item, this.selection, false, true)) {
-			this.grow(item);
-			this.lastSelected = item;
+	},
+
+	isSelectable: function(item) {
+		// user-customizable, will filter items through this
+		return true;
+	},
+
+	setItems: function(/* ... */) {
+		this.clearItems();
+		this.addItems.call(this, arguments);
+	},
+
+	// this is in case you have an active collection array-like object
+	// (i.e. getElementsByTagName collection) that manages its own order
+	// and item list
+	setItemsCollection: function(collection) {
+		this.items = collection;
+	},
+
+	addItems: function(/* ... */) {
+		var args = dojo.lang.unnest(arguments);
+		for(var i = 0; i < args.length; i++) {
+			this.items.push(args[i]);
 		}
-	} else {
-		if (add) {
-			if (this.selectFilter(item, this.selection, true, false)) {
-				if (noToggle) {
-					if (this.select(item)) {
+	},
+
+	addItemsAt: function(item, before /* ... */) {
+		if(this.items.length == 0) { // work for empy case
+			return this.addItems(dojo.lang.toArray(arguments, 2));
+		}
+
+		if(!this.isItem(item)) {
+			item = this.items[item];
+		}
+		if(!item) { throw new Error("addItemsAt: item doesn't exist"); }
+		var idx = this._find(item);
+		if(idx > 0 && before) { idx--; }
+		for(var i = 2; i < arguments.length; i++) {
+			if(!this.isItem(arguments[i])) {
+				this.items.splice(idx++, 0, arguments[i]);
+			}
+		}
+	},
+
+	removeItem: function(item) {
+		// remove item
+		var idx = this._find(item);
+		if(idx > -1) {
+			this.items.splice(idx, 1);
+		}
+		// remove from selection
+		// FIXME: do we call deselect? I don't think so because this isn't how
+		// you usually want to deselect an item. For example, if you deleted an
+		// item, you don't really want to deselect it -- you want it gone. -DS
+		idx = this._find(item, true);
+		if(idx > -1) {
+			this.selection.splice(idx, 1);
+		}
+	},
+
+	clearItems: function() {
+		this.items = [];
+		this.deselectAll();
+	},
+
+	isItem: function(item) {
+		return this._find(item) > -1;
+	},
+
+	isSelected: function(item) {
+		return this._find(item, true) > -1;
+	},
+
+	/**
+	 * allows you to filter item in or out of the selection
+	 * depending on the current selection and action to be taken
+	**/
+	selectFilter: function(item, selection, add, grow) {
+		return true;
+	},
+
+	/**
+	 * update -- manages selections, most selecting should be done here
+	 *  item => item which may be added/grown to/only selected/deselected
+	 *  add => behaves like ctrl in windows selection world
+	 *  grow => behaves like shift
+	 *  noToggle => if true, don't toggle selection on item
+	**/
+	update: function(item, add, grow, noToggle) {
+		if(!this.isItem(item)) { return false; }
+
+		if(this.isGrowable && grow) {
+			if(!this.isSelected(item)
+				&& this.selectFilter(item, this.selection, false, true)) {
+				this.grow(item);
+				this.lastSelected = item;
+			}
+		} else if(add) {
+			if(this.selectFilter(item, this.selection, true, false)) {
+				if(noToggle) {
+					if(this.select(item)) {
 						this.lastSelected = item;
 					}
-				} else {
-					if (this.toggleSelected(item)) {
-						this.lastSelected = item;
-					}
+				} else if(this.toggleSelected(item)) {
+					this.lastSelected = item;
 				}
 			}
 		} else {
 			this.deselectAll();
 			this.select(item);
 		}
-	}
-	this.length = this.selection.length;
-	return true;
-}, grow:function (toItem, fromItem) {
-	if (!this.isGrowable) {
-		return;
-	}
-	if (arguments.length == 1) {
-		fromItem = this._pivotItem;
-		if (!fromItem && this.allowImplicit) {
-			fromItem = this.items[0];
+
+		this.length = this.selection.length;
+	},
+
+	/**
+	 * Grow a selection.
+	 *  toItem => which item to grow selection to
+	 *  fromItem => which item to start the growth from (it won't be selected)
+	 *
+	 * Any items in (fromItem, lastSelected] that aren't part of
+	 * (fromItem, toItem] will be deselected
+	**/
+	grow: function(toItem, fromItem) {
+		if(!this.isGrowable) { return; }
+
+		if(arguments.length == 1) {
+			fromItem = this._pivotItem;
+			if(!fromItem && this.allowImplicit) {
+				fromItem = this.items[0];
+			}
 		}
-	}
-	if (!toItem || !fromItem) {
-		return false;
-	}
-	var fromIdx = this._find(fromItem);
-	var toDeselect = {};
-	var lastIdx = -1;
-	if (this.lastSelected) {
-		lastIdx = this._find(this.lastSelected);
-		var step = fromIdx < lastIdx ? -1 : 1;
-		var range = dojo.math.range(lastIdx, fromIdx, step);
-		for (var i = 0; i < range.length; i++) {
-			toDeselect[range[i]] = true;
+		if(!toItem || !fromItem) { return false; }
+
+		var fromIdx = this._find(fromItem);
+
+		// get items to deselect (fromItem, lastSelected]
+		var toDeselect = {};
+		var lastIdx = -1;
+		if(this.lastSelected) {
+			lastIdx = this._find(this.lastSelected);
+			var step = fromIdx < lastIdx ? -1 : 1;
+			var range = dojo.math.range(lastIdx, fromIdx, step);
+			for(var i = 0; i < range.length; i++) {
+				toDeselect[range[i]] = true;
+			}
 		}
-	}
-	var toIdx = this._find(toItem);
-	var step = fromIdx < toIdx ? -1 : 1;
-	var shrink = lastIdx >= 0 && step == 1 ? lastIdx < toIdx : lastIdx > toIdx;
-	var range = dojo.math.range(toIdx, fromIdx, step);
-	if (range.length) {
-		for (var i = range.length - 1; i >= 0; i--) {
-			var item = this.items[range[i]];
-			if (this.selectFilter(item, this.selection, false, true)) {
-				if (this.select(item, true) || shrink) {
-					this.lastSelected = item;
+
+		// add selection (fromItem, toItem]
+		var toIdx = this._find(toItem);
+		var step = fromIdx < toIdx ? -1 : 1;
+		var shrink = lastIdx >= 0 && step == 1 ? lastIdx < toIdx : lastIdx > toIdx;
+		var range = dojo.math.range(toIdx, fromIdx, step);
+		if(range.length) {
+			for(var i = range.length-1; i >= 0; i--) {
+				var item = this.items[range[i]];
+				if(this.selectFilter(item, this.selection, false, true)) {
+					if(this.select(item, true) || shrink) {
+						this.lastSelected = item;
+					}
+					if(range[i] in toDeselect) {
+						delete toDeselect[range[i]];
+					}
 				}
-				if (range[i] in toDeselect) {
-					delete toDeselect[range[i]];
-				}
 			}
+		} else {
+			this.lastSelected = fromItem;
 		}
-	} else {
-		this.lastSelected = fromItem;
-	}
-	for (var i in toDeselect) {
-		if (this.items[i] == this.lastSelected) {
+
+		// now deselect...
+		for(var i in toDeselect) {
+			if(this.items[i] == this.lastSelected) {
+				//dojo.debug("oops!");
+			}
+			this.deselect(this.items[i]);
 		}
-		this.deselect(this.items[i]);
-	}
-	this._updatePivot();
-}, growUp:function () {
-	if (!this.isGrowable) {
-		return;
-	}
-	var idx = this._find(this.lastSelected) - 1;
-	while (idx >= 0) {
-		if (this.selectFilter(this.items[idx], this.selection, false, true)) {
-			this.grow(this.items[idx]);
-			break;
+
+		// make sure everything is all kosher after selections+deselections
+		this._updatePivot();
+	},
+
+	/**
+	 * Grow selection upwards one item from lastSelected
+	**/
+	growUp: function() {
+		if(!this.isGrowable) { return; }
+
+		var idx = this._find(this.lastSelected) - 1;
+		while(idx >= 0) {
+			if(this.selectFilter(this.items[idx], this.selection, false, true)) {
+				this.grow(this.items[idx]);
+				break;
+			}
+			idx--;
 		}
-		idx--;
-	}
-}, growDown:function () {
-	if (!this.isGrowable) {
-		return;
-	}
-	var idx = this._find(this.lastSelected);
-	if (idx < 0 && this.allowImplicit) {
-		this.select(this.items[0]);
-		idx = 0;
-	}
-	idx++;
-	while (idx > 0 && idx < this.items.length) {
-		if (this.selectFilter(this.items[idx], this.selection, false, true)) {
-			this.grow(this.items[idx]);
-			break;
+	},
+
+	/**
+	 * Grow selection downwards one item from lastSelected
+	**/
+	growDown: function() {
+		if(!this.isGrowable) { return; }
+
+		var idx = this._find(this.lastSelected);
+		if(idx < 0 && this.allowImplicit) {
+			this.select(this.items[0]);
+			idx = 0;
 		}
 		idx++;
-	}
-}, toggleSelected:function (item, noPivot) {
-	if (this.isItem(item)) {
-		if (this.select(item, noPivot)) {
-			return 1;
+		while(idx > 0 && idx < this.items.length) {
+			if(this.selectFilter(this.items[idx], this.selection, false, true)) {
+				this.grow(this.items[idx]);
+				break;
+			}
+			idx++;
 		}
-		if (this.deselect(item)) {
-			return -1;
+	},
+
+	toggleSelected: function(item, noPivot) {
+		if(this.isItem(item)) {
+			if(this.select(item, noPivot)) { return 1; }
+			if(this.deselect(item)) { return -1; }
 		}
-	}
-	return 0;
-}, select:function (item, noPivot) {
-	if (this.isItem(item) && !this.isSelected(item) && this.isSelectable(item)) {
-		this.selection.push(item);
-		this.lastSelected = item;
-		this.onSelect(item);
-		this.onSelectChange(item, true);
-		if (!noPivot) {
-			this._addPivot(item);
-		}
-		this.length = this.selection.length;
-		return true;
-	}
-	return false;
-}, deselect:function (item) {
-	var idx = this._find(item, true);
-	if (idx > -1) {
-		this.selection.splice(idx, 1);
-		this.onDeselect(item);
-		this.onSelectChange(item, false);
-		if (item == this.lastSelected) {
-			this.lastSelected = null;
-		}
-		this._removePivot(item);
-		this.length = this.selection.length;
-		return true;
-	}
-	return false;
-}, selectAll:function () {
-	for (var i = 0; i < this.items.length; i++) {
-		this.select(this.items[i]);
-	}
-}, deselectAll:function () {
-	while (this.selection && this.selection.length) {
-		this.deselect(this.selection[0]);
-	}
-}, selectNext:function () {
-	var idx = this._find(this.lastSelected);
-	while (idx > -1 && ++idx < this.items.length) {
-		if (this.isSelectable(this.items[idx])) {
-			this.deselectAll();
-			this.select(this.items[idx]);
+		return 0;
+	},
+
+	select: function(item, noPivot) {
+		if(this.isItem(item) && !this.isSelected(item)
+			&& this.isSelectable(item)) {
+			this.selection.push(item);
+			this.lastSelected = item;
+			this.onSelect(item);
+			this.onSelectChange(item, true);
+			if(!noPivot) {
+				this._addPivot(item);
+			}
 			return true;
 		}
-	}
-	return false;
-}, selectPrevious:function () {
-	var idx = this._find(this.lastSelected);
-	while (idx-- > 0) {
-		if (this.isSelectable(this.items[idx])) {
-			this.deselectAll();
-			this.select(this.items[idx]);
+		return false;
+	},
+
+	deselect: function(item) {
+		var idx = this._find(item, true);
+		if(idx > -1) {
+			this.selection.splice(idx, 1);
+			this.onDeselect(item);
+			this.onSelectChange(item, false);
+			if(item == this.lastSelected) {
+				this.lastSelected = null;
+			}
+
+			this._removePivot(item);
+
 			return true;
 		}
-	}
-	return false;
-}, selectFirst:function () {
-	this.deselectAll();
-	var idx = 0;
-	while (this.items[idx] && !this.select(this.items[idx])) {
-		idx++;
-	}
-	return this.items[idx] ? true : false;
-}, selectLast:function () {
-	this.deselectAll();
-	var idx = this.items.length - 1;
-	while (this.items[idx] && !this.select(this.items[idx])) {
-		idx--;
-	}
-	return this.items[idx] ? true : false;
-}, _addPivot:function (item, andClear) {
-	this._pivotItem = item;
-	if (andClear) {
-		this._pivotItems = [item];
-	} else {
-		this._pivotItems.push(item);
-	}
-}, _removePivot:function (item) {
-	var i = dojo.lang.find(this._pivotItems, item);
-	if (i > -1) {
-		this._pivotItems.splice(i, 1);
-		this._pivotItem = this._pivotItems[this._pivotItems.length - 1];
-	}
-	this._updatePivot();
-}, _updatePivot:function () {
-	if (this._pivotItems.length == 0) {
-		if (this.lastSelected) {
-			this._addPivot(this.lastSelected);
+		return false;
+	},
+
+	selectAll: function() {
+		for(var i = 0; i < this.items.length; i++) {
+			this.select(this.items[i]);
 		}
-	}
-}, sorted:function () {
-	return dojo.lang.toArray(this.selection).sort(dojo.lang.hitch(this, function (a, b) {
-		var A = this._find(a), B = this._find(b);
-		if (A > B) {
-			return 1;
+	},
+
+	deselectAll: function() {
+		while(this.selection && this.selection.length) {
+			this.deselect(this.selection[0]);
+		}
+	},
+
+	selectNext: function() {
+		var idx = this._find(this.lastSelected);
+		while(idx > -1 && ++idx < this.items.length) {
+			if(this.isSelectable(this.items[idx])) {
+				this.deselectAll();
+				this.select(this.items[idx]);
+				return true;
+			}
+		}
+		return false;
+	},
+
+	selectPrevious: function() {
+		//debugger;
+		var idx = this._find(this.lastSelected);
+		while(idx-- > 0) {
+			if(this.isSelectable(this.items[idx])) {
+				this.deselectAll();
+				this.select(this.items[idx]);
+				return true;
+			}
+		}
+		return false;
+	},
+
+	// select first selectable item
+	selectFirst: function() {
+		this.deselectAll();
+		var idx = 0;
+		while(this.items[idx] && !this.select(this.items[idx])) {
+			idx++;
+		}
+		return this.items[idx] ? true : false;
+	},
+
+	// select last selectable item
+	selectLast: function() {
+		this.deselectAll();
+		var idx = this.items.length-1;
+		while(this.items[idx] && !this.select(this.items[idx])) {
+			idx--;
+		}
+		return this.items[idx] ? true : false;
+	},
+
+	_addPivot: function(item, andClear) {
+		this._pivotItem = item;
+		if(andClear) {
+			this._pivotItems = [item];
 		} else {
-			if (A < B) {
-				return -1;
-			} else {
-				return 0;
+			this._pivotItems.push(item);
+		}
+	},
+
+	_removePivot: function(item) {
+		var i = dojo.lang.find(item, this._pivotItems);
+		if(i > -1) {
+			this._pivotItems.splice(i, 1);
+			this._pivotItem = this._pivotItems[this._pivotItems.length-1];
+		}
+
+		this._updatePivot();
+	},
+
+	_updatePivot: function() {
+		if(this._pivotItems.length == 0) {
+			if(this.lastSelected) {
+				this._addPivot(this.lastSelected);
 			}
 		}
-	}));
-}, updateSelected:function () {
-	for (var i = 0; i < this.selection.length; i++) {
-		if (this._find(this.selection[i]) < 0) {
-			var removed = this.selection.splice(i, 1);
-			this._removePivot(removed[0]);
+	},
+
+	sorted: function() {
+		return dojo.lang.toArray(this.selection).sort(
+			dojo.lang.hitch(this, function(a, b) {
+				var A = this._find(a), B = this._find(b);
+				if(A > B) {
+					return 1;
+				} else if(A < B) {
+					return -1;
+				} else {
+					return 0;
+				}
+			})
+		);
+	},
+
+	// remove any items from the selection that are no longer in this.items
+	updateSelected: function() {
+		for(var i = 0; i < this.selection.length; i++) {
+			if(this._find(this.selection[i]) < 0) {
+				var removed = this.selection.splice(i, 1);
+
+				this._removePivot(removed[0]);
+			}
 		}
+
+		this.length = this.selection.length;
 	}
-	this.length = this.selection.length;
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/storage/Storage.as
===================================================================
--- tags/parley-0.53/root/static/magic/src/storage/Storage.as	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/storage/Storage.as	2008-10-08 11:42:12 UTC (rev 952)
@@ -31,7 +31,6 @@
 		// preload the System Settings finished button movie for offline
 		// access so it is in the cache
 		_root.createEmptyMovieClip("_settingsBackground", 1);
-		// getURL("javascript:alert('"+DojoExternalInterface.dojoPath+"');");
 		_root._settingsBackground.loadMovie(DojoExternalInterface.dojoPath + "storage_dialog.swf");
 	}
 

Modified: tags/parley-0.53/root/static/magic/src/storage/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/storage/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/storage/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,10 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.storage"], browser:["dojo.storage.browser"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.storage"],
+	browser: ["dojo.storage.browser"],
+	dashboard: ["dojo.storage.dashboard"]
+});
 dojo.provide("dojo.storage.*");
 

Modified: tags/parley-0.53/root/static/magic/src/storage/browser.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/storage/browser.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/storage/browser.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,543 +8,192 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.storage.browser");
+dojo.provide("dojo.storage.browser.FlashStorageProvider");
+
 dojo.require("dojo.storage");
 dojo.require("dojo.flash");
 dojo.require("dojo.json");
 dojo.require("dojo.uri.*");
-dojo.storage.browser.FileStorageProvider = function () {
-};
-dojo.inherits(dojo.storage.browser.FileStorageProvider, dojo.storage);
-dojo.storage.browser.FileStorageProvider._KEY_INDEX_FILENAME = "__dojoAllKeys";
-dojo.storage.browser.FileStorageProvider._APPLET_ID = "__dojoFileJavaObj";
-dojo.lang.extend(dojo.storage.browser.FileStorageProvider, {namespace:"default", initialized:false, _available:null, _statusHandler:null, _keyIndex:new Array(), initialize:function () {
-	if (djConfig["disableFileStorage"] == true) {
-		return;
-	}
-	this._loadKeyIndex();
-	this.initialized = true;
-	dojo.storage.manager.loaded();
-}, isAvailable:function () {
-	this._available = false;
-	var protocol = window.location.protocol;
-	if (protocol.indexOf("file") != -1 || protocol.indexOf("chrome") != -1) {
-		this._available = this._isAvailableXPCOM();
-		if (this._available == false) {
-			this._available = this._isAvailableActiveX();
+
+/** 
+		Storage provider that uses features in Flash to achieve permanent storage.
+		
+		@author Alex Russel, alex at dojotoolkit.org
+		@author Brad Neuberg, bkn3 at columbia.edu 
+*/
+dojo.storage.browser.FlashStorageProvider = function(){
+}
+
+dojo.inherits(dojo.storage.browser.FlashStorageProvider, dojo.storage);
+
+// instance methods and properties
+dojo.lang.extend(dojo.storage.browser.FlashStorageProvider, {
+	namespace: "default",
+	initialized: false,
+	_available: null,
+	_statusHandler: null,
+	
+	initialize: function(){
+		if(djConfig["disableFlashStorage"] == true){
+			return;
 		}
-	}
-	return this._available;
-}, put:function (key, value, resultsHandler) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	this._statusHandler = resultsHandler;
-	try {
-		this._save(key, value);
-		resultsHandler.call(null, dojo.storage.SUCCESS, key);
-	}
-	catch (e) {
-		this._statusHandler.call(null, dojo.storage.FAILED, key, e.toString());
-	}
-}, get:function (key) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	var results = this._load(key);
-	return results;
-}, getKeys:function () {
-	return this._keyIndex;
-}, hasKey:function (key) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	this._loadKeyIndex();
-	var exists = false;
-	for (var i = 0; i < this._keyIndex.length; i++) {
-		if (this._keyIndex[i] == key) {
-			exists = true;
+		
+		// initialize our Flash
+		var loadedListener = function(){
+			dojo.storage._flashLoaded();
 		}
-	}
-	return exists;
-}, clear:function () {
-	this._loadKeyIndex();
-	var keyIndex = new Array();
-	for (var i = 0; i < this._keyIndex.length; i++) {
-		keyIndex[keyIndex.length] = new String(this._keyIndex[i]);
-	}
-	for (var i = 0; i < keyIndex.length; i++) {
-		this.remove(keyIndex[i]);
-	}
-}, remove:function (key) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	this._loadKeyIndex();
-	for (var i = 0; i < this._keyIndex.length; i++) {
-		if (this._keyIndex[i] == key) {
-			this._keyIndex.splice(i, 1);
-			break;
+		dojo.flash.addLoadedListener(loadedListener);
+		var swfloc6 = dojo.uri.dojoUri("Storage_version6.swf").toString();
+		var swfloc8 = dojo.uri.dojoUri("Storage_version8.swf").toString();
+		dojo.flash.setSwf({flash6: swfloc6, flash8: swfloc8, visible: false});
+	},
+	
+	isAvailable: function(){
+		if(djConfig["disableFlashStorage"] == true){
+			this._available = false;
 		}
-	}
-	this._save(dojo.storage.browser.FileStorageProvider._KEY_INDEX_FILENAME, this._keyIndex, false);
-	var fullPath = this._getPagePath() + key + ".txt";
-	if (this._isAvailableXPCOM()) {
-		this._removeXPCOM(fullPath);
-	} else {
-		if (this._isAvailableActiveX()) {
-			this._removeActiveX(fullPath);
+		
+		return this._available;
+	},
+	
+	setNamespace: function(namespace){
+		this.namespace = namespace;
+	},
+
+	put: function(key, value, resultsHandler){
+		if(this.isValidKey(key) == false){
+			dojo.raise("Invalid key given: " + key);
 		}
-	}
-}, isPermanent:function () {
-	return true;
-}, getMaximumSize:function () {
-	return dojo.storage.SIZE_NO_LIMIT;
-}, hasSettingsUI:function () {
-	return false;
-}, showSettingsUI:function () {
-	dojo.raise(this.getType() + " does not support a storage settings user-interface");
-}, hideSettingsUI:function () {
-	dojo.raise(this.getType() + " does not support a storage settings user-interface");
-}, getType:function () {
-	return "dojo.storage.browser.FileStorageProvider";
-}, _save:function (key, value, updateKeyIndex) {
-	if (typeof updateKeyIndex == "undefined") {
-		updateKeyIndex = true;
-	}
-	if (dojo.lang.isString(value) == false) {
-		value = dojo.json.serialize(value);
-		value = "/* JavaScript */\n" + value + "\n\n";
-	}
-	var fullPath = this._getPagePath() + key + ".txt";
-	if (this._isAvailableXPCOM()) {
-		this._saveFileXPCOM(fullPath, value);
-	} else {
-		if (this._isAvailableActiveX()) {
-			this._saveFileActiveX(fullPath, value);
+			
+		this._statusHandler = resultsHandler;
+		
+		// serialize the value
+		// Handle strings differently so they have better performance
+		if(dojo.lang.isString(value)){
+			value = "string:" + value;
+		}else{
+			value = dojo.json.serialize(value);
 		}
-	}
-	if (updateKeyIndex) {
-		this._updateKeyIndex(key);
-	}
-}, _load:function (key) {
-	var fullPath = this._getPagePath() + key + ".txt";
-	var results = null;
-	if (this._isAvailableXPCOM()) {
-		results = this._loadFileXPCOM(fullPath);
-	} else {
-		if (this._isAvailableActiveX()) {
-			results = this._loadFileActiveX(fullPath);
-		} else {
-			if (this._isAvailableJava()) {
-				results = this._loadFileJava(fullPath);
-			}
+		
+		dojo.flash.comm.put(key, value, this.namespace);
+	},
+
+	get: function(key){
+		if(this.isValidKey(key) == false){
+			dojo.raise("Invalid key given: " + key);
 		}
-	}
-	if (results == null) {
-		return null;
-	}
-	if (!dojo.lang.isUndefined(results) && results != null && /^\/\* JavaScript \*\//.test(results)) {
-		results = dojo.json.evalJson(results);
-	}
-	return results;
-}, _updateKeyIndex:function (key) {
-	this._loadKeyIndex();
-	var alreadyAdded = false;
-	for (var i = 0; i < this._keyIndex.length; i++) {
-		if (this._keyIndex[i] == key) {
-			alreadyAdded = true;
-			break;
-		}
-	}
-	if (alreadyAdded == false) {
-		this._keyIndex[this._keyIndex.length] = key;
-	}
-	this._save(dojo.storage.browser.FileStorageProvider._KEY_INDEX_FILENAME, this._keyIndex, false);
-}, _loadKeyIndex:function () {
-	var indexContents = this._load(dojo.storage.browser.FileStorageProvider._KEY_INDEX_FILENAME);
-	if (indexContents == null) {
-		this._keyIndex = new Array();
-	} else {
-		this._keyIndex = indexContents;
-	}
-}, _saveFileXPCOM:function (filename, value) {
-	try {
-		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
-		var f = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
-		f.initWithPath(filename);
-		var ouputStream = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
-		ouputStream.init(f, 32 | 4 | 8, 256 + 128, null);
-		ouputStream.write(value, value.length);
-		ouputStream.close();
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
-		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._saveFileXPCOM(): " + msg);
-	}
-}, _loadFileXPCOM:function (filename) {
-	try {
-		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
-		var f = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
-		f.initWithPath(filename);
-		if (f.exists() == false) {
+		
+		var results = dojo.flash.comm.get(key, this.namespace);
+
+		if(results == ""){
 			return null;
 		}
-		var inp = Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream);
-		inp.init(f, 1, 4, null);
-		var inputStream = Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream);
-		inputStream.init(inp);
-		var results = inputStream.read(inputStream.available());
-		return results;
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
+    
+		// destringify the content back into a 
+		// real JavaScript object
+		// Handle strings differently so they have better performance
+		if(!dojo.lang.isUndefined(results) && results != null 
+			 && /^string:/.test(results)){
+			results = results.substring("string:".length);
+		}else{
+			results = dojo.json.evalJson(results);
 		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._loadFileXPCOM(): " + msg);
-	}
-	return null;
-}, _saveFileActiveX:function (filename, value) {
-	try {
-		var fileSystem = new ActiveXObject("Scripting.FileSystemObject");
-		var f = fileSystem.OpenTextFile(filename, 2, true);
-		f.Write(value);
-		f.Close();
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
-		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._saveFileActiveX(): " + msg);
-	}
-}, _loadFileActiveX:function (filename) {
-	try {
-		var fileSystem = new ActiveXObject("Scripting.FileSystemObject");
-		if (fileSystem.FileExists(filename) == false) {
-			return null;
-		}
-		var f = fileSystem.OpenTextFile(filename, 1);
-		var results = f.ReadAll();
-		f.Close();
+    
 		return results;
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
+	},
+
+	getKeys: function(){
+		var results = dojo.flash.comm.getKeys(this.namespace);
+		
+		if(results == ""){
+			return new Array();
 		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._loadFileActiveX(): " + msg);
-	}
-}, _saveFileJava:function (filename, value) {
-	try {
-		var applet = dojo.byId(dojo.storage.browser.FileStorageProvider._APPLET_ID);
-		applet.save(filename, value);
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
-		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._saveFileJava(): " + msg);
-	}
-}, _loadFileJava:function (filename) {
-	try {
-		var applet = dojo.byId(dojo.storage.browser.FileStorageProvider._APPLET_ID);
-		var results = applet.load(filename);
+
+		// the results are returned comma seperated; split them
+		results = results.split(",");
+		
 		return results;
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
+	},
+
+	clear: function(){
+		dojo.flash.comm.clear(this.namespace);
+	},
+	
+	remove: function(key){
+	},
+	
+	isPermanent: function(){
+		return true;
+	},
+
+	getMaximumSize: function(){
+		return dojo.storage.SIZE_NO_LIMIT;
+	},
+
+	hasSettingsUI: function(){
+		return true;
+	},
+
+	showSettingsUI: function(){
+		dojo.flash.comm.showSettings();
+		dojo.flash.obj.setVisible(true);
+		dojo.flash.obj.center();
+	},
+
+	hideSettingsUI: function(){
+		// hide the dialog
+		dojo.flash.obj.setVisible(false);
+		
+		// call anyone who wants to know the dialog is
+		// now hidden
+		if(dojo.storage.onHideSettingsUI != null &&
+			!dojo.lang.isUndefined(dojo.storage.onHideSettingsUI)){
+			dojo.storage.onHideSettingsUI.call(null);	
 		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._loadFileJava(): " + msg);
-	}
-}, _isAvailableActiveX:function () {
-	try {
-		if (window.ActiveXObject) {
-			var fileSystem = new window.ActiveXObject("Scripting.FileSystemObject");
-			return true;
+	},
+	
+	/** 
+			The provider name as a string, such as 
+			"dojo.storage.FlashStorageProvider". 
+	*/
+	getType: function(){
+		return "dojo.storage.FlashStorageProvider";
+	},
+	
+	/** Called when the Flash is finished loading. */
+	_flashLoaded: function(){
+		this.initialized = true;
+
+		// indicate that this storage provider is now loaded
+		dojo.storage.manager.loaded();
+	},
+	
+	/** 
+			Called if the storage system needs to tell us about the status
+			of a put() request. 
+	*/
+	_onStatus: function(statusResult, key){
+		//dojo.debug("_onStatus, statusResult="+statusResult+", key="+key);
+		if(statusResult == dojo.storage.PENDING){
+			dojo.flash.obj.center();
+			dojo.flash.obj.setVisible(true);
+		}else{
+			dojo.flash.obj.setVisible(false);
 		}
-	}
-	catch (e) {
-		dojo.debug(e);
-	}
-	return false;
-}, _isAvailableXPCOM:function () {
-	try {
-		if (window.Components) {
-			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
-			Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
-			return true;
+		
+		if(!dojo.lang.isUndefined(dojo.storage._statusHandler) 
+				&& dojo.storage._statusHandler != null){
+			dojo.storage._statusHandler.call(null, statusResult, key);		
 		}
 	}
-	catch (e) {
-		dojo.debug(e);
-	}
-	return false;
-}, _isAvailableJava:function () {
-	try {
-		if (dojo.render.html.safari == true || dojo.render.html.opera == true()) {
-			if (navigator.javaEnabled() == true) {
-				return true;
-			}
-		}
-	}
-	catch (e) {
-		dojo.debug(e);
-	}
-	return false;
-}, _getPagePath:function () {
-	var path = window.location.pathname;
-	if (/\.html?$/i.test(path)) {
-		path = path.replace(/(?:\/|\\)?[^\.\/\\]*\.html?$/, "");
-	}
-	if (/^\/?[a-z]+\:/i.test(path)) {
-		path = path.replace(/^\/?/, "");
-		path = path.replace(/\//g, "\\");
-	} else {
-		if (/^[\/\\]{2,3}[^\/]/.test(path)) {
-			path = path.replace(/^[\/\\]{2,3}/, "");
-			path = path.replace(/\//g, "\\");
-			path = "\\\\" + path;
-		}
-	}
-	if (/\/$/.test(path) == false && /\\$/.test(path) == false) {
-		if (/\//.test(path)) {
-			path += "/";
-		} else {
-			path += "\\";
-		}
-	}
-	path = unescape(path);
-	return path;
-}, _removeXPCOM:function (filename) {
-	try {
-		netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
-		var f = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
-		f.initWithPath(filename);
-		if (f.exists() == false || f.isDirectory()) {
-			return;
-		}
-		if (f.isFile()) {
-			f.remove(false);
-		}
-	}
-	catch (e) {
-		dojo.raise("dojo.storage.browser.FileStorageProvider.remove(): " + e.toString());
-	}
-}, _removeActiveX:function (filename) {
-	try {
-		var fileSystem = new ActiveXObject("Scripting.FileSystemObject");
-		fileSystem.DeleteFile(filename);
-	}
-	catch (e) {
-		dojo.raise("dojo.storage.browser.FileStorageProvider.remove(): " + e.toString());
-	}
-}, _removeJava:function (filename) {
-	try {
-		var applet = dojo.byId(dojo.storage.browser.FileStorageProvider._APPLET_ID);
-		applet.remove(filename);
-	}
-	catch (e) {
-		var msg = e.toString();
-		if (e.name && e.message) {
-			msg = e.name + ": " + e.message;
-		}
-		dojo.raise("dojo.storage.browser.FileStorageProvider._removeJava(): " + msg);
-	}
-}, _writeApplet:function () {
-	var archive = dojo.uri.moduleUri("dojo", "../DojoFileStorageProvider.jar").toString();
-	var tag = "<applet " + "id='" + dojo.storage.browser.FileStorageProvider._APPLET_ID + "' " + "style='position: absolute; top: -500px; left: -500px; width: 1px; height: 1px;' " + "code='DojoFileStorageProvider.class' " + "archive='" + archive + "' " + "width='1' " + "height='1' " + ">" + "</applet>";
-	document.writeln(tag);
-}});
-dojo.storage.browser.WhatWGStorageProvider = function () {
-};
-dojo.inherits(dojo.storage.browser.WhatWGStorageProvider, dojo.storage);
-dojo.lang.extend(dojo.storage.browser.WhatWGStorageProvider, {namespace:"default", initialized:false, _domain:null, _available:null, _statusHandler:null, initialize:function () {
-	if (djConfig["disableWhatWGStorage"] == true) {
-		return;
-	}
-	this._domain = location.hostname;
-	this.initialized = true;
-	dojo.storage.manager.loaded();
-}, isAvailable:function () {
-	try {
-		var myStorage = globalStorage[location.hostname];
-	}
-	catch (e) {
-		this._available = false;
-		return this._available;
-	}
-	this._available = true;
-	return this._available;
-}, put:function (key, value, resultsHandler) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	this._statusHandler = resultsHandler;
-	if (dojo.lang.isString(value)) {
-		value = "string:" + value;
-	} else {
-		value = dojo.json.serialize(value);
-	}
-	window.addEventListener("storage", function (evt) {
-		resultsHandler.call(null, dojo.storage.SUCCESS, key);
-	}, false);
-	try {
-		var myStorage = globalStorage[this._domain];
-		myStorage.setItem(key, value);
-	}
-	catch (e) {
-		this._statusHandler.call(null, dojo.storage.FAILED, key, e.toString());
-	}
-}, get:function (key) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	var myStorage = globalStorage[this._domain];
-	var results = myStorage.getItem(key);
-	if (results == null) {
-		return null;
-	}
-	results = results.value;
-	if (!dojo.lang.isUndefined(results) && results != null && /^string:/.test(results)) {
-		results = results.substring("string:".length);
-	} else {
-		results = dojo.json.evalJson(results);
-	}
-	return results;
-}, getKeys:function () {
-	var myStorage = globalStorage[this._domain];
-	var keysArray = new Array();
-	for (i = 0; i < myStorage.length; i++) {
-		keysArray[i] = myStorage.key(i);
-	}
-	return keysArray;
-}, clear:function () {
-	var myStorage = globalStorage[this._domain];
-	var keys = new Array();
-	for (var i = 0; i < myStorage.length; i++) {
-		keys[keys.length] = myStorage.key(i);
-	}
-	for (var i = 0; i < keys.length; i++) {
-		myStorage.removeItem(keys[i]);
-	}
-}, remove:function (key) {
-	var myStorage = globalStorage[this._domain];
-	myStorage.removeItem(key);
-}, isPermanent:function () {
-	return true;
-}, getMaximumSize:function () {
-	return dojo.storage.SIZE_NO_LIMIT;
-}, hasSettingsUI:function () {
-	return false;
-}, showSettingsUI:function () {
-	dojo.raise(this.getType() + " does not support a storage settings user-interface");
-}, hideSettingsUI:function () {
-	dojo.raise(this.getType() + " does not support a storage settings user-interface");
-}, getType:function () {
-	return "dojo.storage.browser.WhatWGProvider";
-}});
-dojo.storage.browser.FlashStorageProvider = function () {
-};
-dojo.inherits(dojo.storage.browser.FlashStorageProvider, dojo.storage);
-dojo.lang.extend(dojo.storage.browser.FlashStorageProvider, {namespace:"default", initialized:false, _available:null, _statusHandler:null, initialize:function () {
-	if (djConfig["disableFlashStorage"] == true) {
-		return;
-	}
-	var loadedListener = function () {
-		dojo.storage._flashLoaded();
-	};
-	dojo.flash.addLoadedListener(loadedListener);
-	var swfloc6 = dojo.uri.moduleUri("dojo", "../Storage_version6.swf").toString();
-	var swfloc8 = dojo.uri.moduleUri("dojo", "../Storage_version8.swf").toString();
-	dojo.flash.setSwf({flash6:swfloc6, flash8:swfloc8, visible:false});
-}, isAvailable:function () {
-	if (djConfig["disableFlashStorage"] == true) {
-		this._available = false;
-	} else {
-		this._available = true;
-	}
-	return this._available;
-}, put:function (key, value, resultsHandler) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	this._statusHandler = resultsHandler;
-	if (dojo.lang.isString(value)) {
-		value = "string:" + value;
-	} else {
-		value = dojo.json.serialize(value);
-	}
-	dojo.flash.comm.put(key, value, this.namespace);
-}, get:function (key) {
-	if (this.isValidKey(key) == false) {
-		dojo.raise("Invalid key given: " + key);
-	}
-	var results = dojo.flash.comm.get(key, this.namespace);
-	if (results == "") {
-		return null;
-	}
-	if (!dojo.lang.isUndefined(results) && results != null && /^string:/.test(results)) {
-		results = results.substring("string:".length);
-	} else {
-		results = dojo.json.evalJson(results);
-	}
-	return results;
-}, getKeys:function () {
-	var results = dojo.flash.comm.getKeys(this.namespace);
-	if (results == "") {
-		return [];
-	}
-	return results.split(",");
-}, clear:function () {
-	dojo.flash.comm.clear(this.namespace);
-}, remove:function (key) {
-	dojo.unimplemented("dojo.storage.browser.FlashStorageProvider.remove");
-}, isPermanent:function () {
-	return true;
-}, getMaximumSize:function () {
-	return dojo.storage.SIZE_NO_LIMIT;
-}, hasSettingsUI:function () {
-	return true;
-}, showSettingsUI:function () {
-	dojo.flash.comm.showSettings();
-	dojo.flash.obj.setVisible(true);
-	dojo.flash.obj.center();
-}, hideSettingsUI:function () {
-	dojo.flash.obj.setVisible(false);
-	if (dojo.storage.onHideSettingsUI != null && !dojo.lang.isUndefined(dojo.storage.onHideSettingsUI)) {
-		dojo.storage.onHideSettingsUI.call(null);
-	}
-}, getType:function () {
-	return "dojo.storage.browser.FlashStorageProvider";
-}, _flashLoaded:function () {
-	this._initialized = true;
-	dojo.storage.manager.loaded();
-}, _onStatus:function (statusResult, key) {
-	var ds = dojo.storage;
-	var dfo = dojo.flash.obj;
-	if (statusResult == ds.PENDING) {
-		dfo.center();
-		dfo.setVisible(true);
-	} else {
-		dfo.setVisible(false);
-	}
-	if ((!dj_undef("_statusHandler", ds)) && (ds._statusHandler != null)) {
-		ds._statusHandler.call(null, statusResult, key);
-	}
-}});
-dojo.storage.manager.register("dojo.storage.browser.FileStorageProvider", new dojo.storage.browser.FileStorageProvider());
-dojo.storage.manager.register("dojo.storage.browser.WhatWGStorageProvider", new dojo.storage.browser.WhatWGStorageProvider());
-dojo.storage.manager.register("dojo.storage.browser.FlashStorageProvider", new dojo.storage.browser.FlashStorageProvider());
-dojo.storage.manager.initialize();
+});
 
+// register the existence of our storage providers
+dojo.storage.manager.register("dojo.storage.browser.FlashStorageProvider",
+                              new dojo.storage.browser.FlashStorageProvider());
+
+// now that we are loaded and registered tell the storage manager to initialize
+// itself
+dojo.storage.manager.initialize();
+															

Added: tags/parley-0.53/root/static/magic/src/storage/dashboard.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/storage/dashboard.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/storage/dashboard.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,52 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.require("dojo.storage");
+dojo.require("dojo.json");
+dojo.provide("dojo.storage.dashboard");
+
+dojo.storage.dashboard.StorageProvider = function(){
+	this.initialized = false;
+}
+
+dojo.inherits(dojo.storage.dashboard.StorageProvider, dojo.storage.StorageProvider);
+
+dojo.lang.extend(dojo.storage.dashboard.StorageProvider, {
+	storageOnLoad: function(){
+		this.initialized = true;
+	},
+
+	set: function(key, value, ns){
+		if (ns && widget.system){
+			widget.system("/bin/mkdir " + ns);
+			var system = widget.system("/bin/echo " + value + " >" + ns + "/" + key);
+			if(system.errorString){
+				return false;
+			}
+			return true;
+		}
+
+		return widget.setPreferenceForKey(dojo.json.serialize(value), key);
+	},
+
+	get: function(key, ns){
+		if (ns && widget.system) {
+			var system = widget.system("/bin/cat " + ns + "/" + key);
+			if(system.errorString){
+				return "";
+			}
+			return system.outputString;
+		}
+
+		return dojo.json.evalJson(widget.preferenceForKey(key));
+	}
+});
+
+dojo.storage.setProvider(new dojo.storage.dashboard.StorageProvider());

Modified: tags/parley-0.53/root/static/magic/src/storage.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/storage.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/storage.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,120 +8,411 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/** 
+		FIXME: Write better docs.
 
+		@author Alex Russel, alex at dojotoolkit.org
+		@author Brad Neuberg, bkn3 at columbia.edu 
+*/
+dojo.provide("dojo.storage");
+dojo.provide("dojo.storage.StorageProvider");
 
-dojo.provide("dojo.storage");
 dojo.require("dojo.lang.*");
 dojo.require("dojo.event.*");
-dojo.storage = new function () {
-};
-dojo.declare("dojo.storage", null, {SUCCESS:"success", FAILED:"failed", PENDING:"pending", SIZE_NOT_AVAILABLE:"Size not available", SIZE_NO_LIMIT:"No size limit", namespace:"default", onHideSettingsUI:null, initialize:function () {
-	dojo.unimplemented("dojo.storage.initialize");
-}, isAvailable:function () {
-	dojo.unimplemented("dojo.storage.isAvailable");
-}, put:function (key, value, resultsHandler) {
-	dojo.unimplemented("dojo.storage.put");
-}, get:function (key) {
-	dojo.unimplemented("dojo.storage.get");
-}, hasKey:function (key) {
-	return (this.get(key) != null);
-}, getKeys:function () {
-	dojo.unimplemented("dojo.storage.getKeys");
-}, clear:function () {
-	dojo.unimplemented("dojo.storage.clear");
-}, remove:function (key) {
-	dojo.unimplemented("dojo.storage.remove");
-}, isPermanent:function () {
-	dojo.unimplemented("dojo.storage.isPermanent");
-}, getMaximumSize:function () {
-	dojo.unimplemented("dojo.storage.getMaximumSize");
-}, hasSettingsUI:function () {
-	return false;
-}, showSettingsUI:function () {
-	dojo.unimplemented("dojo.storage.showSettingsUI");
-}, hideSettingsUI:function () {
-	dojo.unimplemented("dojo.storage.hideSettingsUI");
-}, getType:function () {
-	dojo.unimplemented("dojo.storage.getType");
-}, isValidKey:function (keyName) {
-	if ((keyName == null) || (typeof keyName == "undefined")) {
+
+
+/** The base class for all storage providers. */
+
+/** 
+	 The constructor for a storage provider. You should avoid initialization
+	 in the constructor; instead, define initialization in your initialize()
+	 method. 
+*/
+dojo.storage = function(){
+}
+
+dojo.lang.extend(dojo.storage, {
+	/** A put() call to a storage provider was succesful. */
+	SUCCESS: "success",
+	
+	/** A put() call to a storage provider failed. */
+	FAILED: "failed",
+	
+	/** A put() call to a storage provider is pending user approval. */
+	PENDING: "pending",
+	
+	/** 
+	  Returned by getMaximumSize() if this storage provider can not determine
+	  the maximum amount of data it can support. 
+	*/
+	SIZE_NOT_AVAILABLE: "Size not available",
+	
+	/**
+	  Returned by getMaximumSize() if this storage provider has no theoretical
+	  limit on the amount of data it can store. 
+	*/
+	SIZE_NO_LIMIT: "No size limit",
+	
+	/** 
+	  The namespace for all storage operations. This is useful if
+	  several applications want access to the storage system from the same
+	  domain but want different storage silos. 
+	*/
+	namespace: "dojoStorage",
+	
+	/**  
+	  If a function is assigned to this property, then 
+	  when the settings provider's UI is closed this
+	  function is called. Useful, for example, if the
+	  user has just cleared out all storage for this
+	  provider using the settings UI, and you want to 
+	  update your UI.
+	*/
+	onHideSettingsUI: null,
+
+	/** 
+	  Allows this storage provider to initialize itself. This is called
+	  after the page has finished loading, so you can not do document.writes(). 
+	*/
+	initialize: function(){
+	 dojo.unimplemented("dojo.storage.initialize");
+	},
+	
+	/** 
+	  Returns whether this storage provider is 
+	  available on this platform. 
+	
+	  @returns True or false if this storage 
+	  provider is supported.
+	*/
+	isAvailable: function(){
+		dojo.unimplemented("dojo.storage.isAvailable");
+	},
+	
+	/**
+	  Puts a key and value into this storage system.
+
+	  @param key A string key to use when retrieving 
+	         this value in the future.
+	  @param value A value to store; this can be 
+	         any JavaScript type.
+	  @param resultsHandler A callback function 
+	         that will receive three arguments.
+	         The first argument is one of three 
+	         values: dojo.storage.SUCCESS,
+	         dojo.storage.FAILED, or 
+	         dojo.storage.PENDING; these values 
+	         determine how the put request went. 
+	         In some storage systems users can deny
+	         a storage request, resulting in a 
+	         dojo.storage.FAILED, while in 
+	         other storage systems a storage 
+	         request must wait for user approval,
+	         resulting in a dojo.storage.PENDING 
+	         status until the request
+	         is either approved or denied, 
+	         resulting in another call back
+	         with dojo.storage.SUCCESS. 
+  
+	  The second argument in the call back is the key name
+	  that was being stored.
+	  
+	  The third argument in the call back is an 
+	  optional message that details possible error 
+	  messages that might have occurred during
+	  the storage process.
+
+	  Example:
+	    var resultsHandler = function(status, key, message){
+	      alert("status="+status+", key="+key+", message="+message);
+	    };
+	    dojo.storage.put("test", "hello world", 
+	                     resultsHandler);	
+	*/
+	put: function(key, value, resultsHandler){ 
+    dojo.unimplemented("dojo.storage.put");
+  },
+
+	/**
+	  Gets the value with the given key. Returns null
+	  if this key is not in the storage system.
+	
+	  @param key A string key to get the value of.
+	  @returns Returns any JavaScript object type; 
+	  null if the key is not
+	  present. 
+	*/
+	get: function(key){
+    dojo.unimplemented("dojo.storage.get");
+  },
+
+	/**
+	  Determines whether the storage has the given 
+	  key. 
+	
+	    @returns Whether this key is 
+	             present or not. 
+	*/
+	hasKey: function(key){
+		if (this.get(key) != null)
+			return true;
+		else
+			return false;
+	},
+
+	/**
+	  Enumerates all of the available keys in 
+	  this storage system.
+	
+	  @returns Array of string keys in this 
+	           storage system.
+	*/
+	getKeys: function(){
+    dojo.unimplemented("dojo.storage.getKeys");
+  },
+
+	/**
+	  Completely clears this storage system of all 
+	  of it's values and keys. 
+	*/
+	clear: function(){
+    dojo.unimplemented("dojo.storage.clear");
+  },
+  
+  /** Removes the given key from the storage system. */
+  remove: function(key){
+  	dojo.unimplemented("dojo.storage.remove");
+  },
+
+	/**
+	  Returns whether this storage provider's 
+	  values are persisted when this platform 
+	  is shutdown. 
+	
+	  @returns True or false whether this 
+	  storage is permanent. 
+	*/
+	isPermanent: function(){
+		dojo.unimplemented("dojo.storage.isPermanent");
+	},
+
+	/**
+	  The maximum storage allowed by this provider.
+	
+	  @returns Returns the maximum storage size 
+	           supported by this provider, in 
+	           thousands of bytes (i.e., if it 
+	           returns 60 then this means that 60K 
+	           of storage is supported).
+	    
+	           If this provider can not determine 
+	           it's maximum size, then 
+	           dojo.storage.SIZE_NOT_AVAILABLE is 
+	           returned; if there is no theoretical
+	           limit on the amount of storage 
+	           this provider can return, then
+	           dojo.storage.SIZE_NO_LIMIT is 
+	           returned
+	*/
+	getMaximumSize: function(){
+    dojo.unimplemented("dojo.storage.getMaximumSize");
+  },
+
+	/**
+	  Determines whether this provider has a 
+	  settings UI.
+	
+	  @returns True or false if this provider has 
+	           the ability to show a
+	           a settings UI to change it's 
+	           values, change the amount of storage
+	           available, etc. 
+	*/
+	hasSettingsUI: function(){
 		return false;
-	}
-	return /^[0-9A-Za-z_]*$/.test(keyName);
-}});
-dojo.storage.manager = new function () {
+	},
+
+	/**
+	  If this provider has a settings UI, it is 
+	  shown. 
+	*/
+	showSettingsUI: function(){
+	 dojo.unimplemented("dojo.storage.showSettingsUI");
+	},
+
+	/**
+	  If this provider has a settings UI, hides
+	  it.
+	*/
+	hideSettingsUI: function(){
+	 dojo.unimplemented("dojo.storage.hideSettingsUI");
+	},
+	
+	/** 
+	  The provider name as a string, such as 
+	  "dojo.storage.FlashStorageProvider". 
+	*/
+	getType: function(){
+		dojo.unimplemented("dojo.storage.getType");
+	},
+	
+	/**
+	  Subclasses can call this to ensure that the key given is valid in a
+	  consistent way across different storage providers. We use the lowest
+	  common denominator for key values allowed: only letters, numbers, and
+	  underscores are allowed. No spaces. 
+	*/
+	isValidKey: function(keyName){
+		if (keyName == null || typeof keyName == "undefined")
+			return false;
+			
+		return /^[0-9A-Za-z_]*$/.test(keyName);
+  }
+});
+
+
+
+
+/**
+	Initializes the storage systems and figures out the best available 
+	storage options on this platform.
+*/
+dojo.storage.manager = new function(){
 	this.currentProvider = null;
 	this.available = false;
-	this._initialized = false;
-	this._providers = [];
-	this.namespace = "default";
-	this.initialize = function () {
+	this.initialized = false;
+	this.providers = new Array();
+	
+	// TODO: Provide a way for applications to override the default namespace
+	this.namespace = "dojo.storage";
+	
+	/** Initializes the storage system. */
+	this.initialize = function(){
+		// autodetect the best storage provider we can provide on this platform
 		this.autodetect();
-	};
-	this.register = function (name, instance) {
-		this._providers[this._providers.length] = instance;
-		this._providers[name] = instance;
-	};
-	this.setProvider = function (storageClass) {
-	};
-	this.autodetect = function () {
-		if (this._initialized == true) {
+	}
+	
+	/**
+	  Registers the existence of a new storage provider; used by subclasses
+	  to inform the manager of their existence. 
+	
+	  @param name The full class name of this provider, such as 
+	  "dojo.storage.browser.Flash6StorageProvider".
+	  @param instance An instance of this provider, which we will use to
+	  call isAvailable() on. 
+	*/
+	this.register = function(name, instance) {
+		this.providers[this.providers.length] = instance;
+		this.providers[name] = instance;
+	}
+	
+	/**
+	  Instructs the storageManager to use 
+	  the given storage class for all storage requests.
+	    
+	  Example:
+	    
+	  dojo.storage.setProvider(
+	         dojo.storage.browser.IEStorageProvider)
+	*/
+	this.setProvider = function(storageClass){
+	
+	}
+	
+	/** 
+	  Autodetects the best possible persistent
+	  storage provider available on this platform. 
+	*/
+	this.autodetect = function(){
+		if(this.initialized == true) // already finished
 			return;
-		}
+			
+		// go through each provider, seeing if it can be used
 		var providerToUse = null;
-		for (var i = 0; i < this._providers.length; i++) {
-			providerToUse = this._providers[i];
-			if (dojo.lang.isUndefined(djConfig["forceStorageProvider"]) == false && providerToUse.getType() == djConfig["forceStorageProvider"]) {
-				providerToUse.isAvailable();
+		for(var i = 0; i < this.providers.length; i++) {
+			providerToUse = this.providers[i];
+			if(providerToUse.isAvailable()){
 				break;
-			} else {
-				if (dojo.lang.isUndefined(djConfig["forceStorageProvider"]) == true && providerToUse.isAvailable()) {
-					break;
-				}
 			}
-		}
-		if (providerToUse == null) {
-			this._initialized = true;
+		}	
+		
+		if(providerToUse == null){ // no provider available
+			this.initialized = true;
 			this.available = false;
 			this.currentProvider = null;
 			dojo.raise("No storage provider found for this platform");
 		}
+			
+		// create this provider and copy over it's properties
 		this.currentProvider = providerToUse;
-		for (var i in providerToUse) {
-			dojo.storage[i] = providerToUse[i];
+	  	for(var i in providerToUse){
+	  		dojo.storage[i] = providerToUse[i];
 		}
 		dojo.storage.manager = this;
+		
+		// have the provider initialize itself
 		dojo.storage.initialize();
-		this._initialized = true;
+		
+		this.initialized = true;
 		this.available = true;
-	};
-	this.isAvailable = function () {
+	}
+	
+	/** Returns whether any storage options are available. */
+	this.isAvailable = function(){
 		return this.available;
-	};
-	this.isInitialized = function () {
-		if (this.currentProvider.getType() == "dojo.storage.browser.FlashStorageProvider" && dojo.flash.ready == false) {
+	}
+	
+	/** 
+	 	Returns whether the storage system is initialized and
+	 	ready to be used. 
+	*/
+	this.isInitialized = function(){
+		// FIXME: This should _really_ not be in here, but it fixes a bug
+		if(dojo.flash.ready == false){
 			return false;
-		} else {
-			return this._initialized;
+		}else{
+			return this.initialized;
 		}
-	};
-	this.supportsProvider = function (storageClass) {
-		try {
+	}
+
+	/**
+	  Determines if this platform supports
+	  the given storage provider.
+	
+	  Example:
+			
+	  dojo.storage.manager.supportsProvider(
+	    "dojo.storage.browser.InternetExplorerStorageProvider");
+	*/
+	this.supportsProvider = function(storageClass){
+		// construct this class dynamically
+		try{
+			// dynamically call the given providers class level isAvailable()
+			// method
 			var provider = eval("new " + storageClass + "()");
 			var results = provider.isAvailable();
-			if (results == null || typeof results == "undefined") {
+			if(results == null || typeof results == "undefined")
 				return false;
-			}
 			return results;
-		}
-		catch (exception) {
+		}catch (exception){
+			dojo.debug("exception="+exception);
 			return false;
 		}
-	};
-	this.getProvider = function () {
+	}
+
+	/** Gets the current provider. */
+	this.getProvider = function(){
 		return this.currentProvider;
-	};
-	this.loaded = function () {
-	};
-};
-
+	}
+	
+	/** 
+	  The storage provider should call this method when it is loaded and
+	  ready to be used. Clients who will use the provider will connect
+	  to this method to know when they can use the storage system:
+	
+	  dojo.connect(dojo.storage.manager, "loaded", someInstance, 
+	               someInstance.someMethod);
+	*/
+	this.loaded = function(){
+	}
+}

Modified: tags/parley-0.53/root/static/magic/src/string/Builder.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/string/Builder.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/string/Builder.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,97 +8,98 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.string.Builder");
+dojo.require("dojo.string");
 
+// NOTE: testing shows that direct "+=" concatenation is *much* faster on
+// Spidermoneky and Rhino, while arr.push()/arr.join() style concatenation is
+// significantly quicker on IE (Jscript/wsh/etc.).
 
-dojo.provide("dojo.string.Builder");
-dojo.require("dojo.string");
-dojo.require("dojo.lang.common");
-dojo.string.Builder = function (str) {
+dojo.string.Builder = function(str){
 	this.arrConcat = (dojo.render.html.capable && dojo.render.html["ie"]);
+
 	var a = [];
-	var b = "";
+	var b = str || "";
 	var length = this.length = b.length;
-	if (this.arrConcat) {
-		if (b.length > 0) {
+
+	if(this.arrConcat){
+		if(b.length > 0){
 			a.push(b);
 		}
 		b = "";
 	}
-	this.toString = this.valueOf = function () {
+
+	this.toString = this.valueOf = function(){ 
 		return (this.arrConcat) ? a.join("") : b;
 	};
-	this.append = function () {
-		for (var x = 0; x < arguments.length; x++) {
-			var s = arguments[x];
-			if (dojo.lang.isArrayLike(s)) {
-				this.append.apply(this, s);
-			} else {
-				if (this.arrConcat) {
-					a.push(s);
-				} else {
-					b += s;
-				}
-				length += s.length;
-				this.length = length;
-			}
+
+	this.append = function(s){
+		if(this.arrConcat){
+			a.push(s);
+		}else{
+			b+=s;
 		}
+		length += s.length;
+		this.length = length;
 		return this;
 	};
-	this.clear = function () {
+
+	this.clear = function(){
 		a = [];
 		b = "";
 		length = this.length = 0;
 		return this;
 	};
-	this.remove = function (f, l) {
-		var s = "";
-		if (this.arrConcat) {
-			b = a.join("");
+
+	this.remove = function(f,l){
+		var s = ""; 
+		if(this.arrConcat){
+			b = a.join(""); 
 		}
-		a = [];
-		if (f > 0) {
-			s = b.substring(0, (f - 1));
+		a=[];
+		if(f>0){
+			s = b.substring(0, (f-1));
 		}
-		b = s + b.substring(f + l);
-		length = this.length = b.length;
-		if (this.arrConcat) {
+		b = s + b.substring(f + l); 
+		length = this.length = b.length; 
+		if(this.arrConcat){
 			a.push(b);
-			b = "";
+			b="";
 		}
 		return this;
 	};
-	this.replace = function (o, n) {
-		if (this.arrConcat) {
-			b = a.join("");
+
+	this.replace = function(o,n){
+		if(this.arrConcat){
+			b = a.join(""); 
 		}
-		a = [];
-		b = b.replace(o, n);
-		length = this.length = b.length;
-		if (this.arrConcat) {
+		a = []; 
+		b = b.replace(o,n); 
+		length = this.length = b.length; 
+		if(this.arrConcat){
 			a.push(b);
-			b = "";
+			b="";
 		}
 		return this;
 	};
-	this.insert = function (idx, s) {
-		if (this.arrConcat) {
-			b = a.join("");
+
+	this.insert = function(idx,s){
+		if(this.arrConcat){
+			b = a.join(""); 
 		}
-		a = [];
-		if (idx == 0) {
+		a=[];
+		if(idx == 0){
 			b = s + b;
-		} else {
+		}else{
 			var t = b.split("");
-			t.splice(idx, 0, s);
-			b = t.join("");
+			t.splice(idx,0,s);
+			b = t.join("")
 		}
-		length = this.length = b.length;
-		if (this.arrConcat) {
-			a.push(b);
-			b = "";
+		length = this.length = b.length; 
+		if(this.arrConcat){
+			a.push(b); 
+			b="";
 		}
 		return this;
 	};
-	this.append.apply(this, arguments);
 };
-

Modified: tags/parley-0.53/root/static/magic/src/string/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/string/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/string/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,12 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.string", "dojo.string.common", "dojo.string.extras", "dojo.string.Builder"]});
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.string",
+		"dojo.string.common",
+		"dojo.string.extras",
+		"dojo.string.Builder"
+	]
+});
 dojo.provide("dojo.string.*");
-

Modified: tags/parley-0.53/root/static/magic/src/string/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/string/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/string/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,56 +8,80 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.string.common");
 
+dojo.require("dojo.string");
 
-dojo.provide("dojo.string.common");
-dojo.string.trim = function (str, wh) {
-	if (!str.replace) {
-		return str;
-	}
-	if (!str.length) {
-		return str;
-	}
+/**
+ * Trim whitespace from 'str'. If 'wh' > 0,
+ * only trim from start, if 'wh' < 0, only trim
+ * from end, otherwise trim both ends
+ */
+dojo.string.trim = function(str, wh){
+	if(!str.replace){ return str; }
+	if(!str.length){ return str; }
 	var re = (wh > 0) ? (/^\s+/) : (wh < 0) ? (/\s+$/) : (/^\s+|\s+$/g);
 	return str.replace(re, "");
-};
-dojo.string.trimStart = function (str) {
+}
+
+/**
+ * Trim whitespace at the beginning of 'str'
+ */
+dojo.string.trimStart = function(str) {
 	return dojo.string.trim(str, 1);
-};
-dojo.string.trimEnd = function (str) {
+}
+
+/**
+ * Trim whitespace at the end of 'str'
+ */
+dojo.string.trimEnd = function(str) {
 	return dojo.string.trim(str, -1);
-};
-dojo.string.repeat = function (str, count, separator) {
+}
+
+/**
+ * Return 'str' repeated 'count' times, optionally
+ * placing 'separator' between each rep
+ */
+dojo.string.repeat = function(str, count, separator) {
 	var out = "";
-	for (var i = 0; i < count; i++) {
+	for(var i = 0; i < count; i++) {
 		out += str;
-		if (separator && i < count - 1) {
+		if(separator && i < count - 1) {
 			out += separator;
 		}
 	}
 	return out;
-};
-dojo.string.pad = function (str, len, c, dir) {
+}
+
+/**
+ * Pad 'str' to guarantee that it is at least 'len' length
+ * with the character 'c' at either the start (dir=1) or
+ * end (dir=-1) of the string
+ */
+dojo.string.pad = function(str, len/*=2*/, c/*='0'*/, dir/*=1*/) {
 	var out = String(str);
-	if (!c) {
-		c = "0";
+	if(!c) {
+		c = '0';
 	}
-	if (!dir) {
+	if(!dir) {
 		dir = 1;
 	}
-	while (out.length < len) {
-		if (dir > 0) {
+	while(out.length < len) {
+		if(dir > 0) {
 			out = c + out;
 		} else {
 			out += c;
 		}
 	}
 	return out;
-};
-dojo.string.padLeft = function (str, len, c) {
+}
+
+/** same as dojo.string.pad(str, len, c, 1) */
+dojo.string.padLeft = function(str, len, c) {
 	return dojo.string.pad(str, len, c, 1);
-};
-dojo.string.padRight = function (str, len, c) {
+}
+
+/** same as dojo.string.pad(str, len, c, -1) */
+dojo.string.padRight = function(str, len, c) {
 	return dojo.string.pad(str, len, c, -1);
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/string/extras.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/string/extras.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/string/extras.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,165 +8,225 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.string.extras");
 
+dojo.require("dojo.string.common");
+dojo.require("dojo.lang");
 
-dojo.provide("dojo.string.extras");
-dojo.require("dojo.string.common");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.array");
-dojo.string.substituteParams = function (template, hash) {
-	var map = (typeof hash == "object") ? hash : dojo.lang.toArray(arguments, 1);
-	return template.replace(/\%\{(\w+)\}/g, function (match, key) {
-		if (typeof (map[key]) != "undefined" && map[key] != null) {
-			return map[key];
-		}
-		dojo.raise("Substitution not found: " + key);
+/**
+ * Performs parameterized substitutions on a string.  For example,
+ *   dojo.string.substituteParams("File '%{0}' is not found in directory '%{1}'.","foo.html","/temp");
+ * returns
+ *   "File 'foo.html' is not found in directory '/temp'."
+ * 
+ * @param template the original string template with %{values} to be replaced
+ * @param hash name/value pairs (type object) to provide substitutions.  Alternatively, substitutions may be
+ *  included as arguments 1..n to this function, corresponding to template parameters 0..n-1
+ * @return the completed string. Throws an exception if any parameter is unmatched
+ */
+//TODO: use ${} substitution syntax instead, like widgets do?
+dojo.string.substituteParams = function(template /*string */, hash /* object - optional or ... */) {
+	var map = (typeof hash == 'object') ? hash : dojo.lang.toArray(arguments, 1);
+
+	return template.replace(/\%\{(\w+)\}/g, function(match, key){
+		return map[key] || dojo.raise("Substitution not found: " + key);
 	});
 };
+
+/**
+ * Parameterized string function
+ * str - formatted string with %{values} to be replaces
+ * pairs - object of name: "value" value pairs
+ * killExtra - remove all remaining %{values} after pairs are inserted
+ */
+dojo.string.paramString = function(str, pairs, killExtra) {
+	dojo.deprecated("dojo.string.paramString",
+		"use dojo.string.substituteParams instead", "0.4");
+
+	for(var name in pairs) {
+		var re = new RegExp("\\%\\{" + name + "\\}", "g");
+		str = str.replace(re, pairs[name]);
+	}
+
+	if(killExtra) { str = str.replace(/%\{([^\}\s]+)\}/g, ""); }
+	return str;
+}
+
+/** Uppercases the first letter of each word */
 dojo.string.capitalize = function (str) {
-	if (!dojo.lang.isString(str)) {
-		return "";
-	}
-	if (arguments.length == 0) {
-		str = this;
-	}
-	var words = str.split(" ");
-	for (var i = 0; i < words.length; i++) {
+	if (!dojo.lang.isString(str)) { return ""; }
+	if (arguments.length == 0) { str = this; }
+
+	var words = str.split(' ');
+	for(var i=0; i<words.length; i++){
 		words[i] = words[i].charAt(0).toUpperCase() + words[i].substring(1);
 	}
 	return words.join(" ");
-};
+}
+
+/**
+ * Return true if the entire string is whitespace characters
+ */
 dojo.string.isBlank = function (str) {
-	if (!dojo.lang.isString(str)) {
-		return true;
-	}
+	if(!dojo.lang.isString(str)) { return true; }
 	return (dojo.string.trim(str).length == 0);
-};
-dojo.string.encodeAscii = function (str) {
-	if (!dojo.lang.isString(str)) {
-		return str;
-	}
+}
+
+dojo.string.encodeAscii = function(str) {
+	if(!dojo.lang.isString(str)) { return str; }
 	var ret = "";
 	var value = escape(str);
 	var match, re = /%u([0-9A-F]{4})/i;
-	while ((match = value.match(re))) {
-		var num = Number("0x" + match[1]);
+	while((match = value.match(re))) {
+		var num = Number("0x"+match[1]);
 		var newVal = escape("&#" + num + ";");
 		ret += value.substring(0, match.index) + newVal;
-		value = value.substring(match.index + match[0].length);
+		value = value.substring(match.index+match[0].length);
 	}
 	ret += value.replace(/\+/g, "%2B");
 	return ret;
-};
-dojo.string.escape = function (type, str) {
+}
+
+dojo.string.escape = function(type, str) {
 	var args = dojo.lang.toArray(arguments, 1);
-	switch (type.toLowerCase()) {
-	  case "xml":
-	  case "html":
-	  case "xhtml":
-		return dojo.string.escapeXml.apply(this, args);
-	  case "sql":
-		return dojo.string.escapeSql.apply(this, args);
-	  case "regexp":
-	  case "regex":
-		return dojo.string.escapeRegExp.apply(this, args);
-	  case "javascript":
-	  case "jscript":
-	  case "js":
-		return dojo.string.escapeJavaScript.apply(this, args);
-	  case "ascii":
-		return dojo.string.encodeAscii.apply(this, args);
-	  default:
-		return str;
+	switch(type.toLowerCase()) {
+		case "xml":
+		case "html":
+		case "xhtml":
+			return dojo.string.escapeXml.apply(this, args);
+		case "sql":
+			return dojo.string.escapeSql.apply(this, args);
+		case "regexp":
+		case "regex":
+			return dojo.string.escapeRegExp.apply(this, args);
+		case "javascript":
+		case "jscript":
+		case "js":
+			return dojo.string.escapeJavaScript.apply(this, args);
+		case "ascii":
+			// so it's encode, but it seems useful
+			return dojo.string.encodeAscii.apply(this, args);
+		default:
+			return str;
 	}
-};
-dojo.string.escapeXml = function (str, noSingleQuotes) {
-	str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;").replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
-	if (!noSingleQuotes) {
-		str = str.replace(/'/gm, "&#39;");
-	}
+}
+
+dojo.string.escapeXml = function(str, noSingleQuotes) {
+	str = str.replace(/&/gm, "&amp;").replace(/</gm, "&lt;")
+		.replace(/>/gm, "&gt;").replace(/"/gm, "&quot;");
+	if(!noSingleQuotes) { str = str.replace(/'/gm, "&#39;"); }
 	return str;
-};
-dojo.string.escapeSql = function (str) {
+}
+
+dojo.string.escapeSql = function(str) {
 	return str.replace(/'/gm, "''");
-};
-dojo.string.escapeRegExp = function (str) {
+}
+
+dojo.string.escapeRegExp = function(str) {
 	return str.replace(/\\/gm, "\\\\").replace(/([\f\b\n\t\r[\^$|?*+(){}])/gm, "\\$1");
-};
-dojo.string.escapeJavaScript = function (str) {
+}
+
+dojo.string.escapeJavaScript = function(str) {
 	return str.replace(/(["'\f\b\n\t\r])/gm, "\\$1");
-};
-dojo.string.escapeString = function (str) {
-	return ("\"" + str.replace(/(["\\])/g, "\\$1") + "\"").replace(/[\f]/g, "\\f").replace(/[\b]/g, "\\b").replace(/[\n]/g, "\\n").replace(/[\t]/g, "\\t").replace(/[\r]/g, "\\r");
-};
-dojo.string.summary = function (str, len) {
-	if (!len || str.length <= len) {
+}
+
+dojo.string.escapeString = function(str){ 
+	return ('"' + str.replace(/(["\\])/g, '\\$1') + '"'
+		).replace(/[\f]/g, "\\f"
+		).replace(/[\b]/g, "\\b"
+		).replace(/[\n]/g, "\\n"
+		).replace(/[\t]/g, "\\t"
+		).replace(/[\r]/g, "\\r");
+}
+
+// TODO: make an HTML version
+dojo.string.summary = function(str, len) {
+	if(!len || str.length <= len) {
 		return str;
+	} else {
+		return str.substring(0, len).replace(/\.+$/, "") + "...";
 	}
-	return str.substring(0, len).replace(/\.+$/, "") + "...";
-};
-dojo.string.endsWith = function (str, end, ignoreCase) {
-	if (ignoreCase) {
+}
+
+/**
+ * Returns true if 'str' ends with 'end'
+ */
+dojo.string.endsWith = function(str, end, ignoreCase) {
+	if(ignoreCase) {
 		str = str.toLowerCase();
 		end = end.toLowerCase();
 	}
-	if ((str.length - end.length) < 0) {
+	if((str.length - end.length) < 0){
 		return false;
 	}
 	return str.lastIndexOf(end) == str.length - end.length;
-};
-dojo.string.endsWithAny = function (str) {
-	for (var i = 1; i < arguments.length; i++) {
-		if (dojo.string.endsWith(str, arguments[i])) {
+}
+
+/**
+ * Returns true if 'str' ends with any of the arguments[2 -> n]
+ */
+dojo.string.endsWithAny = function(str /* , ... */) {
+	for(var i = 1; i < arguments.length; i++) {
+		if(dojo.string.endsWith(str, arguments[i])) {
 			return true;
 		}
 	}
 	return false;
-};
-dojo.string.startsWith = function (str, start, ignoreCase) {
-	if (ignoreCase) {
+}
+
+/**
+ * Returns true if 'str' starts with 'start'
+ */
+dojo.string.startsWith = function(str, start, ignoreCase) {
+	if(ignoreCase) {
 		str = str.toLowerCase();
 		start = start.toLowerCase();
 	}
 	return str.indexOf(start) == 0;
-};
-dojo.string.startsWithAny = function (str) {
-	for (var i = 1; i < arguments.length; i++) {
-		if (dojo.string.startsWith(str, arguments[i])) {
+}
+
+/**
+ * Returns true if 'str' starts with any of the arguments[2 -> n]
+ */
+dojo.string.startsWithAny = function(str /* , ... */) {
+	for(var i = 1; i < arguments.length; i++) {
+		if(dojo.string.startsWith(str, arguments[i])) {
 			return true;
 		}
 	}
 	return false;
-};
-dojo.string.has = function (str) {
-	for (var i = 1; i < arguments.length; i++) {
-		if (str.indexOf(arguments[i]) > -1) {
+}
+
+/**
+ * Returns true if 'str' contains any of the arguments 2 -> n
+ */
+dojo.string.has = function(str /* , ... */) {
+	for(var i = 1; i < arguments.length; i++) {
+		if(str.indexOf(arguments[i]) > -1){
 			return true;
 		}
 	}
 	return false;
-};
-dojo.string.normalizeNewlines = function (text, newlineChar) {
+}
+
+dojo.string.normalizeNewlines = function (text,newlineChar) {
 	if (newlineChar == "\n") {
 		text = text.replace(/\r\n/g, "\n");
 		text = text.replace(/\r/g, "\n");
+	} else if (newlineChar == "\r") {
+		text = text.replace(/\r\n/g, "\r");
+		text = text.replace(/\n/g, "\r");
 	} else {
-		if (newlineChar == "\r") {
-			text = text.replace(/\r\n/g, "\r");
-			text = text.replace(/\n/g, "\r");
-		} else {
-			text = text.replace(/([^\r])\n/g, "$1\r\n").replace(/\r([^\n])/g, "\r\n$1");
-		}
+		text = text.replace(/([^\r])\n/g, "$1\r\n");
+		text = text.replace(/\r([^\n])/g, "\r\n$1");
 	}
 	return text;
-};
-dojo.string.splitEscaped = function (str, charac) {
+}
+
+dojo.string.splitEscaped = function (str,charac) {
 	var components = [];
 	for (var i = 0, prevcomma = 0; i < str.length; i++) {
-		if (str.charAt(i) == "\\") {
-			i++;
-			continue;
-		}
+		if (str.charAt(i) == '\\') { i++; continue; }
 		if (str.charAt(i) == charac) {
 			components.push(str.substring(prevcomma, i));
 			prevcomma = i + 1;
@@ -174,5 +234,4 @@
 	}
 	components.push(str.substr(prevcomma));
 	return components;
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/string.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/string.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/string.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,5 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.string");
 dojo.require("dojo.string.common");
-

Modified: tags/parley-0.53/root/static/magic/src/style.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/style.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/style.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,11 +8,819 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.style");
+dojo.require("dojo.graphics.color");
+dojo.require("dojo.uri.Uri");
 dojo.require("dojo.lang.common");
-dojo.kwCompoundRequire({browser:["dojo.html.style"]});
-dojo.deprecated("dojo.style", "replaced by dojo.html.style", "0.5");
-dojo.lang.mixin(dojo.style, dojo.html);
 
+(function(){
+	var h = dojo.render.html;
+	var ds = dojo.style;
+	var db = document["body"]||document["documentElement"];
+
+	ds.boxSizing = {
+		MARGIN_BOX: "margin-box",
+		BORDER_BOX: "border-box",
+		PADDING_BOX: "padding-box",
+		CONTENT_BOX: "content-box"
+	};
+	var bs = ds.boxSizing;
+	
+	ds.getBoxSizing = function(node){
+		if((h.ie)||(h.opera)){ 
+			var cm = document["compatMode"];
+			if((cm == "BackCompat")||(cm == "QuirksMode")){ 
+				return bs.BORDER_BOX; 
+			}else{
+				return bs.CONTENT_BOX; 
+			}
+		}else{
+			if(arguments.length == 0){ node = document.documentElement; }
+			var sizing = ds.getStyle(node, "-moz-box-sizing");
+			if(!sizing){ sizing = ds.getStyle(node, "box-sizing"); }
+			return (sizing ? sizing : bs.CONTENT_BOX);
+		}
+	}
+
+	/*
+
+	The following several function use the dimensions shown below
+
+		+-------------------------+
+		|  margin                 |
+		| +---------------------+ |
+		| |  border             | |
+		| | +-----------------+ | |
+		| | |  padding        | | |
+		| | | +-------------+ | | |
+		| | | |   content   | | | |
+		| | | +-------------+ | | |
+		| | +-|-------------|-+ | |
+		| +-|-|-------------|-|-+ |
+		+-|-|-|-------------|-|-|-+
+		| | | |             | | | |
+		| | | |<- content ->| | | |
+		| |<------ inner ------>| |
+		|<-------- outer -------->|
+		+-------------------------+
+
+		* content-box
+
+		|m|b|p|             |p|b|m|
+		| |<------ offset ----->| |
+		| | |<---- client --->| | |
+		| | | |<-- width -->| | | |
+
+		* border-box
+
+		|m|b|p|             |p|b|m|
+		| |<------ offset ----->| |
+		| | |<---- client --->| | |
+		| |<------ width ------>| |
+	*/
+
+	/*
+		Notes:
+
+		General:
+			- Uncomputable values are returned as NaN.
+			- setOuterWidth/Height return *false* if the outer size could not
+			  be computed, otherwise *true*.
+			- (sjmiles) knows no way to find the calculated values for auto-margins. 
+			- All returned values are floating point in 'px' units. If a
+			  non-zero computed style value is not specified in 'px', NaN is
+			  returned.
+
+		FF:
+			- styles specified as '0' (unitless 0) show computed as '0pt'.
+
+		IE:
+			- clientWidth/Height are unreliable (0 unless the object has 'layout').
+			- margins must be specified in px, or 0 (in any unit) for any
+			  sizing function to work. Otherwise margins detect as 'auto'.
+			- padding can be empty or, if specified, must be in px, or 0 (in
+			  any unit) for any sizing function to work.
+
+		Safari:
+			- Safari defaults padding values to 'auto'.
+
+		See the unit tests for examples of (un)computable values in a given browser.
+
+	*/
+
+	// FIXME: these work for some elements (e.g. DIV) but not others (e.g. TABLE, TEXTAREA)
+
+	ds.isBorderBox = function(node){
+		return (ds.getBoxSizing(node) == bs.BORDER_BOX);
+	}
+
+	ds.getUnitValue = function(node, cssSelector, autoIsZero){
+		var s = ds.getComputedStyle(node, cssSelector);
+		if((!s)||((s == 'auto')&&(autoIsZero))){ return { value: 0, units: 'px' }; }
+		if(dojo.lang.isUndefined(s)){return ds.getUnitValue.bad;}
+		// FIXME: is regex inefficient vs. parseInt or some manual test? 
+		var match = s.match(/(\-?[\d.]+)([a-z%]*)/i);
+		if (!match){return ds.getUnitValue.bad;}
+		return { value: Number(match[1]), units: match[2].toLowerCase() };
+	}
+	// FIXME: 'bad' value should be 0?
+	ds.getUnitValue.bad = { value: NaN, units: '' };
+	
+	ds.getPixelValue = function(node, cssSelector, autoIsZero){
+		var result = ds.getUnitValue(node, cssSelector, autoIsZero);
+		// FIXME: there is serious debate as to whether or not this is the right solution
+		if(isNaN(result.value)){ return 0; }
+		// FIXME: code exists for converting other units to px (see Dean Edward's IE7) 
+		// but there are cross-browser complexities
+		if((result.value)&&(result.units != 'px')){ return NaN; }
+		return result.value;
+	}
+	
+	// FIXME: deprecated
+	ds.getNumericStyle = function() {
+		dojo.deprecated('dojo.(style|html).getNumericStyle', 'in favor of dojo.(style|html).getPixelValue', '0.4');
+		return ds.getPixelValue.apply(this, arguments); 
+	}
+
+	ds.setPositivePixelValue = function(node, selector, value){
+		if(isNaN(value)){return false;}
+		node.style[selector] = Math.max(0, value) + 'px'; 
+		return true;
+	}
+	
+	ds._sumPixelValues = function(node, selectors, autoIsZero){
+		var total = 0;
+		for(var x=0; x<selectors.length; x++){
+			total += ds.getPixelValue(node, selectors[x], autoIsZero);
+		}
+		return total;
+	}
+
+	ds.isPositionAbsolute = function(node){
+		return (ds.getComputedStyle(node, 'position') == 'absolute');
+	}
+
+	ds.getBorderExtent = function(node, side){
+		return (ds.getStyle(node, 'border-' + side + '-style') == 'none' ? 0 : ds.getPixelValue(node, 'border-' + side + '-width'));
+	}
+
+	ds.getMarginWidth = function(node){
+		return ds._sumPixelValues(node, ["margin-left", "margin-right"], ds.isPositionAbsolute(node));
+	}
+
+	ds.getBorderWidth = function(node){
+		return ds.getBorderExtent(node, 'left') + ds.getBorderExtent(node, 'right');
+	}
+
+	ds.getPaddingWidth = function(node){
+		return ds._sumPixelValues(node, ["padding-left", "padding-right"], true);
+	}
+
+	ds.getPadBorderWidth = function(node) {
+		return ds.getPaddingWidth(node) + ds.getBorderWidth(node);
+	}
+	
+	ds.getContentBoxWidth = function(node){
+		node = dojo.byId(node);
+		return node.offsetWidth - ds.getPadBorderWidth(node);
+	}
+
+	ds.getBorderBoxWidth = function(node){
+		node = dojo.byId(node);
+		return node.offsetWidth;
+	}
+
+	ds.getMarginBoxWidth = function(node){
+		return ds.getInnerWidth(node) + ds.getMarginWidth(node);
+	}
+
+	ds.setContentBoxWidth = function(node, pxWidth){
+		node = dojo.byId(node);
+		if (ds.isBorderBox(node)){
+			pxWidth += ds.getPadBorderWidth(node);
+		}
+		return ds.setPositivePixelValue(node, "width", pxWidth);
+	}
+
+	ds.setMarginBoxWidth = function(node, pxWidth){
+		node = dojo.byId(node);
+		if (!ds.isBorderBox(node)){
+			pxWidth -= ds.getPadBorderWidth(node);
+		}
+		pxWidth -= ds.getMarginWidth(node);
+		return ds.setPositivePixelValue(node, "width", pxWidth);
+	}
+
+	// FIXME: deprecate and remove
+	ds.getContentWidth = ds.getContentBoxWidth;
+	ds.getInnerWidth = ds.getBorderBoxWidth;
+	ds.getOuterWidth = ds.getMarginBoxWidth;
+	ds.setContentWidth = ds.setContentBoxWidth;
+	ds.setOuterWidth = ds.setMarginBoxWidth;
+
+	ds.getMarginHeight = function(node){
+		return ds._sumPixelValues(node, ["margin-top", "margin-bottom"], ds.isPositionAbsolute(node));
+	}
+
+	ds.getBorderHeight = function(node){
+		return ds.getBorderExtent(node, 'top') + ds.getBorderExtent(node, 'bottom');
+	}
+
+	ds.getPaddingHeight = function(node){
+		return ds._sumPixelValues(node, ["padding-top", "padding-bottom"], true);
+	}
+
+	ds.getPadBorderHeight = function(node) {
+		return ds.getPaddingHeight(node) + ds.getBorderHeight(node);
+	}
+	
+	ds.getContentBoxHeight = function(node){
+		node = dojo.byId(node);
+		return node.offsetHeight - ds.getPadBorderHeight(node);
+	}
+
+	ds.getBorderBoxHeight = function(node){
+		node = dojo.byId(node);
+		return node.offsetHeight; // FIXME: does this work?
+	}
+
+	ds.getMarginBoxHeight = function(node){
+		return ds.getInnerHeight(node) + ds.getMarginHeight(node);
+	}
+
+	ds.setContentBoxHeight = function(node, pxHeight){
+		node = dojo.byId(node);
+		if (ds.isBorderBox(node)){
+			pxHeight += ds.getPadBorderHeight(node);
+		}
+		return ds.setPositivePixelValue(node, "height", pxHeight);
+	}
+
+	ds.setMarginBoxHeight = function(node, pxHeight){
+		node = dojo.byId(node);
+		if (!ds.isBorderBox(node)){
+			pxHeight -= ds.getPadBorderHeight(node);
+		}
+		pxHeight -= ds.getMarginHeight(node);
+		return ds.setPositivePixelValue(node, "height", pxHeight);
+	}
+
+	// FIXME: deprecate and remove
+	ds.getContentHeight = ds.getContentBoxHeight;
+	ds.getInnerHeight = ds.getBorderBoxHeight;
+	ds.getOuterHeight = ds.getMarginBoxHeight;
+	ds.setContentHeight = ds.setContentBoxHeight;
+	ds.setOuterHeight = ds.setMarginBoxHeight;
+
+	/**
+	 * dojo.style.getAbsolutePosition(xyz, true) returns xyz's position relative to the document.
+	 * Itells you where you would position a node
+	 * inside document.body such that it was on top of xyz.  Most people set the flag to true when calling
+	 * getAbsolutePosition().
+	 *
+	 * dojo.style.getAbsolutePosition(xyz, false) returns xyz's position relative to the viewport.
+	 * It returns the position that would be returned
+	 * by event.clientX/Y if the mouse were directly over the top/left of this node.
+	 */
+	ds.getAbsolutePosition = ds.abs = function(node, includeScroll){
+		node = dojo.byId(node);
+		var ret = [];
+		ret.x = ret.y = 0;
+		var st = dojo.html.getScrollTop();
+		var sl = dojo.html.getScrollLeft();
+
+		if(h.ie){
+			with(node.getBoundingClientRect()){
+				ret.x = left-2;
+				ret.y = top-2;
+			}
+		}else if(document.getBoxObjectFor){
+			// mozilla
+			var bo = document.getBoxObjectFor(node);
+			ret.x = bo.x - ds.sumAncestorProperties(node, "scrollLeft");
+			ret.y = bo.y - ds.sumAncestorProperties(node, "scrollTop");
+		}else{
+			if(node["offsetParent"]){
+				var endNode;		
+				// in Safari, if the node is an absolutely positioned child of
+				// the body and the body has a margin the offset of the child
+				// and the body contain the body's margins, so we need to end
+				// at the body
+				if(	(h.safari)&&
+					(node.style.getPropertyValue("position") == "absolute")&&
+					(node.parentNode == db)){
+					endNode = db;
+				}else{
+					endNode = db.parentNode;
+				}
+
+				if(node.parentNode != db){
+					var nd = node;
+					if(window.opera){ nd = db; }
+					ret.x -= ds.sumAncestorProperties(nd, "scrollLeft");
+					ret.y -= ds.sumAncestorProperties(nd, "scrollTop");
+				}
+				do{
+					var n = node["offsetLeft"];
+					ret.x += isNaN(n) ? 0 : n;
+					var m = node["offsetTop"];
+					ret.y += isNaN(m) ? 0 : m;
+					node = node.offsetParent;
+				}while((node != endNode)&&(node != null));
+			}else if(node["x"]&&node["y"]){
+				ret.x += isNaN(node.x) ? 0 : node.x;
+				ret.y += isNaN(node.y) ? 0 : node.y;
+			}
+		}
+
+		// account for document scrolling!
+		if(includeScroll){
+			ret.y += st;
+			ret.x += sl;
+		}
+
+		ret[0] = ret.x;
+		ret[1] = ret.y;
+		return ret;
+	}
+
+	ds.sumAncestorProperties = function(node, prop){
+		node = dojo.byId(node);
+		if(!node){ return 0; } // FIXME: throw an error?
+		
+		var retVal = 0;
+		while(node){
+			var val = node[prop];
+			if(val){
+				retVal += val - 0;
+				if(node==document.body){ break; }// opera and khtml #body & #html has the same values, we only need one value
+			}
+			node = node.parentNode;
+		}
+		return retVal;
+	}
+
+	ds.getTotalOffset = function(node, type, includeScroll){
+		return ds.abs(node, includeScroll)[(type == "top") ? "y" : "x"];
+	}
+
+	ds.getAbsoluteX = ds.totalOffsetLeft = function(node, includeScroll){
+		return ds.getTotalOffset(node, "left", includeScroll);
+	}
+
+	ds.getAbsoluteY = ds.totalOffsetTop = function(node, includeScroll){
+		return ds.getTotalOffset(node, "top", includeScroll);
+	}
+
+	ds.styleSheet = null;
+
+	// FIXME: this is a really basic stub for adding and removing cssRules, but
+	// it assumes that you know the index of the cssRule that you want to add 
+	// or remove, making it less than useful.  So we need something that can 
+	// search for the selector that you you want to remove.
+	ds.insertCssRule = function(selector, declaration, index) {
+		if (!ds.styleSheet) {
+			if (document.createStyleSheet) { // IE
+				ds.styleSheet = document.createStyleSheet();
+			} else if (document.styleSheets[0]) { // rest
+				// FIXME: should create a new style sheet here
+				// fall back on an exsiting style sheet
+				ds.styleSheet = document.styleSheets[0];
+			} else { return null; } // fail
+		}
+
+		if (arguments.length < 3) { // index may == 0
+			if (ds.styleSheet.cssRules) { // W3
+				index = ds.styleSheet.cssRules.length;
+			} else if (ds.styleSheet.rules) { // IE
+				index = ds.styleSheet.rules.length;
+			} else { return null; } // fail
+		}
+
+		if (ds.styleSheet.insertRule) { // W3
+			var rule = selector + " { " + declaration + " }";
+			return ds.styleSheet.insertRule(rule, index);
+		} else if (ds.styleSheet.addRule) { // IE
+			return ds.styleSheet.addRule(selector, declaration, index);
+		} else { return null; } // fail
+	}
+
+	ds.removeCssRule = function(index){
+		if(!ds.styleSheet){
+			dojo.debug("no stylesheet defined for removing rules");
+			return false;
+		}
+		if(h.ie){
+			if(!index){
+				index = ds.styleSheet.rules.length;
+				ds.styleSheet.removeRule(index);
+			}
+		}else if(document.styleSheets[0]){
+			if(!index){
+				index = ds.styleSheet.cssRules.length;
+			}
+			ds.styleSheet.deleteRule(index);
+		}
+		return true;
+	}
+
+	// calls css by XmlHTTP and inserts it into DOM as <style [widgetType="widgetType"]> *downloaded cssText*</style>
+	ds.insertCssFile = function(URI, doc, checkDuplicates){
+		if(!URI){ return; }
+		if(!doc){ doc = document; }
+		var cssStr = dojo.hostenv.getText(URI);
+		cssStr = ds.fixPathsInCssText(cssStr, URI);
+
+		if(checkDuplicates){
+			var styles = doc.getElementsByTagName("style");
+			var cssText = "";
+			for(var i = 0; i<styles.length; i++){
+				cssText = (styles[i].styleSheet && styles[i].styleSheet.cssText) ? styles[i].styleSheet.cssText : styles[i].innerHTML;
+				if(cssStr == cssText){ return; }
+			}
+		}
+
+		var style = ds.insertCssText(cssStr);
+		// insert custom attribute ex dbgHref="../foo.css" usefull when debugging in DOM inspectors, no?
+		if(style && djConfig.isDebug){
+			style.setAttribute("dbgHref", URI);
+		}
+		return style
+	}
+
+	// DomNode Style  = insertCssText(String ".dojoMenu {color: green;}"[, DomDoc document, dojo.uri.Uri Url ])
+	ds.insertCssText = function(cssStr, doc, URI){
+		if(!cssStr){ return; }
+		if(!doc){ doc = document; }
+		if(URI){// fix paths in cssStr
+			cssStr = ds.fixPathsInCssText(cssStr, URI);
+		}
+		var style = doc.createElement("style");
+		style.setAttribute("type", "text/css");
+		// IE is b0rken enough to require that we add the element to the doc
+		// before changing it's properties
+		var head = doc.getElementsByTagName("head")[0];
+		if(!head){ // must have a head tag 
+			dojo.debug("No head tag in document, aborting styles");
+			return;
+		}else{
+			head.appendChild(style);
+		}
+		if(style.styleSheet){// IE
+			style.styleSheet.cssText = cssStr;
+		}else{ // w3c
+			var cssText = doc.createTextNode(cssStr);
+			style.appendChild(cssText);
+		}
+		return style;
+	}
+
+	// String cssText = fixPathsInCssText(String cssStr, dojo.uri.Uri URI)
+	// usage: cssText comes from dojoroot/src/widget/templates/HtmlFoobar.css
+	// 	it has .dojoFoo { background-image: url(images/bar.png);} 
+	//	then uri should point to dojoroot/src/widget/templates/
+	ds.fixPathsInCssText = function(cssStr, URI){
+		if(!cssStr || !URI){ return; }
+		var pos = 0; var str = ""; var url = "";
+		while(pos!=-1){
+			pos = 0;url = "";
+			pos = cssStr.indexOf("url(", pos);
+			if(pos<0){ break; }
+			str += cssStr.slice(0,pos+4);
+			cssStr = cssStr.substring(pos+4, cssStr.length);
+			url += cssStr.match(/^[\t\s\w()\/.\\'"-:#=&?]*\)/)[0]; // url string
+			cssStr = cssStr.substring(url.length-1, cssStr.length); // remove url from css string til next loop
+			url = url.replace(/^[\s\t]*(['"]?)([\w()\/.\\'"-:#=&?]*)\1[\s\t]*?\)/,"$2"); // clean string
+			if(url.search(/(file|https?|ftps?):\/\//)==-1){
+				url = (new dojo.uri.Uri(URI,url).toString());
+			}
+			str += url;
+		};
+		return str+cssStr;
+	}
+
+	ds.getBackgroundColor = function(node) {
+		node = dojo.byId(node);
+		var color;
+		do{
+			color = ds.getStyle(node, "background-color");
+			// Safari doesn't say "transparent"
+			if(color.toLowerCase() == "rgba(0, 0, 0, 0)") { color = "transparent"; }
+			if(node == document.getElementsByTagName("body")[0]) { node = null; break; }
+			node = node.parentNode;
+		}while(node && dojo.lang.inArray(color, ["transparent", ""]));
+		if(color == "transparent"){
+			color = [255, 255, 255, 0];
+		}else{
+			color = dojo.graphics.color.extractRGB(color);
+		}
+		return color;
+	}
+
+	ds.getComputedStyle = function(node, cssSelector, inValue){
+		node = dojo.byId(node);
+		// cssSelector may actually be in camel case, so force selector version
+		var cssSelector = ds.toSelectorCase(cssSelector);
+		var property = ds.toCamelCase(cssSelector);
+		if(!node || !node.style){
+			return inValue;
+		}else if(document.defaultView){ // W3, gecko, KHTML
+			try{			
+				var cs = document.defaultView.getComputedStyle(node, "");
+				if (cs){ 
+					return cs.getPropertyValue(cssSelector);
+				} 
+			}catch(e){ // reports are that Safari can throw an exception above
+				if (node.style.getPropertyValue){ // W3
+					return node.style.getPropertyValue(cssSelector);
+				}else return inValue;
+			}
+		}else if(node.currentStyle){ // IE
+			return node.currentStyle[property];
+		}if(node.style.getPropertyValue){ // W3
+			return node.style.getPropertyValue(cssSelector);
+		}else{
+			return inValue;
+		}
+	}
+
+	/** 
+	 * Retrieve a property value from a node's style object.
+	 */
+	ds.getStyleProperty = function(node, cssSelector){
+		node = dojo.byId(node);
+		// FIXME: should we use node.style.getPropertyValue over style[property]?
+		// style[property] works in all (modern) browsers, getPropertyValue is W3 but not supported in IE
+		// FIXME: what about runtimeStyle?
+		return (node && node.style ? node.style[ds.toCamelCase(cssSelector)] : undefined);
+	}
+
+	/** 
+	 * Retrieve a property value from a node's style object.
+	 */
+	ds.getStyle = function(node, cssSelector){
+		var value = ds.getStyleProperty(node, cssSelector);
+		return (value ? value : ds.getComputedStyle(node, cssSelector));
+	}
+
+	ds.setStyle = function(node, cssSelector, value){
+		node = dojo.byId(node);
+		if(node && node.style){
+			var camelCased = ds.toCamelCase(cssSelector);
+			node.style[camelCased] = value;
+		}
+	}
+
+	ds.toCamelCase = function(selector) {
+		var arr = selector.split('-'), cc = arr[0];
+		for(var i = 1; i < arr.length; i++) {
+			cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
+		}
+		return cc;		
+	}
+
+	ds.toSelectorCase = function(selector) {
+		return selector.replace(/([A-Z])/g, "-$1" ).toLowerCase() ;
+	}
+
+	/* float between 0.0 (transparent) and 1.0 (opaque) */
+	ds.setOpacity = function setOpacity(node, opacity, dontFixOpacity) {
+		node = dojo.byId(node);
+		if(!dontFixOpacity){
+			if( opacity >= 1.0){
+				if(h.ie){
+					ds.clearOpacity(node);
+					return;
+				}else{
+					opacity = 0.999999;
+				}
+			}else if( opacity < 0.0){ opacity = 0; }
+		}
+		if(h.ie){
+			if(node.nodeName.toLowerCase() == "tr"){
+				// FIXME: is this too naive? will we get more than we want?
+				var tds = node.getElementsByTagName("td");
+				for(var x=0; x<tds.length; x++){
+					tds[x].style.filter = "Alpha(Opacity="+opacity*100+")";
+				}
+			}
+			node.style.filter = "Alpha(Opacity="+opacity*100+")";
+		}else if(h.moz){
+			node.style.opacity = opacity; // ffox 1.0 directly supports "opacity"
+			node.style.MozOpacity = opacity;
+		}else if(h.safari){
+			node.style.opacity = opacity; // 1.3 directly supports "opacity"
+			node.style.KhtmlOpacity = opacity;
+		}else{
+			node.style.opacity = opacity;
+		}
+	}
+		
+	ds.getOpacity = function getOpacity (node){
+		node = dojo.byId(node);
+		if(h.ie){
+			var opac = (node.filters && node.filters.alpha &&
+				typeof node.filters.alpha.opacity == "number"
+				? node.filters.alpha.opacity : 100) / 100;
+		}else{
+			var opac = node.style.opacity || node.style.MozOpacity ||
+				node.style.KhtmlOpacity || 1;
+		}
+		return opac >= 0.999999 ? 1.0 : Number(opac);
+	}
+
+	ds.clearOpacity = function clearOpacity(node){
+		node = dojo.byId(node);
+		var ns = node.style;
+		if(h.ie){
+			try {
+				if( node.filters && node.filters.alpha ){
+					ns.filter = ""; // FIXME: may get rid of other filter effects
+				}
+			} catch(e) {
+				/*
+				 * IE7 gives error if node.filters not set;
+				 * don't know why or how to workaround (other than this)
+				 */
+			}
+		}else if(h.moz){
+			ns.opacity = 1;
+			ns.MozOpacity = 1;
+		}else if(h.safari){
+			ns.opacity = 1;
+			ns.KhtmlOpacity = 1;
+		}else{
+			ns.opacity = 1;
+		}
+	}
+
+	/** 
+	* Set the given style attributes for the node. 
+	* Patch submitted by Wolfram Kriesing, 22/03/2006.
+	*
+	* Ie. dojo.style.setStyleAttributes(myNode, "position:absolute; left:10px; top:10px;") 
+	* This just makes it easier to set a style directly without the need to  
+	* override it completely (as node.setAttribute() would). 
+	* If there is a dojo-method for an attribute, like for "opacity" there 
+	* is setOpacity, the dojo method is called instead. 
+	* For example: dojo.style.setStyleAttributes(myNode, "opacity: .4"); 
+	*  
+	* Additionally all the dojo.style.set* methods can also be used. 
+	* Ie. when attributes contains "outer-height: 10;" it will call dojo.style.setOuterHeight("10"); 
+	* 
+	* @param object The node to set the style attributes for. 
+	* @param string Ie. "position:absolute; left:10px; top:10px;" 
+	*/ 
+	ds.setStyleAttributes = function(node, attributes) { 
+		var methodMap={ 
+			"opacity":dojo.style.setOpacity,
+			"content-height":dojo.style.setContentHeight,
+			"content-width":dojo.style.setContentWidth,
+			"outer-height":dojo.style.setOuterHeight,
+			"outer-width":dojo.style.setOuterWidth 
+		} 
+
+		var splittedAttribs=attributes.replace(/(;)?\s*$/, "").split(";"); 
+		for(var i=0; i<splittedAttribs.length; i++){ 
+			var nameValue=splittedAttribs[i].split(":"); 
+			var name=nameValue[0].replace(/\s*$/, "").replace(/^\s*/, "").toLowerCase();
+			var value=nameValue[1].replace(/\s*$/, "").replace(/^\s*/, "");
+			if(dojo.lang.has(methodMap,name)) { 
+				methodMap[name](node,value); 
+			} else { 
+				node.style[dojo.style.toCamelCase(name)]=value; 
+			} 
+		} 
+	} 
+
+	ds._toggle = function(node, tester, setter){
+		node = dojo.byId(node);
+		setter(node, !tester(node));
+		return tester(node);
+	}
+
+	// show/hide are library constructs
+
+	// show() 
+	// if the node.style.display == 'none' then 
+	// set style.display to '' or the value cached by hide()
+	ds.show = function(node){
+		node = dojo.byId(node);
+		if(ds.getStyleProperty(node, 'display')=='none'){
+			ds.setStyle(node, 'display', (node.dojoDisplayCache||''));
+			node.dojoDisplayCache = undefined;	// cannot use delete on a node in IE6
+		}
+	}
+
+	// if the node.style.display == 'none' then 
+	// set style.display to '' or the value cached by hide()
+	ds.hide = function(node){
+		node = dojo.byId(node);
+		if(typeof node["dojoDisplayCache"] == "undefined"){ // it could == '', so we cannot say !node.dojoDisplayCount
+			var d = ds.getStyleProperty(node, 'display')
+			if(d!='none'){
+				node.dojoDisplayCache = d;
+			}
+		}
+		ds.setStyle(node, 'display', 'none');
+	}
+
+	// setShowing() calls show() if showing is true, hide() otherwise
+	ds.setShowing = function(node, showing){
+		ds[(showing ? 'show' : 'hide')](node);
+	}
+
+	// isShowing() is true if the node.style.display is not 'none'
+	// FIXME: returns true if node is bad, isHidden would be easier to make correct
+	ds.isShowing = function(node){
+		return (ds.getStyleProperty(node, 'display') != 'none');
+	}
+
+	// Call setShowing() on node with the complement of isShowing(), then return the new value of isShowing()
+	ds.toggleShowing = function(node){
+		return ds._toggle(node, ds.isShowing, ds.setShowing);
+	}
+
+	// display is a CSS concept
+
+	// Simple mapping of tag names to display values
+	// FIXME: simplistic 
+	ds.displayMap = { tr: '', td: '', th: '', img: 'inline', span: 'inline', input: 'inline', button: 'inline' };
+
+	// Suggest a value for the display property that will show 'node' based on it's tag
+	ds.suggestDisplayByTagName = function(node)
+	{
+		node = dojo.byId(node);
+		if(node && node.tagName){
+			var tag = node.tagName.toLowerCase();
+			return (tag in ds.displayMap ? ds.displayMap[tag] : 'block');
+		}
+	}
+
+	// setDisplay() sets the value of style.display to value of 'display' parameter if it is a string.
+	// Otherwise, if 'display' is false, set style.display to 'none'.
+	// Finally, set 'display' to a suggested display value based on the node's tag
+	ds.setDisplay = function(node, display){
+		ds.setStyle(node, 'display', (dojo.lang.isString(display) ? display : (display ? ds.suggestDisplayByTagName(node) : 'none')));
+	}
+
+	// isDisplayed() is true if the the computed display style for node is not 'none'
+	// FIXME: returns true if node is bad, isNotDisplayed would be easier to make correct
+	ds.isDisplayed = function(node){
+		return (ds.getComputedStyle(node, 'display') != 'none');
+	}
+
+	// Call setDisplay() on node with the complement of isDisplayed(), then
+	// return the new value of isDisplayed()
+	ds.toggleDisplay = function(node){
+		return ds._toggle(node, ds.isDisplayed, ds.setDisplay);
+	}
+
+	// visibility is a CSS concept
+
+	// setVisibility() sets the value of style.visibility to value of
+	// 'visibility' parameter if it is a string.
+	// Otherwise, if 'visibility' is false, set style.visibility to 'hidden'.
+	// Finally, set style.visibility to 'visible'.
+	ds.setVisibility = function(node, visibility){
+		ds.setStyle(node, 'visibility', (dojo.lang.isString(visibility) ? visibility : (visibility ? 'visible' : 'hidden')));
+	}
+
+	// isVisible() is true if the the computed visibility style for node is not 'hidden'
+	// FIXME: returns true if node is bad, isInvisible would be easier to make correct
+	ds.isVisible = function(node){
+		return (ds.getComputedStyle(node, 'visibility') != 'hidden');
+	}
+
+	// Call setVisibility() on node with the complement of isVisible(), then
+	// return the new value of isVisible()
+	ds.toggleVisibility = function(node){
+		return ds._toggle(node, ds.isVisible, ds.setVisibility);
+	}
+
+	// in: coordinate array [x,y,w,h] or dom node
+	// return: coordinate array
+	ds.toCoordinateArray = function(coords, includeScroll) {
+		if(dojo.lang.isArray(coords)){
+			// coords is already an array (of format [x,y,w,h]), just return it
+			while ( coords.length < 4 ) { coords.push(0); }
+			while ( coords.length > 4 ) { coords.pop(); }
+			var ret = coords;
+		} else {
+			// coords is an dom object (or dom object id); return it's coordinates
+			var node = dojo.byId(coords);
+			var pos = ds.getAbsolutePosition(node, includeScroll);
+			var ret = [
+				pos.x,
+				pos.y,
+				ds.getBorderBoxWidth(node),
+				ds.getBorderBoxHeight(node)
+			];
+		}
+		ret.x = ret[0];
+		ret.y = ret[1];
+		ret.w = ret[2];
+		ret.h = ret[3];
+		return ret;
+	};
+})();

Modified: tags/parley-0.53/root/static/magic/src/svg.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/svg.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/svg.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,252 +8,272 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.svg");
+dojo.require("dojo.lang");
+dojo.require("dojo.dom");
 
+dojo.lang.mixin(dojo.svg, dojo.dom);
 
-dojo.provide("dojo.svg");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.dom");
-dojo.mixin(dojo.svg, dojo.dom);
-dojo.svg.graphics = dojo.svg.g = new function (d) {
-	this.suspend = function () {
-		try {
-			d.documentElement.suspendRedraw(0);
-		}
-		catch (e) {
-		}
+dojo.svg.graphics=dojo.svg.g=new function(/* DomDocument */ d){
+	//	summary
+	//	Singleton to encapsulate SVG rendering functions.
+	this.suspend=function(){
+		//	summary
+		//	Suspend the rendering engine
+		try { d.documentElement.suspendRedraw(0); } catch(e){ }
 	};
-	this.resume = function () {
-		try {
-			d.documentElement.unsuspendRedraw(0);
-		}
-		catch (e) {
-		}
+	this.resume=function(){
+		//	summary
+		//	Resume the rendering engine
+		try { d.documentElement.unsuspendRedraw(0); } catch(e){ }
 	};
-	this.force = function () {
-		try {
-			d.documentElement.forceRedraw();
-		}
-		catch (e) {
-		}
+	this.force=function(){
+		//	summary
+		//	Force the render engine to redraw
+		try { d.documentElement.forceRedraw(); } catch(e){ }
 	};
 }(document);
-dojo.svg.animations = dojo.svg.anim = new function (d) {
-	this.arePaused = function () {
+
+dojo.svg.animations=dojo.svg.anim=new function(/* DOMDocument */ d){
+	//	summary
+	//	Singleton to encapsulate SVG animation functionality.
+	this.arePaused=function(){
+		//	summary
+		//	check to see if all animations are paused
 		try {
-			return d.documentElement.animationsPaused();
+			return d.documentElement.animationsPaused();	//	bool
+		} catch(e){
+			return false;	//	bool
 		}
-		catch (e) {
-			return false;
-		}
+	} ;
+	this.pause=function(){
+		//	summary
+		//	pause all animations
+		try { d.documentElement.pauseAnimations(); } catch(e){ }
 	};
-	this.pause = function () {
-		try {
-			d.documentElement.pauseAnimations();
-		}
-		catch (e) {
-		}
+	this.resume=function(){
+		//	summary
+		//	resume all animations
+		try { d.documentElement.unpauseAnimations(); } catch(e){ }
 	};
-	this.resume = function () {
-		try {
-			d.documentElement.unpauseAnimations();
-		}
-		catch (e) {
-		}
-	};
 }(document);
-dojo.svg.toCamelCase = function (selector) {
-	var arr = selector.split("-"), cc = arr[0];
-	for (var i = 1; i < arr.length; i++) {
+
+//	fixme: these functions should be mixed in from dojo.style, but dojo.style is HTML-centric and needs to change.
+dojo.svg.toCamelCase=function(/* string */ selector){
+	//	summary
+	//	converts a CSS-style selector to a camelCased one
+	var arr=selector.split('-'), cc=arr[0];
+	for(var i=1; i < arr.length; i++) {
 		cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
 	}
-	return cc;
+	return cc;	// string
 };
-dojo.svg.toSelectorCase = function (selector) {
-	return selector.replace(/([A-Z])/g, "-$1").toLowerCase();
+dojo.svg.toSelectorCase=function(/* string */ selector) {
+	//	summary
+	//	converts a camelCased selector to a CSS style one
+	return selector.replace(/([A-Z])/g, "-$1" ).toLowerCase();	//	string
 };
-dojo.svg.getStyle = function (node, cssSelector) {
-	return document.defaultView.getComputedStyle(node, cssSelector);
+dojo.svg.getStyle=function(/* SVGElement */ node, /* string */ cssSelector){
+	//	summary
+	//	get the computed style of selector for node.
+	return document.defaultView.getComputedStyle(node, cssSelector);	//	object
 };
-dojo.svg.getNumericStyle = function (node, cssSelector) {
+dojo.svg.getNumericStyle=function(/* SVGElement */ node, /* string */ cssSelector){
+	//	summary
+	//	return the numeric version of the computed style of selector on node.
 	return parseFloat(dojo.svg.getStyle(node, cssSelector));
 };
-dojo.svg.getOpacity = function (node) {
-	return Math.min(1, dojo.svg.getNumericStyle(node, "fill-opacity"));
+
+//	fixme: there are different ways of doing the following, need to take into account
+dojo.svg.getOpacity=function(/* SVGElement */node){
+	//	summary
+	//	Return the opacity of the passed element
+	return Math.min(1.0, dojo.svg.getNumericStyle(node, "fill-opacity"));	//	float
 };
-dojo.svg.setOpacity = function (node, opacity) {
+dojo.svg.setOpacity=function(/* SVGElement */ node, /* float */ opacity){
+	//	summary
+	//	set the opacity of node using attributes.
 	node.setAttributeNS(this.xmlns.svg, "fill-opacity", opacity);
 	node.setAttributeNS(this.xmlns.svg, "stroke-opacity", opacity);
 };
-dojo.svg.clearOpacity = function (node) {
+dojo.svg.clearOpacity=function(/* SVGElement */ node){
+	//	summary
+	//	Set any attributes setting opacity to opaque (1.0)
 	node.setAttributeNS(this.xmlns.svg, "fill-opacity", "1.0");
 	node.setAttributeNS(this.xmlns.svg, "stroke-opacity", "1.0");
 };
-dojo.svg.getCoords = function (node) {
+
+/**
+ *	Coordinates and dimensions.
+ */
+
+// TODO ////////////////////////////////////////////////////////// TODO
+dojo.svg.getCoords=function(/* SVGElement */ node){
 	if (node.getBBox) {
-		var box = node.getBBox();
-		return {x:box.x, y:box.y};
+		var box=node.getBBox();
+		return { x: box.x, y: box.y };
 	}
 	return null;
 };
-dojo.svg.setCoords = function (node, coords) {
-	var p = dojo.svg.getCoords();
-	if (!p) {
-		return;
-	}
-	var dx = p.x - coords.x;
-	var dy = p.y - coords.y;
+dojo.svg.setCoords=function(node, coords){
+	var p=dojo.svg.getCoords();
+	if (!p) return;
+	var dx=p.x - coords.x;
+	var dy=p.y - coords.y;
 	dojo.svg.translate(node, dx, dy);
 };
-dojo.svg.getDimensions = function (node) {
-	if (node.getBBox) {
-		var box = node.getBBox();
-		return {width:box.width, height:box.height};
+dojo.svg.getDimensions=function(node){
+	if (node.getBBox){
+		var box=node.getBBox();
+		return { width: box.width, height : box.height };
 	}
 	return null;
 };
-dojo.svg.setDimensions = function (node, dim) {
-	if (node.width) {
-		node.width.baseVal.value = dim.width;
-		node.height.baseVal.value = dim.height;
-	} else {
-		if (node.r) {
-			node.r.baseVal.value = Math.min(dim.width, dim.height) / 2;
-		} else {
-			if (node.rx) {
-				node.rx.baseVal.value = dim.width / 2;
-				node.ry.baseVal.value = dim.height / 2;
-			}
-		}
+dojo.svg.setDimensions=function(node, dim){
+	//	will only support shape-based and container elements; path-based elements are ignored.
+	if (node.width){
+		node.width.baseVal.value=dim.width;
+		node.height.baseVal.value=dim.height;
 	}
+	else if (node.r){
+		node.r.baseVal.value=Math.min(dim.width, dim.height)/2;
+	}
+	else if (node.rx){
+		node.rx.baseVal.value=dim.width/2;
+		node.ry.baseVal.value=dim.height/2;
+	}
 };
-dojo.svg.translate = function (node, dx, dy) {
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
-		var t = node.ownerSVGElement.createSVGTransform();
+
+/**
+ *	Transformations.
+ */
+dojo.svg.translate=function(node, dx, dy){
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
 		t.setTranslate(dx, dy);
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.scale = function (node, scaleX, scaleY) {
-	if (!scaleY) {
-		var scaleY = scaleX;
-	}
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
-		var t = node.ownerSVGElement.createSVGTransform();
+dojo.svg.scale=function(node, scaleX, scaleY){
+	if (!scaleY) var scaleY=scaleX;
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
 		t.setScale(scaleX, scaleY);
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.rotate = function (node, ang, cx, cy) {
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
-		var t = node.ownerSVGElement.createSVGTransform();
-		if (cx == null) {
-			t.setMatrix(t.matrix.rotate(ang));
-		} else {
-			t.setRotate(ang, cx, cy);
-		}
+dojo.svg.rotate=function(node, ang, cx, cy){
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		if (!cx) t.setMatrix(t.matrix.rotate(ang));
+		else t.setRotate(ang, cx, cy);
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.skew = function (node, ang, axis) {
-	var dir = axis || "x";
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
-		var t = node.ownerSVGElement.createSVGTransform();
-		if (dir != "x") {
-			t.setSkewY(ang);
-		} else {
-			t.setSkewX(ang);
-		}
+dojo.svg.skew=function(node, ang, axis){
+	var dir=axis || "x";
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		if (dir != "x") t.setSkewY(ang);
+		else t.setSkewX(ang);
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.flip = function (node, axis) {
-	var dir = axis || "x";
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
-		var t = node.ownerSVGElement.createSVGTransform();
+dojo.svg.flip=function(node, axis){
+	var dir=axis || "x";
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
 		t.setMatrix((dir != "x") ? t.matrix.flipY() : t.matrix.flipX());
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.invert = function (node) {
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
-		var t = node.ownerSVGElement.createSVGTransform();
+dojo.svg.invert=function(node){
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
 		t.setMatrix(t.matrix.inverse());
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.applyMatrix = function (node, a, b, c, d, e, f) {
-	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform) {
+dojo.svg.applyMatrix=function(node, a, b, c, d, e, f){
+	if (node.transform && node.ownerSVGElement && node.ownerSVGElement.createSVGTransform){
 		var m;
-		if (b) {
-			var m = node.ownerSVGElement.createSVGMatrix();
-			m.a = a;
-			m.b = b;
-			m.c = c;
-			m.d = d;
-			m.e = e;
-			m.f = f;
-		} else {
-			m = a;
-		}
-		var t = node.ownerSVGElement.createSVGTransform();
+		if (b){
+			var m=node.ownerSVGElement.createSVGMatrix();
+			m.a=a;
+			m.b=b;
+			m.c=c;
+			m.d=d;
+			m.e=e;
+			m.f=f;
+		} else m=a;
+		var t=node.ownerSVGElement.createSVGTransform();
 		t.setMatrix(m);
 		node.transform.baseVal.appendItem(t);
 	}
 };
-dojo.svg.group = function (nodes) {
-	var p = nodes.item(0).parentNode;
-	var g = document.createElementNS(this.xmlns.svg, "g");
-	for (var i = 0; i < nodes.length; i++) {
-		g.appendChild(nodes.item(i));
-	}
+
+/**
+ *	Grouping and z-index operations.
+ */
+dojo.svg.group=function(nodes){
+	//	expect an array of nodes, attaches the group to the parent of the first node.
+	var p=nodes.item(0).parentNode;
+	var g=document.createElementNS(this.xmlns.svg, "g");
+	for (var i=0; i < nodes.length; i++) g.appendChild(nodes.item(i));
 	p.appendChild(g);
 	return g;
 };
-dojo.svg.ungroup = function (g) {
-	var p = g.parentNode;
-	while (g.childNodes.length > 0) {
-		p.appendChild(g.childNodes.item(0));
-	}
+dojo.svg.ungroup=function(g){
+	//	puts the children of the group on the same level as group was.
+	var p=g.parentNode;
+	while (g.childNodes.length > 0) p.appendChild(g.childNodes.item(0));
 	p.removeChild(g);
 };
-dojo.svg.getGroup = function (node) {
-	var a = this.getAncestors(node);
-	for (var i = 0; i < a.length; i++) {
-		if (a[i].nodeType == this.ELEMENT_NODE && a[i].nodeName.toLowerCase() == "g") {
+//	if the node is part of a group, return the group, else return null.
+dojo.svg.getGroup=function(node){
+	//	if the node is part of a group, return the group, else return null.
+	var a=this.getAncestors(node);
+	for (var i=0; i < a.length; i++){
+		if (a[i].nodeType == this.ELEMENT_NODE && a[i].nodeName.toLowerCase() == "g")
 			return a[i];
-		}
 	}
 	return null;
 };
-dojo.svg.bringToFront = function (node) {
-	var n = this.getGroup(node) || node;
+dojo.svg.bringToFront=function(node){
+	var n=this.getGroup(node) || node;
 	n.ownerSVGElement.appendChild(n);
 };
-dojo.svg.sendToBack = function (node) {
-	var n = this.getGroup(node) || node;
+dojo.svg.sendToBack=function(node){
+	var n=this.getGroup(node) || node;
 	n.ownerSVGElement.insertBefore(n, n.ownerSVGElement.firstChild);
 };
-dojo.svg.bringForward = function (node) {
-	var n = this.getGroup(node) || node;
-	if (this.getLastChildElement(n.parentNode) != n) {
+
+//	TODO: possibly push node up a level in the DOM if it's at the beginning or end of the childNodes list.
+dojo.svg.bringForward=function(node){
+	var n=this.getGroup(node) || node;
+	if (this.getLastChildElement(n.parentNode) != n){
 		this.insertAfter(n, this.getNextSiblingElement(n), true);
 	}
 };
-dojo.svg.sendBackward = function (node) {
-	var n = this.getGroup(node) || node;
-	if (this.getFirstChildElement(n.parentNode) != n) {
+dojo.svg.sendBackward=function(node){
+	var n=this.getGroup(node) || node;
+	if (this.getFirstChildElement(n.parentNode) != n){
 		this.insertBefore(n, this.getPreviousSiblingElement(n), true);
 	}
 };
-dojo.svg.createNodesFromText = function (txt, wrap) {
-	var docFrag = (new DOMParser()).parseFromString(txt, "text/xml").normalize();
-	if (wrap) {
-		return [docFrag.firstChild.cloneNode(true)];
+// END TODO ////////////////////////////////////////////////////// TODO
+
+dojo.svg.createNodesFromText=function(/* string */ txt, /* bool? */ wrap){
+	//	summary
+	//	Create a list of nodes from text
+	var docFrag=(new DOMParser()).parseFromString(txt, "text/xml").normalize();
+	if(wrap){ 
+		return [docFrag.firstChild.cloneNode(true)];	//	array
 	}
-	var nodes = [];
-	for (var x = 0; x < docFrag.childNodes.length; x++) {
+	var nodes=[];
+	for(var x=0; x<docFrag.childNodes.length; x++){
 		nodes.push(docFrag.childNodes.item(x).cloneNode(true));
 	}
-	return nodes;
-};
-
+	return nodes;	// array
+}
+// vim:ts=4:noet:tw=0:

Added: tags/parley-0.53/root/static/magic/src/text/Builder.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/text/Builder.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/text/Builder.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,16 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.text.Builder");
+dojo.require("dojo.string.Builder");
+
+dojo.deprecated("dojo.text.Builder", "use dojo.string.Builder instead", "0.4");
+
+dojo.text.Builder = dojo.string.Builder;

Added: tags/parley-0.53/root/static/magic/src/text/String.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/text/String.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/text/String.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.deprecated("dojo.text.String", "replaced by dojo.string", "0.4");
+dojo.require("dojo.string");
+
+dojo.text = dojo.string;
+dojo.provide("dojo.text.String");

Added: tags/parley-0.53/root/static/magic/src/text/Text.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/text/Text.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/text/Text.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.deprecated("dojo.text.Text", "replaced by dojo.string", "0.4");
+dojo.require("dojo.string");
+
+dojo.text = dojo.string;
+dojo.provide("dojo.text.Text");

Modified: tags/parley-0.53/root/static/magic/src/text/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/text/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/text/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,10 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.text.String", "dojo.text.Builder"]});
-dojo.deprecated("dojo.text", "textDirectory moved to cal, text.String and text.Builder havne't been here for awhile", "0.5");
-
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.text.String",
+		"dojo.text.Builder"
+	]
+});
+dojo.provide("dojo.text.*");

Modified: tags/parley-0.53/root/static/magic/src/text/textDirectory.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/text/textDirectory.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/text/textDirectory.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,74 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.text.textDirectory");
+dojo.provide("dojo.text.textDirectory.Property");
+dojo.provide("dojo.text.textDirectory.tokenise");
+dojo.require("dojo.string");
 
+/* adapted from Paul Sowden's iCalendar work */
 
-dojo.require("dojo.cal.textDirectory");
-dojo.deprecate("dojo.text.textDirectory", "use dojo.cal.textDirectory", "0.5");
+dojo.textDirectoryTokeniser = function () {}
 
+/*
+ * This class parses a single line from a text/directory file
+ * and returns an object with four named values; name, group, params
+ * and value. name, group and value are strings containing the original
+ * tokens unaltered and values is an array containing name/value pairs
+ * or a single name token packed into arrays.
+ */
+dojo.textDirectoryTokeniser.Property = function (line) {
+	// split into name/value pair
+	var left = dojo.string.trim(line.substring(0, line.indexOf(':')));
+	var right = dojo.string.trim(line.substr(line.indexOf(':') + 1));
+
+	// seperate name and paramters	
+	var parameters = dojo.string.splitEscaped(left,';');
+	this.name = parameters[0]
+	parameters.splice(0, 1);
+
+	// parse paramters
+	this.params = [];
+	for (var i = 0; i < parameters.length; i++) {
+		var arr = parameters[i].split("=");
+		var key = dojo.string.trim(arr[0].toUpperCase());
+		
+		if (arr.length == 1) { this.params.push([key]); continue; }
+		
+		var values = dojo.string.splitEscaped(arr[1],',');
+		for (var j = 0; j < values.length; j++) {
+			if (dojo.string.trim(values[j]) != '') {
+				this.params.push([key, dojo.string.trim(values[j])]);
+			}
+		}
+	}
+
+	// seperate group
+	if (this.name.indexOf('.') > 0) {
+		var arr = this.name.split('.');
+		this.group = arr[0];
+		this.name = arr[1];
+	}
+	
+	// don't do any parsing, leave to implementation
+	this.value = right;
+}
+
+
+// tokeniser, parses into an array of properties.
+dojo.textDirectoryTokeniser.tokenise = function (text) {
+	// normlize to one propterty per line and parse
+	var nText = dojo.string.normalizeNewlines(text,"\n");
+	nText = nText.replace(/\n[ \t]/g, '');
+	nText = nText.replace(/\x00/g, '');
+		
+	var lines = nText.split("\n");
+	var properties = []
+
+	for (var i = 0; i < lines.length; i++) {
+		if (dojo.string.trim(lines[i]) == '') { continue; }
+		var prop = new dojo.textDirectoryTokeniser.Property(lines[i]);
+		properties.push(prop);
+	}
+	return properties;
+}

Modified: tags/parley-0.53/root/static/magic/src/undo/Manager.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/undo/Manager.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/undo/Manager.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,143 +8,191 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.undo.Manager");
+dojo.require("dojo.lang");
 
-
-dojo.provide("dojo.undo.Manager");
-dojo.require("dojo.lang.common");
-dojo.undo.Manager = function (parent) {
+dojo.undo.Manager = function(parent) {
 	this.clear();
 	this._parent = parent;
 };
-dojo.extend(dojo.undo.Manager, {_parent:null, _undoStack:null, _redoStack:null, _currentManager:null, canUndo:false, canRedo:false, isUndoing:false, isRedoing:false, onUndo:function (manager, item) {
-}, onRedo:function (manager, item) {
-}, onUndoAny:function (manager, item) {
-}, onRedoAny:function (manager, item) {
-}, _updateStatus:function () {
-	this.canUndo = this._undoStack.length > 0;
-	this.canRedo = this._redoStack.length > 0;
-}, clear:function () {
-	this._undoStack = [];
-	this._redoStack = [];
-	this._currentManager = this;
-	this.isUndoing = false;
-	this.isRedoing = false;
-	this._updateStatus();
-}, undo:function () {
-	if (!this.canUndo) {
-		return false;
-	}
-	this.endAllTransactions();
-	this.isUndoing = true;
-	var top = this._undoStack.pop();
-	if (top instanceof dojo.undo.Manager) {
-		top.undoAll();
-	} else {
-		top.undo();
-	}
-	if (top.redo) {
-		this._redoStack.push(top);
-	}
-	this.isUndoing = false;
-	this._updateStatus();
-	this.onUndo(this, top);
-	if (!(top instanceof dojo.undo.Manager)) {
-		this.getTop().onUndoAny(this, top);
-	}
-	return true;
-}, redo:function () {
-	if (!this.canRedo) {
-		return false;
-	}
-	this.isRedoing = true;
-	var top = this._redoStack.pop();
-	if (top instanceof dojo.undo.Manager) {
-		top.redoAll();
-	} else {
-		top.redo();
-	}
-	this._undoStack.push(top);
-	this.isRedoing = false;
-	this._updateStatus();
-	this.onRedo(this, top);
-	if (!(top instanceof dojo.undo.Manager)) {
-		this.getTop().onRedoAny(this, top);
-	}
-	return true;
-}, undoAll:function () {
-	while (this._undoStack.length > 0) {
-		this.undo();
-	}
-}, redoAll:function () {
-	while (this._redoStack.length > 0) {
-		this.redo();
-	}
-}, push:function (undo, redo, description) {
-	if (!undo) {
-		return;
-	}
-	if (this._currentManager == this) {
-		this._undoStack.push({undo:undo, redo:redo, description:description});
-	} else {
-		this._currentManager.push.apply(this._currentManager, arguments);
-	}
-	this._redoStack = [];
-	this._updateStatus();
-}, concat:function (manager) {
-	if (!manager) {
-		return;
-	}
-	if (this._currentManager == this) {
-		for (var x = 0; x < manager._undoStack.length; x++) {
-			this._undoStack.push(manager._undoStack[x]);
+dojo.lang.extend(dojo.undo.Manager, {
+	_parent: null,
+	_undoStack: null,
+	_redoStack: null,
+	_currentManager: null,
+
+	canUndo: false,
+	canRedo: false,
+
+	isUndoing: false,
+	isRedoing: false,
+
+	// these events allow you to hook in and update your code (UI?) as necessary
+	onUndo: function(manager, item) {},
+	onRedo: function(manager, item) {},
+
+	// fired when you do *any* undo action, which means you'll have one for every item
+	// in a transaction. this is usually only useful for debugging
+	onUndoAny: function(manager, item) {},
+	onRedoAny: function(manager, item) {},
+
+	_updateStatus: function() {
+		this.canUndo = this._undoStack.length > 0;
+		this.canRedo = this._redoStack.length > 0;
+	},
+
+	clear: function() {
+		this._undoStack = [];
+		this._redoStack = [];
+		this._currentManager = this;
+
+		this.isUndoing = false;
+		this.isRedoing = false;
+
+		this._updateStatus();
+	},
+
+	undo: function() {
+		if(!this.canUndo) { return false; }
+
+		this.endAllTransactions();
+
+		this.isUndoing = true;
+		var top = this._undoStack.pop();
+		if(top instanceof dojo.undo.Manager){
+			top.undoAll();
+		}else{
+			top.undo();
 		}
-		if (manager._undoStack.length > 0) {
+		if(top.redo){
+			this._redoStack.push(top);
+		}
+		this.isUndoing = false;
+
+		this._updateStatus();
+		this.onUndo(this, top);
+		if(!(top instanceof dojo.undo.Manager)){
+			this.getTop().onUndoAny(this, top);
+		}
+		return true;
+	},
+
+	redo: function() {
+		if(!this.canRedo){ return false; }
+
+		this.isRedoing = true;
+		var top = this._redoStack.pop();
+		if(top instanceof dojo.undo.Manager){
+			top.redoAll();
+		}else{
+			top.redo();
+		}
+		this._undoStack.push(top);
+		this.isRedoing = false;
+
+		this._updateStatus();
+		this.onRedo(this, top);
+		if(!(top instanceof dojo.undo.Manager)){
+			this.getTop().onRedoAny(this, top);
+		}
+		return true;
+	},
+
+	undoAll: function() {
+		while(this._undoStack.length > 0) {
+			this.undo();
+		}
+	},
+
+	redoAll: function() {
+		while(this._redoStack.length > 0) {
+			this.redo();
+		}
+	},
+
+	push: function(undo, redo /* optional */, description /* optional */) {
+		if(!undo) { return; }
+
+		if(this._currentManager == this) {
+			this._undoStack.push({
+				undo: undo,
+				redo: redo,
+				description: description
+			});
+		} else {
+			this._currentManager.push.apply(this._currentManager, arguments);
+		}
+		// adding a new undo-able item clears out the redo stack
+		this._redoStack = [];
+		this._updateStatus();
+	},
+
+	concat: function(manager) {
+		if ( !manager ) { return; }
+
+		if (this._currentManager == this ) {
+			for(var x=0; x < manager._undoStack.length; x++) {
+				this._undoStack.push(manager._undoStack[x]);
+			}
+			// adding a new undo-able item clears out the redo stack
 			this._redoStack = [];
+			this._updateStatus();
+		} else {
+			this._currentManager.concat.apply(this._currentManager, arguments);
 		}
-		this._updateStatus();
-	} else {
-		this._currentManager.concat.apply(this._currentManager, arguments);
-	}
-}, beginTransaction:function (description) {
-	if (this._currentManager == this) {
-		var mgr = new dojo.undo.Manager(this);
-		mgr.description = description ? description : "";
-		this._undoStack.push(mgr);
-		this._currentManager = mgr;
-		return mgr;
-	} else {
-		this._currentManager = this._currentManager.beginTransaction.apply(this._currentManager, arguments);
-	}
-}, endTransaction:function (flatten) {
-	if (this._currentManager == this) {
-		if (this._parent) {
-			this._parent._currentManager = this._parent;
-			if (this._undoStack.length == 0 || flatten) {
-				var idx = dojo.lang.find(this._parent._undoStack, this);
-				if (idx >= 0) {
-					this._parent._undoStack.splice(idx, 1);
-					if (flatten) {
-						for (var x = 0; x < this._undoStack.length; x++) {
-							this._parent._undoStack.splice(idx++, 0, this._undoStack[x]);
+	},
+
+	beginTransaction: function(description /* optional */) {
+		if(this._currentManager == this) {
+			var mgr = new dojo.undo.Manager(this);
+			mgr.description = description ? description : "";
+			this._undoStack.push(mgr);
+			this._currentManager = mgr;
+			return mgr;
+		} else {
+			//for nested transactions need to make sure the top level _currentManager is set
+			this._currentManager = this._currentManager.beginTransaction.apply(this._currentManager, arguments);
+		}
+	},
+
+	endTransaction: function(flatten /* optional */) {
+		if(this._currentManager == this) {
+			if(this._parent) {
+				this._parent._currentManager = this._parent;
+				// don't leave empty transactions hangin' around
+				if(this._undoStack.length == 0 || flatten) {
+					var idx = dojo.lang.find(this._parent._undoStack, this);
+					if (idx >= 0) {
+						this._parent._undoStack.splice(idx, 1);
+						//add the current transaction to parents undo stack
+						if (flatten) {
+							for(var x=0; x < this._undoStack.length; x++){
+								this._parent._undoStack.splice(idx++, 0, this._undoStack[x]);
+							}
+							this._updateStatus();
 						}
-						this._updateStatus();
 					}
 				}
+				return this._parent;
 			}
-			return this._parent;
+		} else {
+			//for nested transactions need to make sure the top level _currentManager is set
+			this._currentManager = this._currentManager.endTransaction.apply(this._currentManager, arguments);
 		}
-	} else {
-		this._currentManager = this._currentManager.endTransaction.apply(this._currentManager, arguments);
+	},
+
+	endAllTransactions: function() {
+		while(this._currentManager != this) {
+			this.endTransaction();
+		}
+	},
+
+	// find the top parent of an undo manager
+	getTop: function() {
+		if(this._parent) {
+			return this._parent.getTop();
+		} else {
+			return this;
+		}
 	}
-}, endAllTransactions:function () {
-	while (this._currentManager != this) {
-		this.endTransaction();
-	}
-}, getTop:function () {
-	if (this._parent) {
-		return this._parent.getTop();
-	} else {
-		return this;
-	}
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/undo/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/undo/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/undo/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,5 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.require("dojo.undo.Manager");
 dojo.provide("dojo.undo.*");
-

Modified: tags/parley-0.53/root/static/magic/src/undo/browser.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/undo/browser.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/undo/browser.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,196 +8,272 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.undo.browser");
+dojo.require("dojo.io");
 
+try{
+	if((!djConfig["preventBackButtonFix"])&&(!dojo.hostenv.post_load_)){
+		document.write("<iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='"+(dojo.hostenv.getBaseScriptUri()+'iframe_history.html')+"'></iframe>");
+	}
+}catch(e){/* squelch */}
 
-dojo.provide("dojo.undo.browser");
-dojo.require("dojo.io.common");
-try {
-	if ((!djConfig["preventBackButtonFix"]) && (!dojo.hostenv.post_load_)) {
-		document.write("<iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='" + (djConfig["dojoIframeHistoryUrl"] || dojo.hostenv.getBaseScriptUri() + "iframe_history.html") + "'></iframe>");
-	}
-}
-catch (e) {
-}
-if (dojo.render.html.opera) {
+if(dojo.render.html.opera){
 	dojo.debug("Opera is not supported with dojo.undo.browser, so back/forward detection will not work.");
 }
-dojo.undo.browser = {initialHref:(!dj_undef("window")) ? window.location.href : "", initialHash:(!dj_undef("window")) ? window.location.hash : "", moveForward:false, historyStack:[], forwardStack:[], historyIframe:null, bookmarkAnchor:null, locationTimer:null, setInitialState:function (args) {
-	this.initialState = this._createState(this.initialHref, args, this.initialHash);
-}, addToHistory:function (args) {
-	this.forwardStack = [];
-	var hash = null;
-	var url = null;
-	if (!this.historyIframe) {
-		if (djConfig["useXDomain"] && !djConfig["dojoIframeHistoryUrl"]) {
-			dojo.debug("dojo.undo.browser: When using cross-domain Dojo builds," + " please save iframe_history.html to your domain and set djConfig.dojoIframeHistoryUrl" + " to the path on your domain to iframe_history.html");
+
+/* NOTES:
+ *  Safari 1.2: 
+ *	back button "works" fine, however it's not possible to actually
+ *	DETECT that you've moved backwards by inspecting window.location.
+ *	Unless there is some other means of locating.
+ *	FIXME: perhaps we can poll on history.length?
+ *  Safari 2.0.3+ (and probably 1.3.2+):
+ *	works fine, except when changeUrl is used. When changeUrl is used,
+ *	Safari jumps all the way back to whatever page was shown before
+ *	the page that uses dojo.undo.browser support.
+ *  IE 5.5 SP2:
+ *	back button behavior is macro. It does not move back to the
+ *	previous hash value, but to the last full page load. This suggests
+ *	that the iframe is the correct way to capture the back button in
+ *	these cases.
+ *	Don't test this page using local disk for MSIE. MSIE will not create 
+ *	a history list for iframe_history.html if served from a file: URL. 
+ *	The XML served back from the XHR tests will also not be properly 
+ *	created if served from local disk. Serve the test pages from a web 
+ *	server to test in that browser.
+ *  IE 6.0:
+ *	same behavior as IE 5.5 SP2
+ * Firefox 1.0:
+ *	the back button will return us to the previous hash on the same
+ *	page, thereby not requiring an iframe hack, although we do then
+ *	need to run a timer to detect inter-page movement.
+ */
+dojo.undo.browser = {
+	initialHref: window.location.href,
+	initialHash: window.location.hash,
+
+	moveForward: false,
+	historyStack: [],
+	forwardStack: [],
+	historyIframe: null,
+	bookmarkAnchor: null,
+	locationTimer: null,
+
+	/**
+	 * setInitialState sets the state object and back callback for the very first page that is loaded.
+	 * It is recommended that you call this method as part of an event listener that is registered via
+	 * dojo.addOnLoad().
+	 */
+	setInitialState: function(args){
+		this.initialState = {"url": this.initialHref, "kwArgs": args, "urlHash": this.initialHash};
+	},
+
+	//FIXME: Would like to support arbitrary back/forward jumps. Have to rework iframeLoaded among other things.
+	//FIXME: is there a slight race condition in moz using change URL with the timer check and when
+	//       the hash gets set? I think I have seen a back/forward call in quick succession, but not consistent.
+	/**
+	 * addToHistory takes one argument, and it is an object that defines the following functions:
+	 * - To support getting back button notifications, the object argument should implement a
+	 *   function called either "back", "backButton", or "handle". The string "back" will be
+	 *   passed as the first and only argument to this callback.
+	 * - To support getting forward button notifications, the object argument should implement a
+	 *   function called either "forward", "forwardButton", or "handle". The string "forward" will be
+	 *   passed as the first and only argument to this callback.
+	 * - If you want the browser location string to change, define "changeUrl" on the object. If the
+	 *   value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
+	 *   identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
+	 *   not evaluate to false, that value will be used as the fragment identifier. For example,
+	 *   if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1
+	 *   
+	 * Full example:
+	 * 
+	 * dojo.undo.browser.addToHistory({
+	 *   back: function() { alert('back pressed'); },
+	 *   forward: function() { alert('forward pressed'); },
+	 *   changeUrl: true
+	 * });
+	 */
+	addToHistory: function(args){
+		var hash = null;
+		if(!this.historyIframe){
+			this.historyIframe = window.frames["djhistory"];
 		}
-		this.historyIframe = window.frames["djhistory"];
-	}
-	if (!this.bookmarkAnchor) {
-		this.bookmarkAnchor = document.createElement("a");
-		dojo.body().appendChild(this.bookmarkAnchor);
-		this.bookmarkAnchor.style.display = "none";
-	}
-	if (args["changeUrl"]) {
-		hash = "#" + ((args["changeUrl"] !== true) ? args["changeUrl"] : (new Date()).getTime());
-		if (this.historyStack.length == 0 && this.initialState.urlHash == hash) {
-			this.initialState = this._createState(url, args, hash);
-			return;
-		} else {
-			if (this.historyStack.length > 0 && this.historyStack[this.historyStack.length - 1].urlHash == hash) {
-				this.historyStack[this.historyStack.length - 1] = this._createState(url, args, hash);
-				return;
-			}
+		if(!this.bookmarkAnchor){
+			this.bookmarkAnchor = document.createElement("a");
+			(document.body||document.getElementsByTagName("body")[0]).appendChild(this.bookmarkAnchor);
+			this.bookmarkAnchor.style.display = "none";
 		}
-		this.changingUrl = true;
-		setTimeout("window.location.href = '" + hash + "'; dojo.undo.browser.changingUrl = false;", 1);
-		this.bookmarkAnchor.href = hash;
-		if (dojo.render.html.ie) {
-			url = this._loadIframeHistory();
-			var oldCB = args["back"] || args["backButton"] || args["handle"];
-			var tcb = function (handleName) {
-				if (window.location.hash != "") {
-					setTimeout("window.location.href = '" + hash + "';", 1);
+		if((!args["changeUrl"])||(dojo.render.html.ie)){
+			var url = dojo.hostenv.getBaseScriptUri()+"iframe_history.html?"+(new Date()).getTime();
+			this.moveForward = true;
+			dojo.io.setIFrameSrc(this.historyIframe, url, false);
+		}
+		if(args["changeUrl"]){
+			this.changingUrl = true;
+			hash = "#"+ ((args["changeUrl"]!==true) ? args["changeUrl"] : (new Date()).getTime());
+			setTimeout("window.location.href = '"+hash+"'; dojo.undo.browser.changingUrl = false;", 1);
+			this.bookmarkAnchor.href = hash;
+			
+			if(dojo.render.html.ie){
+				var oldCB = args["back"]||args["backButton"]||args["handle"];
+
+				//The function takes handleName as a parameter, in case the
+				//callback we are overriding was "handle". In that case,
+				//we will need to pass the handle name to handle.
+				var tcb = function(handleName){
+					if(window.location.hash != ""){
+						setTimeout("window.location.href = '"+hash+"';", 1);
+					}
+					//Use apply to set "this" to args, and to try to avoid memory leaks.
+					oldCB.apply(this, [handleName]);
 				}
-				oldCB.apply(this, [handleName]);
-			};
-			if (args["back"]) {
-				args.back = tcb;
-			} else {
-				if (args["backButton"]) {
+		
+				//Set interceptor function in the right place.
+				if(args["back"]){
+					args.back = tcb;
+				}else if(args["backButton"]){
 					args.backButton = tcb;
-				} else {
-					if (args["handle"]) {
-						args.handle = tcb;
+				}else if(args["handle"]){
+					args.handle = tcb;
+				}
+		
+				//If addToHistory is called, then that means we prune the
+				//forward stack -- the user went back, then wanted to
+				//start a new forward path.
+				this.forwardStack = []; 
+				var oldFW = args["forward"]||args["forwardButton"]||args["handle"];
+		
+				//The function takes handleName as a parameter, in case the
+				//callback we are overriding was "handle". In that case,
+				//we will need to pass the handle name to handle.
+				var tfw = function(handleName){
+					if(window.location.hash != ""){
+						window.location.href = hash;
 					}
+					if(oldFW){ // we might not actually have one
+						//Use apply to set "this" to args, and to try to avoid memory leaks.
+						oldFW.apply(this, [handleName]);
+					}
 				}
-			}
-			var oldFW = args["forward"] || args["forwardButton"] || args["handle"];
-			var tfw = function (handleName) {
-				if (window.location.hash != "") {
-					window.location.href = hash;
-				}
-				if (oldFW) {
-					oldFW.apply(this, [handleName]);
-				}
-			};
-			if (args["forward"]) {
-				args.forward = tfw;
-			} else {
-				if (args["forwardButton"]) {
+
+				//Set interceptor function in the right place.
+				if(args["forward"]){
+					args.forward = tfw;
+				}else if(args["forwardButton"]){
 					args.forwardButton = tfw;
-				} else {
-					if (args["handle"]) {
-						args.handle = tfw;
-					}
+				}else if(args["handle"]){
+					args.handle = tfw;
 				}
-			}
-		} else {
-			if (dojo.render.html.moz) {
-				if (!this.locationTimer) {
+
+			}else if(dojo.render.html.moz){
+				// start the timer
+				if(!this.locationTimer){
 					this.locationTimer = setInterval("dojo.undo.browser.checkLocation();", 200);
 				}
 			}
 		}
-	} else {
-		url = this._loadIframeHistory();
-	}
-	this.historyStack.push(this._createState(url, args, hash));
-}, checkLocation:function () {
-	if (!this.changingUrl) {
-		var hsl = this.historyStack.length;
-		if ((window.location.hash == this.initialHash || window.location.href == this.initialHref) && (hsl == 1)) {
-			this.handleBackButton();
-			return;
-		}
-		if (this.forwardStack.length > 0) {
-			if (this.forwardStack[this.forwardStack.length - 1].urlHash == window.location.hash) {
-				this.handleForwardButton();
+
+		this.historyStack.push({"url": url, "kwArgs": args, "urlHash": hash});
+	},
+
+	checkLocation: function(){
+		if (!this.changingUrl){
+			var hsl = this.historyStack.length;
+
+			if((window.location.hash == this.initialHash||window.location.href == this.initialHref)&&(hsl == 1)){
+				// FIXME: could this ever be a forward button?
+				// we can't clear it because we still need to check for forwards. Ugg.
+				// clearInterval(this.locationTimer);
+				this.handleBackButton();
 				return;
 			}
+			// first check to see if we could have gone forward. We always halt on
+			// a no-hash item.
+			if(this.forwardStack.length > 0){
+				if(this.forwardStack[this.forwardStack.length-1].urlHash == window.location.hash){
+					this.handleForwardButton();
+					return;
+				}
+			}
+	
+			// ok, that didn't work, try someplace back in the history stack
+			if((hsl >= 2)&&(this.historyStack[hsl-2])){
+				if(this.historyStack[hsl-2].urlHash==window.location.hash){
+					this.handleBackButton();
+					return;
+				}
+			}
 		}
-		if ((hsl >= 2) && (this.historyStack[hsl - 2])) {
-			if (this.historyStack[hsl - 2].urlHash == window.location.hash) {
-				this.handleBackButton();
+	},
+
+	iframeLoaded: function(evt, ifrLoc){
+		if(!dojo.render.html.opera){
+			var query = this._getUrlQuery(ifrLoc.href);
+			if(query == null){ 
+				// alert("iframeLoaded");
+				// we hit the end of the history, so we should go back
+				if(this.historyStack.length == 1){
+					this.handleBackButton();
+				}
 				return;
 			}
-		}
-	}
-}, iframeLoaded:function (evt, ifrLoc) {
-	if (!dojo.render.html.opera) {
-		var query = this._getUrlQuery(ifrLoc.href);
-		if (query == null) {
-			if (this.historyStack.length == 1) {
+			if(this.moveForward){
+				// we were expecting it, so it's not either a forward or backward movement
+				this.moveForward = false;
+				return;
+			}
+	
+			//Check the back stack first, since it is more likely.
+			//Note that only one step back or forward is supported.
+			if(this.historyStack.length >= 2 && query == this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
 				this.handleBackButton();
 			}
-			return;
-		}
-		if (this.moveForward) {
-			this.moveForward = false;
-			return;
-		}
-		if (this.historyStack.length >= 2 && query == this._getUrlQuery(this.historyStack[this.historyStack.length - 2].url)) {
-			this.handleBackButton();
-		} else {
-			if (this.forwardStack.length > 0 && query == this._getUrlQuery(this.forwardStack[this.forwardStack.length - 1].url)) {
+			else if(this.forwardStack.length > 0 && query == this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
 				this.handleForwardButton();
 			}
 		}
-	}
-}, handleBackButton:function () {
-	var current = this.historyStack.pop();
-	if (!current) {
-		return;
-	}
-	var last = this.historyStack[this.historyStack.length - 1];
-	if (!last && this.historyStack.length == 0) {
-		last = this.initialState;
-	}
-	if (last) {
-		if (last.kwArgs["back"]) {
-			last.kwArgs["back"]();
-		} else {
-			if (last.kwArgs["backButton"]) {
+	},
+
+	handleBackButton: function(){
+		//The "current" page is always at the top of the history stack.
+		var current = this.historyStack.pop();
+		if(!current){ return; }
+		var last = this.historyStack[this.historyStack.length-1];
+		if(!last && this.historyStack.length == 0){
+			last = this.initialState;
+		}
+		if (last){
+			if(last.kwArgs["back"]){
+				last.kwArgs["back"]();
+			}else if(last.kwArgs["backButton"]){
 				last.kwArgs["backButton"]();
-			} else {
-				if (last.kwArgs["handle"]) {
-					last.kwArgs.handle("back");
-				}
+			}else if(last.kwArgs["handle"]){
+				last.kwArgs.handle("back");
 			}
 		}
-	}
-	this.forwardStack.push(current);
-}, handleForwardButton:function () {
-	var last = this.forwardStack.pop();
-	if (!last) {
-		return;
-	}
-	if (last.kwArgs["forward"]) {
-		last.kwArgs.forward();
-	} else {
-		if (last.kwArgs["forwardButton"]) {
+		this.forwardStack.push(current);
+	},
+
+	handleForwardButton: function(){
+		var last = this.forwardStack.pop();
+		if(!last){ return; }
+		if(last.kwArgs["forward"]){
+			last.kwArgs.forward();
+		}else if(last.kwArgs["forwardButton"]){
 			last.kwArgs.forwardButton();
-		} else {
-			if (last.kwArgs["handle"]) {
-				last.kwArgs.handle("forward");
-			}
+		}else if(last.kwArgs["handle"]){
+			last.kwArgs.handle("forward");
 		}
+		this.historyStack.push(last);
+	},
+
+	_getUrlQuery: function(url){
+		var segments = url.split("?");
+		if (segments.length < 2){
+			return null;
+		}
+		else{
+			return segments[1];
+		}
 	}
-	this.historyStack.push(last);
-}, _createState:function (url, args, hash) {
-	return {"url":url, "kwArgs":args, "urlHash":hash};
-}, _getUrlQuery:function (url) {
-	var segments = url.split("?");
-	if (segments.length < 2) {
-		return null;
-	} else {
-		return segments[1];
-	}
-}, _loadIframeHistory:function () {
-	var url = (djConfig["dojoIframeHistoryUrl"] || dojo.hostenv.getBaseScriptUri() + "iframe_history.html") + "?" + (new Date()).getTime();
-	this.moveForward = true;
-	dojo.io.setIFrameSrc(this.historyIframe, url, false);
-	return url;
-}};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/uri/Uri.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uri/Uri.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uri/Uri.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,108 +8,101 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.uri.Uri");
-dojo.uri = new function () {
+
+dojo.uri = new function() {
+	this.joinPath = function() {
+		// DEPRECATED: use the dojo.uri.Uri object instead
+		var arr = [];
+		for(var i = 0; i < arguments.length; i++) { arr.push(arguments[i]); }
+		return arr.join("/").replace(/\/{2,}/g, "/").replace(/((https*|ftps*):)/i, "$1/");
+	}
+	
 	this.dojoUri = function (uri) {
+		// returns a Uri object resolved relative to the dojo root
 		return new dojo.uri.Uri(dojo.hostenv.getBaseScriptUri(), uri);
-	};
-	this.moduleUri = function (module, uri) {
-		var loc = dojo.hostenv.getModuleSymbols(module).join("/");
-		if (!loc) {
-			return null;
-		}
-		if (loc.lastIndexOf("/") != loc.length - 1) {
-			loc += "/";
-		}
-		var colonIndex = loc.indexOf(":");
-		var slashIndex = loc.indexOf("/");
-		if (loc.charAt(0) != "/" && (colonIndex == -1 || colonIndex > slashIndex)) {
-			loc = dojo.hostenv.getBaseScriptUri() + loc;
-		}
-		return new dojo.uri.Uri(loc, uri);
-	};
-	this.Uri = function () {
+	}
+		
+	this.Uri = function (/*uri1, uri2, [...]*/) {
+		// An object representing a Uri.
+		// Each argument is evaluated in order relative to the next until
+		// a conanical uri is producued. To get an absolute Uri relative
+		// to the current document use
+		//      new dojo.uri.Uri(document.baseURI, uri)
+
+		// TODO: support for IPv6, see RFC 2732
+
+		// resolve uri components relative to each other
 		var uri = arguments[0];
 		for (var i = 1; i < arguments.length; i++) {
-			if (!arguments[i]) {
-				continue;
-			}
+			if(!arguments[i]) { continue; }
+
+			// Safari doesn't support this.constructor so we have to be explicit
 			var relobj = new dojo.uri.Uri(arguments[i].toString());
 			var uriobj = new dojo.uri.Uri(uri.toString());
-			if ((relobj.path == "") && (relobj.scheme == null) && (relobj.authority == null) && (relobj.query == null)) {
-				if (relobj.fragment != null) {
-					uriobj.fragment = relobj.fragment;
-				}
+
+			if (relobj.path == "" && relobj.scheme == null &&
+				relobj.authority == null && relobj.query == null) {
+				if (relobj.fragment != null) { uriobj.fragment = relobj.fragment; }
 				relobj = uriobj;
-			} else {
-				if (relobj.scheme == null) {
-					relobj.scheme = uriobj.scheme;
-					if (relobj.authority == null) {
-						relobj.authority = uriobj.authority;
-						if (relobj.path.charAt(0) != "/") {
-							var path = uriobj.path.substring(0, uriobj.path.lastIndexOf("/") + 1) + relobj.path;
-							var segs = path.split("/");
-							for (var j = 0; j < segs.length; j++) {
-								if (segs[j] == ".") {
-									if (j == segs.length - 1) {
-										segs[j] = "";
-									} else {
-										segs.splice(j, 1);
-										j--;
-									}
-								} else {
-									if (j > 0 && !(j == 1 && segs[0] == "") && segs[j] == ".." && segs[j - 1] != "..") {
-										if (j == segs.length - 1) {
-											segs.splice(j, 1);
-											segs[j - 1] = "";
-										} else {
-											segs.splice(j - 1, 2);
-											j -= 2;
-										}
-									}
-								}
+			} else if (relobj.scheme == null) {
+				relobj.scheme = uriobj.scheme;
+			
+				if (relobj.authority == null) {
+					relobj.authority = uriobj.authority;
+					
+					if (relobj.path.charAt(0) != "/") {
+						var path = uriobj.path.substring(0,
+							uriobj.path.lastIndexOf("/") + 1) + relobj.path;
+
+						var segs = path.split("/");
+						for (var j = 0; j < segs.length; j++) {
+							if (segs[j] == ".") {
+								if (j == segs.length - 1) { segs[j] = ""; }
+								else { segs.splice(j, 1); j--; }
+							} else if (j > 0 && !(j == 1 && segs[0] == "") &&
+								segs[j] == ".." && segs[j-1] != "..") {
+
+								if (j == segs.length - 1) { segs.splice(j, 1); segs[j - 1] = ""; }
+								else { segs.splice(j - 1, 2); j -= 2; }
 							}
-							relobj.path = segs.join("/");
 						}
+						relobj.path = segs.join("/");
 					}
 				}
 			}
+
 			uri = "";
-			if (relobj.scheme != null) {
-				uri += relobj.scheme + ":";
-			}
-			if (relobj.authority != null) {
-				uri += "//" + relobj.authority;
-			}
+			if (relobj.scheme != null) { uri += relobj.scheme + ":"; }
+			if (relobj.authority != null) { uri += "//" + relobj.authority; }
 			uri += relobj.path;
-			if (relobj.query != null) {
-				uri += "?" + relobj.query;
-			}
-			if (relobj.fragment != null) {
-				uri += "#" + relobj.fragment;
-			}
+			if (relobj.query != null) { uri += "?" + relobj.query; }
+			if (relobj.fragment != null) { uri += "#" + relobj.fragment; }
 		}
+
 		this.uri = uri.toString();
+
+		// break the uri into its main components
 		var regexp = "^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$";
-		var r = this.uri.match(new RegExp(regexp));
+	    var r = this.uri.match(new RegExp(regexp));
+
 		this.scheme = r[2] || (r[1] ? "" : null);
 		this.authority = r[4] || (r[3] ? "" : null);
-		this.path = r[5];
+		this.path = r[5]; // can never be undefined
 		this.query = r[7] || (r[6] ? "" : null);
-		this.fragment = r[9] || (r[8] ? "" : null);
+		this.fragment  = r[9] || (r[8] ? "" : null);
+		
 		if (this.authority != null) {
+			// server based naming authority
 			regexp = "^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$";
 			r = this.authority.match(new RegExp(regexp));
+			
 			this.user = r[3] || null;
 			this.password = r[4] || null;
 			this.host = r[5];
 			this.port = r[7] || null;
 		}
-		this.toString = function () {
-			return this.uri;
-		};
-	};
+	
+		this.toString = function(){ return this.uri; }
+	}
 };
-

Modified: tags/parley-0.53/root/static/magic/src/uri/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uri/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uri/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,7 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:[["dojo.uri.Uri", false, false]]});
+dojo.kwCompoundRequire({
+	common: ["dojo.uri.Uri", false, false]
+});
 dojo.provide("dojo.uri.*");
-

Deleted: tags/parley-0.53/root/static/magic/src/uri/cache.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uri/cache.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uri/cache.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,32 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.uri.cache");
-dojo.uri.cache = {_cache:{}, set:function (uri, content) {
-	this._cache[uri.toString()] = content;
-	return uri;
-}, remove:function (uri) {
-	delete this._cache[uri.toString()];
-}, get:function (uri) {
-	var key = uri.toString();
-	var value = this._cache[key];
-	if (!value) {
-		value = dojo.hostenv.getText(key);
-		if (value) {
-			this._cache[key] = value;
-		}
-	}
-	return value;
-}, allow:function (uri) {
-	return uri;
-}};
-

Modified: tags/parley-0.53/root/static/magic/src/uuid/LightweightGenerator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/LightweightGenerator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/LightweightGenerator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,23 +8,64 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.uuid.LightweightGenerator");
 
+/**
+ * The LightweightGenerator is intended to be small and fast,
+ * but not necessarily good.
+ * 
+ * Small: The LightweightGenerator has a small footprint. 
+ * Once comments are stripped, it's only about 25 lines of 
+ * code, and it doesn't dojo.require() any other packages.
+ *
+ * Fast: The LightweightGenerator can generate lots of new 
+ * UUIDs fairly quickly (at least, more quickly than the other 
+ * dojo UUID generators).
+ *
+ * Not necessarily good: We use Math.random() as our source
+ * of randomness, which may or may not provide much randomness. 
+ */
+dojo.uuid.LightweightGenerator = new function() {
 
-dojo.provide("dojo.uuid.LightweightGenerator");
-dojo.uuid.LightweightGenerator = new function () {
 	var HEX_RADIX = 16;
+
+// --------------------------------------------------
+// Private functions
+// --------------------------------------------------
 	function _generateRandomEightCharacterHexString() {
-		var random32bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 32));
+		// Make random32bitNumber be a randomly generated floating point number
+		// between 0 and (4,294,967,296 - 1), inclusive.
+		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
 		var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
 		while (eightCharacterHexString.length < 8) {
 			eightCharacterHexString = "0" + eightCharacterHexString;
 		}
-		return eightCharacterHexString;
+		return eightCharacterHexString; // for example: "3B12F1DF"
 	}
-	this.generate = function (returnType) {
+
+// --------------------------------------------------
+// Public functions
+// --------------------------------------------------
+
+/**
+ * This function generates random UUIDs, meaning "version 4" UUIDs.
+ * For example, a typical generated value would be something like
+ * "3b12f1df-5232-4804-897e-917bf397618a".
+ *
+ * Examples:
+ * <pre>
+ *   var string = dojo.uuid.LightweightGenerator.generate();
+ *   var string = dojo.uuid.LightweightGenerator.generate(String);
+ *   var uuid   = dojo.uuid.LightweightGenerator.generate(dojo.uuid.Uuid);
+ * </pre>
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	A newly generated version 4 UUID.
+ */
+	this.generate = function(returnType) {
 		var hyphen = "-";
-		var versionCodeForRandomlyGeneratedUuids = "4";
-		var variantCodeForDCEUuids = "8";
+		var versionCodeForRandomlyGeneratedUuids = "4"; // 8 == binary2hex("0100")
+		var variantCodeForDCEUuids = "8"; // 8 == binary2hex("1000")
 		var a = _generateRandomEightCharacterHexString();
 		var b = _generateRandomEightCharacterHexString();
 		b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
@@ -39,4 +80,3 @@
 		return returnValue;
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/uuid/NameBasedGenerator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/NameBasedGenerator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/NameBasedGenerator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,17 +8,36 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.uuid.NameBasedGenerator");
 
+dojo.uuid.NameBasedGenerator = new function() {
 
-dojo.provide("dojo.uuid.NameBasedGenerator");
-dojo.uuid.NameBasedGenerator = new function () {
-	this.generate = function (returnType) {
-		dojo.unimplemented("dojo.uuid.NameBasedGenerator.generate");
-		var returnValue = "00000000-0000-0000-0000-000000000000";
+/**
+ * This function generates name-based UUIDs, meaning "version 3" 
+ * and "version 5" UUIDs.
+ *
+ * Examples:
+ * <pre>
+ *   var string = dojo.uuid.NameBasedGenerator.generate();
+ *   var string = dojo.uuid.NameBasedGenerator.generate(String);
+ *   var uuid   = dojo.uuid.NameBasedGenerator.generate(dojo.uuid.Uuid);
+ * </pre>
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	A newly generated version 3 or version 5 UUID.
+ */
+	this.generate = function(returnType) {
+		dojo.unimplemented('dojo.uuid.NameBasedGenerator.generate');
+		
+		// FIXME:
+		// For an algorithm to generate name-based UUIDs, 
+		// see sections 4.3 of RFC 4122:
+		//  http://www.ietf.org/rfc/rfc4122.txt
+		
+		var returnValue = "00000000-0000-0000-0000-000000000000"; // FIXME
 		if (returnType && (returnType != String)) {
 			returnValue = new returnType(returnValue);
 		}
 		return returnValue;
 	};
-}();
-
+}();
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/uuid/NilGenerator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/NilGenerator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/NilGenerator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,16 +8,31 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.uuid.NilGenerator");
 
+dojo.uuid.NilGenerator = new function() {
 
-dojo.provide("dojo.uuid.NilGenerator");
-dojo.uuid.NilGenerator = new function () {
-	this.generate = function (returnType) {
+/**
+ * This function returns the Nil UUID: 
+ * "00000000-0000-0000-0000-000000000000".
+ * The Nil UUID is described in section 4.1.7 of
+ * RFC 4122: http://www.ietf.org/rfc/rfc4122.txt
+ *
+ * Examples:
+ * <pre>
+ *   var string = dojo.uuid.NilGenerator.generate();
+ *   var string = dojo.uuid.NilGenerator.generate(String);
+ *   var uuid   = dojo.uuid.NilGenerator.generate(dojo.uuid.Uuid);
+ * </pre>
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	The nil UUID.
+ */
+	this.generate = function(returnType) {
 		var returnValue = "00000000-0000-0000-0000-000000000000";
 		if (returnType && (returnType != String)) {
 			returnValue = new returnType(returnValue);
 		}
 		return returnValue;
 	};
-}();
-
+}();
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/uuid/RandomGenerator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/RandomGenerator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/RandomGenerator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,17 +8,37 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.uuid.RandomGenerator");
 
+dojo.uuid.RandomGenerator = new function() {
 
-dojo.provide("dojo.uuid.RandomGenerator");
-dojo.uuid.RandomGenerator = new function () {
-	this.generate = function (returnType) {
-		dojo.unimplemented("dojo.uuid.RandomGenerator.generate");
-		var returnValue = "00000000-0000-0000-0000-000000000000";
+/**
+ * This function generates random UUIDs, meaning "version 4" UUIDs.
+ * For example, a typical generated value would be something like
+ * "3b12f1df-5232-4804-897e-917bf397618a".
+ *
+ * Examples:
+ * <pre>
+ *   var string = dojo.uuid.RandomGenerator.generate();
+ *   var string = dojo.uuid.RandomGenerator.generate(String);
+ *   var uuid   = dojo.uuid.RandomGenerator.generate(dojo.uuid.Uuid);
+ * </pre>
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	A newly generated version 4 UUID.
+ */
+	this.generate = function(returnType) {
+		dojo.unimplemented('dojo.uuid.RandomGenerator.generate');
+		
+		// FIXME:
+		// For an algorithm to generate a random UUID, see
+		// sections 4.4 and 4.5 of RFC 4122:
+		//  http://www.ietf.org/rfc/rfc4122.txt
+		
+		var returnValue = "00000000-0000-0000-0000-000000000000"; // FIXME
 		if (returnType && (returnType != String)) {
 			returnValue = new returnType(returnValue);
 		}
 		return returnValue;
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/uuid/TimeBasedGenerator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/TimeBasedGenerator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/TimeBasedGenerator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,14 +8,23 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.uuid.TimeBasedGenerator");
+dojo.require("dojo.lang.*");
 
+dojo.uuid.TimeBasedGenerator = new function() {
 
-dojo.provide("dojo.uuid.TimeBasedGenerator");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.type");
-dojo.require("dojo.lang.assert");
-dojo.uuid.TimeBasedGenerator = new function () {
+// --------------------------------------------------
+// Public constants
+// --------------------------------------------------
+	// Number of hours between October 15, 1582 and January 1, 1970:
 	this.GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
+	
+	// Number of seconds between October 15, 1582 and January 1, 1970:
+	//   this.GREGORIAN_CHANGE_OFFSET_IN_SECONDS = 12219292800;	
+	
+// --------------------------------------------------
+// Private variables
+// --------------------------------------------------
 	var _uuidPseudoNodeString = null;
 	var _uuidClockSeqString = null;
 	var _dateValueOfPreviousUuid = null;
@@ -24,34 +33,65 @@
 	var _cachedHundredNanosecondIntervalsPerMillisecond = null;
 	var _uniformNode = null;
 	var HEX_RADIX = 16;
+
+// --------------------------------------------------
+// Private functions
+// --------------------------------------------------
+
+/**
+ * Given an array which holds a 64-bit number broken into 4 16-bit elements,
+ * this method carries any excess bits (greater than 16-bits) from each array
+ * element into the next.
+ *
+ * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
+ */
 	function _carry(arrayA) {
 		arrayA[2] += arrayA[3] >>> 16;
-		arrayA[3] &= 65535;
+		arrayA[3] &= 0xFFFF;
 		arrayA[1] += arrayA[2] >>> 16;
-		arrayA[2] &= 65535;
+		arrayA[2] &= 0xFFFF;
 		arrayA[0] += arrayA[1] >>> 16;
-		arrayA[1] &= 65535;
+		arrayA[1] &= 0xFFFF;
 		dojo.lang.assert((arrayA[0] >>> 16) === 0);
 	}
+
+/**
+ * Given a floating point number, this method returns an array which holds a
+ * 64-bit number broken into 4 16-bit elements.
+ *
+ * @param	x	A floating point number.
+ * @return   An array with 4 elements, each of which is a 16-bit number.
+ */
 	function _get64bitArrayFromFloat(x) {
 		var result = new Array(0, 0, 0, 0);
-		result[3] = x % 65536;
+		result[3] = x % 0x10000;
 		x -= result[3];
-		x /= 65536;
-		result[2] = x % 65536;
+		x /= 0x10000;
+		result[2] = x % 0x10000;
 		x -= result[2];
-		x /= 65536;
-		result[1] = x % 65536;
+		x /= 0x10000;
+		result[1] = x % 0x10000;
 		x -= result[1];
-		x /= 65536;
+		x /= 0x10000;
 		result[0] = x;
 		return result;
 	}
+
+/**
+ * Takes two arrays, each of which holds a 64-bit number broken into 4
+ * 16-bit elements, and returns a new array that holds a 64-bit number
+ * that is the sum of the two original numbers.
+ *
+ * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
+ * @param	arrayB	An array with 4 elements, each of which is a 16-bit number.
+ * @return   An array with 4 elements, each of which is a 16-bit number.
+ */
 	function _addTwo64bitArrays(arrayA, arrayB) {
 		dojo.lang.assertType(arrayA, Array);
 		dojo.lang.assertType(arrayB, Array);
 		dojo.lang.assert(arrayA.length == 4);
 		dojo.lang.assert(arrayB.length == 4);
+	
 		var result = new Array(0, 0, 0, 0);
 		result[3] = arrayA[3] + arrayB[3];
 		result[2] = arrayA[2] + arrayB[2];
@@ -60,31 +100,31 @@
 		_carry(result);
 		return result;
 	}
+
+/**
+ * Takes two arrays, each of which holds a 64-bit number broken into 4
+ * 16-bit elements, and returns a new array that holds a 64-bit number
+ * that is the product of the two original numbers.
+ *
+ * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
+ * @param	arrayB	An array with 4 elements, each of which is a 16-bit number.
+ * @return   An array with 4 elements, each of which is a 16-bit number.
+ */
 	function _multiplyTwo64bitArrays(arrayA, arrayB) {
 		dojo.lang.assertType(arrayA, Array);
 		dojo.lang.assertType(arrayB, Array);
 		dojo.lang.assert(arrayA.length == 4);
 		dojo.lang.assert(arrayB.length == 4);
+	
 		var overflow = false;
-		if (arrayA[0] * arrayB[0] !== 0) {
-			overflow = true;
-		}
-		if (arrayA[0] * arrayB[1] !== 0) {
-			overflow = true;
-		}
-		if (arrayA[0] * arrayB[2] !== 0) {
-			overflow = true;
-		}
-		if (arrayA[1] * arrayB[0] !== 0) {
-			overflow = true;
-		}
-		if (arrayA[1] * arrayB[1] !== 0) {
-			overflow = true;
-		}
-		if (arrayA[2] * arrayB[0] !== 0) {
-			overflow = true;
-		}
+		if (arrayA[0] * arrayB[0] !== 0) { overflow = true; }
+		if (arrayA[0] * arrayB[1] !== 0) { overflow = true; }
+		if (arrayA[0] * arrayB[2] !== 0) { overflow = true; }
+		if (arrayA[1] * arrayB[0] !== 0) { overflow = true; }
+		if (arrayA[1] * arrayB[1] !== 0) { overflow = true; }
+		if (arrayA[2] * arrayB[0] !== 0) { overflow = true; }
 		dojo.lang.assert(!overflow);
+	
 		var result = new Array(0, 0, 0, 0);
 		result[0] += arrayA[0] * arrayB[3];
 		_carry(result);
@@ -108,22 +148,56 @@
 		_carry(result);
 		return result;
 	}
+
+/**
+ * Pads a string with leading zeros and returns the result.
+ * For example:
+ * <pre>
+ *   result = _padWithLeadingZeros("abc", 6);
+ *   dojo.lang.assert(result == "000abc");
+ * </pre>
+ *
+ * @param	string	A string to add padding to.
+ * @param	desiredLength	The number of characters the return string should have.
+ * @return   A string.
+ */
 	function _padWithLeadingZeros(string, desiredLength) {
 		while (string.length < desiredLength) {
 			string = "0" + string;
 		}
 		return string;
 	}
+
+/**
+ * Returns a randomly generated 8-character string of hex digits.
+ *
+ * @return   An 8-character hex string.
+ */
 	function _generateRandomEightCharacterHexString() {
-		var random32bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 32));
+		// FIXME: This probably isn't a very high quality random number.
+	
+		// Make random32bitNumber be a randomly generated floating point number
+		// between 0 and (4,294,967,296 - 1), inclusive.
+		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
+	
 		var eightCharacterString = random32bitNumber.toString(HEX_RADIX);
 		while (eightCharacterString.length < 8) {
 			eightCharacterString = "0" + eightCharacterString;
 		}
 		return eightCharacterString;
 	}
+
+/**
+ * Generates a time-based UUID, meaning a version 1 UUID.  JavaScript
+ * code running in a browser doesn't have access to the IEEE 802.3 address
+ * of the computer, so if a node value isn't supplied, we generate a random 
+ * pseudonode value instead.
+ *
+ * @param	node	Optional. A 12-character string to use as the node in the new UUID.
+ * @return   Returns a 36 character string, which will look something like "b4308fb0-86cd-11da-a72b-0800200c9a66".
+ */
 	function _generateUuidString(node) {
-		dojo.lang.assertType(node, String, {optional:true});
+		dojo.lang.assertType(node, [String, "optional"]);
 		if (node) {
 			dojo.lang.assert(node.length == 12);
 		} else {
@@ -131,8 +205,8 @@
 				node = _uniformNode;
 			} else {
 				if (!_uuidPseudoNodeString) {
-					var pseudoNodeIndicatorBit = 32768;
-					var random15bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 15));
+					var pseudoNodeIndicatorBit = 0x8000;
+					var random15bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 15) );
 					var leftmost4HexCharacters = (pseudoNodeIndicatorBit | random15bitNumber).toString(HEX_RADIX);
 					_uuidPseudoNodeString = leftmost4HexCharacters + _generateRandomEightCharacterHexString();
 				}
@@ -140,12 +214,18 @@
 			}
 		}
 		if (!_uuidClockSeqString) {
-			var variantCodeForDCEUuids = 32768;
-			var random14bitNumber = Math.floor((Math.random() % 1) * Math.pow(2, 14));
+			var variantCodeForDCEUuids = 0x8000; // 10--------------, i.e. uses only first two of 16 bits.
+			var random14bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 14) );
 			_uuidClockSeqString = (variantCodeForDCEUuids | random14bitNumber).toString(HEX_RADIX);
 		}
+	
+		// Maybe we should think about trying to make the code more readable to
+		// newcomers by creating a class called "WholeNumber" that encapsulates
+		// the methods and data structures for working with these arrays that
+		// hold 4 16-bit numbers?  And then these variables below have names
+		// like "wholeSecondsPerHour" rather than "arraySecondsPerHour"?
 		var now = new Date();
-		var millisecondsSince1970 = now.valueOf();
+		var millisecondsSince1970 = now.valueOf(); // milliseconds since midnight 01 January, 1970 UTC.
 		var nowArray = _get64bitArrayFromFloat(millisecondsSince1970);
 		if (!_cachedMillisecondsBetween1582and1970) {
 			var arraySecondsPerHour = _get64bitArrayFromFloat(60 * 60);
@@ -158,11 +238,18 @@
 		var arrayMillisecondsSince1970 = nowArray;
 		var arrayMillisecondsSince1582 = _addTwo64bitArrays(_cachedMillisecondsBetween1582and1970, arrayMillisecondsSince1970);
 		var arrayHundredNanosecondIntervalsSince1582 = _multiplyTwo64bitArrays(arrayMillisecondsSince1582, _cachedHundredNanosecondIntervalsPerMillisecond);
+	
 		if (now.valueOf() == _dateValueOfPreviousUuid) {
 			arrayHundredNanosecondIntervalsSince1582[3] += _nextIntraMillisecondIncrement;
 			_carry(arrayHundredNanosecondIntervalsSince1582);
 			_nextIntraMillisecondIncrement += 1;
 			if (_nextIntraMillisecondIncrement == 10000) {
+				// If we've gotten to here, it means we've already generated 10,000
+				// UUIDs in this single millisecond, which is the most that the UUID
+				// timestamp field allows for.  So now we'll just sit here and wait
+				// for a fraction of a millisecond, so as to ensure that the next
+				// time this method is called there will be a different millisecond
+				// value in the timestamp field.
 				while (now.valueOf() == _dateValueOfPreviousUuid) {
 					now = new Date();
 				}
@@ -171,7 +258,8 @@
 			_dateValueOfPreviousUuid = now.valueOf();
 			_nextIntraMillisecondIncrement = 1;
 		}
-		var hexTimeLowLeftHalf = arrayHundredNanosecondIntervalsSince1582[2].toString(HEX_RADIX);
+	
+		var hexTimeLowLeftHalf  = arrayHundredNanosecondIntervalsSince1582[2].toString(HEX_RADIX);
 		var hexTimeLowRightHalf = arrayHundredNanosecondIntervalsSince1582[3].toString(HEX_RADIX);
 		var hexTimeLow = _padWithLeadingZeros(hexTimeLowLeftHalf, 4) + _padWithLeadingZeros(hexTimeLowRightHalf, 4);
 		var hexTimeMid = arrayHundredNanosecondIntervalsSince1582[1].toString(HEX_RADIX);
@@ -179,21 +267,79 @@
 		var hexTimeHigh = arrayHundredNanosecondIntervalsSince1582[0].toString(HEX_RADIX);
 		hexTimeHigh = _padWithLeadingZeros(hexTimeHigh, 3);
 		var hyphen = "-";
-		var versionCodeForTimeBasedUuids = "1";
-		var resultUuid = hexTimeLow + hyphen + hexTimeMid + hyphen + versionCodeForTimeBasedUuids + hexTimeHigh + hyphen + _uuidClockSeqString + hyphen + node;
+		var versionCodeForTimeBasedUuids = "1"; // binary2hex("0001")
+		var resultUuid = hexTimeLow + hyphen + hexTimeMid + hyphen +
+					versionCodeForTimeBasedUuids + hexTimeHigh + hyphen +
+					_uuidClockSeqString + hyphen + node;
 		resultUuid = resultUuid.toLowerCase();
 		return resultUuid;
 	}
-	this.setNode = function (node) {
+
+// --------------------------------------------------
+// Public functions
+// --------------------------------------------------
+
+/**
+ * Sets the 'node' value that will be included in generated UUIDs.
+ *
+ * @param	node	A 12-character hex string representing a pseudoNode or hardwareNode.
+ */
+	this.setNode = function(node) {
 		dojo.lang.assert((node === null) || (node.length == 12));
 		_uniformNode = node;
 	};
-	this.getNode = function () {
+
+/**
+ * Returns the 'node' value that will be included in generated UUIDs.
+ *
+ * @return	A 12-character hex string representing a pseudoNode or hardwareNode.
+ */
+	this.getNode = function() {
 		return _uniformNode;
 	};
-	this.generate = function (input) {
+
+/**
+ * This function generates time-based UUIDs, meaning "version 1" UUIDs.
+ *
+ * For more info, see
+ *   http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
+ *   http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
+ *   http://kruithof.xs4all.nl/uuid/uuidgen
+ *   http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
+ *   http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html
+ *
+ * Examples:
+ * <pre>
+ *   var generate = dojo.uuid.TimeBasedGenerator.generate;
+ *   var uuid;   // an instance of dojo.uuid.Uuid
+ *   var string; // a simple string literal
+ *   string = generate();
+ *   string = generate(String);
+ *   uuid   = generate(dojo.uuid.Uuid);
+ *   string = generate("017bf397618a");
+ *   string = generate({node: "017bf397618a"});         // hardwareNode
+ *   string = generate({node: "f17bf397618a"});         // pseudoNode
+ *   string = generate({hardwareNode: "017bf397618a"});
+ *   string = generate({pseudoNode:   "f17bf397618a"});
+ *   string = generate({node: "017bf397618a", returnType: String});
+ *   uuid   = generate({node: "017bf397618a", returnType: dojo.uuid.Uuid});
+ *   dojo.uuid.TimeBasedGenerator.setNode("017bf397618a");
+ *   string = generate(); // the generated UUID has node == "017bf397618a"
+ *   uuid   = generate(dojo.uuid.Uuid); // the generated UUID has node == "017bf397618a"
+ * </pre>
+ *
+ * @param	class	The type of instance to return.
+ * @param	node	A 12-character hex string representing a pseudoNode or hardwareNode.
+ * @namedParam	node	A 12-character hex string representing a pseudoNode or hardwareNode.
+ * @namedParam	hardwareNode	A 12-character hex string containing an IEEE 802.3 network node identificator.
+ * @namedParam	pseudoNode	A 12-character hex string representing a pseudoNode.
+ * @namedParam	returnType	The type of instance to return.
+ * @return	A newly generated version 1 UUID.
+ */
+	this.generate = function(input) {
 		var nodeString = null;
 		var returnType = null;
+		
 		if (input) {
 			if (dojo.lang.isObject(input) && !dojo.lang.isBuiltIn(input)) {
 				var namedParameters = input;
@@ -206,14 +352,14 @@
 					var firstCharacter = nodeString.charAt(0);
 					var firstDigit = parseInt(firstCharacter, HEX_RADIX);
 					if (hardwareNode) {
-						dojo.lang.assert((firstDigit >= 0) && (firstDigit <= 7));
+						dojo.lang.assert((firstDigit >= 0x0) && (firstDigit <= 0x7));
 					}
 					if (pseudoNode) {
-						dojo.lang.assert((firstDigit >= 8) && (firstDigit <= 15));
+						dojo.lang.assert((firstDigit >= 0x8) && (firstDigit <= 0xF));
 					}
 				}
 				returnType = namedParameters["returnType"];
-				dojo.lang.assertType(returnType, Function, {optional:true});
+				dojo.lang.assertType(returnType, [Function, "optional"]);
 			} else {
 				if (dojo.lang.isString(input)) {
 					nodeString = input;
@@ -230,8 +376,9 @@
 				var integer = parseInt(nodeString, HEX_RADIX);
 				dojo.lang.assert(isFinite(integer));
 			}
-			dojo.lang.assertType(returnType, Function, {optional:true});
+			dojo.lang.assertType(returnType, [Function, "optional"]);
 		}
+		
 		var uuidString = _generateUuidString(nodeString);
 		var returnValue;
 		if (returnType && (returnType != String)) {
@@ -242,4 +389,3 @@
 		return returnValue;
 	};
 }();
-

Modified: tags/parley-0.53/root/static/magic/src/uuid/Uuid.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/Uuid.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/Uuid.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,12 +8,33 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.uuid.Uuid");
+dojo.require("dojo.lang.*");
 
-
-dojo.provide("dojo.uuid.Uuid");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.assert");
-dojo.uuid.Uuid = function (input) {
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+/**
+ * The Uuid class offers methods for inspecting existing UUIDs.
+ *
+ * Examples:
+ * <pre>
+ *   var uuid;
+ *   uuid = new dojo.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
+ *   uuid = new dojo.uuid.Uuid(); // "00000000-0000-0000-0000-000000000000"
+ *   uuid = new dojo.uuid.Uuid(dojo.uuid.RandomGenerator);
+ *   uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);
+ *
+ *   dojo.uuid.Uuid.setGenerator(dojo.uuid.RandomGenerator);
+ *   uuid = new dojo.uuid.Uuid();
+ *   dojo.lang.assert(!uuid.isEqual(dojo.uuid.Uuid.NIL_UUID));
+ * </pre>
+ *
+ * @scope	public instance constructor
+ * @param	uuidString	A 36-character string that conforms to the UUID spec.
+ * @param	generator	A UUID generator, such as dojo.uuid.TimeBasedGenerator.
+ */
+dojo.uuid.Uuid = function(input) {
 	this._uuidString = dojo.uuid.Uuid.NIL_UUID;
 	if (input) {
 		if (dojo.lang.isString(input)) {
@@ -25,6 +46,7 @@
 				this._uuidString = generator.generate();
 				dojo.lang.assert(this.isValid());
 			} else {
+				// we got passed something other than a string
 				dojo.lang.assert(false, "The dojo.uuid.Uuid() constructor must be initializated with a UUID string.");
 			}
 		}
@@ -36,63 +58,163 @@
 		}
 	}
 };
+
+// -------------------------------------------------------------------
+// Public constants
+// -------------------------------------------------------------------
 dojo.uuid.Uuid.NIL_UUID = "00000000-0000-0000-0000-000000000000";
-dojo.uuid.Uuid.Version = {UNKNOWN:0, TIME_BASED:1, DCE_SECURITY:2, NAME_BASED_MD5:3, RANDOM:4, NAME_BASED_SHA1:5};
-dojo.uuid.Uuid.Variant = {NCS:"0", DCE:"10", MICROSOFT:"110", UNKNOWN:"111"};
+dojo.uuid.Uuid.Version = {
+	UNKNOWN: 0,
+	TIME_BASED: 1,
+	DCE_SECURITY: 2,
+	NAME_BASED_MD5: 3,
+	RANDOM: 4,
+	NAME_BASED_SHA1: 5 };
+dojo.uuid.Uuid.Variant = {
+	NCS: "0",
+	DCE: "10",
+	MICROSOFT: "110",
+	UNKNOWN: "111" };
 dojo.uuid.Uuid.HEX_RADIX = 16;
-dojo.uuid.Uuid.compare = function (uuidOne, uuidTwo) {
+
+// -------------------------------------------------------------------
+// Public class methods
+// -------------------------------------------------------------------
+/**
+ * Given two UUIDs to compare, this method returns 0, 1, or -1.
+ * This method is designed to be used by sorting routines, like
+ * the JavaScript built-in Array sort() method.
+ * This implementation is intended to match the sample 
+ * implementation in IETF RFC 4122: 
+ * http://www.ietf.org/rfc/rfc4122.txt
+ * 
+ * Example:
+ * <pre>
+ *   var generator = dojo.uuid.TimeBasedGenerator;
+ *   var a = new dojo.uuid.Uuid(generator);
+ *   var b = new dojo.uuid.Uuid(generator);
+ *   var c = new dojo.uuid.Uuid(generator);
+ *   var array = new Array(a, b, c);
+ *   array.sort(dojo.uuid.Uuid.compare);
+ * </pre>
+ *
+ * @param	uuidOne	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @param	uuidTwo	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns either 0, 1, or -1.
+ */
+dojo.uuid.Uuid.compare = function(uuidOne, uuidTwo) {
 	var uuidStringOne = uuidOne.toString();
 	var uuidStringTwo = uuidTwo.toString();
-	if (uuidStringOne > uuidStringTwo) {
-		return 1;
-	}
-	if (uuidStringOne < uuidStringTwo) {
-		return -1;
-	}
+	if (uuidStringOne > uuidStringTwo) return 1;
+	if (uuidStringOne < uuidStringTwo) return -1;
 	return 0;
 };
-dojo.uuid.Uuid.setGenerator = function (generator) {
+
+/**
+ * Sets the default generator, which will be used by the 
+ * "new dojo.uuid.Uuid()" constructor if no parameters
+ * are passed in.
+ *
+ * @param	generator	A UUID generator, such as dojo.uuid.TimeBasedGenerator.
+ * @return   Returns true or false. True if this UUID is equal to the otherUuid.
+ */
+dojo.uuid.Uuid.setGenerator = function(generator) {
 	dojo.lang.assert(!generator || (dojo.lang.isObject(generator) && generator.generate));
 	dojo.uuid.Uuid._ourGenerator = generator;
 };
-dojo.uuid.Uuid.getGenerator = function () {
+
+/**
+ * Returns the default generator.  See setGenerator().
+ *
+ * @return   A UUID generator, such as dojo.uuid.TimeBasedGenerator.
+ */
+dojo.uuid.Uuid.getGenerator = function(generator) {
 	return dojo.uuid.Uuid._ourGenerator;
 };
-dojo.uuid.Uuid.prototype.toString = function (format) {
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+/**
+ * Returns a 36-character string representing the UUID, such 
+ * as "3b12f1df-5232-4804-897e-917bf397618a".
+ * 
+ * Examples:
+ * <pre>
+ *   var uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);
+ *   var s;
+ *   s = uuid.toString();       //  eb529fec-6498-11d7-b236-000629ba5445
+ *   s = uuid.toString('{}');   // {eb529fec-6498-11d7-b236-000629ba5445}
+ *   s = uuid.toString('()');   // (eb529fec-6498-11d7-b236-000629ba5445)
+ *   s = uuid.toString('""');   // "eb529fec-6498-11d7-b236-000629ba5445"
+ *   s = uuid.toString("''");   // 'eb529fec-6498-11d7-b236-000629ba5445'
+ *   s = uuid.toString('!-');   //  eb529fec649811d7b236000629ba5445
+ *   s = uuid.toString('urn');  //  urn:uuid:eb529fec-6498-11d7-b236-000629ba5445
+ * </pre>
+ *
+ * @param	uuidOne	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns a standard 36-character UUID string, or something similar. 
+ */
+dojo.uuid.Uuid.prototype.toString = function(format) {
 	if (format) {
 		switch (format) {
-		  case "{}":
-			return "{" + this._uuidString + "}";
-			break;
-		  case "()":
-			return "(" + this._uuidString + ")";
-			break;
-		  case "\"\"":
-			return "\"" + this._uuidString + "\"";
-			break;
-		  case "''":
-			return "'" + this._uuidString + "'";
-			break;
-		  case "urn":
-			return "urn:uuid:" + this._uuidString;
-			break;
-		  case "!-":
-			return this._uuidString.split("-").join("");
-			break;
-		  default:
-			dojo.lang.assert(false, "The toString() method of dojo.uuid.Uuid was passed a bogus format.");
+			case '{}':
+				return '{' + this._uuidString + '}';
+				break;
+			case '()':
+				return '(' + this._uuidString + ')';
+				break;
+			case '""':
+				return '"' + this._uuidString + '"';
+				break;
+			case "''":
+				return "'" + this._uuidString + "'";
+				break;
+			case 'urn':
+				return 'urn:uuid:' + this._uuidString;
+				break;
+			case '!-':
+				return this._uuidString.split('-').join('');
+				break;
+			default:
+				// we got passed something other than what we expected
+				dojo.lang.assert(false, "The toString() method of dojo.uuid.Uuid was passed a bogus format.");
 		}
 	} else {
 		return this._uuidString;
 	}
 };
-dojo.uuid.Uuid.prototype.compare = function (otherUuid) {
+
+/**
+ * Compares this UUID to another UUID, and returns 0, 1, or -1.
+ * This implementation is intended to match the sample 
+ * implementation in IETF RFC 4122: 
+ * http://www.ietf.org/rfc/rfc4122.txt
+ *
+ * @param	otherUuid	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns either 0, 1, or -1.
+ */
+dojo.uuid.Uuid.prototype.compare = function(otherUuid) {
 	return dojo.uuid.Uuid.compare(this, otherUuid);
 };
-dojo.uuid.Uuid.prototype.isEqual = function (otherUuid) {
+
+/**
+ * Returns true if this UUID is equal to the otherUuid, or
+ * false otherwise.
+ *
+ * @param	otherUuid	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns true or false. True if this UUID is equal to the otherUuid.
+ */
+dojo.uuid.Uuid.prototype.isEqual = function(otherUuid) {
 	return (this.compare(otherUuid) == 0);
 };
-dojo.uuid.Uuid.prototype.isValid = function () {
+
+/**
+ * Returns true if the UUID was initialized with a valid value.
+ *
+ * @return   True if the UUID is valid, or false if it is not.
+ */
+dojo.uuid.Uuid.prototype.isValid = function() {
 	try {
 		dojo.lang.assertType(this._uuidString, String);
 		dojo.lang.assert(this._uuidString.length == 36);
@@ -110,106 +232,192 @@
 			dojo.lang.assert(isFinite(integer));
 		}
 		return true;
-	}
-	catch (e) {
+	} catch (e) {
 		return false;
 	}
 };
-dojo.uuid.Uuid.prototype.getVariant = function () {
+
+/**
+ * Returns a variant code that indicates what type of UUID this is.
+ * For example:
+ * <pre>
+ *   var uuid = new dojo.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
+ *   var variant = uuid.getVariant();
+ *   dojo.lang.assert(variant == dojo.uuid.Uuid.Variant.DCE);
+ * </pre>
+ *
+ * @return   Returns one of the enumarted dojo.uuid.Uuid.Variant values.
+ */
+dojo.uuid.Uuid.prototype.getVariant = function() {
+	// "3b12f1df-5232-4804-897e-917bf397618a"
+	//                     ^
+	//                     |
+	//         (variant "10__" == DCE)
 	var variantCharacter = this._uuidString.charAt(19);
 	var variantNumber = parseInt(variantCharacter, dojo.uuid.Uuid.HEX_RADIX);
 	dojo.lang.assert((variantNumber >= 0) && (variantNumber <= 16));
+
 	if (!dojo.uuid.Uuid._ourVariantLookupTable) {
 		var Variant = dojo.uuid.Uuid.Variant;
 		var lookupTable = [];
-		lookupTable[0] = Variant.NCS;
-		lookupTable[1] = Variant.NCS;
-		lookupTable[2] = Variant.NCS;
-		lookupTable[3] = Variant.NCS;
-		lookupTable[4] = Variant.NCS;
-		lookupTable[5] = Variant.NCS;
-		lookupTable[6] = Variant.NCS;
-		lookupTable[7] = Variant.NCS;
-		lookupTable[8] = Variant.DCE;
-		lookupTable[9] = Variant.DCE;
-		lookupTable[10] = Variant.DCE;
-		lookupTable[11] = Variant.DCE;
-		lookupTable[12] = Variant.MICROSOFT;
-		lookupTable[13] = Variant.MICROSOFT;
-		lookupTable[14] = Variant.UNKNOWN;
-		lookupTable[15] = Variant.UNKNOWN;
+
+		lookupTable[0x0] = Variant.NCS;       // 0000
+		lookupTable[0x1] = Variant.NCS;       // 0001
+		lookupTable[0x2] = Variant.NCS;       // 0010
+		lookupTable[0x3] = Variant.NCS;       // 0011
+
+		lookupTable[0x4] = Variant.NCS;       // 0100
+		lookupTable[0x5] = Variant.NCS;       // 0101
+		lookupTable[0x6] = Variant.NCS;       // 0110
+		lookupTable[0x7] = Variant.NCS;       // 0111
+
+		lookupTable[0x8] = Variant.DCE;       // 1000
+		lookupTable[0x9] = Variant.DCE;       // 1001
+		lookupTable[0xA] = Variant.DCE;       // 1010
+		lookupTable[0xB] = Variant.DCE;       // 1011
+
+		lookupTable[0xC] = Variant.MICROSOFT; // 1100
+		lookupTable[0xD] = Variant.MICROSOFT; // 1101
+		lookupTable[0xE] = Variant.UNKNOWN;   // 1110
+		lookupTable[0xF] = Variant.UNKNOWN;   // 1111
+		
 		dojo.uuid.Uuid._ourVariantLookupTable = lookupTable;
 	}
+
 	return dojo.uuid.Uuid._ourVariantLookupTable[variantNumber];
 };
-dojo.uuid.Uuid.prototype.getVersion = function () {
+
+/**
+ * Returns a version number that indicates what type of UUID this is.
+ * For example:
+ * <pre>
+ *   var uuid = new dojo.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
+ *   var version = uuid.getVersion();
+ *   dojo.lang.assert(version == dojo.uuid.Uuid.Version.TIME_BASED);
+ * </pre>
+ *
+ * @return   Returns one of the enumerated dojo.uuid.Uuid.Version values.
+ * @throws   Throws an Error if this is not a DCE Variant UUID.
+ */
+dojo.uuid.Uuid.prototype.getVersion = function() {
 	if (!this._versionNumber) {
 		var errorMessage = "Called getVersion() on a dojo.uuid.Uuid that was not a DCE Variant UUID.";
 		dojo.lang.assert(this.getVariant() == dojo.uuid.Uuid.Variant.DCE, errorMessage);
+	
+		// "b4308fb0-86cd-11da-a72b-0800200c9a66"
+		//                ^
+		//                |
+		//       (version 1 == TIME_BASED)
 		var versionCharacter = this._uuidString.charAt(14);
 		this._versionNumber = parseInt(versionCharacter, dojo.uuid.Uuid.HEX_RADIX);
 	}
 	return this._versionNumber;
 };
-dojo.uuid.Uuid.prototype.getNode = function () {
+
+/**
+ * If this is a version 1 UUID (a time-based UUID), this method returns a 
+ * 12-character string with the "node" or "pseudonode" portion of the UUID, 
+ * which is the rightmost 12 characters.  
+ * Throws an Error if this is not a version 1 UUID.
+ *
+ * @return   Returns a 12-character string, which will look something like "917bf397618a".
+ * @throws   Throws an Error if this is not a version 1 UUID.
+ */
+dojo.uuid.Uuid.prototype.getNode = function() {
 	if (!this._nodeString) {
 		var errorMessage = "Called getNode() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.";
 		dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);
-		var arrayOfStrings = this._uuidString.split("-");
+
+		var arrayOfStrings = this._uuidString.split('-');
 		this._nodeString = arrayOfStrings[4];
 	}
 	return this._nodeString;
 };
-dojo.uuid.Uuid.prototype.getTimestamp = function (returnType) {
+
+/**
+ * If this is a version 1 UUID (a time-based UUID), this method returns 
+ * the timestamp value encoded in the UUID.  The caller can ask for the
+ * timestamp to be returned either as a JavaScript Date object or as a 
+ * 15-character string of hex digits.
+ * Throws an Error if this is not a version 1 UUID.
+ *
+ * Examples:
+ * <pre>
+ *   var uuid = new dojo.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
+ *   var date, string, hexString;
+ *   date   = uuid.getTimestamp();         // returns a JavaScript Date
+ *   date   = uuid.getTimestamp(Date);     // 
+ *   string = uuid.getTimestamp(String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
+ *   hexString = uuid.getTimestamp("hex"); // "1da86cdb4308fb0"
+ * </pre>
+ *
+ * @return   Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
+ * @throws   Throws an Error if this is not a version 1 UUID.
+ */
+dojo.uuid.Uuid.prototype.getTimestamp = function(returnType) {
 	var errorMessage = "Called getTimestamp() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.";
 	dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);
-	if (!returnType) {
-		returnType = null;
-	}
+	
+	if (!returnType) {returnType = null};
 	switch (returnType) {
-	  case "string":
-	  case String:
-		return this.getTimestamp(Date).toUTCString();
-		break;
-	  case "hex":
-		if (!this._timestampAsHexString) {
-			var arrayOfStrings = this._uuidString.split("-");
-			var hexTimeLow = arrayOfStrings[0];
-			var hexTimeMid = arrayOfStrings[1];
-			var hexTimeHigh = arrayOfStrings[2];
-			hexTimeHigh = hexTimeHigh.slice(1);
-			this._timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
-			dojo.lang.assert(this._timestampAsHexString.length == 15);
-		}
-		return this._timestampAsHexString;
-		break;
-	  case null:
-	  case "date":
-	  case Date:
-		if (!this._timestampAsDate) {
-			var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
-			var arrayOfParts = this._uuidString.split("-");
-			var timeLow = parseInt(arrayOfParts[0], dojo.uuid.Uuid.HEX_RADIX);
-			var timeMid = parseInt(arrayOfParts[1], dojo.uuid.Uuid.HEX_RADIX);
-			var timeHigh = parseInt(arrayOfParts[2], dojo.uuid.Uuid.HEX_RADIX);
-			var hundredNanosecondIntervalsSince1582 = timeHigh & 4095;
-			hundredNanosecondIntervalsSince1582 <<= 16;
-			hundredNanosecondIntervalsSince1582 += timeMid;
-			hundredNanosecondIntervalsSince1582 *= 4294967296;
-			hundredNanosecondIntervalsSince1582 += timeLow;
-			var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
-			var secondsPerHour = 60 * 60;
-			var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
-			var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
-			var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
-			var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
-			this._timestampAsDate = new Date(millisecondsSince1970);
-		}
-		return this._timestampAsDate;
-		break;
-	  default:
-		dojo.lang.assert(false, "The getTimestamp() method dojo.uuid.Uuid was passed a bogus returnType: " + returnType);
-		break;
+		case "string":
+		case String:
+			return this.getTimestamp(Date).toUTCString();
+			break;
+		case "hex":
+			// Return a 15-character string of hex digits containing the 
+			// timestamp for this UUID, with the high-order bits first.
+			if (!this._timestampAsHexString) {
+				var arrayOfStrings = this._uuidString.split('-');
+				var hexTimeLow = arrayOfStrings[0];
+				var hexTimeMid = arrayOfStrings[1];
+				var hexTimeHigh = arrayOfStrings[2];
+			
+				// Chop off the leading "1" character, which is the UUID 
+				// version number for time-based UUIDs.
+				hexTimeHigh = hexTimeHigh.slice(1);
+			
+				this._timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
+				dojo.lang.assert(this._timestampAsHexString.length == 15);
+			}
+			return this._timestampAsHexString;
+			break;
+		case null: // no returnType was specified, so default to Date
+		case "date":
+		case Date:
+			// Return a JavaScript Date object. 
+			if (!this._timestampAsDate) {
+				var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
+			
+				var arrayOfParts = this._uuidString.split('-');
+				var timeLow = parseInt(arrayOfParts[0], dojo.uuid.Uuid.HEX_RADIX);
+				var timeMid = parseInt(arrayOfParts[1], dojo.uuid.Uuid.HEX_RADIX);
+				var timeHigh = parseInt(arrayOfParts[2], dojo.uuid.Uuid.HEX_RADIX);
+				var hundredNanosecondIntervalsSince1582 = timeHigh & 0x0FFF;
+				hundredNanosecondIntervalsSince1582 <<= 16;
+				hundredNanosecondIntervalsSince1582 += timeMid;
+				// What we really want to do next is shift left 32 bits, but the 
+				// result will be too big to fit in an int, so we'll multiply by 2^32,
+				// and the result will be a floating point approximation.
+				hundredNanosecondIntervalsSince1582 *= 0x100000000;
+				hundredNanosecondIntervalsSince1582 += timeLow;
+				var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
+			
+				// Again, this will be a floating point approximation.
+				// We can make things exact later if we need to.
+				var secondsPerHour = 60 * 60;
+				var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
+				var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
+				var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
+				var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
+			
+				this._timestampAsDate = new Date(millisecondsSince1970);
+			}
+			return this._timestampAsDate;
+			break;
+		default:
+			// we got passed something other than a valid returnType
+			dojo.lang.assert(false, "The getTimestamp() method dojo.uuid.Uuid was passed a bogus returnType: " + returnType);
+			break;
 	}
 };
-

Modified: tags/parley-0.53/root/static/magic/src/uuid/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/uuid/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/uuid/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,15 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.uuid.Uuid", "dojo.uuid.LightweightGenerator", "dojo.uuid.RandomGenerator", "dojo.uuid.TimeBasedGenerator", "dojo.uuid.NameBasedGenerator", "dojo.uuid.NilGenerator"]});
+dojo.kwCompoundRequire({
+	common: [
+		"dojo.uuid.Uuid",
+		"dojo.uuid.LightweightGenerator",
+		"dojo.uuid.RandomGenerator",
+		"dojo.uuid.TimeBasedGenerator",
+		"dojo.uuid.NameBasedGenerator",
+		"dojo.uuid.NilGenerator"
+	]
+});
 dojo.provide("dojo.uuid.*");
 

Modified: tags/parley-0.53/root/static/magic/src/validate/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,14 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.require("dojo.validate");
-dojo.kwCompoundRequire({common:["dojo.validate.check", "dojo.validate.datetime", "dojo.validate.de", "dojo.validate.jp", "dojo.validate.us", "dojo.validate.web"]});
+dojo.kwCompoundRequire({
+	common:		["dojo.validate.check", 
+						"dojo.validate.datetime", 
+						"dojo.validate.de", 
+						"dojo.validate.jp", 
+						"dojo.validate.us", 
+						"dojo.validate.web" 
+	],
+});
 dojo.provide("dojo.validate.*");
-

Modified: tags/parley-0.53/root/static/magic/src/validate/check.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/check.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/check.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,227 +8,214 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.validate.check");
 dojo.require("dojo.validate.common");
 dojo.require("dojo.lang.common");
-dojo.validate.check = function (form, profile) {
+
+/**
+  Validates user input of an HTML form based on input profile.
+
+	@param form  The form object to be validated.
+	@param profile  The input profile that specifies how the form fields are to be validated.
+	@return results  An object that contains several methods summarizing the results of the validation.
+*/
+dojo.validate.check = function(form, profile) {
+	// Essentially private properties of results object
 	var missing = [];
 	var invalid = [];
-	var results = {isSuccessful:function () {
-		return (!this.hasInvalid() && !this.hasMissing());
-	}, hasMissing:function () {
-		return (missing.length > 0);
-	}, getMissing:function () {
-		return missing;
-	}, isMissing:function (elemname) {
-		for (var i = 0; i < missing.length; i++) {
-			if (elemname == missing[i]) {
-				return true;
+
+	// results object summarizes the validation
+	var results = {
+		isSuccessful: function() {return ( !this.hasInvalid() && !this.hasMissing() );},
+		hasMissing: function() {return ( missing.length > 0 );},
+		getMissing: function() {return missing;},
+		isMissing: function(elemname) {
+			for (var i = 0; i < missing.length; i++) {
+				if ( elemname == missing[i] ) { return true; }
 			}
-		}
-		return false;
-	}, hasInvalid:function () {
-		return (invalid.length > 0);
-	}, getInvalid:function () {
-		return invalid;
-	}, isInvalid:function (elemname) {
-		for (var i = 0; i < invalid.length; i++) {
-			if (elemname == invalid[i]) {
-				return true;
+			return false;
+		},
+		hasInvalid: function() {return ( invalid.length > 0 );},
+		getInvalid: function() {return invalid;},
+		isInvalid: function(elemname) {
+			for (var i = 0; i < invalid.length; i++) {
+				if ( elemname == invalid[i] ) { return true; }
 			}
+			return false;
 		}
-		return false;
-	}};
-	if (profile.trim instanceof Array) {
+	};
+
+	// Filters are applied before fields are validated.
+	// Trim removes white space at the front and end of the fields.
+	if ( profile.trim instanceof Array ) {
 		for (var i = 0; i < profile.trim.length; i++) {
 			var elem = form[profile.trim[i]];
-			if (dj_undef("type", elem) || elem.type != "text" && elem.type != "textarea" && elem.type != "password") {
-				continue;
-			}
+			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
 			elem.value = elem.value.replace(/(^\s*|\s*$)/g, "");
 		}
 	}
-	if (profile.uppercase instanceof Array) {
+	// Convert to uppercase
+	if ( profile.uppercase instanceof Array ) {
 		for (var i = 0; i < profile.uppercase.length; i++) {
 			var elem = form[profile.uppercase[i]];
-			if (dj_undef("type", elem) || elem.type != "text" && elem.type != "textarea" && elem.type != "password") {
-				continue;
-			}
+			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
 			elem.value = elem.value.toUpperCase();
 		}
 	}
-	if (profile.lowercase instanceof Array) {
+	// Convert to lowercase
+	if ( profile.lowercase instanceof Array ) {
 		for (var i = 0; i < profile.lowercase.length; i++) {
 			var elem = form[profile.lowercase[i]];
-			if (dj_undef("type", elem) || elem.type != "text" && elem.type != "textarea" && elem.type != "password") {
-				continue;
-			}
+			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
 			elem.value = elem.value.toLowerCase();
 		}
 	}
-	if (profile.ucfirst instanceof Array) {
+	// Uppercase first letter
+	if ( profile.ucfirst instanceof Array ) {
 		for (var i = 0; i < profile.ucfirst.length; i++) {
 			var elem = form[profile.ucfirst[i]];
-			if (dj_undef("type", elem) || elem.type != "text" && elem.type != "textarea" && elem.type != "password") {
-				continue;
-			}
-			elem.value = elem.value.replace(/\b\w+\b/g, function (word) {
-				return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();
-			});
+			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
+			elem.value = elem.value.replace(/\b\w+\b/g, function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });
 		}
 	}
-	if (profile.digit instanceof Array) {
+	// Remove non digits characters from the input.
+	if ( profile.digit instanceof Array ) {
 		for (var i = 0; i < profile.digit.length; i++) {
 			var elem = form[profile.digit[i]];
-			if (dj_undef("type", elem) || elem.type != "text" && elem.type != "textarea" && elem.type != "password") {
-				continue;
-			}
+			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; }
 			elem.value = elem.value.replace(/\D/g, "");
 		}
 	}
-	if (profile.required instanceof Array) {
-		for (var i = 0; i < profile.required.length; i++) {
-			if (!dojo.lang.isString(profile.required[i])) {
-				continue;
-			}
+
+	// See if required input fields have values missing.
+	if ( profile.required instanceof Array ) {
+		for (var i = 0; i < profile.required.length; i++) { 
+			if(!dojo.lang.isString(profile.required[i])){ continue; }
 			var elem = form[profile.required[i]];
-			if (!dj_undef("type", elem) && (elem.type == "text" || elem.type == "textarea" || elem.type == "password") && /^\s*$/.test(elem.value)) {
+			// Are textbox, textarea, or password fields blank.
+			if ( (elem.type == "text" || elem.type == "textarea" || elem.type == "password") && /^\s*$/.test(elem.value) ) {	
 				missing[missing.length] = elem.name;
-			} else {
-				if (!dj_undef("type", elem) && (elem.type == "select-one" || elem.type == "select-multiple") && (elem.selectedIndex == -1 || /^\s*$/.test(elem.options[elem.selectedIndex].value))) {
-					missing[missing.length] = elem.name;
-				} else {
-					if (elem instanceof Array) {
-						var checked = false;
-						for (var j = 0; j < elem.length; j++) {
-							if (elem[j].checked) {
-								checked = true;
-							}
-						}
-						if (!checked) {
-							missing[missing.length] = elem[0].name;
-						}
-					}
+			}
+			// Does drop-down box have option selected.
+			else if ( (elem.type == "select-one" || elem.type == "select-multiple") && elem.selectedIndex == -1 ) {
+				missing[missing.length] = elem.name;
+			}
+			// Does radio button group (or check box group) have option checked.
+			else if ( elem instanceof Array )  {
+				var checked = false;
+				for (var j = 0; j < elem.length; j++) {
+					if (elem[j].checked) { checked = true; }
 				}
+				if ( !checked ) {	
+					missing[missing.length] = elem[0].name;
+				}
 			}
 		}
 	}
-	if (profile.required instanceof Array) {
-		for (var i = 0; i < profile.required.length; i++) {
-			if (!dojo.lang.isObject(profile.required[i])) {
-				continue;
-			}
+
+	// See if checkbox groups and select boxes have x number of required values.
+	if ( profile.required instanceof Array ) {
+		for (var i = 0; i < profile.required.length; i++) { 
+			if(!dojo.lang.isObject(profile.required[i])){ continue; }
 			var elem, numRequired;
-			for (var name in profile.required[i]) {
-				elem = form[name];
+			for (var name in profile.required[i]) { 
+				elem = form[name]; 
 				numRequired = profile.required[i][name];
 			}
-			if (elem instanceof Array) {
+			// case 1: elem is a check box group
+			if ( elem instanceof Array )  {
 				var checked = 0;
 				for (var j = 0; j < elem.length; j++) {
-					if (elem[j].checked) {
-						checked++;
-					}
+					if (elem[j].checked) { checked++; }
 				}
-				if (checked < numRequired) {
+				if ( checked < numRequired ) {	
 					missing[missing.length] = elem[0].name;
 				}
-			} else {
-				if (!dj_undef("type", elem) && elem.type == "select-multiple") {
-					var selected = 0;
-					for (var j = 0; j < elem.options.length; j++) {
-						if (elem.options[j].selected && !/^\s*$/.test(elem.options[j].value)) {
-							selected++;
-						}
-					}
-					if (selected < numRequired) {
-						missing[missing.length] = elem.name;
-					}
+			}
+			// case 2: elem is a select box
+			else if ( elem.type == "select-multiple" ) {
+				var selected = 0;
+				for (var j = 0; j < elem.options.length; j++) {
+					if (elem.options[j].selected) { selected++; }
 				}
+				if ( selected < numRequired ) {	
+					missing[missing.length] = elem.name;
+				}
 			}
 		}
 	}
-	if (dojo.lang.isObject(profile.dependencies) || dojo.lang.isObject(profile.dependancies)) {
-		if (profile["dependancies"]) {
-			dojo.deprecated("dojo.validate.check", "profile 'dependancies' is deprecated, please use " + "'dependencies'", "0.5");
-			profile.dependencies = profile.dependancies;
+
+	// Dependant fields are required when the target field is present (not blank).
+	// Todo: Support dependant and target fields that are radio button groups, or select drop-down lists.
+	// Todo: Make the dependancy based on a specific value of the target field.
+	// Todo: allow dependant fields to have several required values, like {checkboxgroup: 3}.
+	if(dojo.lang.isObject(profile.dependancies)){
+		// properties of dependancies object are the names of dependant fields to be checked
+		for (name in profile.dependancies) {
+			var elem = form[name];	// the dependant element
+			if ( elem.type != "text" && elem.type != "textarea" && elem.type != "password" ) { continue; } // limited support
+			if ( /\S+/.test(elem.value) ) { continue; }	// has a value already
+			if ( results.isMissing(elem.name) ) { continue; }	// already listed as missing
+			var target = form[profile.dependancies[name]];
+			if ( target.type != "text" && target.type != "textarea" && target.type != "password" ) { continue; }	// limited support
+			if ( /^\s*$/.test(target.value) ) { continue; }	// skip if blank
+			missing[missing.length] = elem.name;	// ok the dependant field is missing
 		}
-		for (name in profile.dependencies) {
-			var elem = form[name];
-			if (dj_undef("type", elem)) {
-				continue;
-			}
-			if (elem.type != "text" && elem.type != "textarea" && elem.type != "password") {
-				continue;
-			}
-			if (/\S+/.test(elem.value)) {
-				continue;
-			}
-			if (results.isMissing(elem.name)) {
-				continue;
-			}
-			var target = form[profile.dependencies[name]];
-			if (target.type != "text" && target.type != "textarea" && target.type != "password") {
-				continue;
-			}
-			if (/^\s*$/.test(target.value)) {
-				continue;
-			}
-			missing[missing.length] = elem.name;
-		}
 	}
-	if (dojo.lang.isObject(profile.constraints)) {
-		for (name in profile.constraints) {
+
+	// Find invalid input fields.
+	if(dojo.lang.isObject(profile.constraints)){
+		// constraint properties are the names of fields to be validated
+		for(name in profile.constraints){
 			var elem = form[name];
-			if (!elem) {
+			if(	(elem.type != "text")&&
+				(elem.type != "textarea")&&
+				(elem.type != "password")){
 				continue;
 			}
-			if (!dj_undef("tagName", elem) && (elem.tagName.toLowerCase().indexOf("input") >= 0 || elem.tagName.toLowerCase().indexOf("textarea") >= 0) && /^\s*$/.test(elem.value)) {
-				continue;
-			}
+			// skip if blank - its optional unless required, in which case it
+			// is already listed as missing.
+			if( /^\s*$/.test(elem.value)){ continue; }
+
 			var isValid = true;
-			if (dojo.lang.isFunction(profile.constraints[name])) {
+			// case 1: constraint value is validation function
+			if(dojo.lang.isFunction(profile.constraints[name])){
 				isValid = profile.constraints[name](elem.value);
-			} else {
-				if (dojo.lang.isArray(profile.constraints[name])) {
-					if (dojo.lang.isArray(profile.constraints[name][0])) {
-						for (var i = 0; i < profile.constraints[name].length; i++) {
-							isValid = dojo.validate.evaluateConstraint(profile, profile.constraints[name][i], name, elem);
-							if (!isValid) {
-								break;
-							}
-						}
-					} else {
-						isValid = dojo.validate.evaluateConstraint(profile, profile.constraints[name], name, elem);
-					}
+			}else if(dojo.lang.isArray(profile.constraints[name])){
+				// case 2: constraint value is array, first elem is function,
+				// tail is parameters
+				var isValidSomething = profile.constraints[name][0];
+				var params = profile.constraints[name].slice(1);
+				params.unshift(elem.value);
+				if(typeof isValidSomething != "undefined"){
+					isValid = isValidSomething.apply(null, params);
+				}else{
+					isValid = false; 
 				}
 			}
-			if (!isValid) {
+
+			if(!isValid){	
 				invalid[invalid.length] = elem.name;
 			}
 		}
 	}
-	if (dojo.lang.isObject(profile.confirm)) {
-		for (name in profile.confirm) {
-			var elem = form[name];
+
+	// Find unequal confirm fields and report them as Invalid.
+	if(dojo.lang.isObject(profile.confirm)){
+		for(name in profile.confirm){
+			var elem = form[name];	// the confirm element
 			var target = form[profile.confirm[name]];
-			if (dj_undef("type", elem) || dj_undef("type", target) || (elem.type != "text" && elem.type != "textarea" && elem.type != "password") || (target.type != elem.type) || (target.value == elem.value) || (results.isInvalid(elem.name)) || (/^\s*$/.test(target.value))) {
-				continue;
-			}
+			if ( (elem.type != "text" && elem.type != "textarea" && elem.type != "password") 
+				||(target.type != elem.type)
+				||(target.value == elem.value)	// it's valid
+				||(results.isInvalid(elem.name))// already listed as invalid
+				||(/^\s*$/.test(target.value))	)	// skip if blank - only confirm if target has a value
+			{
+				continue; 
+			}	
 			invalid[invalid.length] = elem.name;
 		}
 	}
-	return results;
-};
-dojo.validate.evaluateConstraint = function (profile, constraint, fieldName, elem) {
-	var isValidSomething = constraint[0];
-	var params = constraint.slice(1);
-	params.unshift(elem.value);
-	if (typeof isValidSomething != "undefined") {
-		return isValidSomething.apply(null, params);
-	}
-	return false;
-};
 
+	return results;
+}

Modified: tags/parley-0.53/root/static/magic/src/validate/common.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/common.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/common.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,89 +8,219 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.validate.common");
+dojo.require("dojo.validate");
+dojo.require("dojo.regexp");
 
+// *** Validation Functions ****
 
-dojo.provide("dojo.validate.common");
-dojo.require("dojo.regexp");
-dojo.validate.isText = function (value, flags) {
+/**
+  Checks if a string has non whitespace characters. 
+  Parameters allow you to constrain the length.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.length  If set, checks if there are exactly flags.length number of characters.
+    flags.minlength  If set, checks if there are at least flags.minlength number of characters.
+    flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.
+  @return  true or false.
+*/
+dojo.validate.isText = function(value, flags) {
 	flags = (typeof flags == "object") ? flags : {};
-	if (/^\s*$/.test(value)) {
-		return false;
-	}
-	if (typeof flags.length == "number" && flags.length != value.length) {
-		return false;
-	}
-	if (typeof flags.minlength == "number" && flags.minlength > value.length) {
-		return false;
-	}
-	if (typeof flags.maxlength == "number" && flags.maxlength < value.length) {
-		return false;
-	}
+
+	// test for text
+	if ( /^\s*$/.test(value) ) { return false; }
+
+	// length tests
+	if ( typeof flags.length == "number" && flags.length != value.length ) { return false; }
+	if ( typeof flags.minlength == "number" && flags.minlength > value.length ) { return false; }
+	if ( typeof flags.maxlength == "number" && flags.maxlength < value.length ) { return false; }
+
 	return true;
-};
-dojo.validate.isInteger = function (value, flags) {
+}
+
+/**
+  Validates whether a string is in an integer format. 
+
+  @param value  A string.
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. sign is optional).
+    flags.separator  The character used as the thousands separator.  Default is no separator.
+      For more than one symbol use an array, e.g. [",", ""], makes ',' optional.
+  @return  true or false.
+*/
+dojo.validate.isInteger = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.integer(flags) + "$");
 	return re.test(value);
-};
-dojo.validate.isRealNumber = function (value, flags) {
+}
+
+/**
+  Validates whether a string is a real valued number. 
+  Format is the usual exponential notation.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.places  The integer number of decimal places.
+      If not given, the decimal part is optional and the number of places is unlimited.
+    flags.decimal  The character used for the decimal point.  Default is ".".
+    flags.exponent  Express in exponential notation.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. the exponential part is optional).
+    flags.eSigned  The leading plus-or-minus sign on the exponent.  Can be true, false, 
+      or [true, false].  Default is [true, false], (i.e. sign is optional).
+    flags in regexp.integer can be applied.
+  @return  true or false.
+*/
+dojo.validate.isRealNumber = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.realNumber(flags) + "$");
 	return re.test(value);
-};
-dojo.validate.isCurrency = function (value, flags) {
+}
+
+/**
+  Validates whether a string denotes a monetary value. 
+
+  @param value  A string.
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. sign is optional).
+    flags.symbol  A currency symbol such as Yen "?", Pound "?", or the Euro sign "?".  
+      Default is "$".  For more than one symbol use an array, e.g. ["$", ""], makes $ optional.
+    flags.placement  The symbol can come "before" the number or "after".  Default is "before".
+    flags.separator  The character used as the thousands separator. The default is ",".
+    flags.cents  The two decimal places for cents.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. cents are optional).
+    flags.decimal  The character used for the decimal point.  Default is ".".
+  @return  true or false.
+*/
+dojo.validate.isCurrency = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.currency(flags) + "$");
 	return re.test(value);
-};
-dojo.validate._isInRangeCache = {};
-dojo.validate.isInRange = function (value, flags) {
-	value = value.replace(dojo.lang.has(flags, "separator") ? flags.separator : ",", "", "g").replace(dojo.lang.has(flags, "symbol") ? flags.symbol : "$", "");
-	if (isNaN(value)) {
-		return false;
-	}
+}
+
+/**
+  Validates whether a string denoting an integer, 
+  real number, or monetary value is between a max and min. 
+
+  @param value  A string.
+  @param flags  An object.
+    flags.max  A number, which the value must be less than or equal to for the validation to be true.
+    flags.min  A number, which the value must be greater than or equal to for the validation to be true.
+    flags.decimal  The character used for the decimal point.  Default is ".".
+  @return  true or false.
+*/
+dojo.validate.isInRange = function(value, flags) {
+	// assign default values to missing paramters
 	flags = (typeof flags == "object") ? flags : {};
 	var max = (typeof flags.max == "number") ? flags.max : Infinity;
 	var min = (typeof flags.min == "number") ? flags.min : -Infinity;
 	var dec = (typeof flags.decimal == "string") ? flags.decimal : ".";
-	var cache = dojo.validate._isInRangeCache;
-	var cacheIdx = value + "max" + max + "min" + min + "dec" + dec;
-	if (typeof cache[cacheIdx] != "undefined") {
-		return cache[cacheIdx];
-	}
+	
+	// splice out anything not part of a number
 	var pattern = "[^" + dec + "\\deE+-]";
 	value = value.replace(RegExp(pattern, "g"), "");
+
+	// trim ends of things like e, E, or the decimal character
 	value = value.replace(/^([+-]?)(\D*)/, "$1");
 	value = value.replace(/(\D*)$/, "");
+
+	// replace decimal with ".". The minus sign '-' could be the decimal!
 	pattern = "(\\d)[" + dec + "](\\d)";
 	value = value.replace(RegExp(pattern, "g"), "$1.$2");
+
 	value = Number(value);
-	if (value < min || value > max) {
-		cache[cacheIdx] = false;
-		return false;
-	}
-	cache[cacheIdx] = true;
+	if ( value < min || value > max ) { return false; }
+
 	return true;
-};
-dojo.validate.isNumberFormat = function (value, flags) {
+}
+
+
+/**
+  Validates any sort of number based format.
+  Use it for phone numbers, social security numbers, zip-codes, etc.
+  The value can be validated against one format or one of multiple formats.
+
+  Format
+    #        Stands for a digit, 0-9.
+    ?        Stands for an optional digit, 0-9 or nothing.
+    All other characters must appear literally in the expression.
+
+  Example   
+    "(###) ###-####"       ->   (510) 542-9742
+    "(###) ###-#### x#???" ->   (510) 542-9742 x153
+    "###-##-####"          ->   506-82-1089       i.e. social security number
+    "#####-####"           ->   98225-1649        i.e. zip code
+
+  @param value  A string.
+  @param flags  An object.
+    flags.format  A string or an Array of strings for multiple formats.
+  @return  true or false
+*/
+dojo.validate.isNumberFormat = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.numberFormat(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.isValidLuhn = function (value) {
-	var sum, parity, curDigit;
-	if (typeof value != "string") {
-		value = String(value);
-	}
-	value = value.replace(/[- ]/g, "");
-	parity = value.length % 2;
-	sum = 0;
-	for (var i = 0; i < value.length; i++) {
-		curDigit = parseInt(value.charAt(i));
-		if (i % 2 == parity) {
-			curDigit *= 2;
-		}
-		if (curDigit > 9) {
-			curDigit -= 9;
-		}
-		sum += curDigit;
-	}
-	return !(sum % 10);
-};
+}
 
+/**
+	Procedural API Description
+
+		The main aim is to make input validation expressible in a simple format.
+		You define profiles which declare the required and optional fields and any constraints they might have.
+		The results are provided as an object that makes it easy to handle missing and invalid input.
+
+	Usage
+
+		var results = dojo.validate.check(form, profile);
+
+	Profile Object
+
+		var profile = {
+			// filters change the field value and are applied before validation.
+			trim: ["tx1", "tx2"],
+			uppercase: ["tx9"],
+			lowercase: ["tx5", "tx6", "tx7"],
+			ucfirst: ["tx10"],
+			digit: ["tx11"],
+
+			// required input fields that are blank will be reported missing.
+			// required radio button groups and drop-down lists with no selection will be reported missing.
+			// checkbox groups and selectboxes can be required to have more than one value selected.
+			// List required fields by name and use this notation to require more than one value: {checkboxgroup: 2}, {selectboxname: 3}.
+			required: ["tx7", "tx8", "pw1", "ta1", "rb1", "rb2", "cb3", "s1", {"doubledip":2}, {"tripledip":3}],
+
+			// dependant/conditional fields are required if the target field is present and not blank.
+			// At present only textbox, password, and textarea fields are supported.
+			dependancies:	{
+				cc_exp: "cc_no",	
+				cc_type: "cc_no",	
+			},
+
+			// Fields can be validated using any boolean valued function.  
+			// Use arrays to specify parameters in addition to the field value.
+			constraints: {
+				field_name1: myValidationFunction,
+				field_name2: dojo.validate.isInteger,
+				field_name3: [myValidationFunction, additional parameters],
+				field_name4: [dojo.validate.isValidDate, "YYYY.MM.DD"],
+				field_name5: [dojo.validate.isEmailAddress, false, true],
+			},
+
+			// Confirm is a sort of conditional validation.
+			// It associates each field in its property list with another field whose value should be equal.
+			// If the values are not equal, the field in the property list is reported as Invalid. Unless the target field is blank.
+			confirm: {
+				email_confirm: "email",	
+				pw2: "pw1",	
+			}
+		};
+
+	Results Object
+
+		isSuccessful(): Returns true if there were no invalid or missing fields, else it returns false.
+		hasMissing():  Returns true if the results contain any missing fields.
+		getMissing():  Returns a list of required fields that have values missing.
+		isMissing(field):  Returns true if the field is required and the value is missing.
+		hasInvalid():  Returns true if the results contain fields with invalid data.
+		getInvalid():  Returns a list of fields that have invalid values.
+		isInvalid(field):  Returns true if the field has an invalid value.
+
+*/

Deleted: tags/parley-0.53/root/static/magic/src/validate/creditCard.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/creditCard.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/creditCard.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,64 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.validate.creditCard");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.validate.common");
-dojo.validate.isValidCreditCard = function (value, ccType) {
-	if (value && ccType && ((ccType.toLowerCase() == "er" || dojo.validate.isValidLuhn(value)) && (dojo.validate.isValidCreditCardNumber(value, ccType.toLowerCase())))) {
-		return true;
-	}
-	return false;
-};
-dojo.validate.isValidCreditCardNumber = function (value, ccType) {
-	if (typeof value != "string") {
-		value = String(value);
-	}
-	value = value.replace(/[- ]/g, "");
-	var results = [];
-	var cardinfo = {"mc":"5[1-5][0-9]{14}", "ec":"5[1-5][0-9]{14}", "vi":"4([0-9]{12}|[0-9]{15})", "ax":"3[47][0-9]{13}", "dc":"3(0[0-5][0-9]{11}|[68][0-9]{12})", "bl":"3(0[0-5][0-9]{11}|[68][0-9]{12})", "di":"6011[0-9]{12}", "jcb":"(3[0-9]{15}|(2131|1800)[0-9]{11})", "er":"2(014|149)[0-9]{11}"};
-	if (ccType && dojo.lang.has(cardinfo, ccType.toLowerCase())) {
-		return Boolean(value.match(cardinfo[ccType.toLowerCase()]));
-	} else {
-		for (var p in cardinfo) {
-			if (value.match("^" + cardinfo[p] + "$") != null) {
-				results.push(p);
-			}
-		}
-		return (results.length) ? results.join("|") : false;
-	}
-};
-dojo.validate.isValidCvv = function (value, ccType) {
-	if (typeof value != "string") {
-		value = String(value);
-	}
-	var format;
-	switch (ccType.toLowerCase()) {
-	  case "mc":
-	  case "ec":
-	  case "vi":
-	  case "di":
-		format = "###";
-		break;
-	  case "ax":
-		format = "####";
-		break;
-	  default:
-		return false;
-	}
-	var flags = {format:format};
-	if ((value.length == format.length) && (dojo.validate.isNumberFormat(value, flags))) {
-		return true;
-	}
-	return false;
-};
-

Modified: tags/parley-0.53/root/static/magic/src/validate/datetime.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/datetime.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/datetime.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,85 +8,161 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.validate.datetime");
+dojo.require("dojo.validate.common");
 
+/**
+  Validates a time value in any International format.
+  The value can be validated against one format or one of multiple formats.
 
-dojo.provide("dojo.validate.datetime");
-dojo.require("dojo.validate.common");
-dojo.validate.isValidTime = function (value, flags) {
-	dojo.deprecated("dojo.validate.datetime", "use dojo.date.parse instead", "0.5");
+  Format
+  h        12 hour, no zero padding.
+  hh       12 hour, has leading zero.
+  H        24 hour, no zero padding.
+  HH       24 hour, has leading zero.
+  m        minutes, no zero padding.
+  mm       minutes, has leading zero.
+  s        seconds, no zero padding.
+  ss       seconds, has leading zero.
+  All other characters must appear literally in the expression.
+
+  Example
+    "h:m:s t"  ->   2:5:33 PM
+    "HH:mm:ss" ->  14:05:33
+
+  @param value  A string.
+  @param flags  An object.
+    flags.format  A string or an array of strings.  Default is "h:mm:ss t".
+    flags.amSymbol  The symbol used for AM.  Default is "AM".
+    flags.pmSymbol  The symbol used for PM.  Default is "PM".
+  @return  true or false
+*/
+dojo.validate.isValidTime = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.time(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.is12HourTime = function (value) {
-	dojo.deprecated("dojo.validate.datetime", "use dojo.date.parse instead", "0.5");
-	return dojo.validate.isValidTime(value, {format:["h:mm:ss t", "h:mm t"]});
-};
-dojo.validate.is24HourTime = function (value) {
-	dojo.deprecated("dojo.validate.datetime", "use dojo.date.parse instead", "0.5");
-	return dojo.validate.isValidTime(value, {format:["HH:mm:ss", "HH:mm"]});
-};
-dojo.validate.isValidDate = function (dateValue, format) {
-	dojo.deprecated("dojo.validate.datetime", "use dojo.date.parse instead", "0.5");
-	if (typeof format == "object" && typeof format.format == "string") {
-		format = format.format;
-	}
-	if (typeof format != "string") {
-		format = "MM/DD/YYYY";
-	}
+}
+
+/**
+  Validates 12-hour time format.
+  Zero-padding is not allowed for hours, required for minutes and seconds.
+  Seconds are optional.
+
+  @param value  A string.
+  @return  true or false
+*/
+dojo.validate.is12HourTime = function(value) {
+	return dojo.validate.isValidTime(value, {format: ["h:mm:ss t", "h:mm t"]});
+}
+
+/**
+  Validates 24-hour military time format.
+  Zero-padding is required for hours, minutes, and seconds.
+  Seconds are optional.
+
+  @param value  A string.
+  @return  true or false
+*/
+dojo.validate.is24HourTime = function(value) {
+	return dojo.validate.isValidTime(value, {format: ["HH:mm:ss", "HH:mm"]} );
+}
+
+/**
+  Returns true if the date conforms to the format given and is a valid date. Otherwise returns false.
+
+  @param dateValue  A string for the date.
+  @param format  A string, default is  "MM/DD/YYYY".
+  @return  true or false
+
+  Accepts any type of format, including ISO8601.
+  All characters in the format string are treated literally except the following tokens:
+
+  YYYY - matches a 4 digit year
+  M - matches a non zero-padded month
+  MM - matches a zero-padded month
+  D -  matches a non zero-padded date
+  DD -  matches a zero-padded date
+  DDD -  matches an ordinal date, 001-365, and 366 on leapyear
+  ww - matches week of year, 01-53
+  d - matches day of week, 1-7
+
+  Examples: These are all today's date.
+
+  Date          Format
+  2005-W42-3    YYYY-Www-d
+  2005-292      YYYY-DDD
+  20051019      YYYYMMDD
+  10/19/2005    M/D/YYYY
+  19.10.2005    D.M.YYYY
+*/
+dojo.validate.isValidDate = function(dateValue, format) {
+	// Default is the American format
+	if (typeof format == "object" && typeof format.format == "string"){ format = format.format; }
+	if (typeof format != "string") { format = "MM/DD/YYYY"; }
+
+	// Create a literal regular expression based on format
 	var reLiteral = format.replace(/([$^.*+?=!:|\/\\\(\)\[\]\{\}])/g, "\\$1");
-	reLiteral = reLiteral.replace("YYYY", "([0-9]{4})");
-	reLiteral = reLiteral.replace("MM", "(0[1-9]|10|11|12)");
-	reLiteral = reLiteral.replace("M", "([1-9]|10|11|12)");
-	reLiteral = reLiteral.replace("DDD", "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])");
-	reLiteral = reLiteral.replace("DD", "(0[1-9]|[12][0-9]|30|31)");
-	reLiteral = reLiteral.replace("D", "([1-9]|[12][0-9]|30|31)");
-	reLiteral = reLiteral.replace("ww", "(0[1-9]|[1-4][0-9]|5[0-3])");
-	reLiteral = reLiteral.replace("d", "([1-7])");
+
+	// Convert all the tokens to RE elements
+	reLiteral = reLiteral.replace( "YYYY", "([0-9]{4})" );
+	reLiteral = reLiteral.replace( "MM", "(0[1-9]|10|11|12)" );
+	reLiteral = reLiteral.replace( "M", "([1-9]|10|11|12)" );
+	reLiteral = reLiteral.replace( "DDD", "(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])" );
+	reLiteral = reLiteral.replace( "DD", "(0[1-9]|[12][0-9]|30|31)" );
+	reLiteral = reLiteral.replace( "D", "([1-9]|[12][0-9]|30|31)" );
+	reLiteral = reLiteral.replace( "ww", "(0[1-9]|[1-4][0-9]|5[0-3])" );
+	reLiteral = reLiteral.replace( "d", "([1-7])" );
+
+	// Anchor pattern to begining and end of string
 	reLiteral = "^" + reLiteral + "$";
+
+	// Dynamic RE that parses the original format given
 	var re = new RegExp(reLiteral);
-	if (!re.test(dateValue)) {
-		return false;
-	}
+	
+	// Test if date is in a valid format
+	if (!re.test(dateValue))  return false;
+
+	// Parse date to get elements and check if date is valid
+	// Assume valid values for date elements not given.
 	var year = 0, month = 1, date = 1, dayofyear = 1, week = 1, day = 1;
-	var tokens = format.match(/(YYYY|MM|M|DDD|DD|D|ww|d)/g);
+
+	// Capture tokens
+	var tokens = format.match( /(YYYY|MM|M|DDD|DD|D|ww|d)/g );
+
+	// Capture date values
 	var values = re.exec(dateValue);
+
+	// Match up tokens with date values
 	for (var i = 0; i < tokens.length; i++) {
 		switch (tokens[i]) {
-		  case "YYYY":
-			year = Number(values[i + 1]);
-			break;
-		  case "M":
-		  case "MM":
-			month = Number(values[i + 1]);
-			break;
-		  case "D":
-		  case "DD":
-			date = Number(values[i + 1]);
-			break;
-		  case "DDD":
-			dayofyear = Number(values[i + 1]);
-			break;
-		  case "ww":
-			week = Number(values[i + 1]);
-			break;
-		  case "d":
-			day = Number(values[i + 1]);
-			break;
+		case "YYYY":
+			year = Number(values[i+1]); break;
+		case "M":
+		case "MM":
+			month = Number(values[i+1]); break;
+		case "D":
+		case "DD":
+			date = Number(values[i+1]); break;
+		case "DDD":
+			dayofyear = Number(values[i+1]); break;
+		case "ww":
+			week = Number(values[i+1]); break;
+		case "d":
+			day = Number(values[i+1]); break;
 		}
 	}
+
+	// Leap years are divisible by 4, but not by 100, unless by 400
 	var leapyear = (year % 4 == 0 && (year % 100 != 0 || year % 400 == 0));
-	if (date == 31 && (month == 4 || month == 6 || month == 9 || month == 11)) {
-		return false;
-	}
-	if (date >= 30 && month == 2) {
-		return false;
-	}
-	if (date == 29 && month == 2 && !leapyear) {
-		return false;
-	}
-	if (dayofyear == 366 && !leapyear) {
-		return false;
-	}
+
+	// 31st of a month with 30 days
+	if (date == 31 && (month == 4 || month == 6 || month == 9 || month == 11)) return false; 
+
+	// February 30th or 31st
+	if (date >= 30 && month == 2) return false; 
+
+	// February 29th outside a leap year
+	if (date == 29 && month == 2 && !leapyear) return false; 
+	if (dayofyear == 366 && !leapyear)  return false;
+
 	return true;
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/validate/de.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/de.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/de.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,12 +8,23 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.validate.de");
+dojo.require("dojo.validate.common");
 
+/**
+  Validates German currency.
 
-dojo.provide("dojo.validate.de");
-dojo.require("dojo.validate.common");
-dojo.validate.isGermanCurrency = function (value) {
-	var flags = {symbol:"\u20ac", placement:"after", signPlacement:"begin", decimal:",", separator:"."};
+  @param value  A string.
+  @return  true or false.
+*/
+dojo.validate.isGermanCurrency = function(value) {
+	var flags = {
+		symbol: "?",
+		placement: "after",
+		decimal: ",",
+		separator: "."
+	};
 	return dojo.validate.isCurrency(value, flags);
-};
+}
 
+

Modified: tags/parley-0.53/root/static/magic/src/validate/jp.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/jp.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/jp.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,12 +8,21 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.validate.jp");
+dojo.require("dojo.validate.common");
 
+/**
+  Validates Japanese currency.
 
-dojo.provide("dojo.validate.jp");
-dojo.require("dojo.validate.common");
-dojo.validate.isJapaneseCurrency = function (value) {
-	var flags = {symbol:"\xa5", fractional:false};
+  @param value  A string.
+  @return  true or false.
+*/
+dojo.validate.isJapaneseCurrency = function(value) {
+	var flags = {
+		symbol: "?",
+		cents: false
+	};
 	return dojo.validate.isCurrency(value, flags);
-};
+}
 
+

Modified: tags/parley-0.53/root/static/magic/src/validate/us.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/us.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/us.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,27 +8,87 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.validate.us");
+dojo.require("dojo.validate.common");
 
+/**
+  Validates U.S. currency.
 
-dojo.provide("dojo.validate.us");
-dojo.require("dojo.validate.common");
-dojo.validate.us.isCurrency = function (value, flags) {
+  @param value  A string.
+  @param flags  An object.
+    flags in validate.isCurrency can be applied.
+  @return  true or false.
+*/
+dojo.validate.us.isCurrency = function(value, flags) {
 	return dojo.validate.isCurrency(value, flags);
-};
-dojo.validate.us.isState = function (value, flags) {
+}
+
+
+/**
+  Validates US state and territory abbreviations.
+
+	@param value  A two character string.
+  @param flags  An object.
+    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
+    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.
+  @return  true or false
+*/
+dojo.validate.us.isState = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.us.state(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.us.isPhoneNumber = function (value) {
-	var flags = {format:["###-###-####", "(###) ###-####", "(###) ### ####", "###.###.####", "###/###-####", "### ### ####", "###-###-#### x#???", "(###) ###-#### x#???", "(###) ### #### x#???", "###.###.#### x#???", "###/###-#### x#???", "### ### #### x#???", "##########"]};
+}
+
+/**
+  Validates 10 US digit phone number for several common formats:
+
+  @param value The telephone number string
+  @return true or false
+*/
+dojo.validate.us.isPhoneNumber = function(value) {
+	var flags = {
+		format: [
+			"###-###-####",
+			"(###) ###-####",
+			"(###) ### ####",
+			"###.###.####",
+			"###/###-####",
+			"### ### ####",
+			"###-###-#### x#???",
+			"(###) ###-#### x#???",
+			"(###) ### #### x#???",
+			"###.###.#### x#???",
+			"###/###-#### x#???",
+			"### ### #### x#???",
+			"##########"
+		]
+	};
+
 	return dojo.validate.isNumberFormat(value, flags);
-};
-dojo.validate.us.isSocialSecurityNumber = function (value) {
-	var flags = {format:["###-##-####", "### ## ####", "#########"]};
+}
+
+// Validates social security number
+dojo.validate.us.isSocialSecurityNumber = function(value) {
+	var flags = {
+		format: [
+			"###-##-####",
+			"### ## ####",
+			"#########"
+		]
+	};
+
 	return dojo.validate.isNumberFormat(value, flags);
-};
-dojo.validate.us.isZipCode = function (value) {
-	var flags = {format:["#####-####", "##### ####", "#########", "#####"]};
+}
+
+// Validates U.S. zip-code
+dojo.validate.us.isZipCode = function(value) {
+	var flags = {
+		format: [
+			"#####-####",
+			"##### ####",
+			"#########",
+			"#####"
+		]
+	};
+
 	return dojo.validate.isNumberFormat(value, flags);
-};
-
+}

Modified: tags/parley-0.53/root/static/magic/src/validate/web.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate/web.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate/web.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,36 +8,98 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.validate.web");
+dojo.require("dojo.validate.common");
 
+/**
+  Validates an IP address.
+  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
+  Supports 2 formats for Ipv6.
 
-dojo.provide("dojo.validate.web");
-dojo.require("dojo.validate.common");
-dojo.validate.isIpAddress = function (value, flags) {
+  @param value  A string.
+  @param flags  An object.  All flags are boolean with default = true.
+    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
+    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
+    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
+    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
+    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
+      Case insensitive.  Zero padding allowed.
+    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
+    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
+      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d
+  @return  true or false
+*/
+dojo.validate.isIpAddress = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.ipAddress(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.isUrl = function (value, flags) {
+}
+
+/**
+  Checks if a string could be a valid URL.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.scheme  Can be true, false, or [true, false]. 
+      This means: required, not allowed, or either.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+  @return  true or false
+*/
+dojo.validate.isUrl = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.url(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.isEmailAddress = function (value, flags) {
+}
+
+/**
+  Checks if a string could be a valid email address.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.allowCruft  Allow address like <mailto:foo at yahoo.com>.  Default is false.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+  @return  true or false.
+*/
+dojo.validate.isEmailAddress = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.emailAddress(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.isEmailAddressList = function (value, flags) {
+}
+
+/**
+  Checks if a string could be a valid email address list.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.listSeparator  The character used to separate email addresses.  Default is ";", ",", "\n" or " ".
+    flags in regexp.emailAddress can be applied.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+  @return  true or false.
+*/
+dojo.validate.isEmailAddressList = function(value, flags) {
 	var re = new RegExp("^" + dojo.regexp.emailAddressList(flags) + "$", "i");
 	return re.test(value);
-};
-dojo.validate.getEmailAddressList = function (value, flags) {
-	if (!flags) {
-		flags = {};
-	}
-	if (!flags.listSeparator) {
-		flags.listSeparator = "\\s;,";
-	}
-	if (dojo.validate.isEmailAddressList(value, flags)) {
+}
+
+/**
+  Check if value is an email address list. If an empty list
+  is returned, the value didn't pass the test or it was empty.
+
+  @param value	A string
+  @param flags	An object (same as isEmailAddressList)
+  @return array of emails
+*/
+dojo.validate.getEmailAddressList = function(value, flags) {
+	if(!flags) { flags = {}; }
+	if(!flags.listSeparator) { flags.listSeparator = "\\s;,"; }
+
+	if ( dojo.validate.isEmailAddressList(value, flags) ) {
 		return value.split(new RegExp("\\s*[" + flags.listSeparator + "]\\s*"));
 	}
 	return [];
-};
+}
 
+

Modified: tags/parley-0.53/root/static/magic/src/validate.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/validate.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/validate.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,5 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.validate");
 dojo.require("dojo.validate.common");
-

Modified: tags/parley-0.53/root/static/magic/src/widget/AccordionContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/AccordionContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/AccordionContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,121 +8,64 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.AccordionContainer");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.lfx.html");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.widget.html.layout");
-dojo.require("dojo.widget.PageContainer");
-dojo.widget.defineWidget("dojo.widget.AccordionContainer", dojo.widget.HtmlWidget, {isContainer:true, labelNodeClass:"label", containerNodeClass:"accBody", duration:250, fillInTemplate:function () {
-	with (this.domNode.style) {
-		if (position != "absolute") {
-			position = "relative";
-		}
-		overflow = "hidden";
-	}
-}, addChild:function (widget) {
-	var child = this._addChild(widget);
-	this._setSizes();
-	return child;
-}, _addChild:function (widget) {
-	if (widget.open) {
-		dojo.deprecated("open parameter deprecated, use 'selected=true' instead will be removed in ", "0.5");
-		dojo.debug(widget.widgetId + ": open == " + widget.open);
-		widget.selected = true;
-	}
-	if (widget.widgetType != "AccordionPane") {
-		var wrapper = dojo.widget.createWidget("AccordionPane", {label:widget.label, selected:widget.selected, labelNodeClass:this.labelNodeClass, containerNodeClass:this.containerNodeClass, allowCollapse:this.allowCollapse});
-		wrapper.addChild(widget);
-		this.addWidgetAsDirectChild(wrapper);
-		this.registerChild(wrapper, this.children.length);
-		return wrapper;
-	} else {
-		dojo.html.addClass(widget.containerNode, this.containerNodeClass);
-		dojo.html.addClass(widget.labelNode, this.labelNodeClass);
-		this.addWidgetAsDirectChild(widget);
-		this.registerChild(widget, this.children.length);
-		return widget;
-	}
-}, postCreate:function () {
-	var tmpChildren = this.children;
-	this.children = [];
-	dojo.html.removeChildren(this.domNode);
-	dojo.lang.forEach(tmpChildren, dojo.lang.hitch(this, "_addChild"));
-	this._setSizes();
-}, removeChild:function (widget) {
-	dojo.widget.AccordionContainer.superclass.removeChild.call(this, widget);
-	this._setSizes();
-}, onResized:function () {
-	this._setSizes();
-}, _setSizes:function () {
-	var totalCollapsedHeight = 0;
-	var openIdx = 0;
-	dojo.lang.forEach(this.children, function (child, idx) {
-		totalCollapsedHeight += child.getLabelHeight();
-		if (child.selected) {
-			openIdx = idx;
-		}
-	});
-	var mySize = dojo.html.getContentBox(this.domNode);
-	var y = 0;
-	dojo.lang.forEach(this.children, function (child, idx) {
-		var childCollapsedHeight = child.getLabelHeight();
-		child.resizeTo(mySize.width, mySize.height - totalCollapsedHeight + childCollapsedHeight);
-		child.domNode.style.zIndex = idx + 1;
-		child.domNode.style.position = "absolute";
-		child.domNode.style.top = y + "px";
-		y += (idx == openIdx) ? dojo.html.getBorderBox(child.domNode).height : childCollapsedHeight;
-	});
-}, selectChild:function (page) {
-	dojo.lang.forEach(this.children, function (child) {
-		child.setSelected(child == page);
-	});
-	var y = 0;
-	var anims = [];
-	dojo.lang.forEach(this.children, function (child, idx) {
-		if (child.domNode.style.top != (y + "px")) {
-			anims.push(dojo.lfx.html.slideTo(child.domNode, {top:y, left:0}, this.duration));
-		}
-		y += child.selected ? dojo.html.getBorderBox(child.domNode).height : child.getLabelHeight();
-	}, this);
-	dojo.lfx.combine(anims).play();
-}});
-dojo.widget.defineWidget("dojo.widget.AccordionPane", dojo.widget.HtmlWidget, {label:"", "class":"dojoAccordionPane", labelNodeClass:"label", containerNodeClass:"accBody", selected:false, templateString:"<div dojoAttachPoint=\"domNode\">\n<div dojoAttachPoint=\"labelNode\" dojoAttachEvent=\"onclick: onLabelClick\" class=\"${this.labelNodeClass}\">${this.label}</div>\n<div dojoAttachPoint=\"containerNode\" style=\"overflow: hidden;\" class=\"${this.containerNodeClass}\"></div>\n</div>\n", templateCssString:".dojoAccordionPane .label {\n\tcolor: #000;\n\tfont-weight: bold;\n\tbackground: url(\"images/soriaAccordionOff.gif\") repeat-x top left #85aeec;\n\tborder:1px solid #d9d9d9;\n\tfont-size:0.9em;\n}\n\n.dojoAccordionPane-selected .label {\n\tbackground: url(\"images/soriaAccordionSelected.gif\") repeat-x top left #85aeec;\n\tborder:1px solid #84a3d1;\n}\n\n.dojoAccordionPane .label:hover {\n\tcursor: pointer;\n}\n\n.dojoAccordionPane .accBody {\n\tbackground: #fff;\n\tover!
 flow: auto;\n\tborder:1px solid #84a3d1;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/AccordionPane.css"), isContainer:true, fillInTemplate:function () {
-	dojo.html.addClass(this.domNode, this["class"]);
-	dojo.widget.AccordionPane.superclass.fillInTemplate.call(this);
-	dojo.html.disableSelection(this.labelNode);
-	this.setSelected(this.selected);
-}, setLabel:function (label) {
-	this.labelNode.innerHTML = label;
-}, resizeTo:function (width, height) {
-	dojo.html.setMarginBox(this.domNode, {width:width, height:height});
-	var children = [{domNode:this.labelNode, layoutAlign:"top"}, {domNode:this.containerNode, layoutAlign:"client"}];
-	dojo.widget.html.layout(this.domNode, children);
-	var childSize = dojo.html.getContentBox(this.containerNode);
-	this.children[0].resizeTo(childSize.width, childSize.height);
-}, getLabelHeight:function () {
-	return dojo.html.getMarginBox(this.labelNode).height;
-}, onLabelClick:function () {
-	this.parent.selectChild(this);
-}, setSelected:function (isSelected) {
-	this.selected = isSelected;
-	(isSelected ? dojo.html.addClass : dojo.html.removeClass)(this.domNode, this["class"] + "-selected");
-	var child = this.children[0];
-	if (child) {
-		if (isSelected) {
-			if (!child.isShowing()) {
-				child.show();
-			} else {
-				child.onShow();
-			}
-		} else {
-			child.onHide();
-		}
-	}
-}});
-dojo.lang.extend(dojo.widget.Widget, {open:false});
-
+dojo.provide("dojo.widget.AccordionContainer");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.AccordionPane");
+
+dojo.widget.defineWidget(
+	"dojo.widget.AccordionContainer",
+	dojo.widget.HtmlWidget,
+	{
+		widgetType: "AccordionContainer",
+		isContainer: true,
+		labelNodeClass: "",
+		containerNodeClass: "",
+		allowCollapse: false,
+
+		addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+			if (widget.widgetType != "AccordionPane") {
+				var wrapper=dojo.widget.createWidget("AccordionPane",{label: widget.label, open: widget.open, labelNodeClass: this.labelNodeClass, containerNodeClass: this.containerNodeClass, allowCollapse: this.allowCollapse });
+				wrapper.addChild(widget);
+				this.addWidgetAsDirectChild(wrapper);
+				this.registerChild(wrapper);
+				wrapper.setSizes();
+				return wrapper;
+			} else {
+				dojo.html.addClass(widget.containerNode, this.containerNodeClass);
+				dojo.html.addClass(widget.labelNode, this.labelNodeClass);
+				this.addWidgetAsDirectChild(widget);
+				this.registerChild(widget);	
+				widget.setSizes();
+				return widget;
+			}
+	        },
+	
+		postCreate: function() {
+			var tmpChildren = this.children;
+			this.children=[];
+			dojo.html.removeChildren(this.domNode);
+			dojo.lang.forEach(tmpChildren, dojo.lang.hitch(this,"addChild"));
+		},
+	
+		removeChild: function(widget) {
+			dojo.widget.AccordionContainer.superclass.removeChild.call(this, widget);
+			if(this.children[0]){
+				this.children[0].setSizes();
+			}
+		},
+		
+		onResized: function(){
+			this.children[0].setSizes();
+		}
+	}
+);
+
+// These arguments can be specified for the children of a Accordion
+// Since any widget can be specified as a child, mix them
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	label: "",
+	open: false
+});
+

Added: tags/parley-0.53/root/static/magic/src/widget/AccordionPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/AccordionPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/AccordionPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.AccordionPane");
+dojo.requireAfterIf("html", "dojo.widget.html.AccordionPane");

Modified: tags/parley-0.53/root/static/magic/src/widget/AnimatedPng.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/AnimatedPng.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/AnimatedPng.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,40 +8,76 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.AnimatedPng");
+dojo.provide("dojo.widget.html.AnimatedPng");
 
-
-dojo.provide("dojo.widget.AnimatedPng");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.AnimatedPng", dojo.widget.HtmlWidget, {isContainer:false, width:0, height:0, aniSrc:"", interval:100, _blankSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/blank.gif"), templateString:"<img class=\"dojoAnimatedPng\" />", postCreate:function () {
-	this.cellWidth = this.width;
-	this.cellHeight = this.height;
-	var img = new Image();
-	var self = this;
-	img.onload = function () {
-		self._initAni(img.width, img.height);
-	};
-	img.src = this.aniSrc;
-}, _initAni:function (w, h) {
-	this.domNode.src = this._blankSrc;
-	this.domNode.width = this.cellWidth;
-	this.domNode.height = this.cellHeight;
-	this.domNode.style.backgroundImage = "url(" + this.aniSrc + ")";
-	this.domNode.style.backgroundRepeat = "no-repeat";
-	this.aniCols = Math.floor(w / this.cellWidth);
-	this.aniRows = Math.floor(h / this.cellHeight);
-	this.aniCells = this.aniCols * this.aniRows;
-	this.aniFrame = 0;
-	window.setInterval(dojo.lang.hitch(this, "_tick"), this.interval);
-}, _tick:function () {
-	this.aniFrame++;
-	if (this.aniFrame == this.aniCells) {
-		this.aniFrame = 0;
+
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.AnimatedPng",
+	dojo.widget.HtmlWidget,
+	{
+
+		widgetType: "AnimatedPng",
+		isContainer: false,
+
+		domNode: null,
+		width: 0,
+		height: 0,
+		aniSrc: '',
+		interval: 100,
+
+		cellWidth: 0,
+		cellHeight: 0,
+		aniCols: 1,
+		aniRows: 1,
+		aniCells: 1,
+
+		blankSrc: dojo.uri.dojoUri("src/widget/templates/images/blank.gif"),
+
+		templateString: '<img class="dojoAnimatedPng" />',
+
+		postCreate: function(){
+			this.cellWidth = this.width;
+			this.cellHeight = this.height;
+
+			var img = new Image();
+			var self = this;
+
+			img.onload = function(){ self.initAni(img.width, img.height); };
+			img.src = this.aniSrc;
+		},
+
+		initAni: function(w, h){
+
+			this.domNode.src = this.blankSrc;
+			this.domNode.width = this.cellWidth;
+			this.domNode.height = this.cellHeight;
+			this.domNode.style.backgroundImage = 'url('+this.aniSrc+')';
+			this.domNode.style.backgroundRepeat = 'no-repeat';
+
+			this.aniCols = Math.floor(w/this.cellWidth);
+			this.aniRows = Math.floor(h/this.cellHeight);
+			this.aniCells = this.aniCols * this.aniRows;
+			this.aniFrame = 0;
+
+			window.setInterval(dojo.lang.hitch(this, 'tick'), this.interval);
+		},
+
+		tick: function(){
+
+			this.aniFrame++;
+			if (this.aniFrame == this.aniCells) this.aniFrame = 0;
+
+			var col = this.aniFrame % this.aniCols;
+			var row = Math.floor(this.aniFrame / this.aniCols);
+
+			var bx = -1 * col * this.cellWidth;
+			var by = -1 * row * this.cellHeight;
+
+			this.domNode.style.backgroundPosition = bx+'px '+by+'px';
+		}
 	}
-	var col = this.aniFrame % this.aniCols;
-	var row = Math.floor(this.aniFrame / this.aniCols);
-	var bx = -1 * col * this.cellWidth;
-	var by = -1 * row * this.cellHeight;
-	this.domNode.style.backgroundPosition = bx + "px " + by + "px";
-}});
-
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/Button.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Button.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Button.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,252 +8,308 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.Button");
+dojo.provide("dojo.widget.html.Button");
 
-
-dojo.provide("dojo.widget.Button");
 dojo.require("dojo.lang.extras");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.selection");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
 dojo.require("dojo.widget.*");
-dojo.widget.defineWidget("dojo.widget.Button", dojo.widget.HtmlWidget, {isContainer:true, caption:"", templateString:"<div dojoAttachPoint=\"buttonNode\" class=\"dojoButton\" style=\"position:relative;\" dojoAttachEvent=\"onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick; onKey:onKey; onFocus;\">\n  <div class=\"dojoButtonContents\" align=center dojoAttachPoint=\"containerNode\" style=\"position:absolute;z-index:2;\"></div>\n  <img dojoAttachPoint=\"leftImage\" style=\"position:absolute;left:0px;\">\n  <img dojoAttachPoint=\"centerImage\" style=\"position:absolute;z-index:1;\">\n  <img dojoAttachPoint=\"rightImage\" style=\"position:absolute;top:0px;right:0px;\">\n</div>\n", templateCssString:"/* ---- button --- */\n.dojoButton {\n\tpadding: 0 0 0 0;\n\tfont-size: 8pt;\n\twhite-space: nowrap;\n\tcursor: pointer;\n\tfont-family: Myriad, Tahoma, Verdana, sans-serif;\n}\n\n.dojoButton .dojoButtonContents {\n\tpadding: 2px 2px 2px 2px;\n\ttext-align: center;\!
 t\t/* if icon and label are split across two lines, center icon */\n\tcolor: white;\n}\n\n.dojoButtonLeftPart .dojoButtonContents {\n\tpadding-right: 8px;\n}\n\n.dojoButtonDisabled {\n\tcursor: url(\"images/no.gif\"), default;\n}\n\n\n.dojoButtonContents img {\n\tvertical-align: middle;\t/* if icon and label are on same line, center them */\n}\n\n/* -------- colors ------------ */\n\n.dojoButtonHover .dojoButtonContents {\n}\n\n.dojoButtonDepressed .dojoButtonContents {\n\tcolor: #293a4b;\n}\n\n.dojoButtonDisabled .dojoButtonContents {\n\tcolor: #aaa;\n}\n\n\n/* ---------- drop down button specific ---------- */\n\n/* border between label and arrow (for drop down buttons */\n.dojoButton .border {\n\twidth: 1px;\n\tbackground: gray;\n}\n\n/* button arrow */\n.dojoButton .downArrow {\n\tpadding-left: 10px;\n\ttext-align: center;\n}\n\n.dojoButton.disabled .downArrow {\n\tcursor : default;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/ButtonTemplate.css")!
 , inactiveImg:"templates/images/soriaButton-", activeImg:"temp!
 lates/im
ages/soriaActive-", pressedImg:"templates/images/soriaPressed-", disabledImg:"templates/images/soriaDisabled-", width2height:1 / 3, fillInTemplate:function () {
-	if (this.caption) {
-		this.containerNode.appendChild(document.createTextNode(this.caption));
-	}
-	dojo.html.disableSelection(this.containerNode);
-}, postCreate:function () {
-	this._sizeMyself();
-}, _sizeMyself:function () {
-	if (this.domNode.parentNode) {
-		var placeHolder = document.createElement("span");
-		dojo.html.insertBefore(placeHolder, this.domNode);
-	}
-	dojo.body().appendChild(this.domNode);
-	this._sizeMyselfHelper();
-	if (placeHolder) {
-		dojo.html.insertBefore(this.domNode, placeHolder);
-		dojo.html.removeNode(placeHolder);
-	}
-}, _sizeMyselfHelper:function () {
-	var mb = dojo.html.getMarginBox(this.containerNode);
-	this.height = mb.height;
-	this.containerWidth = mb.width;
-	var endWidth = this.height * this.width2height;
-	this.containerNode.style.left = endWidth + "px";
-	this.leftImage.height = this.rightImage.height = this.centerImage.height = this.height;
-	this.leftImage.width = this.rightImage.width = endWidth + 1;
-	this.centerImage.width = this.containerWidth;
-	this.centerImage.style.left = endWidth + "px";
-	this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);
-	if (this.disabled) {
-		dojo.html.prependClass(this.domNode, "dojoButtonDisabled");
-		this.domNode.removeAttribute("tabIndex");
-		dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", true);
-	} else {
-		dojo.html.removeClass(this.domNode, "dojoButtonDisabled");
-		this.domNode.setAttribute("tabIndex", "0");
-		dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", false);
-	}
-	this.domNode.style.height = this.height + "px";
-	this.domNode.style.width = (this.containerWidth + 2 * endWidth) + "px";
-}, onMouseOver:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	if (!dojo.html.hasClass(this.buttonNode, "dojoButtonHover")) {
-		dojo.html.prependClass(this.buttonNode, "dojoButtonHover");
-	}
-	this._setImage(this.activeImg);
-}, onMouseDown:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.prependClass(this.buttonNode, "dojoButtonDepressed");
-	dojo.html.removeClass(this.buttonNode, "dojoButtonHover");
-	this._setImage(this.pressedImg);
-}, onMouseUp:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.prependClass(this.buttonNode, "dojoButtonHover");
-	dojo.html.removeClass(this.buttonNode, "dojoButtonDepressed");
-	this._setImage(this.activeImg);
-}, onMouseOut:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	if (e.toElement && dojo.html.isDescendantOf(e.toElement, this.buttonNode)) {
-		return;
-	}
-	dojo.html.removeClass(this.buttonNode, "dojoButtonHover");
-	dojo.html.removeClass(this.buttonNode, "dojoButtonDepressed");
-	this._setImage(this.inactiveImg);
-}, onKey:function (e) {
-	if (!e.key) {
-		return;
-	}
-	var menu = dojo.widget.getWidgetById(this.menuId);
-	if (e.key == e.KEY_ENTER || e.key == " ") {
-		this.onMouseDown(e);
-		this.buttonClick(e);
-		dojo.lang.setTimeout(this, "onMouseUp", 75, e);
-		dojo.event.browser.stopEvent(e);
-	}
-	if (menu && menu.isShowingNow && e.key == e.KEY_DOWN_ARROW) {
-		dojo.event.disconnect(this.domNode, "onblur", this, "onBlur");
-	}
-}, onFocus:function (e) {
-	var menu = dojo.widget.getWidgetById(this.menuId);
-	if (menu) {
-		dojo.event.connectOnce(this.domNode, "onblur", this, "onBlur");
-	}
-}, onBlur:function (e) {
-	var menu = dojo.widget.getWidgetById(this.menuId);
-	if (!menu) {
-		return;
-	}
-	if (menu.close && menu.isShowingNow) {
-		menu.close();
-	}
-}, buttonClick:function (e) {
-	if (!this.disabled) {
-		try {
-			this.domNode.focus();
+dojo.require("dojo.widget.HtmlWidget");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Button",
+	dojo.widget.HtmlWidget,
+	{
+		widgetType: "Button",
+		isContainer: true,
+	
+		// Constructor arguments
+		caption: "",
+		disabled: false,
+	
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlButtonTemplate.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlButtonTemplate.css"),
+		
+		// button images
+		inactiveImg: "src/widget/templates/images/soriaButton-",
+		activeImg: "src/widget/templates/images/soriaActive-",
+		pressedImg: "src/widget/templates/images/soriaPressed-",
+		disabledImg: "src/widget/templates/images/soriaDisabled-",
+		width2height: 1.0/3.0,
+	
+		// attach points
+		containerNode: null,
+		leftImage: null,
+		centerImage: null,
+		rightImage: null,
+	
+		fillInTemplate: function(args, frag){
+			if(this.caption != ""){
+				this.containerNode.appendChild(document.createTextNode(this.caption));
+			}
+			dojo.html.disableSelection(this.containerNode);
+		},
+
+		postCreate: function(args, frag){
+			this.sizeMyself();
+		},
+	
+		sizeMyself: function(){
+			// we cannot size correctly if any of our ancestors are hidden (display:none),
+			// so temporarily attach to document.body
+			if(this.domNode.parentNode){
+				var placeHolder = document.createElement("span");
+				dojo.dom.insertBefore(placeHolder, this.domNode);
+			}
+			dojo.html.body().appendChild(this.domNode);
+			
+			this.sizeMyselfHelper();
+			
+			// Put this.domNode back where it was originally
+			if(placeHolder){
+				dojo.dom.insertBefore(this.domNode, placeHolder);
+				dojo.dom.removeNode(placeHolder);
+			}
+		},
+
+		sizeMyselfHelper: function(){
+			this.height = dojo.style.getOuterHeight(this.containerNode);
+			this.containerWidth = dojo.style.getOuterWidth(this.containerNode);
+			var endWidth= this.height * this.width2height;
+	
+			this.containerNode.style.left=endWidth+"px";
+	
+			this.leftImage.height = this.rightImage.height = this.centerImage.height = this.height;
+			this.leftImage.width = this.rightImage.width = endWidth+1;
+			this.centerImage.width = this.containerWidth;
+			this.centerImage.style.left=endWidth+"px";
+			this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);
+
+			if ( this.disabled ) {
+				dojo.html.prependClass(this.domNode, "dojoButtonDisabled");
+			} else {
+				dojo.html.removeClass(this.domNode, "dojoButtonDisabled");
+			}
+				
+			this.domNode.style.height=this.height + "px";
+			this.domNode.style.width= (this.containerWidth+2*endWidth) + "px";
+		},
+	
+		onMouseOver: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.domNode, "dojoButtonHover");
+			this._setImage(this.activeImg);
+		},
+	
+		onMouseDown: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.domNode, "dojoButtonDepressed");
+			dojo.html.removeClass(this.domNode, "dojoButtonHover");
+			this._setImage(this.pressedImg);
+		},
+		onMouseUp: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.domNode, "dojoButtonHover");
+			dojo.html.removeClass(this.domNode, "dojoButtonDepressed");
+			this._setImage(this.activeImg);
+		},
+	
+		onMouseOut: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.removeClass(this.domNode, "dojoButtonHover");
+			this._setImage(this.inactiveImg);
+		},
+	
+		buttonClick: function(e){
+			if( !this.disabled ) { this.onClick(e); }
+		},
+
+		onClick: function(e) { },
+
+		_setImage: function(prefix){
+			this.leftImage.src=dojo.uri.dojoUri(prefix + "l.gif");
+			this.centerImage.src=dojo.uri.dojoUri(prefix + "c.gif");
+			this.rightImage.src=dojo.uri.dojoUri(prefix + "r.gif");
+		},
+		
+		_toggleMenu: function(menuId){
+			var menu = dojo.widget.getWidgetById(menuId);
+			if ( !menu ) { return; }
+	
+			if ( menu.open && !menu.isShowingNow) {
+				var pos = dojo.style.getAbsolutePosition(this.domNode, false);
+				menu.open(pos.x, pos.y+this.height, this);
+			} else if ( menu.close && menu.isShowingNow ){
+				menu.close();
+			} else {
+				menu.toggle();
+			}
+		},
+		
+		setCaption: function(content){
+			this.caption=content;
+			this.containerNode.innerHTML=content;
+			this.sizeMyself();
+		},
+		
+		setDisabled: function(disabled){
+			this.disabled=disabled;
+			this.sizeMyself();
 		}
-		catch (e2) {
+	});
+
+/**** DropDownButton - push the button and a menu shows up *****/
+dojo.widget.defineWidget(
+	"dojo.widget.html.DropDownButton",
+	dojo.widget.html.Button,
+	{
+		widgetType: "DropDownButton",
+	
+		menuId: "",
+
+		arrow: null,
+	
+		downArrow: "src/widget/templates/images/whiteDownArrow.gif",
+		disabledDownArrow: "src/widget/templates/images/whiteDownArrow.gif",
+	
+		fillInTemplate: function(args, frag){
+			dojo.widget.html.DropDownButton.superclass.fillInTemplate.call(this, args, frag);
+	
+			this.arrow = document.createElement("img");
+			dojo.html.setClass(this.arrow, "downArrow");
+		},
+
+		sizeMyselfHelper: function(){
+			// draw the arrow (todo: why is the arror in containerNode rather than outside it?)
+			this.arrow.src = dojo.uri.dojoUri(this.disabled ? this.disabledDownArrow : this.downArrow);
+			this.containerNode.appendChild(this.arrow);
+
+			dojo.widget.html.DropDownButton.superclass.sizeMyselfHelper.call(this);
+		},
+
+		onClick: function (e){
+			this._toggleMenu(this.menuId);
 		}
-		this.onClick(e);
-	}
-}, onClick:function (e) {
-}, _setImage:function (prefix) {
-	this.leftImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "l.gif");
-	this.centerImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "c.gif");
-	this.rightImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "r.gif");
-}, _toggleMenu:function (menuId) {
-	var menu = dojo.widget.getWidgetById(menuId);
-	if (!menu) {
-		return;
-	}
-	if (menu.open && !menu.isShowingNow) {
-		var pos = dojo.html.getAbsolutePosition(this.domNode, false);
-		menu.open(pos.x, pos.y + this.height, this);
-		dojo.event.disconnect(this.domNode, "onblur", this, "onBlur");
-	} else {
-		if (menu.close && menu.isShowingNow) {
-			menu.close();
-		} else {
-			menu.toggle();
-		}
-	}
-}, setCaption:function (content) {
-	this.caption = content;
-	this.containerNode.innerHTML = content;
-	this._sizeMyself();
-}, setDisabled:function (disabled) {
-	this.disabled = disabled;
-	this._sizeMyself();
-}});
-dojo.widget.defineWidget("dojo.widget.DropDownButton", dojo.widget.Button, {menuId:"", downArrow:"templates/images/whiteDownArrow.gif", disabledDownArrow:"templates/images/whiteDownArrow.gif", fillInTemplate:function () {
-	dojo.widget.DropDownButton.superclass.fillInTemplate.apply(this, arguments);
-	this.arrow = document.createElement("img");
-	dojo.html.setClass(this.arrow, "downArrow");
-	dojo.widget.wai.setAttr(this.domNode, "waiState", "haspopup", this.menuId);
-}, _sizeMyselfHelper:function () {
-	this.arrow.src = dojo.uri.moduleUri("dojo.widget", this.disabled ? this.disabledDownArrow : this.downArrow);
-	this.containerNode.appendChild(this.arrow);
-	dojo.widget.DropDownButton.superclass._sizeMyselfHelper.call(this);
-}, onClick:function (e) {
-	this._toggleMenu(this.menuId);
-}});
-dojo.widget.defineWidget("dojo.widget.ComboButton", dojo.widget.Button, {menuId:"", templateString:"<div class=\"dojoButton\" style=\"position:relative;top:0px;left:0px; text-align:none;\" dojoAttachEvent=\"onKey;onFocus\">\n\n\t<div dojoAttachPoint=\"buttonNode\" class=\"dojoButtonLeftPart\" style=\"position:absolute;left:0px;top:0px;\"\n\t\tdojoAttachEvent=\"onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick;\">\n\t\t<div class=\"dojoButtonContents\" dojoAttachPoint=\"containerNode\" style=\"position:absolute;top:0px;right:0px;z-index:2;\"></div>\n\t\t<img dojoAttachPoint=\"leftImage\" style=\"position:absolute;left:0px;top:0px;\">\n\t\t<img dojoAttachPoint=\"centerImage\" style=\"position:absolute;right:0px;top:0px;z-index:1;\">\n\t</div>\n\n\t<div dojoAttachPoint=\"rightPart\" class=\"dojoButtonRightPart\" style=\"position:absolute;top:0px;right:0px;\"\n\t\tdojoAttachEvent=\"onMouseOver:rightOver; onMouseOut:rightOut; onMouseDown:rightDown; onMouseUp:r!
 ightUp; onClick:rightClick;\">\n\t\t<img dojoAttachPoint=\"arrowBackgroundImage\" style=\"position:absolute;top:0px;left:0px;z-index:1;\">\n\t\t<img src=\"${dojoWidgetModuleUri}templates/images/whiteDownArrow.gif\"\n\t\t  \t\tstyle=\"z-index:2;position:absolute;left:3px;top:50%;\">\n\t\t<img dojoAttachPoint=\"rightImage\" style=\"position:absolute;top:0px;right:0px;\">\n\t</div>\n\n</div>\n", splitWidth:2, arrowWidth:5, _sizeMyselfHelper:function (e) {
-	var mb = dojo.html.getMarginBox(this.containerNode);
-	this.height = mb.height;
-	this.containerWidth = mb.width;
-	var endWidth = this.height / 3;
-	if (this.disabled) {
-		dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", true);
-		this.domNode.removeAttribute("tabIndex");
-	} else {
-		dojo.widget.wai.setAttr(this.domNode, "waiState", "disabled", false);
-		this.domNode.setAttribute("tabIndex", "0");
-	}
-	this.leftImage.height = this.rightImage.height = this.centerImage.height = this.arrowBackgroundImage.height = this.height;
-	this.leftImage.width = endWidth + 1;
-	this.centerImage.width = this.containerWidth;
-	this.buttonNode.style.height = this.height + "px";
-	this.buttonNode.style.width = endWidth + this.containerWidth + "px";
-	this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);
-	this.arrowBackgroundImage.width = this.arrowWidth;
-	this.rightImage.width = endWidth + 1;
-	this.rightPart.style.height = this.height + "px";
-	this.rightPart.style.width = this.arrowWidth + endWidth + "px";
-	this._setImageR(this.disabled ? this.disabledImg : this.inactiveImg);
-	this.domNode.style.height = this.height + "px";
-	var totalWidth = this.containerWidth + this.splitWidth + this.arrowWidth + 2 * endWidth;
-	this.domNode.style.width = totalWidth + "px";
-}, _setImage:function (prefix) {
-	this.leftImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "l.gif");
-	this.centerImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "c.gif");
-}, rightOver:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.prependClass(this.rightPart, "dojoButtonHover");
-	this._setImageR(this.activeImg);
-}, rightDown:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.prependClass(this.rightPart, "dojoButtonDepressed");
-	dojo.html.removeClass(this.rightPart, "dojoButtonHover");
-	this._setImageR(this.pressedImg);
-}, rightUp:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.prependClass(this.rightPart, "dojoButtonHover");
-	dojo.html.removeClass(this.rightPart, "dojoButtonDepressed");
-	this._setImageR(this.activeImg);
-}, rightOut:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.removeClass(this.rightPart, "dojoButtonHover");
-	dojo.html.removeClass(this.rightPart, "dojoButtonDepressed");
-	this._setImageR(this.inactiveImg);
-}, rightClick:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	try {
-		this.domNode.focus();
-	}
-	catch (e2) {
-	}
-	this._toggleMenu(this.menuId);
-}, _setImageR:function (prefix) {
-	this.arrowBackgroundImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "c.gif");
-	this.rightImage.src = dojo.uri.moduleUri("dojo.widget", prefix + "r.gif");
-}, onKey:function (e) {
-	if (!e.key) {
-		return;
-	}
-	var menu = dojo.widget.getWidgetById(this.menuId);
-	if (e.key == e.KEY_ENTER || e.key == " ") {
-		this.onMouseDown(e);
-		this.buttonClick(e);
-		dojo.lang.setTimeout(this, "onMouseUp", 75, e);
-		dojo.event.browser.stopEvent(e);
-	} else {
-		if (e.key == e.KEY_DOWN_ARROW && e.altKey) {
-			this.rightDown(e);
-			this.rightClick(e);
-			dojo.lang.setTimeout(this, "rightUp", 75, e);
-			dojo.event.browser.stopEvent(e);
-		} else {
-			if (menu && menu.isShowingNow && e.key == e.KEY_DOWN_ARROW) {
-				dojo.event.disconnect(this.domNode, "onblur", this, "onBlur");
+	});
+
+/**** ComboButton - left side is normal button, right side shows menu *****/
+dojo.widget.defineWidget(
+	"dojo.widget.html.ComboButton",
+	dojo.widget.html.Button,
+	{
+		widgetType: "ComboButton",
+	
+		menuId: "",
+	
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlComboButtonTemplate.html"),
+	
+		// attach points
+		leftPart: null,
+		rightPart: null,
+		arrowBackgroundImage: null,
+	
+		// constants
+		splitWidth: 2,		// pixels between left&right part of button
+		arrowWidth: 5,		// width of segment holding down arrow
+	
+		sizeMyselfHelper: function(e){
+			this.height = dojo.style.getOuterHeight(this.containerNode);
+			this.containerWidth = dojo.style.getOuterWidth(this.containerNode);
+			var endWidth= this.height/3;
+	
+			// left part
+			this.leftImage.height = this.rightImage.height = this.centerImage.height = 
+				this.arrowBackgroundImage.height = this.height;
+			this.leftImage.width = endWidth+1;
+			this.centerImage.width = this.containerWidth;
+			this.leftPart.style.height = this.height + "px";
+			this.leftPart.style.width = endWidth + this.containerWidth + "px";
+			this._setImageL(this.disabled ? this.disabledImg : this.inactiveImg);
+	
+			// right part
+			this.arrowBackgroundImage.width=this.arrowWidth;
+			this.rightImage.width = endWidth+1;
+			this.rightPart.style.height = this.height + "px";
+			this.rightPart.style.width = this.arrowWidth + endWidth + "px";
+			this._setImageR(this.disabled ? this.disabledImg : this.inactiveImg);
+	
+			// outer container
+			this.domNode.style.height=this.height + "px";
+			var totalWidth = this.containerWidth+this.splitWidth+this.arrowWidth+2*endWidth;
+			this.domNode.style.width= totalWidth + "px";
+		},
+	
+		/** functions on left part of button**/
+		leftOver: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.leftPart, "dojoButtonHover");
+			this._setImageL(this.activeImg);
+		},
+	
+		leftDown: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.leftPart, "dojoButtonDepressed");
+			dojo.html.removeClass(this.leftPart, "dojoButtonHover");
+			this._setImageL(this.pressedImg);
+		},
+		leftUp: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.leftPart, "dojoButtonHover");
+			dojo.html.removeClass(this.leftPart, "dojoButtonDepressed");
+			this._setImageL(this.activeImg);
+		},
+	
+		leftOut: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.removeClass(this.leftPart, "dojoButtonHover");
+			this._setImageL(this.inactiveImg);
+		},
+	
+		leftClick: function(e){
+			if ( !this.disabled ) {
+				this.onClick(e);
 			}
+		},
+	
+		_setImageL: function(prefix){
+			this.leftImage.src=dojo.uri.dojoUri(prefix + "l.gif");
+			this.centerImage.src=dojo.uri.dojoUri(prefix + "c.gif");
+		},
+	
+		/*** functions on right part of button ***/
+		rightOver: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.rightPart, "dojoButtonHover");
+			this._setImageR(this.activeImg);
+		},
+	
+		rightDown: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.rightPart, "dojoButtonDepressed");
+			dojo.html.removeClass(this.rightPart, "dojoButtonHover");
+			this._setImageR(this.pressedImg);
+		},
+		rightUp: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.rightPart, "dojoButtonHover");
+			dojo.html.removeClass(this.rightPart, "dojoButtonDepressed");
+			this._setImageR(this.activeImg);
+		},
+	
+		rightOut: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.removeClass(this.rightPart, "dojoButtonHover");
+			this._setImageR(this.inactiveImg);
+		},
+	
+		rightClick: function(e){
+			if( this.disabled ){ return; }
+			this._toggleMenu(this.menuId);
+		},
+	
+		_setImageR: function(prefix){
+			this.arrowBackgroundImage.src=dojo.uri.dojoUri(prefix + "c.gif");
+			this.rightImage.src=dojo.uri.dojoUri(prefix + "r.gif");
 		}
-	}
-}});
-
+	});
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/Button2.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Button2.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Button2.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,33 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.Button2");
+dojo.require("dojo.widget.Button");
+dojo.require("dojo.widget.*");
+
+dojo.widget.tags.addParseTreeHandler("dojo:button2");
+dojo.widget.tags.addParseTreeHandler("dojo:dropdownbutton2");
+dojo.widget.tags.addParseTreeHandler("dojo:combobutton2");
+
+dojo.deprecated("dojo.widget.Button2", "Use dojo.widget.Button instead", "0.4");
+
+dojo.requireAfterIf("html", "dojo.widget.html.Button2");
+
+dojo.widget.Button2 = function(){}
+dojo.inherits(dojo.widget.Button2, dojo.widget.Button);
+dojo.lang.extend(dojo.widget.Button2, { widgetType: "Button2" });
+
+dojo.widget.DropDownButton2 = function(){}
+dojo.inherits(dojo.widget.DropDownButton2, dojo.widget.DropDownButton);
+dojo.lang.extend(dojo.widget.DropDownButton2, { widgetType: "DropDownButton2" });
+
+dojo.widget.ComboButton2 = function(){}
+dojo.inherits(dojo.widget.ComboButton2, dojo.widget.ComboButton);
+dojo.lang.extend(dojo.widget.ComboButton2, { widgetType: "ComboButton2" });

Modified: tags/parley-0.53/root/static/magic/src/widget/Chart.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Chart.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Chart.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,226 +8,192 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Chart");
+dojo.provide("dojo.widget.Chart.PlotTypes");
+dojo.provide("dojo.widget.Chart.DataSeries");
+
 dojo.require("dojo.widget.*");
-dojo.require("dojo.gfx.color");
-dojo.require("dojo.gfx.color.hsl");
-dojo.declare("dojo.widget.Chart", null, function () {
+dojo.require("dojo.graphics.color");
+dojo.require("dojo.graphics.color.hsl");
+dojo.widget.tags.addParseTreeHandler("dojo:chart");
+
+dojo.widget.Chart = function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = "Chart";
+	this.isContainer = false;
 	this.series = [];
-}, {isContainer:false, assignColors:function () {
-	var hue = 30;
-	var sat = 120;
-	var lum = 120;
-	var steps = Math.round(330 / this.series.length);
-	for (var i = 0; i < this.series.length; i++) {
-		var c = dojo.gfx.color.hsl2rgb(hue, sat, lum);
-		if (!this.series[i].color) {
-			this.series[i].color = dojo.gfx.color.rgb2hex(c[0], c[1], c[2]);
-		}
-		hue += steps;
-	}
-}, parseData:function (table) {
-	var thead = table.getElementsByTagName("thead")[0];
-	var tbody = table.getElementsByTagName("tbody")[0];
-	if (!(thead && tbody)) {
-		dojo.raise("dojo.widget.Chart: supplied table must define a head and a body.");
-	}
-	var columns = thead.getElementsByTagName("tr")[0].getElementsByTagName("th");
-	for (var i = 1; i < columns.length; i++) {
-		var key = "column" + i;
-		var label = columns[i].innerHTML;
-		var plotType = columns[i].getAttribute("plotType") || "line";
-		var color = columns[i].getAttribute("color");
-		var ds = new dojo.widget.Chart.DataSeries(key, label, plotType, color);
-		this.series.push(ds);
-	}
-	var rows = tbody.rows;
-	var xMin = Number.MAX_VALUE, xMax = Number.MIN_VALUE;
-	var yMin = Number.MAX_VALUE, yMax = Number.MIN_VALUE;
-	var ignore = ["accesskey", "align", "bgcolor", "class", "colspan", "height", "id", "nowrap", "rowspan", "style", "tabindex", "title", "valign", "width"];
-	for (var i = 0; i < rows.length; i++) {
-		var row = rows[i];
-		var cells = row.cells;
-		var x = Number.MIN_VALUE;
-		for (var j = 0; j < cells.length; j++) {
-			if (j == 0) {
-				x = parseFloat(cells[j].innerHTML);
-				xMin = Math.min(xMin, x);
-				xMax = Math.max(xMax, x);
-			} else {
-				var ds = this.series[j - 1];
-				var y = parseFloat(cells[j].innerHTML);
-				yMin = Math.min(yMin, y);
-				yMax = Math.max(yMax, y);
-				var o = {x:x, value:y};
-				var attrs = cells[j].attributes;
-				for (var k = 0; k < attrs.length; k++) {
-					var attr = attrs.item(k);
-					var bIgnore = false;
-					for (var l = 0; l < ignore.length; l++) {
-						if (attr.nodeName.toLowerCase() == ignore[l]) {
-							bIgnore = true;
-							break;
-						}
-					}
-					if (!bIgnore) {
-						o[attr.nodeName] = attr.nodeValue;
-					}
-				}
-				ds.add(o);
+	// FIXME: why is this a mixin method?
+	this.assignColors = function(){
+		var hue=30;
+		var sat=120;
+		var lum=120;
+		var steps = Math.round(330/this.series.length);
+
+		for(var i=0; i<this.series.length; i++){
+			var c=dojo.graphics.color.hsl2rgb(hue,sat,lum);
+			if(!this.series[i].color){
+				this.series[i].color = dojo.graphics.color.rgb2hex(c[0],c[1],c[2]);
 			}
+			hue += steps;
 		}
-	}
-	return {x:{min:xMin, max:xMax}, y:{min:yMin, max:yMax}};
-}});
-dojo.declare("dojo.widget.Chart.DataSeries", null, function (key, label, plotType, color) {
-	this.id = "DataSeries" + dojo.widget.Chart.DataSeries.count++;
+	};
+}
+dojo.inherits(dojo.widget.Chart, dojo.widget.Widget);
+
+dojo.widget.Chart.PlotTypes = {
+	Bar:"bar",
+	Line:"line",
+	Scatter:"scatter",
+	Bubble:"bubble"
+};
+
+/*
+ *	Every chart has a set of data series; this is the series.  Note that each
+ *	member of value is an object and in the minimum has 2 properties: .x and
+ *	.value.
+ */
+dojo.widget.Chart.DataSeries = function(key, label, plotType, color){
+	// FIXME: why the hell are plot types specified neumerically? What is this? C?
+	this.id = "DataSeries"+dojo.widget.Chart.DataSeries.count++;
 	this.key = key;
-	this.label = label || this.id;
-	this.plotType = plotType || "line";
+	this.label = label||this.id;
+	this.plotType = plotType||0;
 	this.color = color;
 	this.values = [];
-}, {add:function (v) {
-	if (v.x == null || v.value == null) {
-		dojo.raise("dojo.widget.Chart.DataSeries.add: v must have both an 'x' and 'value' property.");
-	}
-	this.values.push(v);
-}, clear:function () {
-	this.values = [];
-}, createRange:function (len) {
-	var idx = this.values.length - 1;
-	var length = (len || this.values.length);
-	return {"index":idx, "length":length, "start":Math.max(idx - length, 0)};
-}, getMean:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
-		return 0;
-	}
-	var t = 0;
-	var c = 0;
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			t += n;
-			c++;
+};
+
+dojo.lang.extend(dojo.widget.Chart.DataSeries, {
+	add: function(v){
+		if(v.x==null||v.value==null){
+			dojo.raise("dojo.widget.Chart.DataSeries.add: v must have both an 'x' and 'value' property.");
 		}
-	}
-	t /= Math.max(c, 1);
-	return t;
-}, getMovingAverage:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
-		return 0;
-	}
-	var t = 0;
-	var c = 0;
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			t += n;
-			c++;
+		this.values.push(v);
+	},
+
+	clear: function(){
+		this.values=[];
+	},
+
+	createRange: function(len){
+		var idx = this.values.length-1;
+		var length = (len||this.values.length);
+		return { "index": idx, "length": length, "start":Math.max(idx-length,0) };
+	},
+
+	//	trend values
+	getMean: function(len){
+		var range = this.createRange(len);
+		if(range.index<0){ return 0; }
+		var t = 0;
+		var c = 0;
+		for(var i=range.index; i>=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){ t += n; c++; }
 		}
-	}
-	t /= Math.max(c, 1);
-	return t;
-}, getVariance:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
-		return 0;
-	}
-	var t = 0;
-	var s = 0;
-	var c = 0;
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			t += n;
-			s += Math.pow(n, 2);
-			c++;
+		t /= Math.max(c,1);
+		return t;
+	},
+
+	getMovingAverage: function(len){
+		var range = this.createRange(len);
+		if(range.index<0){ return 0; }
+		var t = 0;
+		var c = 0;
+		for(var i=range.index; i>=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){ t += n; c++; }
 		}
-	}
-	return (s / c) - Math.pow(t / c, 2);
-}, getStandardDeviation:function (len) {
-	return Math.sqrt(this.getVariance(len));
-}, getMax:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
-		return 0;
-	}
-	var t = 0;
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			t = Math.max(n, t);
+		t /= Math.max(c,1);
+		return t;
+	},
+
+	getVariance: function(len){
+		var range = this.createRange(len);
+		if(range.index < 0){ return 0; }
+		var t = 0; // FIXME: for tom: wtf are t, c, and s?
+		var s = 0;
+		var c = 0;
+		for(var i=range.index; i>=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){
+				t += n;
+				s += Math.pow(n,2);
+				c++;
+			}
 		}
-	}
-	return t;
-}, getMin:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
-		return 0;
-	}
-	var t = 0;
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			t = Math.min(n, t);
+		return (s/c)-Math.pow(t/c,2);
+	},
+
+	getStandardDeviation: function(len){
+		return Math.sqrt(this.getVariance(len));
+	},
+
+	getMax: function(len){
+		var range = this.createRange(len);
+		if(range.index < 0){ return 0; }
+		var t = 0;
+		for (var i=range.index; i>=range.start; i--){
+			var n=parseFloat(this.values[i].value);
+			if (!isNaN(n)){
+				t=Math.max(n,t);
+			}
 		}
-	}
-	return t;
-}, getMedian:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
-		return 0;
-	}
-	var a = [];
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			var b = false;
-			for (var j = 0; j < a.length && !b; j++) {
-				if (n == a[j]) {
-					b = true;
+		return t;
+	},
+
+	getMin: function(len){
+		var range=this.createRange(len);
+		if(range.index < 0){ return 0; }
+		var t = 0;
+		for(var i=range.index; i>=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){
+				t=Math.min(n,t);
+			}
+		}
+		return t;
+	},
+
+	getMedian: function(len){
+		var range = this.createRange(len);
+
+		if(range.index<0){ return 0; }
+
+		var a = [];
+		for (var i=range.index; i>=range.start; i--){
+			var n=parseFloat(this.values[i].value);
+			if (!isNaN(n)){
+				var b=false;
+				for(var j=0; j<a.length&&!b; j++){
+					if (n==a[j]) b=true; 
 				}
+				if(!b){ a.push(n); }
 			}
-			if (!b) {
-				a.push(n);
-			}
 		}
-	}
-	a.sort();
-	if (a.length > 0) {
-		return a[Math.ceil(a.length / 2)];
-	}
-	return 0;
-}, getMode:function (len) {
-	var range = this.createRange(len);
-	if (range.index < 0) {
+		a.sort();
+		if(a.length>0){ return a[Math.ceil(a.length/2)]; }
 		return 0;
-	}
-	var o = {};
-	var ret = 0;
-	var m = 0;
-	for (var i = range.index; i >= range.start; i--) {
-		var n = parseFloat(this.values[i].value);
-		if (!isNaN(n)) {
-			if (!o[this.values[i].value]) {
-				o[this.values[i].value] = 1;
-			} else {
-				o[this.values[i].value]++;
+	},
+
+	getMode: function(len){
+		var range=this.createRange(len);
+		if(range.index<0){ return 0; }
+		var o = {};
+		var ret = 0
+		var m = 0;
+		for(var i=range.index; i>=range.start; i--){
+			var n=parseFloat(this.values[i].value);
+			if(!isNaN(n)){
+				if (!o[this.values[i].value]) o[this.values[i].value] = 1;
+				else o[this.values[i].value]++;
 			}
 		}
-	}
-	for (var p in o) {
-		if (m < o[p]) {
-			m = o[p];
-			ret = p;
+		for(var p in o){
+			if(m<o[p]){ m=o[p]; ret=p; }
 		}
+		return parseFloat(ret);
 	}
-	return parseFloat(ret);
-}});
-dojo.requireIf(dojo.render.svg.capable, "dojo.widget.svg.Chart");
-dojo.requireIf(!dojo.render.svg.capable && dojo.render.vml.capable, "dojo.widget.vml.Chart");
+});
 
+dojo.requireIf(dojo.render.svg.support.builtin, "dojo.widget.svg.Chart");
+dojo.requireIf(dojo.render.html.ie, "dojo.widget.vml.Chart");

Modified: tags/parley-0.53/root/static/magic/src/widget/Checkbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Checkbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Checkbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,96 +8,6 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Checkbox");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.selection");
-dojo.widget.defineWidget("dojo.widget.Checkbox", dojo.widget.HtmlWidget, {templateString:"<span style=\"display: inline-block;\" tabIndex=\"${this.tabIndex}\" waiRole=\"checkbox\" id=\"${this.id}\">\n\t<img dojoAttachPoint=\"imageNode\" class=\"dojoHtmlCheckbox\" src=\"${dojoWidgetModuleUri}templates/images/blank.gif\" alt=\"\" />\n\t<input type=\"checkbox\" name=\"${this.name}\" style=\"display: none\" value=\"${this.value}\"\n\t\tdojoAttachPoint=\"inputNode\">\n</span>\n", templateCssString:".dojoHtmlCheckbox {\n\tborder: 0px;\n\twidth: 16px;\n\theight: 16px;\n\tmargin: 2px;\n\tvertical-align: middle;\n}\n\n.dojoHtmlCheckboxOn {\n\tbackground: url(check.gif) 0px 0px;\n}\n.dojoHtmlCheckboxOff {\n\tbackground: url(check.gif) -16px 0px;\n}\n.dojoHtmlCheckboxDisabledOn {\n\tbackground: url(check.gif) -32px 0px;\n}\n.dojoHtmlCheckboxDisabledOff {\n\tbackground: url(check.gif) -48px 0px;\n}\n.dojoHtmlCheckboxOnHover {\n\tbackground: url(check.gif) -64px 0px;\n}\n.dojoHtmlCheckb!
 oxOffHover {\n\tbackground: url(check.gif) -80px 0px;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Checkbox.css"), name:"", id:"", checked:false, tabIndex:"", value:"on", postMixInProperties:function () {
-	dojo.widget.Checkbox.superclass.postMixInProperties.apply(this, arguments);
-	if (!this.disabled && this.tabIndex == "") {
-		this.tabIndex = "0";
-	}
-}, fillInTemplate:function () {
-	this._setInfo();
-}, postCreate:function () {
-	var notcon = true;
-	this.id = this.id != "" ? this.id : this.widgetId;
-	if (this.id != "") {
-		var labels = document.getElementsByTagName("label");
-		if (labels != null && labels.length > 0) {
-			for (var i = 0; i < labels.length; i++) {
-				if (labels[i].htmlFor == this.id) {
-					labels[i].id = (labels[i].htmlFor + "label");
-					this._connectEvents(labels[i]);
-					dojo.widget.wai.setAttr(this.domNode, "waiState", "labelledby", labels[i].id);
-					break;
-				}
-			}
-		}
-	}
-	this._connectEvents(this.domNode);
-	this.inputNode.checked = this.checked;
-}, _connectEvents:function (node) {
-	dojo.event.connect(node, "onmouseover", this, "mouseOver");
-	dojo.event.connect(node, "onmouseout", this, "mouseOut");
-	dojo.event.connect(node, "onkey", this, "onKey");
-	dojo.event.connect(node, "onclick", this, "_onClick");
-	dojo.html.disableSelection(node);
-}, _onClick:function (e) {
-	if (this.disabled == false) {
-		this.checked = !this.checked;
-		this._setInfo();
-	}
-	e.preventDefault();
-	e.stopPropagation();
-	this.onClick();
-}, setValue:function (bool) {
-	if (this.disabled == false) {
-		this.checked = bool;
-		this._setInfo();
-	}
-}, onClick:function () {
-}, onKey:function (e) {
-	var k = dojo.event.browser.keys;
-	if (e.key == " ") {
-		this._onClick(e);
-	}
-}, mouseOver:function (e) {
-	this._hover(e, true);
-}, mouseOut:function (e) {
-	this._hover(e, false);
-}, _hover:function (e, isOver) {
-	if (this.disabled == false) {
-		var state = this.checked ? "On" : "Off";
-		var style = "dojoHtmlCheckbox" + state + "Hover";
-		if (isOver) {
-			dojo.html.addClass(this.imageNode, style);
-		} else {
-			dojo.html.removeClass(this.imageNode, style);
-		}
-	}
-}, _setInfo:function () {
-	var state = "dojoHtmlCheckbox" + (this.disabled ? "Disabled" : "") + (this.checked ? "On" : "Off");
-	dojo.html.setClass(this.imageNode, "dojoHtmlCheckbox " + state);
-	this.inputNode.checked = this.checked;
-	if (this.disabled) {
-		this.inputNode.setAttribute("disabled", true);
-	} else {
-		this.inputNode.removeAttribute("disabled");
-	}
-	dojo.widget.wai.setAttr(this.domNode, "waiState", "checked", this.checked);
-}});
-dojo.widget.defineWidget("dojo.widget.a11y.Checkbox", dojo.widget.Checkbox, {templateString:"<span class='dojoHtmlCheckbox'>\n\t<input type=\"checkbox\" name=\"${this.name}\" tabIndex=\"${this.tabIndex}\" id=\"${this.id}\" value=\"${this.value}\"\n\t\t dojoAttachEvent=\"onClick: _onClick;\" dojoAttachPoint=\"inputNode\"> \n</span>\n", fillInTemplate:function () {
-}, postCreate:function (args, frag) {
-	this.inputNode.checked = this.checked;
-	if (this.disabled) {
-		this.inputNode.setAttribute("disabled", true);
-	}
-}, _onClick:function () {
-	this.onClick();
-}});
 
+dojo.requireAfterIf("html", "dojo.widget.html.Checkbox");

Added: tags/parley-0.53/root/static/magic/src/widget/CiviCrmDatePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/CiviCrmDatePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/CiviCrmDatePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,118 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.CiviCrmDatePicker");
+dojo.provide("dojo.widget.HtmlCiviCrmDatePicker");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.event.*");
+dojo.require("dojo.widget.DatePicker");
+dojo.require("dojo.widget.html.DatePicker");
+dojo.require("dojo.widget.html.TimePicker");
+dojo.require("dojo.html");
+
+dojo.widget.HtmlCiviCrmDatePicker = function(){
+	this.widgetType = "CiviCrmDatePicker";
+	this.idPrefix = "scheduled_date_time";
+	this.mode = "datetime"; // can also be date or time
+
+	this.datePicker = null;
+	this.timePicker = null;
+
+	// html nodes
+	this.dateHolderTd = null;
+	this.timeHolderTd = null;
+	this.formItemsTd = null;
+	this.formItemsTr = null;
+
+	this.monthSelect = null;
+	this.daySelect = null;
+	this.yearSelect = null;
+	this.hourSelect = null;
+	this.minSelect = null;
+	this.apSelect = null;
+
+	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlCiviCrmDatePicker.html");
+
+	this.modeFormats = {
+		date: "MdY",
+		time: "hiA"
+	};
+
+	this.formatMappings = {
+		"M": "monthSelect",
+		"d": "daySelect",
+		"Y": "yearSelect",
+		"h": "hourSelect",
+		"i": "minSelect",
+		"A": "apSelect"
+	};
+
+	this.setDateSelects = function(){
+		var dateObj = this.datePicker.date;
+		this.monthSelect.value = new String(dateObj.getMonth()+1);
+		this.daySelect.value = new String(dateObj.getDate());
+		this.yearSelect.value = new String(dateObj.getFullYear());
+	}
+
+	this.setTimeSelects = function(){
+		var st = this.timePicker.selectedTime;
+		this.hourSelect.value = new String(st.hour);
+		this.minSelect.value = new String(st.minute);
+		this.apSelect.value = st.amPm.toUpperCase();
+	}
+
+	this.fillInTemplate = function(args, frag){
+		var nr = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
+		var sref = {};
+		while(nr.firstChild){
+			if(nr.firstChild.name){
+				sref[nr.firstChild.name] = nr.firstChild;
+			}
+			this.formItemsTd.appendChild(nr.firstChild);
+		}
+
+		if(this.mode.indexOf("date") != -1){
+			this.datePicker = dojo.widget.createWidget("DatePicker", {}, this.dateHolderTd);
+			dojo.event.connect(	this.datePicker, "onSetDate", 
+								this, "setDateSelects");
+
+			var mfd = this.modeFormats.date;
+			for(var x=0; x<mfd.length; x++){
+				this[this.formatMappings[mfd[x]]] = sref[this.idPrefix+"["+mfd[x]+"]"];
+			}
+		}
+		if(this.mode.indexOf("time") != -1){
+			this.timePicker = dojo.widget.createWidget("TimePicker", {}, this.timeHolderTd);
+			dojo.event.connect(	this.timePicker, "onSetTime", 
+								this, "setTimeSelects");
+			var mfd = this.modeFormats.time;
+			for(var x=0; x<mfd.length; x++){
+				this[this.formatMappings[mfd[x]]] = sref[this.idPrefix+"["+mfd[x]+"]"];
+			}
+		}
+	}
+
+	this.unhide = function(){
+		this.formItemsTr.style.display = "";
+	}
+
+	this.postCreate = function(){
+		dojo.event.kwConnect({
+			type: "before", 
+			srcObj: dojo.html.getParentByType(this.domNode, "form"),
+			srcFunc: "onsubmit", 
+			targetObj: this,
+			targetFunc: "unhide"
+		});
+	}
+}
+dojo.inherits(dojo.widget.HtmlCiviCrmDatePicker, dojo.widget.HtmlWidget);
+dojo.widget.tags.addParseTreeHandler("dojo:civicrmdatepicker");
+

Deleted: tags/parley-0.53/root/static/magic/src/widget/Clock.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Clock.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Clock.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,142 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.Clock");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.gfx.*");
-dojo.require("dojo.uri.Uri");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.timing.Timer");
-dojo.widget.defineWidget("dojo.widget.Clock", dojo.widget.HtmlWidget, function () {
-	var self = this;
-	this.timeZoneOffset = 0;
-	this.label = "";
-	this.date = new Date();
-	this.handColor = "#788598";
-	this.handStroke = "#6f7b8c";
-	this.secondHandColor = [201, 4, 5, 0.8];
-	this.topLabelColor = "#efefef";
-	this.labelColor = "#fff";
-	this.timer = new dojo.lang.timing.Timer(1000);
-	this.center = {x:75, y:75};
-	this.hands = {hour:null, minute:null, second:null};
-	this.shadows = {hour:{shadow:null, shift:{dx:2, dy:2}}, minute:{shadow:null, shift:{dx:2, dy:3}}, second:{shadow:null, shift:{dx:4, dy:4}}};
-	this.image = dojo.uri.moduleUri("dojo.widget", "templates/images/clock.png");
-	this.surface = null;
-	this.labelNode = null;
-	this.topLabelNode = null;
-	this.draw = function () {
-		self.date = new Date();
-		var h = (self.date.getHours() + self.timeZoneOffset) % 12;
-		var m = self.date.getMinutes();
-		var s = self.date.getSeconds();
-		self.placeHour(h, m, s);
-		self.placeMinute(m, s);
-		self.placeSecond(s);
-		self.topLabelNode.innerHTML = ((self.date.getHours() + self.timeZoneOffset) > 11) ? "PM" : "AM";
-	};
-	this.timer.onTick = self.draw;
-}, {set:function (dt) {
-	this.date = dt;
-	if (!this.timer.isRunning) {
-		this.draw();
-	}
-}, start:function () {
-	this.timer.start();
-}, stop:function () {
-	this.timer.stop();
-}, _initPoly:function (parent, points) {
-	var path = parent.createPath();
-	var first = true;
-	dojo.lang.forEach(points, function (c) {
-		if (first) {
-			path.moveTo(c.x, c.y);
-			first = false;
-		} else {
-			path.lineTo(c.x, c.y);
-		}
-	});
-	return path;
-}, _placeHand:function (shape, angle, shift) {
-	var move = {dx:this.center.x + (shift ? shift.dx : 0), dy:this.center.y + (shift ? shift.dy : 0)};
-	return shape.setTransform([move, dojo.gfx.matrix.rotateg(-angle)]);
-}, placeHour:function (h, m, s) {
-	var angle = 30 * (h + m / 60 + s / 3600);
-	this._placeHand(this.hands.hour, angle);
-	this._placeHand(this.shadows.hour.shadow, angle, this.shadows.hour.shift);
-}, placeMinute:function (m, s) {
-	var angle = 6 * (m + s / 60);
-	this._placeHand(this.hands.minute, angle);
-	this._placeHand(this.shadows.minute.shadow, angle, this.shadows.minute.shift);
-}, placeSecond:function (s) {
-	var angle = 6 * s;
-	this._placeHand(this.hands.second, angle);
-	this._placeHand(this.shadows.second.shadow, angle, this.shadows.second.shift);
-}, init:function () {
-	if (this.domNode.style.position != "absolute") {
-		this.domNode.style.position = "relative";
-	}
-	while (this.domNode.childNodes.length > 0) {
-		this.domNode.removeChild(this.domNode.childNodes[0]);
-	}
-	this.domNode.style.width = "150px";
-	this.domNode.style.height = "150px";
-	this.surface = dojo.gfx.createSurface(this.domNode, 150, 150);
-	this.surface.createRect({width:150, height:150});
-	this.surface.createImage({width:150, height:150, src:this.image + ""});
-	var hP = [{x:-3, y:-4}, {x:3, y:-4}, {x:1, y:-27}, {x:-1, y:-27}, {x:-3, y:-4}];
-	var mP = [{x:-3, y:-4}, {x:3, y:-4}, {x:1, y:-38}, {x:-1, y:-38}, {x:-3, y:-4}];
-	var sP = [{x:-2, y:-2}, {x:2, y:-2}, {x:1, y:-45}, {x:-1, y:-45}, {x:-2, y:-2}];
-	this.shadows.hour.shadow = this._initPoly(this.surface, hP).setFill([0, 0, 0, 0.1]);
-	this.hands.hour = this._initPoly(this.surface, hP).setStroke({color:this.handStroke, width:1}).setFill({type:"linear", x1:0, y1:0, x2:0, y2:-27, colors:[{offset:0, color:"#fff"}, {offset:0.33, color:this.handColor}]});
-	this.shadows.minute.shadow = this._initPoly(this.surface, mP).setFill([0, 0, 0, 0.1]);
-	this.hands.minute = this._initPoly(this.surface, mP).setStroke({color:this.handStroke, width:1}).setFill({type:"linear", x1:0, y1:0, x2:0, y2:-38, colors:[{offset:0, color:"#fff"}, {offset:0.33, color:this.handColor}]});
-	this.surface.createCircle({r:6}).setStroke({color:this.handStroke, width:2}).setFill("#fff").setTransform({dx:75, dy:75});
-	this.shadows.second.shadow = this._initPoly(this.surface, sP).setFill([0, 0, 0, 0.1]);
-	this.hands.second = this._initPoly(this.surface, sP).setFill(this.secondHandColor);
-	this.surface.createCircle({r:4}).setFill(this.secondHandColor).setTransform({dx:75, dy:75});
-	this.topLabelNode = document.createElement("div");
-	with (this.topLabelNode.style) {
-		position = "absolute";
-		top = "3px";
-		left = "0px";
-		color = this.topLabelColor;
-		textAlign = "center";
-		width = "150px";
-		fontFamily = "sans-serif";
-		fontSize = "11px";
-		textTransform = "uppercase";
-		fontWeight = "bold";
-	}
-	this.topLabelNode.innerHTML = ((this.date.getHours() + this.timeZoneOffset) > 11) ? "PM" : "AM";
-	this.domNode.appendChild(this.topLabelNode);
-	this.labelNode = document.createElement("div");
-	with (this.labelNode.style) {
-		position = "absolute";
-		top = "134px";
-		left = "0px";
-		color = this.labelColor;
-		textAlign = "center";
-		width = "150px";
-		fontFamily = "sans-serif";
-		fontSize = "10px";
-		textTransform = "uppercase";
-		fontWeight = "bold";
-	}
-	this.labelNode.innerHTML = this.label || "&nbsp;";
-	this.domNode.appendChild(this.labelNode);
-	this.draw();
-}, postCreate:function () {
-	this.init();
-	this.start();
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/ColorPalette.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ColorPalette.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ColorPalette.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,53 +8,179 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.ColorPalette");
+dojo.provide("dojo.widget.html.ColorPalette");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.Toolbar");
+dojo.require("dojo.html");
 
+dojo.widget.tags.addParseTreeHandler("dojo:ToolbarColorDialog");
 
-dojo.provide("dojo.widget.ColorPalette");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.selection");
-dojo.widget.defineWidget("dojo.widget.ColorPalette", dojo.widget.HtmlWidget, {palette:"7x10", _palettes:{"7x10":[["fff", "fcc", "fc9", "ff9", "ffc", "9f9", "9ff", "cff", "ccf", "fcf"], ["ccc", "f66", "f96", "ff6", "ff3", "6f9", "3ff", "6ff", "99f", "f9f"], ["c0c0c0", "f00", "f90", "fc6", "ff0", "3f3", "6cc", "3cf", "66c", "c6c"], ["999", "c00", "f60", "fc3", "fc0", "3c0", "0cc", "36f", "63f", "c3c"], ["666", "900", "c60", "c93", "990", "090", "399", "33f", "60c", "939"], ["333", "600", "930", "963", "660", "060", "366", "009", "339", "636"], ["000", "300", "630", "633", "330", "030", "033", "006", "309", "303"]], "3x4":[["ffffff", "00ff00", "008000", "0000ff"], ["c0c0c0", "ffff00", "ff00ff", "000080"], ["808080", "ff0000", "800080", "000000"]]}, buildRendering:function () {
-	this.domNode = document.createElement("table");
-	dojo.html.disableSelection(this.domNode);
-	dojo.event.connect(this.domNode, "onmousedown", function (e) {
-		e.preventDefault();
-	});
-	with (this.domNode) {
-		cellPadding = "0";
-		cellSpacing = "1";
-		border = "1";
-		style.backgroundColor = "white";
+dojo.widget.html.ToolbarColorDialog = function(){
+	dojo.widget.html.ToolbarDialog.call(this);
+	
+	/*
+	FIXME: 	why the fuck did anyone ever think this kind of expensive iteration
+			was a good idea?
+
+	for (var method in this.constructor.prototype) {
+		this[method] = this.constructor.prototype[method];
 	}
-	var colors = this._palettes[this.palette];
-	for (var i = 0; i < colors.length; i++) {
-		var tr = this.domNode.insertRow(-1);
-		for (var j = 0; j < colors[i].length; j++) {
-			if (colors[i][j].length == 3) {
-				colors[i][j] = colors[i][j].replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
+	*/
+}
+
+dojo.inherits(dojo.widget.html.ToolbarColorDialog, dojo.widget.html.ToolbarDialog);
+
+dojo.lang.extend(dojo.widget.html.ToolbarColorDialog, {
+
+	widgetType: "ToolbarColorDialog",
+
+	palette: "7x10",
+
+	fillInTemplate: function (args, frag) {
+		dojo.widget.html.ToolbarColorDialog.superclass.fillInTemplate.call(this, args, frag);
+		this.dialog = dojo.widget.createWidget("ColorPalette", {palette: this.palette});
+		this.dialog.domNode.style.position = "absolute";
+
+		dojo.event.connect(this.dialog, "onColorSelect", this, "_setValue");
+	},
+
+	_setValue: function(color) {
+		this._value = color;
+		this._fireEvent("onSetValue", color);
+	},
+	
+	showDialog: function (e) {
+		dojo.widget.html.ToolbarColorDialog.superclass.showDialog.call(this, e);
+		var x = dojo.html.getAbsoluteX(this.domNode);
+		var y = dojo.html.getAbsoluteY(this.domNode) + dojo.html.getInnerHeight(this.domNode);
+		this.dialog.showAt(x, y);
+	},
+	
+	hideDialog: function (e) {
+		dojo.widget.html.ToolbarColorDialog.superclass.hideDialog.call(this, e);
+		this.dialog.hide();
+	}
+});
+
+
+
+dojo.widget.tags.addParseTreeHandler("dojo:colorpalette");
+
+dojo.widget.html.ColorPalette = function () {
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.ColorPalette, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.ColorPalette, {
+
+	widgetType: "colorpalette",
+	
+	palette: "7x10",
+
+	bgIframe: null,
+	
+	palettes: {
+		"7x10": [["fff", "fcc", "fc9", "ff9", "ffc", "9f9", "9ff", "cff", "ccf", "fcf"],
+			["ccc", "f66", "f96", "ff6", "ff3", "6f9", "3ff", "6ff", "99f", "f9f"],
+			["c0c0c0", "f00", "f90", "fc6", "ff0", "3f3", "6cc", "3cf", "66c", "c6c"],
+			["999", "c00", "f60", "fc3", "fc0", "3c0", "0cc", "36f", "63f", "c3c"],
+			["666", "900", "c60", "c93", "990", "090", "399", "33f", "60c", "939"],
+			["333", "600", "930", "963", "660", "060", "366", "009", "339", "636"],
+			["000", "300", "630", "633", "330", "030", "033", "006", "309", "303"]],
+	
+		"3x4": [["ffffff"/*white*/, "00ff00"/*lime*/, "008000"/*green*/, "0000ff"/*blue*/],
+			["c0c0c0"/*silver*/, "ffff00"/*yellow*/, "ff00ff"/*fuchsia*/, "000080"/*navy*/],
+			["808080"/*gray*/, "ff0000"/*red*/, "800080"/*purple*/, "000000"/*black*/]]
+			//["00ffff"/*aqua*/, "808000"/*olive*/, "800000"/*maroon*/, "008080"/*teal*/]];
+	},
+
+	buildRendering: function () {
+		
+		this.domNode = document.createElement("table");
+		dojo.html.disableSelection(this.domNode);
+		dojo.event.connect(this.domNode, "onmousedown", function (e) {
+			e.preventDefault();
+		});
+		with (this.domNode) { // set the table's properties
+			cellPadding = "0"; cellSpacing = "1"; border = "1";
+			style.backgroundColor = "white"; //style.position = "absolute";
+		}
+		var tbody = document.createElement("tbody");
+		this.domNode.appendChild(tbody);
+		var colors = this.palettes[this.palette];
+		for (var i = 0; i < colors.length; i++) {
+			var tr = document.createElement("tr");
+			for (var j = 0; j < colors[i].length; j++) {
+				if (colors[i][j].length == 3) {
+					colors[i][j] = colors[i][j].replace(/(.)(.)(.)/, "$1$1$2$2$3$3");
+				}
+	
+				var td = document.createElement("td");
+				with (td.style) {
+					backgroundColor = "#" + colors[i][j];
+					border = "1px solid gray";
+					width = height = "15px";
+					fontSize = "1px";
+				}
+	
+				td.color = "#" + colors[i][j];
+	
+				td.onmouseover = function (e) { this.style.borderColor = "white"; }
+				td.onmouseout = function (e) { this.style.borderColor = "gray"; }
+				dojo.event.connect(td, "onmousedown", this, "click");
+	
+				td.innerHTML = "&nbsp;";
+				tr.appendChild(td);
 			}
-			var td = tr.insertCell(-1);
-			with (td.style) {
-				backgroundColor = "#" + colors[i][j];
-				border = "1px solid gray";
-				width = height = "15px";
-				fontSize = "1px";
+			tbody.appendChild(tr);
+		}
+
+		if(dojo.render.html.ie){
+			this.bgIframe = document.createElement("<iframe frameborder='0' src='javascript:void(0);'>");
+			with(this.bgIframe.style){
+				position = "absolute";
+				left = top = "0px";
+				display = "none";
 			}
-			td.color = "#" + colors[i][j];
-			td.onmouseover = function (e) {
-				this.style.borderColor = "white";
-			};
-			td.onmouseout = function (e) {
-				this.style.borderColor = "gray";
-			};
-			dojo.event.connect(td, "onmousedown", this, "onClick");
-			td.innerHTML = "&nbsp;";
+			document.body.appendChild(this.bgIframe);
+			dojo.style.setOpacity(this.bgIframe, 0);
 		}
+	},
+
+	click: function (e) {
+		this.onColorSelect(e.currentTarget.color);
+		e.currentTarget.style.borderColor = "gray";
+	},
+
+	onColorSelect: function (color) { },
+
+	hide: function (){
+		this.domNode.parentNode.removeChild(this.domNode);
+		if(this.bgIframe){
+			this.bgIframe.style.display = "none";
+		}
+	},
+	
+	showAt: function (x, y) {
+		with(this.domNode.style){
+			top = y + "px";
+			left = x + "px";
+			zIndex = 999;
+		}
+		document.body.appendChild(this.domNode);
+		if(this.bgIframe){
+			with(this.bgIframe.style){
+				display = "block";
+				top = y + "px";
+				left = x + "px";
+				zIndex = 998;
+				width = dojo.html.getOuterWidth(this.domNode) + "px";
+				height = dojo.html.getOuterHeight(this.domNode) + "px";
+			}
+
+		}
 	}
-}, onClick:function (e) {
-	this.onColorSelect(e.currentTarget.color);
-	e.currentTarget.style.borderColor = "gray";
-}, onColorSelect:function (color) {
-}});
 
+});

Modified: tags/parley-0.53/root/static/magic/src/widget/ComboBox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ComboBox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ComboBox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,551 +8,229 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.ComboBox");
+
 dojo.require("dojo.widget.*");
 dojo.require("dojo.event.*");
-dojo.require("dojo.io.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.string");
-dojo.require("dojo.widget.html.stabile");
-dojo.require("dojo.widget.PopupContainer");
-dojo.declare("dojo.widget.incrementalComboBoxDataProvider", null, function (options) {
-	this.searchUrl = options.dataUrl;
-	this._cache = {};
-	this._inFlight = false;
-	this._lastRequest = null;
+
+dojo.widget.incrementalComboBoxDataProvider = function(url, limit, timeout){
+	this.searchUrl = url;
+	this.inFlight = false;
+	this.activeRequest = null;
 	this.allowCache = false;
-}, {_addToCache:function (keyword, data) {
-	if (this.allowCache) {
-		this._cache[keyword] = data;
+
+	this.cache = {};
+
+	this.init = function(cbox){
+		this.searchUrl = cbox.dataUrl;
 	}
-}, startSearch:function (searchStr, callback) {
-	if (this._inFlight) {
+
+	this.addToCache = function(keyword, data){
+		if(this.allowCache){
+			this.cache[keyword] = data;
+		}
 	}
-	var tss = encodeURIComponent(searchStr);
-	var realUrl = dojo.string.substituteParams(this.searchUrl, {"searchString":tss});
-	var _this = this;
-	var request = this._lastRequest = dojo.io.bind({url:realUrl, method:"get", mimetype:"text/json", load:function (type, data, evt) {
-		_this._inFlight = false;
-		if (!dojo.lang.isArray(data)) {
-			var arrData = [];
-			for (var key in data) {
-				arrData.push([data[key], key]);
-			}
-			data = arrData;
+
+	this.startSearch = function(searchStr, type, ignoreLimit){
+		if(this.inFlight){
+			// FIXME: implement backoff!
 		}
-		_this._addToCache(searchStr, data);
-		if (request == _this._lastRequest) {
-			callback(data);
-		}
-	}});
-	this._inFlight = true;
-}});
-dojo.declare("dojo.widget.basicComboBoxDataProvider", null, function (options, node) {
-	this._data = [];
+		var tss = encodeURIComponent(searchStr);
+		var realUrl = dojo.string.paramString(this.searchUrl, {"searchString": tss});
+		var _this = this;
+		var request = dojo.io.bind({
+			url: realUrl,
+			method: "get",
+			mimetype: "text/json",
+			load: function(type, data, evt){
+				_this.inFlight = false;
+				if(!dojo.lang.isArray(data)){
+					var arrData = [];
+					for(var key in data){
+						arrData.push([data[key], key]);
+					}
+					data = arrData;
+				}
+				_this.addToCache(searchStr, data);
+				_this.provideSearchResults(data);
+			}
+		});
+		this.inFlight = true;
+	}
+}
+
+dojo.widget.ComboBoxDataProvider = function(dataPairs, limit, timeout){
+	// NOTE: this data provider is designed as a naive reference
+	// implementation, and as such it is written more for readability than
+	// speed. A deployable data provider would implement lookups, search
+	// caching (and invalidation), and a significantly less naive data
+	// structure for storage of items.
+
+	this.data = [];
+	this.searchTimeout = 500;
 	this.searchLimit = 30;
-	this.searchType = "STARTSTRING";
+	this.searchType = "STARTSTRING"; // may also be "STARTWORD" or "SUBSTRING"
 	this.caseSensitive = false;
-	if (!dj_undef("dataUrl", options) && !dojo.string.isBlank(options.dataUrl)) {
-		this._getData(options.dataUrl);
-	} else {
-		if ((node) && (node.nodeName.toLowerCase() == "select")) {
-			var opts = node.getElementsByTagName("option");
-			var ol = opts.length;
-			var data = [];
-			for (var x = 0; x < ol; x++) {
-				var text = opts[x].textContent || opts[x].innerText || opts[x].innerHTML;
-				var keyValArr = [String(text), String(opts[x].value)];
-				data.push(keyValArr);
-				if (opts[x].selected) {
-					options.setAllValues(keyValArr[0], keyValArr[1]);
+	// for caching optimizations
+	this._lastSearch = "";
+	this._lastSearchResults = null;
+
+	this.init = function(cbox, node){
+		if(!dojo.string.isBlank(cbox.dataUrl)){
+			this.getData(cbox.dataUrl);
+		}else{
+			// check to see if we can populate the list from <option> elements
+			if((node)&&(node.nodeName.toLowerCase() == "select")){
+				// NOTE: we're not handling <optgroup> here yet
+				var opts = node.getElementsByTagName("option");
+				var ol = opts.length;
+				var data = [];
+				for(var x=0; x<ol; x++){
+					var keyValArr = [new String(opts[x].innerHTML), new String(opts[x].value)];
+					data.push(keyValArr);
+					if(opts[x].selected){ 
+						cbox.setAllValues(keyValArr[0], keyValArr[1]);
+					}
 				}
+				this.setData(data);
 			}
-			this.setData(data);
 		}
 	}
-}, {_getData:function (url) {
-	dojo.io.bind({url:url, load:dojo.lang.hitch(this, function (type, data, evt) {
-		if (!dojo.lang.isArray(data)) {
-			var arrData = [];
-			for (var key in data) {
-				arrData.push([data[key], key]);
-			}
-			data = arrData;
-		}
-		this.setData(data);
-	}), mimetype:"text/json"});
-}, startSearch:function (searchStr, callback) {
-	this._performSearch(searchStr, callback);
-}, _performSearch:function (searchStr, callback) {
-	var st = this.searchType;
-	var ret = [];
-	if (!this.caseSensitive) {
-		searchStr = searchStr.toLowerCase();
-	}
-	for (var x = 0; x < this._data.length; x++) {
-		if ((this.searchLimit > 0) && (ret.length >= this.searchLimit)) {
-			break;
-		}
-		var dataLabel = new String((!this.caseSensitive) ? this._data[x][0].toLowerCase() : this._data[x][0]);
-		if (dataLabel.length < searchStr.length) {
-			continue;
-		}
-		if (st == "STARTSTRING") {
-			if (searchStr == dataLabel.substr(0, searchStr.length)) {
-				ret.push(this._data[x]);
-			}
-		} else {
-			if (st == "SUBSTRING") {
-				if (dataLabel.indexOf(searchStr) >= 0) {
-					ret.push(this._data[x]);
-				}
-			} else {
-				if (st == "STARTWORD") {
-					var idx = dataLabel.indexOf(searchStr);
-					if (idx == 0) {
-						ret.push(this._data[x]);
+
+	this.getData = function(url){
+		dojo.io.bind({
+			url: url,
+			load: dojo.lang.hitch(this, function(type, data, evt){ 
+				if(!dojo.lang.isArray(data)){
+					var arrData = [];
+					for(var key in data){
+						arrData.push([data[key], key]);
 					}
-					if (idx <= 0) {
-						continue;
-					}
-					var matches = false;
-					while (idx != -1) {
-						if (" ,/(".indexOf(dataLabel.charAt(idx - 1)) != -1) {
-							matches = true;
-							break;
-						}
-						idx = dataLabel.indexOf(searchStr, idx + 1);
-					}
-					if (!matches) {
-						continue;
-					} else {
-						ret.push(this._data[x]);
-					}
+					data = arrData;
 				}
-			}
-		}
+				this.setData(data);
+			}),
+			mimetype: "text/json"
+		});
 	}
-	callback(ret);
-}, setData:function (pdata) {
-	this._data = pdata;
-}});
-dojo.widget.defineWidget("dojo.widget.ComboBox", dojo.widget.HtmlWidget, {forceValidOption:false, searchType:"stringstart", dataProvider:null, autoComplete:true, searchDelay:100, dataUrl:"", fadeTime:200, maxListLength:8, mode:"local", selectedResult:null, dataProviderClass:"", buttonSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/combo_box_arrow.png"), dropdownToggle:"fade", templateString:"<span _=\"whitespace and CR's between tags adds &nbsp; in FF\"\n\tclass=\"dojoComboBoxOuter\"\n\t><input style=\"display:none\"  tabindex=\"-1\" name=\"\" value=\"\" \n\t\tdojoAttachPoint=\"comboBoxValue\"\n\t><input style=\"display:none\"  tabindex=\"-1\" name=\"\" value=\"\" \n\t\tdojoAttachPoint=\"comboBoxSelectionValue\"\n\t><input type=\"text\" autocomplete=\"off\" class=\"dojoComboBox\"\n\t\tdojoAttachEvent=\"key:_handleKeyEvents; keyUp: onKeyUp; compositionEnd; onResize;\"\n\t\tdojoAttachPoint=\"textInputNode\"\n\t><img hspace=\"0\"\n\t\tvspace=\"0\"\n\t\tclass=\"dojoComb!
 oBox\"\n\t\tdojoAttachPoint=\"downArrowNode\"\n\t\tdojoAttachEvent=\"onMouseUp: handleArrowClick; onResize;\"\n\t\tsrc=\"${this.buttonSrc}\"\n></span>\n", templateCssString:".dojoComboBoxOuter {\n\tborder: 0px !important;\n\tmargin: 0px !important;\n\tpadding: 0px !important;\n\tbackground: transparent !important;\n\twhite-space: nowrap !important;\n}\n\n.dojoComboBox {\n\tborder: 1px inset #afafaf;\n\tmargin: 0px;\n\tpadding: 0px;\n\tvertical-align: middle !important;\n\tfloat: none !important;\n\tposition: static !important;\n\tdisplay: inline !important;\n}\n\n/* the input box */\ninput.dojoComboBox {\n\tborder-right-width: 0px !important; \n\tmargin-right: 0px !important;\n\tpadding-right: 0px !important;\n}\n\n/* the down arrow */\nimg.dojoComboBox {\n\tborder-left-width: 0px !important;\n\tpadding-left: 0px !important;\n\tmargin-left: 0px !important;\n}\n\n/* IE vertical-alignment calculations can be off by +-1 but these margins are collapsed away */\n.dj_ie img.dojoC!
 omboBox {\n\tmargin-top: 1px; \n\tmargin-bottom: 1px; \n}\n\n/!
 * the dr
op down */\n.dojoComboBoxOptions {\n\tfont-family: Verdana, Helvetica, Garamond, sans-serif;\n\t/* font-size: 0.7em; */\n\tbackground-color: white;\n\tborder: 1px solid #afafaf;\n\tposition: absolute;\n\tz-index: 1000; \n\toverflow: auto;\n\tcursor: default;\n}\n\n.dojoComboBoxItem {\n\tpadding-left: 2px;\n\tpadding-top: 2px;\n\tmargin: 0px;\n}\n\n.dojoComboBoxItemEven {\n\tbackground-color: #f4f4f4;\n}\n\n.dojoComboBoxItemOdd {\n\tbackground-color: white;\n}\n\n.dojoComboBoxItemHighlight {\n\tbackground-color: #63709A;\n\tcolor: white;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/ComboBox.css"), setValue:function (value) {
-	this.comboBoxValue.value = value;
-	if (this.textInputNode.value != value) {
-		this.textInputNode.value = value;
-		dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
-		this.onValueChanged(value);
+
+	this.startSearch = function(searchStr, type, ignoreLimit){
+		// FIXME: need to add timeout handling here!!
+		this._preformSearch(searchStr, type, ignoreLimit);
 	}
-}, onValueChanged:function (value) {
-}, getValue:function () {
-	return this.comboBoxValue.value;
-}, getState:function () {
-	return {value:this.getValue()};
-}, setState:function (state) {
-	this.setValue(state.value);
-}, enable:function () {
-	this.disabled = false;
-	this.textInputNode.removeAttribute("disabled");
-}, disable:function () {
-	this.disabled = true;
-	this.textInputNode.setAttribute("disabled", true);
-}, _getCaretPos:function (element) {
-	if (dojo.lang.isNumber(element.selectionStart)) {
-		return element.selectionStart;
-	} else {
-		if (dojo.render.html.ie) {
-			var tr = document.selection.createRange().duplicate();
-			var ntr = element.createTextRange();
-			tr.move("character", 0);
-			ntr.move("character", 0);
-			try {
-				ntr.setEndPoint("EndToEnd", tr);
-				return String(ntr.text).replace(/\r/g, "").length;
-			}
-			catch (e) {
-				return 0;
-			}
+
+	this._preformSearch = function(searchStr, type, ignoreLimit){
+		//
+		//	NOTE: this search is LINEAR, which means that it exhibits perhaps
+		//	the worst possible speed characteristics of any search type. It's
+		//	written this way to outline the responsibilities and interfaces for
+		//	a search.
+		//
+		var st = type||this.searchType;
+		// FIXME: this is just an example search, which means that we implement
+		// only a linear search without any of the attendant (useful!) optimizations
+		var ret = [];
+		if(!this.caseSensitive){
+			searchStr = searchStr.toLowerCase();
 		}
-	}
-}, _setCaretPos:function (element, location) {
-	location = parseInt(location);
-	this._setSelectedRange(element, location, location);
-}, _setSelectedRange:function (element, start, end) {
-	if (!end) {
-		end = element.value.length;
-	}
-	if (element.setSelectionRange) {
-		element.focus();
-		element.setSelectionRange(start, end);
-	} else {
-		if (element.createTextRange) {
-			var range = element.createTextRange();
-			with (range) {
-				collapse(true);
-				moveEnd("character", end);
-				moveStart("character", start);
-				select();
+		for(var x=0; x<this.data.length; x++){
+			if((!ignoreLimit)&&(ret.length >= this.searchLimit)){
+				break;
 			}
-		} else {
-			element.value = element.value;
-			element.blur();
-			element.focus();
-			var dist = parseInt(element.value.length) - end;
-			var tchar = String.fromCharCode(37);
-			var tcc = tchar.charCodeAt(0);
-			for (var x = 0; x < dist; x++) {
-				var te = document.createEvent("KeyEvents");
-				te.initKeyEvent("keypress", true, true, null, false, false, false, false, tcc, tcc);
-				element.dispatchEvent(te);
+			// FIXME: we should avoid copies if possible!
+			var dataLabel = new String((!this.caseSensitive) ? this.data[x][0].toLowerCase() : this.data[x][0]);
+			if(dataLabel.length < searchStr.length){
+				// this won't ever be a good search, will it? What if we start
+				// to support regex search?
+				continue;
 			}
-		}
-	}
-}, _handleKeyEvents:function (evt) {
-	if (evt.ctrlKey || evt.altKey || !evt.key) {
-		return;
-	}
-	this._prev_key_backspace = false;
-	this._prev_key_esc = false;
-	var k = dojo.event.browser.keys;
-	var doSearch = true;
-	switch (evt.key) {
-	  case k.KEY_DOWN_ARROW:
-		if (!this.popupWidget.isShowingNow) {
-			this._startSearchFromInput();
-		}
-		this._highlightNextOption();
-		dojo.event.browser.stopEvent(evt);
-		return;
-	  case k.KEY_UP_ARROW:
-		this._highlightPrevOption();
-		dojo.event.browser.stopEvent(evt);
-		return;
-	  case k.KEY_TAB:
-		if (!this.autoComplete && this.popupWidget.isShowingNow && this._highlighted_option) {
-			dojo.event.browser.stopEvent(evt);
-			this._selectOption({"target":this._highlighted_option, "noHide":false});
-			this._setSelectedRange(this.textInputNode, this.textInputNode.value.length, null);
-		} else {
-			this._selectOption();
-			return;
-		}
-		break;
-	  case k.KEY_ENTER:
-		if (this.popupWidget.isShowingNow) {
-			dojo.event.browser.stopEvent(evt);
-		}
-		if (this.autoComplete) {
-			this._selectOption();
-			return;
-		}
-	  case " ":
-		if (this.popupWidget.isShowingNow && this._highlighted_option) {
-			dojo.event.browser.stopEvent(evt);
-			this._selectOption();
-			this._hideResultList();
-			return;
-		}
-		break;
-	  case k.KEY_ESCAPE:
-		this._hideResultList();
-		this._prev_key_esc = true;
-		return;
-	  case k.KEY_BACKSPACE:
-		this._prev_key_backspace = true;
-		if (!this.textInputNode.value.length) {
-			this.setAllValues("", "");
-			this._hideResultList();
-			doSearch = false;
-		}
-		break;
-	  case k.KEY_RIGHT_ARROW:
-	  case k.KEY_LEFT_ARROW:
-		doSearch = false;
-		break;
-	  default:
-		if (evt.charCode == 0) {
-			doSearch = false;
-		}
-	}
-	if (this.searchTimer) {
-		clearTimeout(this.searchTimer);
-	}
-	if (doSearch) {
-		this._blurOptionNode();
-		this.searchTimer = setTimeout(dojo.lang.hitch(this, this._startSearchFromInput), this.searchDelay);
-	}
-}, compositionEnd:function (evt) {
-	evt.key = evt.keyCode;
-	this._handleKeyEvents(evt);
-}, onKeyUp:function (evt) {
-	this.setValue(this.textInputNode.value);
-}, setSelectedValue:function (value) {
-	this.comboBoxSelectionValue.value = value;
-}, setAllValues:function (value1, value2) {
-	this.setSelectedValue(value2);
-	this.setValue(value1);
-}, _focusOptionNode:function (node) {
-	if (this._highlighted_option != node) {
-		this._blurOptionNode();
-		this._highlighted_option = node;
-		dojo.html.addClass(this._highlighted_option, "dojoComboBoxItemHighlight");
-	}
-}, _blurOptionNode:function () {
-	if (this._highlighted_option) {
-		dojo.html.removeClass(this._highlighted_option, "dojoComboBoxItemHighlight");
-		this._highlighted_option = null;
-	}
-}, _highlightNextOption:function () {
-	if ((!this._highlighted_option) || !this._highlighted_option.parentNode) {
-		this._focusOptionNode(this.optionsListNode.firstChild);
-	} else {
-		if (this._highlighted_option.nextSibling) {
-			this._focusOptionNode(this._highlighted_option.nextSibling);
-		}
-	}
-	dojo.html.scrollIntoView(this._highlighted_option);
-}, _highlightPrevOption:function () {
-	if (this._highlighted_option && this._highlighted_option.previousSibling) {
-		this._focusOptionNode(this._highlighted_option.previousSibling);
-	} else {
-		this._highlighted_option = null;
-		this._hideResultList();
-		return;
-	}
-	dojo.html.scrollIntoView(this._highlighted_option);
-}, _itemMouseOver:function (evt) {
-	if (evt.target === this.optionsListNode) {
-		return;
-	}
-	this._focusOptionNode(evt.target);
-	dojo.html.addClass(this._highlighted_option, "dojoComboBoxItemHighlight");
-}, _itemMouseOut:function (evt) {
-	if (evt.target === this.optionsListNode) {
-		return;
-	}
-	this._blurOptionNode();
-}, onResize:function () {
-	var inputSize = dojo.html.getContentBox(this.textInputNode);
-	if (inputSize.height <= 0) {
-		dojo.lang.setTimeout(this, "onResize", 100);
-		return;
-	}
-	var buttonSize = {width:inputSize.height, height:inputSize.height};
-	dojo.html.setContentBox(this.downArrowNode, buttonSize);
-}, fillInTemplate:function (args, frag) {
-	dojo.html.applyBrowserClass(this.domNode);
-	var source = this.getFragNodeRef(frag);
-	if (!this.name && source.name) {
-		this.name = source.name;
-	}
-	this.comboBoxValue.name = this.name;
-	this.comboBoxSelectionValue.name = this.name + "_selected";
-	dojo.html.copyStyle(this.domNode, source);
-	dojo.html.copyStyle(this.textInputNode, source);
-	dojo.html.copyStyle(this.downArrowNode, source);
-	with (this.downArrowNode.style) {
-		width = "0px";
-		height = "0px";
-	}
-	var dpClass;
-	if (this.dataProviderClass) {
-		if (typeof this.dataProviderClass == "string") {
-			dpClass = dojo.evalObjPath(this.dataProviderClass);
-		} else {
-			dpClass = this.dataProviderClass;
-		}
-	} else {
-		if (this.mode == "remote") {
-			dpClass = dojo.widget.incrementalComboBoxDataProvider;
-		} else {
-			dpClass = dojo.widget.basicComboBoxDataProvider;
-		}
-	}
-	this.dataProvider = new dpClass(this, this.getFragNodeRef(frag));
-	this.popupWidget = new dojo.widget.createWidget("PopupContainer", {toggle:this.dropdownToggle, toggleDuration:this.toggleDuration});
-	dojo.event.connect(this, "destroy", this.popupWidget, "destroy");
-	this.optionsListNode = this.popupWidget.domNode;
-	this.domNode.appendChild(this.optionsListNode);
-	dojo.html.addClass(this.optionsListNode, "dojoComboBoxOptions");
-	dojo.event.connect(this.optionsListNode, "onclick", this, "_selectOption");
-	dojo.event.connect(this.optionsListNode, "onmouseover", this, "_onMouseOver");
-	dojo.event.connect(this.optionsListNode, "onmouseout", this, "_onMouseOut");
-	dojo.event.connect(this.optionsListNode, "onmouseover", this, "_itemMouseOver");
-	dojo.event.connect(this.optionsListNode, "onmouseout", this, "_itemMouseOut");
-}, _openResultList:function (results) {
-	if (this.disabled) {
-		return;
-	}
-	this._clearResultList();
-	if (!results.length) {
-		this._hideResultList();
-	}
-	if ((this.autoComplete) && (results.length) && (!this._prev_key_backspace) && (this.textInputNode.value.length > 0)) {
-		var cpos = this._getCaretPos(this.textInputNode);
-		if ((cpos + 1) > this.textInputNode.value.length) {
-			this.textInputNode.value += results[0][0].substr(cpos);
-			this._setSelectedRange(this.textInputNode, cpos, this.textInputNode.value.length);
-		}
-	}
-	var even = true;
-	while (results.length) {
-		var tr = results.shift();
-		if (tr) {
-			var td = document.createElement("div");
-			td.appendChild(document.createTextNode(tr[0]));
-			td.setAttribute("resultName", tr[0]);
-			td.setAttribute("resultValue", tr[1]);
-			td.className = "dojoComboBoxItem " + ((even) ? "dojoComboBoxItemEven" : "dojoComboBoxItemOdd");
-			even = (!even);
-			this.optionsListNode.appendChild(td);
-		}
-	}
-	this._showResultList();
-}, _onFocusInput:function () {
-	this._hasFocus = true;
-}, _onBlurInput:function () {
-	this._hasFocus = false;
-	this._handleBlurTimer(true, 500);
-}, _handleBlurTimer:function (clear, millisec) {
-	if (this.blurTimer && (clear || millisec)) {
-		clearTimeout(this.blurTimer);
-	}
-	if (millisec) {
-		this.blurTimer = dojo.lang.setTimeout(this, "_checkBlurred", millisec);
-	}
-}, _onMouseOver:function (evt) {
-	if (!this._mouseover_list) {
-		this._handleBlurTimer(true, 0);
-		this._mouseover_list = true;
-	}
-}, _onMouseOut:function (evt) {
-	var relTarget = evt.relatedTarget;
-	try {
-		if (!relTarget || relTarget.parentNode != this.optionsListNode) {
-			this._mouseover_list = false;
-			this._handleBlurTimer(true, 100);
-			this._tryFocus();
-		}
-	}
-	catch (e) {
-	}
-}, _isInputEqualToResult:function (result) {
-	var input = this.textInputNode.value;
-	if (!this.dataProvider.caseSensitive) {
-		input = input.toLowerCase();
-		result = result.toLowerCase();
-	}
-	return (input == result);
-}, _isValidOption:function () {
-	var tgt = dojo.html.firstElement(this.optionsListNode);
-	var isValidOption = false;
-	while (!isValidOption && tgt) {
-		if (this._isInputEqualToResult(tgt.getAttribute("resultName"))) {
-			isValidOption = true;
-		} else {
-			tgt = dojo.html.nextElement(tgt);
-		}
-	}
-	return isValidOption;
-}, _checkBlurred:function () {
-	if (!this._hasFocus && !this._mouseover_list) {
-		this._hideResultList();
-		if (!this.textInputNode.value.length) {
-			this.setAllValues("", "");
-			return;
-		}
-		var isValidOption = this._isValidOption();
-		if (this.forceValidOption && !isValidOption) {
-			this.setAllValues("", "");
-			return;
-		}
-		if (!isValidOption) {
-			this.setSelectedValue("");
-		}
-	}
-}, _selectOption:function (evt) {
-	var tgt = null;
-	if (!evt) {
-		evt = {target:this._highlighted_option};
-	}
-	if (!dojo.html.isDescendantOf(evt.target, this.optionsListNode)) {
-		if (!this.textInputNode.value.length) {
-			return;
-		}
-		tgt = dojo.html.firstElement(this.optionsListNode);
-		if (!tgt || !this._isInputEqualToResult(tgt.getAttribute("resultName"))) {
-			return;
-		}
-	} else {
-		tgt = evt.target;
-	}
-	while ((tgt.nodeType != 1) || (!tgt.getAttribute("resultName"))) {
-		tgt = tgt.parentNode;
-		if (tgt === dojo.body()) {
-			return false;
-		}
-	}
-	this.selectedResult = [tgt.getAttribute("resultName"), tgt.getAttribute("resultValue")];
-	this.setAllValues(tgt.getAttribute("resultName"), tgt.getAttribute("resultValue"));
-	if (!evt.noHide) {
-		this._hideResultList();
-		this._setSelectedRange(this.textInputNode, 0, null);
-	}
-	this._tryFocus();
-}, _clearResultList:function () {
-	if (this.optionsListNode.innerHTML) {
-		this.optionsListNode.innerHTML = "";
-	}
-}, _hideResultList:function () {
-	this.popupWidget.close();
-}, _showResultList:function () {
-	var childs = this.optionsListNode.childNodes;
-	if (childs.length) {
-		var visibleCount = Math.min(childs.length, this.maxListLength);
-		with (this.optionsListNode.style) {
-			display = "";
-			if (visibleCount == childs.length) {
-				height = "";
-			} else {
-				height = visibleCount * dojo.html.getMarginBox(childs[0]).height + "px";
+
+			if(st == "STARTSTRING"){
+				// jum.debug(dataLabel.substr(0, searchStr.length))
+				// jum.debug(searchStr);
+				if(searchStr == dataLabel.substr(0, searchStr.length)){
+					ret.push(this.data[x]);
+				}
+			}else if(st == "SUBSTRING"){
+				// this one is a gimmie
+				if(dataLabel.indexOf(searchStr) >= 0){
+					ret.push(this.data[x]);
+				}
+			}else if(st == "STARTWORD"){
+				// do a substring search and then attempt to determine if the
+				// preceeding char was the beginning of the string or a
+				// whitespace char.
+				var idx = dataLabel.indexOf(searchStr);
+				if(idx == 0){
+					// implicit match
+					ret.push(this.data[x]);
+				}
+				if(idx <= 0){
+					// if we didn't match or implicily matched, march onward
+					continue;
+				}
+				// otherwise, we have to go figure out if the match was at the
+				// start of a word...
+				// this code is taken almost directy from nWidgets
+				var matches = false;
+				while(idx!=-1){
+					// make sure the match either starts whole string, or
+					// follows a space, or follows some punctuation
+					if(" ,/(".indexOf(dataLabel.charAt(idx-1)) != -1){
+						// FIXME: what about tab chars?
+						matches = true; break;
+					}
+					idx = dataLabel.indexOf(searchStr, idx+1);
+				}
+				if(!matches){
+					continue;
+				}else{
+					ret.push(this.data[x]);
+				}
 			}
-			width = (dojo.html.getMarginBox(this.domNode).width - 2) + "px";
 		}
-		this.popupWidget.open(this.domNode, this, this.downArrowNode);
-	} else {
-		this._hideResultList();
+		this.provideSearchResults(ret);
 	}
-}, handleArrowClick:function () {
-	this._handleBlurTimer(true, 0);
-	this._tryFocus();
-	if (this.popupWidget.isShowingNow) {
-		this._hideResultList();
-	} else {
-		this._startSearch("");
+
+	this.provideSearchResults = function(resultsDataPairs){
 	}
-}, _tryFocus:function () {
-	try {
-		this.textInputNode.focus();
+
+	this.addData = function(pairs){
+		// FIXME: incredibly naive and slow!
+		this.data = this.data.concat(pairs);
 	}
-	catch (e) {
+
+	this.setData = function(pdata){
+		// populate this.data and initialize lookup structures
+		this.data = pdata;
 	}
-}, _startSearchFromInput:function () {
-	this._startSearch(this.textInputNode.value);
-}, _startSearch:function (key) {
-	this.dataProvider.startSearch(key, dojo.lang.hitch(this, "_openResultList"));
-}, postCreate:function () {
-	this.onResize();
-	dojo.event.connect(this.textInputNode, "onblur", this, "_onBlurInput");
-	dojo.event.connect(this.textInputNode, "onfocus", this, "_onFocusInput");
-	if (this.disabled) {
-		this.disable();
+	
+	if(dataPairs){
+		this.setData(dataPairs);
 	}
-	var s = dojo.widget.html.stabile.getState(this.widgetId);
-	if (s) {
-		this.setState(s);
+}
+
+dojo.declare(
+	"dojo.widget.ComboBox",
+	null,
+	{
+		widgetType: "ComboBox",
+		isContainer: false,
+	
+		forceValidOption: false,
+		searchType: "stringstart",
+		dataProvider: null,
+	
+		startSearch: function(searchString){},
+		openResultList: function(results){},
+		clearResultList: function(){},
+		hideResultList: function(){},
+		selectNextResult: function(){},
+		selectPrevResult: function(){},
+		setSelectedResult: function(){}
 	}
-}});
+);
 
+// render-specific includes
+dojo.requireAfterIf("html", "dojo.widget.html.ComboBox");
+

Modified: tags/parley-0.53/root/static/magic/src/widget/ContentPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ContentPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ContentPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,434 +8,9 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+// This widget doesn't do anything; is basically the same as <div>.
+// It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
+// But note that those classes can contain any widget as a child.
 
-
 dojo.provide("dojo.widget.ContentPane");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.string");
-dojo.require("dojo.string.extras");
-dojo.require("dojo.html.style");
-dojo.widget.defineWidget("dojo.widget.ContentPane", dojo.widget.HtmlWidget, function () {
-	this._styleNodes = [];
-	this._onLoadStack = [];
-	this._onUnloadStack = [];
-	this._callOnUnload = false;
-	this._ioBindObj;
-	this.scriptScope;
-	this.bindArgs = {};
-}, {isContainer:true, adjustPaths:true, href:"", extractContent:true, parseContent:true, cacheContent:true, preload:false, refreshOnShow:false, handler:"", executeScripts:false, scriptSeparation:true, loadingMessage:"Loading...", isLoaded:false, postCreate:function (args, frag, parentComp) {
-	if (this.handler !== "") {
-		this.setHandler(this.handler);
-	}
-	if (this.isShowing() || this.preload) {
-		this.loadContents();
-	}
-}, show:function () {
-	if (this.refreshOnShow) {
-		this.refresh();
-	} else {
-		this.loadContents();
-	}
-	dojo.widget.ContentPane.superclass.show.call(this);
-}, refresh:function () {
-	this.isLoaded = false;
-	this.loadContents();
-}, loadContents:function () {
-	if (this.isLoaded) {
-		return;
-	}
-	if (dojo.lang.isFunction(this.handler)) {
-		this._runHandler();
-	} else {
-		if (this.href != "") {
-			this._downloadExternalContent(this.href, this.cacheContent && !this.refreshOnShow);
-		}
-	}
-}, setUrl:function (url) {
-	this.href = url;
-	this.isLoaded = false;
-	if (this.preload || this.isShowing()) {
-		this.loadContents();
-	}
-}, abort:function () {
-	var bind = this._ioBindObj;
-	if (!bind || !bind.abort) {
-		return;
-	}
-	bind.abort();
-	delete this._ioBindObj;
-}, _downloadExternalContent:function (url, useCache) {
-	this.abort();
-	this._handleDefaults(this.loadingMessage, "onDownloadStart");
-	var self = this;
-	this._ioBindObj = dojo.io.bind(this._cacheSetting({url:url, mimetype:"text/html", handler:function (type, data, xhr) {
-		delete self._ioBindObj;
-		if (type == "load") {
-			self.onDownloadEnd.call(self, url, data);
-		} else {
-			var e = {responseText:xhr.responseText, status:xhr.status, statusText:xhr.statusText, responseHeaders:xhr.getAllResponseHeaders(), text:"Error loading '" + url + "' (" + xhr.status + " " + xhr.statusText + ")"};
-			self._handleDefaults.call(self, e, "onDownloadError");
-			self.onLoad();
-		}
-	}}, useCache));
-}, _cacheSetting:function (bindObj, useCache) {
-	for (var x in this.bindArgs) {
-		if (dojo.lang.isUndefined(bindObj[x])) {
-			bindObj[x] = this.bindArgs[x];
-		}
-	}
-	if (dojo.lang.isUndefined(bindObj.useCache)) {
-		bindObj.useCache = useCache;
-	}
-	if (dojo.lang.isUndefined(bindObj.preventCache)) {
-		bindObj.preventCache = !useCache;
-	}
-	if (dojo.lang.isUndefined(bindObj.mimetype)) {
-		bindObj.mimetype = "text/html";
-	}
-	return bindObj;
-}, onLoad:function (e) {
-	this._runStack("_onLoadStack");
-	this.isLoaded = true;
-}, onUnLoad:function (e) {
-	dojo.deprecated(this.widgetType + ".onUnLoad, use .onUnload (lowercased load)", 0.5);
-}, onUnload:function (e) {
-	this._runStack("_onUnloadStack");
-	delete this.scriptScope;
-	if (this.onUnLoad !== dojo.widget.ContentPane.prototype.onUnLoad) {
-		this.onUnLoad.apply(this, arguments);
-	}
-}, _runStack:function (stName) {
-	var st = this[stName];
-	var err = "";
-	var scope = this.scriptScope || window;
-	for (var i = 0; i < st.length; i++) {
-		try {
-			st[i].call(scope);
-		}
-		catch (e) {
-			err += "\n" + st[i] + " failed: " + e.description;
-		}
-	}
-	this[stName] = [];
-	if (err.length) {
-		var name = (stName == "_onLoadStack") ? "addOnLoad" : "addOnUnLoad";
-		this._handleDefaults(name + " failure\n " + err, "onExecError", "debug");
-	}
-}, addOnLoad:function (obj, func) {
-	this._pushOnStack(this._onLoadStack, obj, func);
-}, addOnUnload:function (obj, func) {
-	this._pushOnStack(this._onUnloadStack, obj, func);
-}, addOnUnLoad:function () {
-	dojo.deprecated(this.widgetType + ".addOnUnLoad, use addOnUnload instead. (lowercased Load)", 0.5);
-	this.addOnUnload.apply(this, arguments);
-}, _pushOnStack:function (stack, obj, func) {
-	if (typeof func == "undefined") {
-		stack.push(obj);
-	} else {
-		stack.push(function () {
-			obj[func]();
-		});
-	}
-}, destroy:function () {
-	this.onUnload();
-	dojo.widget.ContentPane.superclass.destroy.call(this);
-}, onExecError:function (e) {
-}, onContentError:function (e) {
-}, onDownloadError:function (e) {
-}, onDownloadStart:function (e) {
-}, onDownloadEnd:function (url, data) {
-	data = this.splitAndFixPaths(data, url);
-	this.setContent(data);
-}, _handleDefaults:function (e, handler, messType) {
-	if (!handler) {
-		handler = "onContentError";
-	}
-	if (dojo.lang.isString(e)) {
-		e = {text:e};
-	}
-	if (!e.text) {
-		e.text = e.toString();
-	}
-	e.toString = function () {
-		return this.text;
-	};
-	if (typeof e.returnValue != "boolean") {
-		e.returnValue = true;
-	}
-	if (typeof e.preventDefault != "function") {
-		e.preventDefault = function () {
-			this.returnValue = false;
-		};
-	}
-	this[handler](e);
-	if (e.returnValue) {
-		switch (messType) {
-		  case true:
-		  case "alert":
-			alert(e.toString());
-			break;
-		  case "debug":
-			dojo.debug(e.toString());
-			break;
-		  default:
-			if (this._callOnUnload) {
-				this.onUnload();
-			}
-			this._callOnUnload = false;
-			if (arguments.callee._loopStop) {
-				dojo.debug(e.toString());
-			} else {
-				arguments.callee._loopStop = true;
-				this._setContent(e.toString());
-			}
-		}
-	}
-	arguments.callee._loopStop = false;
-}, splitAndFixPaths:function (s, url) {
-	var titles = [], scripts = [], tmp = [];
-	var match = [], requires = [], attr = [], styles = [];
-	var str = "", path = "", fix = "", tagFix = "", tag = "", origPath = "";
-	if (!url) {
-		url = "./";
-	}
-	if (s) {
-		var regex = /<title[^>]*>([\s\S]*?)<\/title>/i;
-		while (match = regex.exec(s)) {
-			titles.push(match[1]);
-			s = s.substring(0, match.index) + s.substr(match.index + match[0].length);
-		}
-		if (this.adjustPaths) {
-			var regexFindTag = /<[a-z][a-z0-9]*[^>]*\s(?:(?:src|href|style)=[^>])+[^>]*>/i;
-			var regexFindAttr = /\s(src|href|style)=(['"]?)([\w()\[\]\/.,\\'"-:;#=&?\s@]+?)\2/i;
-			var regexProtocols = /^(?:[#]|(?:(?:https?|ftps?|file|javascript|mailto|news):))/;
-			while (tag = regexFindTag.exec(s)) {
-				str += s.substring(0, tag.index);
-				s = s.substring((tag.index + tag[0].length), s.length);
-				tag = tag[0];
-				tagFix = "";
-				while (attr = regexFindAttr.exec(tag)) {
-					path = "";
-					origPath = attr[3];
-					switch (attr[1].toLowerCase()) {
-					  case "src":
-					  case "href":
-						if (regexProtocols.exec(origPath)) {
-							path = origPath;
-						} else {
-							path = (new dojo.uri.Uri(url, origPath).toString());
-						}
-						break;
-					  case "style":
-						path = dojo.html.fixPathsInCssText(origPath, url);
-						break;
-					  default:
-						path = origPath;
-					}
-					fix = " " + attr[1] + "=" + attr[2] + path + attr[2];
-					tagFix += tag.substring(0, attr.index) + fix;
-					tag = tag.substring((attr.index + attr[0].length), tag.length);
-				}
-				str += tagFix + tag;
-			}
-			s = str + s;
-		}
-		regex = /(?:<(style)[^>]*>([\s\S]*?)<\/style>|<link ([^>]*rel=['"]?stylesheet['"]?[^>]*)>)/i;
-		while (match = regex.exec(s)) {
-			if (match[1] && match[1].toLowerCase() == "style") {
-				styles.push(dojo.html.fixPathsInCssText(match[2], url));
-			} else {
-				if (attr = match[3].match(/href=(['"]?)([^'">]*)\1/i)) {
-					styles.push({path:attr[2]});
-				}
-			}
-			s = s.substring(0, match.index) + s.substr(match.index + match[0].length);
-		}
-		var regex = /<script([^>]*)>([\s\S]*?)<\/script>/i;
-		var regexSrc = /src=(['"]?)([^"']*)\1/i;
-		var regexDojoJs = /.*(\bdojo\b\.js(?:\.uncompressed\.js)?)$/;
-		var regexInvalid = /(?:var )?\bdjConfig\b(?:[\s]*=[\s]*\{[^}]+\}|\.[\w]*[\s]*=[\s]*[^;\n]*)?;?|dojo\.hostenv\.writeIncludes\(\s*\);?/g;
-		var regexRequires = /dojo\.(?:(?:require(?:After)?(?:If)?)|(?:widget\.(?:manager\.)?registerWidgetPackage)|(?:(?:hostenv\.)?setModulePrefix|registerModulePath)|defineNamespace)\((['"]).*?\1\)\s*;?/;
-		while (match = regex.exec(s)) {
-			if (this.executeScripts && match[1]) {
-				if (attr = regexSrc.exec(match[1])) {
-					if (regexDojoJs.exec(attr[2])) {
-						dojo.debug("Security note! inhibit:" + attr[2] + " from  being loaded again.");
-					} else {
-						scripts.push({path:attr[2]});
-					}
-				}
-			}
-			if (match[2]) {
-				var sc = match[2].replace(regexInvalid, "");
-				if (!sc) {
-					continue;
-				}
-				while (tmp = regexRequires.exec(sc)) {
-					requires.push(tmp[0]);
-					sc = sc.substring(0, tmp.index) + sc.substr(tmp.index + tmp[0].length);
-				}
-				if (this.executeScripts) {
-					scripts.push(sc);
-				}
-			}
-			s = s.substr(0, match.index) + s.substr(match.index + match[0].length);
-		}
-		if (this.extractContent) {
-			match = s.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
-			if (match) {
-				s = match[1];
-			}
-		}
-		if (this.executeScripts && this.scriptSeparation) {
-			var regex = /(<[a-zA-Z][a-zA-Z0-9]*\s[^>]*?\S=)((['"])[^>]*scriptScope[^>]*>)/;
-			var regexAttr = /([\s'";:\(])scriptScope(.*)/;
-			str = "";
-			while (tag = regex.exec(s)) {
-				tmp = ((tag[3] == "'") ? "\"" : "'");
-				fix = "";
-				str += s.substring(0, tag.index) + tag[1];
-				while (attr = regexAttr.exec(tag[2])) {
-					tag[2] = tag[2].substring(0, attr.index) + attr[1] + "dojo.widget.byId(" + tmp + this.widgetId + tmp + ").scriptScope" + attr[2];
-				}
-				str += tag[2];
-				s = s.substr(tag.index + tag[0].length);
-			}
-			s = str + s;
-		}
-	}
-	return {"xml":s, "styles":styles, "titles":titles, "requires":requires, "scripts":scripts, "url":url};
-}, _setContent:function (cont) {
-	this.destroyChildren();
-	for (var i = 0; i < this._styleNodes.length; i++) {
-		if (this._styleNodes[i] && this._styleNodes[i].parentNode) {
-			this._styleNodes[i].parentNode.removeChild(this._styleNodes[i]);
-		}
-	}
-	this._styleNodes = [];
-	try {
-		var node = this.containerNode || this.domNode;
-		while (node.firstChild) {
-			dojo.html.destroyNode(node.firstChild);
-		}
-		if (typeof cont != "string") {
-			node.appendChild(cont);
-		} else {
-			node.innerHTML = cont;
-		}
-	}
-	catch (e) {
-		e.text = "Couldn't load content:" + e.description;
-		this._handleDefaults(e, "onContentError");
-	}
-}, setContent:function (data) {
-	this.abort();
-	if (this._callOnUnload) {
-		this.onUnload();
-	}
-	this._callOnUnload = true;
-	if (!data || dojo.html.isNode(data)) {
-		this._setContent(data);
-		this.onResized();
-		this.onLoad();
-	} else {
-		if (typeof data.xml != "string") {
-			this.href = "";
-			data = this.splitAndFixPaths(data);
-		}
-		this._setContent(data.xml);
-		for (var i = 0; i < data.styles.length; i++) {
-			if (data.styles[i].path) {
-				this._styleNodes.push(dojo.html.insertCssFile(data.styles[i].path, dojo.doc(), false, true));
-			} else {
-				this._styleNodes.push(dojo.html.insertCssText(data.styles[i]));
-			}
-		}
-		if (this.parseContent) {
-			for (var i = 0; i < data.requires.length; i++) {
-				try {
-					eval(data.requires[i]);
-				}
-				catch (e) {
-					e.text = "ContentPane: error in package loading calls, " + (e.description || e);
-					this._handleDefaults(e, "onContentError", "debug");
-				}
-			}
-		}
-		var _self = this;
-		function asyncParse() {
-			if (_self.executeScripts) {
-				_self._executeScripts(data.scripts);
-			}
-			if (_self.parseContent) {
-				var node = _self.containerNode || _self.domNode;
-				var parser = new dojo.xml.Parse();
-				var frag = parser.parseElement(node, null, true);
-				dojo.widget.getParser().createSubComponents(frag, _self);
-			}
-			_self.onResized();
-			_self.onLoad();
-		}
-		if (dojo.hostenv.isXDomain && data.requires.length) {
-			dojo.addOnLoad(asyncParse);
-		} else {
-			asyncParse();
-		}
-	}
-}, setHandler:function (handler) {
-	var fcn = dojo.lang.isFunction(handler) ? handler : window[handler];
-	if (!dojo.lang.isFunction(fcn)) {
-		this._handleDefaults("Unable to set handler, '" + handler + "' not a function.", "onExecError", true);
-		return;
-	}
-	this.handler = function () {
-		return fcn.apply(this, arguments);
-	};
-}, _runHandler:function () {
-	var ret = true;
-	if (dojo.lang.isFunction(this.handler)) {
-		this.handler(this, this.domNode);
-		ret = false;
-	}
-	this.onLoad();
-	return ret;
-}, _executeScripts:function (scripts) {
-	var self = this;
-	var tmp = "", code = "";
-	for (var i = 0; i < scripts.length; i++) {
-		if (scripts[i].path) {
-			dojo.io.bind(this._cacheSetting({"url":scripts[i].path, "load":function (type, scriptStr) {
-				dojo.lang.hitch(self, tmp = ";" + scriptStr);
-			}, "error":function (type, error) {
-				error.text = type + " downloading remote script";
-				self._handleDefaults.call(self, error, "onExecError", "debug");
-			}, "mimetype":"text/plain", "sync":true}, this.cacheContent));
-			code += tmp;
-		} else {
-			code += scripts[i];
-		}
-	}
-	try {
-		if (this.scriptSeparation) {
-			delete this.scriptScope;
-			this.scriptScope = new (new Function("_container_", code + "; return this;"))(self);
-		} else {
-			var djg = dojo.global();
-			if (djg.execScript) {
-				djg.execScript(code);
-			} else {
-				var djd = dojo.doc();
-				var sc = djd.createElement("script");
-				sc.appendChild(djd.createTextNode(code));
-				(this.containerNode || this.domNode).appendChild(sc);
-			}
-		}
-	}
-	catch (e) {
-		e.text = "Error running scripts from content:\n" + e.description;
-		this._handleDefaults(e, "onExecError", "debug");
-	}
-}});
-
+dojo.requireAfterIf("html", "dojo.widget.html.ContentPane");

Added: tags/parley-0.53/root/static/magic/src/widget/ContextMenu.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ContextMenu.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ContextMenu.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,33 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.ContextMenu");
+
+dojo.deprecated("dojo.widget.ContextMenu",  "use dojo.widget.Menu2", "0.4");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.DomWidget");
+
+dojo.widget.ContextMenu = function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = "ContextMenu";
+	this.isContainer = true;
+	this.isOpened = false;
+	
+	// copy children widgets output directly to parent (this node), to avoid
+	// errors trying to insert an <li> under a <div>
+	this.snarfChildDomOutput = true;
+
+}
+
+dojo.inherits(dojo.widget.ContextMenu, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler("dojo:contextmenu");
+
+dojo.requireAfterIf("html", "dojo.widget.html.ContextMenu");

Deleted: tags/parley-0.53/root/static/magic/src/widget/CurrencyTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/CurrencyTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/CurrencyTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,40 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.CurrencyTextbox");
-dojo.require("dojo.widget.IntegerTextbox");
-dojo.require("dojo.validate.common");
-dojo.widget.defineWidget("dojo.widget.CurrencyTextbox", dojo.widget.IntegerTextbox, {mixInProperties:function (localProperties, frag) {
-	dojo.widget.CurrencyTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.fractional) {
-		this.flags.fractional = (localProperties.fractional == "true");
-	} else {
-		if (localProperties.cents) {
-			dojo.deprecated("dojo.widget.IntegerTextbox", "use fractional attr instead of cents", "0.5");
-			this.flags.fractional = (localProperties.cents == "true");
-		}
-	}
-	if (localProperties.symbol) {
-		this.flags.symbol = localProperties.symbol;
-	}
-	if (localProperties.min) {
-		this.flags.min = parseFloat(localProperties.min);
-	}
-	if (localProperties.max) {
-		this.flags.max = parseFloat(localProperties.max);
-	}
-}, isValid:function () {
-	return dojo.validate.isCurrency(this.textbox.value, this.flags);
-}, isInRange:function () {
-	return dojo.validate.isInRange(this.textbox.value, this.flags);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/DatePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DatePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DatePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,342 +8,54 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.DatePicker");
+dojo.provide("dojo.widget.DatePicker.util");
+dojo.require("dojo.widget.DomWidget");
+dojo.require("dojo.date");
 
+// NOTE: this function is only used as mixin (never as a constructor)
+dojo.widget.DatePicker = function() {
+	// the following aliases prevent breaking people using 0.2.x
+	this.months = dojo.date.months,
+	this.weekdays = dojo.date.days,
+	this.toRfcDate = dojo.widget.DatePicker.util.toRfcDate,
+	this.fromRfcDate = dojo.widget.DatePicker.util.fromRfcDate,
+	this.initFirstSaturday = dojo.widget.DatePicker.util.initFirstSaturday
+};
 
-dojo.provide("dojo.widget.DatePicker");
-dojo.require("dojo.date.common");
-dojo.require("dojo.date.format");
-dojo.require("dojo.date.serialize");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.event.*");
-dojo.require("dojo.dom");
-dojo.require("dojo.html.style");
-dojo.widget.defineWidget("dojo.widget.DatePicker", dojo.widget.HtmlWidget, {value:"", name:"", displayWeeks:6, adjustWeeks:false, startDate:"1492-10-12", endDate:"2941-10-12", weekStartsOn:"", staticDisplay:false, dayWidth:"narrow", classNames:{previous:"previousMonth", disabledPrevious:"previousMonthDisabled", current:"currentMonth", disabledCurrent:"currentMonthDisabled", next:"nextMonth", disabledNext:"nextMonthDisabled", currentDate:"currentDate", selectedDate:"selectedDate"}, templateString:"<div class=\"datePickerContainer\" dojoAttachPoint=\"datePickerContainerNode\">\n\t<table cellspacing=\"0\" cellpadding=\"0\" class=\"calendarContainer\">\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<td class=\"monthWrapper\" valign=\"top\">\n\t\t\t\t\t<table class=\"monthContainer\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"monthCurve monthCurveTL\" valign=\"top\"></td>\n\t\t\t\t\t\t\t<td class=\"monthLabelContainer\" valign=\"top\">\n\t\!
 t\t\t\t\t\t\t<span dojoAttachPoint=\"increaseWeekNode\" \n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onIncrementWeek;\" \n\t\t\t\t\t\t\t\t\tclass=\"incrementControl increase\">\n\t\t\t\t\t\t\t\t\t<img src=\"${dojoWidgetModuleUri}templates/images/incrementMonth.png\" \n\t\t\t\t\t\t\t\t\talt=\"&darr;\" style=\"width:7px;height:5px;\" />\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<span \n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"increaseMonthNode\" \n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onIncrementMonth;\" class=\"incrementControl increase\">\n\t\t\t\t\t\t\t\t\t<img src=\"${dojoWidgetModuleUri}templates/images/incrementMonth.png\" \n\t\t\t\t\t\t\t\t\t\talt=\"&darr;\"  dojoAttachPoint=\"incrementMonthImageNode\">\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<span \n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"decreaseWeekNode\" \n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onIncrementWeek;\" \n\t\t\t\t\t\t\t\t\tclass=\"incrementControl decrease\">\n\t\t\t\t\t\t\t\t\t<img src=\"${dojoWi!
 dgetModuleUri}templates/images/decrementMonth.png\" alt=\"&uar!
 r;\" sty
le=\"width:7px;height:5px;\" />\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<span \n\t\t\t\t\t\t\t\t\tdojoAttachPoint=\"decreaseMonthNode\" \n\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onIncrementMonth;\" class=\"incrementControl decrease\">\n\t\t\t\t\t\t\t\t\t<img src=\"${dojoWidgetModuleUri}templates/images/decrementMonth.png\" \n\t\t\t\t\t\t\t\t\t\talt=\"&uarr;\" dojoAttachPoint=\"decrementMonthImageNode\">\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t<span dojoAttachPoint=\"monthLabelNode\" class=\"month\"></span>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td class=\"monthCurve monthCurveTR\" valign=\"top\"></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t<table class=\"calendarBodyContainer\" cellspacing=\"0\" cellpadding=\"0\" border=\"0\">\n\t\t\t\t\t\t<thead>\n\t\t\t\t\t\t\t<tr dojoAttachPoint=\"dayLabelsRow\">\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t!
 \t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</thead>\n\t\t\t\t\t\t<tbody dojoAttachPoint=\"calendarDatesContainerNode\" \n\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: _handleUiClick;\">\n\t\t\t\t\t\t\t<tr dojoAttachPoint=\"calendarWeekTemplate\">\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t\t<td></td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t\t<tfoot>\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"3\" class=\"yearWrapper\">\n\t\t\t\t\t<table cellspacing=\"0\" cellpadding=\"0\" border=\"0\" class=\"yearContainer\">\n\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t<td class=\"curveBL\" valign=\"top\"></td>\n\t\t\t\t\t\t\t<td valign=\"top\">\n\t\t\t\t\t\t\t\t<h3 class=\"yearLabel\">\n\t\t\t\t\t\t\t\t!
 \t<span dojoAttachPoint=\"previousYearLabelNode\"\n\t\t\t\t\t\!
 t\t\t\t\
tdojoAttachEvent=\"onClick: onIncrementYear;\" class=\"previousYear\"></span>\n\t\t\t\t\t\t\t\t\t<span class=\"selectedYear\" dojoAttachPoint=\"currentYearLabelNode\"></span>\n\t\t\t\t\t\t\t\t\t<span dojoAttachPoint=\"nextYearLabelNode\" \n\t\t\t\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onIncrementYear;\" class=\"nextYear\"></span>\n\t\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t<td class=\"curveBR\" valign=\"top\"></td>\n\t\t\t\t\t\t</tr>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tfoot>\n\t</table>\n</div>\n", templateCssString:".datePickerContainer {\n\twidth:164px; /* needed for proper user styling */\n}\n\n.calendarContainer {\n/*\tborder:1px solid #566f8f;*/\n}\n\n.calendarBodyContainer {\n\twidth:100%; /* needed for the explode effect (explain?) */\n\tbackground: #7591bc url(\"images/dpBg.gif\") top left repeat-x;\n}\n\n.calendarBodyContainer thead tr td {\n\tcolor:#293a4b;\n\tfont:bold 0.75em Helvetica, Arial, Verdana, sans-serif;\n\ttext-align:!
 center;\n\tpadding:0.25em;\n\tbackground: url(\"images/dpHorizLine.gif\") bottom left repeat-x;\n}\n\n.calendarBodyContainer tbody tr td {\n\tcolor:#fff;\n\tfont:bold 0.7em Helvetica, Arial, Verdana, sans-serif;\n\ttext-align:center;\n\tpadding:0.4em;\n\tbackground: url(\"images/dpVertLine.gif\") top right repeat-y;\n\tcursor:pointer;\n\tcursor:hand;\n}\n\n\n.monthWrapper {\n\tpadding-bottom:2px;\n\tbackground: url(\"images/dpHorizLine.gif\") bottom left repeat-x;\n}\n\n.monthContainer {\n\twidth:100%;\n}\n\n.monthLabelContainer {\n\ttext-align:center;\n\tfont:bold 0.75em Helvetica, Arial, Verdana, sans-serif;\n\tbackground: url(\"images/dpMonthBg.png\") repeat-x top left !important;\n\tcolor:#293a4b;\n\tpadding:0.25em;\n}\n\n.monthCurve {\n\twidth:12px;\n}\n\n.monthCurveTL {\n\tbackground: url(\"images/dpCurveTL.png\") no-repeat top left !important;\n}\n\n.monthCurveTR {\n\t\tbackground: url(\"images/dpCurveTR.png\") no-repeat top right !important;\n}\n\n\n.yearWrapper {\n!
 \tbackground: url(\"images/dpHorizLineFoot.gif\") top left rep!
 eat-x;\n
\tpadding-top:2px;\n}\n\n.yearContainer {\n\twidth:100%;\n}\n\n.yearContainer td {\n\tbackground:url(\"images/dpYearBg.png\") top left repeat-x;\n}\n\n.yearContainer .yearLabel {\n\tmargin:0;\n\tpadding:0.45em 0 0.45em 0;\n\tcolor:#fff;\n\tfont:bold 0.75em Helvetica, Arial, Verdana, sans-serif;\n\ttext-align:center;\n}\n\n.curveBL {\n\tbackground: url(\"images/dpCurveBL.png\") bottom left no-repeat !important;\n\twidth:9px !important;\n\tpadding:0;\n\tmargin:0;\n}\n\n.curveBR {\n\tbackground: url(\"images/dpCurveBR.png\") bottom right no-repeat !important;\n\twidth:9px !important;\n\tpadding:0;\n\tmargin:0;\n}\n\n\n.previousMonth {\n\tbackground-color:#6782a8 !important;\n}\n\n.previousMonthDisabled {\n\tbackground-color:#a4a5a6 !important;\n\tcursor:default !important\n}\n.currentMonth {\n}\n\n.currentMonthDisabled {\n\tbackground-color:#bbbbbc !important;\n\tcursor:default !important\n}\n.nextMonth {\n\tbackground-color:#6782a8 !important;\n}\n.nextMonthDisabled {\n\tbackg!
 round-color:#a4a5a6 !important;\n\tcursor:default !important;\n}\n\n.currentDate {\n\ttext-decoration:underline;\n\tfont-style:italic;\n}\n\n.selectedDate {\n\tbackground-color:#fff !important;\n\tcolor:#6782a8 !important;\n}\n\n.yearLabel .selectedYear {\n\tpadding:0.2em;\n\tbackground-color:#9ec3fb !important;\n}\n\n.nextYear, .previousYear {\n\tcursor:pointer;cursor:hand;\n\tpadding:0;\n}\n\n.nextYear {\n\tmargin:0 0 0 0.55em;\n}\n\n.previousYear {\n\tmargin:0 0.55em 0 0;\n}\n\n.incrementControl {\n\tcursor:pointer;cursor:hand;\n\twidth:1em;\n}\n\n.increase {\n\tfloat:right;\n}\n\n.decrease {\n\tfloat:left;\n}\n\n.lastColumn {\n\tbackground-image:none !important;\n}\n\n\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/DatePicker.css"), postMixInProperties:function () {
-	dojo.widget.DatePicker.superclass.postMixInProperties.apply(this, arguments);
-	if (!this.weekStartsOn) {
-		this.weekStartsOn = dojo.date.getFirstDayOfWeek(this.lang);
-	}
-	this.today = new Date();
-	this.today.setHours(0, 0, 0, 0);
-	if (typeof (this.value) == "string" && this.value.toLowerCase() == "today") {
-		this.value = new Date();
-	} else {
-		if (this.value && (typeof this.value == "string") && (this.value.split("-").length > 2)) {
-			this.value = dojo.date.fromRfc3339(this.value);
-			this.value.setHours(0, 0, 0, 0);
+dojo.requireAfterIf("html", "dojo.widget.html.DatePicker");
+
+dojo.widget.DatePicker.util = new function() {
+	this.months = dojo.date.months;
+	this.weekdays = dojo.date.days;
+	
+	this.toRfcDate = function(jsDate) {
+		if(!jsDate) {
+			var jsDate = new Date();
 		}
+		// because this is a date picker and not a time picker, we don't return a time
+		return dojo.date.format(jsDate, "%Y-%m-%d");
 	}
-}, fillInTemplate:function (args, frag) {
-	dojo.widget.DatePicker.superclass.fillInTemplate.apply(this, arguments);
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-	this.weekTemplate = dojo.dom.removeNode(this.calendarWeekTemplate);
-	this._preInitUI(this.value ? this.value : this.today, false, true);
-	var dayLabels = dojo.lang.unnest(dojo.date.getNames("days", this.dayWidth, "standAlone", this.lang));
-	if (this.weekStartsOn > 0) {
-		for (var i = 0; i < this.weekStartsOn; i++) {
-			dayLabels.push(dayLabels.shift());
+	
+	this.fromRfcDate = function(rfcDate) {
+		// backwards compatible support for use of "any" instead of just not 
+		// including the time
+		if(rfcDate.indexOf("Tany")!=-1) {
+			rfcDate = rfcDate.replace("Tany","");
 		}
+		var jsDate = new Date();
+		dojo.date.setIso8601(jsDate, rfcDate);
+		return jsDate;
 	}
-	var dayLabelNodes = this.dayLabelsRow.getElementsByTagName("td");
-	for (i = 0; i < 7; i++) {
-		dayLabelNodes.item(i).innerHTML = dayLabels[i];
-	}
-	if (this.value) {
-		this.setValue(this.value);
-	}
-}, getValue:function () {
-	return dojo.date.toRfc3339(new Date(this.value), "dateOnly");
-}, getDate:function () {
-	return this.value;
-}, setValue:function (rfcDate) {
-	this.setDate(rfcDate);
-}, setDate:function (dateObj) {
-	if (dateObj == "") {
-		this.value = "";
-		this._preInitUI(this.curMonth, false, true);
-	} else {
-		if (typeof dateObj == "string") {
-			this.value = dojo.date.fromRfc3339(dateObj);
-			this.value.setHours(0, 0, 0, 0);
-		} else {
-			this.value = new Date(dateObj);
-			this.value.setHours(0, 0, 0, 0);
+	
+	this.initFirstSaturday = function(month, year) {
+		if(!month) {
+			month = this.date.getMonth();
 		}
-	}
-	if (this.selectedNode != null) {
-		dojo.html.removeClass(this.selectedNode, this.classNames.selectedDate);
-	}
-	if (this.clickedNode != null) {
-		dojo.debug("adding selectedDate");
-		dojo.html.addClass(this.clickedNode, this.classNames.selectedDate);
-		this.selectedNode = this.clickedNode;
-	} else {
-		this._preInitUI(this.value, false, true);
-	}
-	this.clickedNode = null;
-	this.onValueChanged(this.value);
-}, _preInitUI:function (dateObj, initFirst, initUI) {
-	if (typeof (this.startDate) == "string") {
-		this.startDate = dojo.date.fromRfc3339(this.startDate);
-	}
-	if (typeof (this.endDate) == "string") {
-		this.endDate = dojo.date.fromRfc3339(this.endDate);
-	}
-	this.startDate.setHours(0, 0, 0, 0);
-	this.endDate.setHours(24, 0, 0, -1);
-	if (dateObj < this.startDate || dateObj > this.endDate) {
-		dateObj = new Date((dateObj < this.startDate) ? this.startDate : this.endDate);
-	}
-	this.firstDay = this._initFirstDay(dateObj, initFirst);
-	this.selectedIsUsed = false;
-	this.currentIsUsed = false;
-	var nextDate = new Date(this.firstDay);
-	var tmpMonth = nextDate.getMonth();
-	this.curMonth = new Date(nextDate);
-	this.curMonth.setDate(nextDate.getDate() + 6);
-	this.curMonth.setDate(1);
-	if (this.displayWeeks == "" || this.adjustWeeks) {
-		this.adjustWeeks = true;
-		this.displayWeeks = Math.ceil((dojo.date.getDaysInMonth(this.curMonth) + this._getAdjustedDay(this.curMonth)) / 7);
-	}
-	var days = this.displayWeeks * 7;
-	if (dojo.date.diff(this.startDate, this.endDate, dojo.date.dateParts.DAY) < days) {
-		this.staticDisplay = true;
-		if (dojo.date.diff(nextDate, this.endDate, dojo.date.dateParts.DAY) > days) {
-			this._preInitUI(this.startDate, true, false);
-			nextDate = new Date(this.firstDay);
+		if(!year) {
+			year = this.date.getFullYear();
 		}
-		this.curMonth = new Date(nextDate);
-		this.curMonth.setDate(nextDate.getDate() + 6);
-		this.curMonth.setDate(1);
-		var curClass = (nextDate.getMonth() == this.curMonth.getMonth()) ? "current" : "previous";
+		var firstOfMonth = new Date(year, month, 1);
+		return {year: year, month: month, date: 7 - firstOfMonth.getDay()};
 	}
-	if (initUI) {
-		this._initUI(days);
-	}
-}, _initUI:function (days) {
-	dojo.dom.removeChildren(this.calendarDatesContainerNode);
-	for (var i = 0; i < this.displayWeeks; i++) {
-		this.calendarDatesContainerNode.appendChild(this.weekTemplate.cloneNode(true));
-	}
-	var nextDate = new Date(this.firstDay);
-	this._setMonthLabel(this.curMonth.getMonth());
-	this._setYearLabels(this.curMonth.getFullYear());
-	var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName("td");
-	var calendarRows = this.calendarDatesContainerNode.getElementsByTagName("tr");
-	var currentCalendarNode;
-	for (i = 0; i < days; i++) {
-		currentCalendarNode = calendarNodes.item(i);
-		currentCalendarNode.innerHTML = nextDate.getDate();
-		currentCalendarNode.setAttribute("djDateValue", nextDate.valueOf());
-		var curClass = (nextDate.getMonth() != this.curMonth.getMonth() && Number(nextDate) < Number(this.curMonth)) ? "previous" : (nextDate.getMonth() == this.curMonth.getMonth()) ? "current" : "next";
-		var mappedClass = curClass;
-		if (this._isDisabledDate(nextDate)) {
-			var classMap = {previous:"disabledPrevious", current:"disabledCurrent", next:"disabledNext"};
-			mappedClass = classMap[curClass];
-		}
-		dojo.html.setClass(currentCalendarNode, this._getDateClassName(nextDate, mappedClass));
-		if (dojo.html.hasClass(currentCalendarNode, this.classNames.selectedDate)) {
-			this.selectedNode = currentCalendarNode;
-		}
-		nextDate = dojo.date.add(nextDate, dojo.date.dateParts.DAY, 1);
-	}
-	this.lastDay = dojo.date.add(nextDate, dojo.date.dateParts.DAY, -1);
-	this._initControls();
-}, _initControls:function () {
-	var d = this.firstDay;
-	var d2 = this.lastDay;
-	var decWeek, incWeek, decMonth, incMonth, decYear, incYear;
-	decWeek = incWeek = decMonth = incMonth = decYear = incYear = !this.staticDisplay;
-	with (dojo.date.dateParts) {
-		var add = dojo.date.add;
-		if (decWeek && add(d, DAY, (-1 * (this._getAdjustedDay(d) + 1))) < this.startDate) {
-			decWeek = decMonth = decYear = false;
-		}
-		if (incWeek && d2 > this.endDate) {
-			incWeek = incMonth = incYear = false;
-		}
-		if (decMonth && add(d, DAY, -1) < this.startDate) {
-			decMonth = decYear = false;
-		}
-		if (incMonth && add(d2, DAY, 1) > this.endDate) {
-			incMonth = incYear = false;
-		}
-		if (decYear && add(d2, YEAR, -1) < this.startDate) {
-			decYear = false;
-		}
-		if (incYear && add(d, YEAR, 1) > this.endDate) {
-			incYear = false;
-		}
-	}
-	function enableControl(node, enabled) {
-		dojo.html.setVisibility(node, enabled ? "" : "hidden");
-	}
-	enableControl(this.decreaseWeekNode, decWeek);
-	enableControl(this.increaseWeekNode, incWeek);
-	enableControl(this.decreaseMonthNode, decMonth);
-	enableControl(this.increaseMonthNode, incMonth);
-	enableControl(this.previousYearLabelNode, decYear);
-	enableControl(this.nextYearLabelNode, incYear);
-}, _incrementWeek:function (evt) {
-	var d = new Date(this.firstDay);
-	switch (evt.target) {
-	  case this.increaseWeekNode.getElementsByTagName("img").item(0):
-	  case this.increaseWeekNode:
-		var tmpDate = dojo.date.add(d, dojo.date.dateParts.WEEK, 1);
-		if (tmpDate < this.endDate) {
-			d = dojo.date.add(d, dojo.date.dateParts.WEEK, 1);
-		}
-		break;
-	  case this.decreaseWeekNode.getElementsByTagName("img").item(0):
-	  case this.decreaseWeekNode:
-		if (d >= this.startDate) {
-			d = dojo.date.add(d, dojo.date.dateParts.WEEK, -1);
-		}
-		break;
-	}
-	this._preInitUI(d, true, true);
-}, _incrementMonth:function (evt) {
-	var d = new Date(this.curMonth);
-	var tmpDate = new Date(this.firstDay);
-	switch (evt.currentTarget) {
-	  case this.increaseMonthNode.getElementsByTagName("img").item(0):
-	  case this.increaseMonthNode:
-		tmpDate = dojo.date.add(tmpDate, dojo.date.dateParts.DAY, this.displayWeeks * 7);
-		if (tmpDate < this.endDate) {
-			d = dojo.date.add(d, dojo.date.dateParts.MONTH, 1);
-		} else {
-			var revertToEndDate = true;
-		}
-		break;
-	  case this.decreaseMonthNode.getElementsByTagName("img").item(0):
-	  case this.decreaseMonthNode:
-		if (tmpDate > this.startDate) {
-			d = dojo.date.add(d, dojo.date.dateParts.MONTH, -1);
-		} else {
-			var revertToStartDate = true;
-		}
-		break;
-	}
-	if (revertToStartDate) {
-		d = new Date(this.startDate);
-	} else {
-		if (revertToEndDate) {
-			d = new Date(this.endDate);
-		}
-	}
-	this._preInitUI(d, false, true);
-}, _incrementYear:function (evt) {
-	var year = this.curMonth.getFullYear();
-	var tmpDate = new Date(this.firstDay);
-	switch (evt.target) {
-	  case this.nextYearLabelNode:
-		tmpDate = dojo.date.add(tmpDate, dojo.date.dateParts.YEAR, 1);
-		if (tmpDate < this.endDate) {
-			year++;
-		} else {
-			var revertToEndDate = true;
-		}
-		break;
-	  case this.previousYearLabelNode:
-		tmpDate = dojo.date.add(tmpDate, dojo.date.dateParts.YEAR, -1);
-		if (tmpDate > this.startDate) {
-			year--;
-		} else {
-			var revertToStartDate = true;
-		}
-		break;
-	}
-	var d;
-	if (revertToStartDate) {
-		d = new Date(this.startDate);
-	} else {
-		if (revertToEndDate) {
-			d = new Date(this.endDate);
-		} else {
-			d = new Date(year, this.curMonth.getMonth(), 1);
-		}
-	}
-	this._preInitUI(d, false, true);
-}, onIncrementWeek:function (evt) {
-	evt.stopPropagation();
-	if (!this.staticDisplay) {
-		this._incrementWeek(evt);
-	}
-}, onIncrementMonth:function (evt) {
-	evt.stopPropagation();
-	if (!this.staticDisplay) {
-		this._incrementMonth(evt);
-	}
-}, onIncrementYear:function (evt) {
-	evt.stopPropagation();
-	if (!this.staticDisplay) {
-		this._incrementYear(evt);
-	}
-}, _setMonthLabel:function (monthIndex) {
-	this.monthLabelNode.innerHTML = dojo.date.getNames("months", "wide", "standAlone", this.lang)[monthIndex];
-}, _setYearLabels:function (year) {
-	var y = year - 1;
-	var that = this;
-	function f(n) {
-		that[n + "YearLabelNode"].innerHTML = dojo.date.format(new Date(y++, 0), {formatLength:"yearOnly", locale:that.lang});
-	}
-	f("previous");
-	f("current");
-	f("next");
-}, _getDateClassName:function (date, monthState) {
-	var currentClassName = this.classNames[monthState];
-	if ((!this.selectedIsUsed && this.value) && (Number(date) == Number(this.value))) {
-		currentClassName = this.classNames.selectedDate + " " + currentClassName;
-		this.selectedIsUsed = true;
-	}
-	if ((!this.currentIsUsed) && (Number(date) == Number(this.today))) {
-		currentClassName = currentClassName + " " + this.classNames.currentDate;
-		this.currentIsUsed = true;
-	}
-	return currentClassName;
-}, onClick:function (evt) {
-	dojo.event.browser.stopEvent(evt);
-}, _handleUiClick:function (evt) {
-	var eventTarget = evt.target;
-	if (eventTarget.nodeType != dojo.dom.ELEMENT_NODE) {
-		eventTarget = eventTarget.parentNode;
-	}
-	dojo.event.browser.stopEvent(evt);
-	this.selectedIsUsed = this.todayIsUsed = false;
-	if (dojo.html.hasClass(eventTarget, this.classNames["disabledPrevious"]) || dojo.html.hasClass(eventTarget, this.classNames["disabledCurrent"]) || dojo.html.hasClass(eventTarget, this.classNames["disabledNext"])) {
-		return;
-	}
-	this.clickedNode = eventTarget;
-	this.setDate(new Date(Number(dojo.html.getAttribute(eventTarget, "djDateValue"))));
-}, onValueChanged:function (date) {
-}, _isDisabledDate:function (dateObj) {
-	if (dateObj < this.startDate || dateObj > this.endDate) {
-		return true;
-	}
-	return this.isDisabledDate(dateObj, this.lang);
-}, isDisabledDate:function (dateObj, locale) {
-	return false;
-}, _initFirstDay:function (dateObj, adj) {
-	var d = new Date(dateObj);
-	if (!adj) {
-		d.setDate(1);
-	}
-	d.setDate(d.getDate() - this._getAdjustedDay(d, this.weekStartsOn));
-	d.setHours(0, 0, 0, 0);
-	return d;
-}, _getAdjustedDay:function (dateObj) {
-	var days = [0, 1, 2, 3, 4, 5, 6];
-	if (this.weekStartsOn > 0) {
-		for (var i = 0; i < this.weekStartsOn; i++) {
-			days.unshift(days.pop());
-		}
-	}
-	return days[dateObj.getDay()];
-}, destroy:function () {
-	dojo.widget.DatePicker.superclass.destroy.apply(this, arguments);
-	dojo.html.destroyNode(this.weekTemplate);
-}});
-
+}

Deleted: tags/parley-0.53/root/static/magic/src/widget/DateTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DateTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DateTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,47 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.DateTextbox");
-dojo.require("dojo.widget.ValidationTextbox");
-dojo.require("dojo.date.format");
-dojo.require("dojo.validate.datetime");
-dojo.widget.defineWidget("dojo.widget.DateTextbox", dojo.widget.ValidationTextbox, {displayFormat:"", formatLength:"short", mixInProperties:function (localProperties) {
-	dojo.widget.DateTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.format) {
-		this.flags.format = localProperties.format;
-	}
-}, isValid:function () {
-	if (this.flags.format) {
-		dojo.deprecated("dojo.widget.DateTextbox", "format attribute is deprecated; use displayFormat or formatLength instead", "0.5");
-		return dojo.validate.isValidDate(this.textbox.value, this.flags.format);
-	}
-	return dojo.date.parse(this.textbox.value, {formatLength:this.formatLength, selector:"dateOnly", locale:this.lang, datePattern:this.displayFormat});
-}});
-dojo.widget.defineWidget("dojo.widget.TimeTextbox", dojo.widget.ValidationTextbox, {displayFormat:"", formatLength:"short", mixInProperties:function (localProperties) {
-	dojo.widget.TimeTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.format) {
-		this.flags.format = localProperties.format;
-	}
-	if (localProperties.amsymbol) {
-		this.flags.amSymbol = localProperties.amsymbol;
-	}
-	if (localProperties.pmsymbol) {
-		this.flags.pmSymbol = localProperties.pmsymbol;
-	}
-}, isValid:function () {
-	if (this.flags.format) {
-		dojo.deprecated("dojo.widget.TimeTextbox", "format attribute is deprecated; use displayFormat or formatLength instead", "0.5");
-		return dojo.validate.isValidTime(this.textbox.value, this.flags);
-	}
-	return dojo.date.parse(this.textbox.value, {formatLength:this.formatLength, selector:"timeOnly", locale:this.lang, timePattern:this.displayFormat});
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/DebugConsole.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DebugConsole.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DebugConsole.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,16 +8,15 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.DebugConsole");
-dojo.require("dojo.widget.Widget");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.FloatingPane");
-dojo.widget.defineWidget("dojo.widget.DebugConsole", dojo.widget.FloatingPane, {fillInTemplate:function () {
-	dojo.widget.DebugConsole.superclass.fillInTemplate.apply(this, arguments);
-	this.containerNode.id = "debugConsoleClientPane";
-	djConfig.isDebug = true;
-	djConfig.debugContainerId = this.containerNode.id;
-}});
-
+dojo.provide("dojo.widget.DebugConsole");
+dojo.require("dojo.widget.Widget");
+
+dojo.widget.DebugConsole= function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = "DebugConsole";
+	this.isContainer = true;
+}
+dojo.inherits(dojo.widget.DebugConsole, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler("dojo:debugconsole");
+dojo.requireAfterIf("html", "dojo.widget.html.DebugConsole");

Modified: tags/parley-0.53/root/static/magic/src/widget/Dialog.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Dialog.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Dialog.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,293 +8,262 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Dialog");
+dojo.provide("dojo.widget.html.Dialog");
+
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.ContentPane");
 dojo.require("dojo.event.*");
-dojo.require("dojo.gfx.color");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.iframe");
-dojo.declare("dojo.widget.ModalDialogBase", null, {isContainer:true, focusElement:"", bgColor:"black", bgOpacity:0.4, followScroll:true, closeOnBackgroundClick:false, trapTabs:function (e) {
-	if (e.target == this.tabStartOuter) {
-		if (this._fromTrap) {
-			this.tabStart.focus();
-			this._fromTrap = false;
-		} else {
-			this._fromTrap = true;
-			this.tabEnd.focus();
-		}
-	} else {
-		if (e.target == this.tabStart) {
-			if (this._fromTrap) {
-				this._fromTrap = false;
-			} else {
-				this._fromTrap = true;
-				this.tabEnd.focus();
-			}
-		} else {
-			if (e.target == this.tabEndOuter) {
-				if (this._fromTrap) {
+dojo.require("dojo.graphics.color");
+dojo.require("dojo.html");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Dialog",
+	dojo.widget.html.ContentPane,
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlDialog.html"),
+		isContainer: true,
+		_scrollConnected: false,
+		
+		// provide a focusable element or element id if you need to
+		// work around FF's tendency to send focus into outer space on hide
+		focusElement: "",
+
+		bg: null,
+		bgColor: "black",
+		bgOpacity: 0.4,
+		followScroll: true,
+		_fromTrap: false,
+		anim: null,
+		blockDuration: 0,
+		lifetime: 0,
+
+		trapTabs: function(e){
+			if(e.target == this.tabStart) {
+				if(this._fromTrap) {
+					this._fromTrap = false;
+				} else {
+					this._fromTrap = true;
 					this.tabEnd.focus();
+				}
+			} else if(e.target == this.tabEnd) {
+				if(this._fromTrap) {
 					this._fromTrap = false;
 				} else {
 					this._fromTrap = true;
 					this.tabStart.focus();
 				}
+			}
+		},
+
+		clearTrap: function(e) {
+			var _this = this;
+			setTimeout(function() {
+				_this._fromTrap = false;
+			}, 100);
+		},
+
+		postCreate: function(args, frag, parentComp) {
+			with(this.domNode.style) {
+				position = "absolute";
+				zIndex = 999;
+				display = "none";
+				overflow = "visible";
+			}
+			var b = document.body;
+			b.appendChild(this.domNode);
+
+			this.bg = document.createElement("div");
+			this.bg.className = "dialogUnderlay";
+			with(this.bg.style) {
+				position = "absolute";
+				left = top = "0px";
+				zIndex = 998;
+				display = "none";
+			}
+			this.setBackgroundColor(this.bgColor);
+			b.appendChild(this.bg);
+
+			this.bgIframe = new dojo.html.BackgroundIframe(this.bg);
+		},
+
+		setBackgroundColor: function(color) {
+			if(arguments.length >= 3) {
+				color = new dojo.graphics.color.Color(arguments[0], arguments[1], arguments[2]);
 			} else {
-				if (e.target == this.tabEnd) {
-					if (this._fromTrap) {
-						this._fromTrap = false;
-					} else {
-						this._fromTrap = true;
-						this.tabStart.focus();
+				color = new dojo.graphics.color.Color(color);
+			}
+			this.bg.style.backgroundColor = color.toString();
+			return this.bgColor = color;
+		},
+		
+		setBackgroundOpacity: function(op) {
+			if(arguments.length == 0) { op = this.bgOpacity; }
+			dojo.style.setOpacity(this.bg, op);
+			try {
+				this.bgOpacity = dojo.style.getOpacity(this.bg);
+			} catch (e) {
+				this.bgOpacity = op;
+			}
+			return this.bgOpacity;
+		},
+
+		sizeBackground: function() {
+			if(this.bgOpacity > 0) {
+				var h = Math.max(
+					document.documentElement.scrollHeight || document.body.scrollHeight,
+					dojo.html.getViewportHeight());
+				var w = dojo.html.getViewportWidth();
+				this.bg.style.width = w + "px";
+				this.bg.style.height = h + "px";
+			}
+			this.bgIframe.onResized();
+		},
+
+		showBackground: function() {
+			this.sizeBackground();
+			if(this.bgOpacity > 0) {
+				this.bg.style.display = "block";
+			}
+		},
+
+		placeDialog: function() {
+			var scroll_offset = dojo.html.getScrollOffset();
+			var viewport_size = dojo.html.getViewportSize();
+
+			// find the size of the dialog
+			var w = dojo.style.getOuterWidth(this.containerNode);
+			var h = dojo.style.getOuterHeight(this.containerNode);
+
+			var x = scroll_offset[0] + (viewport_size[0] - w)/2;
+			var y = scroll_offset[1] + (viewport_size[1] - h)/2;
+
+			with(this.domNode.style) {
+				left = x + "px";
+				top = y + "px";
+			}
+		},
+
+		show: function() {
+			this.setBackgroundOpacity();
+			this.showBackground();
+
+			dojo.widget.html.Dialog.superclass.show.call(this);
+
+			// FIXME: moz doesn't generate onscroll events for mouse or key scrolling (wtf)
+			// we should create a fake event by polling the scrolltop/scrollleft every X ms.
+			// this smells like it should be a dojo feature rather than just for this widget.
+
+			if (this.followScroll && !this._scrollConnected){
+				this._scrollConnected = true;
+				dojo.event.connect(window, "onscroll", this, "onScroll");
+			}
+			
+			if(this.lifetime){
+				this.timeRemaining = this.lifetime;
+				if(!this.blockDuration){
+					dojo.event.connect(this.bg, "onclick", this, "hide");
+				}else{
+					dojo.event.disconnect(this.bg, "onclick", this, "hide");
+				}
+				if(this.timerNode){
+					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
+				}
+				if(this.blockDuration && this.closeNode){
+					if(this.lifetime > this.blockDuration){
+						this.closeNode.style.visibility = "hidden";
+					}else{
+						this.closeNode.style.display = "none";
 					}
 				}
+				this.timer = setInterval(dojo.lang.hitch(this, "onTick"), 100);
 			}
-		}
-	}
-}, clearTrap:function (e) {
-	var _this = this;
-	setTimeout(function () {
-		_this._fromTrap = false;
-	}, 100);
-}, postCreate:function () {
-	with (this.domNode.style) {
-		position = "absolute";
-		zIndex = 999;
-		display = "none";
-		overflow = "visible";
-	}
-	var b = dojo.body();
-	b.appendChild(this.domNode);
-	this.bg = document.createElement("div");
-	this.bg.className = "dialogUnderlay";
-	with (this.bg.style) {
-		position = "absolute";
-		left = top = "0px";
-		zIndex = 998;
-		display = "none";
-	}
-	b.appendChild(this.bg);
-	this.setBackgroundColor(this.bgColor);
-	this.bgIframe = new dojo.html.BackgroundIframe();
-	if (this.bgIframe.iframe) {
-		with (this.bgIframe.iframe.style) {
-			position = "absolute";
-			left = top = "0px";
-			zIndex = 90;
-			display = "none";
-		}
-	}
-	if (this.closeOnBackgroundClick) {
-		dojo.event.kwConnect({srcObj:this.bg, srcFunc:"onclick", adviceObj:this, adviceFunc:"onBackgroundClick", once:true});
-	}
-}, uninitialize:function () {
-	this.bgIframe.remove();
-	dojo.html.removeNode(this.bg, true);
-}, setBackgroundColor:function (color) {
-	if (arguments.length >= 3) {
-		color = new dojo.gfx.color.Color(arguments[0], arguments[1], arguments[2]);
-	} else {
-		color = new dojo.gfx.color.Color(color);
-	}
-	this.bg.style.backgroundColor = color.toString();
-	return this.bgColor = color;
-}, setBackgroundOpacity:function (op) {
-	if (arguments.length == 0) {
-		op = this.bgOpacity;
-	}
-	dojo.html.setOpacity(this.bg, op);
-	try {
-		this.bgOpacity = dojo.html.getOpacity(this.bg);
-	}
-	catch (e) {
-		this.bgOpacity = op;
-	}
-	return this.bgOpacity;
-}, _sizeBackground:function () {
-	if (this.bgOpacity > 0) {
-		var viewport = dojo.html.getViewport();
-		var h = viewport.height;
-		var w = viewport.width;
-		with (this.bg.style) {
-			width = w + "px";
-			height = h + "px";
-		}
-		var scroll_offset = dojo.html.getScroll().offset;
-		this.bg.style.top = scroll_offset.y + "px";
-		this.bg.style.left = scroll_offset.x + "px";
-		var viewport = dojo.html.getViewport();
-		if (viewport.width != w) {
-			this.bg.style.width = viewport.width + "px";
-		}
-		if (viewport.height != h) {
-			this.bg.style.height = viewport.height + "px";
-		}
-	}
-	this.bgIframe.size(this.bg);
-}, _showBackground:function () {
-	if (this.bgOpacity > 0) {
-		this.bg.style.display = "block";
-	}
-	if (this.bgIframe.iframe) {
-		this.bgIframe.iframe.style.display = "block";
-	}
-}, placeModalDialog:function () {
-	var scroll_offset = dojo.html.getScroll().offset;
-	var viewport_size = dojo.html.getViewport();
-	var mb;
-	if (this.isShowing()) {
-		mb = dojo.html.getMarginBox(this.domNode);
-	} else {
-		dojo.html.setVisibility(this.domNode, false);
-		dojo.html.show(this.domNode);
-		mb = dojo.html.getMarginBox(this.domNode);
-		dojo.html.hide(this.domNode);
-		dojo.html.setVisibility(this.domNode, true);
-	}
-	var x = scroll_offset.x + (viewport_size.width - mb.width) / 2;
-	var y = scroll_offset.y + (viewport_size.height - mb.height) / 2;
-	with (this.domNode.style) {
-		left = x + "px";
-		top = y + "px";
-	}
-}, _onKey:function (evt) {
-	if (evt.key) {
-		var node = evt.target;
-		while (node != null) {
-			if (node == this.domNode) {
-				return;
+
+			this.checkSize();
+		},
+
+		onLoad: function(){
+			// when href is specified we need to reposition
+			// the dialog after the data is loaded
+			this.placeDialog();
+		},
+		
+		fillInTemplate: function(){
+			// dojo.event.connect(this.domNode, "onclick", this, "killEvent");
+		},
+
+		hide: function(){
+			// workaround for FF focus going into outer space
+			if (this.focusElement) { 
+				dojo.byId(this.focusElement).focus(); 
+				dojo.byId(this.focusElement).blur();
 			}
-			node = node.parentNode;
-		}
-		if (evt.key != evt.KEY_TAB) {
-			dojo.event.browser.stopEvent(evt);
-		} else {
-			if (!dojo.render.html.opera) {
-				try {
-					this.tabStart.focus();
+			
+			if(this.timer){
+				clearInterval(this.timer);
+			}
+
+			this.bg.style.display = "none";
+			this.bg.style.width = this.bg.style.height = "1px";
+
+			dojo.widget.html.Dialog.superclass.hide.call(this);
+
+			if (this._scrollConnected){
+				this._scrollConnected = false;
+				dojo.event.disconnect(window, "onscroll", this, "onScroll");
+			}
+		},
+		
+		setTimerNode: function(node){
+			this.timerNode = node;
+		},
+
+		setCloseControl: function(node) {
+			this.closeNode = node;
+			dojo.event.connect(node, "onclick", this, "hide");
+		},
+
+		setShowControl: function(node) {
+			dojo.event.connect(node, "onclick", this, "show");
+		},
+		
+		onTick: function(){
+			if(this.timer){
+				this.timeRemaining -= 100;
+				if(this.lifetime - this.timeRemaining >= this.blockDuration){
+					dojo.event.connect(this.bg, "onclick", this, "hide");
+					if(this.closeNode){
+						this.closeNode.style.visibility = "visible";
+					}
 				}
-				catch (e) {
+				if(!this.timeRemaining){
+					clearInterval(this.timer);
+					this.hide();
+				}else if(this.timerNode){
+					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
 				}
 			}
-		}
-	}
-}, showModalDialog:function () {
-	if (this.followScroll && !this._scrollConnected) {
-		this._scrollConnected = true;
-		dojo.event.connect(window, "onscroll", this, "_onScroll");
-	}
-	dojo.event.connect(document.documentElement, "onkey", this, "_onKey");
-	this.placeModalDialog();
-	this.setBackgroundOpacity();
-	this._sizeBackground();
-	this._showBackground();
-	this._fromTrap = true;
-	setTimeout(dojo.lang.hitch(this, function () {
-		try {
-			this.tabStart.focus();
-		}
-		catch (e) {
-		}
-	}), 50);
-}, hideModalDialog:function () {
-	if (this.focusElement) {
-		dojo.byId(this.focusElement).focus();
-		dojo.byId(this.focusElement).blur();
-	}
-	this.bg.style.display = "none";
-	this.bg.style.width = this.bg.style.height = "1px";
-	if (this.bgIframe.iframe) {
-		this.bgIframe.iframe.style.display = "none";
-	}
-	dojo.event.disconnect(document.documentElement, "onkey", this, "_onKey");
-	if (this._scrollConnected) {
-		this._scrollConnected = false;
-		dojo.event.disconnect(window, "onscroll", this, "_onScroll");
-	}
-}, _onScroll:function () {
-	var scroll_offset = dojo.html.getScroll().offset;
-	this.bg.style.top = scroll_offset.y + "px";
-	this.bg.style.left = scroll_offset.x + "px";
-	this.placeModalDialog();
-}, checkSize:function () {
-	if (this.isShowing()) {
-		this._sizeBackground();
-		this.placeModalDialog();
-		this.onResized();
-	}
-}, onBackgroundClick:function () {
-	if (this.lifetime - this.timeRemaining >= this.blockDuration) {
-		return;
-	}
-	this.hide();
-}});
-dojo.widget.defineWidget("dojo.widget.Dialog", [dojo.widget.ContentPane, dojo.widget.ModalDialogBase], {templateString:"<div id=\"${this.widgetId}\" class=\"dojoDialog\" dojoattachpoint=\"wrapper\">\n\t<span dojoattachpoint=\"tabStartOuter\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\"\ttabindex=\"0\"></span>\n\t<span dojoattachpoint=\"tabStart\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\" tabindex=\"0\"></span>\n\t<div dojoattachpoint=\"containerNode\" style=\"position: relative; z-index: 2;\"></div>\n\t<span dojoattachpoint=\"tabEnd\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\" tabindex=\"0\"></span>\n\t<span dojoattachpoint=\"tabEndOuter\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\" tabindex=\"0\"></span>\n</div>\n", blockDuration:0, lifetime:0, closeNode:"", postMixInProperties:function () {
-	dojo.widget.Dialog.superclass.postMixInProperties.apply(this, arguments);
-	if (this.closeNode) {
-		this.setCloseControl(this.closeNode);
-	}
-}, postCreate:function () {
-	dojo.widget.Dialog.superclass.postCreate.apply(this, arguments);
-	dojo.widget.ModalDialogBase.prototype.postCreate.apply(this, arguments);
-}, show:function () {
-	if (this.lifetime) {
-		this.timeRemaining = this.lifetime;
-		if (this.timerNode) {
-			this.timerNode.innerHTML = Math.ceil(this.timeRemaining / 1000);
-		}
-		if (this.blockDuration && this.closeNode) {
-			if (this.lifetime > this.blockDuration) {
-				this.closeNode.style.visibility = "hidden";
-			} else {
-				this.closeNode.style.display = "none";
+		},
+
+		onScroll: function(){
+			this.placeDialog();
+			this.domNode.style.display = "block";
+		},
+
+		// Called when the browser window's size is changed
+		checkSize: function() {
+			if(this.isShowing()){
+				this.sizeBackground();
+				this.placeDialog();
+				this.domNode.style.display="block";
+				this.onResized();
 			}
+		},
+		
+		killEvent: function(evt){
+			evt.preventDefault();
+			evt.stopPropagation();
 		}
-		if (this.timer) {
-			clearInterval(this.timer);
-		}
-		this.timer = setInterval(dojo.lang.hitch(this, "_onTick"), 100);
-	}
-	this.showModalDialog();
-	dojo.widget.Dialog.superclass.show.call(this);
-}, onLoad:function () {
-	this.placeModalDialog();
-	dojo.widget.Dialog.superclass.onLoad.call(this);
-}, fillInTemplate:function () {
-}, hide:function () {
-	this.hideModalDialog();
-	dojo.widget.Dialog.superclass.hide.call(this);
-	if (this.timer) {
-		clearInterval(this.timer);
-	}
-}, setTimerNode:function (node) {
-	this.timerNode = node;
-}, setCloseControl:function (node) {
-	this.closeNode = dojo.byId(node);
-	dojo.event.connect(this.closeNode, "onclick", this, "hide");
-}, setShowControl:function (node) {
-	node = dojo.byId(node);
-	dojo.event.connect(node, "onclick", this, "show");
-}, _onTick:function () {
-	if (this.timer) {
-		this.timeRemaining -= 100;
-		if (this.lifetime - this.timeRemaining >= this.blockDuration) {
-			if (this.closeNode) {
-				this.closeNode.style.visibility = "visible";
-			}
-		}
-		if (!this.timeRemaining) {
-			clearInterval(this.timer);
-			this.hide();
-		} else {
-			if (this.timerNode) {
-				this.timerNode.innerHTML = Math.ceil(this.timeRemaining / 1000);
-			}
-		}
-	}
-}});
 
+	}
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/DocPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DocPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DocPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,255 +8,5 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.DocPane");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.io.*");
-dojo.require("dojo.event.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.Editor2");
-dojo.require("dojo.widget.Dialog");
-dojo.require("dojo.html.common");
-dojo.require("dojo.html.display");
-dojo.widget.DocPane = function () {
-	dojo.event.topic.subscribe("/docs/function/results", this, "onDocResults");
-	dojo.event.topic.subscribe("/docs/package/results", this, "onPkgResults");
-	dojo.event.topic.subscribe("/docs/function/detail", this, "onDocSelectFunction");
-};
-dojo.widget.defineWidget("dojo.widget.DocPane", dojo.widget.HtmlWidget, {dialog:null, dialogBg:null, dialogFg:null, logIn:null, edit:null, save:null, cancel:null, detail:null, result:null, packag:null, fn:null, fnLink:null, count:null, row:null, summary:null, description:null, variables:null, vRow:null, vLink:null, vDesc:null, methods:null, mRow:null, mLink:null, mDesc:null, requires:null, rRow:null, rRow2:null, rH3:null, rLink:null, parameters:null, pRow:null, pLink:null, pDesc:null, pOpt:null, pType:null, sType:null, sName:null, sParams:null, sPType:null, sPTypeSave:null, sPName:null, sPNameSave:null, pkgDescription:null, _appends:[], templateString:"<div class=\"dojoDocPane\">\n\t<div dojoAttachPoint=\"containerNode\" class=\"container\"></div>\n\n\t<div dojoAttachPoint=\"dialog\" class=\"dialog\">\n\t\t<div class=\"container\" dojoAttachPoint=\"dialogBg\">\n\t\t\t<div class=\"docDialog\" dojoAttachPoint=\"dialogFg\">\n\t\t\t\t<h2>Log In</h2>\n\t\t\t\t<p><input id=\"dojo!
 DocUserName\" dojoAttachPoint=\"userName\"><label for=\"dojoDocUserName\">User Name:</label></p>\n\t\t\t\t<p><input id=\"dojoDocPassword\" dojoAttachPoint=\"password\" type=\"password\"><label for=\"dojoDocPassword\">Password:</label></p>\n\t\t\t\t<p><input type=\"button\" dojoAttachPoint=\"cancel\" value=\"cancel\"> <input type=\"button\" dojoAttachPoint=\"logIn\" value=\"Log In\"></p>\n\t\t\t\t<p></p>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\n\t<div dojoAttachPoint=\"nav\" class=\"nav\"><span>Detail</span> | <span>Source</span> | <span>Examples</span> | <span>Walkthrough</span></div>\n\n\t<div dojoAttachPoint=\"detail\" class=\"detail\">\n\t\t<h1>Detail: <span class=\"fn\" dojoAttachPoint=\"fn\">dojo.select</span></h1>\n\t\t<div class=\"description\" dojoAttachPoint=\"description\">Description</div>\n\t\t<div class=\"params\" dojoAttachPoint=\"parameters\">\n\t\t\t<h2>Parameters</h2>\n\t\t\t<div class=\"row\" dojoAttachPoint=\"pRow\">\n\t\t\t\t<span dojoAttachPoint=\"pOpt\">!
 <em>optional</em> </span>\n\t\t\t\t<span><span dojoAttachPoint!
 =\"pType
\">type</span> </span>\n\t\t\t\t<a href=\"#\" dojoAttachPoint=\"pLink\">variable</a>\n\t\t\t\t<span> - <span dojoAttachPoint=\"pDesc\"></span></span>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"variables\" dojoAttachPoint=\"variables\">\n\t\t\t<h2>Variables</h2>\n\t\t\t<div class\"row\" dojoAttachPoint=\"vRow\">\n\t\t\t\t<a href=\"#\" dojoAttachPoint=\"vLink\">variable</a><span> - <span dojoAttachPoint=\"vDesc\"></span></span>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"signature\">\n\t\t\t<h2>Signature</h2>\n\t\t\t<div class=\"source\">\n\t\t\t\t<span class=\"return\" dojoAttachPoint=\"sType\">returnType</span> \n\t\t\t\t<span class=\"function\" dojoAttachPoint=\"sName\">foo</span>\n\t\t\t\t(<span class=\"params\" dojoAttachPoint=\"sParams\">\n\t\t\t\t\t<span class=\"type\" dojoAttachPoint=\"sPType\">type </span>\n\t\t\t\t\t<span class=\"name\" dojoAttachPoint=\"sPName\">paramName</span>\n\t\t\t\t</span>)\n\t\t\t</div>\n\t\t</div>\n\t</div>\n\t\n\t<div dojoAttachPoint=\"res!
 ult\" class=\"result\">\n\t\t<h1>Search Results: <span dojoAttachPoint=\"count\">0</span> matches</h1>\n\t\t<div class=\"row\" dojoAttachPoint=\"row\">\n\t\t\t<a href=\"#\" dojoAttachPoint=\"fnLink\">dojo.fnLink</a>\n\t\t\t<span> - <span class=\"summary\" dojoAttachPoint=\"summary\">summary</span></span>\n\t\t</div>\n\t</div>\n\n\t<div dojoAttachPoint=\"packag\" class=\"package\">\n\t\t<h1>Package: \n\t\t\t<span class=\"pkg\" dojoAttachPoint=\"pkg\">dojo.package</span> \n\t\t\t<span class=\"edit\" dojoAttachPoint=\"edit\">[edit]</span> \n\t\t\t<span class=\"save\" dojoAttachPoint=\"save\">[save]</span>\n\t\t</h1>\n\t\t<div dojoAttachPoint=\"pkgDescription\" class=\"description\">Description</div>\n\t\t<div class=\"methods\" dojoAttachPoint=\"methods\">\n\t\t\t<h2>Methods</h2>\n\t\t\t<div class=\"row\" dojoAttachPoint=\"mRow\">\n\t\t\t\t<a href=\"#\" dojoAttachPoint=\"mLink\">method</a>\n\t\t\t\t<span> - <span class=\"description\" dojoAttachPoint=\"mDesc\"></span></span>\n\!
 t\t\t</div>\n\t\t</div>\n\t\t<div class=\"requires\" dojoAttac!
 hPoint=\
"requires\">\n\t\t\t<h2>Requires</h2>\n\t\t\t<div class=\"row\" dojoAttachPoint=\"rRow\">\n\t\t\t\t<h3 dojoAttachPoint=\"rH3\">Environment</h3>\n\t\t\t\t<div dojoAttachPoint=\"rRow2\"><a href=\"#\" dojoAttachPoint=\"rLink\" class=\"package\">require</a></div>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n</div>\n", templateCssString:".dojoDocPane { padding:1em; font: 1em Georgia,Times,\"Times New Roman\",serif; }\n\n.dojoDocPane .container{ }\n\n.dojoDocPane .dialog{ }\n.dojoDocPane .dialog .container{ padding: 0.5em; background: #fff; border: 2px solid #333; }\n.dojoDocPane .dialog .docDialog{ background: transparent; width: 20em; }\n.dojoDocPane .dialog .docDialog h2{ margin-top: 0; padding-top: 0; }\n.dojoDocPane .dialog .docDialog input { float: right; margin-right: 1em; }\n.dojoDocPane .dialog .docDialog p{ clear: both; }\n#dojoDocUserName, #dojoDocPassword { width: 10em; }\n\n.dojoDocPane .nav{ }\n.dojoDocPane .nav span{ }\n\n.dojoDocPane .detail{ }\n.dojoDocPane .detail h1{ }\!
 n.dojoDocPane .detail h1 span.fn{ }\n.dojoDocPane .detail .description{ }\n.dojoDocPane .detail .params{ }\n.dojoDocPane .detail .params .row{ }\n.dojoDocPane .detail .params .row span{ }\n.dojoDocPane .detail .variables{ }\n.dojoDocPane .detail .variables .row{ }\n.dojoDocPane .detail .signature{ }\n.dojoDocPane .detail .signature .source{ white-space: pre; font: 0.8em Monaco, Courier, \"Courier New\", monospace; }\n.dojoDocPane .detail .signature .source .return{ color:#369; }\n.dojoDocPane .detail .signature .source .function{ color: #98543F; font-weight: bold; }\n.dojoDocPane .detail .signature .source .params{ }\n.dojoDocPane .detail .signature .source .params .type{ font-style: italic; color: #d17575; }\n.dojoDocPane .detail .signature .source .params .name{ color: #d14040; }\n\n.dojoDocPane .result{ }\n.dojoDocPane .result h1{ }\n.dojoDocPane .result .row{ }\n.dojoDocPane .result .row .summary{ }\n\n.dojoDocPane .package{ }\n.dojoDocPane .package h1{ }\n.dojoDocPane !
 .package .row{ }\n.dojoDocPane .package .row .summary{ }\n.doj!
 oDocPane
 .package .description{ }\n.dojoDocPane .package .methods{ }\n.dojoDocPane .package .methods h2{ }\n.dojoDocPane .package .methods .row{ }\n.dojoDocPane .package .methods .row .description{ }\n.dojoDocPane .package .requires{ }\n.dojoDocPane .package .requires h2{ }\n.dojoDocPane .package .requires .row{ }\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/DocPane.css"), isContainer:true, fillInTemplate:function () {
-	this.requires = dojo.html.removeNode(this.requires);
-	this.rRow.style.display = "none";
-	this.rRow2.style.display = "none";
-	this.methods = dojo.html.removeNode(this.methods);
-	this.mRow.style.display = "none";
-	this.dialog = dojo.widget.createWidget("dialog", {}, this.dialog);
-	this.dialog.setCloseControl(this.cancel);
-	dojo.html.setOpacity(this.dialogBg, 0.8);
-	dojo.html.setOpacity(this.dialogFg, 1);
-	dojo.event.connect(this.edit, "onclick", dojo.lang.hitch(this, function () {
-		if (!this._isLoggedIn) {
-			this.dialog.show();
-		}
-	}));
-	dojo.event.connect(this.logIn, "onclick", this, "_logIn");
-	dojo.event.connect(this.save, "onclick", this, "_save");
-	dojo.event.connect(dojo.docs, "logInSuccess", this, "_loggedIn");
-	this.homeSave = this.containerNode.cloneNode(true);
-	this.detailSave = dojo.html.removeNode(this.detail);
-	this.resultSave = dojo.html.removeNode(this.result);
-	this.packageSave = dojo.html.removeNode(this.packag);
-	this.results = dojo.html.removeNode(this.results);
-	this.rowParent = this.row.parentNode;
-	this.rowSave = dojo.html.removeNode(this.row);
-	this.vParent = this.vRow.parentNode;
-	this.vSave = dojo.html.removeNode(this.vRow);
-	this.pParent = this.pRow.parentNode;
-	this.pSave = dojo.html.removeNode(this.pRow);
-	this.sPTypeSave = dojo.html.removeNode(this.sPType);
-	this.sPNameSave = dojo.html.removeNode(this.sPName);
-	this.navSave = dojo.html.removeNode(this.nav);
-}, _logIn:function () {
-	dojo.docs.setUserName(this.userName.value);
-	dojo.docs.setPassword(this.password.value);
-}, _loggedIn:function () {
-	this._isLoggedIn = true;
-	this.dialog.hide();
-	this.pkgEditor = dojo.widget.createWidget("editor2", {toolbarAlwaysVisible:true}, this.pkgDescription);
-}, _save:function () {
-	if (this.pkgEditor) {
-		dojo.docs.savePackage(this._pkgPath, {description:this.pkgEditor.getEditorContent()});
-	}
-}, onDocSelectFunction:function (message) {
-	dojo.debug("onDocSelectFunction()");
-	for (var key in message) {
-		dojo.debug(key + ": " + dojo.json.serialize(message[key]));
-	}
-	var meta = message.meta;
-	if (meta) {
-		var variables = meta.variables;
-		var this_variables = meta.this_variables;
-		var child_variables = meta.child_variables;
-		var parameters = meta.parameters;
-	}
-	var doc = message.doc;
-	dojo.debug(dojo.json.serialize(doc));
-	var appends = this._appends;
-	dojo.html.removeChildren(this.domNode);
-	this.fn.innerHTML = message.name;
-	this.variables.style.display = "block";
-	var all = [];
-	if (variables) {
-		all = variables;
-	}
-	if (this_variables) {
-		all = all.concat(this_variables);
-	}
-	if (child_variables) {
-		all = all.concat(child_variables);
-	}
-	if (!all.length) {
-		this.variables.style.display = "none";
-	} else {
-		for (var i = 0, one; one = all[i]; i++) {
-			this.vLink.innerHTML = one;
-			this.vDesc.parentNode.style.display = "none";
-			appends.push(this.vParent.appendChild(this.vSave.cloneNode(true)));
-		}
-	}
-	this.sParams.innerHTML = "";
-	var first = true;
-	for (var param in parameters) {
-		var paramType = parameters[param].type;
-		var paramSummary = parameters[param].summary;
-		var paramName = param;
-		this.parameters.style.display = "block";
-		this.pLink.innerHTML = paramName;
-		this.pOpt.style.display = "none";
-		if (parameters[param].opt) {
-			this.pOpt.style.display = "inline";
-		}
-		this.pType.parentNode.style.display = "none";
-		if (parameters[param][0]) {
-			this.pType.parentNode.style.display = "inline";
-			this.pType.innerHTML = paramType;
-		}
-		this.pDesc.parentNode.style.display = "none";
-		if (paramSummary) {
-			this.pDesc.parentNode.style.display = "inline";
-			this.pDesc.innerHTML = paramSummary;
-		}
-		appends.push(this.pParent.appendChild(this.pSave.cloneNode(true)));
-		if (!first) {
-			this.sParams.appendChild(document.createTextNode(", "));
-		}
-		first = false;
-		if (paramType) {
-			dojo.debug(this.sPTypeSave);
-			this.sPTypeSave.innerHTML = paramType;
-			this.sParams.appendChild(this.sPTypeSave.cloneNode(true));
-			this.sParams.appendChild(document.createTextNode(" "));
-		}
-		dojo.debug(this.sPNameSave);
-		this.sPNameSave.innerHTML = paramName;
-		this.sParams.appendChild(this.sPNameSave.cloneNode(true));
-	}
-	if (message.returns) {
-		this.sType.innerHTML = message.returns;
-	} else {
-		this.sType.innerHTML = "void";
-	}
-	this.sName.innerHTML = message.name;
-	this.domNode.appendChild(this.navSave);
-	this.domNode.appendChild(this.detailSave.cloneNode(true));
-	for (var i = 0, append; append = appends[i]; i++) {
-		dojo.html.removeNode(append);
-	}
-}, onPkgResult:function (results) {
-	if (this.pkgEditor) {
-		this.pkgEditor.close(true);
-		dojo.debug(this.pkgDescription);
-	}
-	var methods = results.methods;
-	var requires = results.requires;
-	var description = results.description;
-	this._pkgPath = results.path;
-	var requireLinks = [];
-	var appends = this._appends;
-	while (appends.length) {
-		dojo.html.removeNode(appends.shift());
-	}
-	dojo.html.removeChildren(this.domNode);
-	this.pkg.innerHTML = results.pkg;
-	var hasRequires = false;
-	for (var env in requires) {
-		hasRequires = true;
-		this.rH3.style.display = "none";
-		if (env != "common") {
-			this.rH3.style.display = "";
-			this.rH3.innerHTML = env;
-		}
-		for (var i = 0, require; require = requires[env][i]; i++) {
-			requireLinks.push({name:require});
-			this.rLink.innerHTML = require;
-			this.rLink.href = "#" + require;
-			var rRow2 = this.rRow2.parentNode.insertBefore(this.rRow2.cloneNode(true), this.rRow2);
-			rRow2.style.display = "";
-			appends.push(rRow2);
-		}
-		var rRow = this.rRow.parentNode.insertBefore(this.rRow.cloneNode(true), this.rRow);
-		rRow.style.display = "";
-		appends.push(rRow);
-	}
-	if (hasRequires) {
-		appends.push(this.packageSave.appendChild(this.requires.cloneNode(true)));
-	}
-	if (results.size) {
-		for (var i = 0, method; method = methods[i]; i++) {
-			this.mLink.innerHTML = method.name;
-			this.mLink.href = "#" + method.name;
-			this.mDesc.parentNode.style.display = "none";
-			if (method.summary) {
-				this.mDesc.parentNode.style.display = "inline";
-				this.mDesc.innerHTML = method.summary;
-			}
-			var mRow = this.mRow.parentNode.insertBefore(this.mRow.cloneNode(true), this.mRow);
-			mRow.style.display = "";
-			appends.push(mRow);
-		}
-		appends.push(this.packageSave.appendChild(this.methods.cloneNode(true)));
-	}
-	this.domNode.appendChild(this.packageSave);
-	this.pkgDescription.innerHTML = description;
-	function makeSelect(fOrP, x) {
-		return function (e) {
-			dojo.event.topic.publish("/docs/" + fOrP + "/select", x);
-		};
-	}
-	var as = this.domNode.getElementsByTagName("a");
-	for (var i = 0, a; a = as[i]; i++) {
-		if (a.className == "docMLink") {
-			dojo.event.connect(a, "onclick", makeSelect("function", methods[i]));
-		} else {
-			if (a.className == "docRLink") {
-				dojo.event.connect(a, "onclick", makeSelect("package", requireLinks[i]));
-			}
-		}
-	}
-}, onDocResults:function (fns) {
-	dojo.debug("onDocResults(): called");
-	if (fns.length == 1) {
-		dojo.event.topic.publish("/docs/function/select", fns[0]);
-		return;
-	}
-	dojo.html.removeChildren(this.domNode);
-	this.count.innerHTML = fns.length;
-	var appends = [];
-	for (var i = 0, fn; fn = fns[i]; i++) {
-		this.fnLink.innerHTML = fn.name;
-		this.fnLink.href = "#" + fn.name;
-		if (fn.id) {
-			this.fnLink.href = this.fnLink.href + "," + fn.id;
-		}
-		this.summary.parentNode.style.display = "none";
-		if (fn.summary) {
-			this.summary.parentNode.style.display = "inline";
-			this.summary.innerHTML = fn.summary;
-		}
-		appends.push(this.rowParent.appendChild(this.rowSave.cloneNode(true)));
-	}
-	function makeSelect(x) {
-		return function (e) {
-			dojo.event.topic.publish("/docs/function/select", x);
-		};
-	}
-	this.domNode.appendChild(this.resultSave.cloneNode(true));
-	var as = this.domNode.getElementsByTagName("a");
-	for (var i = 0, a; a = as[i]; i++) {
-		dojo.event.connect(a, "onclick", makeSelect(fns[i]));
-	}
-	for (var i = 0, append; append = appends[i]; i++) {
-		this.rowParent.removeChild(append);
-	}
-}});
-
+dojo.requireAfterIf("html", "dojo.widget.html.DocPane");

Modified: tags/parley-0.53/root/static/magic/src/widget/DomWidget.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DomWidget.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DomWidget.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,500 +8,586 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.DomWidget");
 
-
-dojo.provide("dojo.widget.DomWidget");
 dojo.require("dojo.event.*");
 dojo.require("dojo.widget.Widget");
 dojo.require("dojo.dom");
-dojo.require("dojo.html.style");
 dojo.require("dojo.xml.Parse");
 dojo.require("dojo.uri.*");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.lang.extras");
+
 dojo.widget._cssFiles = {};
 dojo.widget._cssStrings = {};
 dojo.widget._templateCache = {};
-dojo.widget.defaultStrings = {dojoRoot:dojo.hostenv.getBaseScriptUri(), dojoWidgetModuleUri:dojo.uri.moduleUri("dojo.widget"), baseScriptUri:dojo.hostenv.getBaseScriptUri()};
-dojo.widget.fillFromTemplateCache = function (obj, templatePath, templateString, avoidCache) {
+
+dojo.widget.defaultStrings = {
+	dojoRoot: dojo.hostenv.getBaseScriptUri(),
+	baseScriptUri: dojo.hostenv.getBaseScriptUri()
+};
+
+dojo.widget.buildFromTemplate = function() {
+	dojo.lang.forward("fillFromTemplateCache");
+}
+
+// static method to build from a template w/ or w/o a real widget in place
+dojo.widget.fillFromTemplateCache = function(obj, templatePath, templateCssPath, templateString, avoidCache){
+	// dojo.debug("avoidCache:", avoidCache);
 	var tpath = templatePath || obj.templatePath;
+	var cpath = templateCssPath || obj.templateCssPath;
+
+	// DEPRECATED: use Uri objects, not strings
+	if (tpath && !(tpath instanceof dojo.uri.Uri)) {
+		tpath = dojo.uri.dojoUri(tpath);
+		dojo.deprecated("templatePath should be of type dojo.uri.Uri", null, "0.4");
+	}
+	if (cpath && !(cpath instanceof dojo.uri.Uri)) {
+		cpath = dojo.uri.dojoUri(cpath);
+		dojo.deprecated("templateCssPath should be of type dojo.uri.Uri", null, "0.4");
+	}
+	
 	var tmplts = dojo.widget._templateCache;
-	if (!tpath && !obj["widgetType"]) {
+	if(!obj["widgetType"]) { // don't have a real template here
 		do {
 			var dummyName = "__dummyTemplate__" + dojo.widget._templateCache.dummyCount++;
-		} while (tmplts[dummyName]);
+		} while(tmplts[dummyName]);
 		obj.widgetType = dummyName;
 	}
-	var wt = tpath ? tpath.toString() : obj.widgetType;
+	var wt = obj.widgetType;
+
+	if(cpath && !dojo.widget._cssFiles[cpath.toString()]){
+		if((!obj.templateCssString)&&(cpath)){
+			obj.templateCssString = dojo.hostenv.getText(cpath);
+			obj.templateCssPath = null;
+		}
+		if((obj["templateCssString"])&&(!obj.templateCssString["loaded"])){
+			dojo.style.insertCssText(obj.templateCssString, null, cpath);
+			if(!obj.templateCssString){ obj.templateCssString = ""; }
+			obj.templateCssString.loaded = true;
+		}
+		dojo.widget._cssFiles[cpath.toString()] = true;
+	}
+
 	var ts = tmplts[wt];
-	if (!ts) {
-		tmplts[wt] = {"string":null, "node":null};
-		if (avoidCache) {
+	if(!ts){
+		tmplts[wt] = { "string": null, "node": null };
+		if(avoidCache){
 			ts = {};
-		} else {
+		}else{
 			ts = tmplts[wt];
 		}
 	}
-	if ((!obj.templateString) && (!avoidCache)) {
+	if((!obj.templateString)&&(!avoidCache)){
 		obj.templateString = templateString || ts["string"];
 	}
-	if (obj.templateString) {
-		obj.templateString = this._sanitizeTemplateString(obj.templateString);
-	}
-	if ((!obj.templateNode) && (!avoidCache)) {
+	if((!obj.templateNode)&&(!avoidCache)){
 		obj.templateNode = ts["node"];
 	}
-	if ((!obj.templateNode) && (!obj.templateString) && (tpath)) {
-		var tstring = this._sanitizeTemplateString(dojo.hostenv.getText(tpath));
+	if((!obj.templateNode)&&(!obj.templateString)&&(tpath)){
+		// fetch a text fragment and assign it to templateString
+		// NOTE: we rely on blocking IO here!
+		var tstring = dojo.hostenv.getText(tpath);
+		if(tstring){
+			// strip <?xml ...?> declarations so that external SVG and XML
+			// documents can be added to a document without worry
+			tstring = tstring.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
+			var matches = tstring.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
+			if(matches){
+				tstring = matches[1];
+			}
+		}else{
+			tstring = "";
+		}
 		obj.templateString = tstring;
-		if (!avoidCache) {
+		if(!avoidCache){
 			tmplts[wt]["string"] = tstring;
 		}
 	}
-	if ((!ts["string"]) && (!avoidCache)) {
+	if((!ts["string"])&&(!avoidCache)){
 		ts.string = obj.templateString;
 	}
-};
-dojo.widget._sanitizeTemplateString = function (tString) {
-	if (tString) {
-		tString = tString.replace(/^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im, "");
-		var matches = tString.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
-		if (matches) {
-			tString = matches[1];
-		}
-	} else {
-		tString = "";
-	}
-	return tString;
-};
+}
 dojo.widget._templateCache.dummyCount = 0;
+
 dojo.widget.attachProperties = ["dojoAttachPoint", "id"];
 dojo.widget.eventAttachProperty = "dojoAttachEvent";
 dojo.widget.onBuildProperty = "dojoOnBuild";
-dojo.widget.waiNames = ["waiRole", "waiState"];
-dojo.widget.wai = {waiRole:{name:"waiRole", "namespace":"http://www.w3.org/TR/xhtml2", alias:"x2", prefix:"wairole:"}, waiState:{name:"waiState", "namespace":"http://www.w3.org/2005/07/aaa", alias:"aaa", prefix:""}, setAttr:function (node, ns, attr, value) {
-	if (dojo.render.html.ie) {
-		node.setAttribute(this[ns].alias + ":" + attr, this[ns].prefix + value);
-	} else {
-		node.setAttributeNS(this[ns]["namespace"], attr, this[ns].prefix + value);
+dojo.widget.waiNames  = ["waiRole", "waiState"];
+dojo.widget.wai = {
+	waiRole: { 	name: "waiRole", 
+				namespace: "http://www.w3.org/TR/xhtml2", 
+				alias: "x2",
+				prefix: "wairole:",
+				nsName: "role"
+	},
+	waiState: { name: "waiState", 
+				namespace: "http://www.w3.org/2005/07/aaa" , 
+				alias: "aaa",
+				prefix: "",
+				nsName: "state"
+	},
+	setAttr: function(node, attr, value){
+		if(dojo.render.html.ie){
+			node.setAttribute(this[attr].alias+":"+this[attr].nsName, this[attr].prefix+value);
+		}else{
+			node.setAttributeNS(this[attr].namespace, this[attr].nsName, this[attr].prefix+value);
+		}
 	}
-}, getAttr:function (node, ns, attr) {
-	if (dojo.render.html.ie) {
-		return node.getAttribute(this[ns].alias + ":" + attr);
-	} else {
-		return node.getAttributeNS(this[ns]["namespace"], attr);
-	}
-}, removeAttr:function (node, ns, attr) {
-	var success = true;
-	if (dojo.render.html.ie) {
-		success = node.removeAttribute(this[ns].alias + ":" + attr);
-	} else {
-		node.removeAttributeNS(this[ns]["namespace"], attr);
-	}
-	return success;
-}};
-dojo.widget.attachTemplateNodes = function (rootNode, targetObj, events) {
+};
+
+dojo.widget.attachTemplateNodes = function(rootNode, targetObj, events){
+	// FIXME: this method is still taking WAAAY too long. We need ways of optimizing:
+	//	a.) what we are looking for on each node
+	//	b.) the nodes that are subject to interrogation (use xpath instead?)
+	//	c.) how expensive event assignment is (less eval(), more connect())
+	// var start = new Date();
 	var elementNodeType = dojo.dom.ELEMENT_NODE;
-	function trim(str) {
+
+	function trim(str){
 		return str.replace(/^\s+|\s+$/g, "");
 	}
-	if (!rootNode) {
+
+	if(!rootNode){ 
 		rootNode = targetObj.domNode;
 	}
-	if (rootNode.nodeType != elementNodeType) {
+
+	if(rootNode.nodeType != elementNodeType){
 		return;
 	}
+	// alert(events.length);
+
 	var nodes = rootNode.all || rootNode.getElementsByTagName("*");
 	var _this = targetObj;
-	for (var x = -1; x < nodes.length; x++) {
+	for(var x=-1; x<nodes.length; x++){
 		var baseNode = (x == -1) ? rootNode : nodes[x];
+		// FIXME: is this going to have capitalization problems?  Could use getAttribute(name, 0); to get attributes case-insensitve
 		var attachPoint = [];
-		if (!targetObj.widgetsInTemplate || !baseNode.getAttribute("dojoType")) {
-			for (var y = 0; y < this.attachProperties.length; y++) {
-				var tmpAttachPoint = baseNode.getAttribute(this.attachProperties[y]);
-				if (tmpAttachPoint) {
-					attachPoint = tmpAttachPoint.split(";");
-					for (var z = 0; z < attachPoint.length; z++) {
-						if (dojo.lang.isArray(targetObj[attachPoint[z]])) {
-							targetObj[attachPoint[z]].push(baseNode);
-						} else {
-							targetObj[attachPoint[z]] = baseNode;
-						}
+		for(var y=0; y<this.attachProperties.length; y++){
+			var tmpAttachPoint = baseNode.getAttribute(this.attachProperties[y]);
+			if(tmpAttachPoint){
+				attachPoint = tmpAttachPoint.split(";");
+				for(var z=0; z<attachPoint.length; z++){
+					if(dojo.lang.isArray(targetObj[attachPoint[z]])){
+						targetObj[attachPoint[z]].push(baseNode);
+					}else{
+						targetObj[attachPoint[z]]=baseNode;
 					}
-					break;
 				}
+				break;
 			}
-			var attachEvent = baseNode.getAttribute(this.eventAttachProperty);
-			if (attachEvent) {
-				var evts = attachEvent.split(";");
-				for (var y = 0; y < evts.length; y++) {
-					if ((!evts[y]) || (!evts[y].length)) {
-						continue;
-					}
-					var thisFunc = null;
-					var tevt = trim(evts[y]);
-					if (evts[y].indexOf(":") >= 0) {
-						var funcNameArr = tevt.split(":");
-						tevt = trim(funcNameArr[0]);
-						thisFunc = trim(funcNameArr[1]);
-					}
-					if (!thisFunc) {
-						thisFunc = tevt;
-					}
-					var tf = function () {
-						var ntf = new String(thisFunc);
-						return function (evt) {
-							if (_this[ntf]) {
-								_this[ntf](dojo.event.browser.fixEvent(evt, this));
-							}
-						};
-					}();
-					dojo.event.browser.addListener(baseNode, tevt, tf, false, true);
-				}
-			}
-			for (var y = 0; y < events.length; y++) {
-				var evtVal = baseNode.getAttribute(events[y]);
-				if ((evtVal) && (evtVal.length)) {
-					var thisFunc = null;
-					var domEvt = events[y].substr(4);
-					thisFunc = trim(evtVal);
-					var funcs = [thisFunc];
-					if (thisFunc.indexOf(";") >= 0) {
-						funcs = dojo.lang.map(thisFunc.split(";"), trim);
-					}
-					for (var z = 0; z < funcs.length; z++) {
-						if (!funcs[z].length) {
-							continue;
-						}
-						var tf = function () {
-							var ntf = new String(funcs[z]);
-							return function (evt) {
-								if (_this[ntf]) {
-									_this[ntf](dojo.event.browser.fixEvent(evt, this));
-								}
-							};
-						}();
-						dojo.event.browser.addListener(baseNode, domEvt, tf, false, true);
-					}
-				}
-			}
 		}
+		// continue;
+
+		// FIXME: we need to put this into some kind of lookup structure
+		// instead of direct assignment
 		var tmpltPoint = baseNode.getAttribute(this.templateProperty);
-		if (tmpltPoint) {
-			targetObj[tmpltPoint] = baseNode;
+		if(tmpltPoint){
+			targetObj[tmpltPoint]=baseNode;
 		}
-		dojo.lang.forEach(dojo.widget.waiNames, function (name) {
+
+		dojo.lang.forEach(dojo.widget.waiNames, function(name){
 			var wai = dojo.widget.wai[name];
 			var val = baseNode.getAttribute(wai.name);
-			if (val) {
-				if (val.indexOf("-") == -1) {
-					dojo.widget.wai.setAttr(baseNode, wai.name, "role", val);
-				} else {
-					var statePair = val.split("-");
-					dojo.widget.wai.setAttr(baseNode, wai.name, statePair[0], statePair[1]);
+			if(val){
+				dojo.widget.wai.setAttr(baseNode, wai.name, val);
+			}
+		}, this);
+
+		var attachEvent = baseNode.getAttribute(this.eventAttachProperty);
+		if(attachEvent){
+			// NOTE: we want to support attributes that have the form
+			// "domEvent: nativeEvent; ..."
+			var evts = attachEvent.split(";");
+			for(var y=0; y<evts.length; y++){
+				if((!evts[y])||(!evts[y].length)){ continue; }
+				var thisFunc = null;
+				var tevt = trim(evts[y]);
+				if(evts[y].indexOf(":") >= 0){
+					// oh, if only JS had tuple assignment
+					var funcNameArr = tevt.split(":");
+					tevt = trim(funcNameArr[0]);
+					thisFunc = trim(funcNameArr[1]);
 				}
+				if(!thisFunc){
+					thisFunc = tevt;
+				}
+
+				var tf = function(){ 
+					var ntf = new String(thisFunc);
+					return function(evt){
+						if(_this[ntf]){
+							_this[ntf](dojo.event.browser.fixEvent(evt, this));
+						}
+					};
+				}();
+				dojo.event.browser.addListener(baseNode, tevt, tf, false, true);
+				// dojo.event.browser.addListener(baseNode, tevt, dojo.lang.hitch(_this, thisFunc));
 			}
-		}, this);
+		}
+
+		for(var y=0; y<events.length; y++){
+			//alert(events[x]);
+			var evtVal = baseNode.getAttribute(events[y]);
+			if((evtVal)&&(evtVal.length)){
+				var thisFunc = null;
+				var domEvt = events[y].substr(4); // clober the "dojo" prefix
+				thisFunc = trim(evtVal);
+				var funcs = [thisFunc];
+				if(thisFunc.indexOf(";")>=0){
+					funcs = dojo.lang.map(thisFunc.split(";"), trim);
+				}
+				for(var z=0; z<funcs.length; z++){
+					if(!funcs[z].length){ continue; }
+					var tf = function(){ 
+						var ntf = new String(funcs[z]);
+						return function(evt){
+							if(_this[ntf]){
+								_this[ntf](dojo.event.browser.fixEvent(evt, this));
+							}
+						}
+					}();
+					dojo.event.browser.addListener(baseNode, domEvt, tf, false, true);
+					// dojo.event.browser.addListener(baseNode, domEvt, dojo.lang.hitch(_this, funcs[z]));
+				}
+			}
+		}
+
 		var onBuild = baseNode.getAttribute(this.onBuildProperty);
-		if (onBuild) {
-			eval("var node = baseNode; var widget = targetObj; " + onBuild);
+		if(onBuild){
+			eval("var node = baseNode; var widget = targetObj; "+onBuild);
 		}
 	}
-};
-dojo.widget.getDojoEventsFromStr = function (str) {
+
+}
+
+dojo.widget.getDojoEventsFromStr = function(str){
+	// var lstr = str.toLowerCase();
 	var re = /(dojoOn([a-z]+)(\s?))=/gi;
-	var evts = str ? str.match(re) || [] : [];
+	var evts = str ? str.match(re)||[] : [];
 	var ret = [];
 	var lem = {};
-	for (var x = 0; x < evts.length; x++) {
-		if (evts[x].length < 1) {
-			continue;
-		}
+	for(var x=0; x<evts.length; x++){
+		if(evts[x].legth < 1){ continue; }
 		var cm = evts[x].replace(/\s/, "");
-		cm = (cm.slice(0, cm.length - 1));
-		if (!lem[cm]) {
+		cm = (cm.slice(0, cm.length-1));
+		if(!lem[cm]){
 			lem[cm] = true;
 			ret.push(cm);
 		}
 	}
 	return ret;
-};
-dojo.declare("dojo.widget.DomWidget", dojo.widget.Widget, function () {
-	if ((arguments.length > 0) && (typeof arguments[0] == "object")) {
-		this.create(arguments[0]);
-	}
-}, {templateNode:null, templateString:null, templateCssString:null, preventClobber:false, domNode:null, containerNode:null, widgetsInTemplate:false, addChild:function (widget, overrideContainerNode, pos, ref, insertIndex) {
-	if (!this.isContainer) {
-		dojo.debug("dojo.widget.DomWidget.addChild() attempted on non-container widget");
-		return null;
-	} else {
-		if (insertIndex == undefined) {
-			insertIndex = this.children.length;
+}
+
+/*
+dojo.widget.buildAndAttachTemplate = function(obj, templatePath, templateCssPath, templateString, targetObj) {
+	this.buildFromTemplate(obj, templatePath, templateCssPath, templateString);
+	var node = dojo.dom.createNodesFromText(obj.templateString, true)[0];
+	this.attachTemplateNodes(node, targetObj||obj, dojo.widget.getDojoEventsFromStr(templateString));
+	return node;
+}
+*/
+
+dojo.declare("dojo.widget.DomWidget", dojo.widget.Widget, {
+	initializer: function() {
+		if((arguments.length>0)&&(typeof arguments[0] == "object")){
+			this.create(arguments[0]);
 		}
-		this.addWidgetAsDirectChild(widget, overrideContainerNode, pos, ref, insertIndex);
-		this.registerChild(widget, insertIndex);
-	}
-	return widget;
-}, addWidgetAsDirectChild:function (widget, overrideContainerNode, pos, ref, insertIndex) {
-	if ((!this.containerNode) && (!overrideContainerNode)) {
-		this.containerNode = this.domNode;
-	}
-	var cn = (overrideContainerNode) ? overrideContainerNode : this.containerNode;
-	if (!pos) {
-		pos = "after";
-	}
-	if (!ref) {
-		if (!cn) {
-			cn = dojo.body();
+	},
+								 
+	templateNode: null,
+	templateString: null,
+	templateCssString: null,
+	preventClobber: false,
+	domNode: null, // this is our visible representation of the widget!
+	containerNode: null, // holds child elements
+
+	// Process the given child widget, inserting it's dom node as a child of our dom node
+	// FIXME: should we support addition at an index in the children arr and
+	// order the display accordingly? Right now we always append.
+	addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+		if(!this.isContainer){ // we aren't allowed to contain other widgets, it seems
+			dojo.debug("dojo.widget.DomWidget.addChild() attempted on non-container widget");
+			return null;
+		}else{
+			this.addWidgetAsDirectChild(widget, overrideContainerNode, pos, ref, insertIndex);
+			this.registerChild(widget, insertIndex);
 		}
-		ref = cn.lastChild;
-	}
-	if (!insertIndex) {
-		insertIndex = 0;
-	}
-	widget.domNode.setAttribute("dojoinsertionindex", insertIndex);
-	if (!ref) {
-		cn.appendChild(widget.domNode);
-	} else {
-		if (pos == "insertAtIndex") {
-			dojo.dom.insertAtIndex(widget.domNode, ref.parentNode, insertIndex);
-		} else {
-			if ((pos == "after") && (ref === cn.lastChild)) {
-				cn.appendChild(widget.domNode);
-			} else {
-				dojo.dom.insertAtPosition(widget.domNode, cn, pos);
-			}
+		return widget;
+	},
+	
+	addWidgetAsDirectChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+		if((!this.containerNode)&&(!overrideContainerNode)){
+			this.containerNode = this.domNode;
 		}
-	}
-}, registerChild:function (widget, insertionIndex) {
-	widget.dojoInsertionIndex = insertionIndex;
-	var idx = -1;
-	for (var i = 0; i < this.children.length; i++) {
-		if (this.children[i].dojoInsertionIndex <= insertionIndex) {
-			idx = i;
+		var cn = (overrideContainerNode) ? overrideContainerNode : this.containerNode;
+		if(!pos){ pos = "after"; }
+		if(!ref){ 
+			// if(!cn){ cn = document.body; }
+			if(!cn){ cn = document.body; }
+			ref = cn.lastChild; 
 		}
-	}
-	this.children.splice(idx + 1, 0, widget);
-	widget.parent = this;
-	widget.addedTo(this, idx + 1);
-	delete dojo.widget.manager.topWidgets[widget.widgetId];
-}, removeChild:function (widget) {
-	dojo.dom.removeNode(widget.domNode);
-	return dojo.widget.DomWidget.superclass.removeChild.call(this, widget);
-}, getFragNodeRef:function (frag) {
-	if (!frag) {
-		return null;
-	}
-	if (!frag[this.getNamespacedType()]) {
-		dojo.raise("Error: no frag for widget type " + this.getNamespacedType() + ", id " + this.widgetId + " (maybe a widget has set it's type incorrectly)");
-	}
-	return frag[this.getNamespacedType()]["nodeRef"];
-}, postInitialize:function (args, frag, parentComp) {
-	var sourceNodeRef = this.getFragNodeRef(frag);
-	if (parentComp && (parentComp.snarfChildDomOutput || !sourceNodeRef)) {
-		parentComp.addWidgetAsDirectChild(this, "", "insertAtIndex", "", args["dojoinsertionindex"], sourceNodeRef);
-	} else {
-		if (sourceNodeRef) {
-			if (this.domNode && (this.domNode !== sourceNodeRef)) {
-				this._sourceNodeRef = dojo.dom.replaceNode(sourceNodeRef, this.domNode);
+		if(!insertIndex) { insertIndex = 0; }
+		widget.domNode.setAttribute("dojoinsertionindex", insertIndex);
+
+		// insert the child widget domNode directly underneath my domNode, in the
+		// specified position (by default, append to end)
+		if(!ref){
+			cn.appendChild(widget.domNode);
+		}else{
+			// FIXME: was this meant to be the (ugly hack) way to support insert @ index?
+			//dojo.dom[pos](widget.domNode, ref, insertIndex);
+
+			// CAL: this appears to be the intended way to insert a node at a given position...
+			if (pos == 'insertAtIndex'){
+				// dojo.debug("idx:", insertIndex, "isLast:", ref === cn.lastChild);
+				dojo.dom.insertAtIndex(widget.domNode, ref.parentNode, insertIndex);
+			}else{
+				// dojo.debug("pos:", pos, "isLast:", ref === cn.lastChild);
+				if((pos == "after")&&(ref === cn.lastChild)){
+					cn.appendChild(widget.domNode);
+				}else{
+					dojo.dom.insertAtPosition(widget.domNode, cn, pos);
+				}
 			}
 		}
-	}
-	if (parentComp) {
-		parentComp.registerChild(this, args.dojoinsertionindex);
-	} else {
-		dojo.widget.manager.topWidgets[this.widgetId] = this;
-	}
-	if (this.widgetsInTemplate) {
-		var parser = new dojo.xml.Parse();
-		var subContainerNode;
-		var subnodes = this.domNode.getElementsByTagName("*");
-		for (var i = 0; i < subnodes.length; i++) {
-			if (subnodes[i].getAttribute("dojoAttachPoint") == "subContainerWidget") {
-				subContainerNode = subnodes[i];
+	},
+
+	// Record that given widget descends from me
+	registerChild: function(widget, insertionIndex){
+
+		// we need to insert the child at the right point in the parent's 
+		// 'children' array, based on the insertionIndex
+
+		widget.dojoInsertionIndex = insertionIndex;
+
+		var idx = -1;
+		for(var i=0; i<this.children.length; i++){
+			if (this.children[i].dojoInsertionIndex < insertionIndex){
+				idx = i;
 			}
-			if (subnodes[i].getAttribute("dojoType")) {
-				subnodes[i].setAttribute("isSubWidget", true);
-			}
 		}
-		if (this.isContainer && !this.containerNode) {
-			if (subContainerNode) {
-				var src = this.getFragNodeRef(frag);
-				if (src) {
-					dojo.dom.moveChildren(src, subContainerNode);
-					frag["dojoDontFollow"] = true;
-				}
-			} else {
-				dojo.debug("No subContainerWidget node can be found in template file for widget " + this);
-			}
+
+		this.children.splice(idx+1, 0, widget);
+
+		widget.parent = this;
+		widget.addedTo(this);
+		
+		// If this widget was created programatically, then it was erroneously added
+		// to dojo.widget.manager.topWidgets.  Fix that here.
+		delete dojo.widget.manager.topWidgets[widget.widgetId];
+	},
+
+	removeChild: function(widget){
+		// detach child domNode from parent domNode
+		dojo.dom.removeNode(widget.domNode);
+
+		// remove child widget from parent widget
+		return dojo.widget.DomWidget.superclass.removeChild.call(this, widget);
+	},
+
+	getFragNodeRef: function(frag){
+		if( !frag || !frag["dojo:"+this.widgetType.toLowerCase()] ){
+			dojo.raise("Error: no frag for widget type " + this.widgetType +
+				", id " + this.widgetId + " (maybe a widget has set it's type incorrectly)");
 		}
-		var templatefrag = parser.parseElement(this.domNode, null, true);
-		dojo.widget.getParser().createSubComponents(templatefrag, this);
-		var subwidgets = [];
-		var stack = [this];
-		var w;
-		while ((w = stack.pop())) {
-			for (var i = 0; i < w.children.length; i++) {
-				var cwidget = w.children[i];
-				if (cwidget._processedSubWidgets || !cwidget.extraArgs["issubwidget"]) {
-					continue;
-				}
-				subwidgets.push(cwidget);
-				if (cwidget.isContainer) {
-					stack.push(cwidget);
-				}
+		return (frag ? frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"] : null);
+	},
+	
+	// Replace source domNode with generated dom structure, and register
+	// widget with parent.
+	postInitialize: function(args, frag, parentComp){
+		var sourceNodeRef = this.getFragNodeRef(frag);
+		// Stick my generated dom into the output tree
+		//alert(this.widgetId + ": replacing " + sourceNodeRef + " with " + this.domNode.innerHTML);
+		if (parentComp && (parentComp.snarfChildDomOutput || !sourceNodeRef)){
+			// Add my generated dom as a direct child of my parent widget
+			// This is important for generated widgets, and also cases where I am generating an
+			// <li> node that can't be inserted back into the original DOM tree
+			parentComp.addWidgetAsDirectChild(this, "", "insertAtIndex", "",  args["dojoinsertionindex"], sourceNodeRef);
+		} else if (sourceNodeRef){
+			// Do in-place replacement of the my source node with my generated dom
+			if(this.domNode && (this.domNode !== sourceNodeRef)){
+				var oldNode = sourceNodeRef.parentNode.replaceChild(this.domNode, sourceNodeRef);
 			}
 		}
-		for (var i = 0; i < subwidgets.length; i++) {
-			var widget = subwidgets[i];
-			if (widget._processedSubWidgets) {
-				dojo.debug("This should not happen: widget._processedSubWidgets is already true!");
-				return;
-			}
-			widget._processedSubWidgets = true;
-			if (widget.extraArgs["dojoattachevent"]) {
-				var evts = widget.extraArgs["dojoattachevent"].split(";");
-				for (var j = 0; j < evts.length; j++) {
-					var thisFunc = null;
-					var tevt = dojo.string.trim(evts[j]);
-					if (tevt.indexOf(":") >= 0) {
-						var funcNameArr = tevt.split(":");
-						tevt = dojo.string.trim(funcNameArr[0]);
-						thisFunc = dojo.string.trim(funcNameArr[1]);
-					}
-					if (!thisFunc) {
-						thisFunc = tevt;
-					}
-					if (dojo.lang.isFunction(widget[tevt])) {
-						dojo.event.kwConnect({srcObj:widget, srcFunc:tevt, targetObj:this, targetFunc:thisFunc});
-					} else {
-						alert(tevt + " is not a function in widget " + widget);
-					}
-				}
-			}
-			if (widget.extraArgs["dojoattachpoint"]) {
-				this[widget.extraArgs["dojoattachpoint"]] = widget;
-			}
+
+		// Register myself with my parent, or with the widget manager if
+		// I have no parent
+		// TODO: the code below erroneously adds all programatically generated widgets
+		// to topWidgets (since we don't know who the parent is until after creation finishes)
+		if ( parentComp ) {
+			parentComp.registerChild(this, args.dojoinsertionindex);
+		} else {
+			dojo.widget.manager.topWidgets[this.widgetId]=this;
 		}
-	}
-	if (this.isContainer && !frag["dojoDontFollow"]) {
-		dojo.widget.getParser().createSubComponents(frag, this);
-	}
-}, buildRendering:function (args, frag) {
-	var ts = dojo.widget._templateCache[this.widgetType];
-	if (args["templatecsspath"]) {
-		args["templateCssPath"] = args["templatecsspath"];
-	}
-	var cpath = args["templateCssPath"] || this.templateCssPath;
-	if (cpath && !dojo.widget._cssFiles[cpath.toString()]) {
-		if ((!this.templateCssString) && (cpath)) {
-			this.templateCssString = dojo.hostenv.getText(cpath);
-			this.templateCssPath = null;
+
+		// Expand my children widgets
+		if(this.isContainer){
+			//alert("recurse from " + this.widgetId);
+			// build any sub-components with us as the parent
+			var fragParser = dojo.widget.getParser();
+			fragParser.createSubComponents(frag, this);
 		}
-		dojo.widget._cssFiles[cpath.toString()] = true;
-	}
-	if ((this["templateCssString"]) && (!dojo.widget._cssStrings[this.templateCssString])) {
-		dojo.html.insertCssText(this.templateCssString, null, cpath);
-		dojo.widget._cssStrings[this.templateCssString] = true;
-	}
-	if ((!this.preventClobber) && ((this.templatePath) || (this.templateNode) || ((this["templateString"]) && (this.templateString.length)) || ((typeof ts != "undefined") && ((ts["string"]) || (ts["node"]))))) {
-		this.buildFromTemplate(args, frag);
-	} else {
-		this.domNode = this.getFragNodeRef(frag);
-	}
-	this.fillInTemplate(args, frag);
-}, buildFromTemplate:function (args, frag) {
-	var avoidCache = false;
-	if (args["templatepath"]) {
-		args["templatePath"] = args["templatepath"];
-	}
-	dojo.widget.fillFromTemplateCache(this, args["templatePath"], null, avoidCache);
-	var ts = dojo.widget._templateCache[this.templatePath ? this.templatePath.toString() : this.widgetType];
-	if ((ts) && (!avoidCache)) {
-		if (!this.templateString.length) {
-			this.templateString = ts["string"];
+	},
+
+	// method over-ride
+	buildRendering: function(args, frag){
+		// DOM widgets construct themselves from a template
+		var ts = dojo.widget._templateCache[this.widgetType];
+		if(	
+			(!this.preventClobber)&&(
+				(this.templatePath)||
+				(this.templateNode)||
+				(
+					(this["templateString"])&&(this.templateString.length) 
+				)||
+				(
+					(typeof ts != "undefined")&&( (ts["string"])||(ts["node"]) )
+				)
+			)
+		){
+			// if it looks like we can build the thing from a template, do it!
+			this.buildFromTemplate(args, frag);
+		}else{
+			// otherwise, assign the DOM node that was the source of the widget
+			// parsing to be the root node
+			this.domNode = this.getFragNodeRef(frag);
 		}
-		if (!this.templateNode) {
-			this.templateNode = ts["node"];
+		this.fillInTemplate(args, frag); 	// this is where individual widgets
+											// will handle population of data
+											// from properties, remote data
+											// sets, etc.
+	},
+
+	buildFromTemplate: function(args, frag){
+		// var start = new Date();
+		// copy template properties if they're already set in the templates object
+		// dojo.debug("buildFromTemplate:", this);
+		var avoidCache = false;
+		if(args["templatecsspath"]){
+			args["templateCssPath"] = args["templatecsspath"];
 		}
-	}
-	var matches = false;
-	var node = null;
-	var tstr = this.templateString;
-	if ((!this.templateNode) && (this.templateString)) {
-		matches = this.templateString.match(/\$\{([^\}]+)\}/g);
-		if (matches) {
-			var hash = this.strings || {};
-			for (var key in dojo.widget.defaultStrings) {
-				if (dojo.lang.isUndefined(hash[key])) {
-					hash[key] = dojo.widget.defaultStrings[key];
-				}
+		if(args["templatepath"]){
+			avoidCache = true;
+			args["templatePath"] = args["templatepath"];
+		}
+		dojo.widget.fillFromTemplateCache(	this, 
+											args["templatePath"], 
+											args["templateCssPath"],
+											null,
+											avoidCache);
+		var ts = dojo.widget._templateCache[this.widgetType];
+		if((ts)&&(!avoidCache)){
+			if(!this.templateString.length){
+				this.templateString = ts["string"];
 			}
-			for (var i = 0; i < matches.length; i++) {
-				var key = matches[i];
-				key = key.substring(2, key.length - 1);
-				var kval = (key.substring(0, 5) == "this.") ? dojo.lang.getObjPathValue(key.substring(5), this) : hash[key];
-				var value;
-				if ((kval) || (dojo.lang.isString(kval))) {
-					value = new String((dojo.lang.isFunction(kval)) ? kval.call(this, key, this.templateString) : kval);
-					while (value.indexOf("\"") > -1) {
-						value = value.replace("\"", "&quot;");
+			if(!this.templateNode){
+				this.templateNode = ts["node"];
+			}
+		}
+		var matches = false;
+		var node = null;
+		// var tstr = new String(this.templateString); 
+		var tstr = this.templateString; 
+		// attempt to clone a template node, if there is one
+		if((!this.templateNode)&&(this.templateString)){
+			matches = this.templateString.match(/\$\{([^\}]+)\}/g);
+			if(matches) {
+				// if we do property replacement, don't create a templateNode
+				// to clone from.
+				var hash = this.strings || {};
+				// FIXME: should this hash of default replacements be cached in
+				// templateString?
+				for(var key in dojo.widget.defaultStrings) {
+					if(dojo.lang.isUndefined(hash[key])) {
+						hash[key] = dojo.widget.defaultStrings[key];
 					}
-					tstr = tstr.replace(matches[i], value);
 				}
+				// FIXME: this is a lot of string munging. Can we make it faster?
+				for(var i = 0; i < matches.length; i++) {
+					var key = matches[i];
+					key = key.substring(2, key.length-1);
+					var kval = (key.substring(0, 5) == "this.") ? dojo.lang.getObjPathValue(key.substring(5), this) : hash[key];
+					var value;
+					if((kval)||(dojo.lang.isString(kval))){
+						value = (dojo.lang.isFunction(kval)) ? kval.call(this, key, this.templateString) : kval;
+						tstr = tstr.replace(matches[i], value);
+					}
+				}
+			}else{
+				// otherwise, we are required to instantiate a copy of the template
+				// string if one is provided.
+				
+				// FIXME: need to be able to distinguish here what should be done
+				// or provide a generic interface across all DOM implementations
+				// FIMXE: this breaks if the template has whitespace as its first 
+				// characters
+				// node = this.createNodesFromText(this.templateString, true);
+				// this.templateNode = node[0].cloneNode(true); // we're optimistic here
+				this.templateNode = this.createNodesFromText(this.templateString, true)[0];
+				if(!avoidCache){
+					ts.node = this.templateNode;
+				}
 			}
-		} else {
-			this.templateNode = this.createNodesFromText(this.templateString, true)[0];
-			if (!avoidCache) {
-				ts.node = this.templateNode;
-			}
 		}
-	}
-	if ((!this.templateNode) && (!matches)) {
-		dojo.debug("DomWidget.buildFromTemplate: could not create template");
-		return false;
-	} else {
-		if (!matches) {
+		if((!this.templateNode)&&(!matches)){ 
+			dojo.debug("weren't able to create template!");
+			return false;
+		}else if(!matches){
 			node = this.templateNode.cloneNode(true);
-			if (!node) {
-				return false;
-			}
-		} else {
+			if(!node){ return false; }
+		}else{
 			node = this.createNodesFromText(tstr, true)[0];
 		}
-	}
-	this.domNode = node;
-	this.attachTemplateNodes();
-	if (this.isContainer && this.containerNode) {
-		var src = this.getFragNodeRef(frag);
-		if (src) {
-			dojo.dom.moveChildren(src, this.containerNode);
+
+		// recurse through the node, looking for, and attaching to, our
+		// attachment points which should be defined on the template node.
+
+		this.domNode = node;
+		// dojo.profile.start("attachTemplateNodes");
+		this.attachTemplateNodes(this.domNode, this);
+		// dojo.profile.end("attachTemplateNodes");
+		
+		// relocate source contents to templated container node
+		// this.containerNode must be able to receive children, or exceptions will be thrown
+		if (this.isContainer && this.containerNode){
+			var src = this.getFragNodeRef(frag);
+			if (src){
+				dojo.dom.moveChildren(src, this.containerNode);
+			}
 		}
+	},
+
+	attachTemplateNodes: function(baseNode, targetObj){
+		if(!targetObj){ targetObj = this; }
+		return dojo.widget.attachTemplateNodes(baseNode, targetObj, 
+					dojo.widget.getDojoEventsFromStr(this.templateString));
+	},
+
+	fillInTemplate: function(){
+		// dojo.unimplemented("dojo.widget.DomWidget.fillInTemplate");
+	},
+	
+	// method over-ride
+	destroyRendering: function(){
+		try{
+			delete this.domNode;
+		}catch(e){ /* squelch! */ }
+	},
+
+	// FIXME: method over-ride
+	cleanUp: function(){},
+	
+	getContainerHeight: function(){
+		dojo.unimplemented("dojo.widget.DomWidget.getContainerHeight");
+	},
+
+	getContainerWidth: function(){
+		dojo.unimplemented("dojo.widget.DomWidget.getContainerWidth");
+	},
+
+	createNodesFromText: function(){
+		dojo.unimplemented("dojo.widget.DomWidget.createNodesFromText");
 	}
-}, attachTemplateNodes:function (baseNode, targetObj) {
-	if (!baseNode) {
-		baseNode = this.domNode;
-	}
-	if (!targetObj) {
-		targetObj = this;
-	}
-	return dojo.widget.attachTemplateNodes(baseNode, targetObj, dojo.widget.getDojoEventsFromStr(this.templateString));
-}, fillInTemplate:function () {
-}, destroyRendering:function () {
-	try {
-		dojo.dom.destroyNode(this.domNode);
-		delete this.domNode;
-	}
-	catch (e) {
-	}
-	if (this._sourceNodeRef) {
-		try {
-			dojo.dom.destroyNode(this._sourceNodeRef);
-		}
-		catch (e) {
-		}
-	}
-}, createNodesFromText:function () {
-	dojo.unimplemented("dojo.widget.DomWidget.createNodesFromText");
-}});
-
+});

Added: tags/parley-0.53/root/static/magic/src/widget/DropdownButton.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DropdownButton.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DropdownButton.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,29 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.DropdownButton");
+
+dojo.deprecated("dojo.widget.DropdownButton",  "use dojo.widget.ComboButton", "0.4");
+
+// Draws a button with a down arrow;
+// when you press the down arrow something appears (usually a menu)
+
+dojo.require("dojo.widget.*");
+
+dojo.widget.tags.addParseTreeHandler("dojo:dropdownbutton");
+
+dojo.widget.DropdownButton = function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = "DropdownButton";
+}
+dojo.inherits(dojo.widget.DropdownButton, dojo.widget.Widget);
+
+dojo.requireAfterIf("html", "dojo.widget.html.DropdownButton");

Modified: tags/parley-0.53/root/static/magic/src/widget/DropdownContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DropdownContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DropdownContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,58 +8,111 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.DropdownContainer");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.PopupContainer");
 dojo.require("dojo.event.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.iframe");
-dojo.require("dojo.html.util");
-dojo.widget.defineWidget("dojo.widget.DropdownContainer", dojo.widget.HtmlWidget, {inputWidth:"7em", id:"", inputId:"", inputName:"", iconURL:dojo.uri.moduleUri("dojo.widget", "templates/images/combo_box_arrow.png"), copyClasses:false, iconAlt:"", containerToggle:"plain", containerToggleDuration:150, templateString:"<span style=\"white-space:nowrap\"><input type=\"hidden\" name=\"\" value=\"\" dojoAttachPoint=\"valueNode\" /><input name=\"\" type=\"text\" value=\"\" style=\"vertical-align:middle;\" dojoAttachPoint=\"inputNode\" autocomplete=\"off\" /> <img src=\"${this.iconURL}\" alt=\"${this.iconAlt}\" dojoAttachEvent=\"onclick:onIconClick\" dojoAttachPoint=\"buttonNode\" style=\"vertical-align:middle; cursor:pointer; cursor:hand\" /></span>", templateCssPath:"", isContainer:true, attachTemplateNodes:function () {
-	dojo.widget.DropdownContainer.superclass.attachTemplateNodes.apply(this, arguments);
-	this.popup = dojo.widget.createWidget("PopupContainer", {toggle:this.containerToggle, toggleDuration:this.containerToggleDuration});
-	this.containerNode = this.popup.domNode;
-}, fillInTemplate:function (args, frag) {
-	this.domNode.appendChild(this.popup.domNode);
-	if (this.id) {
-		this.domNode.id = this.id;
-	}
-	if (this.inputId) {
-		this.inputNode.id = this.inputId;
-	}
-	if (this.inputName) {
-		this.inputNode.name = this.inputName;
-	}
-	this.inputNode.style.width = this.inputWidth;
-	this.inputNode.disabled = this.disabled;
-	if (this.copyClasses) {
-		this.inputNode.style = "";
-		this.inputNode.className = this.getFragNodeRef(frag).className;
-	}
-	dojo.event.connect(this.inputNode, "onchange", this, "onInputChange");
-}, onIconClick:function (evt) {
-	if (this.disabled) {
-		return;
-	}
-	if (!this.popup.isShowingNow) {
-		this.popup.open(this.inputNode, this, this.buttonNode);
-	} else {
-		this.popup.close();
-	}
-}, hideContainer:function () {
-	if (this.popup.isShowingNow) {
-		this.popup.close();
-	}
-}, onInputChange:function () {
-}, enable:function () {
-	this.inputNode.disabled = false;
-	dojo.widget.DropdownContainer.superclass.enable.apply(this, arguments);
-}, disable:function () {
-	this.inputNode.disabled = true;
-	dojo.widget.DropdownContainer.superclass.disable.apply(this, arguments);
-}});
+dojo.require("dojo.html");
 
+dojo.widget.defineWidget(
+	"dojo.widget.DropdownContainer",
+	dojo.widget.HtmlWidget,
+	{
+		initializer: function(){
+		},
+
+		inputWidth: "7em",
+		inputId: "",
+		inputName: "",
+		iconURL: dojo.uri.dojoUri("src/widget/templates/images/combo_box_arrow.png"),
+		iconAlt: "",
+
+		inputNode: null,
+		buttonNode: null,
+		containerNode: null,
+		subWidgetNode: null,
+
+		containerToggle: "plain",
+		containerToggleDuration: 150,
+		containerAnimInProgress: false,
+
+		templateString: '<div><span style="white-space:nowrap"><input type="text" value="" style="vertical-align:middle;" dojoAttachPoint="inputNode" autocomplete="off" /> <img src="${this.iconURL}" alt="${this.iconAlt}" dojoAttachPoint="buttonNode" dojoAttachEvent="onclick: onIconClick;" style="vertical-align:middle; cursor:pointer; cursor:hand;" /></span><br /><div dojoAttachPoint="containerNode" style="display:none;position:absolute;width:12em;background-color:#fff;"></div></div>',
+		templateCssPath: "",
+
+		fillInTemplate: function(args, frag){
+			var source = this.getFragNodeRef(frag);
+			
+			this.containerNode.style.left = "";
+			this.containerNode.style.top = "";
+
+			if(this.inputId){ this.inputNode.id = this.inputId; }
+			if(this.inputName){ this.inputNode.name = this.inputName; }
+			this.inputNode.style.width = this.inputWidth;
+
+			dojo.event.connect(this.inputNode, "onchange", this, "onInputChange");
+			
+			this.containerIframe = new dojo.html.BackgroundIframe(this.containerNode);
+			this.containerIframe.size([0,0,0,0]);
+		},
+
+		postMixInProperties: function(args, frag, parentComp){
+			// now that we know the setting for toggle, get toggle object
+			// (default to plain toggler if user specified toggler not present)
+			this.containerToggleObj =
+				dojo.lfx.toggle[this.containerToggle.toLowerCase()] || dojo.lfx.toggle.plain;
+			dojo.widget.DropdownContainer.superclass.postMixInProperties.call(this, args, frag, parentComp);
+		},
+
+		onIconClick: function(evt){
+			this.toggleContainerShow();
+		},
+
+		toggleContainerShow: function(){
+			if(dojo.html.isShowing(this.containerNode)){
+				this.hideContainer();
+			}else{
+				this.showContainer();
+			}
+		},
+		
+		showContainer: function(){
+			this.containerAnimInProgress=true;
+			this.containerToggleObj.show(this.containerNode, this.containerToggleDuration, null,
+				dojo.lang.hitch(this, this.onContainerShow), this.explodeSrc);
+			dojo.lang.setTimeout(this, this.sizeBackgroundIframe, this.containerToggleDuration);
+		},
+
+		onContainerShow: function(){
+			this.containerAnimInProgress=false;
+		},
+
+		hideContainer: function(){
+			this.containerAnimInProgress=true;
+			this.containerToggleObj.hide(this.containerNode, this.containerToggleDuration, null,
+				dojo.lang.hitch(this, this.onContainerHide), this.explodeSrc);
+			dojo.lang.setTimeout(this, this.sizeBackgroundIframe, this.containerToggleDuration);
+		},
+
+		onContainerHide: function(){
+			this.containerAnimInProgress=false;
+		},
+		
+		sizeBackgroundIframe: function(){
+			var w = dojo.style.getOuterWidth(this.containerNode);
+			var h = dojo.style.getOuterHeight(this.containerNode);
+			if(w==0||h==0){
+				// need more time to calculate size
+				dojo.lang.setTimeout(this, "sizeBackgroundIframe", 100);
+				return;
+			}
+			if(dojo.html.isShowing(this.containerNode)){
+				this.containerIframe.size([0,0,w,h]);
+			}
+		},
+
+		onInputChange: function(){}
+	},
+	"html"
+);
+
+dojo.widget.tags.addParseTreeHandler("dojo:dropdowncontainer");

Modified: tags/parley-0.53/root/static/magic/src/widget/DropdownDatePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DropdownDatePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DropdownDatePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,103 +8,60 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.DropdownDatePicker");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.DropdownContainer");
 dojo.require("dojo.widget.DatePicker");
 dojo.require("dojo.event.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.date.format");
-dojo.require("dojo.date.serialize");
-dojo.require("dojo.string.common");
-dojo.require("dojo.i18n.common");
-dojo.requireLocalization("dojo.widget", "DropdownDatePicker", null, "ROOT");
-dojo.widget.defineWidget("dojo.widget.DropdownDatePicker", dojo.widget.DropdownContainer, {iconURL:dojo.uri.moduleUri("dojo.widget", "templates/images/dateIcon.gif"), formatLength:"short", displayFormat:"", saveFormat:"", value:"", name:"", displayWeeks:6, adjustWeeks:false, startDate:"1492-10-12", endDate:"2941-10-12", weekStartsOn:"", staticDisplay:false, postMixInProperties:function (localProperties, frag) {
-	dojo.widget.DropdownDatePicker.superclass.postMixInProperties.apply(this, arguments);
-	var messages = dojo.i18n.getLocalization("dojo.widget", "DropdownDatePicker", this.lang);
-	this.iconAlt = messages.selectDate;
-	if (typeof (this.value) == "string" && this.value.toLowerCase() == "today") {
-		this.value = new Date();
-	}
-	if (this.value && isNaN(this.value)) {
-		var orig = this.value;
-		this.value = dojo.date.fromRfc3339(this.value);
-		if (!this.value) {
-			this.value = new Date(orig);
-			dojo.deprecated("dojo.widget.DropdownDatePicker", "date attributes must be passed in Rfc3339 format", "0.5");
+dojo.require("dojo.html");
+
+dojo.widget.defineWidget(
+	"dojo.widget.DropdownDatePicker",
+	dojo.widget.DropdownContainer,
+	{
+		iconURL: dojo.uri.dojoUri("src/widget/templates/images/dateIcon.gif"),
+		iconAlt: "Select a Date",
+		zIndex: "10",
+		datePicker: null,
+		
+		dateFormat: "%m/%d/%Y",
+		date: null,
+		
+		fillInTemplate: function(args, frag){
+			dojo.widget.DropdownDatePicker.superclass.fillInTemplate.call(this, args, frag);
+			var source = this.getFragNodeRef(frag);
+			
+			if(args.date){ this.date = new Date(args.date); }
+			
+			var dpNode = document.createElement("div");
+			this.containerNode.appendChild(dpNode);
+			
+			var dateProps = { widgetContainerId: this.widgetId };
+			if(this.date){
+				dateProps["date"] = this.date;
+				dateProps["storedDate"] = dojo.widget.DatePicker.util.toRfcDate(this.date);
+				this.inputNode.value = dojo.date.format(this.date, this.dateFormat);
+			}
+			this.datePicker = dojo.widget.createWidget("DatePicker", dateProps, dpNode);
+			dojo.event.connect(this.datePicker, "onSetDate", this, "onSetDate");
+			this.containerNode.style.zIndex = this.zIndex;
+			this.containerNode.style.backgroundColor = "transparent";
+		},
+		
+		onSetDate: function(){
+			this.inputNode.value = dojo.date.format(this.datePicker.date, this.dateFormat);
+			this.hideContainer();
+		},
+		
+		onInputChange: function(){
+			var tmp = new Date(this.inputNode.value);
+			this.datePicker.date = tmp;
+			this.datePicker.setDate(dojo.widget.DatePicker.util.toRfcDate(tmp));
+			this.datePicker.initData();
+			this.datePicker.initUI();
 		}
-	}
-	if (this.value && !isNaN(this.value)) {
-		this.value = new Date(this.value);
-	}
-}, fillInTemplate:function (args, frag) {
-	dojo.widget.DropdownDatePicker.superclass.fillInTemplate.call(this, args, frag);
-	var dpArgs = {widgetContainerId:this.widgetId, lang:this.lang, value:this.value, startDate:this.startDate, endDate:this.endDate, displayWeeks:this.displayWeeks, weekStartsOn:this.weekStartsOn, adjustWeeks:this.adjustWeeks, staticDisplay:this.staticDisplay};
-	this.datePicker = dojo.widget.createWidget("DatePicker", dpArgs, this.containerNode, "child");
-	dojo.event.connect(this.datePicker, "onValueChanged", this, "_updateText");
-	dojo.event.connect(this.inputNode, "onChange", this, "_updateText");
-	if (this.value) {
-		this._updateText();
-	}
-	this.containerNode.explodeClassName = "calendarBodyContainer";
-	this.valueNode.name = this.name;
-}, getValue:function () {
-	return this.valueNode.value;
-}, getDate:function () {
-	return this.datePicker.value;
-}, setValue:function (rfcDate) {
-	this.setDate(rfcDate);
-}, setDate:function (dateObj) {
-	this.datePicker.setDate(dateObj);
-	this._syncValueNode();
-}, _updateText:function () {
-	this.inputNode.value = this.datePicker.value ? dojo.date.format(this.datePicker.value, {formatLength:this.formatLength, datePattern:this.displayFormat, selector:"dateOnly", locale:this.lang}) : "";
-	if (this.value < this.datePicker.startDate || this.value > this.datePicker.endDate) {
-		this.inputNode.value = "";
-	}
-	this._syncValueNode();
-	this.onValueChanged(this.getDate());
-	this.hideContainer();
-}, onValueChanged:function (dateObj) {
-}, onInputChange:function () {
-	var input = dojo.string.trim(this.inputNode.value);
-	if (input) {
-		var inputDate = dojo.date.parse(input, {formatLength:this.formatLength, datePattern:this.displayFormat, selector:"dateOnly", locale:this.lang});
-		if (!this.datePicker._isDisabledDate(inputDate)) {
-			this.setDate(inputDate);
-		}
-	} else {
-		if (input == "") {
-			this.datePicker.setDate("");
-		}
-		this.valueNode.value = input;
-	}
-	if (input) {
-		this._updateText();
-	}
-}, _syncValueNode:function () {
-	var date = this.datePicker.value;
-	var value = "";
-	switch (this.saveFormat.toLowerCase()) {
-	  case "rfc":
-	  case "iso":
-	  case "":
-		value = dojo.date.toRfc3339(date, "dateOnly");
-		break;
-	  case "posix":
-	  case "unix":
-		value = Number(date);
-		break;
-	  default:
-		if (date) {
-			value = dojo.date.format(date, {datePattern:this.saveFormat, selector:"dateOnly", locale:this.lang});
-		}
-	}
-	this.valueNode.value = value;
-}, destroy:function (finalize) {
-	this.datePicker.destroy(finalize);
-	dojo.widget.DropdownDatePicker.superclass.destroy.apply(this, arguments);
-}});
+	},
+	"html"
+);
 
+dojo.widget.tags.addParseTreeHandler("dojo:dropdowndatepicker");

Deleted: tags/parley-0.53/root/static/magic/src/widget/DropdownTimePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/DropdownTimePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/DropdownTimePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,156 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.DropdownTimePicker");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.DropdownContainer");
-dojo.require("dojo.widget.TimePicker");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.date.format");
-dojo.require("dojo.date.serialize");
-dojo.require("dojo.i18n.common");
-dojo.requireLocalization("dojo.widget", "DropdownTimePicker", null, "ROOT");
-dojo.widget.defineWidget("dojo.widget.DropdownTimePicker", dojo.widget.DropdownContainer, {iconURL:dojo.uri.moduleUri("dojo.widget", "templates/images/timeIcon.gif"), formatLength:"short", displayFormat:"", timeFormat:"", saveFormat:"", value:"", name:"", postMixInProperties:function () {
-	dojo.widget.DropdownTimePicker.superclass.postMixInProperties.apply(this, arguments);
-	var messages = dojo.i18n.getLocalization("dojo.widget", "DropdownTimePicker", this.lang);
-	this.iconAlt = messages.selectTime;
-	if (typeof (this.value) == "string" && this.value.toLowerCase() == "today") {
-		this.value = new Date();
-	}
-	if (this.value && isNaN(this.value)) {
-		var orig = this.value;
-		this.value = dojo.date.fromRfc3339(this.value);
-		if (!this.value) {
-			var d = dojo.date.format(new Date(), {selector:"dateOnly", datePattern:"yyyy-MM-dd"});
-			var c = orig.split(":");
-			for (var i = 0; i < c.length; ++i) {
-				if (c[i].length == 1) {
-					c[i] = "0" + c[i];
-				}
-			}
-			orig = c.join(":");
-			this.value = dojo.date.fromRfc3339(d + "T" + orig);
-			dojo.deprecated("dojo.widget.DropdownTimePicker", "time attributes must be passed in Rfc3339 format", "0.5");
-		}
-	}
-	if (this.value && !isNaN(this.value)) {
-		this.value = new Date(this.value);
-	}
-}, fillInTemplate:function () {
-	dojo.widget.DropdownTimePicker.superclass.fillInTemplate.apply(this, arguments);
-	var value = "";
-	if (this.value instanceof Date) {
-		value = this.value;
-	} else {
-		if (this.value) {
-			var orig = this.value;
-			var d = dojo.date.format(new Date(), {selector:"dateOnly", datePattern:"yyyy-MM-dd"});
-			var c = orig.split(":");
-			for (var i = 0; i < c.length; ++i) {
-				if (c[i].length == 1) {
-					c[i] = "0" + c[i];
-				}
-			}
-			orig = c.join(":");
-			value = dojo.date.fromRfc3339(d + "T" + orig);
-		}
-	}
-	var tpArgs = {widgetContainerId:this.widgetId, lang:this.lang, value:value};
-	this.timePicker = dojo.widget.createWidget("TimePicker", tpArgs, this.containerNode, "child");
-	dojo.event.connect(this.timePicker, "onValueChanged", this, "_updateText");
-	if (this.value) {
-		this._updateText();
-	}
-	this.containerNode.style.zIndex = this.zIndex;
-	this.containerNode.explodeClassName = "timeContainer";
-	this.valueNode.name = this.name;
-}, getValue:function () {
-	return this.valueNode.value;
-}, getTime:function () {
-	return this.timePicker.storedTime;
-}, setValue:function (rfcDate) {
-	this.setTime(rfcDate);
-}, setTime:function (dateObj) {
-	var value = "";
-	if (dateObj instanceof Date) {
-		value = dateObj;
-	} else {
-		if (this.value) {
-			var orig = this.value;
-			var d = dojo.date.format(new Date(), {selector:"dateOnly", datePattern:"yyyy-MM-dd"});
-			var c = orig.split(":");
-			for (var i = 0; i < c.length; ++i) {
-				if (c[i].length == 1) {
-					c[i] = "0" + c[i];
-				}
-			}
-			orig = c.join(":");
-			value = dojo.date.fromRfc3339(d + "T" + orig);
-		}
-	}
-	this.timePicker.setTime(value);
-	this._syncValueNode();
-}, _updateText:function () {
-	if (this.timePicker.selectedTime.anyTime) {
-		this.inputNode.value = "";
-	} else {
-		if (this.timeFormat) {
-			dojo.deprecated("dojo.widget.DropdownTimePicker", "Must use displayFormat attribute instead of timeFormat.  See dojo.date.format for specification.", "0.5");
-			this.inputNode.value = dojo.date.strftime(this.timePicker.time, this.timeFormat, this.lang);
-		} else {
-			this.inputNode.value = dojo.date.format(this.timePicker.time, {formatLength:this.formatLength, timePattern:this.displayFormat, selector:"timeOnly", locale:this.lang});
-		}
-	}
-	this._syncValueNode();
-	this.onValueChanged(this.getTime());
-	this.hideContainer();
-}, onValueChanged:function (dateObj) {
-}, onInputChange:function () {
-	if (this.dateFormat) {
-		dojo.deprecated("dojo.widget.DropdownTimePicker", "Cannot parse user input.  Must use displayFormat attribute instead of dateFormat.  See dojo.date.format for specification.", "0.5");
-	} else {
-		var input = dojo.string.trim(this.inputNode.value);
-		if (input) {
-			var inputTime = dojo.date.parse(input, {formatLength:this.formatLength, timePattern:this.displayFormat, selector:"timeOnly", locale:this.lang});
-			if (inputTime) {
-				this.setTime(inputTime);
-			}
-		} else {
-			this.valueNode.value = input;
-		}
-	}
-	if (input) {
-		this._updateText();
-	}
-}, _syncValueNode:function () {
-	var time = this.timePicker.time;
-	var value;
-	switch (this.saveFormat.toLowerCase()) {
-	  case "rfc":
-	  case "iso":
-	  case "":
-		value = dojo.date.toRfc3339(time, "timeOnly");
-		break;
-	  case "posix":
-	  case "unix":
-		value = Number(time);
-		break;
-	  default:
-		value = dojo.date.format(time, {datePattern:this.saveFormat, selector:"timeOnly", locale:this.lang});
-	}
-	this.valueNode.value = value;
-}, destroy:function (finalize) {
-	this.timePicker.destroy(finalize);
-	dojo.widget.DropdownTimePicker.superclass.destroy.apply(this, arguments);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/Editor.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Editor.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Editor.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,383 +8,526 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
+/* TODO:
+ * - font selector
+ * - test, bug fix, more features :)
+*/
 dojo.provide("dojo.widget.Editor");
-dojo.deprecated("dojo.widget.Editor", "is replaced by dojo.widget.Editor2", "0.5");
+dojo.provide("dojo.widget.html.Editor");
 dojo.require("dojo.io.*");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.Toolbar");
 dojo.require("dojo.widget.RichText");
 dojo.require("dojo.widget.ColorPalette");
 dojo.require("dojo.string.extras");
+
 dojo.widget.tags.addParseTreeHandler("dojo:Editor");
-dojo.widget.Editor = function () {
+
+dojo.widget.html.Editor = function() {
 	dojo.widget.HtmlWidget.call(this);
 	this.contentFilters = [];
 	this._toolbars = [];
+}
+dojo.inherits(dojo.widget.html.Editor, dojo.widget.HtmlWidget);
+
+dojo.widget.html.Editor.itemGroups = {
+	textGroup: ["bold", "italic", "underline", "strikethrough"],
+	blockGroup: ["formatBlock", "fontName", "fontSize"],
+	justifyGroup: ["justifyleft", "justifycenter", "justifyright"],
+	commandGroup: ["save", "cancel"],
+	colorGroup: ["forecolor", "hilitecolor"],
+	listGroup: ["insertorderedlist", "insertunorderedlist"],
+	indentGroup: ["outdent", "indent"],
+	linkGroup: ["createlink", "insertimage", "inserthorizontalrule"]
 };
-dojo.inherits(dojo.widget.Editor, dojo.widget.HtmlWidget);
-dojo.widget.Editor.itemGroups = {textGroup:["bold", "italic", "underline", "strikethrough"], blockGroup:["formatBlock", "fontName", "fontSize"], justifyGroup:["justifyleft", "justifycenter", "justifyright"], commandGroup:["save", "cancel"], colorGroup:["forecolor", "hilitecolor"], listGroup:["insertorderedlist", "insertunorderedlist"], indentGroup:["outdent", "indent"], linkGroup:["createlink", "insertimage", "inserthorizontalrule"]};
-dojo.widget.Editor.formatBlockValues = {"Normal":"p", "Main heading":"h2", "Sub heading":"h3", "Sub sub heading":"h4", "Preformatted":"pre"};
-dojo.widget.Editor.fontNameValues = {"Arial":"Arial, Helvetica, sans-serif", "Verdana":"Verdana, sans-serif", "Times New Roman":"Times New Roman, serif", "Courier":"Courier New, monospace"};
-dojo.widget.Editor.fontSizeValues = {"1 (8 pt)":"1", "2 (10 pt)":"2", "3 (12 pt)":"3", "4 (14 pt)":"4", "5 (18 pt)":"5", "6 (24 pt)":"6", "7 (36 pt)":"7"};
-dojo.widget.Editor.defaultItems = ["commandGroup", "|", "blockGroup", "|", "textGroup", "|", "colorGroup", "|", "justifyGroup", "|", "listGroup", "indentGroup", "|", "linkGroup"];
-dojo.widget.Editor.supportedCommands = ["save", "cancel", "|", "-", "/", " "];
-dojo.lang.extend(dojo.widget.Editor, {widgetType:"Editor", saveUrl:"", saveMethod:"post", saveArgName:"editorContent", closeOnSave:false, items:dojo.widget.Editor.defaultItems, formatBlockItems:dojo.lang.shallowCopy(dojo.widget.Editor.formatBlockValues), fontNameItems:dojo.lang.shallowCopy(dojo.widget.Editor.fontNameValues), fontSizeItems:dojo.lang.shallowCopy(dojo.widget.Editor.fontSizeValues), getItemProperties:function (name) {
-	var props = {};
-	switch (name.toLowerCase()) {
-	  case "bold":
-	  case "italic":
-	  case "underline":
-	  case "strikethrough":
-		props.toggleItem = true;
-		break;
-	  case "justifygroup":
-		props.defaultButton = "justifyleft";
-		props.preventDeselect = true;
-		props.buttonGroup = true;
-		break;
-	  case "listgroup":
-		props.buttonGroup = true;
-		break;
-	  case "save":
-	  case "cancel":
-		props.label = dojo.string.capitalize(name);
-		break;
-	  case "forecolor":
-	  case "hilitecolor":
-		props.name = name;
-		props.toggleItem = true;
-		props.icon = this.getCommandImage(name);
-		break;
-	  case "formatblock":
-		props.name = "formatBlock";
-		props.values = this.formatBlockItems;
-		break;
-	  case "fontname":
-		props.name = "fontName";
-		props.values = this.fontNameItems;
-	  case "fontsize":
-		props.name = "fontSize";
-		props.values = this.fontSizeItems;
-	}
-	return props;
-}, validateItems:true, focusOnLoad:true, minHeight:"1em", _richText:null, _richTextType:"RichText", _toolbarContainer:null, _toolbarContainerType:"ToolbarContainer", _toolbars:[], _toolbarType:"Toolbar", _toolbarItemType:"ToolbarItem", buildRendering:function (args, frag) {
-	var node = frag["dojo:" + this.widgetType.toLowerCase()]["nodeRef"];
-	var trt = dojo.widget.createWidget(this._richTextType, {focusOnLoad:this.focusOnLoad, minHeight:this.minHeight}, node);
-	var _this = this;
-	setTimeout(function () {
-		_this.setRichText(trt);
-		_this.initToolbar();
-		_this.fillInTemplate(args, frag);
-	}, 0);
-}, setRichText:function (richText) {
-	if (this._richText && this._richText == richText) {
-		dojo.debug("Already set the richText to this richText!");
-		return;
-	}
-	if (this._richText && !this._richText.isClosed) {
-		dojo.debug("You are switching richTexts yet you haven't closed the current one. Losing reference!");
-	}
-	this._richText = richText;
-	dojo.event.connect(this._richText, "close", this, "onClose");
-	dojo.event.connect(this._richText, "onLoad", this, "onLoad");
-	dojo.event.connect(this._richText, "onDisplayChanged", this, "updateToolbar");
-	if (this._toolbarContainer) {
-		this._toolbarContainer.enable();
-		this.updateToolbar(true);
-	}
-}, initToolbar:function () {
-	if (this._toolbarContainer) {
-		return;
-	}
-	this._toolbarContainer = dojo.widget.createWidget(this._toolbarContainerType);
-	var tb = this.addToolbar();
-	var last = true;
-	for (var i = 0; i < this.items.length; i++) {
-		if (this.items[i] == "\n") {
-			tb = this.addToolbar();
-		} else {
-			if ((this.items[i] == "|") && (!last)) {
-				last = true;
+
+dojo.widget.html.Editor.formatBlockValues = {
+	"Normal": "p",
+	"Main heading": "h2",
+	"Sub heading": "h3",
+	"Sub sub heading": "h4",
+	"Preformatted": "pre"
+};
+
+dojo.widget.html.Editor.fontNameValues = {
+	"Arial": "Arial, Helvetica, sans-serif",
+	"Verdana": "Verdana, sans-serif",
+	"Times New Roman": "Times New Roman, serif",
+	"Courier": "Courier New, monospace"
+};
+
+dojo.widget.html.Editor.fontSizeValues = {
+	"1 (8 pt)" : "1",
+	"2 (10 pt)": "2",
+	"3 (12 pt)": "3",
+	"4 (14 pt)": "4",
+	"5 (18 pt)": "5",
+	"6 (24 pt)": "6",
+	"7 (36 pt)": "7"
+};
+
+dojo.widget.html.Editor.defaultItems = [
+	"commandGroup", "|", "blockGroup", "|", "textGroup", "|", "colorGroup", "|", "justifyGroup", "|", "listGroup", "indentGroup", "|", "linkGroup"
+];
+
+// ones we support by default without asking the RichText component
+// NOTE: you shouldn't put buttons like bold, italic, etc in here
+dojo.widget.html.Editor.supportedCommands = ["save", "cancel", "|", "-", "/", " "];
+
+dojo.lang.extend(dojo.widget.html.Editor, {
+	widgetType: "Editor",
+
+	saveUrl: "",
+	saveMethod: "post",
+	saveArgName: "editorContent",
+	closeOnSave: false,
+	items: dojo.widget.html.Editor.defaultItems,
+	formatBlockItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.formatBlockValues),
+	fontNameItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.fontNameValues),
+	fontSizeItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.fontSizeValues),
+
+	// used to get the properties of an item if it is given as a string
+	getItemProperties: function(name) {
+		var props = {};
+		switch(name.toLowerCase()) {
+			case "bold":
+			case "italic":
+			case "underline":
+			case "strikethrough":
+				props.toggleItem = true;
+				break;
+
+			case "justifygroup":
+				props.defaultButton = "justifyleft";
+				props.preventDeselect = true;
+				props.buttonGroup = true;
+				break;
+
+			case "listgroup":
+				props.buttonGroup = true;
+				break;
+
+			case "save":
+			case "cancel":
+				props.label = dojo.string.capitalize(name);
+				break;
+
+			case "forecolor":
+			case "hilitecolor":
+				props.name = name;
+				props.toggleItem = true; // FIXME: they aren't exactly toggle items
+				props.icon = this.getCommandImage(name);
+				break;
+
+			case "formatblock":
+				props.name = "formatBlock";
+				props.values = this.formatBlockItems;
+				break;
+
+			case "fontname":
+				props.name = "fontName";
+				props.values = this.fontNameItems;
+
+			case "fontsize":
+				props.name = "fontSize";
+				props.values = this.fontSizeItems;
+		}
+		return props;
+	},
+
+	validateItems: true, // set to false to add items, regardless of support
+	focusOnLoad: true,
+	minHeight: "1em",
+
+	_richText: null, // RichText widget
+	_richTextType: "RichText",
+
+	_toolbarContainer: null, // ToolbarContainer widget
+	_toolbarContainerType: "ToolbarContainer",
+
+	_toolbars: [],
+	_toolbarType: "Toolbar",
+
+	_toolbarItemType: "ToolbarItem",
+
+	buildRendering: function(args, frag) {
+		// get the node from args/frag
+		var node = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
+		var trt = dojo.widget.createWidget(this._richTextType, {
+			focusOnLoad: this.focusOnLoad,
+			minHeight: this.minHeight
+		}, node)
+		var _this = this;
+		// this appears to fix a weird timing bug on Safari
+		setTimeout(function(){
+			_this.setRichText(trt);
+
+			_this.initToolbar();
+
+			_this.fillInTemplate(args, frag);
+		}, 0);
+	},
+
+	setRichText: function(richText) {
+		if(this._richText && this._richText == richText) {
+			dojo.debug("Already set the richText to this richText!");
+			return;
+		}
+
+		if(this._richText && !this._richText.isClosed) {
+			dojo.debug("You are switching richTexts yet you haven't closed the current one. Losing reference!");
+		}
+		this._richText = richText;
+		dojo.event.connect(this._richText, "close", this, "onClose");
+		dojo.event.connect(this._richText, "onLoad", this, "onLoad");
+		dojo.event.connect(this._richText, "onDisplayChanged", this, "updateToolbar");
+		if(this._toolbarContainer) {
+			this._toolbarContainer.enable();
+			this.updateToolbar(true);
+		}
+	},
+
+	initToolbar: function() {
+		// var tic = new Date();
+		if(this._toolbarContainer) { return; } // only create it once
+		this._toolbarContainer = dojo.widget.createWidget(this._toolbarContainerType);
+		var tb = this.addToolbar();
+		var last = true;
+		for(var i = 0; i < this.items.length; i++) {
+			if(this.items[i] == "\n") { // new row
+				tb = this.addToolbar();
 			} else {
-				last = this.addItem(this.items[i], tb);
+				if((this.items[i] == "|")&&(!last)){
+					last = true;
+				}else{
+					last = this.addItem(this.items[i], tb);
+				}
 			}
 		}
-	}
-	this.insertToolbar(this._toolbarContainer.domNode, this._richText.domNode);
-}, insertToolbar:function (tbNode, richTextNode) {
-	dojo.html.insertBefore(tbNode, richTextNode);
-}, addToolbar:function (toolbar) {
-	this.initToolbar();
-	if (!(toolbar instanceof dojo.widget.Toolbar)) {
-		toolbar = dojo.widget.createWidget(this._toolbarType);
-	}
-	this._toolbarContainer.addChild(toolbar);
-	this._toolbars.push(toolbar);
-	return toolbar;
-}, addItem:function (item, tb, dontValidate) {
-	if (!tb) {
-		tb = this._toolbars[0];
-	}
-	var cmd = ((item) && (!dojo.lang.isUndefined(item["getValue"]))) ? cmd = item["getValue"]() : item;
-	var groups = dojo.widget.Editor.itemGroups;
-	if (item instanceof dojo.widget.ToolbarItem) {
-		tb.addChild(item);
-	} else {
-		if (groups[cmd]) {
+		this.insertToolbar(this._toolbarContainer.domNode, this._richText.domNode);
+		// alert(new Date - tic);
+	},
+
+	// allow people to override this so they can make their own placement logic
+	insertToolbar: function(tbNode, richTextNode) {
+		dojo.html.insertBefore(tbNode, richTextNode);
+		//dojo.html.insertBefore(this._toolbarContainer.domNode, this._richText.domNode);
+	},
+
+	addToolbar: function(toolbar) {
+		this.initToolbar();
+		if(!(toolbar instanceof dojo.widget.html.Toolbar)) {
+			toolbar = dojo.widget.createWidget(this._toolbarType);
+		}
+		this._toolbarContainer.addChild(toolbar);
+		this._toolbars.push(toolbar);
+		return toolbar;
+	},
+
+	addItem: function(item, tb, dontValidate) {
+		if(!tb) { tb = this._toolbars[0]; }
+		var cmd = ((item)&&(!dojo.lang.isUndefined(item["getValue"]))) ?  cmd = item["getValue"](): item;
+
+		var groups = dojo.widget.html.Editor.itemGroups;
+		if(item instanceof dojo.widget.ToolbarItem) {
+			tb.addChild(item);
+		} else if(groups[cmd]) {
 			var group = groups[cmd];
 			var worked = true;
-			if (cmd == "justifyGroup" || cmd == "listGroup") {
+			if(cmd == "justifyGroup" || cmd == "listGroup") {
 				var btnGroup = [cmd];
-				for (var i = 0; i < group.length; i++) {
-					if (dontValidate || this.isSupportedCommand(group[i])) {
+				for(var i = 0 ; i < group.length; i++) {
+					if(dontValidate || this.isSupportedCommand(group[i])) {
 						btnGroup.push(this.getCommandImage(group[i]));
-					} else {
+					}else{
 						worked = false;
 					}
 				}
-				if (btnGroup.length) {
+				if(btnGroup.length){
+					/*
+					// the addChild interface is assinine. Work around it.
+					var tprops = this.getItemProperties(cmd);
+					var tmpGroup = dojo.widget.createWidget("ToolbarButtonGroup", tprops);
+					dojo.debug(btnGroup);
+					dojo.event.connect(tmpGroup, "onClick", this, "_action");
+					dojo.event.connect(tmpGroup, "onChangeSelect", this, "_action");
+					*/
 					var btn = tb.addChild(btnGroup, null, this.getItemProperties(cmd));
 					dojo.event.connect(btn, "onClick", this, "_action");
 					dojo.event.connect(btn, "onChangeSelect", this, "_action");
 				}
 				return worked;
 			} else {
-				for (var i = 0; i < group.length; i++) {
-					if (!this.addItem(group[i], tb)) {
+				for(var i = 0; i < group.length; i++) {
+					if(!this.addItem(group[i], tb)){
 						worked = false;
 					}
 				}
 				return worked;
 			}
 		} else {
-			if ((!dontValidate) && (!this.isSupportedCommand(cmd))) {
+			if((!dontValidate)&&(!this.isSupportedCommand(cmd))){
 				return false;
 			}
-			if (dontValidate || this.isSupportedCommand(cmd)) {
+			if(dontValidate || this.isSupportedCommand(cmd)) {
 				cmd = cmd.toLowerCase();
-				if (cmd == "formatblock") {
-					var select = dojo.widget.createWidget("ToolbarSelect", {name:"formatBlock", values:this.formatBlockItems});
+				if(cmd == "formatblock") {
+					var select = dojo.widget.createWidget("ToolbarSelect", {
+						name: "formatBlock",
+						values: this.formatBlockItems
+					});
 					tb.addChild(select);
 					var _this = this;
-					dojo.event.connect(select, "onSetValue", function (item, value) {
+					dojo.event.connect(select, "onSetValue", function(item, value) {
 						_this.onAction("formatBlock", value);
 					});
+				} else if(cmd == "fontname") {
+					var select = dojo.widget.createWidget("ToolbarSelect", {
+						name: "fontName",
+						values: this.fontNameItems
+					});
+					tb.addChild(select);
+					dojo.event.connect(select, "onSetValue", dojo.lang.hitch(this, function(item, value) {
+						this.onAction("fontName", value);
+					}));
+				} else if(cmd == "fontsize") {
+					var select = dojo.widget.createWidget("ToolbarSelect", {
+						name: "fontSize",
+						values: this.fontSizeItems
+					});
+					tb.addChild(select);
+					dojo.event.connect(select, "onSetValue", dojo.lang.hitch(this, function(item, value) {
+						this.onAction("fontSize", value);
+					}));
+				} else if(dojo.lang.inArray(cmd, ["forecolor", "hilitecolor"])) {
+					var btn = tb.addChild(dojo.widget.createWidget("ToolbarColorDialog", this.getItemProperties(cmd)));
+					dojo.event.connect(btn, "onSetValue", this, "_setValue");
 				} else {
-					if (cmd == "fontname") {
-						var select = dojo.widget.createWidget("ToolbarSelect", {name:"fontName", values:this.fontNameItems});
-						tb.addChild(select);
-						dojo.event.connect(select, "onSetValue", dojo.lang.hitch(this, function (item, value) {
-							this.onAction("fontName", value);
-						}));
+					var btn = tb.addChild(this.getCommandImage(cmd), null, this.getItemProperties(cmd));
+					if(cmd == "save"){
+						dojo.event.connect(btn, "onClick", this, "_save");
+					}else if(cmd == "cancel"){
+						dojo.event.connect(btn, "onClick", this, "_close");
 					} else {
-						if (cmd == "fontsize") {
-							var select = dojo.widget.createWidget("ToolbarSelect", {name:"fontSize", values:this.fontSizeItems});
-							tb.addChild(select);
-							dojo.event.connect(select, "onSetValue", dojo.lang.hitch(this, function (item, value) {
-								this.onAction("fontSize", value);
-							}));
-						} else {
-							if (dojo.lang.inArray(cmd, ["forecolor", "hilitecolor"])) {
-								var btn = tb.addChild(dojo.widget.createWidget("ToolbarColorDialog", this.getItemProperties(cmd)));
-								dojo.event.connect(btn, "onSetValue", this, "_setValue");
-							} else {
-								var btn = tb.addChild(this.getCommandImage(cmd), null, this.getItemProperties(cmd));
-								if (cmd == "save") {
-									dojo.event.connect(btn, "onClick", this, "_save");
-								} else {
-									if (cmd == "cancel") {
-										dojo.event.connect(btn, "onClick", this, "_close");
-									} else {
-										dojo.event.connect(btn, "onClick", this, "_action");
-										dojo.event.connect(btn, "onChangeSelect", this, "_action");
-									}
-								}
-							}
-						}
+						dojo.event.connect(btn, "onClick", this, "_action");
+						dojo.event.connect(btn, "onChangeSelect", this, "_action");
 					}
 				}
 			}
 		}
-	}
-	return true;
-}, enableToolbar:function () {
-	if (this._toolbarContainer) {
-		this._toolbarContainer.domNode.style.display = "";
-		this._toolbarContainer.enable();
-	}
-}, disableToolbar:function (hide) {
-	if (hide) {
-		if (this._toolbarContainer) {
-			this._toolbarContainer.domNode.style.display = "none";
+		return true;
+	},
+
+	enableToolbar: function() {
+		if(this._toolbarContainer) {
+			this._toolbarContainer.domNode.style.display = "";
+			this._toolbarContainer.enable();
 		}
-	} else {
-		if (this._toolbarContainer) {
-			this._toolbarContainer.disable();
+	},
+
+	disableToolbar: function(hide){
+		if(hide){
+			if(this._toolbarContainer){
+				this._toolbarContainer.domNode.style.display = "none";
+			}
+		}else{
+			if(this._toolbarContainer){
+				this._toolbarContainer.disable();
+			}
 		}
-	}
-}, _updateToolbarLastRan:null, _updateToolbarTimer:null, _updateToolbarFrequency:500, updateToolbar:function (force) {
-	if (!this._toolbarContainer) {
-		return;
-	}
-	var diff = new Date() - this._updateToolbarLastRan;
-	if (!force && this._updateToolbarLastRan && (diff < this._updateToolbarFrequency)) {
-		clearTimeout(this._updateToolbarTimer);
-		var _this = this;
-		this._updateToolbarTimer = setTimeout(function () {
-			_this.updateToolbar();
-		}, this._updateToolbarFrequency / 2);
-		return;
-	} else {
-		this._updateToolbarLastRan = new Date();
-	}
-	var items = this._toolbarContainer.getItems();
-	for (var i = 0; i < items.length; i++) {
-		var item = items[i];
-		if (item instanceof dojo.widget.ToolbarSeparator) {
-			continue;
+	},
+
+	_updateToolbarLastRan: null,
+	_updateToolbarTimer: null,
+	_updateToolbarFrequency: 500,
+
+	updateToolbar: function(force) {
+		if(!this._toolbarContainer) { return; }
+
+		// keeps the toolbar from updating too frequently
+		// TODO: generalize this functionality?
+		var diff = new Date() - this._updateToolbarLastRan;
+		if(!force && this._updateToolbarLastRan && (diff < this._updateToolbarFrequency)) {
+			clearTimeout(this._updateToolbarTimer);
+			var _this = this;
+			this._updateToolbarTimer = setTimeout(function() {
+				_this.updateToolbar();
+			}, this._updateToolbarFrequency/2);
+			return;
+		} else {
+			this._updateToolbarLastRan = new Date();
 		}
-		var cmd = item._name;
-		if (cmd == "save" || cmd == "cancel") {
-			continue;
-		} else {
-			if (cmd == "justifyGroup") {
+		// end frequency checker
+
+		var items = this._toolbarContainer.getItems();
+		for(var i = 0; i < items.length; i++) {
+			var item = items[i];
+			if(item instanceof dojo.widget.html.ToolbarSeparator) { continue; }
+			var cmd = item._name;
+			if (cmd == "save" || cmd == "cancel") { continue; }
+			else if(cmd == "justifyGroup") {
 				try {
-					if (!this._richText.queryCommandEnabled("justifyleft")) {
+					if(!this._richText.queryCommandEnabled("justifyleft")) {
 						item.disable(false, true);
 					} else {
 						item.enable(false, true);
 						var jitems = item.getItems();
-						for (var j = 0; j < jitems.length; j++) {
+						for(var j = 0; j < jitems.length; j++) {
 							var name = jitems[j]._name;
 							var value = this._richText.queryCommandValue(name);
-							if (typeof value == "boolean" && value) {
+							if(typeof value == "boolean" && value) {
 								value = name;
 								break;
+							} else if(typeof value == "string") {
+								value = "justify"+value;
 							} else {
-								if (typeof value == "string") {
-									value = "justify" + value;
-								} else {
-									value = null;
-								}
+								value = null;
 							}
 						}
-						if (!value) {
-							value = "justifyleft";
-						}
+						if(!value) { value = "justifyleft"; } // TODO: query actual style
 						item.setValue(value, false, true);
 					}
+				} catch(err) {}
+			} else if(cmd == "listGroup") {
+				var litems = item.getItems();
+				for(var j = 0; j < litems.length; j++) {
+					this.updateItem(litems[j]);
 				}
-				catch (err) {
-				}
 			} else {
-				if (cmd == "listGroup") {
-					var litems = item.getItems();
-					for (var j = 0; j < litems.length; j++) {
-						this.updateItem(litems[j]);
-					}
-				} else {
-					this.updateItem(item);
-				}
+				this.updateItem(item);
 			}
 		}
-	}
-}, updateItem:function (item) {
-	try {
-		var cmd = item._name;
-		var enabled = this._richText.queryCommandEnabled(cmd);
-		item.setEnabled(enabled, false, true);
-		var active = this._richText.queryCommandState(cmd);
-		if (active && cmd == "underline") {
-			active = !this._richText.queryCommandEnabled("unlink");
-		}
-		item.setSelected(active, false, true);
-		return true;
-	}
-	catch (err) {
-		return false;
-	}
-}, supportedCommands:dojo.widget.Editor.supportedCommands.concat(), isSupportedCommand:function (cmd) {
-	var yes = dojo.lang.inArray(cmd, this.supportedCommands);
-	if (!yes) {
+	},
+
+	updateItem: function(item) {
 		try {
-			var richText = this._richText || dojo.widget.HtmlRichText.prototype;
-			yes = richText.queryCommandAvailable(cmd);
+			var cmd = item._name;
+			var enabled = this._richText.queryCommandEnabled(cmd);
+			item.setEnabled(enabled, false, true);
+
+			var active = this._richText.queryCommandState(cmd);
+			if(active && cmd == "underline") {
+				// don't activate underlining if we are on a link
+				active = !this._richText.queryCommandEnabled("unlink");
+			}
+			item.setSelected(active, false, true);
+			return true;
+		} catch(err) {
+			return false;
 		}
-		catch (E) {
+	},
+
+	supportedCommands: dojo.widget.html.Editor.supportedCommands.concat(),
+
+	isSupportedCommand: function(cmd) {
+		// FIXME: how do we check for ActiveX?
+		var yes = dojo.lang.inArray(cmd, this.supportedCommands);
+		if(!yes) {
+			try {
+				var richText = this._richText || dojo.widget.HtmlRichText.prototype;
+				yes = richText.queryCommandAvailable(cmd);
+			} catch(E) {}
 		}
-	}
-	return yes;
-}, getCommandImage:function (cmd) {
-	if (cmd == "|") {
-		return cmd;
-	} else {
-		return dojo.uri.moduleUri("dojo.widget", "templates/buttons/" + cmd + ".gif");
-	}
-}, _action:function (e) {
-	this._fire("onAction", e.getValue());
-}, _setValue:function (a, b) {
-	this._fire("onAction", a.getValue(), b);
-}, _save:function (e) {
-	if (!this._richText.isClosed) {
-		if (this.saveUrl.length) {
-			var content = {};
-			content[this.saveArgName] = this.getHtml();
-			dojo.io.bind({method:this.saveMethod, url:this.saveUrl, content:content});
+		return yes;
+	},
+
+	getCommandImage: function(cmd) {
+		if(cmd == "|") {
+			return cmd;
 		} else {
-			dojo.debug("please set a saveUrl for the editor");
+			return dojo.uri.dojoUri("src/widget/templates/buttons/" + cmd + ".gif");
 		}
-		if (this.closeOnSave) {
+	},
+
+	_action: function(e) {
+		this._fire("onAction", e.getValue());
+	},
+
+	_setValue: function(a, b) {
+		this._fire("onAction", a.getValue(), b);
+	},
+
+	_save: function(e){
+		// FIXME: how should this behave when there's a larger form in play?
+		if(!this._richText.isClosed){
+			if(this.saveUrl.length){
+				var content = {};
+				content[this.saveArgName] = this.getHtml();
+				dojo.io.bind({
+					method: this.saveMethod,
+					url: this.saveUrl,
+					content: content
+				});
+			}else{
+				dojo.debug("please set a saveUrl for the editor");
+			}
+			if(this.closeOnSave){
+				this._richText.close(e.getName().toLowerCase() == "save");
+			}
+		}
+	},
+
+	_close: function(e) {
+		if(!this._richText.isClosed) {
 			this._richText.close(e.getName().toLowerCase() == "save");
 		}
-	}
-}, _close:function (e) {
-	if (!this._richText.isClosed) {
-		this._richText.close(e.getName().toLowerCase() == "save");
-	}
-}, onAction:function (cmd, value) {
-	switch (cmd) {
-	  case "createlink":
-		if (!(value = prompt("Please enter the URL of the link:", "http://"))) {
-			return;
+	},
+
+	onAction: function(cmd, value) {
+		switch(cmd) {
+			case "createlink":
+				if(!(value = prompt("Please enter the URL of the link:", "http://"))) {
+					return;
+				}
+				break;
+			case "insertimage":
+				if(!(value = prompt("Please enter the URL of the image:", "http://"))) {
+					return;
+				}
+				break;
 		}
-		break;
-	  case "insertimage":
-		if (!(value = prompt("Please enter the URL of the image:", "http://"))) {
-			return;
+		this._richText.execCommand(cmd, value);
+	},
+
+	fillInTemplate: function(args, frag) {
+		// dojo.event.connect(this, "onResized", this._richText, "onResized");
+	},
+
+	_fire: function(eventName) {
+		if(dojo.lang.isFunction(this[eventName])) {
+			var args = [];
+			if(arguments.length == 1) {
+				args.push(this);
+			} else {
+				for(var i = 1; i < arguments.length; i++) {
+					args.push(arguments[i]);
+				}
+			}
+			this[eventName].apply(this, args);
 		}
-		break;
-	}
-	this._richText.execCommand(cmd, value);
-}, fillInTemplate:function (args, frag) {
-}, _fire:function (eventName) {
-	if (dojo.lang.isFunction(this[eventName])) {
-		var args = [];
-		if (arguments.length == 1) {
-			args.push(this);
+	},
+
+	getHtml: function(){
+		this._richText.contentFilters = this._richText.contentFilters.concat(this.contentFilters);
+		return this._richText.getEditorContent();
+	},
+
+	getEditorContent: function(){
+		return this.getHtml();
+	},
+
+	onClose: function(save, hide){
+		this.disableToolbar(hide);
+		if(save) {
+			this._fire("onSave");
 		} else {
-			for (var i = 1; i < arguments.length; i++) {
-				args.push(arguments[i]);
-			}
+			this._fire("onCancel");
 		}
-		this[eventName].apply(this, args);
-	}
-}, getHtml:function () {
-	this._richText.contentFilters = this._richText.contentFilters.concat(this.contentFilters);
-	return this._richText.getEditorContent();
-}, getEditorContent:function () {
-	return this.getHtml();
-}, onClose:function (save, hide) {
-	this.disableToolbar(hide);
-	if (save) {
-		this._fire("onSave");
-	} else {
-		this._fire("onCancel");
-	}
-}, onLoad:function () {
-}, onSave:function () {
-}, onCancel:function () {
-}});
+	},
 
+	// events baby!
+	onLoad: function(){},
+	onSave: function(){},
+	onCancel: function(){}
+});
+

Modified: tags/parley-0.53/root/static/magic/src/widget/Editor2.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Editor2.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Editor2.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,405 +8,388 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
+/* TODO:
+ * - font selector
+ * - test, bug fix, more features :)
+*/
 dojo.provide("dojo.widget.Editor2");
+dojo.provide("dojo.widget.html.Editor2");
 dojo.require("dojo.io.*");
+dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.RichText");
 dojo.require("dojo.widget.Editor2Toolbar");
-dojo.require("dojo.uri.cache");
-dojo.widget.Editor2Manager = new dojo.widget.HandlerManager;
-dojo.lang.mixin(dojo.widget.Editor2Manager, {_currentInstance:null, commandState:{Disabled:0, Latched:1, Enabled:2}, getCurrentInstance:function () {
-	return this._currentInstance;
-}, setCurrentInstance:function (inst) {
-	this._currentInstance = inst;
-}, getCommand:function (editor, name) {
-	var oCommand;
-	name = name.toLowerCase();
-	for (var i = 0; i < this._registeredHandlers.length; i++) {
-		oCommand = this._registeredHandlers[i](editor, name);
-		if (oCommand) {
-			return oCommand;
-		}
-	}
-	switch (name) {
-	  case "htmltoggle":
-		oCommand = new dojo.widget.Editor2BrowserCommand(editor, name);
-		break;
-	  case "formatblock":
-		oCommand = new dojo.widget.Editor2FormatBlockCommand(editor, name);
-		break;
-	  case "anchor":
-		oCommand = new dojo.widget.Editor2Command(editor, name);
-		break;
-	  case "createlink":
-		oCommand = new dojo.widget.Editor2DialogCommand(editor, name, {contentFile:"dojo.widget.Editor2Plugin.CreateLinkDialog", contentClass:"Editor2CreateLinkDialog", title:"Insert/Edit Link", width:"300px", height:"200px"});
-		break;
-	  case "insertimage":
-		oCommand = new dojo.widget.Editor2DialogCommand(editor, name, {contentFile:"dojo.widget.Editor2Plugin.InsertImageDialog", contentClass:"Editor2InsertImageDialog", title:"Insert/Edit Image", width:"400px", height:"270px"});
-		break;
-	  default:
-		var curtInst = this.getCurrentInstance();
-		if ((curtInst && curtInst.queryCommandAvailable(name)) || (!curtInst && dojo.widget.Editor2.prototype.queryCommandAvailable(name))) {
-			oCommand = new dojo.widget.Editor2BrowserCommand(editor, name);
-		} else {
-			dojo.debug("dojo.widget.Editor2Manager.getCommand: Unknown command " + name);
-			return;
-		}
-	}
-	return oCommand;
-}, destroy:function () {
-	this._currentInstance = null;
-	dojo.widget.HandlerManager.prototype.destroy.call(this);
-}});
-dojo.addOnUnload(dojo.widget.Editor2Manager, "destroy");
-dojo.lang.declare("dojo.widget.Editor2Command", null, function (editor, name) {
-	this._editor = editor;
-	this._updateTime = 0;
-	this._name = name;
-}, {_text:"Unknown", execute:function (para) {
-	dojo.unimplemented("dojo.widget.Editor2Command.execute");
-}, getText:function () {
-	return this._text;
-}, getState:function () {
-	return dojo.widget.Editor2Manager.commandState.Enabled;
-}, destroy:function () {
-}});
-dojo.widget.Editor2BrowserCommandNames = {"bold":"Bold", "copy":"Copy", "cut":"Cut", "Delete":"Delete", "indent":"Indent", "inserthorizontalrule":"Horizental Rule", "insertorderedlist":"Numbered List", "insertunorderedlist":"Bullet List", "italic":"Italic", "justifycenter":"Align Center", "justifyfull":"Justify", "justifyleft":"Align Left", "justifyright":"Align Right", "outdent":"Outdent", "paste":"Paste", "redo":"Redo", "removeformat":"Remove Format", "selectall":"Select All", "strikethrough":"Strikethrough", "subscript":"Subscript", "superscript":"Superscript", "underline":"Underline", "undo":"Undo", "unlink":"Remove Link", "createlink":"Create Link", "insertimage":"Insert Image", "htmltoggle":"HTML Source", "forecolor":"Foreground Color", "hilitecolor":"Background Color", "plainformatblock":"Paragraph Style", "formatblock":"Paragraph Style", "fontsize":"Font Size", "fontname":"Font Name"};
-dojo.lang.declare("dojo.widget.Editor2BrowserCommand", dojo.widget.Editor2Command, function (editor, name) {
-	var text = dojo.widget.Editor2BrowserCommandNames[name.toLowerCase()];
-	if (text) {
-		this._text = text;
-	}
-}, {execute:function (para) {
-	this._editor.execCommand(this._name, para);
-}, getState:function () {
-	if (this._editor._lastStateTimestamp > this._updateTime || this._state == undefined) {
-		this._updateTime = this._editor._lastStateTimestamp;
-		try {
-			if (this._editor.queryCommandEnabled(this._name)) {
-				if (this._editor.queryCommandState(this._name)) {
-					this._state = dojo.widget.Editor2Manager.commandState.Latched;
-				} else {
-					this._state = dojo.widget.Editor2Manager.commandState.Enabled;
+// dojo.require("dojo.widget.ColorPalette");
+// dojo.require("dojo.string.extras");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Editor2",
+	dojo.widget.html.RichText,
+	{
+		saveUrl: "",
+		saveMethod: "post",
+		saveArgName: "editorContent",
+		closeOnSave: false,
+		shareToolbar: false,
+		toolbarAlwaysVisible: false,
+		htmlEditing: false,
+		_inHtmlMode: false,
+		_htmlEditNode: null,
+
+		commandList: dojo.widget.html.Editor2Toolbar.prototype.commandList,
+		toolbarWidget: null,
+		scrollInterval: null,
+		
+
+		editorOnLoad: function(){
+			var toolbars = dojo.widget.byType("Editor2Toolbar");
+			if((!toolbars.length)||(!this.shareToolbar)){
+				var tbOpts = {};
+				tbOpts.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlEditorToolbarOneline.html");
+				this.toolbarWidget = dojo.widget.createWidget("Editor2Toolbar", 
+										tbOpts, this.domNode, "before");
+				dojo.event.connect(this, "destroy", this.toolbarWidget, "destroy");
+				this.toolbarWidget.hideUnusableButtons(this);
+
+				if(this.object){
+					this.tbBgIframe = new dojo.html.BackgroundIframe(this.toolbarWidget.domNode);
+					this.tbBgIframe.iframe.style.height = "30px";
 				}
-			} else {
-				this._state = dojo.widget.Editor2Manager.commandState.Disabled;
+
+				// need to set position fixed to wherever this thing has landed
+				if(this.toolbarAlwaysVisible){
+					var src = document["documentElement"]||window;
+					this.scrollInterval = setInterval(dojo.lang.hitch(this, "globalOnScrollHandler"), 100);
+					// dojo.event.connect(src, "onscroll", this, "globalOnScrollHandler");
+					dojo.event.connect("before", this, "destroyRendering", this, "unhookScroller");
+				}
+			}else{
+				// FIXME: 	should we try harder to explicitly manage focus in
+				// 			order to prevent too many editors from all querying
+				// 			for button status concurrently?
+				// FIXME: 	selecting in one shared toolbar doesn't clobber
+				// 			selection in the others. This is problematic.
+				this.toolbarWidget = toolbars[0];
 			}
-		}
-		catch (e) {
-			this._state = dojo.widget.Editor2Manager.commandState.Enabled;
-		}
-	}
-	return this._state;
-}, getValue:function () {
-	try {
-		return this._editor.queryCommandValue(this._name);
-	}
-	catch (e) {
-	}
-}});
-dojo.lang.declare("dojo.widget.Editor2FormatBlockCommand", dojo.widget.Editor2BrowserCommand, {});
-dojo.require("dojo.widget.FloatingPane");
-dojo.widget.defineWidget("dojo.widget.Editor2Dialog", [dojo.widget.HtmlWidget, dojo.widget.FloatingPaneBase, dojo.widget.ModalDialogBase], {templateString:"<div id=\"${this.widgetId}\" class=\"dojoFloatingPane\">\n\t<span dojoattachpoint=\"tabStartOuter\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\"\ttabindex=\"0\"></span>\n\t<span dojoattachpoint=\"tabStart\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\" tabindex=\"0\"></span>\n\t<div dojoAttachPoint=\"titleBar\" class=\"dojoFloatingPaneTitleBar\"  style=\"display:none\">\n\t  \t<img dojoAttachPoint=\"titleBarIcon\"  class=\"dojoFloatingPaneTitleBarIcon\">\n\t\t<div dojoAttachPoint=\"closeAction\" dojoAttachEvent=\"onClick:hide\"\n   \t  \t\tclass=\"dojoFloatingPaneCloseIcon\"></div>\n\t\t<div dojoAttachPoint=\"restoreAction\" dojoAttachEvent=\"onClick:restoreWindow\"\n   \t  \t\tclass=\"dojoFloatingPaneRestoreIcon\"></div>\n\t\t<div dojoAttachPoint=\"maximizeAction\" dojoAttachEvent=\"onClick:maximizeWindow\"\n  !
  \t  \t\tclass=\"dojoFloatingPaneMaximizeIcon\"></div>\n\t\t<div dojoAttachPoint=\"minimizeAction\" dojoAttachEvent=\"onClick:minimizeWindow\"\n   \t  \t\tclass=\"dojoFloatingPaneMinimizeIcon\"></div>\n\t  \t<div dojoAttachPoint=\"titleBarText\" class=\"dojoFloatingPaneTitleText\">${this.title}</div>\n\t</div>\n\n\t<div id=\"${this.widgetId}_container\" dojoAttachPoint=\"containerNode\" class=\"dojoFloatingPaneClient\"></div>\n\t<span dojoattachpoint=\"tabEnd\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\" tabindex=\"0\"></span>\n\t<span dojoattachpoint=\"tabEndOuter\" dojoonfocus=\"trapTabs\" dojoonblur=\"clearTrap\" tabindex=\"0\"></span>\n\t<div dojoAttachPoint=\"resizeBar\" class=\"dojoFloatingPaneResizebar\" style=\"display:none\"></div>\n</div>\n", modal:true, width:"", height:"", windowState:"minimized", displayCloseAction:true, contentFile:"", contentClass:"", fillInTemplate:function (args, frag) {
-	this.fillInFloatingPaneTemplate(args, frag);
-	dojo.widget.Editor2Dialog.superclass.fillInTemplate.call(this, args, frag);
-}, postCreate:function () {
-	if (this.contentFile) {
-		dojo.require(this.contentFile);
-	}
-	if (this.modal) {
-		dojo.widget.ModalDialogBase.prototype.postCreate.call(this);
-	} else {
-		with (this.domNode.style) {
-			zIndex = 999;
-			display = "none";
-		}
-	}
-	dojo.widget.FloatingPaneBase.prototype.postCreate.apply(this, arguments);
-	dojo.widget.Editor2Dialog.superclass.postCreate.call(this);
-	if (this.width && this.height) {
-		with (this.domNode.style) {
-			width = this.width;
-			height = this.height;
-		}
-	}
-}, createContent:function () {
-	if (!this.contentWidget && this.contentClass) {
-		this.contentWidget = dojo.widget.createWidget(this.contentClass);
-		this.addChild(this.contentWidget);
-	}
-}, show:function () {
-	if (!this.contentWidget) {
-		dojo.widget.Editor2Dialog.superclass.show.apply(this, arguments);
-		this.createContent();
-		dojo.widget.Editor2Dialog.superclass.hide.call(this);
-	}
-	if (!this.contentWidget || !this.contentWidget.loadContent()) {
-		return;
-	}
-	this.showFloatingPane();
-	dojo.widget.Editor2Dialog.superclass.show.apply(this, arguments);
-	if (this.modal) {
-		this.showModalDialog();
-	}
-	if (this.modal) {
-		this.bg.style.zIndex = this.domNode.style.zIndex - 1;
-	}
-}, onShow:function () {
-	dojo.widget.Editor2Dialog.superclass.onShow.call(this);
-	this.onFloatingPaneShow();
-}, closeWindow:function () {
-	this.hide();
-	dojo.widget.Editor2Dialog.superclass.closeWindow.apply(this, arguments);
-}, hide:function () {
-	if (this.modal) {
-		this.hideModalDialog();
-	}
-	dojo.widget.Editor2Dialog.superclass.hide.call(this);
-}, checkSize:function () {
-	if (this.isShowing()) {
-		if (this.modal) {
-			this._sizeBackground();
-		}
-		this.placeModalDialog();
-		this.onResized();
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.Editor2DialogContent", dojo.widget.HtmlWidget, {widgetsInTemplate:true, loadContent:function () {
-	return true;
-}, cancel:function () {
-	this.parent.hide();
-}});
-dojo.lang.declare("dojo.widget.Editor2DialogCommand", dojo.widget.Editor2BrowserCommand, function (editor, name, dialogParas) {
-	this.dialogParas = dialogParas;
-}, {execute:function () {
-	if (!this.dialog) {
-		if (!this.dialogParas.contentFile || !this.dialogParas.contentClass) {
-			alert("contentFile and contentClass should be set for dojo.widget.Editor2DialogCommand.dialogParas!");
-			return;
-		}
-		this.dialog = dojo.widget.createWidget("Editor2Dialog", this.dialogParas);
-		dojo.body().appendChild(this.dialog.domNode);
-		dojo.event.connect(this, "destroy", this.dialog, "destroy");
-	}
-	this.dialog.show();
-}, getText:function () {
-	return this.dialogParas.title || dojo.widget.Editor2DialogCommand.superclass.getText.call(this);
-}});
-dojo.widget.Editor2ToolbarGroups = {};
-dojo.widget.defineWidget("dojo.widget.Editor2", dojo.widget.RichText, function () {
-	this._loadedCommands = {};
-}, {toolbarAlwaysVisible:false, toolbarWidget:null, scrollInterval:null, toolbarTemplatePath:dojo.uri.cache.set(dojo.uri.moduleUri("dojo.widget", "templates/EditorToolbarOneline.html"), "<div class=\"EditorToolbarDomNode EditorToolbarSmallBg\">\n\t<table cellpadding=\"1\" cellspacing=\"0\" border=\"0\">\n\t\t<tbody>\n\t\t\t<tr valign=\"top\" align=\"left\">\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"htmltoggle\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon\" \n\t\t\t\t\t\tstyle=\"background-image: none; width: 30px;\" >&lt;h&gt;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"copy\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Copy\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"paste\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon!
 _Paste\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"undo\">\n\t\t\t\t\t\t<!-- FIXME: should we have the text \"undo\" here? -->\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Undo\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"redo\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Redo\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td isSpacer=\"true\">\n\t\t\t\t\t<span class=\"iconContainer\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Sep\"\tstyle=\"width: 5px; min-width: 5px;\"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"createlink\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Link\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>!
 \n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\!
 " dojoET
ItemName=\"insertimage\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Image\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"inserthorizontalrule\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_HorizontalLine \">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"bold\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Bold\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"italic\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Italic\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"underline\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Underline\">&nbsp;</span>\n\t\t\t!
 \t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"strikethrough\">\n\t\t\t\t\t\t<span \n\t\t\t\t\t\t\tclass=\"dojoE2TBIcon dojoE2TBIcon_StrikeThrough\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td isSpacer=\"true\">\n\t\t\t\t\t<span class=\"iconContainer\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Sep\" \n\t\t\t\t\t\t\tstyle=\"width: 5px; min-width: 5px;\"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"insertunorderedlist\">\n\t\t\t\t\t\t<span \n\t\t\t\t\t\t\tclass=\"dojoE2TBIcon dojoE2TBIcon_BulletedList\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"insertorderedlist\">\n\t\t\t\t\t\t<span \n\t\t\t\t\t\t\tclass=\"dojoE2TBIcon dojoE2TBIcon_NumberedList\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t!
 \t</td>\n\t\t\t\t<td isSpacer=\"true\">\n\t\t\t\t\t<span class!
 =\"iconC
ontainer\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Sep\" style=\"width: 5px; min-width: 5px;\"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"indent\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Indent\" \n\t\t\t\t\t\t\tunselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"outdent\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Outdent\" \n\t\t\t\t\t\t\tunselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td isSpacer=\"true\">\n\t\t\t\t\t<span class=\"iconContainer\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Sep\" style=\"width: 5px; min-width: 5px;\"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"forecolor\">\n\t\t\t\t\t\t<sp!
 an class=\"dojoE2TBIcon dojoE2TBIcon_TextColor\" \n\t\t\t\t\t\t\tunselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"hilitecolor\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_BackgroundColor\" \n\t\t\t\t\t\t\tunselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td isSpacer=\"true\">\n\t\t\t\t\t<span class=\"iconContainer\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Sep\" style=\"width: 5px; min-width: 5px;\"></span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"justifyleft\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_LeftJustify\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"justifycenter\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon doj!
 oE2TBIcon_CenterJustify\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t!
 \t\t\t</
td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"justifyright\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_RightJustify\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"justifyfull\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_BlockJustify\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\t\n\t\t\t\t<td>\n\t\t\t\t\t<select class=\"dojoEditorToolbarItem\" dojoETItemName=\"plainformatblock\">\n\t\t\t\t\t\t<!-- FIXME: using \"p\" here inserts a paragraph in most cases! -->\n\t\t\t\t\t\t<option value=\"\">-- format --</option>\n\t\t\t\t\t\t<option value=\"p\">Normal</option>\n\t\t\t\t\t\t<option value=\"pre\">Fixed Font</option>\n\t\t\t\t\t\t<option value=\"h1\">Main Heading</option>\n\t\t\t\t\t\t<option value=\"h2\">Section Heading</option>\n\t\t\t\t\t\t<option value=\"h3\">Sub-Heading</option>\n\t\t\t\t\t\t<!-- <op!
 tion value=\"blockquote\">Block Quote</option> -->\n\t\t\t\t\t</select>\n\t\t\t\t</td>\n\t\t\t\t<td><!-- uncomment to enable save button -->\n\t\t\t\t\t<!-- save -->\n\t\t\t\t\t<!--span class=\"iconContainer dojoEditorToolbarItem\" dojoETItemName=\"save\">\n\t\t\t\t\t\t<span class=\"dojoE2TBIcon dojoE2TBIcon_Save\">&nbsp;</span>\n\t\t\t\t\t</span-->\n\t\t\t\t</td>\n\t\t\t\t<td width=\"*\">&nbsp;</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n</div>\n"), toolbarTemplateCssPath:null, toolbarPlaceHolder:"", _inSourceMode:false, _htmlEditNode:null, toolbarGroup:"", shareToolbar:false, contextMenuGroupSet:"", editorOnLoad:function () {
-	dojo.event.topic.publish("dojo.widget.Editor2::preLoadingToolbar", this);
-	if (this.toolbarAlwaysVisible) {
-		dojo.require("dojo.widget.Editor2Plugin.AlwaysShowToolbar");
-	}
-	if (this.toolbarWidget) {
-		this.toolbarWidget.show();
-		dojo.html.insertBefore(this.toolbarWidget.domNode, this.domNode.firstChild);
-	} else {
-		if (this.shareToolbar) {
-			dojo.deprecated("Editor2:shareToolbar is deprecated in favor of toolbarGroup", "0.5");
-			this.toolbarGroup = "defaultDojoToolbarGroup";
-		}
-		if (this.toolbarGroup) {
-			if (dojo.widget.Editor2ToolbarGroups[this.toolbarGroup]) {
-				this.toolbarWidget = dojo.widget.Editor2ToolbarGroups[this.toolbarGroup];
+			dojo.event.topic.registerPublisher("Editor2.clobberFocus", this.editNode, "onfocus");
+			// dojo.event.topic.registerPublisher("Editor2.clobberFocus", this.editNode, "onclick");
+			dojo.event.topic.subscribe("Editor2.clobberFocus", this, "setBlur");
+			dojo.event.connect(this.editNode, "onfocus", this, "setFocus");
+			dojo.event.connect(this.toolbarWidget.linkButton, "onclick", 
+				dojo.lang.hitch(this, function(){
+					var range;
+					if(this.document.selection){
+						range = this.document.selection.createRange().text;
+					}else if(dojo.render.html.mozilla){
+						range = this.window.getSelection().toString();
+					}
+					if(range.length){
+						this.toolbarWidget.exec("createlink", 
+							prompt("Please enter the URL of the link:", "http://"));
+					}else{
+						alert("Please select text to link");
+					}
+				})
+			);
+
+			var focusFunc = dojo.lang.hitch(this, function(){ 
+				if(dojo.render.html.ie){
+					this.editNode.focus();
+				}else{
+					this.window.focus(); 
+				}
+			});
+
+			dojo.event.connect(this.toolbarWidget, "formatSelectClick", focusFunc);
+			dojo.event.connect(this, "execCommand", focusFunc);
+
+			if(this.htmlEditing){
+				var tb = this.toolbarWidget.htmltoggleButton;
+				if(tb){
+					tb.style.display = "";
+					dojo.event.connect(this.toolbarWidget, "htmltoggleClick",
+										this, "toggleHtmlEditing");
+				}
 			}
-		}
-		if (!this.toolbarWidget) {
-			var tbOpts = {shareGroup:this.toolbarGroup, parent:this};
-			tbOpts.templateString = dojo.uri.cache.get(this.toolbarTemplatePath);
-			if (this.toolbarTemplateCssPath) {
-				tbOpts.templateCssPath = this.toolbarTemplateCssPath;
-				tbOpts.templateCssString = dojo.uri.cache.get(this.toolbarTemplateCssPath);
+		},
+
+		toggleHtmlEditing: function(){
+			if(!this._inHtmlMode){
+				this._inHtmlMode = true;
+				this.toolbarWidget.highlightButton("htmltoggle");
+				if(!this._htmlEditNode){
+					this._htmlEditNode = document.createElement("textarea");
+					dojo.html.insertBefore(this._htmlEditNode, this.domNode);
+				}
+				this._htmlEditNode.style.display = "";
+				this._htmlEditNode.style.width = "100%";
+				this._htmlEditNode.style.height = dojo.style.getInnerHeight(this.editNode)+"px";
+				this._htmlEditNode.value = this.editNode.innerHTML;
+				this.domNode.style.display = "none";
+			}else{
+				this._inHtmlMode = false;
+				this.domNode.style.display = "";
+				this.toolbarWidget.unhighlightButton("htmltoggle");
+				dojo.lang.setTimeout(this, "replaceEditorContent", 1, this._htmlEditNode.value);
+				this._htmlEditNode.style.display = "none";
+				this.editNode.focus();
 			}
-			if (this.toolbarPlaceHolder) {
-				this.toolbarWidget = dojo.widget.createWidget("Editor2Toolbar", tbOpts, dojo.byId(this.toolbarPlaceHolder), "after");
-			} else {
-				this.toolbarWidget = dojo.widget.createWidget("Editor2Toolbar", tbOpts, this.domNode.firstChild, "before");
+		},
+
+		setFocus: function(){
+			// dojo.debug("setFocus:", this);
+			dojo.event.connect(this.toolbarWidget, "exec", this, "execCommand");
+		},
+
+		setBlur: function(){
+			// dojo.debug("setBlur:", this);
+			dojo.event.disconnect(this.toolbarWidget, "exec", this, "execCommand");
+		},
+
+		_scrollSetUp: false,
+		_fixEnabled: false,
+		_scrollThreshold: false,
+		_handleScroll: true,
+		globalOnScrollHandler: function(){
+			var isIE = dojo.render.html.ie;
+			if(!this._handleScroll){ return; }
+			var ds = dojo.style;
+			var tdn = this.toolbarWidget.domNode;
+			var db = document["body"];
+			var totalHeight = ds.getOuterHeight(tdn);
+			if(!this._scrollSetUp){
+				this._scrollSetUp = true;
+				var editorWidth =  ds.getOuterWidth(this.domNode); 
+				this._scrollThreshold = ds.abs(tdn, false).y;
+				// dojo.debug("threshold:", this._scrollThreshold);
+				if((isIE)&&(db)&&(ds.getStyle(db, "background-image")=="none")){
+					with(db.style){
+						backgroundImage = "url(" + dojo.uri.dojoUri("src/widget/templates/images/blank.gif") + ")";
+						backgroundAttachment = "fixed";
+					}
+				}
 			}
-			if (this.toolbarGroup) {
-				dojo.widget.Editor2ToolbarGroups[this.toolbarGroup] = this.toolbarWidget;
+
+			var scrollPos = (window["pageYOffset"]) ? window["pageYOffset"] : (document["documentElement"]||document["body"]).scrollTop;
+
+			// FIXME: need to have top and bottom thresholds so toolbar doesn't keep scrolling past the bottom
+			if(scrollPos > this._scrollThreshold){
+				// dojo.debug(scrollPos);
+				if(!this._fixEnabled){
+					this.domNode.style.marginTop = totalHeight+"px";
+					if(isIE){
+						// FIXME: should we just use setBehvior() here instead?
+						var cl = dojo.style.abs(tdn).x;
+						document.body.appendChild(tdn);
+						tdn.style.left = cl+dojo.style.getPixelValue(document.body, "margin-left")+"px";
+						dojo.html.addClass(tdn, "IEFixedToolbar");
+						if(this.object){
+							dojo.html.addClass(this.tbBgIframe, "IEFixedToolbar");
+						}
+						
+					}else{
+						with(tdn.style){
+							position = "fixed";
+							top = "0px";
+						}
+					}
+					tdn.style.zIndex = 1000;
+					this._fixEnabled = true;
+				}
+				// if we're showing the floating toolbar, make sure that if
+				// we've scrolled past the bottom of the editor that we hide
+				// the toolbar for this instance of the editor.
+
+				// TODO: when we get multiple editor toolbar support working
+				// correctly, ensure that we check this against the scroll
+				// position of the bottom-most editor instance.
+				if(!dojo.render.html.safari){
+					// safari reports a bunch of things incorrectly here
+					var eHeight = (this.height) ? parseInt(this.height) : ((this.object) ? dojo.style.getInnerHeight(this.editNode) : this._lastHeight);
+					if(scrollPos > (this._scrollThreshold+eHeight)){
+						tdn.style.display = "none";
+					}else{
+						tdn.style.display = "";
+					}
+				}
+
+			}else if(this._fixEnabled){
+				this.domNode.style.marginTop = null;
+				with(tdn.style){
+					position = "";
+					top = "";
+					zIndex = "";
+					if(isIE){
+						marginTop = "";
+					}
+				}
+				if(isIE){
+					dojo.html.removeClass(tdn, "IEFixedToolbar");
+					dojo.html.insertBefore(tdn, this._htmlEditNode||this.domNode);
+				}
+				this._fixEnabled = false;
 			}
-			dojo.event.connect(this, "close", this.toolbarWidget, "hide");
-			this.toolbarLoaded();
-		}
-	}
-	dojo.event.topic.registerPublisher("Editor2.clobberFocus", this, "clobberFocus");
-	dojo.event.topic.subscribe("Editor2.clobberFocus", this, "setBlur");
-	dojo.event.topic.publish("dojo.widget.Editor2::onLoad", this);
-}, toolbarLoaded:function () {
-}, registerLoadedPlugin:function (obj) {
-	if (!this.loadedPlugins) {
-		this.loadedPlugins = [];
-	}
-	this.loadedPlugins.push(obj);
-}, unregisterLoadedPlugin:function (obj) {
-	for (var i in this.loadedPlugins) {
-		if (this.loadedPlugins[i] === obj) {
-			delete this.loadedPlugins[i];
-			return;
-		}
-	}
-	dojo.debug("dojo.widget.Editor2.unregisterLoadedPlugin: unknow plugin object: " + obj);
-}, execCommand:function (command, argument) {
-	switch (command.toLowerCase()) {
-	  case "htmltoggle":
-		this.toggleHtmlEditing();
-		break;
-	  default:
-		dojo.widget.Editor2.superclass.execCommand.apply(this, arguments);
-	}
-}, queryCommandEnabled:function (command, argument) {
-	switch (command.toLowerCase()) {
-	  case "htmltoggle":
-		return true;
-	  default:
-		if (this._inSourceMode) {
-			return false;
-		}
-		return dojo.widget.Editor2.superclass.queryCommandEnabled.apply(this, arguments);
-	}
-}, queryCommandState:function (command, argument) {
-	switch (command.toLowerCase()) {
-	  case "htmltoggle":
-		return this._inSourceMode;
-	  default:
-		return dojo.widget.Editor2.superclass.queryCommandState.apply(this, arguments);
-	}
-}, onClick:function (e) {
-	dojo.widget.Editor2.superclass.onClick.call(this, e);
-	if (dojo.widget.PopupManager) {
-		if (!e) {
-			e = this.window.event;
-		}
-		dojo.widget.PopupManager.onClick(e);
-	}
-}, clobberFocus:function () {
-}, toggleHtmlEditing:function () {
-	if (this === dojo.widget.Editor2Manager.getCurrentInstance()) {
-		if (!this._inSourceMode) {
-			var html = this.getEditorContent();
-			this._inSourceMode = true;
-			if (!this._htmlEditNode) {
-				this._htmlEditNode = dojo.doc().createElement("textarea");
-				dojo.html.insertAfter(this._htmlEditNode, this.editorObject);
+		},
+
+		unhookScroller: function(){
+			this._handleScroll = false;
+			clearInterval(this.scrollInterval);
+			// var src = document["documentElement"]||window;
+			// dojo.event.disconnect(src, "onscroll", this, "globalOnScrollHandler");
+			if(dojo.render.html.ie){
+				dojo.html.removeClass(this.toolbarWidget.domNode, "IEFixedToolbar");
 			}
-			this._htmlEditNode.style.display = "";
-			this._htmlEditNode.style.width = "100%";
-			this._htmlEditNode.style.height = dojo.html.getBorderBox(this.editNode).height + "px";
-			this._htmlEditNode.value = html;
-			with (this.editorObject.style) {
-				position = "absolute";
-				left = "-2000px";
-				top = "-2000px";
+		},
+
+		_updateToolbarLastRan: null,
+		_updateToolbarTimer: null,
+		_updateToolbarFrequency: 500,
+
+		updateToolbar: function(force){
+			if((!this.isLoaded)||(!this.toolbarWidget)){ return; }
+
+			// keeps the toolbar from updating too frequently
+			// TODO: generalize this functionality?
+			var diff = new Date() - this._updateToolbarLastRan;
+			if( (!force)&&(this._updateToolbarLastRan)&&
+				((diff < this._updateToolbarFrequency)) ){
+
+				clearTimeout(this._updateToolbarTimer);
+				var _this = this;
+				this._updateToolbarTimer = setTimeout(function() {
+					_this.updateToolbar();
+				}, this._updateToolbarFrequency/2);
+				return;
+
+			}else{
+				this._updateToolbarLastRan = new Date();
 			}
-		} else {
-			this._inSourceMode = false;
-			this._htmlEditNode.blur();
-			with (this.editorObject.style) {
-				position = "";
-				left = "";
-				top = "";
+			// end frequency checker
+
+			dojo.lang.forEach(this.commandList, function(cmd){
+					if(cmd == "inserthtml"){ return; }
+					try{
+						if(this.queryCommandEnabled(cmd)){
+							if(this.queryCommandState(cmd)){
+								this.toolbarWidget.highlightButton(cmd);
+							}else{
+								this.toolbarWidget.unhighlightButton(cmd);
+							}
+						}
+					}catch(e){
+						// alert(cmd+":"+e);
+					}
+				}, this);
+
+			var h = dojo.render.html;
+			
+			// safari f's us for selection primitives
+			if(h.safari){ return; }
+
+			var selectedNode = (h.ie) ? this.document.selection.createRange().parentElement() : this.window.getSelection().anchorNode;
+			// make sure we actuall have an element
+			while((selectedNode)&&(selectedNode.nodeType != 1)){
+				selectedNode = selectedNode.parentNode;
 			}
-			var html = this._htmlEditNode.value;
-			dojo.lang.setTimeout(this, "replaceEditorContent", 1, html);
-			this._htmlEditNode.style.display = "none";
-			this.focus();
+			if(!selectedNode){ return; }
+
+			var formats = ["p", "pre", "h1", "h2", "h3", "h4"];
+			// gotta run some specialized updates for the various
+			// formatting options
+			var type = formats[dojo.lang.find(formats, selectedNode.nodeName.toLowerCase())];
+			while((selectedNode)&&(selectedNode!=this.editNode)&&(!type)){
+				selectedNode = selectedNode.parentNode;
+				type = formats[dojo.lang.find(formats, selectedNode.nodeName.toLowerCase())];
+			}
+			if(!type){
+				type = "";
+			}else{
+				if(type.charAt(0)=="h"){
+					this.toolbarWidget.unhighlightButton("bold");
+				}
+			}
+			this.toolbarWidget.selectFormat(type);
+		},
+
+		updateItem: function(item) {
+			try {
+				var cmd = item._name;
+				var enabled = this._richText.queryCommandEnabled(cmd);
+				item.setEnabled(enabled, false, true);
+
+				var active = this._richText.queryCommandState(cmd);
+				if(active && cmd == "underline") {
+					// don't activate underlining if we are on a link
+					active = !this._richText.queryCommandEnabled("unlink");
+				}
+				item.setSelected(active, false, true);
+				return true;
+			} catch(err) {
+				return false;
+			}
+		},
+
+
+		_save: function(e){
+			// FIXME: how should this behave when there's a larger form in play?
+			if(!this.isClosed){
+				if(this.saveUrl.length){
+					var content = {};
+					content[this.saveArgName] = this.getHtml();
+					dojo.io.bind({
+						method: this.saveMethod,
+						url: this.saveUrl,
+						content: content
+					});
+				}else{
+					dojo.debug("please set a saveUrl for the editor");
+				}
+				if(this.closeOnSave){
+					this.close(e.getName().toLowerCase() == "save");
+				}
+			}
+		},
+
+		wireUpOnLoad: function(){
+			if(!dojo.render.html.ie){
+				/*
+				dojo.event.kwConnect({
+					srcObj:		this.document,
+					srcFunc:	"click", 
+					targetObj:	this.toolbarWidget,
+					targetFunc:	"hideAllDropDowns",
+					once:		true
+				});
+				*/
+			}
 		}
-		this.onDisplayChanged(null, true);
-	}
-}, setFocus:function () {
-	if (dojo.widget.Editor2Manager.getCurrentInstance() === this) {
-		return;
-	}
-	this.clobberFocus();
-	dojo.widget.Editor2Manager.setCurrentInstance(this);
-}, setBlur:function () {
-}, saveSelection:function () {
-	this._bookmark = null;
-	this._bookmark = dojo.withGlobal(this.window, dojo.html.selection.getBookmark);
-}, restoreSelection:function () {
-	if (this._bookmark) {
-		this.focus();
-		dojo.withGlobal(this.window, "moveToBookmark", dojo.html.selection, [this._bookmark]);
-		this._bookmark = null;
-	} else {
-		dojo.debug("restoreSelection: no saved selection is found!");
-	}
-}, _updateToolbarLastRan:null, _updateToolbarTimer:null, _updateToolbarFrequency:500, updateToolbar:function (force) {
-	if ((!this.isLoaded) || (!this.toolbarWidget)) {
-		return;
-	}
-	var diff = new Date() - this._updateToolbarLastRan;
-	if ((!force) && (this._updateToolbarLastRan) && ((diff < this._updateToolbarFrequency))) {
-		clearTimeout(this._updateToolbarTimer);
-		var _this = this;
-		this._updateToolbarTimer = setTimeout(function () {
-			_this.updateToolbar();
-		}, this._updateToolbarFrequency / 2);
-		return;
-	} else {
-		this._updateToolbarLastRan = new Date();
-	}
-	if (dojo.widget.Editor2Manager.getCurrentInstance() !== this) {
-		return;
-	}
-	this.toolbarWidget.update();
-}, destroy:function (finalize) {
-	this._htmlEditNode = null;
-	dojo.event.disconnect(this, "close", this.toolbarWidget, "hide");
-	if (!finalize) {
-		this.toolbarWidget.destroy();
-	}
-	dojo.widget.Editor2.superclass.destroy.call(this);
-}, _lastStateTimestamp:0, onDisplayChanged:function (e, forceUpdate) {
-	this._lastStateTimestamp = (new Date()).getTime();
-	dojo.widget.Editor2.superclass.onDisplayChanged.call(this, e);
-	this.updateToolbar(forceUpdate);
-}, onLoad:function () {
-	try {
-		dojo.widget.Editor2.superclass.onLoad.call(this);
-	}
-	catch (e) {
-		dojo.debug(e);
-	}
-	this.editorOnLoad();
-}, onFocus:function () {
-	dojo.widget.Editor2.superclass.onFocus.call(this);
-	this.setFocus();
-}, getEditorContent:function () {
-	if (this._inSourceMode) {
-		return this._htmlEditNode.value;
-	}
-	return dojo.widget.Editor2.superclass.getEditorContent.call(this);
-}, replaceEditorContent:function (html) {
-	if (this._inSourceMode) {
-		this._htmlEditNode.value = html;
-		return;
-	}
-	dojo.widget.Editor2.superclass.replaceEditorContent.apply(this, arguments);
-}, getCommand:function (name) {
-	if (this._loadedCommands[name]) {
-		return this._loadedCommands[name];
-	}
-	var cmd = dojo.widget.Editor2Manager.getCommand(this, name);
-	this._loadedCommands[name] = cmd;
-	return cmd;
-}, shortcuts:[["bold"], ["italic"], ["underline"], ["selectall", "a"], ["insertunorderedlist", "\\"]], setupDefaultShortcuts:function () {
-	var exec = function (cmd) {
-		return function () {
-			cmd.execute();
-		};
-	};
-	var self = this;
-	dojo.lang.forEach(this.shortcuts, function (item) {
-		var cmd = self.getCommand(item[0]);
-		if (cmd) {
-			self.addKeyHandler(item[1] ? item[1] : item[0].charAt(0), item[2] == undefined ? self.KEY_CTRL : item[2], exec(cmd));
-		}
-	});
-}});
+	},
+	"html",
+	function(){
+		var cp = dojo.widget.html.Editor2.prototype;
+		if(!cp._wrappersSet){
+			cp._wrappersSet = true;
+			cp.fillInTemplate = (function(fit){
+				return function(){
+					fit.call(this);
+					this.editorOnLoad();
+				};
+			})(cp.fillInTemplate);
+		
+			cp.onDisplayChanged = (function(odc){
+				return function(){
+					try{
+						odc.call(this);
+						this.updateToolbar();
+					}catch(e){}
+				};
+			})(cp.onDisplayChanged);
 
+			cp.onLoad = (function(ol){
+				return function(){
+					ol.call(this);
+					this.wireUpOnLoad();
+				};
+			})(cp.onLoad);
+		}
+	}
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/Editor2Toolbar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Editor2Toolbar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Editor2Toolbar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,489 +8,312 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Editor2Toolbar");
+dojo.provide("dojo.widget.html.Editor2Toolbar");
+
 dojo.require("dojo.lang.*");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.event.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.display");
 dojo.require("dojo.widget.RichText");
-dojo.require("dojo.widget.PopupContainer");
 dojo.require("dojo.widget.ColorPalette");
-dojo.lang.declare("dojo.widget.HandlerManager", null, function () {
-	this._registeredHandlers = [];
-}, {registerHandler:function (obj, func) {
-	if (arguments.length == 2) {
-		this._registeredHandlers.push(function () {
-			return obj[func].apply(obj, arguments);
-		});
-	} else {
-		this._registeredHandlers.push(obj);
-	}
-}, removeHandler:function (func) {
-	for (var i = 0; i < this._registeredHandlers.length; i++) {
-		if (func === this._registeredHandlers[i]) {
-			delete this._registeredHandlers[i];
-			return;
-		}
-	}
-	dojo.debug("HandlerManager handler " + func + " is not registered, can not remove.");
-}, destroy:function () {
-	for (var i = 0; i < this._registeredHandlers.length; i++) {
-		delete this._registeredHandlers[i];
-	}
-}});
-dojo.widget.Editor2ToolbarItemManager = new dojo.widget.HandlerManager;
-dojo.lang.mixin(dojo.widget.Editor2ToolbarItemManager, {getToolbarItem:function (name) {
-	var item;
-	name = name.toLowerCase();
-	for (var i = 0; i < this._registeredHandlers.length; i++) {
-		item = this._registeredHandlers[i](name);
-		if (item) {
-			return item;
-		}
-	}
-	switch (name) {
-	  case "bold":
-	  case "copy":
-	  case "cut":
-	  case "delete":
-	  case "indent":
-	  case "inserthorizontalrule":
-	  case "insertorderedlist":
-	  case "insertunorderedlist":
-	  case "italic":
-	  case "justifycenter":
-	  case "justifyfull":
-	  case "justifyleft":
-	  case "justifyright":
-	  case "outdent":
-	  case "paste":
-	  case "redo":
-	  case "removeformat":
-	  case "selectall":
-	  case "strikethrough":
-	  case "subscript":
-	  case "superscript":
-	  case "underline":
-	  case "undo":
-	  case "unlink":
-	  case "createlink":
-	  case "insertimage":
-	  case "htmltoggle":
-		item = new dojo.widget.Editor2ToolbarButton(name);
-		break;
-	  case "forecolor":
-	  case "hilitecolor":
-		item = new dojo.widget.Editor2ToolbarColorPaletteButton(name);
-		break;
-	  case "plainformatblock":
-		item = new dojo.widget.Editor2ToolbarFormatBlockPlainSelect("formatblock");
-		break;
-	  case "formatblock":
-		item = new dojo.widget.Editor2ToolbarFormatBlockSelect("formatblock");
-		break;
-	  case "fontsize":
-		item = new dojo.widget.Editor2ToolbarFontSizeSelect("fontsize");
-		break;
-	  case "fontname":
-		item = new dojo.widget.Editor2ToolbarFontNameSelect("fontname");
-		break;
-	  case "inserttable":
-	  case "insertcell":
-	  case "insertcol":
-	  case "insertrow":
-	  case "deletecells":
-	  case "deletecols":
-	  case "deleterows":
-	  case "mergecells":
-	  case "splitcell":
-		dojo.debug(name + " is implemented in dojo.widget.Editor2Plugin.TableOperation, please require it first.");
-		break;
-	  case "inserthtml":
-	  case "blockdirltr":
-	  case "blockdirrtl":
-	  case "dirltr":
-	  case "dirrtl":
-	  case "inlinedirltr":
-	  case "inlinedirrtl":
-		dojo.debug("Not yet implemented toolbar item: " + name);
-		break;
-	  default:
-		dojo.debug("dojo.widget.Editor2ToolbarItemManager.getToolbarItem: Unknown toolbar item: " + name);
-	}
-	return item;
-}});
-dojo.addOnUnload(dojo.widget.Editor2ToolbarItemManager, "destroy");
-dojo.declare("dojo.widget.Editor2ToolbarButton", null, function (name) {
-	this._name = name;
-}, {create:function (node, toolbar, nohover) {
-	this._domNode = node;
-	var cmd = toolbar.parent.getCommand(this._name);
-	if (cmd) {
-		this._domNode.title = cmd.getText();
-	}
-	this.disableSelection(this._domNode);
-	this._parentToolbar = toolbar;
-	dojo.event.connect(this._domNode, "onclick", this, "onClick");
-	if (!nohover) {
-		dojo.event.connect(this._domNode, "onmouseover", this, "onMouseOver");
-		dojo.event.connect(this._domNode, "onmouseout", this, "onMouseOut");
-	}
-}, disableSelection:function (rootnode) {
-	dojo.html.disableSelection(rootnode);
-	var nodes = rootnode.all || rootnode.getElementsByTagName("*");
-	for (var x = 0; x < nodes.length; x++) {
-		dojo.html.disableSelection(nodes[x]);
-	}
-}, onMouseOver:function () {
-	var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-	if (curInst) {
-		var _command = curInst.getCommand(this._name);
-		if (_command && _command.getState() != dojo.widget.Editor2Manager.commandState.Disabled) {
-			this.highlightToolbarItem();
-		}
-	}
-}, onMouseOut:function () {
-	this.unhighlightToolbarItem();
-}, destroy:function () {
-	this._domNode = null;
-	this._parentToolbar = null;
-}, onClick:function (e) {
-	if (this._domNode && !this._domNode.disabled && this._parentToolbar.checkAvailability()) {
-		e.preventDefault();
-		e.stopPropagation();
-		var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-		if (curInst) {
-			var _command = curInst.getCommand(this._name);
-			if (_command) {
-				_command.execute();
-			}
-		}
-	}
-}, refreshState:function () {
-	var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-	var em = dojo.widget.Editor2Manager;
-	if (curInst) {
-		var _command = curInst.getCommand(this._name);
-		if (_command) {
-			var state = _command.getState();
-			if (state != this._lastState) {
-				switch (state) {
-				  case em.commandState.Latched:
-					this.latchToolbarItem();
-					break;
-				  case em.commandState.Enabled:
-					this.enableToolbarItem();
-					break;
-				  case em.commandState.Disabled:
-				  default:
-					this.disableToolbarItem();
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Editor2Toolbar",
+	dojo.widget.HtmlWidget,
+	{
+		commandList: [ "bold", "italic", "underline", "subscript", "superscript",
+			"fontname", "fontsize", "forecolor", "hilitecolor", "justifycenter",
+			"justifyfull", "justifyleft", "justifyright", "cut", "copy", "paste",
+			"delete", "undo", "redo", "createlink", "unlink", "removeformat",
+			"inserthorizontalrule", "insertimage", "insertorderedlist",
+			"insertunorderedlist", "indent", "outdent", "formatblock", "strikethrough", 
+			"inserthtml", "blockdirltr", "blockdirrtl", "dirltr", "dirrtl",
+			"inlinedirltr", "inlinedirrtl", "inserttable", "insertcell",
+			"insertcol", "insertrow", "deletecells", "deletecols", "deleterows",
+			"mergecells", "splitcell"
+		],
+
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlEditorToolbar.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlEditorToolbar.css"),
+
+		forecolorPalette: null,
+		hilitecolorPalette: null,
+
+		// DOM Nodes
+		wikiwordButton: null,
+		htmltoggleButton: null,
+		insertimageButton: null,
+		styleDropdownButton: null,
+		styleDropdownContainer: null,
+		copyButton: null,
+		boldButton: null,
+		italicButton: null,
+		underlineButton: null,
+		justifycenterButton: null,
+		justifyleftButton: null,
+		justifyfullButton: null,
+		justifyrightButton: null,
+		pasteButton: null,
+		undoButton: null,
+		redoButton: null,
+		linkButton: null,
+		insertunorderedlistButton: null,
+		insertorderedlistButton: null,
+		forecolorButton: null,
+		forecolorDropDown: null,
+		hilitecolorButton: null,
+		hilitecolorDropDown: null,
+		formatSelectBox: null,
+		inserthorizontalruleButton: null,
+		strikethroughButton: null,
+		clickInterceptDiv: null,
+		oneLineTr: null,
+
+		buttonClick: function(e){ e.preventDefault(); /* dojo.debug("buttonClick"); */ },
+
+		buttonMouseOver: function(e){  },
+		buttonMouseOut: function(e){  },
+
+
+		// event signals
+		preventSelect: function(e){ if(dojo.render.html.safari){ e.preventDefault(); } },
+		wikiwordClick: function(){ },
+		insertimageClick: function(){ },
+		htmltoggleClick: function(){ },
+
+		styleDropdownClick: function(){
+			dojo.debug("styleDropdownClick:", this.styleDropdownContainer);
+			dojo.style.toggleShowing(this.styleDropdownContainer);
+		},
+
+
+		copyClick: function(){ this.exec("copy"); },
+		boldClick: function(){ this.exec("bold"); },
+		italicClick: function(){ this.exec("italic"); },
+		underlineClick: function(){ this.exec("underline"); },
+		justifyleftClick: function(){ this.exec("justifyleft"); },
+		justifycenterClick: function(){ this.exec("justifycenter"); },
+		justifyfullClick: function(){ this.exec("justifyfull"); },
+		justifyrightClick: function(){ this.exec("justifyright"); },
+		pasteClick: function(){ this.exec("paste"); },
+		undoClick: function(){ this.exec("undo"); },
+		redoClick: function(){ this.exec("redo"); },
+		linkClick: function(){ 
+			// FIXME: we need to alert the user if they haven't selected any text
+			// this.exec(	"createlink", 
+			// 			prompt("Please enter the URL of the link:", "http://"));
+		},
+		insertunorderedlistClick: function(){ this.exec("insertunorderedlist"); },
+		insertorderedlistClick: function(){ this.exec("insertorderedlist"); },
+		inserthorizontalruleClick: function(){ this.exec("inserthorizontalrule"); },
+		strikethroughClick: function(){ this.exec("strikethrough"); },
+
+		formatSelectClick: function(){ 
+			var sv = this.formatSelectBox.value.toLowerCase();
+			this.exec("formatblock", sv);
+		},
+
+		normalTextClick: function(){ this.exec("formatblock", "p"); },
+		h1TextClick: function(){ this.exec("formatblock", "h1"); },
+		h2TextClick: function(){ this.exec("formatblock", "h2"); },
+		h3TextClick: function(){ this.exec("formatblock", "h3"); },
+		h4TextClick: function(){ this.exec("formatblock", "h4"); },
+		indentClick: function(){ this.exec("indent"); },
+		outdentClick: function(){ this.exec("outdent"); },
+
+
+		hideAllDropDowns: function(){
+			this.domNode.style.height = "";
+			dojo.lang.forEach(dojo.widget.byType("Editor2Toolbar"), function(tb){
+				try{
+					dojo.style.hide(tb.forecolorDropDown);
+					dojo.style.hide(tb.hilitecolorDropDown);
+					dojo.style.hide(tb.styleDropdownContainer);
+					if(tb.clickInterceptDiv){
+						dojo.style.hide(tb.clickInterceptDiv);
+					}
+				}catch(e){}
+				if(dojo.render.html.ie){
+					try{
+						dojo.style.hide(tb.forecolorPalette.bgIframe);
+					}catch(e){}
+					try{
+						dojo.style.hide(tb.hilitecolorPalette.bgIframe);
+					}catch(e){}
 				}
-				this._lastState = state;
-			}
-		}
-	}
-	return em.commandState.Enabled;
-}, latchToolbarItem:function () {
-	this._domNode.disabled = false;
-	this.removeToolbarItemStyle(this._domNode);
-	dojo.html.addClass(this._domNode, this._parentToolbar.ToolbarLatchedItemStyle);
-}, enableToolbarItem:function () {
-	this._domNode.disabled = false;
-	this.removeToolbarItemStyle(this._domNode);
-	dojo.html.addClass(this._domNode, this._parentToolbar.ToolbarEnabledItemStyle);
-}, disableToolbarItem:function () {
-	this._domNode.disabled = true;
-	this.removeToolbarItemStyle(this._domNode);
-	dojo.html.addClass(this._domNode, this._parentToolbar.ToolbarDisabledItemStyle);
-}, highlightToolbarItem:function () {
-	dojo.html.addClass(this._domNode, this._parentToolbar.ToolbarHighlightedItemStyle);
-}, unhighlightToolbarItem:function () {
-	dojo.html.removeClass(this._domNode, this._parentToolbar.ToolbarHighlightedItemStyle);
-}, removeToolbarItemStyle:function () {
-	dojo.html.removeClass(this._domNode, this._parentToolbar.ToolbarEnabledItemStyle);
-	dojo.html.removeClass(this._domNode, this._parentToolbar.ToolbarLatchedItemStyle);
-	dojo.html.removeClass(this._domNode, this._parentToolbar.ToolbarDisabledItemStyle);
-	this.unhighlightToolbarItem();
-}});
-dojo.declare("dojo.widget.Editor2ToolbarDropDownButton", dojo.widget.Editor2ToolbarButton, {onClick:function () {
-	if (this._domNode && !this._domNode.disabled && this._parentToolbar.checkAvailability()) {
-		if (!this._dropdown) {
-			this._dropdown = dojo.widget.createWidget("PopupContainer", {});
-			this._domNode.appendChild(this._dropdown.domNode);
-		}
-		if (this._dropdown.isShowingNow) {
-			this._dropdown.close();
-		} else {
-			this.onDropDownShown();
-			this._dropdown.open(this._domNode, null, this._domNode);
-		}
-	}
-}, destroy:function () {
-	this.onDropDownDestroy();
-	if (this._dropdown) {
-		this._dropdown.destroy();
-	}
-	dojo.widget.Editor2ToolbarDropDownButton.superclass.destroy.call(this);
-}, onDropDownShown:function () {
-}, onDropDownDestroy:function () {
-}});
-dojo.declare("dojo.widget.Editor2ToolbarColorPaletteButton", dojo.widget.Editor2ToolbarDropDownButton, {onDropDownShown:function () {
-	if (!this._colorpalette) {
-		this._colorpalette = dojo.widget.createWidget("ColorPalette", {});
-		this._dropdown.addChild(this._colorpalette);
-		this.disableSelection(this._dropdown.domNode);
-		this.disableSelection(this._colorpalette.domNode);
-		dojo.event.connect(this._colorpalette, "onColorSelect", this, "setColor");
-		dojo.event.connect(this._dropdown, "open", this, "latchToolbarItem");
-		dojo.event.connect(this._dropdown, "close", this, "enableToolbarItem");
-	}
-}, setColor:function (color) {
-	this._dropdown.close();
-	var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-	if (curInst) {
-		var _command = curInst.getCommand(this._name);
-		if (_command) {
-			_command.execute(color);
-		}
-	}
-}});
-dojo.declare("dojo.widget.Editor2ToolbarFormatBlockPlainSelect", dojo.widget.Editor2ToolbarButton, {create:function (node, toolbar) {
-	this._domNode = node;
-	this._parentToolbar = toolbar;
-	this._domNode = node;
-	this.disableSelection(this._domNode);
-	dojo.event.connect(this._domNode, "onchange", this, "onChange");
-}, destroy:function () {
-	this._domNode = null;
-}, onChange:function () {
-	if (this._parentToolbar.checkAvailability()) {
-		var sv = this._domNode.value.toLowerCase();
-		var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-		if (curInst) {
-			var _command = curInst.getCommand(this._name);
-			if (_command) {
-				_command.execute(sv);
-			}
-		}
-	}
-}, refreshState:function () {
-	if (this._domNode) {
-		dojo.widget.Editor2ToolbarFormatBlockPlainSelect.superclass.refreshState.call(this);
-		var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-		if (curInst) {
-			var _command = curInst.getCommand(this._name);
-			if (_command) {
-				var format = _command.getValue();
-				if (!format) {
-					format = "";
+			});
+		},
+
+		selectFormat: function(format){
+			dojo.lang.forEach(this.formatSelectBox.options, function(item){
+				if(item.value.toLowerCase() == format.toLowerCase()){
+					item.selected = true;
 				}
-				dojo.lang.forEach(this._domNode.options, function (item) {
-					if (item.value.toLowerCase() == format.toLowerCase()) {
-						item.selected = true;
+			});
+		},
+
+		forecolorClick: function(e){
+			this.colorClick(e, "forecolor");
+		},
+
+		hilitecolorClick: function(e){
+			this.colorClick(e, "hilitecolor");
+		},
+
+		// FIXME: these methods aren't currently dealing with clicking in the
+		// general document to hide the menu
+		colorClick: function(e, type){
+			var h = dojo.render.html;
+			this.hideAllDropDowns();
+			// FIXME: if we've been "popped out", we need to set the height of the toolbar.
+			e.stopPropagation();
+			var dd = this[type+"DropDown"];
+			var pal = this[type+"Palette"];
+			dojo.style.toggleShowing(dd);
+			if(!pal){
+				pal = this[type+"Palette"] = dojo.widget.createWidget("ColorPalette", {}, dd, "first");
+				var fcp = pal.domNode;
+				with(dd.style){
+					width = dojo.html.getOuterWidth(fcp) + "px";
+					height = dojo.html.getOuterHeight(fcp) + "px";
+					zIndex = 1002;
+					position = "absolute";
+				}
+
+				dojo.event.connect(	"after",
+									pal, "onColorSelect",
+									this, "exec",
+									function(mi){ mi.args.unshift(type); return mi.proceed(); }
+				);
+
+				dojo.event.connect(	"after",
+									pal, "onColorSelect",
+									dojo.style, "toggleShowing",
+									this, function(mi){ mi.args.unshift(dd); return mi.proceed(); }
+				);
+
+				var cid = this.clickInterceptDiv;
+				if(!cid){
+					cid = this.clickInterceptDiv = document.createElement("div");
+					document.body.appendChild(cid);
+					with(cid.style){
+						backgroundColor = "transparent";
+						top = left = "0px";
+						height = width = "100%";
+						position = "absolute";
+						border = "none";
+						display = "none";
+						zIndex = 1001;
 					}
+					dojo.event.connect(cid, "onclick", function(){ cid.style.display = "none"; });
+				}
+				dojo.event.connect(pal, "onColorSelect", function(){ cid.style.display = "none"; });
+
+				dojo.event.kwConnect({
+					srcObj:		document.body, 
+					srcFunc:	"onclick", 
+					targetObj:	this,
+					targetFunc:	"hideAllDropDowns",
+					once:		true
 				});
+				document.body.appendChild(dd);
 			}
-		}
-	}
-}});
-dojo.declare("dojo.widget.Editor2ToolbarComboItem", dojo.widget.Editor2ToolbarDropDownButton, {href:null, create:function (node, toolbar) {
-	dojo.widget.Editor2ToolbarComboItem.superclass.create.apply(this, arguments);
-	if (!this._contentPane) {
-		dojo.require("dojo.widget.ContentPane");
-		this._contentPane = dojo.widget.createWidget("ContentPane", {preload:"true"});
-		this._contentPane.addOnLoad(this, "setup");
-		this._contentPane.setUrl(this.href);
-	}
-}, onMouseOver:function (e) {
-	if (this._lastState != dojo.widget.Editor2Manager.commandState.Disabled) {
-		dojo.html.addClass(e.currentTarget, this._parentToolbar.ToolbarHighlightedSelectStyle);
-	}
-}, onMouseOut:function (e) {
-	dojo.html.removeClass(e.currentTarget, this._parentToolbar.ToolbarHighlightedSelectStyle);
-}, onDropDownShown:function () {
-	if (!this._dropdown.__addedContentPage) {
-		this._dropdown.addChild(this._contentPane);
-		this._dropdown.__addedContentPage = true;
-	}
-}, setup:function () {
-}, onChange:function (e) {
-	if (this._parentToolbar.checkAvailability()) {
-		var name = e.currentTarget.getAttribute("dropDownItemName");
-		var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-		if (curInst) {
-			var _command = curInst.getCommand(this._name);
-			if (_command) {
-				_command.execute(name);
-			}
-		}
-	}
-	this._dropdown.close();
-}, onMouseOverItem:function (e) {
-	dojo.html.addClass(e.currentTarget, this._parentToolbar.ToolbarHighlightedSelectItemStyle);
-}, onMouseOutItem:function (e) {
-	dojo.html.removeClass(e.currentTarget, this._parentToolbar.ToolbarHighlightedSelectItemStyle);
-}});
-dojo.declare("dojo.widget.Editor2ToolbarFormatBlockSelect", dojo.widget.Editor2ToolbarComboItem, {href:dojo.uri.moduleUri("dojo.widget", "templates/Editor2/EditorToolbar_FormatBlock.html"), setup:function () {
-	dojo.widget.Editor2ToolbarFormatBlockSelect.superclass.setup.call(this);
-	var nodes = this._contentPane.domNode.all || this._contentPane.domNode.getElementsByTagName("*");
-	this._blockNames = {};
-	this._blockDisplayNames = {};
-	for (var x = 0; x < nodes.length; x++) {
-		var node = nodes[x];
-		dojo.html.disableSelection(node);
-		var name = node.getAttribute("dropDownItemName");
-		if (name) {
-			this._blockNames[name] = node;
-			var childrennodes = node.getElementsByTagName(name);
-			this._blockDisplayNames[name] = childrennodes[childrennodes.length - 1].innerHTML;
-		}
-	}
-	for (var name in this._blockNames) {
-		dojo.event.connect(this._blockNames[name], "onclick", this, "onChange");
-		dojo.event.connect(this._blockNames[name], "onmouseover", this, "onMouseOverItem");
-		dojo.event.connect(this._blockNames[name], "onmouseout", this, "onMouseOutItem");
-	}
-}, onDropDownDestroy:function () {
-	if (this._blockNames) {
-		for (var name in this._blockNames) {
-			delete this._blockNames[name];
-			delete this._blockDisplayNames[name];
-		}
-	}
-}, refreshState:function () {
-	dojo.widget.Editor2ToolbarFormatBlockSelect.superclass.refreshState.call(this);
-	if (this._lastState != dojo.widget.Editor2Manager.commandState.Disabled) {
-		var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-		if (curInst) {
-			var _command = curInst.getCommand(this._name);
-			if (_command) {
-				var format = _command.getValue();
-				if (format == this._lastSelectedFormat && this._blockDisplayNames) {
-					return this._lastState;
+			dojo.style.toggleShowing(this.clickInterceptDiv);
+			var pos = dojo.style.abs(this[type+"Button"]);
+			dojo.html.placeOnScreenPoint(dd, pos.x, pos.y, 0, false);
+			if(pal.bgIframe){
+				with(pal.bgIframe.style){
+					display = "block";
+					left = dd.style.left;
+					top = dd.style.top;
+					width = dojo.style.getOuterWidth(dd)+"px";
+					height = dojo.style.getOuterHeight(dd)+"px";
 				}
-				this._lastSelectedFormat = format;
-				var label = this._domNode.getElementsByTagName("label")[0];
-				var isSet = false;
-				if (this._blockDisplayNames) {
-					for (var name in this._blockDisplayNames) {
-						if (name == format) {
-							label.innerHTML = this._blockDisplayNames[name];
-							isSet = true;
-							break;
+			}
+		},
+
+		uninitialize: function(){
+			if(!dojo.render.html.ie){
+				// apparently this causes leakage on IE!
+				dojo.event.kwDisconnect({
+					srcObj:		document.body, 
+					srcFunc:	"onclick", 
+					targetObj:	this,
+					targetFunc:	"hideAllDropDowns",
+					once:		true
+				});
+			}
+		},
+
+		// stub for observers
+		exec: function(what, arg){ /* dojo.debug(what, new Date()); */ },
+
+		hideUnusableButtons: function(obj){
+			var op = obj||dojo.widget.html.RichText.prototype;
+			dojo.lang.forEach(this.commandList,
+				function(cmd){
+					if(this[cmd+"Button"]){
+						var cb = this[cmd+"Button"];
+						if(!op.queryCommandAvailable(cmd)){
+							cb.style.display = "none";
+							cb.parentNode.style.display = "none";
 						}
 					}
-					if (!isSet) {
-						label.innerHTML = "&nbsp;";
-					}
+				},
+				this);
+				if(this.oneLineTr){
+					var lastVisibleIsSpacer = false;
+					var lastVisible = false;
+					var tds = this.oneLineTr.getElementsByTagName("td");
+					dojo.lang.forEach(tds, function(td){
+						if(td.getAttribute("isSpacer")){
+							if(td.style.display != "none"){
+								if(lastVisibleIsSpacer){
+									td.style.display = "none";
+								}
+								lastVisibleIsSpacer = true;
+							}else{
+								lastVisible = td;
+								lastVisibleIsSpacer = true;
+							}
+						}else{
+							if(td.style.display != "none"){
+								lastVisible = td;
+								lastVisibleIsSpacer = false;
+							}
+						}
+					});
 				}
+		},
+
+		highlightButton: function(name){
+			var bn = name+"Button";
+			if(this[bn]){
+				with(this[bn].style){
+					backgroundColor = "White";
+					border = "1px solid #aeaeab";
+				}
 			}
-		}
-	}
-	return this._lastState;
-}});
-dojo.declare("dojo.widget.Editor2ToolbarFontSizeSelect", dojo.widget.Editor2ToolbarComboItem, {href:dojo.uri.moduleUri("dojo.widget", "templates/Editor2/EditorToolbar_FontSize.html"), setup:function () {
-	dojo.widget.Editor2ToolbarFormatBlockSelect.superclass.setup.call(this);
-	var nodes = this._contentPane.domNode.all || this._contentPane.domNode.getElementsByTagName("*");
-	this._fontsizes = {};
-	this._fontSizeDisplayNames = {};
-	for (var x = 0; x < nodes.length; x++) {
-		var node = nodes[x];
-		dojo.html.disableSelection(node);
-		var name = node.getAttribute("dropDownItemName");
-		if (name) {
-			this._fontsizes[name] = node;
-			this._fontSizeDisplayNames[name] = node.getElementsByTagName("font")[0].innerHTML;
-		}
-	}
-	for (var name in this._fontsizes) {
-		dojo.event.connect(this._fontsizes[name], "onclick", this, "onChange");
-		dojo.event.connect(this._fontsizes[name], "onmouseover", this, "onMouseOverItem");
-		dojo.event.connect(this._fontsizes[name], "onmouseout", this, "onMouseOutItem");
-	}
-}, onDropDownDestroy:function () {
-	if (this._fontsizes) {
-		for (var name in this._fontsizes) {
-			delete this._fontsizes[name];
-			delete this._fontSizeDisplayNames[name];
-		}
-	}
-}, refreshState:function () {
-	dojo.widget.Editor2ToolbarFormatBlockSelect.superclass.refreshState.call(this);
-	if (this._lastState != dojo.widget.Editor2Manager.commandState.Disabled) {
-		var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-		if (curInst) {
-			var _command = curInst.getCommand(this._name);
-			if (_command) {
-				var size = _command.getValue();
-				if (size == this._lastSelectedSize && this._fontSizeDisplayNames) {
-					return this._lastState;
+		},
+
+		unhighlightButton: function(name){
+			var bn = name+"Button";
+			if(this[bn]){
+				// dojo.debug("unhighlighting:", name);
+				with(this[bn].style){
+					backgroundColor = "";
+					border = "";
 				}
-				this._lastSelectedSize = size;
-				var label = this._domNode.getElementsByTagName("label")[0];
-				var isSet = false;
-				if (this._fontSizeDisplayNames) {
-					for (var name in this._fontSizeDisplayNames) {
-						if (name == size) {
-							label.innerHTML = this._fontSizeDisplayNames[name];
-							isSet = true;
-							break;
-						}
-					}
-					if (!isSet) {
-						label.innerHTML = "&nbsp;";
-					}
-				}
 			}
 		}
-	}
-	return this._lastState;
-}});
-dojo.declare("dojo.widget.Editor2ToolbarFontNameSelect", dojo.widget.Editor2ToolbarFontSizeSelect, {href:dojo.uri.moduleUri("dojo.widget", "templates/Editor2/EditorToolbar_FontName.html")});
-dojo.widget.defineWidget("dojo.widget.Editor2Toolbar", dojo.widget.HtmlWidget, function () {
-	dojo.event.connect(this, "fillInTemplate", dojo.lang.hitch(this, function () {
-		if (dojo.render.html.ie) {
-			this.domNode.style.zoom = 1;
-		}
-	}));
-}, {templateString:"<div dojoAttachPoint=\"domNode\" class=\"EditorToolbarDomNode\" unselectable=\"on\">\n\t<table cellpadding=\"3\" cellspacing=\"0\" border=\"0\">\n\t\t<!--\n\t\t\tour toolbar should look something like:\n\n\t\t\t+=======+=======+=======+=============================================+\n\t\t\t| w   w | style | copy  | bo | it | un | le | ce | ri |\n\t\t\t| w w w | style |=======|==============|==============|\n\t\t\t|  w w  | style | paste |  undo | redo | change style |\n\t\t\t+=======+=======+=======+=============================================+\n\t\t-->\n\t\t<tbody>\n\t\t\t<tr valign=\"top\">\n\t\t\t\t<td rowspan=\"2\">\n\t\t\t\t\t<div class=\"bigIcon\" dojoAttachPoint=\"wikiWordButton\"\n\t\t\t\t\t\tdojoOnClick=\"wikiWordClick; buttonClick;\">\n\t\t\t\t\t\t<span style=\"font-size: 30px; margin-left: 5px;\">\n\t\t\t\t\t\t\tW\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t\t<td rowspan=\"2\">\n\t\t\t\t\t<div class=\"bigIcon\" dojoAttachPoint!
 =\"styleDropdownButton\"\n\t\t\t\t\t\tdojoOnClick=\"styleDropdownClick; buttonClick;\">\n\t\t\t\t\t\t<span unselectable=\"on\"\n\t\t\t\t\t\t\tstyle=\"font-size: 30px; margin-left: 5px;\">\n\t\t\t\t\t\t\tS\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"StyleDropdownContainer\" style=\"display: none;\"\n\t\t\t\t\t\tdojoAttachPoint=\"styleDropdownContainer\">\n\t\t\t\t\t\t<table cellpadding=\"0\" cellspacing=\"0\" border=\"0\"\n\t\t\t\t\t\t\theight=\"100%\" width=\"100%\">\n\t\t\t\t\t\t\t<tr valign=\"top\">\n\t\t\t\t\t\t\t\t<td rowspan=\"2\">\n\t\t\t\t\t\t\t\t\t<div style=\"height: 245px; overflow: auto;\">\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"normalTextClick\">normal</div>\n\t\t\t\t\t\t\t\t\t\t<h1 class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"h1TextClick\">Heading 1</h1>\n\t\t\t\t\t\t\t\t\t\t<h2 class=\"he!
 adingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\!
 t\t\t\t\
t\t\t\t\t\t\tdojoOnClick=\"h2TextClick\">Heading 2</h2>\n\t\t\t\t\t\t\t\t\t\t<h3 class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"h3TextClick\">Heading 3</h3>\n\t\t\t\t\t\t\t\t\t\t<h4 class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"h4TextClick\">Heading 4</h4>\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"blahTextClick\">blah</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"blahTextClick\">blah</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\"\n\t\t\t\t\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\t\t\t\t\tdojoOnClick=\"blahTextClick\">blah</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\">blah</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\">blah</div>\n\t!
 \t\t\t\t\t\t\t\t\t<div class=\"headingContainer\">blah</div>\n\t\t\t\t\t\t\t\t\t\t<div class=\"headingContainer\">blah</div>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t<!--\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\t<span class=\"iconContainer\" dojoOnClick=\"buttonClick;\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"icon justifyleft\" \n\t\t\t\t\t\t\t\t\t\t\tstyle=\"float: left;\">&nbsp;</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t<span class=\"iconContainer\" dojoOnClick=\"buttonClick;\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"icon justifycenter\" \n\t\t\t\t\t\t\t\t\t\t\tstyle=\"float: left;\">&nbsp;</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t<span class=\"iconContainer\" dojoOnClick=\"buttonClick;\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"icon justifyright\" \n\t\t\t\t\t\t\t\t\t\t\tstyle=\"float: left;\">&nbsp;</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t<span class=\"iconContainer\" dojoOnClick=\"buttonClick;\">\n\t\t\t\t\t\t\t\t\t\t<spa!
 n class=\"icon justifyfull\" \n\t\t\t\t\t\t\t\t\t\t\tstyle=\"f!
 loat: le
ft;\">&nbsp;</span>\n\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t\t-->\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr valign=\"top\">\n\t\t\t\t\t\t\t\t<td>\n\t\t\t\t\t\t\t\t\tthud\n\t\t\t\t\t\t\t\t</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</table>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<!-- copy -->\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"copyButton\"\n\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\tdojoOnClick=\"copyClick; buttonClick;\">\n\t\t\t\t\t\t<span class=\"icon copy\" \n\t\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\t\tstyle=\"float: left;\">&nbsp;</span> copy\n\t\t\t\t\t</span>\n\t\t\t\t\t<!-- \"droppable\" options -->\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"boldButton\"\n\t\t\t\t\t\tunselectable=\"on\"\n\t\t\t\t\t\tdojoOnClick=\"boldClick; buttonClick;\">\n\t\t\t\t\t\t<span class=\"icon bold\" unselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoin!
 t=\"italicButton\"\n\t\t\t\t\t\tdojoOnClick=\"italicClick; buttonClick;\">\n\t\t\t\t\t\t<span class=\"icon italic\" unselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"underlineButton\"\n\t\t\t\t\t\tdojoOnClick=\"underlineClick; buttonClick;\">\n\t\t\t\t\t\t<span class=\"icon underline\" unselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"leftButton\"\n\t\t\t\t\t\tdojoOnClick=\"leftClick; buttonClick;\">\n\t\t\t\t\t\t<span class=\"icon justifyleft\" unselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"fullButton\"\n\t\t\t\t\t\tdojoOnClick=\"fullClick; buttonClick;\">\n\t\t\t\t\t\t<span class=\"icon justifyfull\" unselectable=\"on\">&nbsp;</span>\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"rightButton\"\n\t\t\t\t\t\tdojoOnClick=\"rightClick; buttonClick;\">\n\t\t\t\!
 t\t\t<span class=\"icon justifyright\" unselectable=\"on\">&nb!
 sp;</spa
n>\n\t\t\t\t\t</span>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t<!-- paste -->\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"pasteButton\"\n\t\t\t\t\t\tdojoOnClick=\"pasteClick; buttonClick;\" unselectable=\"on\">\n\t\t\t\t\t\t<span class=\"icon paste\" style=\"float: left;\" unselectable=\"on\">&nbsp;</span> paste\n\t\t\t\t\t</span>\n\t\t\t\t\t<!-- \"droppable\" options -->\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"undoButton\"\n\t\t\t\t\t\tdojoOnClick=\"undoClick; buttonClick;\" unselectable=\"on\">\n\t\t\t\t\t\t<span class=\"icon undo\" style=\"float: left;\" unselectable=\"on\">&nbsp;</span> undo\n\t\t\t\t\t</span>\n\t\t\t\t\t<span class=\"iconContainer\" dojoAttachPoint=\"redoButton\"\n\t\t\t\t\t\tdojoOnClick=\"redoClick; buttonClick;\" unselectable=\"on\">\n\t\t\t\t\t\t<span class=\"icon redo\" style=\"float: left;\" unselectable=\"on\">&nbsp;</span> redo\n\t\t\t\t\t</span>\n\t\t\t\t</td>\t\n\t\t\t</tr>\n\t\t</tbody>!
 \n\t</table>\n</div>\n", templateCssString:".StyleDropdownContainer {\n\tposition: absolute;\n\tz-index: 1000;\n\toverflow: auto;\n\tcursor: default;\n\twidth: 250px;\n\theight: 250px;\n\tbackground-color: white;\n\tborder: 1px solid black;\n}\n\n.ColorDropdownContainer {\n\tposition: absolute;\n\tz-index: 1000;\n\toverflow: auto;\n\tcursor: default;\n\twidth: 250px;\n\theight: 150px;\n\tbackground-color: white;\n\tborder: 1px solid black;\n}\n\n.EditorToolbarDomNode {\n\tbackground-image: url(buttons/bg-fade.png);\n\tbackground-repeat: repeat-x;\n\tbackground-position: 0px -50px;\n}\n\n.EditorToolbarSmallBg {\n\tbackground-image: url(images/toolbar-bg.gif);\n\tbackground-repeat: repeat-x;\n\tbackground-position: 0px 0px;\n}\n\n/*\nbody {\n\tbackground:url(images/blank.gif) fixed;\n}*/\n\n.IEFixedToolbar {\n\tposition:absolute;\n\t/* top:0; */\n\ttop: expression(eval((document.documentElement||document.body).scrollTop));\n}\n\ndiv.bigIcon {\n\twidth: 40px;\n\theight: 40px; !
 \n\t/* background-color: white; */\n\t/* border: 1px solid #a6!
 a7a3; */
\n\tfont-family: Verdana, Trebuchet, Tahoma, Arial;\n}\n\n.iconContainer {\n\tfont-family: Verdana, Trebuchet, Tahoma, Arial;\n\tfont-size: 13px;\n\tfloat: left;\n\theight: 18px;\n\tdisplay: block;\n\t/* background-color: white; */\n\tcursor: pointer;\n\tpadding: 1px 4px 1px 1px; /* almost the same as a transparent border */\n\tborder: 0px;\n}\n\n.dojoE2TBIcon {\n\tdisplay: block;\n\ttext-align: center;\n\tmin-width: 18px;\n\twidth: 18px;\n\theight: 18px;\n\t/* background-color: #a6a7a3; */\n\tbackground-repeat: no-repeat;\n\tbackground-image: url(buttons/aggregate.gif);\n}\n\n\n.dojoE2TBIcon[class~=dojoE2TBIcon] {\n}\n\n.ToolbarButtonLatched {\n	border: #316ac5 1px solid; !important;\n	padding: 0px 3px 0px 0px; !important; /* make room for border */\n	background-color: #c1d2ee;\n}\n\n.ToolbarButtonHighlighted {\n	border: #316ac5 1px solid; !important;\n	padding: 0px 3px 0px 0px; !important; /* make room for border */\n	background-color: #dff1ff;\n}\n\n.ToolbarButtonDisabled!
 {\n	filter: gray() alpha(opacity=30); /* IE */\n	opacity: 0.30; /* Safari, Opera and Mozilla */\n}\n\n.headingContainer {\n\twidth: 150px;\n\theight: 30px;\n\tmargin: 0px;\n\t/* padding-left: 5px; */\n\toverflow: hidden;\n\tline-height: 25px;\n\tborder-bottom: 1px solid black;\n\tborder-top: 1px solid white;\n}\n\n.EditorToolbarDomNode select {\n\tfont-size: 14px;\n}\n \n.dojoE2TBIcon_Sep { width: 5px; min-width: 5px; max-width: 5px; background-position: 0px 0px}\n.dojoE2TBIcon_Backcolor { background-position: -18px 0px}\n.dojoE2TBIcon_Bold { background-position: -36px 0px}\n.dojoE2TBIcon_Cancel { background-position: -54px 0px}\n.dojoE2TBIcon_Copy { background-position: -72px 0px}\n.dojoE2TBIcon_Link { background-position: -90px 0px}\n.dojoE2TBIcon_Cut { background-position: -108px 0px}\n.dojoE2TBIcon_Delete { background-position: -126px 0px}\n.dojoE2TBIcon_TextColor { background-position: -144px 0px}\n.dojoE2TBIcon_BackgroundColor { background-position: -162px 0px}\n.dojo!
 E2TBIcon_Indent { background-position: -180px 0px}\n.dojoE2TBI!
 con_Hori
zontalLine { background-position: -198px 0px}\n.dojoE2TBIcon_Image { background-position: -216px 0px}\n.dojoE2TBIcon_NumberedList { background-position: -234px 0px}\n.dojoE2TBIcon_Table { background-position: -252px 0px}\n.dojoE2TBIcon_BulletedList { background-position: -270px 0px}\n.dojoE2TBIcon_Italic { background-position: -288px 0px}\n.dojoE2TBIcon_CenterJustify { background-position: -306px 0px}\n.dojoE2TBIcon_BlockJustify { background-position: -324px 0px}\n.dojoE2TBIcon_LeftJustify { background-position: -342px 0px}\n.dojoE2TBIcon_RightJustify { background-position: -360px 0px}\n.dojoE2TBIcon_left_to_right { background-position: -378px 0px}\n.dojoE2TBIcon_list_bullet_indent { background-position: -396px 0px}\n.dojoE2TBIcon_list_bullet_outdent { background-position: -414px 0px}\n.dojoE2TBIcon_list_num_indent { background-position: -432px 0px}\n.dojoE2TBIcon_list_num_outdent { background-position: -450px 0px}\n.dojoE2TBIcon_Outdent { background-position: -468px 0px}\n.!
 dojoE2TBIcon_Paste { background-position: -486px 0px}\n.dojoE2TBIcon_Redo { background-position: -504px 0px}\ndojoE2TBIcon_RemoveFormat { background-position: -522px 0px}\n.dojoE2TBIcon_right_to_left { background-position: -540px 0px}\n.dojoE2TBIcon_Save { background-position: -558px 0px}\n.dojoE2TBIcon_Space { background-position: -576px 0px}\n.dojoE2TBIcon_StrikeThrough { background-position: -594px 0px}\n.dojoE2TBIcon_Subscript { background-position: -612px 0px}\n.dojoE2TBIcon_Superscript { background-position: -630px 0px}\n.dojoE2TBIcon_Underline { background-position: -648px 0px}\n.dojoE2TBIcon_Undo { background-position: -666px 0px}\n.dojoE2TBIcon_WikiWord { background-position: -684px 0px}\n\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/EditorToolbar.css"), ToolbarLatchedItemStyle:"ToolbarButtonLatched", ToolbarEnabledItemStyle:"ToolbarButtonEnabled", ToolbarDisabledItemStyle:"ToolbarButtonDisabled", ToolbarHighlightedItemStyle:"ToolbarButtonHighli!
 ghted", ToolbarHighlightedSelectStyle:"ToolbarSelectHighlighte!
 d", Tool
barHighlightedSelectItemStyle:"ToolbarSelectHighlightedItem", postCreate:function () {
-	var nodes = dojo.html.getElementsByClass("dojoEditorToolbarItem", this.domNode);
-	this.items = {};
-	for (var x = 0; x < nodes.length; x++) {
-		var node = nodes[x];
-		var itemname = node.getAttribute("dojoETItemName");
-		if (itemname) {
-			var item = dojo.widget.Editor2ToolbarItemManager.getToolbarItem(itemname);
-			if (item) {
-				item.create(node, this);
-				this.items[itemname.toLowerCase()] = item;
-			} else {
-				node.style.display = "none";
+	},
+	"html",
+	function(){
+		// dojo.event.connect(this, "fillInTemplate", this, "hideUnusableButtons");
+		dojo.event.connect(this, "fillInTemplate", dojo.lang.hitch(this, function(){
+			if(dojo.render.html.ie){
+				this.domNode.style.zoom = 1.0;
 			}
-		}
+		}));
 	}
-}, update:function () {
-	for (var cmd in this.items) {
-		this.items[cmd].refreshState();
-	}
-}, shareGroup:"", checkAvailability:function () {
-	if (!this.shareGroup) {
-		this.parent.focus();
-		return true;
-	}
-	var curInst = dojo.widget.Editor2Manager.getCurrentInstance();
-	if (this.shareGroup == curInst.toolbarGroup) {
-		return true;
-	}
-	return false;
-}, destroy:function () {
-	for (var it in this.items) {
-		this.items[it].destroy();
-		delete this.items[it];
-	}
-	dojo.widget.Editor2Toolbar.superclass.destroy.call(this);
-}});
-
+);

Deleted: tags/parley-0.53/root/static/magic/src/widget/FilteringTable.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/FilteringTable.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/FilteringTable.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,710 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.FilteringTable");
-dojo.require("dojo.date.format");
-dojo.require("dojo.math");
-dojo.require("dojo.collections.Store");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.util");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.event.*");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.FilteringTable", dojo.widget.HtmlWidget, function () {
-	this.store = new dojo.collections.Store();
-	this.valueField = "Id";
-	this.multiple = false;
-	this.maxSelect = 0;
-	this.maxSortable = 1;
-	this.minRows = 0;
-	this.defaultDateFormat = "%D";
-	this.isInitialized = false;
-	this.alternateRows = false;
-	this.columns = [];
-	this.sortInformation = [{index:0, direction:0}];
-	this.headClass = "";
-	this.tbodyClass = "";
-	this.headerClass = "";
-	this.headerUpClass = "selectedUp";
-	this.headerDownClass = "selectedDown";
-	this.rowClass = "";
-	this.rowAlternateClass = "alt";
-	this.rowSelectedClass = "selected";
-	this.columnSelected = "sorted-column";
-}, {isContainer:false, templatePath:null, templateCssPath:null, getTypeFromString:function (s) {
-	var parts = s.split("."), i = 0, obj = dj_global;
-	do {
-		obj = obj[parts[i++]];
-	} while (i < parts.length && obj);
-	return (obj != dj_global) ? obj : null;
-}, getByRow:function (row) {
-	return this.store.getByKey(dojo.html.getAttribute(row, "value"));
-}, getDataByRow:function (row) {
-	return this.store.getDataByKey(dojo.html.getAttribute(row, "value"));
-}, getRow:function (obj) {
-	var rows = this.domNode.tBodies[0].rows;
-	for (var i = 0; i < rows.length; i++) {
-		if (this.store.getDataByKey(dojo.html.getAttribute(rows[i], "value")) == obj) {
-			return rows[i];
-		}
-	}
-	return null;
-}, getColumnIndex:function (fieldPath) {
-	for (var i = 0; i < this.columns.length; i++) {
-		if (this.columns[i].getField() == fieldPath) {
-			return i;
-		}
-	}
-	return -1;
-}, getSelectedData:function () {
-	var data = this.store.get();
-	var a = [];
-	for (var i = 0; i < data.length; i++) {
-		if (data[i].isSelected) {
-			a.push(data[i].src);
-		}
-	}
-	if (this.multiple) {
-		return a;
-	} else {
-		return a[0];
-	}
-}, isSelected:function (obj) {
-	var data = this.store.get();
-	for (var i = 0; i < data.length; i++) {
-		if (data[i].src == obj) {
-			return true;
-		}
-	}
-	return false;
-}, isValueSelected:function (val) {
-	var v = this.store.getByKey(val);
-	if (v) {
-		return v.isSelected;
-	}
-	return false;
-}, isIndexSelected:function (idx) {
-	var v = this.store.getByIndex(idx);
-	if (v) {
-		return v.isSelected;
-	}
-	return false;
-}, isRowSelected:function (row) {
-	var v = this.getByRow(row);
-	if (v) {
-		return v.isSelected;
-	}
-	return false;
-}, reset:function () {
-	this.store.clearData();
-	this.columns = [];
-	this.sortInformation = [{index:0, direction:0}];
-	this.resetSelections();
-	this.isInitialized = false;
-	this.onReset();
-}, resetSelections:function () {
-	this.store.forEach(function (element) {
-		element.isSelected = false;
-	});
-}, onReset:function () {
-}, select:function (obj) {
-	var data = this.store.get();
-	for (var i = 0; i < data.length; i++) {
-		if (data[i].src == obj) {
-			data[i].isSelected = true;
-			break;
-		}
-	}
-	this.onDataSelect(obj);
-}, selectByValue:function (val) {
-	this.select(this.store.getDataByKey(val));
-}, selectByIndex:function (idx) {
-	this.select(this.store.getDataByIndex(idx));
-}, selectByRow:function (row) {
-	this.select(this.getDataByRow(row));
-}, selectAll:function () {
-	this.store.forEach(function (element) {
-		element.isSelected = true;
-	});
-}, onDataSelect:function (obj) {
-}, toggleSelection:function (obj) {
-	var data = this.store.get();
-	for (var i = 0; i < data.length; i++) {
-		if (data[i].src == obj) {
-			data[i].isSelected = !data[i].isSelected;
-			break;
-		}
-	}
-	this.onDataToggle(obj);
-}, toggleSelectionByValue:function (val) {
-	this.toggleSelection(this.store.getDataByKey(val));
-}, toggleSelectionByIndex:function (idx) {
-	this.toggleSelection(this.store.getDataByIndex(idx));
-}, toggleSelectionByRow:function (row) {
-	this.toggleSelection(this.getDataByRow(row));
-}, toggleAll:function () {
-	this.store.forEach(function (element) {
-		element.isSelected = !element.isSelected;
-	});
-}, onDataToggle:function (obj) {
-}, _meta:{field:null, format:null, filterer:null, noSort:false, sortType:"String", dataType:String, sortFunction:null, filterFunction:null, label:null, align:"left", valign:"middle", getField:function () {
-	return this.field || this.label;
-}, getType:function () {
-	return this.dataType;
-}}, createMetaData:function (obj) {
-	for (var p in this._meta) {
-		if (!obj[p]) {
-			obj[p] = this._meta[p];
-		}
-	}
-	if (!obj.label) {
-		obj.label = obj.field;
-	}
-	if (!obj.filterFunction) {
-		obj.filterFunction = this._defaultFilter;
-	}
-	return obj;
-}, parseMetadata:function (head) {
-	this.columns = [];
-	this.sortInformation = [];
-	var row = head.getElementsByTagName("tr")[0];
-	var cells = row.getElementsByTagName("td");
-	if (cells.length == 0) {
-		cells = row.getElementsByTagName("th");
-	}
-	for (var i = 0; i < cells.length; i++) {
-		var o = this.createMetaData({});
-		if (dojo.html.hasAttribute(cells[i], "align")) {
-			o.align = dojo.html.getAttribute(cells[i], "align");
-		}
-		if (dojo.html.hasAttribute(cells[i], "valign")) {
-			o.valign = dojo.html.getAttribute(cells[i], "valign");
-		}
-		if (dojo.html.hasAttribute(cells[i], "nosort")) {
-			o.noSort = (dojo.html.getAttribute(cells[i], "nosort") == "true");
-		}
-		if (dojo.html.hasAttribute(cells[i], "sortusing")) {
-			var trans = dojo.html.getAttribute(cells[i], "sortusing");
-			var f = this.getTypeFromString(trans);
-			if (f != null && f != window && typeof (f) == "function") {
-				o.sortFunction = f;
-			}
-		}
-		o.label = dojo.html.renderedTextContent(cells[i]);
-		if (dojo.html.hasAttribute(cells[i], "field")) {
-			o.field = dojo.html.getAttribute(cells[i], "field");
-		} else {
-			if (o.label.length > 0) {
-				o.field = o.label;
-			} else {
-				o.field = "field" + i;
-			}
-		}
-		if (dojo.html.hasAttribute(cells[i], "format")) {
-			o.format = dojo.html.getAttribute(cells[i], "format");
-		}
-		if (dojo.html.hasAttribute(cells[i], "dataType")) {
-			var sortType = dojo.html.getAttribute(cells[i], "dataType");
-			if (sortType.toLowerCase() == "html" || sortType.toLowerCase() == "markup") {
-				o.sortType = "__markup__";
-			} else {
-				var type = this.getTypeFromString(sortType);
-				if (type) {
-					o.sortType = sortType;
-					o.dataType = type;
-				}
-			}
-		}
-		if (dojo.html.hasAttribute(cells[i], "filterusing")) {
-			var trans = dojo.html.getAttribute(cells[i], "filterusing");
-			var f = this.getTypeFromString(trans);
-			if (f != null && f != window && typeof (f) == "function") {
-				o.filterFunction = f;
-			}
-		}
-		this.columns.push(o);
-		if (dojo.html.hasAttribute(cells[i], "sort")) {
-			var info = {index:i, direction:0};
-			var dir = dojo.html.getAttribute(cells[i], "sort");
-			if (!isNaN(parseInt(dir))) {
-				dir = parseInt(dir);
-				info.direction = (dir != 0) ? 1 : 0;
-			} else {
-				info.direction = (dir.toLowerCase() == "desc") ? 1 : 0;
-			}
-			this.sortInformation.push(info);
-		}
-	}
-	if (this.sortInformation.length == 0) {
-		this.sortInformation.push({index:0, direction:0});
-	} else {
-		if (this.sortInformation.length > this.maxSortable) {
-			this.sortInformation.length = this.maxSortable;
-		}
-	}
-}, parseData:function (body) {
-	if (body.rows.length == 0 && this.columns.length == 0) {
-		return;
-	}
-	var self = this;
-	this["__selected__"] = [];
-	var arr = this.store.getFromHtml(this.columns, body, function (obj, row) {
-		if (typeof (obj[self.valueField]) == "undefined" || obj[self.valueField] == null) {
-			obj[self.valueField] = dojo.html.getAttribute(row, "value");
-		}
-		if (dojo.html.getAttribute(row, "selected") == "true") {
-			self["__selected__"].push(obj);
-		}
-	});
-	this.store.setData(arr, true);
-	this.render();
-	for (var i = 0; i < this["__selected__"].length; i++) {
-		this.select(this["__selected__"][i]);
-	}
-	this.renderSelections();
-	delete this["__selected__"];
-	this.isInitialized = true;
-}, onSelect:function (e) {
-	var row = dojo.html.getParentByType(e.target, "tr");
-	if (dojo.html.hasAttribute(row, "emptyRow")) {
-		return;
-	}
-	var body = dojo.html.getParentByType(row, "tbody");
-	if (this.multiple) {
-		if (e.shiftKey) {
-			var startRow;
-			var rows = body.rows;
-			for (var i = 0; i < rows.length; i++) {
-				if (rows[i] == row) {
-					break;
-				}
-				if (this.isRowSelected(rows[i])) {
-					startRow = rows[i];
-				}
-			}
-			if (!startRow) {
-				startRow = row;
-				for (; i < rows.length; i++) {
-					if (this.isRowSelected(rows[i])) {
-						row = rows[i];
-						break;
-					}
-				}
-			}
-			this.resetSelections();
-			if (startRow == row) {
-				this.toggleSelectionByRow(row);
-			} else {
-				var doSelect = false;
-				for (var i = 0; i < rows.length; i++) {
-					if (rows[i] == startRow) {
-						doSelect = true;
-					}
-					if (doSelect) {
-						this.selectByRow(rows[i]);
-					}
-					if (rows[i] == row) {
-						doSelect = false;
-					}
-				}
-			}
-		} else {
-			this.toggleSelectionByRow(row);
-		}
-	} else {
-		this.resetSelections();
-		this.toggleSelectionByRow(row);
-	}
-	this.renderSelections();
-}, onSort:function (e) {
-	var oldIndex = this.sortIndex;
-	var oldDirection = this.sortDirection;
-	var source = e.target;
-	var row = dojo.html.getParentByType(source, "tr");
-	var cellTag = "td";
-	if (row.getElementsByTagName(cellTag).length == 0) {
-		cellTag = "th";
-	}
-	var headers = row.getElementsByTagName(cellTag);
-	var header = dojo.html.getParentByType(source, cellTag);
-	for (var i = 0; i < headers.length; i++) {
-		dojo.html.setClass(headers[i], this.headerClass);
-		if (headers[i] == header) {
-			if (this.sortInformation[0].index != i) {
-				this.sortInformation.unshift({index:i, direction:0});
-			} else {
-				this.sortInformation[0] = {index:i, direction:(~this.sortInformation[0].direction) & 1};
-			}
-		}
-	}
-	this.sortInformation.length = Math.min(this.sortInformation.length, this.maxSortable);
-	for (var i = 0; i < this.sortInformation.length; i++) {
-		var idx = this.sortInformation[i].index;
-		var dir = (~this.sortInformation[i].direction) & 1;
-		dojo.html.setClass(headers[idx], dir == 0 ? this.headerDownClass : this.headerUpClass);
-	}
-	this.render();
-}, onFilter:function () {
-}, _defaultFilter:function (obj) {
-	return true;
-}, setFilter:function (field, fn) {
-	for (var i = 0; i < this.columns.length; i++) {
-		if (this.columns[i].getField() == field) {
-			this.columns[i].filterFunction = fn;
-			break;
-		}
-	}
-	this.applyFilters();
-}, setFilterByIndex:function (idx, fn) {
-	this.columns[idx].filterFunction = fn;
-	this.applyFilters();
-}, clearFilter:function (field) {
-	for (var i = 0; i < this.columns.length; i++) {
-		if (this.columns[i].getField() == field) {
-			this.columns[i].filterFunction = this._defaultFilter;
-			break;
-		}
-	}
-	this.applyFilters();
-}, clearFilterByIndex:function (idx) {
-	this.columns[idx].filterFunction = this._defaultFilter;
-	this.applyFilters();
-}, clearFilters:function () {
-	for (var i = 0; i < this.columns.length; i++) {
-		this.columns[i].filterFunction = this._defaultFilter;
-	}
-	var rows = this.domNode.tBodies[0].rows;
-	for (var i = 0; i < rows.length; i++) {
-		rows[i].style.display = "";
-		if (this.alternateRows) {
-			dojo.html[((i % 2 == 1) ? "addClass" : "removeClass")](rows[i], this.rowAlternateClass);
-		}
-	}
-	this.onFilter();
-}, applyFilters:function () {
-	var alt = 0;
-	var rows = this.domNode.tBodies[0].rows;
-	for (var i = 0; i < rows.length; i++) {
-		var b = true;
-		var row = rows[i];
-		for (var j = 0; j < this.columns.length; j++) {
-			var value = this.store.getField(this.getDataByRow(row), this.columns[j].getField());
-			if (this.columns[j].getType() == Date && value != null && !value.getYear) {
-				value = new Date(value);
-			}
-			if (!this.columns[j].filterFunction(value)) {
-				b = false;
-				break;
-			}
-		}
-		row.style.display = (b ? "" : "none");
-		if (b && this.alternateRows) {
-			dojo.html[((alt++ % 2 == 1) ? "addClass" : "removeClass")](row, this.rowAlternateClass);
-		}
-	}
-	this.onFilter();
-}, createSorter:function (info) {
-	var self = this;
-	var sortFunctions = [];
-	function createSortFunction(fieldIndex, dir) {
-		var meta = self.columns[fieldIndex];
-		var field = meta.getField();
-		return function (rowA, rowB) {
-			if (dojo.html.hasAttribute(rowA, "emptyRow")) {
-				return 1;
-			}
-			if (dojo.html.hasAttribute(rowB, "emptyRow")) {
-				return -1;
-			}
-			var a = self.store.getField(self.getDataByRow(rowA), field);
-			var b = self.store.getField(self.getDataByRow(rowB), field);
-			var ret = 0;
-			if (a > b) {
-				ret = 1;
-			}
-			if (a < b) {
-				ret = -1;
-			}
-			return dir * ret;
-		};
-	}
-	var current = 0;
-	var max = Math.min(info.length, this.maxSortable, this.columns.length);
-	while (current < max) {
-		var direction = (info[current].direction == 0) ? 1 : -1;
-		sortFunctions.push(createSortFunction(info[current].index, direction));
-		current++;
-	}
-	return function (rowA, rowB) {
-		var idx = 0;
-		while (idx < sortFunctions.length) {
-			var ret = sortFunctions[idx++](rowA, rowB);
-			if (ret != 0) {
-				return ret;
-			}
-		}
-		return 0;
-	};
-}, createRow:function (obj) {
-	var row = document.createElement("tr");
-	dojo.html.disableSelection(row);
-	if (obj.key != null) {
-		row.setAttribute("value", obj.key);
-	}
-	for (var j = 0; j < this.columns.length; j++) {
-		var cell = document.createElement("td");
-		cell.setAttribute("align", this.columns[j].align);
-		cell.setAttribute("valign", this.columns[j].valign);
-		dojo.html.disableSelection(cell);
-		var val = this.store.getField(obj.src, this.columns[j].getField());
-		if (typeof (val) == "undefined") {
-			val = "";
-		}
-		this.fillCell(cell, this.columns[j], val);
-		row.appendChild(cell);
-	}
-	return row;
-}, fillCell:function (cell, meta, val) {
-	if (meta.sortType == "__markup__") {
-		cell.innerHTML = val;
-	} else {
-		if (meta.getType() == Date) {
-			val = new Date(val);
-			if (!isNaN(val)) {
-				var format = this.defaultDateFormat;
-				if (meta.format) {
-					format = meta.format;
-				}
-				cell.innerHTML = dojo.date.strftime(val, format);
-			} else {
-				cell.innerHTML = val;
-			}
-		} else {
-			if ("Number number int Integer float Float".indexOf(meta.getType()) > -1) {
-				if (val.length == 0) {
-					val = "0";
-				}
-				var n = parseFloat(val, 10) + "";
-				if (n.indexOf(".") > -1) {
-					n = dojo.math.round(parseFloat(val, 10), 2);
-				}
-				cell.innerHTML = n;
-			} else {
-				cell.innerHTML = val;
-			}
-		}
-	}
-}, prefill:function () {
-	this.isInitialized = false;
-	var body = this.domNode.tBodies[0];
-	while (body.childNodes.length > 0) {
-		body.removeChild(body.childNodes[0]);
-	}
-	if (this.minRows > 0) {
-		for (var i = 0; i < this.minRows; i++) {
-			var row = document.createElement("tr");
-			if (this.alternateRows) {
-				dojo.html[((i % 2 == 1) ? "addClass" : "removeClass")](row, this.rowAlternateClass);
-			}
-			row.setAttribute("emptyRow", "true");
-			for (var j = 0; j < this.columns.length; j++) {
-				var cell = document.createElement("td");
-				cell.innerHTML = "&nbsp;";
-				row.appendChild(cell);
-			}
-			body.appendChild(row);
-		}
-	}
-}, init:function () {
-	this.isInitialized = false;
-	var head = this.domNode.getElementsByTagName("thead")[0];
-	if (head.getElementsByTagName("tr").length == 0) {
-		var row = document.createElement("tr");
-		for (var i = 0; i < this.columns.length; i++) {
-			var cell = document.createElement("td");
-			cell.setAttribute("align", this.columns[i].align);
-			cell.setAttribute("valign", this.columns[i].valign);
-			dojo.html.disableSelection(cell);
-			cell.innerHTML = this.columns[i].label;
-			row.appendChild(cell);
-			if (!this.columns[i].noSort) {
-				dojo.event.connect(cell, "onclick", this, "onSort");
-			}
-		}
-		dojo.html.prependChild(row, head);
-	}
-	if (this.store.get().length == 0) {
-		return false;
-	}
-	var idx = this.domNode.tBodies[0].rows.length;
-	if (!idx || idx == 0 || this.domNode.tBodies[0].rows[0].getAttribute("emptyRow") == "true") {
-		idx = 0;
-		var body = this.domNode.tBodies[0];
-		while (body.childNodes.length > 0) {
-			body.removeChild(body.childNodes[0]);
-		}
-		var data = this.store.get();
-		for (var i = 0; i < data.length; i++) {
-			var row = this.createRow(data[i]);
-			body.appendChild(row);
-			idx++;
-		}
-	}
-	if (this.minRows > 0 && idx < this.minRows) {
-		idx = this.minRows - idx;
-		for (var i = 0; i < idx; i++) {
-			row = document.createElement("tr");
-			row.setAttribute("emptyRow", "true");
-			for (var j = 0; j < this.columns.length; j++) {
-				cell = document.createElement("td");
-				cell.innerHTML = "&nbsp;";
-				row.appendChild(cell);
-			}
-			body.appendChild(row);
-		}
-	}
-	var row = this.domNode.getElementsByTagName("thead")[0].rows[0];
-	var cellTag = "td";
-	if (row.getElementsByTagName(cellTag).length == 0) {
-		cellTag = "th";
-	}
-	var headers = row.getElementsByTagName(cellTag);
-	for (var i = 0; i < headers.length; i++) {
-		dojo.html.setClass(headers[i], this.headerClass);
-	}
-	for (var i = 0; i < this.sortInformation.length; i++) {
-		var idx = this.sortInformation[i].index;
-		var dir = (~this.sortInformation[i].direction) & 1;
-		dojo.html.setClass(headers[idx], dir == 0 ? this.headerDownClass : this.headerUpClass);
-	}
-	this.isInitialized = true;
-	return this.isInitialized;
-}, render:function () {
-	if (!this.isInitialized) {
-		var b = this.init();
-		if (!b) {
-			this.prefill();
-			return;
-		}
-	}
-	var rows = [];
-	var body = this.domNode.tBodies[0];
-	var emptyRowIdx = -1;
-	for (var i = 0; i < body.rows.length; i++) {
-		rows.push(body.rows[i]);
-	}
-	var sortFunction = this.createSorter(this.sortInformation);
-	if (sortFunction) {
-		rows.sort(sortFunction);
-	}
-	for (var i = 0; i < rows.length; i++) {
-		if (this.alternateRows) {
-			dojo.html[((i % 2 == 1) ? "addClass" : "removeClass")](rows[i], this.rowAlternateClass);
-		}
-		dojo.html[(this.isRowSelected(body.rows[i]) ? "addClass" : "removeClass")](body.rows[i], this.rowSelectedClass);
-		body.appendChild(rows[i]);
-	}
-}, renderSelections:function () {
-	var body = this.domNode.tBodies[0];
-	for (var i = 0; i < body.rows.length; i++) {
-		dojo.html[(this.isRowSelected(body.rows[i]) ? "addClass" : "removeClass")](body.rows[i], this.rowSelectedClass);
-	}
-}, initialize:function () {
-	var self = this;
-	dojo.event.connect(this.store, "onSetData", function () {
-		self.store.forEach(function (element) {
-			element.isSelected = false;
-		});
-		self.isInitialized = false;
-		var body = self.domNode.tBodies[0];
-		if (body) {
-			while (body.childNodes.length > 0) {
-				body.removeChild(body.childNodes[0]);
-			}
-		}
-		self.render();
-	});
-	dojo.event.connect(this.store, "onClearData", function () {
-		self.isInitialized = false;
-		self.render();
-	});
-	dojo.event.connect(this.store, "onAddData", function (addedObject) {
-		var row = self.createRow(addedObject);
-		self.domNode.tBodies[0].appendChild(row);
-		self.render();
-	});
-	dojo.event.connect(this.store, "onAddDataRange", function (arr) {
-		for (var i = 0; i < arr.length; i++) {
-			arr[i].isSelected = false;
-			var row = self.createRow(arr[i]);
-			self.domNode.tBodies[0].appendChild(row);
-		}
-		self.render();
-	});
-	dojo.event.connect(this.store, "onRemoveData", function (removedObject) {
-		var rows = self.domNode.tBodies[0].rows;
-		for (var i = 0; i < rows.length; i++) {
-			if (self.getDataByRow(rows[i]) == removedObject.src) {
-				rows[i].parentNode.removeChild(rows[i]);
-				break;
-			}
-		}
-		self.render();
-	});
-	dojo.event.connect(this.store, "onUpdateField", function (obj, fieldPath, val) {
-		var row = self.getRow(obj);
-		var idx = self.getColumnIndex(fieldPath);
-		if (row && row.cells[idx] && self.columns[idx]) {
-			self.fillCell(row.cells[idx], self.columns[idx], val);
-		}
-	});
-}, postCreate:function () {
-	this.store.keyField = this.valueField;
-	if (this.domNode) {
-		if (this.domNode.nodeName.toLowerCase() != "table") {
-		}
-		if (this.domNode.getElementsByTagName("thead")[0]) {
-			var head = this.domNode.getElementsByTagName("thead")[0];
-			if (this.headClass.length > 0) {
-				head.className = this.headClass;
-			}
-			dojo.html.disableSelection(this.domNode);
-			this.parseMetadata(head);
-			var header = "td";
-			if (head.getElementsByTagName(header).length == 0) {
-				header = "th";
-			}
-			var headers = head.getElementsByTagName(header);
-			for (var i = 0; i < headers.length; i++) {
-				if (!this.columns[i].noSort) {
-					dojo.event.connect(headers[i], "onclick", this, "onSort");
-				}
-			}
-		} else {
-			this.domNode.appendChild(document.createElement("thead"));
-		}
-		if (this.domNode.tBodies.length < 1) {
-			var body = document.createElement("tbody");
-			this.domNode.appendChild(body);
-		} else {
-			var body = this.domNode.tBodies[0];
-		}
-		if (this.tbodyClass.length > 0) {
-			body.className = this.tbodyClass;
-		}
-		dojo.event.connect(body, "onclick", this, "onSelect");
-		this.parseData(body);
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/FisheyeList.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/FisheyeList.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/FisheyeList.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,439 +8,736 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.FisheyeList");
+dojo.provide("dojo.widget.html.FisheyeList");
+dojo.provide("dojo.widget.html.FisheyeListItem");
 
+//
+// TODO
+// fix SVG support, and turn it on only if the browser supports it
+// fix really long labels in vertical mode
+//
 
-dojo.provide("dojo.widget.FisheyeList");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.html.util");
-dojo.require("dojo.event.*");
-dojo.widget.defineWidget("dojo.widget.FisheyeList", dojo.widget.HtmlWidget, function () {
-	this.pos = {x:-1, y:-1};
-	this.EDGE = {CENTER:0, LEFT:1, RIGHT:2, TOP:3, BOTTOM:4};
-	this.timerScale = 1;
-}, {templateString:"<div class=\"dojoHtmlFisheyeListBar\"></div>", templateCssString:".dojoHtmlFisheyeListItemLabel {\n\tfont-family: Arial, Helvetica, sans-serif;\n\tbackground-color: #eee;\n\tborder: 2px solid #666;\n\tpadding: 2px;\n\ttext-align: center;\n\tposition: absolute;\n\tdisplay: none;\n}\n\n.dojoHtmlFisheyeListItemLabel.selected {\n\tdisplay: block;\n}\n\n.dojoHtmlFisheyeListItemImage {\n\tborder: 0px;\n\tposition: absolute;\n}\n\n.dojoHtmlFisheyeListItem {\n\tposition: absolute;\n\tz-index: 2;\n}\n\n.dojoHtmlFisheyeListBar {\n\tposition: relative;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/FisheyeList.css"), isContainer:true, snarfChildDomOutput:true, itemWidth:40, itemHeight:40, itemMaxWidth:150, itemMaxHeight:150, orientation:"horizontal", conservativeTrigger:false, effectUnits:2, itemPadding:10, attachEdge:"center", labelEdge:"bottom", enableCrappySvgSupport:false, fillInTemplate:function () {
-	dojo.html.disableSelection(this.domNode);
-	this.isHorizontal = (this.orientation == "horizontal");
-	this.selectedNode = -1;
-	this.isOver = false;
-	this.hitX1 = -1;
-	this.hitY1 = -1;
-	this.hitX2 = -1;
-	this.hitY2 = -1;
-	this.anchorEdge = this._toEdge(this.attachEdge, this.EDGE.CENTER);
-	this.labelEdge = this._toEdge(this.labelEdge, this.EDGE.TOP);
-	if (this.isHorizontal && (this.anchorEdge == this.EDGE.LEFT)) {
-		this.anchorEdge = this.EDGE.CENTER;
-	}
-	if (this.isHorizontal && (this.anchorEdge == this.EDGE.RIGHT)) {
-		this.anchorEdge = this.EDGE.CENTER;
-	}
-	if (!this.isHorizontal && (this.anchorEdge == this.EDGE.TOP)) {
-		this.anchorEdge = this.EDGE.CENTER;
-	}
-	if (!this.isHorizontal && (this.anchorEdge == this.EDGE.BOTTOM)) {
-		this.anchorEdge = this.EDGE.CENTER;
-	}
-	if (this.labelEdge == this.EDGE.CENTER) {
-		this.labelEdge = this.EDGE.TOP;
-	}
-	if (this.isHorizontal && (this.labelEdge == this.EDGE.LEFT)) {
-		this.labelEdge = this.EDGE.TOP;
-	}
-	if (this.isHorizontal && (this.labelEdge == this.EDGE.RIGHT)) {
-		this.labelEdge = this.EDGE.TOP;
-	}
-	if (!this.isHorizontal && (this.labelEdge == this.EDGE.TOP)) {
-		this.labelEdge = this.EDGE.LEFT;
-	}
-	if (!this.isHorizontal && (this.labelEdge == this.EDGE.BOTTOM)) {
-		this.labelEdge = this.EDGE.LEFT;
-	}
-	this.proximityLeft = this.itemWidth * (this.effectUnits - 0.5);
-	this.proximityRight = this.itemWidth * (this.effectUnits - 0.5);
-	this.proximityTop = this.itemHeight * (this.effectUnits - 0.5);
-	this.proximityBottom = this.itemHeight * (this.effectUnits - 0.5);
-	if (this.anchorEdge == this.EDGE.LEFT) {
-		this.proximityLeft = 0;
-	}
-	if (this.anchorEdge == this.EDGE.RIGHT) {
-		this.proximityRight = 0;
-	}
-	if (this.anchorEdge == this.EDGE.TOP) {
-		this.proximityTop = 0;
-	}
-	if (this.anchorEdge == this.EDGE.BOTTOM) {
-		this.proximityBottom = 0;
-	}
-	if (this.anchorEdge == this.EDGE.CENTER) {
-		this.proximityLeft /= 2;
-		this.proximityRight /= 2;
-		this.proximityTop /= 2;
-		this.proximityBottom /= 2;
-	}
-}, postCreate:function () {
-	this._initializePositioning();
-	if (!this.conservativeTrigger) {
-		dojo.event.connect(document.documentElement, "onmousemove", this, "_onMouseMove");
-	}
-	dojo.event.connect(document.documentElement, "onmouseout", this, "_onBodyOut");
-	dojo.event.connect(this, "addChild", this, "_initializePositioning");
-}, _initializePositioning:function () {
-	this.itemCount = this.children.length;
-	this.barWidth = (this.isHorizontal ? this.itemCount : 1) * this.itemWidth;
-	this.barHeight = (this.isHorizontal ? 1 : this.itemCount) * this.itemHeight;
-	this.totalWidth = this.proximityLeft + this.proximityRight + this.barWidth;
-	this.totalHeight = this.proximityTop + this.proximityBottom + this.barHeight;
-	for (var i = 0; i < this.children.length; i++) {
-		this.children[i].posX = this.itemWidth * (this.isHorizontal ? i : 0);
-		this.children[i].posY = this.itemHeight * (this.isHorizontal ? 0 : i);
-		this.children[i].cenX = this.children[i].posX + (this.itemWidth / 2);
-		this.children[i].cenY = this.children[i].posY + (this.itemHeight / 2);
-		var isz = this.isHorizontal ? this.itemWidth : this.itemHeight;
-		var r = this.effectUnits * isz;
-		var c = this.isHorizontal ? this.children[i].cenX : this.children[i].cenY;
-		var lhs = this.isHorizontal ? this.proximityLeft : this.proximityTop;
-		var rhs = this.isHorizontal ? this.proximityRight : this.proximityBottom;
-		var siz = this.isHorizontal ? this.barWidth : this.barHeight;
-		var range_lhs = r;
-		var range_rhs = r;
-		if (range_lhs > c + lhs) {
-			range_lhs = c + lhs;
+dojo.require("dojo.dom");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.event");
+
+dojo.widget.tags.addParseTreeHandler("dojo:FisheyeList");
+dojo.widget.tags.addParseTreeHandler("dojo:FisheyeListItem");
+
+dojo.widget.html.FisheyeList = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.FisheyeList, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.FisheyeList, {
+
+	templateString: '<div class="dojoHtmlFisheyeListBar"></div>',
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlFisheyeList.css"),
+	widgetType: "FisheyeList",
+
+	EDGE: {
+		CENTER: 0,
+		LEFT: 1,
+		RIGHT: 2,
+		TOP: 3,
+		BOTTOM: 4
+	},
+
+	isContainer: true,
+	snarfChildDomOutput: true,
+	
+	pos: {x: -1, y: -1},		// current cursor position, relative to the grid
+	
+	// for conservative trigger mode, when triggered, timerScale is gradually increased from 0 to 1
+	timerScale: 1.0,
+
+	/////////////////////////////////////////////////////////////////
+	//
+	// i spy OPTIONS!!!!
+	//
+
+	itemWidth: 40,
+	itemHeight: 40,
+
+	itemMaxWidth: 150,
+	itemMaxHeight: 150,
+
+	orientation: 'horizontal',
+	
+	conservativeTrigger: false,		// don't active menu until mouse is over an image (macintosh style)
+
+	effectUnits: 2,
+	itemPadding: 10,
+
+	attachEdge: 'center',
+	labelEdge: 'bottom',
+
+	enableCrappySvgSupport: false,
+
+
+	//
+	//
+	//
+	/////////////////////////////////////////////////////////////////
+
+	fillInTemplate: function(args, frag) {
+		//dojo.debug(this.orientation);
+
+		dojo.html.disableSelection(this.domNode);
+
+		this.isHorizontal = (this.orientation == 'horizontal') ? 1 : 0;
+		this.selectedNode = -1;
+
+		this.isOver = false;
+		this.hitX1 = -1;
+		this.hitY1 = -1;
+		this.hitX2 = -1;
+		this.hitY2 = -1;
+
+		//
+		// only some edges make sense...
+		//
+
+		this.anchorEdge = this.toEdge(this.attachEdge, this.EDGE.CENTER);
+		this.labelEdge  = this.toEdge(this.labelEdge,  this.EDGE.TOP);
+
+		if ( this.isHorizontal && (this.anchorEdge == this.EDGE.LEFT  )){ this.anchorEdge = this.EDGE.CENTER; }
+		if ( this.isHorizontal && (this.anchorEdge == this.EDGE.RIGHT )){ this.anchorEdge = this.EDGE.CENTER; }
+		if (!this.isHorizontal && (this.anchorEdge == this.EDGE.TOP   )){ this.anchorEdge = this.EDGE.CENTER; }
+		if (!this.isHorizontal && (this.anchorEdge == this.EDGE.BOTTOM)){ this.anchorEdge = this.EDGE.CENTER; }
+
+		if (this.labelEdge == this.EDGE.CENTER){ this.labelEdge = this.EDGE.TOP; }
+		if ( this.isHorizontal && (this.labelEdge == this.EDGE.LEFT  )){ this.labelEdge = this.EDGE.TOP; }
+		if ( this.isHorizontal && (this.labelEdge == this.EDGE.RIGHT )){ this.labelEdge = this.EDGE.TOP; }
+		if (!this.isHorizontal && (this.labelEdge == this.EDGE.TOP   )){ this.labelEdge = this.EDGE.LEFT; }
+		if (!this.isHorizontal && (this.labelEdge == this.EDGE.BOTTOM)){ this.labelEdge = this.EDGE.LEFT; }
+
+
+		//
+		// figure out the proximity size
+		//
+
+		this.proximityLeft   = this.itemWidth  * (this.effectUnits - 0.5);
+		this.proximityRight  = this.itemWidth  * (this.effectUnits - 0.5);
+		this.proximityTop    = this.itemHeight * (this.effectUnits - 0.5);
+		this.proximityBottom = this.itemHeight * (this.effectUnits - 0.5);
+
+		if (this.anchorEdge == this.EDGE.LEFT){
+			this.proximityLeft = 0;
 		}
-		if (range_rhs > (siz - c + rhs)) {
-			range_rhs = siz - c + rhs;
+		if (this.anchorEdge == this.EDGE.RIGHT){
+			this.proximityRight = 0;
 		}
-		this.children[i].effectRangeLeft = range_lhs / isz;
-		this.children[i].effectRangeRght = range_rhs / isz;
-	}
-	this.domNode.style.width = this.barWidth + "px";
-	this.domNode.style.height = this.barHeight + "px";
-	for (var i = 0; i < this.children.length; i++) {
-		var itm = this.children[i];
-		var elm = itm.domNode;
-		elm.style.left = itm.posX + "px";
-		elm.style.top = itm.posY + "px";
-		elm.style.width = this.itemWidth + "px";
-		elm.style.height = this.itemHeight + "px";
-		if (itm.svgNode) {
-			itm.svgNode.style.position = "absolute";
-			itm.svgNode.style.left = this.itemPadding + "%";
-			itm.svgNode.style.top = this.itemPadding + "%";
-			itm.svgNode.style.width = (100 - 2 * this.itemPadding) + "%";
-			itm.svgNode.style.height = (100 - 2 * this.itemPadding) + "%";
-			itm.svgNode.style.zIndex = 1;
-			itm.svgNode.setSize(this.itemWidth, this.itemHeight);
-		} else {
-			itm.imgNode.style.left = this.itemPadding + "%";
-			itm.imgNode.style.top = this.itemPadding + "%";
-			itm.imgNode.style.width = (100 - 2 * this.itemPadding) + "%";
-			itm.imgNode.style.height = (100 - 2 * this.itemPadding) + "%";
+		if (this.anchorEdge == this.EDGE.TOP){
+			this.proximityTop = 0;
 		}
-	}
-	this._calcHitGrid();
-}, _onBodyOut:function (e) {
-	if (dojo.html.overElement(dojo.body(), e)) {
-		return;
-	}
-	this._setDormant(e);
-}, _setDormant:function (e) {
-	if (!this.isOver) {
-		return;
-	}
-	this.isOver = false;
-	if (this.conservativeTrigger) {
-		dojo.event.disconnect(document.documentElement, "onmousemove", this, "_onMouseMove");
-	}
-	this._onGridMouseMove(-1, -1);
-}, _setActive:function (e) {
-	if (this.isOver) {
-		return;
-	}
-	this.isOver = true;
-	if (this.conservativeTrigger) {
-		dojo.event.connect(document.documentElement, "onmousemove", this, "_onMouseMove");
-		this.timerScale = 0;
-		this._onMouseMove(e);
-		this._expandSlowly();
-	}
-}, _onMouseMove:function (e) {
-	if ((e.pageX >= this.hitX1) && (e.pageX <= this.hitX2) && (e.pageY >= this.hitY1) && (e.pageY <= this.hitY2)) {
-		if (!this.isOver) {
-			this._setActive(e);
+		if (this.anchorEdge == this.EDGE.BOTTOM){
+			this.proximityBottom = 0;
 		}
-		this._onGridMouseMove(e.pageX - this.hitX1, e.pageY - this.hitY1);
-	} else {
-		if (this.isOver) {
-			this._setDormant(e);
+		if (this.anchorEdge == this.EDGE.CENTER){
+			this.proximityLeft   /= 2;
+			this.proximityRight  /= 2;
+			this.proximityTop    /= 2;
+			this.proximityBottom /= 2;
 		}
-	}
-}, onResized:function () {
-	this._calcHitGrid();
-}, _onGridMouseMove:function (x, y) {
-	this.pos = {x:x, y:y};
-	this._paint();
-}, _paint:function () {
-	var x = this.pos.x;
-	var y = this.pos.y;
-	if (this.itemCount <= 0) {
-		return;
-	}
-	var pos = this.isHorizontal ? x : y;
-	var prx = this.isHorizontal ? this.proximityLeft : this.proximityTop;
-	var siz = this.isHorizontal ? this.itemWidth : this.itemHeight;
-	var sim = this.isHorizontal ? (1 - this.timerScale) * this.itemWidth + this.timerScale * this.itemMaxWidth : (1 - this.timerScale) * this.itemHeight + this.timerScale * this.itemMaxHeight;
-	var cen = ((pos - prx) / siz) - 0.5;
-	var max_off_cen = (sim / siz) - 0.5;
-	if (max_off_cen > this.effectUnits) {
-		max_off_cen = this.effectUnits;
-	}
-	var off_weight = 0;
-	if (this.anchorEdge == this.EDGE.BOTTOM) {
-		var cen2 = (y - this.proximityTop) / this.itemHeight;
-		off_weight = (cen2 > 0.5) ? 1 : y / (this.proximityTop + (this.itemHeight / 2));
-	}
-	if (this.anchorEdge == this.EDGE.TOP) {
-		var cen2 = (y - this.proximityTop) / this.itemHeight;
-		off_weight = (cen2 < 0.5) ? 1 : (this.totalHeight - y) / (this.proximityBottom + (this.itemHeight / 2));
-	}
-	if (this.anchorEdge == this.EDGE.RIGHT) {
-		var cen2 = (x - this.proximityLeft) / this.itemWidth;
-		off_weight = (cen2 > 0.5) ? 1 : x / (this.proximityLeft + (this.itemWidth / 2));
-	}
-	if (this.anchorEdge == this.EDGE.LEFT) {
-		var cen2 = (x - this.proximityLeft) / this.itemWidth;
-		off_weight = (cen2 < 0.5) ? 1 : (this.totalWidth - x) / (this.proximityRight + (this.itemWidth / 2));
-	}
-	if (this.anchorEdge == this.EDGE.CENTER) {
-		if (this.isHorizontal) {
-			off_weight = y / (this.totalHeight);
-		} else {
-			off_weight = x / (this.totalWidth);
+	},
+	
+	postCreate: function(args, frag) {
+		this.initializePositioning();
+
+		//
+		// in liberal trigger mode, activate menu whenever mouse is close
+		//
+		if( !this.conservativeTrigger ){
+			dojo.event.connect(document.documentElement, "onmousemove", this, "mouseHandler");
 		}
-		if (off_weight > 0.5) {
-			off_weight = 1 - off_weight;
+		
+		// Deactivate the menu if mouse is moved off screen (doesn't work for FF?)
+		dojo.event.connect(document.documentElement, "onmouseout", this, "onBodyOut");
+		dojo.event.connect(this, "addChild", this, "initializePositioning");
+	},
+
+	initializePositioning: function(){
+		this.itemCount = this.children.length;
+
+		this.barWidth  = (this.isHorizontal ? this.itemCount : 1) * this.itemWidth;
+		this.barHeight = (this.isHorizontal ? 1 : this.itemCount) * this.itemHeight;
+
+		this.totalWidth  = this.proximityLeft + this.proximityRight  + this.barWidth;
+		this.totalHeight = this.proximityTop  + this.proximityBottom + this.barHeight;
+
+		//
+		// calculate effect ranges for each item
+		//
+
+		for (var i=0; i<this.children.length; i++){
+
+			this.children[i].posX = this.itemWidth  * (this.isHorizontal ? i : 0);
+			this.children[i].posY = this.itemHeight * (this.isHorizontal ? 0 : i);
+
+			this.children[i].cenX = this.children[i].posX + (this.itemWidth  / 2);
+			this.children[i].cenY = this.children[i].posY + (this.itemHeight / 2);
+
+			var isz = this.isHorizontal ? this.itemWidth : this.itemHeight;
+			var r = this.effectUnits * isz;
+			var c = this.isHorizontal ? this.children[i].cenX : this.children[i].cenY;
+			var lhs = this.isHorizontal ? this.proximityLeft : this.proximityTop;
+			var rhs = this.isHorizontal ? this.proximityRight : this.proximityBottom;
+			var siz = this.isHorizontal ? this.barWidth : this.barHeight;
+
+			var range_lhs = r;
+			var range_rhs = r;
+
+			if (range_lhs > c+lhs){ range_lhs = c+lhs; }
+			if (range_rhs > (siz-c+rhs)){ range_rhs = siz-c+rhs; }
+
+			this.children[i].effectRangeLeft = range_lhs / isz;
+			this.children[i].effectRangeRght = range_rhs / isz;
+
+			//dojo.debug('effect range for '+i+' is '+range_lhs+'/'+range_rhs);
 		}
-		off_weight *= 2;
-	}
-	for (var i = 0; i < this.itemCount; i++) {
-		var weight = this._weighAt(cen, i);
-		if (weight < 0) {
-			weight = 0;
+
+
+		//
+		// create the bar
+		//
+
+		this.domNode.style.width = this.barWidth + 'px';
+		this.domNode.style.height = this.barHeight + 'px';
+
+
+		//
+		// position the items
+		//
+		for (var i=0; i<this.children.length; i++){
+			var itm = this.children[i];
+			var elm = itm.domNode;
+			elm.style.left   = itm.posX + 'px';
+			elm.style.top    = itm.posY + 'px';
+			elm.style.width  = this.itemWidth + 'px';
+			elm.style.height = this.itemHeight + 'px';
+			
+			if ( itm.svgNode ) {
+				itm.svgNode.style.position = 'absolute';
+				itm.svgNode.style.left = this.itemPadding+'%';
+				itm.svgNode.style.top = this.itemPadding+'%';
+				itm.svgNode.style.width = (100 - 2 * this.itemPadding) + '%';
+				itm.svgNode.style.height = (100 - 2 * this.itemPadding) + '%';
+				itm.svgNode.style.zIndex = 1;
+	
+				itm.svgNode.setSize(this.itemWidth, this.itemHeight);
+			} else {
+				itm.imgNode.style.left = this.itemPadding+'%';
+				itm.imgNode.style.top = this.itemPadding+'%';
+				itm.imgNode.style.width = (100 - 2 * this.itemPadding) + '%';
+				itm.imgNode.style.height = (100 - 2 * this.itemPadding) + '%';
+			}
 		}
-		this._setItemSize(i, weight * off_weight);
-	}
-	var main_p = Math.round(cen);
-	var offset = 0;
-	if (cen < 0) {
-		main_p = 0;
-	} else {
-		if (cen > this.itemCount - 1) {
-			main_p = this.itemCount - 1;
-		} else {
+
+		//
+		// calc the grid
+		//
+
+		this.calcHitGrid();
+	},
+
+	onBodyOut: function(e){
+		// clicking over an object inside of body causes this event to fire; ignore that case
+		if( dojo.html.overElement(document.body, e) ){
+			return;
+		}
+		this.setDormant(e);
+	},
+
+	// when mouse moves out of menu's range
+	setDormant: function(e){
+		if( !this.isOver ){ return; }	// already dormant?
+		this.isOver = false;
+
+		if ( this.conservativeTrigger ) {
+			// user can't re-trigger the menu expansion
+			// until he mouses over a icon again
+			dojo.event.disconnect(document.documentElement, "onmousemove", this, "mouseHandler");
+		}
+		this.onGridMouseMove(-1, -1);
+	},
+
+	// when mouse is moved into menu's range
+	setActive: function(e){
+		if( this.isOver ){ return; }	// already activated?
+		this.isOver = true;
+
+		if ( this.conservativeTrigger ) {
+			// switch event handlers so that we handle mouse events from anywhere near
+			// the menu
+			dojo.event.connect(document.documentElement, "onmousemove", this, "mouseHandler");
+
+			this.timerScale=0.0;
+
+			// call mouse handler to do some initial necessary calculations/positioning
+			this.mouseHandler(e);
+
+			// slowly expand the icon size so it isn't jumpy
+			this.expandSlowly();
+		}
+	},
+
+	// when mouse is moved
+	mouseHandler: function(e) {
+		if ((e.pageX >= this.hitX1) && (e.pageX <= this.hitX2) &&
+			(e.pageY >= this.hitY1) && (e.pageY <= this.hitY2)){
+			if( !this.isOver ){
+				this.setActive(e);
+			}
+			this.onGridMouseMove(e.pageX-this.hitX1, e.pageY-this.hitY1);
+		}else{
+			if (this.isOver){
+				this.setDormant(e);
+			}
+		}
+	},
+
+	onResized: function() {
+		this.calcHitGrid();
+	},
+
+	onGridMouseMove: function(x, y){
+		this.pos = {x:x, y:y};
+		this.paint();
+	},
+	
+	paint: function(){
+		var x=this.pos.x;
+		var y=this.pos.y;
+
+		if( this.itemCount <= 0 ){ return; }
+
+		//
+		// figure out our main index
+		//
+
+		var pos = this.isHorizontal ? x : y;
+		var prx = this.isHorizontal ? this.proximityLeft : this.proximityTop;
+		var siz = this.isHorizontal ? this.itemWidth : this.itemHeight;
+		var sim = this.isHorizontal ? 
+			(1.0-this.timerScale)*this.itemWidth + this.timerScale*this.itemMaxWidth :
+			(1.0-this.timerScale)*this.itemHeight + this.timerScale*this.itemMaxHeight ;
+
+		var cen = ((pos - prx) / siz) - 0.5;
+		var max_off_cen = (sim / siz) - 0.5;
+
+		if (max_off_cen > this.effectUnits){ max_off_cen = this.effectUnits; }
+
+
+		//
+		// figure out our off-axis weighting
+		//
+
+		var off_weight = 0;
+
+		if (this.anchorEdge == this.EDGE.BOTTOM){
+			var cen2 = (y - this.proximityTop) / this.itemHeight;
+			off_weight = (cen2 > 0.5) ? 1 : y / (this.proximityTop + (this.itemHeight / 2));
+		}
+		if (this.anchorEdge == this.EDGE.TOP){
+			var cen2 = (y - this.proximityTop) / this.itemHeight;
+			off_weight = (cen2 < 0.5) ? 1 : (this.totalHeight - y) / (this.proximityBottom + (this.itemHeight / 2));
+		}
+		if (this.anchorEdge == this.EDGE.RIGHT){
+			var cen2 = (x - this.proximityLeft) / this.itemWidth;
+			off_weight = (cen2 > 0.5) ? 1 : x / (this.proximityLeft + (this.itemWidth / 2));
+		}
+		if (this.anchorEdge == this.EDGE.LEFT){
+			var cen2 = (x - this.proximityLeft) / this.itemWidth;
+			off_weight = (cen2 < 0.5) ? 1 : (this.totalWidth - x) / (this.proximityRight + (this.itemWidth / 2));
+		}
+		if (this.anchorEdge == this.EDGE.CENTER){
+
+			if (this.isHorizontal){
+				off_weight = y / (this.totalHeight);
+			}else{
+				off_weight = x / (this.totalWidth);
+			}
+
+			if (off_weight > 0.5){
+				off_weight = 1 - off_weight;
+			}
+
+			off_weight *= 2;
+		}
+
+
+		//
+		// set the sizes
+		//
+
+		for(var i=0; i<this.itemCount; i++){
+
+			var weight = this.weightAt(cen, i);
+
+			if (weight < 0){weight = 0;}
+
+			this.setitemsize(i, weight * off_weight);
+		}
+
+		//
+		// set the positions
+		//
+
+		var main_p = Math.round(cen);
+		var offset = 0;
+
+		if (cen < 0){
+			main_p = 0;
+
+		}else if (cen > this.itemCount - 1){
+
+			main_p = this.itemCount -1;
+
+		}else{
+
 			offset = (cen - main_p) * ((this.isHorizontal ? this.itemWidth : this.itemHeight) - this.children[main_p].sizeMain);
 		}
-	}
-	this._positionElementsFrom(main_p, offset);
-}, _weighAt:function (cen, i) {
-	var dist = Math.abs(cen - i);
-	var limit = ((cen - i) > 0) ? this.children[i].effectRangeRght : this.children[i].effectRangeLeft;
-	return (dist > limit) ? 0 : (1 - dist / limit);
-}, _setItemSize:function (p, scale) {
-	scale *= this.timerScale;
-	var w = Math.round(this.itemWidth + ((this.itemMaxWidth - this.itemWidth) * scale));
-	var h = Math.round(this.itemHeight + ((this.itemMaxHeight - this.itemHeight) * scale));
-	if (this.isHorizontal) {
-		this.children[p].sizeW = w;
-		this.children[p].sizeH = h;
-		this.children[p].sizeMain = w;
-		this.children[p].sizeOff = h;
-		var y = 0;
-		if (this.anchorEdge == this.EDGE.TOP) {
-			y = (this.children[p].cenY - (this.itemHeight / 2));
-		} else {
-			if (this.anchorEdge == this.EDGE.BOTTOM) {
+
+		this.positionElementsFrom(main_p, offset);
+	},
+
+	weightAt: function(cen, i){
+
+		var dist = Math.abs(cen - i);
+
+		var limit = ((cen - i) > 0) ? this.children[i].effectRangeRght : this.children[i].effectRangeLeft;
+
+		return (dist > limit) ? 0 : (1 - dist / limit);
+	},
+
+	positionFromNode: function(p, w){
+
+		//
+		// we need to grow all the nodes growing out from node 'i'
+		//
+
+		this.setitemsize(p, w);
+
+		var wx = w;
+		for(var i=p; i<this.itemCount; i++){
+			wx = 0.8 * wx;
+			this.setitemsize(i, wx);
+		}
+
+		var wx = w;
+		for(var i=p; i>=0; i--){
+			wx = 0.8 * wx;
+			this.setitemsize(i, wx);
+		}
+	},
+
+	setitemsize: function(p, scale){
+		scale *= this.timerScale;
+		var w = Math.round(this.itemWidth  + ((this.itemMaxWidth  - this.itemWidth ) * scale));
+		var h = Math.round(this.itemHeight + ((this.itemMaxHeight - this.itemHeight) * scale));
+
+		if (this.isHorizontal){
+
+			this.children[p].sizeW = w;
+			this.children[p].sizeH = h;
+
+			this.children[p].sizeMain = w;
+			this.children[p].sizeOff  = h;
+
+			var y = 0;
+
+			if (this.anchorEdge == this.EDGE.TOP){
+
+				y = (this.children[p].cenY - (this.itemHeight / 2));
+
+			}else if (this.anchorEdge == this.EDGE.BOTTOM){
+
 				y = (this.children[p].cenY - (h - (this.itemHeight / 2)));
-			} else {
+
+			}else{
+
 				y = (this.children[p].cenY - (h / 2));
 			}
-		}
-		this.children[p].usualX = Math.round(this.children[p].cenX - (w / 2));
-		this.children[p].domNode.style.top = y + "px";
-		this.children[p].domNode.style.left = this.children[p].usualX + "px";
-	} else {
-		this.children[p].sizeW = w;
-		this.children[p].sizeH = h;
-		this.children[p].sizeOff = w;
-		this.children[p].sizeMain = h;
-		var x = 0;
-		if (this.anchorEdge == this.EDGE.LEFT) {
-			x = this.children[p].cenX - (this.itemWidth / 2);
-		} else {
-			if (this.anchorEdge == this.EDGE.RIGHT) {
+
+			this.children[p].usualX = Math.round(this.children[p].cenX - (w / 2));
+			
+			this.children[p].domNode.style.top  = y + 'px';
+
+			this.children[p].domNode.style.left  = this.children[p].usualX + 'px';
+
+		}else{
+
+			this.children[p].sizeW = w;
+			this.children[p].sizeH = h;
+
+			this.children[p].sizeOff  = w;
+			this.children[p].sizeMain = h;
+
+			var x = 0;
+
+			if (this.anchorEdge == this.EDGE.LEFT){
+
+				x = this.children[p].cenX - (this.itemWidth / 2);
+
+			}else if (this.anchorEdge == this.EDGE.RIGHT){
+
 				x = this.children[p].cenX - (w - (this.itemWidth / 2));
-			} else {
+			}else{
+
 				x = this.children[p].cenX - (w / 2);
 			}
+
+			this.children[p].domNode.style.left = x + 'px';
+			this.children[p].usualY = Math.round(this.children[p].cenY - (h / 2));
+
+			this.children[p].domNode.style.top  = this.children[p].usualY + 'px';
 		}
-		this.children[p].domNode.style.left = x + "px";
-		this.children[p].usualY = Math.round(this.children[p].cenY - (h / 2));
-		this.children[p].domNode.style.top = this.children[p].usualY + "px";
-	}
-	this.children[p].domNode.style.width = w + "px";
-	this.children[p].domNode.style.height = h + "px";
-	if (this.children[p].svgNode) {
-		this.children[p].svgNode.setSize(w, h);
-	}
-}, _positionElementsFrom:function (p, offset) {
-	var pos = 0;
-	if (this.isHorizontal) {
-		pos = Math.round(this.children[p].usualX + offset);
-		this.children[p].domNode.style.left = pos + "px";
-	} else {
-		pos = Math.round(this.children[p].usualY + offset);
-		this.children[p].domNode.style.top = pos + "px";
-	}
-	this._positionLabel(this.children[p]);
-	var bpos = pos;
-	for (var i = p - 1; i >= 0; i--) {
-		bpos -= this.children[i].sizeMain;
-		if (this.isHorizontal) {
-			this.children[i].domNode.style.left = bpos + "px";
-		} else {
-			this.children[i].domNode.style.top = bpos + "px";
+
+		this.children[p].domNode.style.width  = w + 'px';
+		this.children[p].domNode.style.height = h + 'px';
+
+		if (this.children[p].svgNode){
+			this.children[p].svgNode.setSize(w, h);
 		}
-		this._positionLabel(this.children[i]);
-	}
-	var apos = pos;
-	for (var i = p + 1; i < this.itemCount; i++) {
-		apos += this.children[i - 1].sizeMain;
-		if (this.isHorizontal) {
-			this.children[i].domNode.style.left = apos + "px";
-		} else {
-			this.children[i].domNode.style.top = apos + "px";
+	},
+
+	positionElementsFrom: function(p, offset){
+
+		var pos = 0;
+
+		if (this.isHorizontal){
+			pos = Math.round(this.children[p].usualX + offset);
+			this.children[p].domNode.style.left = pos + 'px';
+		}else{
+			pos = Math.round(this.children[p].usualY + offset);
+			this.children[p].domNode.style.top = pos + 'px';
 		}
-		this._positionLabel(this.children[i]);
-	}
-}, _positionLabel:function (itm) {
-	var x = 0;
-	var y = 0;
-	var mb = dojo.html.getMarginBox(itm.lblNode);
-	if (this.labelEdge == this.EDGE.TOP) {
-		x = Math.round((itm.sizeW / 2) - (mb.width / 2));
-		y = -mb.height;
-	}
-	if (this.labelEdge == this.EDGE.BOTTOM) {
-		x = Math.round((itm.sizeW / 2) - (mb.width / 2));
-		y = itm.sizeH;
-	}
-	if (this.labelEdge == this.EDGE.LEFT) {
-		x = -mb.width;
-		y = Math.round((itm.sizeH / 2) - (mb.height / 2));
-	}
-	if (this.labelEdge == this.EDGE.RIGHT) {
-		x = itm.sizeW;
-		y = Math.round((itm.sizeH / 2) - (mb.height / 2));
-	}
-	itm.lblNode.style.left = x + "px";
-	itm.lblNode.style.top = y + "px";
-}, _calcHitGrid:function () {
-	var pos = dojo.html.getAbsolutePosition(this.domNode, true);
-	this.hitX1 = pos.x - this.proximityLeft;
-	this.hitY1 = pos.y - this.proximityTop;
-	this.hitX2 = this.hitX1 + this.totalWidth;
-	this.hitY2 = this.hitY1 + this.totalHeight;
-}, _toEdge:function (inp, def) {
-	return this.EDGE[inp.toUpperCase()] || def;
-}, _expandSlowly:function () {
-	if (!this.isOver) {
-		return;
-	}
-	this.timerScale += 0.2;
-	this._paint();
-	if (this.timerScale < 1) {
-		dojo.lang.setTimeout(this, "_expandSlowly", 10);
-	}
-}, destroy:function () {
-	dojo.event.disconnect(document.documentElement, "onmouseout", this, "_onBodyOut");
-	dojo.event.disconnect(document.documentElement, "onmousemove", this, "_onMouseMove");
-	dojo.widget.FisheyeList.superclass.destroy.call(this);
-}});
-dojo.widget.defineWidget("dojo.widget.FisheyeListItem", dojo.widget.HtmlWidget, {iconSrc:"", svgSrc:"", caption:"", id:"", _blankImgPath:dojo.uri.moduleUri("dojo.widget", "templates/images/blank.gif"), templateString:"<div class=\"dojoHtmlFisheyeListItem\">" + "  <img class=\"dojoHtmlFisheyeListItemImage\" dojoAttachPoint=\"imgNode\" dojoAttachEvent=\"onMouseOver;onMouseOut;onClick\">" + "  <div class=\"dojoHtmlFisheyeListItemLabel\" dojoAttachPoint=\"lblNode\"></div>" + "</div>", fillInTemplate:function () {
-	if (this.svgSrc != "") {
-		this.svgNode = this._createSvgNode(this.svgSrc);
-		this.domNode.appendChild(this.svgNode);
-		this.imgNode.style.display = "none";
-	} else {
-		if ((this.iconSrc.toLowerCase().substring(this.iconSrc.length - 4) == ".png") && (dojo.render.html.ie) && (!dojo.render.html.ie70)) {
-			if (dojo.dom.hasParent(this.imgNode) && this.id != "") {
-				var parent = this.imgNode.parentNode;
-				parent.setAttribute("id", this.id);
+		this.positionLabel(this.children[p]);
+
+
+		//
+		// position before
+		//
+
+		var bpos = pos;
+
+		for(var i=p-1; i>=0; i--){
+
+			bpos -= this.children[i].sizeMain;
+
+			if (this.isHorizontal){
+				this.children[i].domNode.style.left = bpos + 'px';
+			}else{
+				this.children[i].domNode.style.top = bpos + 'px';
 			}
-			this.imgNode.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.iconSrc + "', sizingMethod='scale')";
-			this.imgNode.src = this._blankImgPath.toString();
-		} else {
-			if (dojo.dom.hasParent(this.imgNode) && this.id != "") {
-				var parent = this.imgNode.parentNode;
-				parent.setAttribute("id", this.id);
+			this.positionLabel(this.children[i]);
+		}
+
+		//
+		// position after
+		//
+
+		var apos = pos;
+
+		for(var i=p+1; i<this.itemCount; i++){
+
+			apos += this.children[i-1].sizeMain;
+
+			if (this.isHorizontal){
+				this.children[i].domNode.style.left = apos + 'px';
+			}else{
+				this.children[i].domNode.style.top = apos + 'px';
 			}
-			this.imgNode.src = this.iconSrc;
+			this.positionLabel(this.children[i]);
 		}
+
+	},
+
+	positionLabel: function(itm){
+
+		var x = 0;
+		var y = 0;
+		
+		var labelW = dojo.style.getOuterWidth(itm.lblNode);
+		var labelH = dojo.style.getOuterHeight(itm.lblNode);
+
+		if (this.labelEdge == this.EDGE.TOP){
+			x = Math.round((itm.sizeW / 2) - (labelW / 2));
+			y = -labelH;
+		}
+
+		if (this.labelEdge == this.EDGE.BOTTOM){
+			x = Math.round((itm.sizeW / 2) - (labelW / 2));
+			y = itm.sizeH;
+		}
+
+		if (this.labelEdge == this.EDGE.LEFT){
+			x = -labelW;
+			y = Math.round((itm.sizeH / 2) - (labelH / 2));
+		}
+
+		if (this.labelEdge == this.EDGE.RIGHT){
+			x = itm.sizeW;
+			y = Math.round((itm.sizeH / 2) - (labelH / 2));
+		}
+
+		itm.lblNode.style.left = x + 'px';
+		itm.lblNode.style.top  = y + 'px';
+	},
+
+	calcHitGrid: function(){
+
+		var pos = dojo.style.getAbsolutePosition(this.domNode, true);
+
+		this.hitX1 = pos.x - this.proximityLeft;
+		this.hitY1 = pos.y - this.proximityTop;
+		this.hitX2 = this.hitX1 + this.totalWidth;
+		this.hitY2 = this.hitY1 + this.totalHeight;
+
+		//dojo.debug(this.hitX1+','+this.hitY1+' // '+this.hitX2+','+this.hitY2);
+	},
+
+	toEdge: function(inp, def){
+		return this.EDGE[inp.toUpperCase()] || def;
+	},
+	
+	// slowly expand the image to user specified max size
+	expandSlowly: function(){
+		if( !this.isOver ){ return; }
+		this.timerScale += 0.2;
+		this.paint();
+		if ( this.timerScale<1.0 ) {
+			dojo.lang.setTimeout(this, "expandSlowly", 10);
+		}
+	},
+
+	destroy: function(){
+		// need to disconnect when we destroy
+		dojo.event.disconnect(document.documentElement, "onmouseout", this, "onBodyOut");
+		dojo.event.disconnect(document.documentElement, "onmousemove", this, "mouseHandler");
+		dojo.widget.html.FisheyeList.superclass.destroy.call(this);
 	}
-	if (this.lblNode) {
-		this.lblNode.appendChild(document.createTextNode(this.caption));
-	}
-	dojo.html.disableSelection(this.domNode);
-}, _createSvgNode:function (src) {
-	var elm = document.createElement("embed");
-	elm.src = src;
-	elm.type = "image/svg+xml";
-	elm.style.width = "1px";
-	elm.style.height = "1px";
-	elm.loaded = 0;
-	elm.setSizeOnLoad = false;
-	elm.onload = function () {
-		this.svgRoot = this.getSVGDocument().rootElement;
-		this.svgDoc = this.getSVGDocument().documentElement;
-		this.zeroWidth = this.svgRoot.width.baseVal.value;
-		this.zeroHeight = this.svgRoot.height.baseVal.value;
-		this.loaded = true;
-		if (this.setSizeOnLoad) {
-			this.setSize(this.setWidth, this.setHeight);
+});
+
+dojo.widget.html.FisheyeListItem = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.FisheyeListItem, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.FisheyeListItem, {
+	widgetType: "FisheyeListItem",
+	
+	// Constructor arguments
+	iconSrc: "",
+	svgSrc: "",
+	caption: "",
+
+	blankImgPath: dojo.uri.dojoUri("src/widget/templates/images/blank.gif"),
+
+	templateString:
+		'<div class="dojoHtmlFisheyeListItem">' +
+		'  <img class="dojoHtmlFisheyeListItemImage" dojoAttachPoint="imgNode" dojoAttachEvent="onMouseOver;onMouseOut;onClick">' +
+		'  <div class="dojoHtmlFisheyeListItemLabel" dojoAttachPoint="lblNode"></div>' +
+		'</div>',
+	
+	imgNode: null,
+
+	fillInTemplate: function() {
+		//
+		// set image
+		// TODO: turn on/off SVG support based on browser version.
+		// this.parent.enableCrappySvgSupport is not available to this function
+		//
+		if (this.svgSrc != ""){
+			this.svgNode = this.createSvgNode(this.svgSrc);
+			this.domNode.appendChild(this.svgNode);
+			this.imgNode.style.display = 'none';
+		} else if((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4)==".png")&&(dojo.render.html.ie)){
+			this.imgNode.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+this.iconSrc+"', sizingMethod='scale')";
+			this.imgNode.src = this.blankImgPath.toString();
+		} else {
+			this.imgNode.src = this.iconSrc;
 		}
-	};
-	elm.setSize = function (w, h) {
-		if (!this.loaded) {
-			this.setWidth = w;
-			this.setHeight = h;
-			this.setSizeOnLoad = true;
-			return;
+
+		//
+		// Label
+		//
+		if ( this.lblNode ) {
+			this.lblNode.appendChild(document.createTextNode(this.caption));
 		}
-		this.style.width = w + "px";
-		this.style.height = h + "px";
-		this.svgRoot.width.baseVal.value = w;
-		this.svgRoot.height.baseVal.value = h;
-		var scale_x = w / this.zeroWidth;
-		var scale_y = h / this.zeroHeight;
-		for (var i = 0; i < this.svgDoc.childNodes.length; i++) {
-			if (this.svgDoc.childNodes[i].setAttribute) {
-				this.svgDoc.childNodes[i].setAttribute("transform", "scale(" + scale_x + "," + scale_y + ")");
+		dojo.html.disableSelection(this.domNode);
+	},
+	
+	createSvgNode: function(src){
+
+		var elm = document.createElement('embed');
+		elm.src = src;
+		elm.type = 'image/svg+xml';
+		//elm.style.border = '1px solid black';
+		elm.style.width = '1px';
+		elm.style.height = '1px';
+		elm.loaded = 0;
+		elm.setSizeOnLoad = false;
+
+		elm.onload = function(){
+			this.svgRoot = this.getSVGDocument().rootElement;
+			this.svgDoc = this.getSVGDocument().documentElement;
+			this.zeroWidth = this.svgRoot.width.baseVal.value;
+			this.zeroHeight = this.svgRoot.height.baseVal.value;
+			this.loaded = true;
+
+			if (this.setSizeOnLoad){
+				this.setSize(this.setWidth, this.setHeight);
 			}
 		}
-	};
-	return elm;
-}, onMouseOver:function (e) {
-	if (!this.parent.isOver) {
-		this.parent._setActive(e);
+
+		elm.setSize = function(w, h){
+			if (!this.loaded){
+				this.setWidth = w;
+				this.setHeight = h;
+				this.setSizeOnLoad = true;
+				return;
+			}
+
+			this.style.width = w+'px';
+			this.style.height = h+'px';
+			this.svgRoot.width.baseVal.value = w;
+			this.svgRoot.height.baseVal.value = h;
+
+			var scale_x = w / this.zeroWidth;
+			var scale_y = h / this.zeroHeight;
+
+			for(var i=0; i<this.svgDoc.childNodes.length; i++){
+				if (this.svgDoc.childNodes[i].setAttribute){
+					this.svgDoc.childNodes[i].setAttribute( "transform", "scale("+scale_x+","+scale_y+")" );
+				}
+			}
+		}
+
+		return elm;
+	},
+
+	onMouseOver: function(e) {
+		// in conservative mode, don't activate the menu until user mouses over an icon
+		if( !this.parent.isOver ){
+			this.parent.setActive(e);
+		}
+		if ( this.caption != "" ) {
+			dojo.html.addClass(this.lblNode, "selected");
+			this.parent.positionLabel(this);
+		}
+	},
+	
+	onMouseOut: function() {
+		dojo.html.removeClass(this.lblNode, "selected");
+	},
+
+	onClick: function() {
 	}
-	if (this.caption != "") {
-		dojo.html.addClass(this.lblNode, "selected");
-		this.parent._positionLabel(this);
-	}
-}, onMouseOut:function (e) {
-	dojo.html.removeClass(this.lblNode, "selected");
-}, onClick:function (e) {
-}});
+});
 

Modified: tags/parley-0.53/root/static/magic/src/widget/FloatingPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/FloatingPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/FloatingPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,242 +8,298 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.FloatingPane");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.Manager");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.iframe");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.lfx.shadow");
-dojo.require("dojo.widget.html.layout");
-dojo.require("dojo.widget.ContentPane");
-dojo.require("dojo.dnd.HtmlDragMove");
-dojo.require("dojo.widget.Dialog");
-dojo.require("dojo.widget.ResizeHandle");
-dojo.declare("dojo.widget.FloatingPaneBase", null, {title:"", iconSrc:"", hasShadow:false, constrainToContainer:false, taskBarId:"", resizable:true, titleBarDisplay:true, windowState:"normal", displayCloseAction:false, displayMinimizeAction:false, displayMaximizeAction:false, _max_taskBarConnectAttempts:5, _taskBarConnectAttempts:0, templateString:"<div id=\"${this.widgetId}\" dojoAttachEvent=\"onMouseDown\" class=\"dojoFloatingPane\">\n\t<div dojoAttachPoint=\"titleBar\" class=\"dojoFloatingPaneTitleBar\"  style=\"display:none\">\n\t  \t<img dojoAttachPoint=\"titleBarIcon\"  class=\"dojoFloatingPaneTitleBarIcon\">\n\t\t<div dojoAttachPoint=\"closeAction\" dojoAttachEvent=\"onClick:closeWindow\"\n   \t  \t\tclass=\"dojoFloatingPaneCloseIcon\"></div>\n\t\t<div dojoAttachPoint=\"restoreAction\" dojoAttachEvent=\"onClick:restoreWindow\"\n   \t  \t\tclass=\"dojoFloatingPaneRestoreIcon\"></div>\n\t\t<div dojoAttachPoint=\"maximizeAction\" dojoAttachEvent=\"onClick:maximizeWindow!
 \"\n   \t  \t\tclass=\"dojoFloatingPaneMaximizeIcon\"></div>\n\t\t<div dojoAttachPoint=\"minimizeAction\" dojoAttachEvent=\"onClick:minimizeWindow\"\n   \t  \t\tclass=\"dojoFloatingPaneMinimizeIcon\"></div>\n\t  \t<div dojoAttachPoint=\"titleBarText\" class=\"dojoFloatingPaneTitleText\">${this.title}</div>\n\t</div>\n\n\t<div id=\"${this.widgetId}_container\" dojoAttachPoint=\"containerNode\" class=\"dojoFloatingPaneClient\"></div>\n\n\t<div dojoAttachPoint=\"resizeBar\" class=\"dojoFloatingPaneResizebar\" style=\"display:none\"></div>\n</div>\n", templateCssString:"\n/********** Outer Window ***************/\n\n.dojoFloatingPane {\n\t/* essential css */\n\tposition: absolute;\n\toverflow: visible;\t\t/* so drop shadow is displayed */\n\tz-index: 10;\n\n\t/* styling css */\n\tborder: 1px solid;\n\tborder-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;\n\tbackground-color: ThreeDFace;\n}\n\n\n/********** Title Bar ****************/\n\n.dojoFloatingPaneTitle!
 Bar {\n\tvertical-align: top;\n\tmargin: 2px 2px 2px 2px;\n\tz!
 -index: 
10;\n\tbackground-color: #7596c6;\n\tcursor: default;\n\toverflow: hidden;\n\tborder-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;\n\tvertical-align: middle;\n}\n\n.dojoFloatingPaneTitleText {\n\tfloat: left;\n\tpadding: 2px 4px 2px 2px;\n\twhite-space: nowrap;\n\tcolor: CaptionText;\n\tfont: small-caption;\n}\n\n.dojoTitleBarIcon {\n\tfloat: left;\n\theight: 22px;\n\twidth: 22px;\n\tvertical-align: middle;\n\tmargin-right: 5px;\n\tmargin-left: 5px;\n}\n\n.dojoFloatingPaneActions{\n\tfloat: right;\n\tposition: absolute;\n\tright: 2px;\n\ttop: 2px;\n\tvertical-align: middle;\n}\n\n\n.dojoFloatingPaneActionItem {\n\tvertical-align: middle;\n\tmargin-right: 1px;\n\theight: 22px;\n\twidth: 22px;\n}\n\n\n.dojoFloatingPaneTitleBarIcon {\n\t/* essential css */\n\tfloat: left;\n\n\t/* styling css */\n\tmargin-left: 2px;\n\tmargin-right: 4px;\n\theight: 22px;\n}\n\n/* minimize/maximize icons are specified by CSS only */\n.dojoFloatingPaneMinimizeIcon,\n.dojoFloati!
 ngPaneMaximizeIcon,\n.dojoFloatingPaneRestoreIcon,\n.dojoFloatingPaneCloseIcon {\n\tvertical-align: middle;\n\theight: 22px;\n\twidth: 22px;\n\tfloat: right;\n}\n.dojoFloatingPaneMinimizeIcon {\n\tbackground-image: url(images/floatingPaneMinimize.gif);\n}\n.dojoFloatingPaneMaximizeIcon {\n\tbackground-image: url(images/floatingPaneMaximize.gif);\n}\n.dojoFloatingPaneRestoreIcon {\n\tbackground-image: url(images/floatingPaneRestore.gif);\n}\n.dojoFloatingPaneCloseIcon {\n\tbackground-image: url(images/floatingPaneClose.gif);\n}\n\n/* bar at bottom of window that holds resize handle */\n.dojoFloatingPaneResizebar {\n\tz-index: 10;\n\theight: 13px;\n\tbackground-color: ThreeDFace;\n}\n\n/************* Client Area ***************/\n\n.dojoFloatingPaneClient {\n\tposition: relative;\n\tz-index: 10;\n\tborder: 1px solid;\n\tborder-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;\n\tmargin: 2px;\n\tbackground-color: ThreeDFace;\n\tpadding: 8px;\n\tfont-family: Ver!
 dana, Helvetica, Garamond, sans-serif;\n\tfont-size: 12px;\n\t!
 overflow
: auto;\n}\n\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/FloatingPane.css"), fillInFloatingPaneTemplate:function (args, frag) {
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-	dojo.body().appendChild(this.domNode);
-	if (!this.isShowing()) {
-		this.windowState = "minimized";
-	}
-	if (this.iconSrc == "") {
-		dojo.html.removeNode(this.titleBarIcon);
-	} else {
-		this.titleBarIcon.src = this.iconSrc.toString();
-	}
-	if (this.titleBarDisplay) {
-		this.titleBar.style.display = "";
-		dojo.html.disableSelection(this.titleBar);
-		this.titleBarIcon.style.display = (this.iconSrc == "" ? "none" : "");
-		this.minimizeAction.style.display = (this.displayMinimizeAction ? "" : "none");
-		this.maximizeAction.style.display = (this.displayMaximizeAction && this.windowState != "maximized" ? "" : "none");
-		this.restoreAction.style.display = (this.displayMaximizeAction && this.windowState == "maximized" ? "" : "none");
-		this.closeAction.style.display = (this.displayCloseAction ? "" : "none");
-		this.drag = new dojo.dnd.HtmlDragMoveSource(this.domNode);
-		if (this.constrainToContainer) {
-			this.drag.constrainTo();
-		}
-		this.drag.setDragHandle(this.titleBar);
-		var self = this;
-		dojo.event.topic.subscribe("dragMove", function (info) {
-			if (info.source.domNode == self.domNode) {
-				dojo.event.topic.publish("floatingPaneMove", {source:self});
-			}
-		});
-	}
-	if (this.resizable) {
-		this.resizeBar.style.display = "";
-		this.resizeHandle = dojo.widget.createWidget("ResizeHandle", {targetElmId:this.widgetId, id:this.widgetId + "_resize"});
-		this.resizeBar.appendChild(this.resizeHandle.domNode);
-	}
-	if (this.hasShadow) {
-		this.shadow = new dojo.lfx.shadow(this.domNode);
-	}
-	this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);
-	if (this.taskBarId) {
-		this._taskBarSetup();
-	}
-	dojo.body().removeChild(this.domNode);
-}, postCreate:function () {
-	if (dojo.hostenv.post_load_) {
-		this._setInitialWindowState();
-	} else {
-		dojo.addOnLoad(this, "_setInitialWindowState");
-	}
-}, maximizeWindow:function (evt) {
-	var mb = dojo.html.getMarginBox(this.domNode);
-	this.previous = {width:mb.width || this.width, height:mb.height || this.height, left:this.domNode.style.left, top:this.domNode.style.top, bottom:this.domNode.style.bottom, right:this.domNode.style.right};
-	if (this.domNode.parentNode.style.overflow.toLowerCase() != "hidden") {
-		this.parentPrevious = {overflow:this.domNode.parentNode.style.overflow};
-		dojo.debug(this.domNode.parentNode.style.overflow);
-		this.domNode.parentNode.style.overflow = "hidden";
-	}
-	this.domNode.style.left = dojo.html.getPixelValue(this.domNode.parentNode, "padding-left", true) + "px";
-	this.domNode.style.top = dojo.html.getPixelValue(this.domNode.parentNode, "padding-top", true) + "px";
-	if ((this.domNode.parentNode.nodeName.toLowerCase() == "body")) {
-		var viewport = dojo.html.getViewport();
-		var padding = dojo.html.getPadding(dojo.body());
-		this.resizeTo(viewport.width - padding.width, viewport.height - padding.height);
-	} else {
-		var content = dojo.html.getContentBox(this.domNode.parentNode);
-		this.resizeTo(content.width, content.height);
-	}
-	this.maximizeAction.style.display = "none";
-	this.restoreAction.style.display = "";
-	if (this.resizeHandle) {
-		this.resizeHandle.domNode.style.display = "none";
-	}
-	this.drag.setDragHandle(null);
-	this.windowState = "maximized";
-}, minimizeWindow:function (evt) {
-	this.hide();
-	for (var attr in this.parentPrevious) {
-		this.domNode.parentNode.style[attr] = this.parentPrevious[attr];
-	}
-	this.lastWindowState = this.windowState;
-	this.windowState = "minimized";
-}, restoreWindow:function (evt) {
-	if (this.windowState == "minimized") {
-		this.show();
-		if (this.lastWindowState == "maximized") {
-			this.domNode.parentNode.style.overflow = "hidden";
-			this.windowState = "maximized";
-		} else {
-			this.windowState = "normal";
-		}
-	} else {
-		if (this.windowState == "maximized") {
-			for (var attr in this.previous) {
-				this.domNode.style[attr] = this.previous[attr];
-			}
-			for (var attr in this.parentPrevious) {
-				this.domNode.parentNode.style[attr] = this.parentPrevious[attr];
-			}
-			this.resizeTo(this.previous.width, this.previous.height);
-			this.previous = null;
-			this.parentPrevious = null;
-			this.restoreAction.style.display = "none";
-			this.maximizeAction.style.display = this.displayMaximizeAction ? "" : "none";
-			if (this.resizeHandle) {
-				this.resizeHandle.domNode.style.display = "";
-			}
-			this.drag.setDragHandle(this.titleBar);
-			this.windowState = "normal";
-		} else {
-		}
-	}
-}, toggleDisplay:function () {
-	if (this.windowState == "minimized") {
-		this.restoreWindow();
-	} else {
-		this.minimizeWindow();
-	}
-}, closeWindow:function (evt) {
-	dojo.html.removeNode(this.domNode);
-	this.destroy();
-}, onMouseDown:function (evt) {
-	this.bringToTop();
-}, bringToTop:function () {
-	var floatingPanes = dojo.widget.manager.getWidgetsByType(this.widgetType);
-	var windows = [];
-	for (var x = 0; x < floatingPanes.length; x++) {
-		if (this.widgetId != floatingPanes[x].widgetId) {
-			windows.push(floatingPanes[x]);
-		}
-	}
-	windows.sort(function (a, b) {
-		return a.domNode.style.zIndex - b.domNode.style.zIndex;
-	});
-	windows.push(this);
-	var floatingPaneStartingZ = 100;
-	for (x = 0; x < windows.length; x++) {
-		windows[x].domNode.style.zIndex = floatingPaneStartingZ + x * 2;
-	}
-}, _setInitialWindowState:function () {
-	if (this.isShowing()) {
-		this.width = -1;
-		var mb = dojo.html.getMarginBox(this.domNode);
-		this.resizeTo(mb.width, mb.height);
-	}
-	if (this.windowState == "maximized") {
-		this.maximizeWindow();
-		this.show();
-		return;
-	}
-	if (this.windowState == "normal") {
-		this.show();
-		return;
-	}
-	if (this.windowState == "minimized") {
-		this.hide();
-		return;
-	}
-	this.windowState = "minimized";
-}, _taskBarSetup:function () {
-	var taskbar = dojo.widget.getWidgetById(this.taskBarId);
-	if (!taskbar) {
-		if (this._taskBarConnectAttempts < this._max_taskBarConnectAttempts) {
-			dojo.lang.setTimeout(this, this._taskBarSetup, 50);
-			this._taskBarConnectAttempts++;
-		} else {
-			dojo.debug("Unable to connect to the taskBar");
-		}
-		return;
-	}
-	taskbar.addChild(this);
-}, showFloatingPane:function () {
-	this.bringToTop();
-}, onFloatingPaneShow:function () {
-	var mb = dojo.html.getMarginBox(this.domNode);
-	this.resizeTo(mb.width, mb.height);
-}, resizeTo:function (width, height) {
-	dojo.html.setMarginBox(this.domNode, {width:width, height:height});
-	dojo.widget.html.layout(this.domNode, [{domNode:this.titleBar, layoutAlign:"top"}, {domNode:this.resizeBar, layoutAlign:"bottom"}, {domNode:this.containerNode, layoutAlign:"client"}]);
-	dojo.widget.html.layout(this.containerNode, this.children, "top-bottom");
-	this.bgIframe.onResized();
-	if (this.shadow) {
-		this.shadow.size(width, height);
-	}
-	this.onResized();
-}, checkSize:function () {
-}, destroyFloatingPane:function () {
-	if (this.resizeHandle) {
-		this.resizeHandle.destroy();
-		this.resizeHandle = null;
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.FloatingPane", [dojo.widget.ContentPane, dojo.widget.FloatingPaneBase], {fillInTemplate:function (args, frag) {
-	this.fillInFloatingPaneTemplate(args, frag);
-	dojo.widget.FloatingPane.superclass.fillInTemplate.call(this, args, frag);
-}, postCreate:function () {
-	dojo.widget.FloatingPaneBase.prototype.postCreate.apply(this, arguments);
-	dojo.widget.FloatingPane.superclass.postCreate.apply(this, arguments);
-}, show:function () {
-	dojo.widget.FloatingPane.superclass.show.apply(this, arguments);
-	this.showFloatingPane();
-}, onShow:function () {
-	dojo.widget.FloatingPane.superclass.onShow.call(this);
-	this.onFloatingPaneShow();
-}, destroy:function () {
-	this.destroyFloatingPane();
-	dojo.widget.FloatingPane.superclass.destroy.apply(this, arguments);
-}});
-dojo.widget.defineWidget("dojo.widget.ModalFloatingPane", [dojo.widget.FloatingPane, dojo.widget.ModalDialogBase], {windowState:"minimized", displayCloseAction:true, postCreate:function () {
-	dojo.widget.ModalDialogBase.prototype.postCreate.call(this);
-	dojo.widget.ModalFloatingPane.superclass.postCreate.call(this);
-}, show:function () {
-	this.showModalDialog();
-	dojo.widget.ModalFloatingPane.superclass.show.apply(this, arguments);
-	this.bg.style.zIndex = this.domNode.style.zIndex - 1;
-}, hide:function () {
-	this.hideModalDialog();
-	dojo.widget.ModalFloatingPane.superclass.hide.apply(this, arguments);
-}, closeWindow:function () {
-	this.hide();
-	dojo.widget.ModalFloatingPane.superclass.closeWindow.apply(this, arguments);
-}});
-
+dojo.provide("dojo.widget.FloatingPane");
+dojo.provide("dojo.widget.html.FloatingPane");
+
+//
+// this widget provides a window-like floating pane
+//
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.Manager");
+dojo.require("dojo.html");
+dojo.require("dojo.html.shadow");
+dojo.require("dojo.style");
+dojo.require("dojo.dom");
+dojo.require("dojo.html.layout");
+dojo.require("dojo.widget.ContentPane");
+dojo.require("dojo.dnd.HtmlDragMove");
+dojo.require("dojo.dnd.HtmlDragMoveSource");
+dojo.require("dojo.dnd.HtmlDragMoveObject");
+dojo.require("dojo.widget.ResizeHandle");
+
+dojo.widget.html.FloatingPane = function(){
+	dojo.widget.html.ContentPane.call(this);
+}
+
+dojo.inherits(dojo.widget.html.FloatingPane, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.html.FloatingPane, {
+	widgetType: "FloatingPane",
+
+	// Constructor arguments
+	title: '',
+	iconSrc: '',
+	hasShadow: false,
+	constrainToContainer: false,
+	taskBarId: "",
+	resizable: true,
+	titleBarDisplay: "fancy",
+
+	windowState: "normal",
+	displayCloseAction: false,
+	displayMinimizeAction: false,
+	displayMaximizeAction: false,
+
+	maxTaskBarConnectAttempts: 5,
+	taskBarConnectAttempts: 0,
+
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlFloatingPane.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlFloatingPane.css"),
+
+	drag: null,
+
+	fillInTemplate: function(args, frag){
+		// Copy style info from input node to output node
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+
+		// necessary for safari, khtml (for computing width/height)
+		document.body.appendChild(this.domNode);
+
+		// if display:none then state=minimized, otherwise state=normal
+		if(!this.isShowing()){
+			this.windowState="minimized";
+		}
+
+		// <img src=""> can hang IE!  better get rid of it
+		if(this.iconSrc==""){
+			dojo.dom.removeNode(this.titleBarIcon);
+		}else{
+			this.titleBarIcon.src = this.iconSrc.toString();// dojo.uri.Uri obj req. toString()
+		}
+
+		if(this.titleBarDisplay!="none"){	
+			this.titleBar.style.display="";
+			dojo.html.disableSelection(this.titleBar);
+
+			this.titleBarIcon.style.display = (this.iconSrc=="" ? "none" : "");
+
+			this.minimizeAction.style.display = (this.displayMinimizeAction ? "" : "none");
+			this.maximizeAction.style.display= 
+				(this.displayMaximizeAction && this.windowState!="maximized" ? "" : "none");
+			this.restoreAction.style.display= 
+				(this.displayMaximizeAction && this.windowState=="maximized" ? "" : "none");
+			this.closeAction.style.display= (this.displayCloseAction ? "" : "none");
+
+			this.drag = new dojo.dnd.HtmlDragMoveSource(this.domNode);	
+			if (this.constrainToContainer) {
+				this.drag.constrainTo();
+			}
+			this.drag.setDragHandle(this.titleBar);
+
+			var self = this;
+
+			dojo.event.topic.subscribe("dragMove",
+				function (info){
+					if (info.source.domNode == self.domNode){
+						dojo.event.topic.publish('floatingPaneMove', { source: self } );
+					}
+				}
+			);
+
+		}
+
+		if(this.resizable){
+			this.resizeBar.style.display="";
+			var rh = dojo.widget.createWidget("ResizeHandle", {targetElmId: this.widgetId, id:this.widgetId+"_resize"});
+			this.resizeBar.appendChild(rh.domNode);
+		}
+
+		// add a drop shadow
+		if(this.hasShadow){
+			this.shadow=new dojo.html.shadow(this.domNode);
+		}
+
+		// Prevent IE bleed-through problem
+		this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);
+
+		if( this.taskBarId ){
+			this.taskBarSetup();
+		}
+
+		if (dojo.hostenv.post_load_) {
+			this.setInitialWindowState();
+		} else {
+			dojo.addOnLoad(this, "setInitialWindowState");
+		}
+
+		// counteract body.appendChild above
+		document.body.removeChild(this.domNode);
+
+		dojo.widget.html.FloatingPane.superclass.fillInTemplate.call(this, args, frag);
+	},
+
+	postCreate: function(){
+		if(this.isShowing()){
+			this.width=-1;	// force resize
+			this.resizeTo(dojo.style.getOuterWidth(this.domNode), dojo.style.getOuterHeight(this.domNode));
+		}
+	},
+
+	maximizeWindow: function(evt) {
+		this.previous={
+			width: dojo.style.getOuterWidth(this.domNode) || this.width,
+			height: dojo.style.getOuterHeight(this.domNode) || this.height,
+			left: this.domNode.style.left,
+			top: this.domNode.style.top,
+			bottom: this.domNode.style.bottom,
+			right: this.domNode.style.right
+		};
+		this.domNode.style.left =
+			dojo.style.getPixelValue(this.domNode.parentNode, "padding-left", true) + "px";
+		this.domNode.style.top =
+			dojo.style.getPixelValue(this.domNode.parentNode, "padding-top", true) + "px";
+
+		if ((this.domNode.parentNode.nodeName.toLowerCase() == 'body')) {
+			this.resizeTo(
+				dojo.html.getViewportWidth()-dojo.style.getPaddingWidth(document.body),
+				dojo.html.getViewportHeight()-dojo.style.getPaddingHeight(document.body)
+			);
+		} else {
+			this.resizeTo(
+				dojo.style.getContentWidth(this.domNode.parentNode),
+				dojo.style.getContentHeight(this.domNode.parentNode)
+			);
+		}
+		this.maximizeAction.style.display="none";
+		this.restoreAction.style.display="";
+		this.windowState="maximized";
+	},
+
+	minimizeWindow: function(evt) {
+		this.hide();
+		this.windowState = "minimized";
+	},
+
+	restoreWindow: function(evt) {
+		if (this.windowState=="minimized") {
+			this.show() 
+		} else {
+			for(var attr in this.previous){
+				this.domNode.style[attr] = this.previous[attr];
+			}
+			this.resizeTo(this.previous.width, this.previous.height);
+			this.previous=null;
+
+			this.restoreAction.style.display="none";
+			this.maximizeAction.style.display=this.displayMaximizeAction ? "" : "none";
+		}
+
+		this.windowState="normal";
+	},
+
+	closeWindow: function(evt) {
+		dojo.dom.removeNode(this.domNode);
+		this.destroy();
+	},
+
+	onMouseDown: function(evt) {
+		this.bringToTop();
+	},
+
+	bringToTop: function() {
+		var floatingPanes= dojo.widget.manager.getWidgetsByType(this.widgetType);
+		var windows = [];
+		for (var x=0; x<floatingPanes.length; x++) {
+			if (this.widgetId != floatingPanes[x].widgetId) {
+					windows.push(floatingPanes[x]);
+			}
+		}
+
+		windows.sort(function(a,b) {
+			return a.domNode.style.zIndex - b.domNode.style.zIndex;
+		});
+		
+		windows.push(this);
+
+		var floatingPaneStartingZ = 100;
+		for (x=0; x<windows.length;x++) {
+			windows[x].domNode.style.zIndex = floatingPaneStartingZ + x;
+		}
+	},
+
+	setInitialWindowState: function() {
+		if (this.windowState == "maximized") {
+			this.maximizeWindow();
+			this.show();
+			return;
+		}
+
+		if (this.windowState=="normal") {
+			this.show();
+			return;
+		}
+
+		if (this.windowState=="minimized") {
+			this.hide();
+			return;
+		}
+
+		this.windowState="minimized";
+	},
+
+	// add icon to task bar, connected to me
+	taskBarSetup: function() {
+		var taskbar = dojo.widget.getWidgetById(this.taskBarId);
+		if (!taskbar){
+			if (this.taskBarConnectAttempts <  this.maxTaskBarConnectAttempts) {
+				dojo.lang.setTimeout(this, this.taskBarSetup, 50);
+				this.taskBarConnectAttempts++;
+			} else {
+				dojo.debug("Unable to connect to the taskBar");
+			}
+			return;
+		}
+		taskbar.addChild(this);
+	},
+
+	show: function(){
+		dojo.widget.html.FloatingPane.superclass.show.apply(this, arguments);
+		this.bringToTop();
+	},
+
+	onShow: function(){
+		dojo.widget.html.FloatingPane.superclass.onShow.call(this);
+		this.resizeTo(dojo.style.getOuterWidth(this.domNode), dojo.style.getOuterHeight(this.domNode));
+	},
+
+	// This is called when the user adjusts the size of the floating pane
+	resizeTo: function(w, h){
+		dojo.style.setOuterWidth(this.domNode, w);
+		dojo.style.setOuterHeight(this.domNode, h);
+
+		dojo.html.layout(this.domNode,
+			[
+			  {domNode: this.titleBar, layoutAlign: "top"},
+			  {domNode: this.resizeBar, layoutAlign: "bottom"},
+			  {domNode: this.containerNode, layoutAlign: "client"}
+			] );
+
+		// If any of the children have layoutAlign specified, obey it
+		dojo.html.layout(this.containerNode, this.children, "top-bottom");
+		
+		this.bgIframe.onResized();
+		if(this.shadow){ this.shadow.size(w, h); }
+		this.onResized();
+	},
+
+	checkSize: function() {
+		// checkSize() is called when the user has resized the browser window,
+		// but that doesn't affect this widget (or this widget's children)
+		// so it can be safely ignored...
+		// TODO: unless we are maximized.  then we should resize ourself.
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:FloatingPane");

Deleted: tags/parley-0.53/root/static/magic/src/widget/Form.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Form.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Form.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,267 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.Form");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.Form", dojo.widget.HtmlWidget, {isContainer:true, templateString:"<form dojoAttachPoint='containerNode' dojoAttachEvent='onSubmit:onSubmit'></form>", formElements:[], ignoreNullValues:false, postCreate:function (args, frag) {
-	for (var key in args) {
-		if (key == "dojotype") {
-			continue;
-		}
-		var attr = document.createAttribute(key);
-		attr.nodeValue = args[key];
-		this.containerNode.setAttributeNode(attr);
-	}
-}, _createRepeaters:function (obj, widget) {
-	for (var i = 0; i < widget.children.length; ++i) {
-		if (widget.children[i].widgetType == "RepeaterContainer") {
-			var rIndex = widget.children[i].index;
-			var rIndexPos = rIndex.indexOf("%{index}");
-			rIndex = rIndex.substr(0, rIndexPos - 1);
-			var myObj = this._getObject(obj, rIndex);
-			if (typeof (myObj) == "object" && myObj.length == 0) {
-				myObj = new Array();
-			}
-			var rowCount = widget.children[i].getRowCount();
-			for (var j = 0, len = rowCount; j < len; ++j) {
-				widget.children[i].deleteRow(0);
-			}
-			for (var j = 0; j < myObj.length; j++) {
-				widget.children[i].addRow(false);
-			}
-		}
-		if (widget.children[i].isContainer) {
-			this._createRepeaters(obj, widget.children[i]);
-		}
-	}
-}, _createFormElements:function () {
-	if (dojo.render.html.safari) {
-		this.formElements = [];
-		var elems = ["INPUT", "SELECT", "TEXTAREA"];
-		for (var k = 0; k < elems.length; k++) {
-			var list = this.containerNode.getElementsByTagName(elems[k]);
-			for (var j = 0, len2 = list.length; j < len2; j++) {
-				this.formElements.push(list[j]);
-			}
-		}
-	} else {
-		this.formElements = this.containerNode.elements;
-	}
-}, onSubmit:function (e) {
-	e.preventDefault();
-}, submit:function () {
-	this.containerNode.submit();
-}, _getFormElement:function (name) {
-	if (dojo.render.html.ie) {
-		for (var i = 0, len = this.formElements.length; i < len; i++) {
-			var element = this.formElements[i];
-			if (element.name == name) {
-				return element;
-			}
-		}
-	} else {
-		var elem = this.formElements[name];
-		if (typeof (elem) != "undefined") {
-			return elem;
-		}
-	}
-	return null;
-}, _getObject:function (obj, searchString) {
-	var namePath = [];
-	namePath = searchString.split(".");
-	var myObj = obj;
-	var name = namePath[namePath.length - 1];
-	for (var j = 0, len = namePath.length; j < len; ++j) {
-		var p = namePath[j];
-		if (typeof (myObj[p]) == "undefined") {
-			myObj[p] = {};
-		}
-		myObj = myObj[p];
-	}
-	return myObj;
-}, _setToContainers:function (obj, widget) {
-	for (var i = 0, len = widget.children.length; i < len; ++i) {
-		var currentWidget = widget.children[i];
-		if (currentWidget.widgetType == "Repeater") {
-			for (var j = 0, len = currentWidget.getRowCount(); j < len; ++j) {
-				currentWidget._initRow(j);
-			}
-		}
-		if (currentWidget.isContainer) {
-			this._setToContainers(obj, currentWidget);
-			continue;
-		}
-		switch (currentWidget.widgetType) {
-		  case "Checkbox":
-			currentWidget.setValue(currentWidget.inputNode.checked);
-			break;
-		  case "DropdownDatePicker":
-			currentWidget.setValue(currentWidget.getValue());
-			break;
-		  case "Select":
-			continue;
-			break;
-		  case "ComboBox":
-			continue;
-			break;
-		  default:
-			break;
-		}
-	}
-}, setValues:function (obj) {
-	this._createFormElements();
-	this._createRepeaters(obj, this);
-	for (var i = 0, len = this.formElements.length; i < len; i++) {
-		var element = this.formElements[i];
-		if (element.name == "") {
-			continue;
-		}
-		var namePath = new Array();
-		namePath = element.name.split(".");
-		var myObj = obj;
-		var name = namePath[namePath.length - 1];
-		for (var j = 1, len2 = namePath.length; j < len2; ++j) {
-			var p = namePath[j - 1];
-			if (typeof (myObj[p]) == "undefined") {
-				myObj = undefined;
-				break;
-			}
-			myObj = myObj[p];
-		}
-		if (typeof (myObj) == "undefined") {
-			continue;
-		}
-		if (typeof (myObj[name]) == "undefined" && this.ignoreNullValues) {
-			continue;
-		}
-		var type = element.type;
-		if (type == "hidden" || type == "text" || type == "textarea" || type == "password") {
-			type = "text";
-		}
-		switch (type) {
-		  case "checkbox":
-			element.checked = false;
-			if (typeof (myObj[name]) == "undefined") {
-				continue;
-			}
-			for (var j = 0, len2 = myObj[name].length; j < len2; ++j) {
-				if (element.value == myObj[name][j]) {
-					element.checked = true;
-				}
-			}
-			break;
-		  case "radio":
-			element.checked = false;
-			if (typeof (myObj[name]) == "undefined") {
-				continue;
-			}
-			if (myObj[name] == element.value) {
-				element.checked = true;
-			}
-			break;
-		  case "select-multiple":
-			element.selectedIndex = -1;
-			for (var j = 0, len2 = element.options.length; j < len2; ++j) {
-				for (var k = 0, len3 = myObj[name].length; k < len3; ++k) {
-					if (element.options[j].value == myObj[name][k]) {
-						element.options[j].selected = true;
-					}
-				}
-			}
-			break;
-		  case "select-one":
-			element.selectedIndex = "0";
-			for (var j = 0, len2 = element.options.length; j < len2; ++j) {
-				if (element.options[j].value == myObj[name]) {
-					element.options[j].selected = true;
-				} else {
-				}
-			}
-			break;
-		  case "text":
-			var value = "";
-			if (typeof (myObj[name]) != "undefined") {
-				value = myObj[name];
-			}
-			element.value = value;
-			break;
-		  default:
-			dojo.debug("Not supported type (" + type + ")");
-			break;
-		}
-	}
-	this._setToContainers(obj, this);
-}, getValues:function () {
-	this._createFormElements();
-	var obj = {};
-	for (var i = 0, len = this.formElements.length; i < len; i++) {
-		var elm = this.formElements[i];
-		var namePath = [];
-		if (elm.name == "") {
-			continue;
-		}
-		namePath = elm.name.split(".");
-		var myObj = obj;
-		var name = namePath[namePath.length - 1];
-		for (var j = 1, len2 = namePath.length; j < len2; ++j) {
-			var nameIndex = null;
-			var p = namePath[j - 1];
-			var nameA = p.split("[");
-			if (nameA.length > 1) {
-				if (typeof (myObj[nameA[0]]) == "undefined") {
-					myObj[nameA[0]] = [];
-				}
-				nameIndex = parseInt(nameA[1]);
-				if (typeof (myObj[nameA[0]][nameIndex]) == "undefined") {
-					myObj[nameA[0]][nameIndex] = {};
-				}
-			} else {
-				if (typeof (myObj[nameA[0]]) == "undefined") {
-					myObj[nameA[0]] = {};
-				}
-			}
-			if (nameA.length == 1) {
-				myObj = myObj[nameA[0]];
-			} else {
-				myObj = myObj[nameA[0]][nameIndex];
-			}
-		}
-		if ((elm.type != "select-multiple" && elm.type != "checkbox" && elm.type != "radio") || (elm.type == "radio" && elm.checked)) {
-			if (name == name.split("[")[0]) {
-				myObj[name] = elm.value;
-			} else {
-			}
-		} else {
-			if (elm.type == "checkbox" && elm.checked) {
-				if (typeof (myObj[name]) == "undefined") {
-					myObj[name] = [];
-				}
-				myObj[name].push(elm.value);
-			} else {
-				if (elm.type == "select-multiple") {
-					if (typeof (myObj[name]) == "undefined") {
-						myObj[name] = [];
-					}
-					for (var jdx = 0, len3 = elm.options.length; jdx < len3; ++jdx) {
-						if (elm.options[jdx].selected) {
-							myObj[name].push(elm.options[jdx].value);
-						}
-					}
-				}
-			}
-		}
-		name = undefined;
-	}
-	return obj;
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/GoogleMap.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/GoogleMap.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/GoogleMap.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,162 +8,37 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.GoogleMap");
-dojo.require("dojo.event.*");
-dojo.require("dojo.math");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.uri.Uri");
-dojo.require("dojo.widget.HtmlWidget");
-(function () {
-	var gkey = djConfig["gMapKey"] || djConfig["googleMapKey"];
-	var uri = new dojo.uri.Uri(window.location.href);
-	if (uri.host == "www.dojotoolkit.org") {
-		gkey = "ABQIAAAACUNdgv_7FGOmUslbm9l6_hRqjp7ri2mNiOEYqetD3xnFHpt5rBSjszDd1sdufPyQKUTyCf_YxoIxvw";
-	} else {
-		if (uri.host == "blog.dojotoolkit.org") {
-			gkey = "ABQIAAAACUNdgv_7FGOmUslbm9l6_hSkep6Av1xaMhVn3yCLkorJeXeLARQ6fammI_P3qSGleTJhoI5_1JmP_Q";
-		} else {
-			if (uri.host == "archive.dojotoolkit.org") {
-				gkey = "ABQIAAAACUNdgv_7FGOmUslbm9l6_hTaQpDt0dyGLIHbXMPTzg1kWeAfwRTwZNyrUfbfxYE9yIvRivEjcXoDTg";
-			} else {
-				if (uri.host == "dojotoolkit.org") {
-					gkey = "ABQIAAAACUNdgv_7FGOmUslbm9l6_hSaOaO_TgJ5c3mtQFnk5JO2zD5dZBRZk-ieqVs7BORREYNzAERmcJoEjQ";
-				}
-			}
-		}
-	}
-	if (!dojo.hostenv.post_load_) {
-		if (!gkey || gkey == "") {
-			dojo.raise("dojo.widget.GoogleMap: The Google Map widget requires a proper API key in order to be used.");
-		}
-		var tag = "<scr" + "ipt src='http://maps.google.com/maps?file=api&amp;v=2&amp;key=" + gkey + "'></scri" + "pt>";
-		if (!dj_global["GMap2"]) {
-			document.write(tag);
-		}
-	} else {
-		dojo.debug("Cannot initialize Google Map system after the page has been loaded! Please either manually include the script block provided by Google in your page or require() the GoogleMap widget before onload has fired.");
-	}
-})();
-dojo.widget.defineWidget("dojo.widget.GoogleMap", dojo.widget.HtmlWidget, function () {
-	this.map = null;
-	this.geocoder = null;
-	this.data = [];
-	this.datasrc = "";
-	this.controls = ["largemap", "scale", "maptype"];
-}, {templatePath:null, templateCssPath:null, isContainer:false, _defaultPoint:{lat:39.10662, lng:-94.578209}, setControls:function () {
-	var methodmap = {largemap:GLargeMapControl, smallmap:GSmallMapControl, smallzoom:GSmallZoomControl, scale:GScaleControl, maptype:GMapTypeControl, overview:GOverviewMapControl};
-	for (var i = 0; i < this.controls.length; i++) {
-		this.map.addControl(new (methodmap[this.controls[i].toLowerCase()])());
-	}
-}, findCenter:function (bounds) {
-	if (this.data.length == 1) {
-		return (new GLatLng(this.data[0].lat, this.data[0].lng));
-	}
-	var clat = (bounds.getNorthEast().lat() + bounds.getSouthWest().lat()) / 2;
-	var clng = (bounds.getNorthEast().lng() + bounds.getSouthWest().lng()) / 2;
-	return (new GLatLng(clat, clng));
-}, createPinpoint:function (pt, overlay) {
-	var m = new GMarker(pt);
-	if (overlay) {
-		GEvent.addListener(m, "click", function () {
-			m.openInfoWindowHtml("<div>" + overlay + "</div>");
-		});
-	}
-	return m;
-}, plot:function (obj) {
-	var p = new GLatLng(obj.lat, obj.lng);
-	var d = obj.description || null;
-	var m = this.createPinpoint(p, d);
-	this.map.addOverlay(m);
-}, plotAddress:function (address) {
-	var self = this;
-	this.geocoder.getLocations(address, function (response) {
-		if (!response || response.Status.code != 200) {
-			alert("The address \"" + address + "\" was not found.");
-			return;
-		}
-		var obj = {lat:response.Placemark[0].Point.coordinates[1], lng:response.Placemark[0].Point.coordinates[0], description:response.Placemark[0].address};
-		self.data.push(obj);
-		self.render();
-	});
-}, parse:function (table) {
-	this.data = [];
-	var h = table.getElementsByTagName("thead")[0];
-	if (!h) {
-		return;
-	}
-	var a = [];
-	var cols = h.getElementsByTagName("td");
-	if (cols.length == 0) {
-		cols = h.getElementsByTagName("th");
-	}
-	for (var i = 0; i < cols.length; i++) {
-		var c = cols[i].innerHTML.toLowerCase();
-		if (c == "long") {
-			c = "lng";
-		}
-		a.push(c);
-	}
-	var b = table.getElementsByTagName("tbody")[0];
-	if (!b) {
-		return;
-	}
-	for (var i = 0; i < b.childNodes.length; i++) {
-		if (!(b.childNodes[i].nodeName && b.childNodes[i].nodeName.toLowerCase() == "tr")) {
-			continue;
-		}
-		var cells = b.childNodes[i].getElementsByTagName("td");
-		var o = {};
-		for (var j = 0; j < a.length; j++) {
-			var col = a[j];
-			if (col == "lat" || col == "lng") {
-				o[col] = parseFloat(cells[j].innerHTML);
-			} else {
-				o[col] = cells[j].innerHTML;
-			}
-		}
-		this.data.push(o);
-	}
-}, render:function () {
-	if (this.data.length == 0) {
-		this.map.setCenter(new GLatLng(this._defaultPoint.lat, this._defaultPoint.lng), 4);
-		return;
-	}
-	this.map.clearOverlays();
-	var bounds = new GLatLngBounds();
-	var d = this.data;
-	for (var i = 0; i < d.length; i++) {
-		bounds.extend(new GLatLng(d[i].lat, d[i].lng));
-	}
-	var zoom = Math.min((this.map.getBoundsZoomLevel(bounds) - 1), 14);
-	this.map.setCenter(this.findCenter(bounds), zoom);
-	for (var i = 0; i < this.data.length; i++) {
-		this.plot(this.data[i]);
-	}
-}, initialize:function (args, frag) {
-	if (this.datasrc) {
-		this.parse(dojo.byId(this.datasrc));
-	} else {
-		if (this.domNode.getElementsByTagName("table")[0]) {
-			this.parse(this.domNode.getElementsByTagName("table")[0]);
-		}
-	}
-}, postCreate:function () {
-	while (this.domNode.childNodes.length > 0) {
-		this.domNode.removeChild(this.domNode.childNodes[0]);
-	}
-	if (this.domNode.style.position != "absolute") {
-		this.domNode.style.position = "relative";
-	}
-	this.map = new GMap2(this.domNode);
-	try {
-		this.geocoder = new GClientGeocoder();
-	}
-	catch (ex) {
-	}
-	this.render();
-	this.setControls();
-}});
-
+dojo.provide("dojo.widget.GoogleMap");
+dojo.provide("dojo.widget.GoogleMap.Controls");
+dojo.require("dojo.widget.*");
+dojo.widget.tags.addParseTreeHandler("dojo:googlemap");
+
+dojo.widget.GoogleMap=function(){
+	//	summary
+	//	base class for the Google Map widget
+	dojo.widget.Widget.call(this);
+	this.widgetType="GoogleMap";
+	this.isContainer=false;
+}
+dojo.inherits(dojo.widget.GoogleMap, dojo.widget.Widget);
+
+dojo.widget.GoogleMap.Controls={
+	LargeMap:"largemap",
+	SmallMap:"smallmap",
+	SmallZoom:"smallzoom",
+	Scale:"scale",
+	MapType:"maptype",
+	Overview:"overview",
+	get:function(s){
+		for(var p in this){
+			if(typeof(this[p])=="string"
+				&& this[p]==s
+			){
+				return p;
+			}
+		}
+		return null;
+	}
+};
+
+dojo.requireAfterIf("html", "dojo.widget.html.GoogleMap");

Modified: tags/parley-0.53/root/static/magic/src/widget/HtmlWidget.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/HtmlWidget.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/HtmlWidget.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,94 +8,156 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.HtmlWidget");
 dojo.require("dojo.widget.DomWidget");
-dojo.require("dojo.html.util");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.layout");
+dojo.require("dojo.html");
+dojo.require("dojo.html.extras");
 dojo.require("dojo.lang.extras");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.lfx.toggle");
-dojo.declare("dojo.widget.HtmlWidget", dojo.widget.DomWidget, {templateCssPath:null, templatePath:null, lang:"", toggle:"plain", toggleDuration:150, initialize:function (args, frag) {
-}, postMixInProperties:function (args, frag) {
-	if (this.lang === "") {
-		this.lang = null;
-	}
-	this.toggleObj = dojo.lfx.toggle[this.toggle.toLowerCase()] || dojo.lfx.toggle.plain;
-}, createNodesFromText:function (txt, wrap) {
-	return dojo.html.createNodesFromText(txt, wrap);
-}, destroyRendering:function (finalize) {
-	try {
-		if (this.bgIframe) {
-			this.bgIframe.remove();
-			delete this.bgIframe;
+
+dojo.declare("dojo.widget.HtmlWidget", dojo.widget.DomWidget, {								 
+	widgetType: "HtmlWidget",
+
+	templateCssPath: null,
+	templatePath: null,
+
+	// for displaying/hiding widget
+	toggle: "plain",
+	toggleDuration: 150,
+
+	animationInProgress: false,
+
+	initialize: function(args, frag){
+	},
+
+	postMixInProperties: function(args, frag){
+		// now that we know the setting for toggle, get toggle object
+		// (default to plain toggler if user specified toggler not present)
+		this.toggleObj =
+			dojo.lfx.toggle[this.toggle.toLowerCase()] || dojo.lfx.toggle.plain;
+	},
+
+	getContainerHeight: function(){
+		// NOTE: container height must be returned as the INNER height
+		dojo.unimplemented("dojo.widget.HtmlWidget.getContainerHeight");
+	},
+
+	getContainerWidth: function(){
+		return this.parent.domNode.offsetWidth;
+	},
+
+	setNativeHeight: function(height){
+		var ch = this.getContainerHeight();
+	},
+
+	createNodesFromText: function(txt, wrap){
+		return dojo.html.createNodesFromText(txt, wrap);
+	},
+
+	destroyRendering: function(finalize){
+		try{
+			if(!finalize){
+				dojo.event.browser.clean(this.domNode);
+			}
+			this.domNode.parentNode.removeChild(this.domNode);
+			delete this.domNode;
+		}catch(e){ /* squelch! */ }
+	},
+
+	/////////////////////////////////////////////////////////
+	// Displaying/hiding the widget
+	/////////////////////////////////////////////////////////
+	isShowing: function(){
+		return dojo.style.isShowing(this.domNode);
+	},
+
+	toggleShowing: function(){
+		// dojo.style.toggleShowing(this.domNode);
+		if(this.isHidden){
+			this.show();
+		}else{
+			this.hide();
 		}
-		if (!finalize && this.domNode) {
-			dojo.event.browser.clean(this.domNode);
-		}
-		dojo.widget.HtmlWidget.superclass.destroyRendering.call(this);
-	}
-	catch (e) {
-	}
-}, isShowing:function () {
-	return dojo.html.isShowing(this.domNode);
-}, toggleShowing:function () {
-	if (this.isShowing()) {
-		this.hide();
-	} else {
-		this.show();
-	}
-}, show:function () {
-	if (this.isShowing()) {
-		return;
-	}
-	this.animationInProgress = true;
-	this.toggleObj.show(this.domNode, this.toggleDuration, null, dojo.lang.hitch(this, this.onShow), this.explodeSrc);
-}, onShow:function () {
-	this.animationInProgress = false;
-	this.checkSize();
-}, hide:function () {
-	if (!this.isShowing()) {
-		return;
-	}
-	this.animationInProgress = true;
-	this.toggleObj.hide(this.domNode, this.toggleDuration, null, dojo.lang.hitch(this, this.onHide), this.explodeSrc);
-}, onHide:function () {
-	this.animationInProgress = false;
-}, _isResized:function (w, h) {
-	if (!this.isShowing()) {
-		return false;
-	}
-	var wh = dojo.html.getMarginBox(this.domNode);
-	var width = w || wh.width;
-	var height = h || wh.height;
-	if (this.width == width && this.height == height) {
-		return false;
-	}
-	this.width = width;
-	this.height = height;
-	return true;
-}, checkSize:function () {
-	if (!this._isResized()) {
-		return;
-	}
-	this.onResized();
-}, resizeTo:function (w, h) {
-	dojo.html.setMarginBox(this.domNode, {width:w, height:h});
-	if (this.isShowing()) {
+	},
+
+	show: function(){
+		this.animationInProgress=true;
+		this.isHidden = false;
+		this.toggleObj.show(this.domNode, this.toggleDuration, null,
+			dojo.lang.hitch(this, this.onShow), this.explodeSrc);
+	},
+
+	// called after the show() animation has completed
+	onShow: function(){
+		this.animationInProgress=false;
+		this.checkSize();
+	},
+
+	hide: function(){
+		this.animationInProgress = true;
+		this.isHidden = true;
+		this.toggleObj.hide(this.domNode, this.toggleDuration, null,
+			dojo.lang.hitch(this, this.onHide), this.explodeSrc);
+	},
+
+	// called after the hide() animation has completed
+	onHide: function(){
+		this.animationInProgress=false;
+	},
+
+	//////////////////////////////////////////////////////////////////////////////
+	// Sizing related methods
+	//  If the parent changes size then for each child it should call either
+	//   - resizeTo(): size the child explicitly
+	//   - or checkSize(): notify the child the the parent has changed size
+	//////////////////////////////////////////////////////////////////////////////
+
+	// Test if my size has changed.
+	// If width & height are specified then that's my new size; otherwise,
+	// query outerWidth/outerHeight of my domNode
+	_isResized: function(w, h){
+		// If I'm not being displayed then disregard (show() must
+		// check if the size has changed)
+		if(!this.isShowing()){ return false; }
+
+		// If my parent has been resized and I have style="height: 100%"
+		// or something similar then my size has changed too.
+		w=w||dojo.style.getOuterWidth(this.domNode);
+		h=h||dojo.style.getOuterHeight(this.domNode);
+		if(this.width == w && this.height == h){ return false; }
+
+		this.width=w;
+		this.height=h;
+		return true;
+	},
+
+	// Called when my parent has changed size, but my parent won't call resizeTo().
+	// This is useful if my size is height:100% or something similar.
+	// Also called whenever I am shown, because the first time I am shown I may need
+	// to do size calculations.
+	checkSize: function(){
+		if(!this._isResized()){ return; }
 		this.onResized();
-	}
-}, resizeSoon:function () {
-	if (this.isShowing()) {
-		dojo.lang.setTimeout(this, this.onResized, 0);
-	}
-}, onResized:function () {
-	dojo.lang.forEach(this.children, function (child) {
-		if (child.checkSize) {
-			child.checkSize();
+	},
+
+	// Explicitly set this widget's size (in pixels).
+	resizeTo: function(w, h){
+		if(!this._isResized(w,h)){ return; }
+		dojo.style.setOuterWidth(this.domNode, w);
+		dojo.style.setOuterHeight(this.domNode, h);
+		this.onResized();
+	},
+
+	resizeSoon: function(){
+		if(this.isShowing()){
+			dojo.lang.setTimeout(this, this.onResized, 0);
 		}
-	});
-}});
+	},
 
+	// Called when my size has changed.
+	// Must notify children if their size has (possibly) changed
+	onResized: function(){
+		dojo.lang.forEach(this.children, function(child){ child.checkSize(); });
+	}
+});

Modified: tags/parley-0.53/root/static/magic/src/widget/InlineEditBox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/InlineEditBox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/InlineEditBox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,149 +8,165 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.InlineEditBox");
+dojo.provide("dojo.widget.html.InlineEditBox");
 
-
-dojo.provide("dojo.widget.InlineEditBox");
 dojo.require("dojo.widget.*");
-dojo.require("dojo.event.*");
 dojo.require("dojo.lfx.*");
-dojo.require("dojo.gfx.color");
+dojo.require("dojo.graphics.color");
 dojo.require("dojo.string");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.layout");
-dojo.widget.defineWidget("dojo.widget.InlineEditBox", dojo.widget.HtmlWidget, function () {
+dojo.require("dojo.style");
+dojo.require("dojo.html");
+
+dojo.widget.tags.addParseTreeHandler("dojo:inlineeditbox");
+
+dojo.widget.html.InlineEditBox = function(){
+	dojo.widget.HtmlWidget.call(this);
+	// mutable objects need to be in constructor to give each instance its own copy
 	this.history = [];
-}, {templateString:"<form class=\"inlineEditBox\" style=\"display: none\" dojoAttachPoint=\"form\" dojoAttachEvent=\"onSubmit:saveEdit; onReset:cancelEdit; onKeyUp: checkForValueChange;\">\n\t<input type=\"text\" dojoAttachPoint=\"text\" style=\"display: none;\" />\n\t<textarea dojoAttachPoint=\"textarea\" style=\"display: none;\"></textarea>\n\t<input type=\"submit\" value=\"Save\" dojoAttachPoint=\"submitButton\" />\n\t<input type=\"reset\" value=\"Cancel\" dojoAttachPoint=\"cancelButton\" />\n</form>\n", templateCssString:".editLabel {\n\tfont-size : small;\n\tpadding : 0 5px;\n\tdisplay : none;\n}\n\n.editableRegionDisabled {\n\tcursor : pointer;\n\t_cursor : hand;\n}\n\n.editableRegion {\n\tbackground-color : #ffc !important;\n\tcursor : pointer;\n\t_cursor : hand;\n}\n\n.editableRegion .editLabel {\n\tdisplay : inline;\n}\n\n.editableTextareaRegion .editLabel {\n\tdisplay : block;\n}\n\n.inlineEditBox {\n\t/*background-color : #ffc;*/\n\tdisplay : inline;\n}\n", templ!
 ateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/InlineEditBox.css"), mode:"text", name:"", minWidth:100, minHeight:200, editing:false, value:"", textValue:"", defaultText:"", postMixInProperties:function () {
-	if (this.textValue) {
-		dojo.deprecated("InlineEditBox: Use value parameter instead of textValue; will be removed in 0.5");
-		this.value = this.textValue;
-	}
-	if (this.defaultText) {
-		dojo.deprecated("InlineEditBox: Use value parameter instead of defaultText; will be removed in 0.5");
-		this.value = this.defaultText;
-	}
-}, postCreate:function (args, frag) {
-	this.editable = this.getFragNodeRef(frag);
-	dojo.html.insertAfter(this.editable, this.form);
-	dojo.event.connect(this.editable, "onmouseover", this, "onMouseOver");
-	dojo.event.connect(this.editable, "onmouseout", this, "onMouseOut");
-	dojo.event.connect(this.editable, "onclick", this, "_beginEdit");
-	if (this.value) {
-		this.editable.innerHTML = this.value;
-		return;
-	} else {
-		this.value = dojo.string.trim(this.editable.innerHTML);
-		this.editable.innerHTML = this.value;
-	}
-}, onMouseOver:function () {
-	if (!this.editing) {
-		if (this.disabled) {
-			dojo.html.addClass(this.editable, "editableRegionDisabled");
-		} else {
+}
+
+dojo.inherits(dojo.widget.html.InlineEditBox, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.InlineEditBox, {
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlInlineEditBox.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlInlineEditBox.css"),
+	widgetType: "InlineEditBox",
+
+	form: null,
+	editBox: null,
+	edit: null,
+	text: null,
+	textarea: null,
+	submitButton: null,
+	cancelButton: null,
+	mode: "text",
+
+	minWidth: 100, //px. minimum width of edit box
+	minHeight: 200, //px. minimum width of edit box, if it's a TA
+
+	editing: false,
+	textValue: "",
+	defaultText: "",
+	doFade: false,
+	
+	onSave: function(newValue, oldValue){},
+	onUndo: function(value){},
+
+	postCreate: function(args, frag){
+		// put original node back in the document, and attach handlers
+		// which hide it and display the editor
+		this.editable = this.getFragNodeRef(frag);
+		dojo.dom.insertAfter(this.editable, this.form);
+		dojo.event.connect(this.editable, "onmouseover", this, "mouseover");
+		dojo.event.connect(this.editable, "onmouseout", this, "mouseout");
+		dojo.event.connect(this.editable, "onclick", this, "beginEdit");
+
+		this.textValue = dojo.string.trim(this.editable.innerHTML);
+		if(dojo.string.trim(this.textValue).length == 0){
+			this.editable.innerHTML = this.defaultText;
+		}		
+	},
+
+	mouseover: function(e){
+		if(!this.editing){
 			dojo.html.addClass(this.editable, "editableRegion");
-			if (this.mode == "textarea") {
+			if(this.mode == "textarea"){
 				dojo.html.addClass(this.editable, "editableTextareaRegion");
 			}
 		}
-	}
-}, onMouseOut:function () {
-	if (!this.editing) {
-		dojo.html.removeClass(this.editable, "editableRegion");
-		dojo.html.removeClass(this.editable, "editableTextareaRegion");
-		dojo.html.removeClass(this.editable, "editableRegionDisabled");
-	}
-}, _beginEdit:function (e) {
-	if (this.editing || this.disabled) {
-		return;
-	}
-	this.onMouseOut();
-	this.editing = true;
-	var ee = this[this.mode.toLowerCase()];
-	ee.value = dojo.string.trim(this.value);
-	ee.style.fontSize = dojo.html.getStyle(this.editable, "font-size");
-	ee.style.fontWeight = dojo.html.getStyle(this.editable, "font-weight");
-	ee.style.fontStyle = dojo.html.getStyle(this.editable, "font-style");
-	var bb = dojo.html.getBorderBox(this.editable);
-	ee.style.width = Math.max(bb.width, this.minWidth) + "px";
-	if (this.mode.toLowerCase() == "textarea") {
-		ee.style.display = "block";
-		ee.style.height = Math.max(bb.height, this.minHeight) + "px";
-	} else {
-		ee.style.display = "";
-	}
-	this.form.style.display = "";
-	this.editable.style.display = "none";
-	ee.focus();
-	ee.select();
-	this.submitButton.disabled = true;
-}, saveEdit:function (e) {
-	e.preventDefault();
-	e.stopPropagation();
-	var ee = this[this.mode.toLowerCase()];
-	if ((this.value != ee.value) && (dojo.string.trim(ee.value) != "")) {
-		this.doFade = true;
-		this.history.push(this.value);
-		this.onSave(ee.value, this.value, this.name);
-		this.value = ee.value;
-		this.editable.innerHTML = "";
-		var textNode = document.createTextNode(this.value);
-		this.editable.appendChild(textNode);
-	} else {
+	},
+
+	mouseout: function(e){
+		if(!this.editing){
+			dojo.html.removeClass(this.editable, "editableRegion");
+			dojo.html.removeClass(this.editable, "editableTextareaRegion");
+		}
+	},
+
+	// When user clicks the text, then start editing.
+	// Hide the text and display the form instead.
+	beginEdit: function(e){
+		if(this.editing){ return; }
+		this.mouseout();
+		this.editing = true;
+
+		// setup the form's <input> or <textarea> field, as specified by mode
+		var ee = this[this.mode.toLowerCase()];
+		ee.value = dojo.string.trim(this.textValue);
+		ee.style.fontSize = dojo.style.getStyle(this.editable, "font-size");
+		ee.style.fontWeight = dojo.style.getStyle(this.editable, "font-weight");
+		ee.style.fontStyle = dojo.style.getStyle(this.editable, "font-style");
+		ee.style.width = Math.max(dojo.html.getInnerWidth(this.editable), this.minWidth) + "px";
+		if(this.mode.toLowerCase()=="textarea"){
+			ee.style.display = "block";
+			ee.style.height = Math.max(dojo.html.getInnerHeight(this.editable), this.minHeight) + "px";
+		} else {
+			ee.style.display = "";
+		}
+
+		// show the edit form and hide the read only version of the text
+		this.form.style.display = "";
+		this.editable.style.display = "none";
+
+		ee.select();
+		this.submitButton.disabled = true;
+	},
+
+	saveEdit: function(e){
+		e.preventDefault();
+		e.stopPropagation();
+		var ee = this[this.mode.toLowerCase()];
+		if((this.textValue != ee.value)&&
+			(dojo.string.trim(ee.value) != "")){
+			this.doFade = true;
+			this.history.push(this.textValue);
+			this.onSave(ee.value, this.textValue);
+			this.textValue = ee.value;
+			this.editable.innerHTML = this.textValue;
+		}else{
+			this.doFade = false;
+		}
+		this.finishEdit(e);
+	},
+
+	cancelEdit: function(e){
+		if(!this.editing){ return false; }
+		this.editing = false;
+		this.form.style.display="none";
+		this.editable.style.display = "";
+		return true;
+	},
+
+	finishEdit: function(e){
+		if(!this.cancelEdit(e)){ return; }
+		if(this.doFade) {
+			dojo.lfx.highlight(this.editable, dojo.graphics.color.hex2rgb("#ffc"), 700).play(300);
+		}
 		this.doFade = false;
+	},
+
+	setText: function(txt){
+		// sets the text without informing the server
+		var tt = dojo.string.trim(txt);
+		this.textValue = tt
+		this.editable.innerHTML = tt;
+	},
+
+	undo: function(){
+		if(this.history.length > 0){
+			var value = this.history.pop();
+			this.editable.innerHTML = value;
+			this.textValue = value;
+			this.onUndo(value);
+		}
+	},
+
+	checkForValueChange: function(){
+		var ee = this[this.mode.toLowerCase()];
+		if((this.textValue != ee.value)&&
+			(dojo.string.trim(ee.value) != "")){
+			this.submitButton.disabled = false;
+		}
 	}
-	this._finishEdit(e);
-}, _stopEditing:function () {
-	this.editing = false;
-	this.form.style.display = "none";
-	this.editable.style.display = "";
-	return true;
-}, cancelEdit:function (e) {
-	this._stopEditing();
-	this.onCancel();
-	return true;
-}, _finishEdit:function (e) {
-	this._stopEditing();
-	if (this.doFade) {
-		dojo.lfx.highlight(this.editable, dojo.gfx.color.hex2rgb("#ffc"), 700).play(300);
-	}
-	this.doFade = false;
-}, setText:function (txt) {
-	dojo.deprecated("setText() is deprecated, call setValue() instead, will be removed in 0.5");
-	this.setValue(txt);
-}, setValue:function (txt) {
-	txt = "" + txt;
-	var tt = dojo.string.trim(txt);
-	this.value = tt;
-	this.editable.innerHTML = tt;
-}, undo:function () {
-	if (this.history.length > 0) {
-		var curValue = this.value;
-		var value = this.history.pop();
-		this.editable.innerHTML = value;
-		this.value = value;
-		this.onUndo(value);
-		this.onSave(value, curValue, this.name);
-	}
-}, onChange:function (newValue, oldValue) {
-}, onSave:function (newValue, oldValue, name) {
-}, onCancel:function () {
-}, checkForValueChange:function () {
-	var ee = this[this.mode.toLowerCase()];
-	if ((this.value != ee.value) && (dojo.string.trim(ee.value) != "")) {
-		this.submitButton.disabled = false;
-	}
-	this.onChange(this.value, ee.value);
-}, disable:function () {
-	this.submitButton.disabled = true;
-	this.cancelButton.disabled = true;
-	var ee = this[this.mode.toLowerCase()];
-	ee.disabled = true;
-	dojo.widget.InlineEditBox.superclass.disable.apply(this, arguments);
-}, enable:function () {
-	this.checkForValueChange();
-	this.cancelButton.disabled = false;
-	var ee = this[this.mode.toLowerCase()];
-	ee.disabled = false;
-	dojo.widget.InlineEditBox.superclass.enable.apply(this, arguments);
-}});
-
+});

Deleted: tags/parley-0.53/root/static/magic/src/widget/IntegerTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/IntegerTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/IntegerTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,42 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.IntegerTextbox");
-dojo.require("dojo.widget.ValidationTextbox");
-dojo.require("dojo.validate.common");
-dojo.widget.defineWidget("dojo.widget.IntegerTextbox", dojo.widget.ValidationTextbox, {mixInProperties:function (localProperties, frag) {
-	dojo.widget.IntegerTextbox.superclass.mixInProperties.apply(this, arguments);
-	if ((localProperties.signed == "true") || (localProperties.signed == "always")) {
-		this.flags.signed = true;
-	} else {
-		if ((localProperties.signed == "false") || (localProperties.signed == "never")) {
-			this.flags.signed = false;
-			this.flags.min = 0;
-		} else {
-			this.flags.signed = [true, false];
-		}
-	}
-	if (localProperties.separator) {
-		this.flags.separator = localProperties.separator;
-	}
-	if (localProperties.min) {
-		this.flags.min = parseInt(localProperties.min);
-	}
-	if (localProperties.max) {
-		this.flags.max = parseInt(localProperties.max);
-	}
-}, isValid:function () {
-	return dojo.validate.isInteger(this.textbox.value, this.flags);
-}, isInRange:function () {
-	return dojo.validate.isInRange(this.textbox.value, this.flags);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/InternetTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/InternetTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/InternetTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,78 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.InternetTextbox");
-dojo.require("dojo.widget.ValidationTextbox");
-dojo.require("dojo.validate.web");
-dojo.widget.defineWidget("dojo.widget.IpAddressTextbox", dojo.widget.ValidationTextbox, {mixInProperties:function (localProperties) {
-	dojo.widget.IpAddressTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.allowdotteddecimal) {
-		this.flags.allowDottedDecimal = (localProperties.allowdotteddecimal == "true");
-	}
-	if (localProperties.allowdottedhex) {
-		this.flags.allowDottedHex = (localProperties.allowdottedhex == "true");
-	}
-	if (localProperties.allowdottedoctal) {
-		this.flags.allowDottedOctal = (localProperties.allowdottedoctal == "true");
-	}
-	if (localProperties.allowdecimal) {
-		this.flags.allowDecimal = (localProperties.allowdecimal == "true");
-	}
-	if (localProperties.allowhex) {
-		this.flags.allowHex = (localProperties.allowhex == "true");
-	}
-	if (localProperties.allowipv6) {
-		this.flags.allowIPv6 = (localProperties.allowipv6 == "true");
-	}
-	if (localProperties.allowhybrid) {
-		this.flags.allowHybrid = (localProperties.allowhybrid == "true");
-	}
-}, isValid:function () {
-	return dojo.validate.isIpAddress(this.textbox.value, this.flags);
-}});
-dojo.widget.defineWidget("dojo.widget.UrlTextbox", dojo.widget.IpAddressTextbox, {mixInProperties:function (localProperties) {
-	dojo.widget.UrlTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.scheme) {
-		this.flags.scheme = (localProperties.scheme == "true");
-	}
-	if (localProperties.allowip) {
-		this.flags.allowIP = (localProperties.allowip == "true");
-	}
-	if (localProperties.allowlocal) {
-		this.flags.allowLocal = (localProperties.allowlocal == "true");
-	}
-	if (localProperties.allowcc) {
-		this.flags.allowCC = (localProperties.allowcc == "true");
-	}
-	if (localProperties.allowgeneric) {
-		this.flags.allowGeneric = (localProperties.allowgeneric == "true");
-	}
-}, isValid:function () {
-	return dojo.validate.isUrl(this.textbox.value, this.flags);
-}});
-dojo.widget.defineWidget("dojo.widget.EmailTextbox", dojo.widget.UrlTextbox, {mixInProperties:function (localProperties) {
-	dojo.widget.EmailTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.allowcruft) {
-		this.flags.allowCruft = (localProperties.allowcruft == "true");
-	}
-}, isValid:function () {
-	return dojo.validate.isEmailAddress(this.textbox.value, this.flags);
-}});
-dojo.widget.defineWidget("dojo.widget.EmailListTextbox", dojo.widget.EmailTextbox, {mixInProperties:function (localProperties) {
-	dojo.widget.EmailListTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.listseparator) {
-		this.flags.listSeparator = localProperties.listseparator;
-	}
-}, isValid:function () {
-	return dojo.validate.isEmailAddressList(this.textbox.value, this.flags);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/LayoutContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/LayoutContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/LayoutContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,27 +8,63 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+//
+// this widget provides Delphi-style panel layout semantics
+//
 
+dojo.provide("dojo.widget.LayoutContainer");
+dojo.provide("dojo.widget.html.LayoutContainer");
 
-dojo.provide("dojo.widget.LayoutContainer");
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.html.layout");
-dojo.widget.defineWidget("dojo.widget.LayoutContainer", dojo.widget.HtmlWidget, {isContainer:true, layoutChildPriority:"top-bottom", postCreate:function () {
-	dojo.widget.html.layout(this.domNode, this.children, this.layoutChildPriority);
-}, addChild:function (child, overrideContainerNode, pos, ref, insertIndex) {
-	dojo.widget.LayoutContainer.superclass.addChild.call(this, child, overrideContainerNode, pos, ref, insertIndex);
-	dojo.widget.html.layout(this.domNode, this.children, this.layoutChildPriority);
-}, removeChild:function (pane) {
-	dojo.widget.LayoutContainer.superclass.removeChild.call(this, pane);
-	dojo.widget.html.layout(this.domNode, this.children, this.layoutChildPriority);
-}, onResized:function () {
-	dojo.widget.html.layout(this.domNode, this.children, this.layoutChildPriority);
-}, show:function () {
-	this.domNode.style.display = "";
-	this.checkSize();
-	this.domNode.style.display = "none";
-	this.domNode.style.visibility = "";
-	dojo.widget.LayoutContainer.superclass.show.call(this);
-}});
-dojo.lang.extend(dojo.widget.Widget, {layoutAlign:"none"});
+dojo.require("dojo.html.layout");
 
+dojo.widget.html.LayoutContainer = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.LayoutContainer, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.LayoutContainer, {
+	widgetType: "LayoutContainer",
+	isContainer: true,
+
+	layoutChildPriority: 'top-bottom',
+
+	postCreate: function(){
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	addChild: function(child, overrideContainerNode, pos, ref, insertIndex){
+		dojo.widget.html.LayoutContainer.superclass.addChild.call(this, child, overrideContainerNode, pos, ref, insertIndex);
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	removeChild: function(pane){
+		dojo.widget.html.LayoutContainer.superclass.removeChild.call(this,pane);
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	onResized: function(){
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	show: function(){
+		// If this node was created while display=="none" then it
+		// hasn't been laid out yet.  Do that now.
+		this.domNode.style.display="";
+		this.checkSize();
+		this.domNode.style.display="none";
+		this.domNode.style.visibility="";
+
+		dojo.widget.html.LayoutContainer.superclass.show.call(this);
+	}
+});
+
+// This argument can be specified for the children of a LayoutContainer.
+// Since any widget can be specified as a LayoutContainer child, mix it
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	layoutAlign: 'none'
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:LayoutContainer");

Modified: tags/parley-0.53/root/static/magic/src/widget/LinkPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/LinkPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/LinkPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,16 +8,10 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.LinkPane");
+
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.ContentPane");
-dojo.require("dojo.html.style");
-dojo.widget.defineWidget("dojo.widget.LinkPane", dojo.widget.ContentPane, {templateString:"<div class=\"dojoLinkPane\"></div>", fillInTemplate:function (args, frag) {
-	var source = this.getFragNodeRef(frag);
-	this.label += source.innerHTML;
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-}});
+dojo.requireAfterIf("html", "dojo.widget.html.LinkPane");
+dojo.widget.tags.addParseTreeHandler("dojo:LinkPane");
 
+// NOTE: there's no stub file for this widget

Modified: tags/parley-0.53/root/static/magic/src/widget/Manager.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Manager.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Manager.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,258 +8,276 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Manager");
 dojo.require("dojo.lang.array");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.event.*");
-dojo.widget.manager = new function () {
+
+// Manager class
+dojo.widget.manager = new function(){
 	this.widgets = [];
 	this.widgetIds = [];
+	
+	// map of widgetId-->widget for widgets without parents (top level widgets)
 	this.topWidgets = {};
+
 	var widgetTypeCtr = {};
 	var renderPrefixCache = [];
+
 	this.getUniqueId = function (widgetType) {
-		var widgetId;
-		do {
-			widgetId = widgetType + "_" + (widgetTypeCtr[widgetType] != undefined ? ++widgetTypeCtr[widgetType] : widgetTypeCtr[widgetType] = 0);
-		} while (this.getWidgetById(widgetId));
-		return widgetId;
-	};
-	this.add = function (widget) {
+		return widgetType + "_" + (widgetTypeCtr[widgetType] != undefined ?
+			++widgetTypeCtr[widgetType] : widgetTypeCtr[widgetType] = 0);
+	}
+
+	this.add = function(widget){
+		dojo.profile.start("dojo.widget.manager.add");
 		this.widgets.push(widget);
-		if (!widget.extraArgs["id"]) {
+		// Opera9 uses ID (caps)
+		if(!widget.extraArgs["id"]){
 			widget.extraArgs["id"] = widget.extraArgs["ID"];
 		}
-		if (widget.widgetId == "") {
-			if (widget["id"]) {
+		// FIXME: the rest of this method is very slow!
+		if(widget.widgetId == ""){
+			if(widget["id"]){
 				widget.widgetId = widget["id"];
-			} else {
-				if (widget.extraArgs["id"]) {
-					widget.widgetId = widget.extraArgs["id"];
-				} else {
-					widget.widgetId = this.getUniqueId(widget.ns + "_" + widget.widgetType);
-				}
+			}else if(widget.extraArgs["id"]){
+				widget.widgetId = widget.extraArgs["id"];
+			}else{
+				widget.widgetId = this.getUniqueId(widget.widgetType);
 			}
 		}
-		if (this.widgetIds[widget.widgetId]) {
-			dojo.debug("widget ID collision on ID: " + widget.widgetId);
+		if(this.widgetIds[widget.widgetId]){
+			dojo.debug("widget ID collision on ID: "+widget.widgetId);
 		}
 		this.widgetIds[widget.widgetId] = widget;
-	};
-	this.destroyAll = function () {
-		for (var x = this.widgets.length - 1; x >= 0; x--) {
-			try {
+		// Widget.destroy already calls removeById(), so we don't need to
+		// connect() it here
+		dojo.profile.end("dojo.widget.manager.add");
+	}
+
+	this.destroyAll = function(){
+		for(var x=this.widgets.length-1; x>=0; x--){
+			try{
+				// this.widgets[x].destroyChildren();
 				this.widgets[x].destroy(true);
 				delete this.widgets[x];
-			}
-			catch (e) {
-			}
+			}catch(e){ }
 		}
-	};
-	this.remove = function (widgetIndex) {
-		if (dojo.lang.isNumber(widgetIndex)) {
-			var tw = this.widgets[widgetIndex].widgetId;
-			delete this.topWidgets[tw];
-			delete this.widgetIds[tw];
-			this.widgets.splice(widgetIndex, 1);
-		} else {
-			this.removeById(widgetIndex);
-		}
-	};
-	this.removeById = function (id) {
-		if (!dojo.lang.isString(id)) {
-			id = id["widgetId"];
-			if (!id) {
-				dojo.debug("invalid widget or id passed to removeById");
-				return;
-			}
-		}
-		for (var i = 0; i < this.widgets.length; i++) {
-			if (this.widgets[i].widgetId == id) {
+	}
+
+	// FIXME: we should never allow removal of the root widget until all others
+	// are removed!
+	this.remove = function(widgetIndex){
+		var tw = this.widgets[widgetIndex].widgetId;
+		delete this.widgetIds[tw];
+		this.widgets.splice(widgetIndex, 1);
+	}
+	
+	// FIXME: suboptimal performance
+	this.removeById = function(id) {
+		for (var i=0; i<this.widgets.length; i++){
+			if(this.widgets[i].widgetId == id){
 				this.remove(i);
 				break;
 			}
 		}
-	};
-	this.getWidgetById = function (id) {
-		if (dojo.lang.isString(id)) {
-			return this.widgetIds[id];
-		}
-		return id;
-	};
-	this.getWidgetsByType = function (type) {
+	}
+
+	this.getWidgetById = function(id){
+		return this.widgetIds[id];
+	}
+
+	this.getWidgetsByType = function(type){
 		var lt = type.toLowerCase();
-		var getType = (type.indexOf(":") < 0 ? function (x) {
-			return x.widgetType.toLowerCase();
-		} : function (x) {
-			return x.getNamespacedType();
-		});
 		var ret = [];
-		dojo.lang.forEach(this.widgets, function (x) {
-			if (getType(x) == lt) {
+		dojo.lang.forEach(this.widgets, function(x){
+			if(x.widgetType.toLowerCase() == lt){
 				ret.push(x);
 			}
 		});
 		return ret;
-	};
-	this.getWidgetsByFilter = function (unaryFunc, onlyOne) {
+	}
+
+	this.getWidgetsOfType = function (id) {
+		dojo.deprecated("getWidgetsOfType", "use getWidgetsByType", "0.4");
+		return dojo.widget.manager.getWidgetsByType(id);
+	}
+
+	this.getWidgetsByFilter = function(unaryFunc, onlyOne){
 		var ret = [];
-		dojo.lang.every(this.widgets, function (x) {
-			if (unaryFunc(x)) {
+		dojo.lang.every(this.widgets, function(x){
+			if(unaryFunc(x)){
 				ret.push(x);
-				if (onlyOne) {
-					return false;
-				}
+				if(onlyOne){return false;}
 			}
 			return true;
 		});
 		return (onlyOne ? ret[0] : ret);
-	};
-	this.getAllWidgets = function () {
+	}
+
+	this.getAllWidgets = function() {
 		return this.widgets.concat();
-	};
-	this.getWidgetByNode = function (node) {
-		var w = this.getAllWidgets();
-		node = dojo.byId(node);
-		for (var i = 0; i < w.length; i++) {
-			if (w[i].domNode == node) {
+	}
+
+	//	added, trt 2006-01-20
+	this.getWidgetByNode = function(/* DOMNode */ node){
+		var w=this.getAllWidgets();
+		for (var i=0; i<w.length; i++){
+			if (w[i].domNode==node){
 				return w[i];
 			}
 		}
 		return null;
-	};
+	}
+
+	// shortcuts, baby
 	this.byId = this.getWidgetById;
 	this.byType = this.getWidgetsByType;
 	this.byFilter = this.getWidgetsByFilter;
 	this.byNode = this.getWidgetByNode;
+
+	// map of previousally discovered implementation names to constructors
 	var knownWidgetImplementations = {};
+
+	// support manually registered widget packages
 	var widgetPackages = ["dojo.widget"];
-	for (var i = 0; i < widgetPackages.length; i++) {
+	for (var i=0; i<widgetPackages.length; i++) {
+		// convenience for checking if a package exists (reverse lookup)
 		widgetPackages[widgetPackages[i]] = true;
 	}
-	this.registerWidgetPackage = function (pname) {
-		if (!widgetPackages[pname]) {
+
+	this.registerWidgetPackage = function(pname) {
+		if(!widgetPackages[pname]){
 			widgetPackages[pname] = true;
 			widgetPackages.push(pname);
 		}
-	};
-	this.getWidgetPackageList = function () {
-		return dojo.lang.map(widgetPackages, function (elt) {
-			return (elt !== true ? elt : undefined);
-		});
-	};
-	this.getImplementation = function (widgetName, ctorObject, mixins, ns) {
-		var impl = this.getImplementationName(widgetName, ns);
-		if (impl) {
-			var ret = ctorObject ? new impl(ctorObject) : new impl();
+	}
+	
+	this.getWidgetPackageList = function() {
+		return dojo.lang.map(widgetPackages, function(elt) { return(elt!==true ? elt : undefined); });
+	}
+	
+	this.getImplementation = function(widgetName, ctorObject, mixins){
+		// try and find a name for the widget
+		var impl = this.getImplementationName(widgetName);
+		if(impl){ 
+			// var tic = new Date();
+			var ret = new impl(ctorObject);
+			// dojo.debug(new Date() - tic);
 			return ret;
 		}
-	};
-	function buildPrefixCache() {
-		for (var renderer in dojo.render) {
-			if (dojo.render[renderer]["capable"] === true) {
-				var prefixes = dojo.render[renderer].prefixes;
-				for (var i = 0; i < prefixes.length; i++) {
-					renderPrefixCache.push(prefixes[i].toLowerCase());
-				}
-			}
-		}
 	}
-	var findImplementationInModule = function (lowerCaseWidgetName, module) {
-		if (!module) {
-			return null;
-		}
-		for (var i = 0, l = renderPrefixCache.length, widgetModule; i <= l; i++) {
-			widgetModule = (i < l ? module[renderPrefixCache[i]] : module);
-			if (!widgetModule) {
-				continue;
-			}
-			for (var name in widgetModule) {
-				if (name.toLowerCase() == lowerCaseWidgetName) {
-					return widgetModule[name];
-				}
-			}
-		}
-		return null;
-	};
-	var findImplementation = function (lowerCaseWidgetName, moduleName) {
-		var module = dojo.evalObjPath(moduleName, false);
-		return (module ? findImplementationInModule(lowerCaseWidgetName, module) : null);
-	};
-	this.getImplementationName = function (widgetName, ns) {
+
+	this.getImplementationName = function(widgetName){
+		/*
+		 * This is the overly-simplistic implemention of getImplementation (har
+		 * har). In the future, we are going to want something that allows more
+		 * freedom of expression WRT to specifying different specializations of
+		 * a widget.
+		 *
+		 * Additionally, this implementation treats widget names as case
+		 * insensitive, which does not necessarialy mesh with the markup which
+		 * can construct a widget.
+		 */
+
 		var lowerCaseWidgetName = widgetName.toLowerCase();
-		ns = ns || "dojo";
-		var imps = knownWidgetImplementations[ns] || (knownWidgetImplementations[ns] = {});
-		var impl = imps[lowerCaseWidgetName];
-		if (impl) {
+
+		var impl = knownWidgetImplementations[lowerCaseWidgetName];
+		if(impl){
 			return impl;
 		}
-		if (!renderPrefixCache.length) {
-			buildPrefixCache();
-		}
-		var nsObj = dojo.ns.get(ns);
-		if (!nsObj) {
-			dojo.ns.register(ns, ns + ".widget");
-			nsObj = dojo.ns.get(ns);
-		}
-		if (nsObj) {
-			nsObj.resolve(widgetName);
-		}
-		impl = findImplementation(lowerCaseWidgetName, nsObj.module);
-		if (impl) {
-			return (imps[lowerCaseWidgetName] = impl);
-		}
-		nsObj = dojo.ns.require(ns);
-		if ((nsObj) && (nsObj.resolver)) {
-			nsObj.resolve(widgetName);
-			impl = findImplementation(lowerCaseWidgetName, nsObj.module);
-			if (impl) {
-				return (imps[lowerCaseWidgetName] = impl);
+
+		// first store a list of the render prefixes we are capable of rendering
+		if(!renderPrefixCache.length){
+			for(var renderer in dojo.render){
+				if(dojo.render[renderer]["capable"] === true){
+					var prefixes = dojo.render[renderer].prefixes;
+					for(var i = 0; i < prefixes.length; i++){
+						renderPrefixCache.push(prefixes[i].toLowerCase());
+					}
+				}
 			}
+			// make sure we don't HAVE to prefix widget implementation names
+			// with anything to get them to render
+			renderPrefixCache.push("");
 		}
-		dojo.deprecated("dojo.widget.Manager.getImplementationName", "Could not locate widget implementation for \"" + widgetName + "\" in \"" + nsObj.module + "\" registered to namespace \"" + nsObj.name + "\". " + "Developers must specify correct namespaces for all non-Dojo widgets", "0.5");
-		for (var i = 0; i < widgetPackages.length; i++) {
-			impl = findImplementation(lowerCaseWidgetName, widgetPackages[i]);
-			if (impl) {
-				return (imps[lowerCaseWidgetName] = impl);
+
+		// look for a rendering-context specific version of our widget name
+		for(var i = 0; i < widgetPackages.length; i++){
+			var widgetPackage = dojo.evalObjPath(widgetPackages[i]);
+			if(!widgetPackage) { continue; }
+
+			for (var j = 0; j < renderPrefixCache.length; j++) {
+				if (!widgetPackage[renderPrefixCache[j]]) { continue; }
+				for (var widgetClass in widgetPackage[renderPrefixCache[j]]) {
+					if (widgetClass.toLowerCase() != lowerCaseWidgetName) { continue; }
+					knownWidgetImplementations[lowerCaseWidgetName] =
+						widgetPackage[renderPrefixCache[j]][widgetClass];
+					return knownWidgetImplementations[lowerCaseWidgetName];
+				}
 			}
+
+			for (var j = 0; j < renderPrefixCache.length; j++) {
+				for (var widgetClass in widgetPackage) {
+					if (widgetClass.toLowerCase() !=
+						(renderPrefixCache[j] + lowerCaseWidgetName)) { continue; }
+	
+					knownWidgetImplementations[lowerCaseWidgetName] =
+						widgetPackage[widgetClass];
+					return knownWidgetImplementations[lowerCaseWidgetName];
+				}
+			}
 		}
-		throw new Error("Could not locate widget implementation for \"" + widgetName + "\" in \"" + nsObj.module + "\" registered to namespace \"" + nsObj.name + "\"");
-	};
-	this.resizing = false;
-	this.onWindowResized = function () {
-		if (this.resizing) {
-			return;
+		
+		throw new Error('Could not locate "' + widgetName + '" class');
+	}
+
+	// FIXME: does it even belong in this name space?
+	// NOTE: this method is implemented by DomWidget.js since not all
+	// hostenv's would have an implementation.
+	/*this.getWidgetFromPrimitive = function(baseRenderType){
+		dojo.unimplemented("dojo.widget.manager.getWidgetFromPrimitive");
+	}
+
+	this.getWidgetFromEvent = function(nativeEvt){
+		dojo.unimplemented("dojo.widget.manager.getWidgetFromEvent");
+	}*/
+
+	// Catch window resize events and notify top level widgets
+	this.resizing=false;
+	this.onWindowResized = function(){
+		if(this.resizing){
+			return;	// duplicate event
 		}
-		try {
-			this.resizing = true;
-			for (var id in this.topWidgets) {
+		try{
+			this.resizing=true;
+			for(var id in this.topWidgets){
 				var child = this.topWidgets[id];
-				if (child.checkSize) {
+				if(child.checkSize ){
 					child.checkSize();
 				}
-			}
+			};
+		}catch(e){
+		}finally{
+			this.resizing=false;
 		}
-		catch (e) {
-		}
-		finally {
-			this.resizing = false;
-		}
-	};
-	if (typeof window != "undefined") {
-		dojo.addOnLoad(this, "onWindowResized");
-		dojo.event.connect(window, "onresize", this, "onWindowResized");
 	}
+	if(typeof window != "undefined") {
+		dojo.addOnLoad(this, 'onWindowResized');							// initial sizing
+		dojo.event.connect(window, 'onresize', this, 'onWindowResized');	// window resize
+	}
+
+	// FIXME: what else?
 };
-(function () {
+
+(function(){
 	var dw = dojo.widget;
 	var dwm = dw.manager;
 	var h = dojo.lang.curry(dojo.lang, "hitch", dwm);
-	var g = function (oldName, newName) {
-		dw[(newName || oldName)] = h(oldName);
-	};
+	var g = function(oldName, newName){
+		dw[(newName||oldName)] = h(oldName);
+	}
+	// copy the methods from the default manager (this) to the widget namespace
 	g("add", "addWidget");
 	g("destroyAll", "destroyAllWidgets");
 	g("remove", "removeWidget");
@@ -271,18 +289,18 @@
 	g("getWidgetsByType", "byType");
 	g("getWidgetsByFilter", "byFilter");
 	g("getWidgetByNode", "byNode");
-	dw.all = function (n) {
+	dw.all = function(n){
 		var widgets = dwm.getAllWidgets.apply(dwm, arguments);
-		if (arguments.length > 0) {
+		if(arguments.length > 0) {
 			return widgets[n];
 		}
 		return widgets;
-	};
+	}
 	g("registerWidgetPackage");
 	g("getImplementation", "getWidgetImplementation");
 	g("getImplementationName", "getWidgetImplementationName");
+
 	dw.widgets = dwm.widgets;
 	dw.widgetIds = dwm.widgetIds;
 	dw.root = dwm.root;
 })();
-

Added: tags/parley-0.53/root/static/magic/src/widget/Menu.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Menu.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Menu.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,59 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.Menu");
+dojo.provide("dojo.widget.DomMenu");
+
+dojo.deprecated("dojo.widget.Menu, dojo.widget.DomMenu",  "use dojo.widget.Menu2", "0.4");
+
+dojo.require("dojo.widget.*");
+
+dojo.widget.tags.addParseTreeHandler("dojo:menu");
+
+/* Menu
+ *******/
+
+dojo.widget.Menu = function () {
+	dojo.widget.Menu.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.Menu, dojo.widget.Widget);
+
+dojo.lang.extend(dojo.widget.Menu, {
+	widgetType: "Menu",
+	isContainer: true,
+	
+	items: [],
+	push: function(item){
+		dojo.connect.event(item, "onSelect", this, "onSelect");
+		this.items.push(item);
+	},
+	onSelect: function(){}
+});
+
+
+/* DomMenu
+ **********/
+
+dojo.widget.DomMenu = function(){
+	dojo.widget.DomMenu.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.DomMenu, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.DomMenu, {
+	widgetType: "Menu",
+	isContainer: true,
+
+	push: function (item) {
+		dojo.widget.Menu.call(this, item);
+		this.domNode.appendChild(item.domNode);
+	}
+});
+
+dojo.requireAfterIf("html", "dojo.widget.html.Menu");

Modified: tags/parley-0.53/root/static/magic/src/widget/Menu2.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Menu2.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Menu2.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,448 +8,1183 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.Menu2");
+dojo.provide("dojo.widget.html.Menu2");
+dojo.provide("dojo.widget.PopupMenu2");
+dojo.provide("dojo.widget.MenuItem2");
+dojo.provide("dojo.widget.MenuBar2");
 
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.event.*");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
 
-dojo.provide("dojo.widget.Menu2");
-dojo.require("dojo.widget.PopupContainer");
-dojo.declare("dojo.widget.MenuBase", null, function () {
-	this.eventNames = {open:""};
-}, {isContainer:true, isMenu:true, eventNaming:"default", templateCssString:"\n.dojoPopupMenu2 {\n\tposition: absolute;\n\tborder: 1px solid #7298d0;\n\tbackground:#85aeec url(images/soriaMenuBg.gif) repeat-x bottom left !important;\n\tpadding: 1px;\n\tmargin-top: 1px;\n\tmargin-bottom: 1px;\n}\n\n.dojoMenuItem2{\n\twhite-space: nowrap;\n\tfont: menu;\n\tmargin: 0;\n}\n\n.dojoMenuItem2Hover {\n\tbackground-color: #D2E4FD;\n\tcursor:pointer;\n\tcursor:hand;\n}\n\n.dojoMenuItem2Icon {\n\tposition: relative;\n\tbackground-position: center center;\n\tbackground-repeat: no-repeat;\n\twidth: 16px;\n\theight: 16px;\n\tpadding-right: 3px;\n}\n\n.dojoMenuItem2Label {\n\tposition: relative;\n\tvertical-align: middle;\n}\n\n/* main label text */\n.dojoMenuItem2Label {\n\tposition: relative;\n\tvertical-align: middle;\n}\n\n.dojoMenuItem2Accel {\n\tposition: relative;\n\tvertical-align: middle;\n\tpadding-left: 3px;\n}\n\n.dojoMenuItem2Disabled .dojoMenuItem2Label,\n.dojoMenuItem2Disab!
 led .dojoMenuItem2Accel {\n\tcolor: #607a9e;\n}\n\n.dojoMenuItem2Submenu {\n\tposition: relative;\n\tbackground-position: center center;\n\tbackground-repeat: no-repeat;\n\tbackground-image: url(images/submenu_off.gif);\n\twidth: 5px;\n\theight: 9px;\n\tpadding-left: 3px;\n}\n.dojoMenuItem2Hover .dojoMenuItem2Submenu {\n\tbackground-image: url(images/submenu_on.gif);\n}\n\n.dojoMenuItem2Disabled .dojoMenuItem2Submenu {\n\tbackground-image: url(images/submenu_disabled.gif);\n}\n\n.dojoMenuSeparator2 {\n\tfont-size: 1px;\n\tmargin: 0;\n}\n\n.dojoMenuSeparator2Top {\n\theight: 50%;\n\tborder-bottom: 1px solid #7a98c4;\n\tmargin: 0px 2px;\n\tfont-size: 1px;\n}\n\n.dojoMenuSeparator2Bottom {\n\theight: 50%;\n\tborder-top: 1px solid #c9deff;\n\tmargin: 0px 2px;\n\tfont-size: 1px;\n}\n\n.dojoMenuBar2 {\n\tbackground:#85aeec url(images/soriaBarBg.gif) repeat-x top left;\n\t/*border-bottom:1px solid #6b9fec;*/\n\tpadding: 1px;\n}\n\n.dojoMenuBar2 .dojoMenuItem2 {\n\twhite-space: now!
 rap;\n\tfont: menu;\n\tmargin: 0;\n\tposition: relative;\n\tve!
 rtical-a
lign: middle;\n\tz-index: 1;\n\tpadding: 3px 8px;\n\tdisplay: inline;/* needed in khtml to display correctly */\n\tdisplay: -moz-inline-box;/* needed in firefox */\n\tcursor:pointer;\n\tcursor:hand;\n}\n\n.dojoMenuBar2 .dojoMenuItem2Hover {\n\tbackground-color:#d2e4fd;\n}\n\n.dojoMenuBar2 .dojoMenuItem2Disabled span {\n\tcolor: #4f6582;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Menu2.css"), submenuDelay:500, initialize:function (args, frag) {
-	if (this.eventNaming == "default") {
-		for (var eventName in this.eventNames) {
-			this.eventNames[eventName] = this.widgetId + "/" + eventName;
+
+dojo.widget.PopupMenu2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+	this.items = [];	// unused???
+	this.targetNodeIds = []; // fill this with nodeIds upon widget creation and it becomes context menu for those nodes
+	this.queueOnAnimationFinish = [];
+
+	this.eventNames =  {
+		open: ""
+	};
+
+}
+
+dojo.inherits(dojo.widget.PopupMenu2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.PopupMenu2, {
+	widgetType: "PopupMenu2",
+	isContainer: true,
+
+	snarfChildDomOutput: true,
+
+	currentSubmenu: null,
+	currentSubmenuTrigger: null,
+	parentMenu: null,
+	parentMenuBar: null,
+	isShowingNow: false,
+	menuX: 0,
+	menuY: 0,
+	menuWidth: 0,
+	menuHeight: 0,
+	menuIndex: 0,
+
+	domNode: null,
+	containerNode: null,
+
+	eventNaming: "default",
+
+
+	templateString: '<div class="dojoPopupMenu2" style="left:-9999px; top:-9999px; display: none;"><div dojoAttachPoint="containerNode" class="dojoPopupMenu2Client"></div></div>',
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlMenu2.css"),
+
+	itemHeight: 18,
+	iconGap: 1,
+	accelGap: 10,
+	submenuGap: 2,
+	finalGap: 5,
+	submenuIconSize: 4,
+	separatorHeight: 9,
+	submenuDelay: 500,
+	submenuOverlap: 5,
+	contextMenuForWindow: false,
+	openEvent: null,
+
+	submenuIconSrc: dojo.uri.dojoUri("src/widget/templates/images/submenu_off.gif").toString(),
+	submenuIconOnSrc: dojo.uri.dojoUri("src/widget/templates/images/submenu_on.gif").toString(),
+
+	initialize: function(args, frag) {
+
+		if (this.eventNaming == "default") {
+			for (var eventName in this.eventNames) {
+				this.eventNames[eventName] = this.widgetId+"/"+eventName;
+			}
 		}
-	}
-}, _moveToNext:function (evt) {
-	this._highlightOption(1);
-	return true;
-}, _moveToPrevious:function (evt) {
-	this._highlightOption(-1);
-	return true;
-}, _moveToParentMenu:function (evt) {
-	if (this._highlighted_option && this.parentMenu) {
-		if (evt._menu2UpKeyProcessed) {
-			return true;
-		} else {
-			this._highlighted_option.onUnhover();
-			this.closeSubmenu();
-			evt._menu2UpKeyProcessed = true;
+
+	},
+
+	postCreate: function(){
+		if (this.domNode.style.display=="none"){
+			this.domNode.style.display = "";
 		}
-	}
-	return false;
-}, _moveToChildMenu:function (evt) {
-	if (this._highlighted_option && this._highlighted_option.submenuId) {
-		this._highlighted_option._onClick(true);
-		return true;
-	}
-	return false;
-}, _selectCurrentItem:function (evt) {
-	if (this._highlighted_option) {
-		this._highlighted_option._onClick();
-		return true;
-	}
-	return false;
-}, processKey:function (evt) {
-	if (evt.ctrlKey || evt.altKey || !evt.key) {
-		return false;
-	}
-	var rval = false;
-	switch (evt.key) {
-	  case evt.KEY_DOWN_ARROW:
-		rval = this._moveToNext(evt);
-		break;
-	  case evt.KEY_UP_ARROW:
-		rval = this._moveToPrevious(evt);
-		break;
-	  case evt.KEY_RIGHT_ARROW:
-		rval = this._moveToChildMenu(evt);
-		break;
-	  case evt.KEY_LEFT_ARROW:
-		rval = this._moveToParentMenu(evt);
-		break;
-	  case " ":
-	  case evt.KEY_ENTER:
-		if (rval = this._selectCurrentItem(evt)) {
-			break;
+		this.domNode.style.left = '-9999px'
+		this.domNode.style.top = '-9999px'
+
+		// attach menu to document body if it's not already there
+		if (this.domNode.parentNode != document.body){
+			document.body.appendChild(this.domNode);
 		}
-	  case evt.KEY_ESCAPE:
-	  case evt.KEY_TAB:
-		this.close(true);
-		rval = true;
-		break;
-	}
-	return rval;
-}, _findValidItem:function (dir, curItem) {
-	if (curItem) {
-		curItem = dir > 0 ? curItem.getNextSibling() : curItem.getPreviousSibling();
-	}
-	for (var i = 0; i < this.children.length; ++i) {
-		if (!curItem) {
-			curItem = dir > 0 ? this.children[0] : this.children[this.children.length - 1];
+
+
+		if (this.contextMenuForWindow){
+			var doc = document.documentElement  || document.body;
+			dojo.widget.Menu2.OperaAndKonqFixer.fixNode(doc);
+			dojo.event.connect(doc, "oncontextmenu", this, "onOpen");
+		} else if ( this.targetNodeIds.length > 0 ){
+			for(var i=0; i<this.targetNodeIds.length; i++){
+				this.bindDomNode(this.targetNodeIds[i]);
+			}
 		}
-		if (curItem.onHover && curItem.isShowing()) {
-			return curItem;
+
+		this.subscribeSubitemsOnOpen();
+
+		this.layoutMenuSoon();
+	},
+
+	subscribeSubitemsOnOpen: function() {
+		var subItems = this.getChildrenOfType(dojo.widget.MenuItem2);
+
+		//dojo.debug(subItems)
+
+		for(var i=0; i<subItems.length; i++) {
+			//dojo.debug(subItems[i]);
+			dojo.event.topic.subscribe(this.eventNames.open, subItems[i], "menuOpen")
 		}
-		curItem = dir > 0 ? curItem.getNextSibling() : curItem.getPreviousSibling();
-	}
-}, _highlightOption:function (dir) {
-	var item;
-	if ((!this._highlighted_option)) {
-		item = this._findValidItem(dir);
-	} else {
-		item = this._findValidItem(dir, this._highlighted_option);
-	}
-	if (item) {
-		if (this._highlighted_option) {
-			this._highlighted_option.onUnhover();
+	},
+
+	// get open event for current menu
+	getTopOpenEvent: function() {
+		var menu = this;
+		while (menu.parent){ menu = menu.parent; }
+		return menu.openEvent;
+	},
+
+	// attach menu to given node
+	bindDomNode: function(nodeName){
+		var node = dojo.byId(nodeName);
+
+		// fixes node so that it supports oncontextmenu if not natively supported, Konqueror, Opera more?
+		dojo.widget.Menu2.OperaAndKonqFixer.fixNode(node);
+
+		dojo.event.kwConnect({
+			srcObj:     node,
+			srcFunc:    "oncontextmenu",
+			targetObj:  this,
+			targetFunc: "onOpen",
+			once:       true
+		});
+	},
+
+	// detach menu from given node
+	unBindDomNode: function(nodeName){
+		var node = dojo.byId(nodeName);
+		dojo.event.kwDisconnect({
+			srcObj:     node,
+			srcFunc:    "oncontextmenu",
+			targetObj:  this,
+			targetFunc: "onOpen",
+			once:       true
+		});
+
+		// cleans a fixed node, konqueror and opera
+		dojo.widget.Menu2.OperaAndKonqFixer.cleanNode(node);
+	},
+
+	layoutMenuSoon: function(){
+		dojo.lang.setTimeout(this, "layoutMenu", 0);
+	},
+
+	layoutMenu: function(){
+
+        // menu must be attached to DOM for size calculations to work
+		// even though we attached to document.body in postCreate(), here
+		// we seem to be attached to a #document-fragment.  Don't understand why.
+        document.body.appendChild(this.domNode);
+
+        // determine menu width
+		var max_label_w = 0;
+		var max_accel_w = 0;
+
+		for(var i=0; i<this.children.length; i++){
+			if (this.children[i].getLabelWidth){
+				max_label_w = Math.max(max_label_w, this.children[i].getLabelWidth());
+			}
+
+			if (dojo.lang.isFunction(this.children[i].getAccelWidth)){
+				max_accel_w = Math.max(max_accel_w, this.children[i].getAccelWidth());
+			}
 		}
-		item.onHover();
-		dojo.html.scrollIntoView(item.domNode);
-		try {
-			var node = dojo.html.getElementsByClass("dojoMenuItem2Label", item.domNode)[0];
-			node.focus();
+
+		if( isNaN(max_label_w) || isNaN(max_accel_w) ){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
 		}
-		catch (e) {
+
+		var clientLeft = dojo.style.getPixelValue(this.domNode, "padding-left", true) + dojo.style.getPixelValue(this.containerNode, "padding-left", true);
+		var clientTop  = dojo.style.getPixelValue(this.domNode, "padding-top", true)  + dojo.style.getPixelValue(this.containerNode, "padding-top", true);
+
+		if( isNaN(clientLeft) || isNaN(clientTop) ){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
 		}
+
+		var y = clientTop;
+		var max_item_width = 0;
+
+		for(var i=0; i<this.children.length; i++){
+
+			var ch = this.children[i];
+
+			ch.layoutItem(max_label_w, max_accel_w);
+
+			ch.topPosition = y;
+
+			y += dojo.style.getOuterHeight(ch.domNode);
+			max_item_width = Math.max(max_item_width, dojo.style.getOuterWidth(ch.domNode));
+		}
+
+		dojo.style.setContentWidth(this.containerNode, max_item_width);
+		dojo.style.setContentHeight(this.containerNode, y-clientTop);
+
+		dojo.style.setContentWidth(this.domNode, dojo.style.getOuterWidth(this.containerNode));
+		dojo.style.setContentHeight(this.domNode, dojo.style.getOuterHeight(this.containerNode));
+
+		this.menuWidth = dojo.style.getOuterWidth(this.domNode);
+		this.menuHeight = dojo.style.getOuterHeight(this.domNode);
+	},
+
+	/**
+	 * Open the menu at position (x,y), relative to the viewport
+	 * (usually positions are relative to the document; why is this different??)
+	 */
+	open: function(x, y, parent, explodeSrc){
+
+		// if explodeSrc isn't specified then explode from my parent widget
+		explodeSrc = explodeSrc || parent["domNode"] || [];
+
+		if (this.isShowingNow){ return; }
+
+		var parentMenu = (parent && parent.widgetType=="PopupMenu2") ? parent : null;
+
+		if ( !parentMenu ) {
+			// record whenever a top level menu is opened
+			// explodeSrc may or may not be a node - it may also be an [x,y] position array
+			var button = explodeSrc instanceof Array ? null : explodeSrc;
+			dojo.widget.html.Menu2Manager.opened(this, button);
+		}
+
+		//dojo.debug("open called for animation "+this.animationInProgress)
+
+		// if I click  right button and menu is opened, then it gets 2 commands: close -> open
+		// so close enables animation and next "open" is put to queue to occur at new location
+		if(this.animationInProgress){
+			this.queueOnAnimationFinish.push(this.open, arguments);
+			return;
+		}
+
+		var viewport = dojo.html.getViewportSize();
+		var scrolloffset = dojo.html.getScrollOffset();
+
+		var clientRect = {
+			'left'  : scrolloffset[0],
+			'right' : scrolloffset[0] + viewport[0],
+			'top'   : scrolloffset[1],
+			'bottom': scrolloffset[1] + viewport[1]
+		};
+
+		if (parentMenu){
+			// submenu is opening
+
+			if (x + this.menuWidth > clientRect.right){ x = x - (this.menuWidth + parentMenu.menuWidth - (2 * this.submenuOverlap)); }
+
+			if (y + this.menuHeight > clientRect.bottom){ y = y -
+			(this.menuHeight - (this.itemHeight + 5)); } // TODO: why 5?
+
+		}else{
+			// top level menu is opening
+			x+=scrolloffset[0];
+			y+=scrolloffset[1];
+			explodeSrc[0] += scrolloffset[0];
+			explodeSrc[1] += scrolloffset[1];
+
+			if (x < clientRect.left){ x = clientRect.left; }
+			if (x + this.menuWidth > clientRect.right){ x = x - this.menuWidth; }
+
+			if (y < clientRect.top){ y = clientRect.top; }
+			if (y + this.menuHeight > clientRect.bottom){ y = y - this.menuHeight; }
+		}
+
+		this.parentMenu = parentMenu;
+		this.explodeSrc = explodeSrc;
+		this.menuIndex = parentMenu ? parentMenu.menuIndex + 1 : 1;
+
+		this.menuX = x;
+		this.menuY = y;
+
+		// move the menu into position but make it invisible
+		// (because when menus are initially constructed they are visible but off-screen)
+		this.domNode.style.zIndex = 200 + this.menuIndex;
+		this.domNode.style.left = x + 'px';
+		this.domNode.style.top = y + 'px';
+		this.domNode.style.display='none';
+		this.domNode.style.position='absolute';
+
+		// then use the user defined method to display it
+		this.show();
+
+		this.isShowingNow = true;
+	},
+
+	close: function(){
+		// If we are in the process of opening the menu and we are asked to close it,
+		// we should really cancel the current animation, but for simplicity we will
+		// just ignore the request
+		if(this.animationInProgress){
+			this.queueOnAnimationFinish.push(this.close, []);
+			return;
+		}
+
+		this.closeSubmenu();
+		this.hide();
+		this.isShowingNow = false;
+		dojo.widget.html.Menu2Manager.closed(this);
+
+		if (this.parentMenuBar){
+			this.parentMenuBar.closedMenu(this);
+		}
+	},
+
+	onShow: function() {
+		dojo.widget.HtmlWidget.prototype.onShow.call(this);
+		this.processQueue();
+	},
+
+	// do events from queue
+	processQueue: function() {
+		if (!this.queueOnAnimationFinish.length) return;
+
+		var func = this.queueOnAnimationFinish.shift();
+		var args = this.queueOnAnimationFinish.shift();
+
+		func.apply(this, args);
+	},
+
+	onHide: function() {
+		dojo.widget.HtmlWidget.prototype.onHide.call(this);
+
+		this.processQueue();
+	},
+
+
+	closeAll: function(){
+		if (this.parentMenu){
+			this.parentMenu.closeAll();
+		}else{
+			this.close();
+		}
+	},
+
+	closeSubmenu: function(){
+		if (this.currentSubmenu == null){ return; }
+
+		this.currentSubmenu.close();
+		this.currentSubmenu = null;
+
+		this.currentSubmenuTrigger.is_open = false;
+		this.currentSubmenuTrigger.closedSubmenu();
+		this.currentSubmenuTrigger = null;
+	},
+
+	openSubmenu: function(submenu, from_item){
+
+		var our_x = dojo.style.getPixelValue(this.domNode, 'left');
+		var our_y = dojo.style.getPixelValue(this.domNode, 'top');
+		var our_w = dojo.style.getOuterWidth(this.domNode);
+		var item_y = from_item.topPosition;
+
+		var x = our_x + our_w - this.submenuOverlap;
+		var y = our_y + item_y;
+
+		this.currentSubmenu = submenu;
+		this.currentSubmenu.open(x, y, this, from_item.domNode);
+
+		this.currentSubmenuTrigger = from_item;
+		this.currentSubmenuTrigger.is_open = true;
+	},
+
+	onOpen: function(e){
+		this.openEvent = e;
+
+		//dojo.debugShallow(e);
+		this.open(e.clientX, e.clientY, null, [e.clientX, e.clientY]);
+
+		if(e["preventDefault"]){
+			e.preventDefault();
+		}
+	},
+
+	isPointInMenu: function(x, y){
+
+		if (x < this.menuX){ return false; }
+		if (x > this.menuX + this.menuWidth){ return false; }
+
+		if (y < this.menuY){ return false; }
+		if (y > this.menuY + this.menuHeight){ return false; }
+
+		return true;
 	}
-}, onItemClick:function (item) {
-}, closeSubmenu:function (force) {
-	if (this.currentSubmenu == null) {
-		return;
-	}
-	this.currentSubmenu.close(force);
-	this.currentSubmenu = null;
-	this.currentSubmenuTrigger.is_open = false;
-	this.currentSubmenuTrigger._closedSubmenu(force);
-	this.currentSubmenuTrigger = null;
-}});
-dojo.widget.defineWidget("dojo.widget.PopupMenu2", [dojo.widget.HtmlWidget, dojo.widget.PopupContainerBase, dojo.widget.MenuBase], function () {
-	this.targetNodeIds = [];
-}, {templateString:"<table class=\"dojoPopupMenu2\" border=0 cellspacing=0 cellpadding=0 style=\"display: none; position: absolute;\">" + "<tbody dojoAttachPoint=\"containerNode\"></tbody>" + "</table>", submenuOverlap:5, contextMenuForWindow:false, parentMenu:null, postCreate:function () {
-	if (this.contextMenuForWindow) {
-		var doc = dojo.body();
-		this.bindDomNode(doc);
-	} else {
-		if (this.targetNodeIds.length > 0) {
-			dojo.lang.forEach(this.targetNodeIds, this.bindDomNode, this);
+});
+
+
+dojo.widget.MenuItem2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+
+	this.eventNames = {
+		engage: ""
+	};
+}
+
+dojo.inherits(dojo.widget.MenuItem2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuItem2, {
+	widgetType: "MenuItem2",
+	templateString:
+			 '<div class="dojoMenuItem2">'
+			+'<div dojoAttachPoint="iconNode" class="dojoMenuItem2Icon"></div>'
+			+'<span dojoAttachPoint="labelNode" class="dojoMenuItem2Label"><span><span></span></span></span>'
+			+'<span dojoAttachPoint="accelNode" class="dojoMenuItem2Accel"><span><span></span></span></span>'
+			+'<div dojoAttachPoint="submenuNode" class="dojoMenuItem2Submenu"></div>'
+			+'<div dojoAttachPoint="targetNode" class="dojoMenuItem2Target" dojoAttachEvent="onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;">&nbsp;</div>'
+			+'</div>',
+
+	//
+	// nodes
+	//
+
+	domNode: null,
+	iconNode: null,
+	labelNode: null,
+	accelNode: null,
+	submenuNode: null,
+	targetNode: null,
+
+	//
+	// internal settings
+	//
+
+	is_hovering: false,
+	hover_timer: null,
+	is_open: false,
+	topPosition: 0,
+
+	//
+	// options
+	//
+
+	caption: 'Untitled',
+	accelKey: '',
+	iconSrc: '',
+	submenuId: '',
+	disabled: false,
+	eventNaming: "default",
+
+
+	postCreate: function(){
+
+		dojo.html.disableSelection(this.domNode);
+
+		if (this.disabled){
+			this.setDisabled(true);
 		}
-	}
-	this._subscribeSubitemsOnOpen();
-}, _subscribeSubitemsOnOpen:function () {
-	var subItems = this.getChildrenOfType(dojo.widget.MenuItem2);
-	for (var i = 0; i < subItems.length; i++) {
-		dojo.event.topic.subscribe(this.eventNames.open, subItems[i], "menuOpen");
-	}
-}, getTopOpenEvent:function () {
-	var menu = this;
-	while (menu.parentMenu) {
-		menu = menu.parentMenu;
-	}
-	return menu.openEvent;
-}, bindDomNode:function (node) {
-	node = dojo.byId(node);
-	var win = dojo.html.getElementWindow(node);
-	if (dojo.html.isTag(node, "iframe") == "iframe") {
-		win = dojo.html.iframeContentWindow(node);
-		node = dojo.withGlobal(win, dojo.body);
-	}
-	dojo.widget.Menu2.OperaAndKonqFixer.fixNode(node);
-	dojo.event.kwConnect({srcObj:node, srcFunc:"oncontextmenu", targetObj:this, targetFunc:"onOpen", once:true});
-	if (dojo.render.html.moz && win.document.designMode.toLowerCase() == "on") {
-		dojo.event.browser.addListener(node, "contextmenu", dojo.lang.hitch(this, "onOpen"));
-	}
-	dojo.widget.PopupManager.registerWin(win);
-}, unBindDomNode:function (nodeName) {
-	var node = dojo.byId(nodeName);
-	dojo.event.kwDisconnect({srcObj:node, srcFunc:"oncontextmenu", targetObj:this, targetFunc:"onOpen", once:true});
-	dojo.widget.Menu2.OperaAndKonqFixer.cleanNode(node);
-}, _openAsSubmenu:function (parent, explodeSrc, orient) {
-	if (this.isShowingNow) {
-		return;
-	}
-	this.parentMenu = parent;
-	this.open(explodeSrc, parent, explodeSrc, orient);
-}, close:function (force) {
-	if (this.animationInProgress) {
-		dojo.widget.PopupContainerBase.prototype.close.call(this, force);
-		return;
-	}
-	if (this._highlighted_option) {
-		this._highlighted_option.onUnhover();
-	}
-	dojo.widget.PopupContainerBase.prototype.close.call(this, force);
-	this.parentMenu = null;
-}, closeAll:function (force) {
-	if (this.parentMenu) {
-		this.parentMenu.closeAll(force);
-	} else {
-		this.close(force);
-	}
-}, _openSubmenu:function (submenu, from_item) {
-	submenu._openAsSubmenu(this, from_item.arrow, {"TR":"TL", "TL":"TR"});
-	this.currentSubmenu = submenu;
-	this.currentSubmenuTrigger = from_item;
-	this.currentSubmenuTrigger.is_open = true;
-}, focus:function () {
-	if (this.currentSubmenuTrigger) {
-		if (this.currentSubmenuTrigger.caption) {
-			try {
-				this.currentSubmenuTrigger.caption.focus();
+
+		this.labelNode.childNodes[0].appendChild(document.createTextNode(this.caption));
+		this.accelNode.childNodes[0].appendChild(document.createTextNode(this.accelKey));
+
+		this.labelShadowNode = this.labelNode.childNodes[0].childNodes[0];
+		this.accelShadowNode = this.accelNode.childNodes[0].childNodes[0];
+
+		this.labelShadowNode.appendChild(document.createTextNode(this.caption));
+		this.accelShadowNode.appendChild(document.createTextNode(this.accelKey));
+
+		if (this.eventNaming == "default") {
+			for (var eventName in this.eventNames) {
+				this.eventNames[eventName] = this.widgetId+"/"+eventName;
 			}
-			catch (e) {
+		}
+	},
+
+	layoutItem: function(label_w, accel_w){
+
+		var x_label = this.parent.itemHeight + this.parent.iconGap;
+		var x_accel = x_label + label_w + this.parent.accelGap;
+		var x_submu = x_accel + accel_w + this.parent.submenuGap;
+		var total_w = x_submu + this.parent.submenuIconSize + this.parent.finalGap;
+
+
+		this.iconNode.style.left = '0px';
+		this.iconNode.style.top = '0px';
+
+
+		if (this.iconSrc){
+
+			if ((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4) == ".png") && (dojo.render.html.ie)){
+
+				this.iconNode.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='"+this.iconSrc+"', sizingMethod='image')";
+				this.iconNode.style.backgroundImage = '';
+			}else{
+				this.iconNode.style.backgroundImage = 'url('+this.iconSrc+')';
 			}
-		} else {
-			try {
-				this.currentSubmenuTrigger.domNode.focus();
+		}else{
+			this.iconNode.style.backgroundImage = '';
+		}
+
+		dojo.style.setOuterWidth(this.iconNode, this.parent.itemHeight);
+		dojo.style.setOuterHeight(this.iconNode, this.parent.itemHeight);
+
+		dojo.style.setOuterHeight(this.labelNode, this.parent.itemHeight);
+		dojo.style.setOuterHeight(this.accelNode, this.parent.itemHeight);
+
+		dojo.style.setContentWidth(this.domNode, total_w);
+		dojo.style.setContentHeight(this.domNode, this.parent.itemHeight);
+
+		this.labelNode.style.left = x_label + 'px';
+		this.accelNode.style.left = x_accel + 'px';
+		this.submenuNode.style.left = x_submu + 'px';
+
+		dojo.style.setOuterWidth(this.submenuNode, this.parent.submenuIconSize);
+		dojo.style.setOuterHeight(this.submenuNode, this.parent.itemHeight);
+
+		this.submenuNode.style.display = this.submenuId ? 'block' : 'none';
+		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconSrc+')';
+
+		dojo.style.setOuterWidth(this.targetNode, total_w);
+		dojo.style.setOuterHeight(this.targetNode, this.parent.itemHeight);
+	},
+
+	onHover: function(){
+
+		if (this.is_hovering){ return; }
+		if (this.is_open){ return; }
+
+		this.parent.closeSubmenu();
+		this.highlightItem();
+
+		if (this.is_hovering){ this.stopSubmenuTimer(); }
+		this.is_hovering = true;
+		this.startSubmenuTimer();
+	},
+
+	onUnhover: function(){
+		if (!this.is_open){ this.unhighlightItem(); }
+
+		this.is_hovering = false;
+		this.stopSubmenuTimer();
+	},
+
+	// Internal function for clicks
+	_onClick: function(){
+		if (this.disabled){ return; }
+
+		if (this.submenuId){
+			if (!this.is_open){
+				this.stopSubmenuTimer();
+				this.openSubmenu();
 			}
-			catch (e) {
-			}
+		}else{
+			this.parent.closeAll();
 		}
-	}
-}, onOpen:function (e) {
-	this.openEvent = e;
-	if (e["target"]) {
-		this.openedForWindow = dojo.html.getElementWindow(e.target);
-	} else {
-		this.openedForWindow = null;
-	}
-	var x = e.pageX, y = e.pageY;
-	var win = dojo.html.getElementWindow(e.target);
-	var iframe = win._frameElement || win.frameElement;
-	if (iframe) {
-		var cood = dojo.html.abs(iframe, true);
-		x += cood.x - dojo.withGlobal(win, dojo.html.getScroll).left;
-		y += cood.y - dojo.withGlobal(win, dojo.html.getScroll).top;
-	}
-	this.open(x, y, null, [x, y]);
-	dojo.event.browser.stopEvent(e);
-}});
-dojo.widget.defineWidget("dojo.widget.MenuItem2", dojo.widget.HtmlWidget, function () {
-	this.eventNames = {engage:""};
-}, {templateString:"<tr class=\"dojoMenuItem2\" dojoAttachEvent=\"onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick; onKey:onKey;\">" + "<td><div class=\"${this.iconClass}\" style=\"${this.iconStyle}\"></div></td>" + "<td tabIndex=\"-1\" class=\"dojoMenuItem2Label\" dojoAttachPoint=\"caption\">${this.caption}</td>" + "<td class=\"dojoMenuItem2Accel\">${this.accelKey}</td>" + "<td><div class=\"dojoMenuItem2Submenu\" style=\"display:${this.arrowDisplay};\" dojoAttachPoint=\"arrow\"></div></td>" + "</tr>", is_hovering:false, hover_timer:null, is_open:false, topPosition:0, caption:"Untitled", accelKey:"", iconSrc:"", disabledClass:"dojoMenuItem2Disabled", iconClass:"dojoMenuItem2Icon", submenuId:"", eventNaming:"default", highlightClass:"dojoMenuItem2Hover", postMixInProperties:function () {
-	this.iconStyle = "";
-	if (this.iconSrc) {
-		if ((this.iconSrc.toLowerCase().substring(this.iconSrc.length - 4) == ".png") && (dojo.render.html.ie55 || dojo.render.html.ie60)) {
-			this.iconStyle = "filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + this.iconSrc + "', sizingMethod='image')";
-		} else {
-			this.iconStyle = "background-image: url(" + this.iconSrc + ")";
+
+		// for some browsers the onMouseOut doesn't get called (?), so call it manually
+		this.onUnhover();
+
+		// user defined handler for click
+		this.onClick();
+
+		dojo.event.topic.publish(this.eventNames.engage, this);
+	},
+
+	// User defined function to handle clicks
+	onClick: function() { },
+
+	highlightItem: function(){
+		dojo.html.addClass(this.domNode, 'dojoMenuItem2Hover');
+		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconOnSrc+')';
+	},
+
+	unhighlightItem: function(){
+		dojo.html.removeClass(this.domNode, 'dojoMenuItem2Hover');
+		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconSrc+')';
+	},
+
+	startSubmenuTimer: function(){
+		this.stopSubmenuTimer();
+
+		if (this.disabled){ return; }
+
+		var self = this;
+		var closure = function(){ return function(){ self.openSubmenu(); } }();
+
+		this.hover_timer = window.setTimeout(closure, this.parent.submenuDelay);
+	},
+
+	stopSubmenuTimer: function(){
+		if (this.hover_timer){
+			window.clearTimeout(this.hover_timer);
+			this.hover_timer = null;
 		}
-	}
-	this.arrowDisplay = this.submenuId ? "block" : "none";
-	dojo.widget.MenuItem2.superclass.postMixInProperties.apply(this, arguments);
-}, fillInTemplate:function () {
-	dojo.html.disableSelection(this.domNode);
-	if (this.disabled) {
-		this.setDisabled(true);
-	}
-	if (this.eventNaming == "default") {
-		for (var eventName in this.eventNames) {
-			this.eventNames[eventName] = this.widgetId + "/" + eventName;
+	},
+
+	openSubmenu: function(){
+		// first close any other open submenu
+		this.parent.closeSubmenu();
+
+		var submenu = dojo.widget.getWidgetById(this.submenuId);
+		if (submenu){
+
+			this.parent.openSubmenu(submenu, this);
 		}
-	}
-}, onHover:function () {
-	this.onUnhover();
-	if (this.is_hovering) {
-		return;
-	}
-	if (this.is_open) {
-		return;
-	}
-	if (this.parent._highlighted_option) {
-		this.parent._highlighted_option.onUnhover();
-	}
-	this.parent.closeSubmenu();
-	this.parent._highlighted_option = this;
-	dojo.widget.PopupManager.setFocusedMenu(this.parent);
-	this._highlightItem();
-	if (this.is_hovering) {
-		this._stopSubmenuTimer();
-	}
-	this.is_hovering = true;
-	this._startSubmenuTimer();
-}, onUnhover:function () {
-	if (!this.is_open) {
-		this._unhighlightItem();
-	}
-	this.is_hovering = false;
-	this.parent._highlighted_option = null;
-	if (this.parent.parentMenu) {
-		dojo.widget.PopupManager.setFocusedMenu(this.parent.parentMenu);
-	}
-	this._stopSubmenuTimer();
-}, _onClick:function (focus) {
-	var displayingSubMenu = false;
-	if (this.disabled) {
-		return false;
-	}
-	if (this.submenuId) {
-		if (!this.is_open) {
-			this._stopSubmenuTimer();
-			this._openSubmenu();
+
+		//dojo.debug('open submenu for item '+this.widgetId);
+	},
+
+	closedSubmenu: function(){
+
+		this.onUnhover();
+	},
+
+	setDisabled: function(value){
+		this.disabled = value;
+
+		if (this.disabled){
+			dojo.html.addClass(this.domNode, 'dojoMenuItem2Disabled');
+		}else{
+			dojo.html.removeClass(this.domNode, 'dojoMenuItem2Disabled');
 		}
-		displayingSubMenu = true;
-	} else {
-		this.onUnhover();
-		this.parent.closeAll(true);
+	},
+
+	getLabelWidth: function(){
+
+		var node = this.labelNode.childNodes[0];
+
+		return dojo.style.getOuterWidth(node);
+	},
+
+	getAccelWidth: function(){
+
+		var node = this.accelNode.childNodes[0];
+
+		return dojo.style.getOuterWidth(node);
+	},
+
+	menuOpen: function(message) {
 	}
-	this.onClick();
-	dojo.event.topic.publish(this.eventNames.engage, this);
-	if (displayingSubMenu && focus) {
-		dojo.widget.getWidgetById(this.submenuId)._highlightOption(1);
+
+});
+
+
+dojo.widget.MenuSeparator2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.MenuSeparator2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuSeparator2, {
+	widgetType: "MenuSeparator2",
+
+	domNode: null,
+	topNode: null,
+	bottomNode: null,
+
+	templateString: '<div class="dojoMenuSeparator2">'
+			+'<div dojoAttachPoint="topNode" class="dojoMenuSeparator2Top"></div>'
+			+'<div dojoAttachPoint="bottomNode" class="dojoMenuSeparator2Bottom"></div>'
+			+'</div>',
+
+	postCreate: function(){
+		dojo.html.disableSelection(this.domNode);
+		this.layoutItem();
+	},
+
+	layoutItem: function(label_w, accel_w){
+
+		var full_width = this.parent.itemHeight
+				+ this.parent.iconGap
+				+ label_w
+				+ this.parent.accelGap
+				+ accel_w
+				+ this.parent.submenuGap
+				+ this.parent.submenuIconSize
+				+ this.parent.finalGap;
+
+		if (isNaN(full_width)){ return; }
+
+		dojo.style.setContentHeight(this.domNode, this.parent.separatorHeight);
+		dojo.style.setContentWidth(this.domNode, full_width);
 	}
-	return;
-}, onClick:function () {
-	this.parent.onItemClick(this);
-}, _highlightItem:function () {
-	dojo.html.addClass(this.domNode, this.highlightClass);
-}, _unhighlightItem:function () {
-	dojo.html.removeClass(this.domNode, this.highlightClass);
-}, _startSubmenuTimer:function () {
-	this._stopSubmenuTimer();
-	if (this.disabled) {
-		return;
-	}
-	var self = this;
-	var closure = function () {
-		return function () {
-			self._openSubmenu();
-		};
-	}();
-	this.hover_timer = dojo.lang.setTimeout(closure, this.parent.submenuDelay);
-}, _stopSubmenuTimer:function () {
-	if (this.hover_timer) {
-		dojo.lang.clearTimeout(this.hover_timer);
-		this.hover_timer = null;
-	}
-}, _openSubmenu:function () {
-	if (this.disabled) {
-		return;
-	}
-	this.parent.closeSubmenu();
-	var submenu = dojo.widget.getWidgetById(this.submenuId);
-	if (submenu) {
-		this.parent._openSubmenu(submenu, this);
-	}
-}, _closedSubmenu:function () {
-	this.onUnhover();
-}, setDisabled:function (value) {
-	this.disabled = value;
-	if (this.disabled) {
-		dojo.html.addClass(this.domNode, this.disabledClass);
-	} else {
-		dojo.html.removeClass(this.domNode, this.disabledClass);
-	}
-}, enable:function () {
-	this.setDisabled(false);
-}, disable:function () {
-	this.setDisabled(true);
-}, menuOpen:function (message) {
-}});
-dojo.widget.defineWidget("dojo.widget.MenuSeparator2", dojo.widget.HtmlWidget, {templateString:"<tr class=\"dojoMenuSeparator2\"><td colspan=4>" + "<div class=\"dojoMenuSeparator2Top\"></div>" + "<div class=\"dojoMenuSeparator2Bottom\"></div>" + "</td></tr>", postCreate:function () {
-	dojo.html.disableSelection(this.domNode);
-}});
-dojo.widget.defineWidget("dojo.widget.MenuBar2", [dojo.widget.HtmlWidget, dojo.widget.MenuBase], {menuOverlap:2, templateString:"<div class=\"dojoMenuBar2\" dojoAttachPoint=\"containerNode\" tabIndex=\"0\"></div>", close:function (force) {
-	if (this._highlighted_option) {
-		this._highlighted_option.onUnhover();
-	}
-	this.closeSubmenu(force);
-}, closeAll:function (force) {
-	this.close(force);
-}, processKey:function (evt) {
-	if (evt.ctrlKey || evt.altKey) {
-		return false;
-	}
-	var rval = false;
-	switch (evt.key) {
-	  case evt.KEY_DOWN_ARROW:
-		rval = this._moveToChildMenu(evt);
-		break;
-	  case evt.KEY_UP_ARROW:
-		rval = this._moveToParentMenu(evt);
-		break;
-	  case evt.KEY_RIGHT_ARROW:
-		rval = this._moveToNext(evt);
-		break;
-	  case evt.KEY_LEFT_ARROW:
-		rval = this._moveToPrevious(evt);
-		break;
-	  default:
-		rval = dojo.widget.MenuBar2.superclass.processKey.apply(this, arguments);
-		break;
-	}
-	return rval;
-}, postCreate:function () {
-	dojo.widget.MenuBar2.superclass.postCreate.apply(this, arguments);
-	this.isShowingNow = true;
-}, _openSubmenu:function (submenu, from_item) {
-	submenu._openAsSubmenu(this, from_item.domNode, {"BL":"TL", "TL":"BL"});
-	this.currentSubmenu = submenu;
-	this.currentSubmenuTrigger = from_item;
-	this.currentSubmenuTrigger.is_open = true;
-}});
-dojo.widget.defineWidget("dojo.widget.MenuBarItem2", dojo.widget.MenuItem2, {templateString:"<span class=\"dojoMenuItem2\" dojoAttachEvent=\"onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;\">${this.caption}</span>"});
-dojo.widget.Menu2.OperaAndKonqFixer = new function () {
-	var implement = true;
-	var delfunc = false;
-	if (!dojo.lang.isFunction(dojo.doc().oncontextmenu)) {
-		dojo.doc().oncontextmenu = function () {
-			implement = false;
-			delfunc = true;
-		};
-	}
-	if (dojo.doc().createEvent) {
-		try {
-			var e = dojo.doc().createEvent("MouseEvents");
-			e.initMouseEvent("contextmenu", 1, 1, dojo.global(), 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
-			dojo.doc().dispatchEvent(e);
+});
+
+//
+// the menu manager makes sure we don't have several menus
+// open at once. the root menu in an opening sequence calls
+// opened(). when a root menu closes it calls closed(). then
+// everything works. lovely.
+//
+
+dojo.widget.html.Menu2Manager = new function(){
+
+	this.currentMenu = null;
+	this.currentButton = null;		// button that opened current menu (if any)
+	this.focusNode = null;
+
+	dojo.event.connect(document, 'onmousedown', this, 'onClick');
+	dojo.event.connect(window, "onscroll", this, "onClick");
+
+	this.closed = function(menu){
+		if (this.currentMenu == menu){
+			this.currentMenu = null;
+			this.currentButton = null;
 		}
-		catch (e) {
+	};
+
+	this.opened = function(menu, button){
+		if (menu == this.currentMenu){ return; }
+
+		if (this.currentMenu){
+			this.currentMenu.close();
 		}
-	} else {
-		implement = false;
-	}
-	if (delfunc) {
-		delete dojo.doc().oncontextmenu;
-	}
-	this.fixNode = function (node) {
-		if (implement) {
-			if (!dojo.lang.isFunction(node.oncontextmenu)) {
-				node.oncontextmenu = function (e) {
-				};
+
+		this.currentMenu = menu;
+		this.currentButton = button;
+	};
+
+	this.onClick = function(e){
+
+		if (!this.currentMenu){ return; }
+
+		var scrolloffset = dojo.html.getScrollOffset();
+
+		var x = e.clientX + scrolloffset[0];
+		var y = e.clientY + scrolloffset[1];
+
+		var m = this.currentMenu;
+
+		// starting from the base menu, perform a hit test
+		// and exit when one succeeds
+
+		while (m){
+
+			if (m.isPointInMenu(x, y)){
+
+				return;
 			}
-			if (dojo.render.html.opera) {
-				node._menufixer_opera = function (e) {
-					if (e.ctrlKey) {
-						this.oncontextmenu(e);
-					}
-				};
-				dojo.event.connect(node, "onclick", node, "_menufixer_opera");
-			} else {
-				node._menufixer_konq = function (e) {
-					if (e.button == 2) {
-						e.preventDefault();
-						this.oncontextmenu(e);
-					}
-				};
-				dojo.event.connect(node, "onmousedown", node, "_menufixer_konq");
-			}
+
+			m = m.currentSubmenu;
 		}
+
+		// Also, if user clicked the button that opened this menu, then
+		// that button will send the menu a close() command, so this code
+		// shouldn't try to close the menu.  Closing twice messes up animation.
+		if (this.currentButton && dojo.html.overElement(this.currentButton, e)){
+			return;
+		}
+
+		// the click didn't fall within the open menu tree
+		// so close it
+
+		this.currentMenu.close();
 	};
-	this.cleanNode = function (node) {
-		if (implement) {
-			if (node._menufixer_opera) {
-				dojo.event.disconnect(node, "onclick", node, "_menufixer_opera");
-				delete node._menufixer_opera;
-			} else {
-				if (node._menufixer_konq) {
-					dojo.event.disconnect(node, "onmousedown", node, "_menufixer_konq");
-					delete node._menufixer_konq;
-				}
+}
+
+// ************************** make contextmenu work in konqueror and opera *********************
+dojo.widget.Menu2.OperaAndKonqFixer = new function(){
+ 	var implement = true;
+ 	var delfunc = false;
+
+ 	/** 	dom event check
+ 	*
+ 	*	make a event and dispatch it and se if it calls function below,
+ 	*	if it does its supported and we dont need to implement our own
+ 	*/
+
+ 	// gets called if we have support for oncontextmenu
+ 	if (!dojo.lang.isFunction(document.oncontextmenu)){
+ 		document.oncontextmenu = function(){
+ 			implement = false;
+ 			delfunc = true;
+ 		}
+ 	}
+
+ 	if (document.createEvent){ // moz, safari has contextmenu event, need to do livecheck on this env.
+ 		try {
+ 			var e = document.createEvent("MouseEvents");
+ 			e.initMouseEvent("contextmenu", 1, 1, window, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
+ 			document.dispatchEvent(e);
+ 		} catch (e) {/* assume not supported */}
+ 	} else {
+ 		// IE no need to implement custom contextmenu
+ 		implement = false;
+ 	}
+
+ 	// clear this one if it wasn't there before
+ 	if (delfunc){
+ 		delete document.oncontextmenu;
+ 	}
+ 	/***** end dom event check *****/
+
+
+ 	/**
+ 	*	this fixes a dom node by attaching a custom oncontextmenu function that gets called when apropriate
+ 	*	@param	node	a dom node
+ 	*
+ 	*	no returns
+ 	*/
+ 	this.fixNode = function(node){
+ 		if (implement){
+ 			// attach stub oncontextmenu function
+ 			if (!dojo.lang.isFunction(node.oncontextmenu)){
+ 				node.oncontextmenu = function(e){/*stub*/}
+ 			}
+
+ 			// attach control function for oncontextmenu
+ 			if (window.opera){
+ 				// opera
+ 				// listen to ctrl-click events
+ 				node._menufixer_opera = function(e){
+ 					if (e.ctrlKey){
+ 						this.oncontextmenu(e);
+ 					}
+ 				};
+
+ 				dojo.event.connect(node, "onclick", node, "_menufixer_opera");
+
+ 			} else {
+ 				// konqueror
+ 				// rightclick, listen to mousedown events
+ 				node._menufixer_konq = function(e){
+ 					if (e.button==2 ){
+ 						e.preventDefault(); // need to prevent browsers menu
+ 						this.oncontextmenu(e);
+ 					}
+ 				};
+
+ 				dojo.event.connect(node, "onmousedown", node, "_menufixer_konq");
+ 			}
+ 		}
+ 	}
+
+ 	/**
+ 	*	this cleans up a fixed node, prevent memoryleak?
+ 	*	@param node	node to clean
+ 	*
+ 	*	no returns
+ 	*/
+ 	this.cleanNode = function(node){
+ 		if (implement){
+ 			// checks needed if we gets a non fixed node
+ 			if (node._menufixer_opera){
+ 				dojo.event.disconnect(node, "onclick", node, "_menufixer_opera");
+ 				delete node._menufixer_opera;
+ 			} else if(node._menufixer_konq){
+ 				dojo.event.disconnect(node, "onmousedown", node, "_menufixer_konq");
+ 				delete node._menufixer_konq;
+ 			}
+ 			if (node.oncontextmenu){
+ 				delete node.oncontextmenu;
+ 			}
+ 		}
+ 	}
+};
+
+
+dojo.widget.MenuBar2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.MenuBar2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuBar2, {
+	widgetType: "MenuBar2",
+	isContainer: true,
+
+	snarfChildDomOutput: true,
+
+	currentItem: null,
+	isExpanded: false,
+
+	currentSubmenu: null,
+	currentSubmenuTrigger: null,
+
+	domNode: null,
+	containerNode: null,
+
+	templateString: '<div class="dojoMenuBar2"><div dojoAttachPoint="containerNode" class="dojoMenuBar2Client"></div></div>',
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlMenu2.css"),
+
+	itemHeight: 18,
+	openEvent: null,
+
+
+	postCreate: function(){
+
+		// do something here
+
+		this.layoutMenuSoon();
+	},
+
+	layoutMenuSoon: function(){
+		dojo.lang.setTimeout(this, "layoutMenu", 0);
+	},
+
+	layoutMenu: function(){
+
+		// menu must be attached to DOM for size calculations to work
+
+		var parent = this.domNode.parentNode;
+		if (! parent || parent == undefined) {
+			document.body.appendChild(this.domNode);
+		}
+
+
+		// determine menu height
+
+		var max_label_h = 0;
+
+		for(var i=0; i<this.children.length; i++){
+
+			if (this.children[i].getLabelHeight){
+
+				max_label_h = Math.max(max_label_h, this.children[i].getLabelHeight());
 			}
-			if (node.oncontextmenu) {
-				delete node.oncontextmenu;
+		}
+
+		if (isNaN(max_label_h)){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
+		}
+
+		var clientLeft = dojo.style.getPixelValue(this.domNode, "padding-left", true)
+				+ dojo.style.getPixelValue(this.containerNode, "margin-left", true)
+				+ dojo.style.getPixelValue(this.containerNode, "padding-left", true);
+		var clientTop  = dojo.style.getPixelValue(this.domNode, "padding-top", true)
+				+ dojo.style.getPixelValue(this.containerNode, "padding-top", true);
+
+		if (isNaN(clientLeft) || isNaN(clientTop)){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
+		}
+
+		var max_item_height = 0;
+		var x = clientLeft;
+
+		for (var i=0; i<this.children.length; i++){
+
+			var ch = this.children[i];
+
+			ch.layoutItem(max_label_h);
+
+			ch.leftPosition = x;
+			ch.domNode.style.left = x + 'px';
+
+			x += dojo.style.getOuterWidth(ch.domNode);
+			max_item_height = Math.max(max_item_height, dojo.style.getOuterHeight(ch.domNode));
+		}
+
+		dojo.style.setContentHeight(this.containerNode, max_item_height);
+		dojo.style.setContentHeight(this.domNode, dojo.style.getOuterHeight(this.containerNode));
+	},
+
+	openSubmenu: function(submenu, from_item){
+
+		var our_pos = dojo.style.getAbsolutePosition(this.domNode, false);
+
+		var our_h = dojo.style.getOuterHeight(this.domNode);
+		var item_x = from_item.leftPosition;
+
+		var x = our_pos.x + item_x;
+		var y = our_pos.y + our_h;
+
+		this.currentSubmenu = submenu;
+		this.currentSubmenu.open(x, y, this, from_item.domNode);
+		this.currentSubmenu.parentMenuBar = this;
+	},
+
+	closeSubmenu: function(){
+
+		if (this.currentSubmenu == null){ return; }
+
+		var menu = this.currentSubmenu;
+		this.currentSubmenu = null;
+		menu.close();
+	},
+
+	itemHover: function(item){
+
+		if (item == this.currentItem) return;
+
+		if (this.currentItem){
+			this.currentItem.unhighlightItem();
+
+			if (this.isExpanded){
+				this.closeSubmenu();
 			}
 		}
-	};
-};
 
+		this.currentItem = item;
+		this.currentItem.highlightItem();
+
+		if (this.isExpanded){
+			this.currentItem.expandMenu();
+		}
+	},
+
+	itemUnhover: function(item){
+
+		if (item != this.currentItem) return;
+
+		if (this.currentItem && !this.isExpanded){
+			this.currentItem.unhighlightItem();
+			this.currentItem = null;
+		}
+	},
+
+	itemClick: function(item){
+
+		if (item != this.currentItem){
+
+			this.itemHover(item);
+		}
+
+		if (this.isExpanded){
+
+			this.isExpanded = false;
+			this.closeSubmenu();
+
+		}else{
+
+			this.isExpanded = true;
+			this.currentItem.expandMenu();
+		}
+	},
+
+	closedMenu: function(menu){
+
+		if (this.currentSubmenu == menu){
+
+			this.isExpanded = false;
+			this.itemUnhover(this.currentItem);
+		}
+	}
+});
+
+
+dojo.widget.MenuBarItem2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.MenuBarItem2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuBarItem2, {
+
+	widgetType: "MenuBarItem2",
+	templateString:
+			 '<div class="dojoMenuBarItem2">'
+			+'<span dojoAttachPoint="labelNode" class="dojoMenuBarItem2Label"><span><span></span></span></span>'
+			+'<div dojoAttachPoint="targetNode" class="dojoMenuBarItem2Target" dojoAttachEvent="onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;">&nbsp;</div>'
+			+'</div>',
+
+	//
+	// nodes
+	//
+
+	domNode: null,
+	labelNode: null,
+	targetNode: null,
+
+	//
+	// internal settings
+	//
+
+	is_hovering: false,
+	hover_timer: null,
+	is_open: false,
+
+	//
+	// options
+	//
+
+	caption: 'Untitled',
+	accelKey: '',
+	iconSrc: '',
+	submenuId: '',
+	disabled: false,
+	eventNaming: "default",
+
+
+	postCreate: function(){
+
+		dojo.html.disableSelection(this.domNode);
+
+		if (this.disabled){
+			this.setDisabled(true);
+		}
+
+		this.labelNode.childNodes[0].appendChild(document.createTextNode(this.caption));
+
+		this.labelShadowNode = this.labelNode.childNodes[0].childNodes[0];
+		this.labelShadowNode.appendChild(document.createTextNode(this.caption));
+
+		if (this.eventNaming == "default") {
+			for (var eventName in this.eventNames) {
+				this.eventNames[eventName] = this.widgetId+"/"+eventName;
+			}
+		}
+	},
+
+	layoutItem: function(item_h){
+
+		var label_w = dojo.style.getOuterWidth(this.labelNode);
+
+		var clientLeft = dojo.style.getPixelValue(this.domNode, "padding-left", true);
+		var clientTop  = dojo.style.getPixelValue(this.domNode, "padding-top", true);
+
+		this.labelNode.style.left = clientLeft + 'px';
+
+		dojo.style.setOuterHeight(this.labelNode, item_h);
+		dojo.style.setContentWidth(this.domNode, label_w);
+		dojo.style.setContentHeight(this.domNode, item_h);
+
+		this.labelNode.style.left = '0px';
+
+		dojo.style.setOuterWidth(this.targetNode, label_w);
+		dojo.style.setOuterHeight(this.targetNode, item_h);
+	},
+
+	getLabelHeight: function(){
+
+		return dojo.style.getOuterHeight(this.labelNode);
+	},
+
+	onHover: function(){
+		this.parent.itemHover(this);
+	},
+
+	onUnhover: function(){
+		this.parent.itemUnhover(this);
+	},
+
+	_onClick: function(){
+		this.parent.itemClick(this);
+	},
+
+	highlightItem: function(){
+		dojo.html.addClass(this.domNode, 'dojoMenuBarItem2Hover');
+	},
+
+	unhighlightItem: function(){
+		dojo.html.removeClass(this.domNode, 'dojoMenuBarItem2Hover');
+	},
+
+	expandMenu: function(){
+
+		var submenu = dojo.widget.getWidgetById(this.submenuId);
+		if (submenu){
+
+			this.parent.openSubmenu(submenu, this);
+		}
+	},
+
+	setDisabled: function(value){
+		this.disabled = value;
+
+		if (this.disabled){
+			dojo.html.addClass(this.domNode, 'dojoMenuBarItem2Disabled');
+		}else{
+			dojo.html.removeClass(this.domNode, 'dojoMenuBarItem2Disabled');
+		}
+	}
+});
+
+// make it a tag
+dojo.widget.tags.addParseTreeHandler("dojo:MenuBar2");
+dojo.widget.tags.addParseTreeHandler("dojo:MenuBarItem2");
+dojo.widget.tags.addParseTreeHandler("dojo:PopupMenu2");
+dojo.widget.tags.addParseTreeHandler("dojo:MenuItem2");
+dojo.widget.tags.addParseTreeHandler("dojo:MenuSeparator2");
+

Added: tags/parley-0.53/root/static/magic/src/widget/MenuItem.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/MenuItem.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/MenuItem.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,47 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.MenuItem");
+dojo.provide("dojo.widget.DomMenuItem");
+
+dojo.deprecated("dojo.widget.MenuItem, dojo.widget.DomMenuItem",  "use dojo.widget.Menu2", "0.4");
+
+dojo.require("dojo.string");
+dojo.require("dojo.widget.*");
+
+dojo.widget.tags.addParseTreeHandler("dojo:MenuItem");
+
+/* MenuItem
+ ***********/
+ 
+dojo.widget.MenuItem = function(){
+	dojo.widget.MenuItem.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.MenuItem, dojo.widget.Widget);
+
+dojo.lang.extend(dojo.widget.MenuItem, {
+	widgetType: "MenuItem",
+	isContainer: true
+});
+
+
+/* DomMenuItem
+ **************/
+dojo.widget.DomMenuItem = function(){
+	dojo.widget.DomMenuItem.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.DomMenuItem, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.DomMenuItem, {
+	widgetType: "MenuItem"
+});
+
+dojo.requireAfterIf("html", "dojo.html");
+dojo.requireAfterIf("html", "dojo.widget.html.MenuItem");

Modified: tags/parley-0.53/root/static/magic/src/widget/MonthlyCalendar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/MonthlyCalendar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/MonthlyCalendar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,113 +8,34 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.MonthlyCalendar");
+dojo.provide("dojo.widget.MonthlyCalendar.util");
+dojo.require("dojo.widget.DomWidget");
+dojo.require("dojo.date");
 
+dojo.widget.MonthlyCalendar= function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = "MonthlyCalendar";
+	this.isContainer = false;
+	// the following aliases prevent breaking people using 0.2.x
+	this.months = dojo.date.months;
+	this.weekdays = dojo.date.days;
+	this.toRfcDate = dojo.widget.MonthlyCalendar.util.toRfcDate;
+	this.fromRfcDate = dojo.widget.MonthlyCalendar.util.fromRfcDate;
+	this.initFirstSaturday = dojo.widget.MonthlyCalendar.util.initFirstSaturday;
+}
 
-dojo.provide("dojo.widget.MonthlyCalendar");
-dojo.require("dojo.date.common");
-dojo.require("dojo.date.format");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.DatePicker");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.widget.MonthlyCalendar");
-dojo.widget.defineWidget("dojo.widget.MonthlyCalendar", dojo.widget.DatePicker, {dayWidth:"wide", templateString:"<div class=\"datePickerContainer\" dojoAttachPoint=\"datePickerContainerNode\">\n\t<h3 class=\"monthLabel\">\n\t<!--\n\t<span \n\t\tdojoAttachPoint=\"decreaseWeekNode\" \n\t\tdojoAttachEvent=\"onClick: onIncrementWeek;\" \n\t\tclass=\"incrementControl\">\n\t\t<img src=\"${dojoWidgetModuleUri}templates/decrementWeek.gif\" alt=\"&uarr;\" />\n\t</span>\n\t-->\n\t<span \n\t\tdojoAttachPoint=\"decreaseMonthNode\" \n\t\tdojoAttachEvent=\"onClick: onIncrementMonth;\" class=\"incrementControl\">\n\t\t<img src=\"${dojoWidgetModuleUri}templates/decrementMonth.gif\" \n\t\t\talt=\"&uarr;\" dojoAttachPoint=\"decrementMonthImageNode\">\n\t</span>\n\t<span dojoAttachPoint=\"monthLabelNode\" class=\"month\">July</span>\n\t<span \n\t\tdojoAttachPoint=\"increaseMonthNode\" \n\t\tdojoAttachEvent=\"onClick: onIncrementMonth;\" class=\"incrementControl\">\n\t\t<img src=\"${dojoWidge!
 tModuleUri}templates/incrementMonth.gif\" \n\t\t\talt=\"&darr;\"  dojoAttachPoint=\"incrementMonthImageNode\">\n\t</span>\n\t<!--\n\t\t<span dojoAttachPoint=\"increaseWeekNode\" \n\t\t\tdojoAttachEvent=\"onClick: onIncrementWeek;\" \n\t\t\tclass=\"incrementControl\">\n\t\t\t<img src=\"${dojoWidgetModuleUri}templates/incrementWeek.gif\" \n\t\t\talt=\"&darr;\" />\n\t\t</span>\n\t-->\n\t</h3>\n\t<table class=\"calendarContainer\">\n\t\t<thead>\n\t\t\t<tr dojoAttachPoint=\"dayLabelsRow\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody dojoAttachPoint=\"calendarDatesContainerNode\" \n\t\t\tdojoAttachEvent=\"onClick: onSetDate;\">\n\t\t\t<tr dojoAttachPoint=\"calendarRow0\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t\t<tr dojoAttachPoint=\"calendarRo!
 w1\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>!
 \n\t\t\t
\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t\t<tr dojoAttachPoint=\"calendarRow2\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t\t<tr dojoAttachPoint=\"calendarRow3\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t\t<tr dojoAttachPoint=\"calendarRow4\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t\t<tr dojoAttachPoint=\"calendarRow5\">\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t\t<td></td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n\t<h3 class=\"yearLabel\">\n\t\t<span dojoAttachPoint=\"previousYearLabelNode\"\n\t\t\tdojoAttachEvent=\"onClick: on!
 IncrementYear;\" class=\"previousYear\"></span>\n\t\t<span class=\"selectedYear\" dojoAttachPoint=\"currentYearLabelNode\"></span>\n\t\t<span dojoAttachPoint=\"nextYearLabelNode\" \n\t\t\tdojoAttachEvent=\"onClick: onIncrementYear;\" class=\"nextYear\"></span>\n\t</h3>\n</div>\n", templateCssString:".datePickerContainer {\n\tmargin:0.5em 2em 0.5em 0;\n\t/*width:10em;*/\n\tfloat:left;\n}\n\n.previousMonth {\n\tbackground-color:#bbbbbb;\n}\n\n.currentMonth {\n\tbackground-color:#8f8f8f;\n}\n\n.nextMonth {\n\tbackground-color:#eeeeee;\n}\n\n.currentDate {\n\ttext-decoration:underline;\n\tfont-style:italic;\n}\n\n.selectedItem {\n\tbackground-color:#3a3a3a;\n\tcolor:#ffffff;\n}\n\n.calendarContainer {\n\tborder-collapse:collapse;\n\tborder-spacing:0;\n\tborder-bottom:1px solid #e6e6e6;\n\toverflow: hidden;\n\ttext-align: right;\n}\n\n.calendarContainer thead{\n\tborder-bottom:1px solid #e6e6e6;\n}\n\n.calendarContainer tbody * td {\n		height: 100px;\n		border: 1px solid gray;\n!
 }\n\n.calendarContainer td {\n		width: 100px;\n		padding: 2px;!
 \n\tvert
ical-align: top;\n}\n\n.monthLabel {\n\tfont-size:0.9em;\n\tfont-weight:400;\n\tmargin:0;\n\ttext-align:center;\n}\n\n.monthLabel .month {\n\tpadding:0 0.4em 0 0.4em;\n}\n\n.yearLabel {\n\tfont-size:0.9em;\n\tfont-weight:400;\n\tmargin:0.25em 0 0 0;\n\ttext-align:right;\n\tcolor:#a3a3a3;\n}\n\n.yearLabel .selectedYear {\n\tcolor:#000;\n\tpadding:0 0.2em;\n}\n\n.nextYear, .previousYear {\n\tcursor:pointer;cursor:hand;\n}\n\n.incrementControl {\n\tcursor:pointer;cursor:hand;\n\twidth:1em;\n}\n\n.dojoMonthlyCalendarEvent {\n\tfont-size:0.7em;\n\toverflow: hidden;\n\tfont-color: grey;\n\twhite-space: nowrap;\n\ttext-align: left;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/MonthlyCalendar.css"), initializer:function () {
-	this.iCalendars = [];
-}, addCalendar:function (cal) {
-	dojo.debug("Adding Calendar");
-	this.iCalendars.push(cal);
-	dojo.debug("Starting init");
-	this.initUI();
-	dojo.debug("done init");
-}, createDayContents:function (node, mydate) {
-	dojo.html.removeChildren(node);
-	node.appendChild(document.createTextNode(mydate.getDate()));
-	for (var x = 0; x < this.iCalendars.length; x++) {
-		var evts = this.iCalendars[x].getEvents(mydate);
-		if ((dojo.lang.isArray(evts)) && (evts.length > 0)) {
-			for (var y = 0; y < evts.length; y++) {
-				var el = document.createElement("div");
-				dojo.html.addClass(el, "dojoMonthlyCalendarEvent");
-				el.appendChild(document.createTextNode(evts[y].summary.value));
-				el.width = dojo.html.getContentBox(node).width;
-				node.appendChild(el);
-			}
-		}
-	}
-}, initUI:function () {
-	var dayLabels = dojo.date.getNames("days", this.dayWidth, "standAlone", this.lang);
-	var dayLabelNodes = this.dayLabelsRow.getElementsByTagName("td");
-	for (var i = 0; i < 7; i++) {
-		dayLabelNodes.item(i).innerHTML = dayLabels[i];
-	}
-	this.selectedIsUsed = false;
-	this.currentIsUsed = false;
-	var currentClassName = "";
-	var previousDate = new Date();
-	var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName("td");
-	var currentCalendarNode;
-	previousDate.setHours(8);
-	var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
-	var lastDay = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date + 42, 8);
-	if (this.iCalendars.length > 0) {
-		for (var x = 0; x < this.iCalendars.length; x++) {
-			this.iCalendars[x].preComputeRecurringEvents(lastDay);
-		}
-	}
-	if (this.firstSaturday.date < 7) {
-		var dayInWeek = 6;
-		for (var i = this.firstSaturday.date; i > 0; i--) {
-			currentCalendarNode = calendarNodes.item(dayInWeek);
-			this.createDayContents(currentCalendarNode, nextDate);
-			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
-			dayInWeek--;
-			previousDate = nextDate;
-			nextDate = this.incrementDate(nextDate, false);
-		}
-		for (var i = dayInWeek; i > -1; i--) {
-			currentCalendarNode = calendarNodes.item(i);
-			this.createDayContents(currentCalendarNode, nextDate);
-			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "previous"));
-			previousDate = nextDate;
-			nextDate = this.incrementDate(nextDate, false);
-		}
-	} else {
-		nextDate.setDate(1);
-		for (var i = 0; i < 7; i++) {
-			currentCalendarNode = calendarNodes.item(i);
-			this.createDayContents(currentCalendarNode, nextDate);
-			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
-			previousDate = nextDate;
-			nextDate = this.incrementDate(nextDate, true);
-		}
-	}
-	previousDate.setDate(this.firstSaturday.date);
-	previousDate.setMonth(this.firstSaturday.month);
-	previousDate.setFullYear(this.firstSaturday.year);
-	nextDate = this.incrementDate(previousDate, true);
-	var count = 7;
-	currentCalendarNode = calendarNodes.item(count);
-	while ((nextDate.getMonth() == previousDate.getMonth()) && (count < 42)) {
-		this.createDayContents(currentCalendarNode, nextDate);
-		dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
-		currentCalendarNode = calendarNodes.item(++count);
-		previousDate = nextDate;
-		nextDate = this.incrementDate(nextDate, true);
-	}
-	while (count < 42) {
-		this.createDayContents(currentCalendarNode, nextDate);
-		dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "next"));
-		currentCalendarNode = calendarNodes.item(++count);
-		previousDate = nextDate;
-		nextDate = this.incrementDate(nextDate, true);
-	}
-	this.setMonthLabel(this.firstSaturday.month);
-	this.setYearLabels(this.firstSaturday.year);
-}});
-dojo.widget.MonthlyCalendar.util = new function () {
-	this.toRfcDate = function (jsDate) {
-		if (!jsDate) {
+dojo.inherits(dojo.widget.MonthlyCalendar, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler("dojo:monthlycalendar");
+
+dojo.requireAfterIf("html", "dojo.widget.html.MonthlyCalendar");
+
+dojo.widget.MonthlyCalendar.util= new function() {
+	this.months = dojo.date.months;
+	this.weekdays = dojo.date.days;
+	
+	this.toRfcDate = function(jsDate) {
+		if(!jsDate) {
 			jsDate = this.today;
 		}
 		var year = jsDate.getFullYear();
@@ -126,24 +47,28 @@
 		if (date < 10) {
 			date = "0" + date.toString();
 		}
+		// because this is a date picker and not a time picker, we treat time 
+		// as zero
 		return year + "-" + month + "-" + date + "T00:00:00+00:00";
-	};
-	this.fromRfcDate = function (rfcDate) {
+	}
+	
+	this.fromRfcDate = function(rfcDate) {
 		var tempDate = rfcDate.split("-");
-		if (tempDate.length < 3) {
+		if(tempDate.length < 3) {
 			return new Date();
 		}
-		return new Date(parseInt(tempDate[0]), (parseInt(tempDate[1], 10) - 1), parseInt(tempDate[2].substr(0, 2), 10));
-	};
-	this.initFirstSaturday = function (month, year) {
-		if (!month) {
+		// fullYear, month, date
+		return new Date(parseInt(tempDate[0]), (parseInt(tempDate[1], 10) - 1), parseInt(tempDate[2].substr(0,2), 10));
+	}
+	
+	this.initFirstSaturday = function(month, year) {
+		if(!month) {
 			month = this.date.getMonth();
 		}
-		if (!year) {
+		if(!year) {
 			year = this.date.getFullYear();
 		}
 		var firstOfMonth = new Date(year, month, 1);
-		return {year:year, month:month, date:7 - firstOfMonth.getDay()};
-	};
-};
-
+		return {year: year, month: month, date: 7 - firstOfMonth.getDay()};
+	}
+}

Deleted: tags/parley-0.53/root/static/magic/src/widget/PageContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/PageContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/PageContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,202 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.PageContainer");
-dojo.require("dojo.lang.func");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.selection");
-dojo.widget.defineWidget("dojo.widget.PageContainer", dojo.widget.HtmlWidget, {isContainer:true, doLayout:true, templateString:"<div dojoAttachPoint='containerNode'></div>", selectedChild:"", fillInTemplate:function (args, frag) {
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-	dojo.widget.PageContainer.superclass.fillInTemplate.apply(this, arguments);
-}, postCreate:function (args, frag) {
-	if (this.children.length) {
-		dojo.lang.forEach(this.children, this._setupChild, this);
-		var initialChild;
-		if (this.selectedChild) {
-			this.selectChild(this.selectedChild);
-		} else {
-			for (var i = 0; i < this.children.length; i++) {
-				if (this.children[i].selected) {
-					this.selectChild(this.children[i]);
-					break;
-				}
-			}
-			if (!this.selectedChildWidget) {
-				this.selectChild(this.children[0]);
-			}
-		}
-	}
-}, addChild:function (child) {
-	dojo.widget.PageContainer.superclass.addChild.apply(this, arguments);
-	this._setupChild(child);
-	this.onResized();
-	if (!this.selectedChildWidget) {
-		this.selectChild(child);
-	}
-}, _setupChild:function (page) {
-	page.hide();
-	page.domNode.style.position = "relative";
-	dojo.event.topic.publish(this.widgetId + "-addChild", page);
-}, removeChild:function (page) {
-	dojo.widget.PageContainer.superclass.removeChild.apply(this, arguments);
-	if (this._beingDestroyed) {
-		return;
-	}
-	dojo.event.topic.publish(this.widgetId + "-removeChild", page);
-	this.onResized();
-	if (this.selectedChildWidget === page) {
-		this.selectedChildWidget = undefined;
-		if (this.children.length > 0) {
-			this.selectChild(this.children[0], true);
-		}
-	}
-}, selectChild:function (page, callingWidget) {
-	page = dojo.widget.byId(page);
-	this.correspondingPageButton = callingWidget;
-	if (this.selectedChildWidget) {
-		this._hideChild(this.selectedChildWidget);
-	}
-	this.selectedChildWidget = page;
-	this.selectedChild = page.widgetId;
-	this._showChild(page);
-	page.isFirstChild = (page == this.children[0]);
-	page.isLastChild = (page == this.children[this.children.length - 1]);
-	dojo.event.topic.publish(this.widgetId + "-selectChild", page);
-}, forward:function () {
-	var index = dojo.lang.find(this.children, this.selectedChildWidget);
-	this.selectChild(this.children[index + 1]);
-}, back:function () {
-	var index = dojo.lang.find(this.children, this.selectedChildWidget);
-	this.selectChild(this.children[index - 1]);
-}, onResized:function () {
-	if (this.doLayout && this.selectedChildWidget) {
-		with (this.selectedChildWidget.domNode.style) {
-			top = dojo.html.getPixelValue(this.containerNode, "padding-top", true);
-			left = dojo.html.getPixelValue(this.containerNode, "padding-left", true);
-		}
-		var content = dojo.html.getContentBox(this.containerNode);
-		this.selectedChildWidget.resizeTo(content.width, content.height);
-	}
-}, _showChild:function (page) {
-	if (this.doLayout) {
-		var content = dojo.html.getContentBox(this.containerNode);
-		page.resizeTo(content.width, content.height);
-	}
-	page.selected = true;
-	page.show();
-}, _hideChild:function (page) {
-	page.selected = false;
-	page.hide();
-}, closeChild:function (page) {
-	var remove = page.onClose(this, page);
-	if (remove) {
-		this.removeChild(page);
-		page.destroy();
-	}
-}, destroy:function () {
-	this._beingDestroyed = true;
-	dojo.event.topic.destroy(this.widgetId + "-addChild");
-	dojo.event.topic.destroy(this.widgetId + "-removeChild");
-	dojo.event.topic.destroy(this.widgetId + "-selectChild");
-	dojo.widget.PageContainer.superclass.destroy.apply(this, arguments);
-}});
-dojo.widget.defineWidget("dojo.widget.PageController", dojo.widget.HtmlWidget, {templateString:"<span wairole='tablist' dojoAttachEvent='onKey'></span>", isContainer:true, containerId:"", buttonWidget:"PageButton", "class":"dojoPageController", fillInTemplate:function () {
-	dojo.html.addClass(this.domNode, this["class"]);
-	dojo.widget.wai.setAttr(this.domNode, "waiRole", "role", "tablist");
-}, postCreate:function () {
-	this.pane2button = {};
-	var container = dojo.widget.byId(this.containerId);
-	if (container) {
-		dojo.lang.forEach(container.children, this.onAddChild, this);
-	}
-	dojo.event.topic.subscribe(this.containerId + "-addChild", this, "onAddChild");
-	dojo.event.topic.subscribe(this.containerId + "-removeChild", this, "onRemoveChild");
-	dojo.event.topic.subscribe(this.containerId + "-selectChild", this, "onSelectChild");
-}, destroy:function () {
-	dojo.event.topic.unsubscribe(this.containerId + "-addChild", this, "onAddChild");
-	dojo.event.topic.unsubscribe(this.containerId + "-removeChild", this, "onRemoveChild");
-	dojo.event.topic.unsubscribe(this.containerId + "-selectChild", this, "onSelectChild");
-	dojo.widget.PageController.superclass.destroy.apply(this, arguments);
-}, onAddChild:function (page) {
-	var button = dojo.widget.createWidget(this.buttonWidget, {label:page.label, closeButton:page.closable});
-	this.addChild(button);
-	this.domNode.appendChild(button.domNode);
-	this.pane2button[page] = button;
-	page.controlButton = button;
-	var _this = this;
-	dojo.event.connect(button, "onClick", function () {
-		_this.onButtonClick(page);
-	});
-	dojo.event.connect(button, "onCloseButtonClick", function () {
-		_this.onCloseButtonClick(page);
-	});
-}, onRemoveChild:function (page) {
-	if (this._currentChild == page) {
-		this._currentChild = null;
-	}
-	var button = this.pane2button[page];
-	if (button) {
-		button.destroy();
-	}
-	this.pane2button[page] = null;
-}, onSelectChild:function (page) {
-	if (this._currentChild) {
-		var oldButton = this.pane2button[this._currentChild];
-		oldButton.clearSelected();
-	}
-	var newButton = this.pane2button[page];
-	newButton.setSelected();
-	this._currentChild = page;
-}, onButtonClick:function (page) {
-	var container = dojo.widget.byId(this.containerId);
-	container.selectChild(page, false, this);
-}, onCloseButtonClick:function (page) {
-	var container = dojo.widget.byId(this.containerId);
-	container.closeChild(page);
-}, onKey:function (evt) {
-	if ((evt.keyCode == evt.KEY_RIGHT_ARROW) || (evt.keyCode == evt.KEY_LEFT_ARROW)) {
-		var current = 0;
-		var next = null;
-		var current = dojo.lang.find(this.children, this.pane2button[this._currentChild]);
-		if (evt.keyCode == evt.KEY_RIGHT_ARROW) {
-			next = this.children[(current + 1) % this.children.length];
-		} else {
-			next = this.children[(current + (this.children.length - 1)) % this.children.length];
-		}
-		dojo.event.browser.stopEvent(evt);
-		next.onClick();
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.PageButton", dojo.widget.HtmlWidget, {templateString:"<span class='item'>" + "<span dojoAttachEvent='onClick' dojoAttachPoint='titleNode' class='selectButton'>${this.label}</span>" + "<span dojoAttachEvent='onClick:onCloseButtonClick' class='closeButton'>[X]</span>" + "</span>", label:"foo", closeButton:false, onClick:function () {
-	this.focus();
-}, onCloseButtonMouseOver:function () {
-	dojo.html.addClass(this.closeButtonNode, "closeHover");
-}, onCloseButtonMouseOut:function () {
-	dojo.html.removeClass(this.closeButtonNode, "closeHover");
-}, onCloseButtonClick:function (evt) {
-}, setSelected:function () {
-	dojo.html.addClass(this.domNode, "current");
-	this.titleNode.setAttribute("tabIndex", "0");
-}, clearSelected:function () {
-	dojo.html.removeClass(this.domNode, "current");
-	this.titleNode.setAttribute("tabIndex", "-1");
-}, focus:function () {
-	if (this.titleNode.focus) {
-		this.titleNode.focus();
-	}
-}});
-dojo.lang.extend(dojo.widget.Widget, {label:"", selected:false, closable:false, onClose:function () {
-	return true;
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/Parse.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Parse.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Parse.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,220 +8,305 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.Parse");
 
-
-dojo.provide("dojo.widget.Parse");
 dojo.require("dojo.widget.Manager");
 dojo.require("dojo.dom");
-dojo.widget.Parse = function (fragment) {
+
+dojo.widget.Parse = function(fragment) {
 	this.propertySetsList = [];
 	this.fragment = fragment;
-	this.createComponents = function (frag, parentComp) {
-		var comps = [];
+	
+	this.createComponents = function(frag, parentComp){
+		var comps = [ ];
 		var built = false;
-		try {
-			if (frag && frag.tagName && (frag != frag.nodeRef)) {
+		// if we have items to parse/create at this level, do it!
+		try{
+			if((frag)&&(frag["tagName"])&&(frag!=frag["nodeRef"])){
 				var djTags = dojo.widget.tags;
-				var tna = String(frag.tagName).split(";");
-				for (var x = 0; x < tna.length; x++) {
-					var ltn = tna[x].replace(/^\s+|\s+$/g, "").toLowerCase();
-					frag.tagName = ltn;
-					var ret;
-					if (djTags[ltn]) {
+				// we split so that you can declare multiple
+				// non-destructive widgets from the same ctor node
+				var tna = String(frag["tagName"]).split(";");
+				for(var x=0; x<tna.length; x++){
+					var ltn = (tna[x].replace(/^\s+|\s+$/g, "")).toLowerCase();
+					if(djTags[ltn]){
 						built = true;
-						ret = djTags[ltn](frag, this, parentComp, frag.index);
+						frag.tagName = ltn;
+						var ret = djTags[ltn](frag, this, parentComp, frag["index"]);
 						comps.push(ret);
-					} else {
-						if (ltn.indexOf(":") == -1) {
-							ltn = "dojo:" + ltn;
+					}else{
+						if((dojo.lang.isString(ltn))&&(ltn.substr(0, 5)=="dojo:")){
+							dojo.debug("no tag handler registed for type: ", ltn);
 						}
-						ret = dojo.widget.buildWidgetFromParseTree(ltn, frag, this, parentComp, frag.index);
-						if (ret) {
-							built = true;
-							comps.push(ret);
-						}
 					}
 				}
 			}
-		}
-		catch (e) {
+		}catch(e){
 			dojo.debug("dojo.widget.Parse: error:", e);
+			// throw(e);
+			// IE is such a bitch sometimes
 		}
-		if (!built) {
+		// if there's a sub-frag, build widgets from that too
+		if(!built){
 			comps = comps.concat(this.createSubComponents(frag, parentComp));
 		}
 		return comps;
-	};
-	this.createSubComponents = function (fragment, parentComp) {
+	}
+
+	/*	createSubComponents recurses over a raw JavaScript object structure,
+			and calls the corresponding handler for its normalized tagName if it exists
+	*/
+	this.createSubComponents = function(fragment, parentComp){
 		var frag, comps = [];
-		for (var item in fragment) {
+		for(var item in fragment){
 			frag = fragment[item];
-			if (frag && typeof frag == "object" && (frag != fragment.nodeRef) && (frag != fragment.tagName) && (!dojo.dom.isNode(frag))) {
+			if ((frag)&&(typeof frag == "object")&&(frag!=fragment.nodeRef)&&(frag!=fragment["tagName"])){
 				comps = comps.concat(this.createComponents(frag, parentComp));
 			}
 		}
 		return comps;
-	};
-	this.parsePropertySets = function (fragment) {
+	}
+
+	/*  parsePropertySets checks the top level of a raw JavaScript object
+			structure for any propertySets.  It stores an array of references to 
+			propertySets that it finds.
+	*/
+	this.parsePropertySets = function(fragment) {
 		return [];
-	};
-	this.parseProperties = function (fragment) {
+		var propertySets = [];
+		for(var item in fragment){
+			if(	(fragment[item]["tagName"] == "dojo:propertyset") ) {
+				propertySets.push(fragment[item]);
+			}
+		}
+		// FIXME: should we store these propertySets somewhere for later retrieval
+		this.propertySetsList.push(propertySets);
+		return propertySets;
+	}
+	
+	/*  parseProperties checks a raw JavaScript object structure for
+			properties, and returns an array of properties that it finds.
+	*/
+	this.parseProperties = function(fragment) {
 		var properties = {};
-		for (var item in fragment) {
-			if ((fragment[item] == fragment.tagName) || (fragment[item] == fragment.nodeRef)) {
-			} else {
-				var frag = fragment[item];
-				if (frag.tagName && dojo.widget.tags[frag.tagName.toLowerCase()]) {
-				} else {
-					if (frag[0] && frag[0].value != "" && frag[0].value != null) {
-						try {
-							if (item.toLowerCase() == "dataprovider") {
-								var _this = this;
-								this.getDataProvider(_this, frag[0].value);
-								properties.dataProvider = this.dataProvider;
-							}
-							properties[item] = frag[0].value;
-							var nestedProperties = this.parseProperties(frag);
-							for (var property in nestedProperties) {
-								properties[property] = nestedProperties[property];
-							}
+		for(var item in fragment){
+			// FIXME: need to check for undefined?
+			// case: its a tagName or nodeRef
+			if((fragment[item] == fragment["tagName"])||
+				(fragment[item] == fragment.nodeRef)){
+				// do nothing
+			}else{
+				if((fragment[item]["tagName"])&&
+					(dojo.widget.tags[fragment[item].tagName.toLowerCase()])){
+					// TODO: it isn't a property or property set, it's a fragment, 
+					// so do something else
+					// FIXME: needs to be a better/stricter check
+					// TODO: handle xlink:href for external property sets
+				}else if((fragment[item][0])&&(fragment[item][0].value!="")&&(fragment[item][0].value!=null)){
+					try{
+						// FIXME: need to allow more than one provider
+						if(item.toLowerCase() == "dataprovider") {
+							var _this = this;
+							this.getDataProvider(_this, fragment[item][0].value);
+							properties.dataProvider = this.dataProvider;
 						}
-						catch (e) {
-							dojo.debug(e);
+						properties[item] = fragment[item][0].value;
+						var nestedProperties = this.parseProperties(fragment[item]);
+						// FIXME: this kind of copying is expensive and inefficient!
+						for(var property in nestedProperties){
+							properties[property] = nestedProperties[property];
 						}
-					}
+					}catch(e){ dojo.debug(e); }
 				}
-				switch (item.toLowerCase()) {
-				  case "checked":
-				  case "disabled":
-					if (typeof properties[item] != "boolean") {
-						properties[item] = true;
-					}
-					break;
-				}
 			}
 		}
 		return properties;
-	};
-	this.getDataProvider = function (objRef, dataUrl) {
-		dojo.io.bind({url:dataUrl, load:function (type, evaldObj) {
-			if (type == "load") {
-				objRef.dataProvider = evaldObj;
-			}
-		}, mimetype:"text/javascript", sync:true});
-	};
-	this.getPropertySetById = function (propertySetId) {
-		for (var x = 0; x < this.propertySetsList.length; x++) {
-			if (propertySetId == this.propertySetsList[x]["id"][0].value) {
+	}
+
+	/* getPropertySetById returns the propertySet that matches the provided id
+	*/
+	
+	this.getDataProvider = function(objRef, dataUrl) {
+		// FIXME: this is currently sync.  To make this async, we made need to move 
+		//this step into the widget ctor, so that it is loaded when it is needed 
+		// to populate the widget
+		dojo.io.bind({
+			url: dataUrl,
+			load: function(type, evaldObj){
+				if(type=="load"){
+					objRef.dataProvider = evaldObj;
+				}
+			},
+			mimetype: "text/javascript",
+			sync: true
+		});
+	}
+
+	
+	this.getPropertySetById = function(propertySetId){
+		for(var x = 0; x < this.propertySetsList.length; x++){
+			if(propertySetId == this.propertySetsList[x]["id"][0].value){
 				return this.propertySetsList[x];
 			}
 		}
 		return "";
-	};
-	this.getPropertySetsByType = function (componentType) {
+	}
+	
+	/* getPropertySetsByType returns the propertySet(s) that match(es) the
+	 * provided componentClass
+	 */
+	this.getPropertySetsByType = function(componentType){
 		var propertySets = [];
-		for (var x = 0; x < this.propertySetsList.length; x++) {
+		for(var x=0; x < this.propertySetsList.length; x++){
 			var cpl = this.propertySetsList[x];
-			var cpcc = cpl.componentClass || cpl.componentType || null;
-			var propertySetId = this.propertySetsList[x]["id"][0].value;
-			if (cpcc && (propertySetId == cpcc[0].value)) {
+			var cpcc = cpl["componentClass"]||cpl["componentType"]||null;
+			// FIXME: propertySetId is not in scope here
+			if((cpcc)&&(propertySetId == cpcc[0].value)){
 				propertySets.push(cpl);
 			}
 		}
 		return propertySets;
-	};
-	this.getPropertySets = function (fragment) {
+	}
+	
+	/* getPropertySets returns the propertySet for a given component fragment
+	*/
+	this.getPropertySets = function(fragment){
 		var ppl = "dojo:propertyproviderlist";
 		var propertySets = [];
-		var tagname = fragment.tagName;
-		if (fragment[ppl]) {
+		var tagname = fragment["tagName"];
+		if(fragment[ppl]){ 
 			var propertyProviderIds = fragment[ppl].value.split(" ");
-			for (var propertySetId in propertyProviderIds) {
-				if ((propertySetId.indexOf("..") == -1) && (propertySetId.indexOf("://") == -1)) {
+			// FIXME: should the propertyProviderList attribute contain #
+			// 		  syntax for reference to ids or not?
+			// FIXME: need a better test to see if this is local or external
+			// FIXME: doesn't handle nested propertySets, or propertySets that
+			// 		  just contain information about css documents, etc.
+			for(var propertySetId in propertyProviderIds){
+				if((propertySetId.indexOf("..")==-1)&&(propertySetId.indexOf("://")==-1)){
+					// get a reference to a propertySet within the current parsed structure
 					var propertySet = this.getPropertySetById(propertySetId);
-					if (propertySet != "") {
+					if(propertySet != ""){
 						propertySets.push(propertySet);
 					}
-				} else {
+				}else{
+					// FIXME: add code to parse and return a propertySet from
+					// another document
+					// alex: is this even necessaray? Do we care? If so, why?
 				}
 			}
 		}
-		return this.getPropertySetsByType(tagname).concat(propertySets);
-	};
-	this.createComponentFromScript = function (nodeRef, componentName, properties, ns) {
-		properties.fastMixIn = true;
-		var ltn = (ns || "dojo") + ":" + componentName.toLowerCase();
-		if (dojo.widget.tags[ltn]) {
+		// we put the typed ones first so that the parsed ones override when
+		// iteration happens.
+		return (this.getPropertySetsByType(tagname)).concat(propertySets);
+	}
+	
+	/* 
+		nodeRef is the node to be replaced... in the future, we might want to add 
+		an alternative way to specify an insertion point
+
+		componentName is the expected dojo widget name, i.e. Button of ContextMenu
+
+		properties is an object of name value pairs
+	*/
+	this.createComponentFromScript = function(nodeRef, componentName, properties){
+		var ltn = "dojo:" + componentName.toLowerCase();
+		if(dojo.widget.tags[ltn]){
+			properties.fastMixIn = true;
 			return [dojo.widget.tags[ltn](properties, this, null, null, properties)];
+		}else{
+			if(ltn.substr(0, 5)=="dojo:"){
+				dojo.debug("no tag handler registed for type: ", ltn);
+			}
 		}
-		return [dojo.widget.buildWidgetFromParseTree(ltn, properties, this, null, null, properties)];
-	};
-};
-dojo.widget._parser_collection = {"dojo":new dojo.widget.Parse()};
-dojo.widget.getParser = function (name) {
-	if (!name) {
-		name = "dojo";
 	}
-	if (!this._parser_collection[name]) {
+}
+
+
+dojo.widget._parser_collection = {"dojo": new dojo.widget.Parse() };
+dojo.widget.getParser = function(name){
+	if(!name){ name = "dojo"; }
+	if(!this._parser_collection[name]){
 		this._parser_collection[name] = new dojo.widget.Parse();
 	}
 	return this._parser_collection[name];
-};
-dojo.widget.createWidget = function (name, props, refNode, position) {
-	var isNode = false;
-	var isNameStr = (typeof name == "string");
-	if (isNameStr) {
-		var pos = name.indexOf(":");
-		var ns = (pos > -1) ? name.substring(0, pos) : "dojo";
-		if (pos > -1) {
-			name = name.substring(pos + 1);
-		}
-		var lowerCaseName = name.toLowerCase();
-		var namespacedName = ns + ":" + lowerCaseName;
-		isNode = (dojo.byId(name) && !dojo.widget.tags[namespacedName]);
-	}
-	if ((arguments.length == 1) && (isNode || !isNameStr)) {
+}
+
+/**
+ * Creates widget.
+ *
+ * @param name     The name of the widget to create
+ * @param props    Key-Value pairs of properties of the widget
+ * @param refNode  If the last argument is specified this node is used as
+ *                 a reference for inserting this node into a DOM tree else
+ *                 it beomces the domNode
+ * @param position The position to insert this widget's node relative to the
+ *                 refNode argument
+ * @return The new Widget object
+ */
+ 
+dojo.widget.createWidget = function(name, props, refNode, position){
+	var lowerCaseName = name.toLowerCase();
+	var namespacedName = "dojo:" + lowerCaseName;
+	var isNode = ( dojo.byId(name) && (!dojo.widget.tags[namespacedName]) );
+
+	// if we got a node or an unambiguious ID, build a widget out of it
+	if(	(arguments.length==1) && ((typeof name != "string")||(isNode)) ){
+		// we got a DOM node
 		var xp = new dojo.xml.Parse();
-		var tn = isNode ? dojo.byId(name) : name;
+		// FIXME: we should try to find the parent!
+		var tn = (isNode) ? dojo.byId(name) : name;
 		return dojo.widget.getParser().createComponents(xp.parseElement(tn, null, true))[0];
 	}
-	function fromScript(placeKeeperNode, name, props, ns) {
-		props[namespacedName] = {dojotype:[{value:lowerCaseName}], nodeRef:placeKeeperNode, fastMixIn:true};
-		props.ns = ns;
-		return dojo.widget.getParser().createComponentFromScript(placeKeeperNode, name, props, ns);
+
+	function fromScript (placeKeeperNode, name, props) {
+		props[namespacedName] = { 
+			dojotype: [{value: lowerCaseName}],
+			nodeRef: placeKeeperNode,
+			fastMixIn: true
+		};
+		return dojo.widget.getParser().createComponentFromScript(
+			placeKeeperNode, name, props, true);
 	}
-	props = props || {};
+
+	if (typeof name != "string" && typeof props == "string") {
+		dojo.deprecated("dojo.widget.createWidget", 
+			"argument order is now of the form " +
+			"dojo.widget.createWidget(NAME, [PROPERTIES, [REFERENCENODE, [POSITION]]])", "0.4");
+		return fromScript(name, props, refNode);
+	}
+	
+	props = props||{};
 	var notRef = false;
 	var tn = null;
 	var h = dojo.render.html.capable;
-	if (h) {
+	if(h){
 		tn = document.createElement("span");
 	}
-	if (!refNode) {
+	if(!refNode){
 		notRef = true;
 		refNode = tn;
-		if (h) {
-			dojo.body().appendChild(refNode);
+		if(h){
+			document.body.appendChild(refNode);
 		}
-	} else {
-		if (position) {
-			dojo.dom.insertAtPosition(tn, refNode, position);
-		} else {
-			tn = refNode;
-		}
+	}else if(position){
+		dojo.dom.insertAtPosition(tn, refNode, position);
+	}else{ // otherwise don't replace, but build in-place
+		tn = refNode;
 	}
-	var widgetArray = fromScript(tn, name.toLowerCase(), props, ns);
-	if ((!widgetArray) || (!widgetArray[0]) || (typeof widgetArray[0].widgetType == "undefined")) {
+	var widgetArray = fromScript(tn, name, props);
+	if (!widgetArray || !widgetArray[0] || typeof widgetArray[0].widgetType == "undefined") {
 		throw new Error("createWidget: Creation of \"" + name + "\" widget failed.");
 	}
-	try {
-		if (notRef && widgetArray[0].domNode.parentNode) {
+	if (notRef) {
+		if (widgetArray[0].domNode.parentNode) {
 			widgetArray[0].domNode.parentNode.removeChild(widgetArray[0].domNode);
 		}
 	}
-	catch (e) {
-		dojo.debug(e);
-	}
-	return widgetArray[0];
-};
-
+	return widgetArray[0]; // just return the widget
+}
+ 
+dojo.widget.fromScript = function(name, props, refNode, position){
+	dojo.deprecated("dojo.widget.fromScript", " use " +
+		"dojo.widget.createWidget instead", "0.4");
+	return dojo.widget.createWidget(name, props, refNode, position);
+}

Added: tags/parley-0.53/root/static/magic/src/widget/PopUpButton.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/PopUpButton.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/PopUpButton.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,192 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.PopUpButton");
+dojo.provide("dojo.widget.DomPopUpButton");
+dojo.provide("dojo.widget.HtmlPopUpButton");
+
+dojo.deprecated("dojo.widget.PopUpButton, dojo.widget.DomPopUpButton, dojo.widget.HtmlPopUpButton",  "use dojo.widget.DropDownButton", "0.4");
+
+//dojo.require("dojo.widget.Button");
+//dojo.require("dojo.widget.HtmlButton");
+
+dojo.require("dojo.widget.Menu");
+dojo.require("dojo.widget.MenuItem");
+
+dojo.require("dojo.html");
+
+dojo.widget.tags.addParseTreeHandler("dojo:PopUpButton");
+
+/* PopUpButton
+ **************/
+ 
+dojo.widget.PopUpButton = function () {
+	dojo.widget.PopUpButton.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.PopUpButton, dojo.widget.Widget);
+
+dojo.lang.extend(dojo.widget.PopUpButton, {
+	widgetType: "PopUpButton",
+	
+	label: ""
+});
+
+
+/* DomPopUpButton
+ *****************/
+dojo.widget.DomPopUpButton = function(){
+	dojo.widget.DomPopUpButton.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.DomPopUpButton, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.DomPopUpButton, {
+	widgetType: dojo.widget.PopUpButton.prototype.widgetType
+});
+
+
+/* HtmlPopUpButton
+ ******************/
+
+dojo.widget.HtmlPopUpButton = function () {
+	dojo.widget.HtmlPopUpButton.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.HtmlPopUpButton, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.HtmlPopUpButton, {
+	widgetType: dojo.widget.PopUpButton.prototype.widgetType,
+	templateString: null,
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/PopUpButton.css"),
+	
+	buildRendering: function (args, frag) {
+		dojo.style.insertCssFile(this.templateCssPath, null, true);
+	
+		this.domNode = document.createElement("a");
+		this.domNode.className = "PopUpButton";
+		dojo.event.connect(this.domNode, "onmousedown", this, "onMouseDown");
+		
+		// draw the arrow
+		var arrow = document.createElement("img");
+		arrow.src = dojo.uri.dojoUri("src/widget/templates/images/dropdownButtonsArrow.gif");
+		dojo.html.setClass(arrow, "downArrow");
+		this.domNode.appendChild(arrow);
+
+		this.menu = dojo.widget.fromScript("Menu");
+		dojo.html.addClass(this.menu.domNode, "PopUpButtonMenu");
+		dojo.event.connect(this.menu, "onSelect", this, "onSelect");
+		
+		if (frag["dojo:" + this.widgetType.toLowerCase()].nodeRef) {
+			var node = frag["dojo:" + this.widgetType.toLowerCase()].nodeRef;
+			var options = node.getElementsByTagName("option");
+			for (var i = 0; i < options.length; i++) {
+				var properties = {
+					title: dojo.dom.textContent(options[i]),
+					value: options[i].value
+				}
+				this.addItem(dojo.widget.fromScript("MenuItem", properties));
+			}
+		}
+	},
+
+	addItem: function (item) {
+		// TODO: should be dojo.widget.MenuItem
+		if (item instanceof dojo.widget.html.MenuItem) {
+			this.menu.push(item);
+		} else {
+			// TODO: create one
+			var menuItem = dojo.widget.fromScript("MenuItem", {title: item});
+			this.menu.push(menuItem);
+		}
+	},
+	
+	
+/* Enabled utility methods
+ **************************/
+	
+	_enabled: true,
+	
+	isEnabled: function() { return this._enabled; },
+	
+	setEnabled: function(enabled, force, preventEvent) {
+		enabled = Boolean(enabled);
+		if (force || this._enabled != enabled) {
+			this._enabled = enabled;
+			if (!preventEvent) {
+				this._fireEvent(this._enabled ? "onEnable" : "onDisable");
+				this._fireEvent("onChangeEnabled");
+			}
+		}
+		
+		dojo.html[(this._enabled ? "add" : "remove")
+			+ "Class"](this.domNode, "disabled");
+		
+		return this._enabled;
+	},
+	
+	enable: function(force, preventEvent) {
+		return this.setEnabled(true, force, preventEvent);
+	},
+	
+	disable: function(force, preventEvent) {
+		return this.setEnabled(false, force, preventEvent);
+	},
+	
+	toggleEnabled: function(force, preventEvent) {
+		return this.setEnabled(!this._enabled, force, preventEvent);
+	},
+
+
+/* Select utility methods
+ **************************/
+
+	onSelect: function (item, e) {
+		this.domNode.firstChild.nodeValue = item.title;
+	},
+	
+	onMouseDown: function (e) {
+		if (!this._menuVisible) {
+			this._showMenu(e);
+			dojo.lang.setTimeout(dojo.event.connect, 1, document, "onmousedown", this, "_hideMenu");
+		}
+	},
+	
+	
+	_fireEvent: function(evt) {
+		if(typeof this[evt] == "function") {
+			var args = [this];
+			for(var i = 1; i < arguments.length; i++) {
+				args.push(arguments[i]);
+			}
+			this[evt].apply(this, args);
+		}
+	},
+
+	
+	_showMenu: function (e) {
+		if (!this._enabled) { return; }
+		this._menuVisible = true;
+		with (dojo.html) {
+			var y = getAbsoluteY(this.domNode) + getInnerHeight(this.domNode);
+			var x = getAbsoluteX(this.domNode);
+		}
+	
+		document.body.appendChild(this.menu.domNode);
+		with (this.menu.domNode.style) {
+			top = y + "px";
+			left = x + "px";
+		}
+	},
+	
+	_hideMenu: function (e) {
+		this.menu.domNode.parentNode.removeChild(this.menu.domNode);
+		dojo.event.disconnect(document, "onmousedown", this, "_hideMenu");
+		this._menuVisible = false;
+	}
+
+});

Deleted: tags/parley-0.53/root/static/magic/src/widget/PopupContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/PopupContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/PopupContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,297 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.PopupContainer");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.html.iframe");
-dojo.require("dojo.event.*");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.declare("dojo.widget.PopupContainerBase", null, function () {
-	this.queueOnAnimationFinish = [];
-}, {isShowingNow:false, currentSubpopup:null, beginZIndex:1000, parentPopup:null, parent:null, popupIndex:0, aroundBox:dojo.html.boxSizing.BORDER_BOX, openedForWindow:null, processKey:function (evt) {
-	return false;
-}, applyPopupBasicStyle:function () {
-	with (this.domNode.style) {
-		display = "none";
-		position = "absolute";
-	}
-}, aboutToShow:function () {
-}, open:function (x, y, parent, explodeSrc, orient, padding) {
-	if (this.isShowingNow) {
-		return;
-	}
-	if (this.animationInProgress) {
-		this.queueOnAnimationFinish.push(this.open, arguments);
-		return;
-	}
-	this.aboutToShow();
-	var around = false, node, aroundOrient;
-	if (typeof x == "object") {
-		node = x;
-		aroundOrient = explodeSrc;
-		explodeSrc = parent;
-		parent = y;
-		around = true;
-	}
-	this.parent = parent;
-	dojo.body().appendChild(this.domNode);
-	explodeSrc = explodeSrc || parent["domNode"] || [];
-	var parentPopup = null;
-	this.isTopLevel = true;
-	while (parent) {
-		if (parent !== this && (parent.setOpenedSubpopup != undefined && parent.applyPopupBasicStyle != undefined)) {
-			parentPopup = parent;
-			this.isTopLevel = false;
-			parentPopup.setOpenedSubpopup(this);
-			break;
-		}
-		parent = parent.parent;
-	}
-	this.parentPopup = parentPopup;
-	this.popupIndex = parentPopup ? parentPopup.popupIndex + 1 : 1;
-	if (this.isTopLevel) {
-		var button = dojo.html.isNode(explodeSrc) ? explodeSrc : null;
-		dojo.widget.PopupManager.opened(this, button);
-	}
-	if (this.isTopLevel && !dojo.withGlobal(this.openedForWindow || dojo.global(), dojo.html.selection.isCollapsed)) {
-		this._bookmark = dojo.withGlobal(this.openedForWindow || dojo.global(), dojo.html.selection.getBookmark);
-	} else {
-		this._bookmark = null;
-	}
-	if (explodeSrc instanceof Array) {
-		explodeSrc = {left:explodeSrc[0], top:explodeSrc[1], width:0, height:0};
-	}
-	with (this.domNode.style) {
-		display = "";
-		zIndex = this.beginZIndex + this.popupIndex;
-	}
-	if (around) {
-		this.move(node, padding, aroundOrient);
-	} else {
-		this.move(x, y, padding, orient);
-	}
-	this.domNode.style.display = "none";
-	this.explodeSrc = explodeSrc;
-	this.show();
-	this.isShowingNow = true;
-}, move:function (x, y, padding, orient) {
-	var around = (typeof x == "object");
-	if (around) {
-		var aroundOrient = padding;
-		var node = x;
-		padding = y;
-		if (!aroundOrient) {
-			aroundOrient = {"BL":"TL", "TL":"BL"};
-		}
-		dojo.html.placeOnScreenAroundElement(this.domNode, node, padding, this.aroundBox, aroundOrient);
-	} else {
-		if (!orient) {
-			orient = "TL,TR,BL,BR";
-		}
-		dojo.html.placeOnScreen(this.domNode, x, y, padding, true, orient);
-	}
-}, close:function (force) {
-	if (force) {
-		this.domNode.style.display = "none";
-	}
-	if (this.animationInProgress) {
-		this.queueOnAnimationFinish.push(this.close, []);
-		return;
-	}
-	this.closeSubpopup(force);
-	this.hide();
-	if (this.bgIframe) {
-		this.bgIframe.hide();
-		this.bgIframe.size({left:0, top:0, width:0, height:0});
-	}
-	if (this.isTopLevel) {
-		dojo.widget.PopupManager.closed(this);
-	}
-	this.isShowingNow = false;
-	if (this.parent) {
-		setTimeout(dojo.lang.hitch(this, function () {
-			try {
-				if (this.parent["focus"]) {
-					this.parent.focus();
-				} else {
-					this.parent.domNode.focus();
-				}
-			}
-			catch (e) {
-				dojo.debug("No idea how to focus to parent", e);
-			}
-		}), 10);
-	}
-	if (this._bookmark && dojo.withGlobal(this.openedForWindow || dojo.global(), dojo.html.selection.isCollapsed)) {
-		if (this.openedForWindow) {
-			this.openedForWindow.focus();
-		}
-		try {
-			dojo.withGlobal(this.openedForWindow || dojo.global(), "moveToBookmark", dojo.html.selection, [this._bookmark]);
-		}
-		catch (e) {
-		}
-	}
-	this._bookmark = null;
-}, closeAll:function (force) {
-	if (this.parentPopup) {
-		this.parentPopup.closeAll(force);
-	} else {
-		this.close(force);
-	}
-}, setOpenedSubpopup:function (popup) {
-	this.currentSubpopup = popup;
-}, closeSubpopup:function (force) {
-	if (this.currentSubpopup == null) {
-		return;
-	}
-	this.currentSubpopup.close(force);
-	this.currentSubpopup = null;
-}, onShow:function () {
-	dojo.widget.PopupContainer.superclass.onShow.apply(this, arguments);
-	this.openedSize = {w:this.domNode.style.width, h:this.domNode.style.height};
-	if (dojo.render.html.ie) {
-		if (!this.bgIframe) {
-			this.bgIframe = new dojo.html.BackgroundIframe();
-			this.bgIframe.setZIndex(this.domNode);
-		}
-		this.bgIframe.size(this.domNode);
-		this.bgIframe.show();
-	}
-	this.processQueue();
-}, processQueue:function () {
-	if (!this.queueOnAnimationFinish.length) {
-		return;
-	}
-	var func = this.queueOnAnimationFinish.shift();
-	var args = this.queueOnAnimationFinish.shift();
-	func.apply(this, args);
-}, onHide:function () {
-	dojo.widget.HtmlWidget.prototype.onHide.call(this);
-	if (this.openedSize) {
-		with (this.domNode.style) {
-			width = this.openedSize.w;
-			height = this.openedSize.h;
-		}
-	}
-	this.processQueue();
-}});
-dojo.widget.defineWidget("dojo.widget.PopupContainer", [dojo.widget.HtmlWidget, dojo.widget.PopupContainerBase], {isContainer:true, fillInTemplate:function () {
-	this.applyPopupBasicStyle();
-	dojo.widget.PopupContainer.superclass.fillInTemplate.apply(this, arguments);
-}});
-dojo.widget.PopupManager = new function () {
-	this.currentMenu = null;
-	this.currentButton = null;
-	this.currentFocusMenu = null;
-	this.focusNode = null;
-	this.registeredWindows = [];
-	this.registerWin = function (win) {
-		if (!win.__PopupManagerRegistered) {
-			dojo.event.connect(win.document, "onmousedown", this, "onClick");
-			dojo.event.connect(win, "onscroll", this, "onClick");
-			dojo.event.connect(win.document, "onkey", this, "onKey");
-			win.__PopupManagerRegistered = true;
-			this.registeredWindows.push(win);
-		}
-	};
-	this.registerAllWindows = function (targetWindow) {
-		if (!targetWindow) {
-			targetWindow = dojo.html.getDocumentWindow(window.top && window.top.document || window.document);
-		}
-		this.registerWin(targetWindow);
-		for (var i = 0; i < targetWindow.frames.length; i++) {
-			try {
-				var win = dojo.html.getDocumentWindow(targetWindow.frames[i].document);
-				if (win) {
-					this.registerAllWindows(win);
-				}
-			}
-			catch (e) {
-			}
-		}
-	};
-	this.unRegisterWin = function (win) {
-		if (win.__PopupManagerRegistered) {
-			dojo.event.disconnect(win.document, "onmousedown", this, "onClick");
-			dojo.event.disconnect(win, "onscroll", this, "onClick");
-			dojo.event.disconnect(win.document, "onkey", this, "onKey");
-			win.__PopupManagerRegistered = false;
-		}
-	};
-	this.unRegisterAllWindows = function () {
-		for (var i = 0; i < this.registeredWindows.length; ++i) {
-			this.unRegisterWin(this.registeredWindows[i]);
-		}
-		this.registeredWindows = [];
-	};
-	dojo.addOnLoad(this, "registerAllWindows");
-	dojo.addOnUnload(this, "unRegisterAllWindows");
-	this.closed = function (menu) {
-		if (this.currentMenu == menu) {
-			this.currentMenu = null;
-			this.currentButton = null;
-			this.currentFocusMenu = null;
-		}
-	};
-	this.opened = function (menu, button) {
-		if (menu == this.currentMenu) {
-			return;
-		}
-		if (this.currentMenu) {
-			this.currentMenu.close();
-		}
-		this.currentMenu = menu;
-		this.currentFocusMenu = menu;
-		this.currentButton = button;
-	};
-	this.setFocusedMenu = function (menu) {
-		this.currentFocusMenu = menu;
-	};
-	this.onKey = function (e) {
-		if (!e.key) {
-			return;
-		}
-		if (!this.currentMenu || !this.currentMenu.isShowingNow) {
-			return;
-		}
-		var m = this.currentFocusMenu;
-		while (m) {
-			if (m.processKey(e)) {
-				e.preventDefault();
-				e.stopPropagation();
-				break;
-			}
-			m = m.parentPopup || m.parentMenu;
-		}
-	}, this.onClick = function (e) {
-		if (!this.currentMenu) {
-			return;
-		}
-		var scrolloffset = dojo.html.getScroll().offset;
-		var m = this.currentMenu;
-		while (m) {
-			if (dojo.html.overElement(m.domNode, e) || dojo.html.isDescendantOf(e.target, m.domNode)) {
-				return;
-			}
-			m = m.currentSubpopup;
-		}
-		if (this.currentButton && dojo.html.overElement(this.currentButton, e)) {
-			return;
-		}
-		this.currentMenu.closeAll(true);
-	};
-};
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/ProgressBar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ProgressBar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ProgressBar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,187 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.ProgressBar");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.event");
-dojo.require("dojo.dom");
-dojo.require("dojo.html.style");
-dojo.require("dojo.string.*");
-dojo.require("dojo.lfx.*");
-dojo.widget.defineWidget("dojo.widget.ProgressBar", dojo.widget.HtmlWidget, {progressValue:0, maxProgressValue:100, width:300, height:30, frontPercentClass:"frontPercent", backPercentClass:"backPercent", frontBarClass:"frontBar", backBarClass:"backBar", hasText:false, isVertical:false, showOnlyIntegers:false, dataSource:"", pollInterval:3000, duration:1000, templateString:"<div dojoAttachPoint=\"containerNode\" style=\"position:relative;overflow:hidden\">\n\t<div style=\"position:absolute;display:none;width:100%;text-align:center\" dojoAttachPoint=\"backPercentLabel\" class=\"dojoBackPercentLabel\"></div>\n\t<div style=\"position:absolute;overflow:hidden;width:100%;height:100%\" dojoAttachPoint=\"internalProgress\">\n\t<div style=\"position:absolute;display:none;width:100%;text-align:center\" dojoAttachPoint=\"frontPercentLabel\" class=\"dojoFrontPercentLabel\"></div></div>\n</div>\n", templateCssString:".backBar{\n\tborder:1px solid #84a3d1;\n}\n.frontBar{\n\tbackground:ur!
 l(\"images/bar.gif\") repeat bottom left;\n\tbackground-attachment: fixed;\n}\n.h-frontBar{\n\tbackground:url(\"images/h-bar.gif\") repeat bottom left;\n\tbackground-attachment: fixed;\n}\n.simpleFrontBar{\n\tbackground: red;\n}\n.frontPercent,.backPercent{\n\tfont:bold 13px helvetica;\n}\n.backPercent{\n\tcolor:#293a4b;\n}\n.frontPercent{\n\tcolor:#fff;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/ProgressBar.css"), containerNode:null, internalProgress:null, _pixelUnitRatio:0, _pixelPercentRatio:0, _unitPercentRatio:0, _unitPixelRatio:0, _floatDimension:0, _intDimension:0, _progressPercentValue:"0%", _floatMaxProgressValue:0, _dimension:"width", _pixelValue:0, _oInterval:null, _animation:null, _animationStopped:true, _progressValueBak:false, _hasTextBak:false, fillInTemplate:function (args, frag) {
-	this.internalProgress.className = this.frontBarClass;
-	this.containerNode.className = this.backBarClass;
-	if (this.isVertical) {
-		this.internalProgress.style.bottom = "0px";
-		this.internalProgress.style.left = "0px";
-		this._dimension = "height";
-	} else {
-		this.internalProgress.style.top = "0px";
-		this.internalProgress.style.left = "0px";
-		this._dimension = "width";
-	}
-	this.frontPercentLabel.className = this.frontPercentClass;
-	this.backPercentLabel.className = this.backPercentClass;
-	this.progressValue = "" + this.progressValue;
-	this.domNode.style.height = this.height + "px";
-	this.domNode.style.width = this.width + "px";
-	this._intDimension = parseInt("0" + eval("this." + this._dimension));
-	this._floatDimension = parseFloat("0" + eval("this." + this._dimension));
-	this._pixelPercentRatio = this._floatDimension / 100;
-	this.setMaxProgressValue(this.maxProgressValue, true);
-	this.setProgressValue(dojo.string.trim(this.progressValue), true);
-	dojo.debug("float dimension: " + this._floatDimension);
-	dojo.debug("this._unitPixelRatio: " + this._unitPixelRatio);
-	this.showText(this.hasText);
-}, showText:function (visible) {
-	if (visible) {
-		this.backPercentLabel.style.display = "block";
-		this.frontPercentLabel.style.display = "block";
-	} else {
-		this.backPercentLabel.style.display = "none";
-		this.frontPercentLabel.style.display = "none";
-	}
-	this.hasText = visible;
-}, postCreate:function (args, frag) {
-	this.render();
-}, _backupValues:function () {
-	this._progressValueBak = this.progressValue;
-	this._hasTextBak = this.hasText;
-}, _restoreValues:function () {
-	this.setProgressValue(this._progressValueBak);
-	this.showText(this._hasTextBak);
-}, _setupAnimation:function () {
-	var _self = this;
-	dojo.debug("internalProgress width: " + this.internalProgress.style.width);
-	this._animation = dojo.lfx.html.slideTo(this.internalProgress, {top:0, left:parseInt(this.width) - parseInt(this.internalProgress.style.width)}, parseInt(this.duration), null, function () {
-		var _backAnim = dojo.lfx.html.slideTo(_self.internalProgress, {top:0, left:0}, parseInt(_self.duration));
-		dojo.event.connect(_backAnim, "onEnd", function () {
-			if (!_self._animationStopped) {
-				_self._animation.play();
-			}
-		});
-		if (!_self._animationStopped) {
-			_backAnim.play();
-		}
-		_backAnim = null;
-	});
-}, getMaxProgressValue:function () {
-	return this.maxProgressValue;
-}, setMaxProgressValue:function (maxValue, noRender) {
-	if (!this._animationStopped) {
-		return;
-	}
-	this.maxProgressValue = maxValue;
-	this._floatMaxProgressValue = parseFloat("0" + this.maxProgressValue);
-	this._pixelUnitRatio = this._floatDimension / this.maxProgressValue;
-	this._unitPercentRatio = this._floatMaxProgressValue / 100;
-	this._unitPixelRatio = this._floatMaxProgressValue / this._floatDimension;
-	this.setProgressValue(this.progressValue, true);
-	if (!noRender) {
-		this.render();
-	}
-}, setProgressValue:function (value, noRender) {
-	if (!this._animationStopped) {
-		return;
-	}
-	this._progressPercentValue = "0%";
-	var _value = dojo.string.trim("" + value);
-	var _floatValue = parseFloat("0" + _value);
-	var _intValue = parseInt("0" + _value);
-	var _pixelValue = 0;
-	if (dojo.string.endsWith(_value, "%", false)) {
-		this._progressPercentValue = Math.min(_floatValue.toFixed(1), 100) + "%";
-		_value = Math.min((_floatValue) * this._unitPercentRatio, this.maxProgressValue);
-		_pixelValue = Math.min((_floatValue) * this._pixelPercentRatio, eval("this." + this._dimension));
-	} else {
-		this.progressValue = Math.min(_floatValue, this.maxProgressValue);
-		this._progressPercentValue = Math.min((_floatValue / this._unitPercentRatio).toFixed(1), 100) + "%";
-		_pixelValue = Math.min(_floatValue / this._unitPixelRatio, eval("this." + this._dimension));
-	}
-	this.progressValue = dojo.string.trim(_value);
-	this._pixelValue = _pixelValue;
-	if (!noRender) {
-		this.render();
-	}
-}, getProgressValue:function () {
-	return this.progressValue;
-}, getProgressPercentValue:function () {
-	return this._progressPercentValue;
-}, setDataSource:function (dataSource) {
-	this.dataSource = dataSource;
-}, setPollInterval:function (pollInterval) {
-	this.pollInterval = pollInterval;
-}, start:function () {
-	var _showFunction = dojo.lang.hitch(this, this._showRemoteProgress);
-	this._oInterval = setInterval(_showFunction, this.pollInterval);
-}, startAnimation:function () {
-	if (this._animationStopped) {
-		this._backupValues();
-		this.setProgressValue("10%");
-		this._animationStopped = false;
-		this._setupAnimation();
-		this.showText(false);
-		this.internalProgress.style.height = "105%";
-		this._animation.play();
-	}
-}, stopAnimation:function () {
-	if (this._animation) {
-		this._animationStopped = true;
-		this._animation.stop();
-		this.internalProgress.style.height = "100%";
-		this.internalProgress.style.left = "0px";
-		this._restoreValues();
-		this._setLabelPosition();
-	}
-}, _showRemoteProgress:function () {
-	var _self = this;
-	if ((this.getMaxProgressValue() == this.getProgressValue()) && this._oInterval) {
-		clearInterval(this._oInterval);
-		this._oInterval = null;
-		this.setProgressValue("100%");
-		return;
-	}
-	var bArgs = {url:_self.dataSource, method:"POST", mimetype:"text/json", error:function (type, errorObj) {
-		dojo.debug("[ProgressBar] showRemoteProgress error");
-	}, load:function (type, data, evt) {
-		_self.setProgressValue((_self._oInterval ? data["progress"] : "100%"));
-	}};
-	dojo.io.bind(bArgs);
-}, render:function () {
-	this._setPercentLabel(dojo.string.trim(this._progressPercentValue));
-	this._setPixelValue(this._pixelValue);
-	this._setLabelPosition();
-}, _setLabelPosition:function () {
-	var _widthFront = dojo.html.getContentBox(this.frontPercentLabel).width;
-	var _heightFront = dojo.html.getContentBox(this.frontPercentLabel).height;
-	var _widthBack = dojo.html.getContentBox(this.backPercentLabel).width;
-	var _heightBack = dojo.html.getContentBox(this.backPercentLabel).height;
-	var _leftFront = (parseInt(this.width) - _widthFront) / 2 + "px";
-	var _bottomFront = (parseInt(this.height) - parseInt(_heightFront)) / 2 + "px";
-	var _leftBack = (parseInt(this.width) - _widthBack) / 2 + "px";
-	var _bottomBack = (parseInt(this.height) - parseInt(_heightBack)) / 2 + "px";
-	this.frontPercentLabel.style.left = _leftFront;
-	this.backPercentLabel.style.left = _leftBack;
-	this.frontPercentLabel.style.bottom = _bottomFront;
-	this.backPercentLabel.style.bottom = _bottomBack;
-}, _setPercentLabel:function (percentValue) {
-	dojo.dom.removeChildren(this.frontPercentLabel);
-	dojo.dom.removeChildren(this.backPercentLabel);
-	var _percentValue = this.showOnlyIntegers == false ? percentValue : parseInt(percentValue) + "%";
-	this.frontPercentLabel.appendChild(document.createTextNode(_percentValue));
-	this.backPercentLabel.appendChild(document.createTextNode(_percentValue));
-}, _setPixelValue:function (value) {
-	eval("this.internalProgress.style." + this._dimension + " = " + value + " + 'px'");
-	this.onChange();
-}, onChange:function () {
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/RadioGroup.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/RadioGroup.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/RadioGroup.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,122 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.RadioGroup");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.event.browser");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.RadioGroup", dojo.widget.HtmlWidget, function () {
-	this.selectedItem = null;
-	this.items = [];
-	this.selected = [];
-	this.groupCssClass = "radioGroup";
-	this.selectedCssClass = "selected";
-	this.itemContentCssClass = "itemContent";
-}, {isContainer:false, templatePath:null, templateCssPath:null, postCreate:function () {
-	this._parseStructure();
-	dojo.html.addClass(this.domNode, this.groupCssClass);
-	this._setupChildren();
-	dojo.event.browser.addListener(this.domNode, "onclick", dojo.lang.hitch(this, "onSelect"));
-	if (this.selectedItem) {
-		this._selectItem(this.selectedItem);
-	}
-}, _parseStructure:function () {
-	if (this.domNode.tagName.toLowerCase() != "ul" && this.domNode.tagName.toLowerCase() != "ol") {
-		dojo.raise("RadioGroup: Expected ul or ol content.");
-		return;
-	}
-	this.items = [];
-	var nl = this.domNode.getElementsByTagName("li");
-	for (var i = 0; i < nl.length; i++) {
-		if (nl[i].parentNode == this.domNode) {
-			this.items.push(nl[i]);
-		}
-	}
-}, add:function (node) {
-	if (node.parentNode != this.domNode) {
-		this.domNode.appendChild(node);
-	}
-	this.items.push(node);
-	this._setup(node);
-}, remove:function (node) {
-	var idx = -1;
-	for (var i = 0; i < this.items.length; i++) {
-		if (this.items[i] == node) {
-			idx = i;
-			break;
-		}
-	}
-	if (idx < 0) {
-		return;
-	}
-	this.items.splice(idx, 1);
-	node.parentNode.removeChild(node);
-}, clear:function () {
-	for (var i = 0; i < this.items.length; i++) {
-		this.domNode.removeChild(this.items[i]);
-	}
-	this.items = [];
-}, clearSelections:function () {
-	for (var i = 0; i < this.items.length; i++) {
-		dojo.html.removeClass(this.items[i], this.selectedCssClass);
-	}
-	this.selectedItem = null;
-}, _setup:function (node) {
-	var span = document.createElement("span");
-	dojo.html.disableSelection(span);
-	dojo.html.addClass(span, this.itemContentCssClass);
-	dojo.dom.moveChildren(node, span);
-	node.appendChild(span);
-	if (this.selected.length > 0) {
-		var uid = dojo.html.getAttribute(node, "id");
-		if (uid && uid == this.selected) {
-			this.selectedItem = node;
-		}
-	}
-	dojo.event.browser.addListener(node, "onclick", dojo.lang.hitch(this, "onItemSelect"));
-	if (dojo.html.hasAttribute(node, "onitemselect")) {
-		var tn = dojo.lang.nameAnonFunc(new Function(dojo.html.getAttribute(node, "onitemselect")), this);
-		dojo.event.browser.addListener(node, "onclick", dojo.lang.hitch(this, tn));
-	}
-}, _setupChildren:function () {
-	for (var i = 0; i < this.items.length; i++) {
-		this._setup(this.items[i]);
-	}
-}, _selectItem:function (node, event, nofire) {
-	if (this.selectedItem) {
-		dojo.html.removeClass(this.selectedItem, this.selectedCssClass);
-	}
-	this.selectedItem = node;
-	dojo.html.addClass(this.selectedItem, this.selectedCssClass);
-	if (!dj_undef("currentTarget", event)) {
-		return;
-	}
-	if (!nofire) {
-		if (dojo.render.html.ie) {
-			this.selectedItem.fireEvent("onclick");
-		} else {
-			var e = document.createEvent("MouseEvents");
-			e.initEvent("click", true, false);
-			this.selectedItem.dispatchEvent(e);
-		}
-	}
-}, getValue:function () {
-	return this.selectedItem;
-}, onSelect:function (e) {
-}, onItemSelect:function (e) {
-	if (!dj_undef("currentTarget", e)) {
-		this._selectItem(e.currentTarget, e);
-	}
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/RealNumberTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/RealNumberTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/RealNumberTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,50 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.RealNumberTextbox");
-dojo.require("dojo.widget.IntegerTextbox");
-dojo.require("dojo.validate.common");
-dojo.widget.defineWidget("dojo.widget.RealNumberTextbox", dojo.widget.IntegerTextbox, {mixInProperties:function (localProperties, frag) {
-	dojo.widget.RealNumberTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.places) {
-		this.flags.places = Number(localProperties.places);
-	}
-	if ((localProperties.exponent == "true") || (localProperties.exponent == "always")) {
-		this.flags.exponent = true;
-	} else {
-		if ((localProperties.exponent == "false") || (localProperties.exponent == "never")) {
-			this.flags.exponent = false;
-		} else {
-			this.flags.exponent = [true, false];
-		}
-	}
-	if ((localProperties.esigned == "true") || (localProperties.esigned == "always")) {
-		this.flags.eSigned = true;
-	} else {
-		if ((localProperties.esigned == "false") || (localProperties.esigned == "never")) {
-			this.flags.eSigned = false;
-		} else {
-			this.flags.eSigned = [true, false];
-		}
-	}
-	if (localProperties.min) {
-		this.flags.min = parseFloat(localProperties.min);
-	}
-	if (localProperties.max) {
-		this.flags.max = parseFloat(localProperties.max);
-	}
-}, isValid:function () {
-	return dojo.validate.isRealNumber(this.textbox.value, this.flags);
-}, isInRange:function () {
-	return dojo.validate.isInRange(this.textbox.value, this.flags);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/RegexpTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/RegexpTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/RegexpTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,27 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.RegexpTextbox");
-dojo.require("dojo.widget.ValidationTextbox");
-dojo.widget.defineWidget("dojo.widget.RegexpTextbox", dojo.widget.ValidationTextbox, {mixInProperties:function (localProperties, frag) {
-	dojo.widget.RegexpTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.regexp) {
-		this.flags.regexp = localProperties.regexp;
-	}
-	if (localProperties.flags) {
-		this.flags.flags = localProperties.flags;
-	}
-}, isValid:function () {
-	var regexp = new RegExp(this.flags.regexp, this.flags.flags);
-	return regexp.test(this.textbox.value);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/RemoteTabController.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/RemoteTabController.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/RemoteTabController.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,28 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.RemoteTabController");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.TabContainer");
-dojo.require("dojo.event.*");
-dojo.deprecated("dojo.widget.RemoteTabController is slated for removal in 0.5; use PageController or TabController instead.", "0.5");
-dojo.widget.defineWidget("dojo.widget.RemoteTabController", dojo.widget.TabController, {templateCssString:".dojoRemoteTabController {\n\tposition: relative;\n}\n\n.dojoRemoteTab {\n\tposition : relative;\n\tfloat : left;\n\tpadding-left : 9px;\n\tborder-bottom : 1px solid #6290d2;\n\tbackground : url(images/tab_left.gif) no-repeat left top;\n\tcursor: pointer;\n\twhite-space: nowrap;\n\tz-index: 3;\n}\n\n.dojoRemoteTab div {\n\tdisplay : block;\n\tpadding : 4px 15px 4px 6px;\n\tbackground : url(images/tab_top_right.gif) no-repeat right top;\n\tcolor : #333;\n\tfont-size : 90%;\n}\n\n.dojoRemoteTabPaneClose {\n\tposition : absolute;\n\tbottom : 0px;\n\tright : 6px;\n\theight : 12px;\n\twidth : 12px;\n\tbackground : url(images/tab_close.gif) no-repeat right top;\n}\n\n.dojoRemoteTabPaneCloseHover {\n\tbackground-image : url(images/tab_close_h.gif);\n}\n\n.dojoRemoteTabClose {\n\tdisplay : inline-block;\n\theight : 12px;\n\twidth : 12px;\n\tpadding : 0 12px 0 0;\n\tmargin : 0 !
 -10px 0 10px;\n\tbackground : url(images/tab_close.gif) no-repeat right top;\n\tcursor : default;\n}\n\n.dojoRemoteTabCloseHover {\n\tbackground-image : url(images/tab_close_h.gif);\n}\n\n.dojoRemoteTab.current {\n\tpadding-bottom : 1px;\n\tborder-bottom : 0;\n\tbackground-position : 0 -150px;\n}\n\n.dojoRemoteTab.current div {\n\tpadding-bottom : 5px;\n\tmargin-bottom : -1px;\n\tbackground-position : 100% -150px;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/RemoteTabControl.css"), templateString:"<div dojoAttachPoint=\"domNode\" wairole=\"tablist\"></div>", "class":"dojoRemoteTabController", tabContainer:"", postMixInProperties:function () {
-	this.containerId = this.tabContainer;
-	dojo.widget.RemoteTabController.superclass.postMixInProperties.apply(this, arguments);
-}, fillInTemplate:function () {
-	dojo.html.addClass(this.domNode, this["class"]);
-	if (this.tabContainer) {
-		dojo.addOnLoad(dojo.lang.hitch(this, "setupTabs"));
-	}
-	dojo.widget.RemoteTabController.superclass.fillInTemplate.apply(this, arguments);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/Repeater.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Repeater.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Repeater.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,128 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.Repeater");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.string");
-dojo.require("dojo.event.*");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.widget.Repeater");
-dojo.widget.defineWidget("dojo.widget.Repeater", dojo.widget.HtmlWidget, {name:"", rowTemplate:"", myObject:null, pattern:"", useDnd:false, isContainer:true, initialize:function (args, frag) {
-	var node = this.getFragNodeRef(frag);
-	node.removeAttribute("dojotype");
-	this.setRow(dojo.string.trim(node.innerHTML), {});
-	node.innerHTML = "";
-	frag = null;
-}, postCreate:function (args, frag) {
-	if (this.useDnd) {
-		dojo.require("dojo.dnd.*");
-		var dnd = new dojo.dnd.HtmlDropTarget(this.domNode, [this.widgetId]);
-	}
-}, _reIndexRows:function () {
-	for (var i = 0, len = this.domNode.childNodes.length; i < len; i++) {
-		var elems = ["INPUT", "SELECT", "TEXTAREA"];
-		for (var k = 0; k < elems.length; k++) {
-			var list = this.domNode.childNodes[i].getElementsByTagName(elems[k]);
-			for (var j = 0, len2 = list.length; j < len2; j++) {
-				var name = list[j].name;
-				var index = dojo.string.escape("regexp", this.pattern);
-				index = index.replace(/(%\\\{index\\\})/g, "%{index}");
-				var nameRegexp = dojo.string.substituteParams(index, {"index":"[0-9]*"});
-				var newName = dojo.string.substituteParams(this.pattern, {"index":"" + i});
-				var re = new RegExp(nameRegexp, "g");
-				list[j].name = name.replace(re, newName);
-			}
-		}
-	}
-}, onDeleteRow:function (e) {
-	var index = dojo.string.escape("regexp", this.pattern);
-	index = index.replace(/%\\\{index\\\}/g, "%{index}");
-	var nameRegexp = dojo.string.substituteParams(index, {"index":"([0-9]*)"});
-	var re = new RegExp(nameRegexp, "g");
-	this.deleteRow(re.exec(e.target.name)[1]);
-}, hasRows:function () {
-	if (this.domNode.childNodes.length > 0) {
-		return true;
-	}
-	return false;
-}, getRowCount:function () {
-	return this.domNode.childNodes.length;
-}, deleteRow:function (idx) {
-	this.domNode.removeChild(this.domNode.childNodes[idx]);
-	this._reIndexRows();
-}, _changeRowPosition:function (e) {
-	if (e.dragStatus == "dropFailure") {
-		this.domNode.removeChild(e["dragSource"].domNode);
-	} else {
-		if (e.dragStatus == "dropSuccess") {
-		}
-	}
-	this._reIndexRows();
-}, setRow:function (template, myObject) {
-	template = template.replace(/\%\{(index)\}/g, "0");
-	this.rowTemplate = template;
-	this.myObject = myObject;
-}, getRow:function () {
-	return this.rowTemplate;
-}, _initRow:function (node) {
-	if (typeof (node) == "number") {
-		node = this.domNode.childNodes[node];
-	}
-	var elems = ["INPUT", "SELECT", "IMG"];
-	for (var k = 0; k < elems.length; k++) {
-		var list = node.getElementsByTagName(elems[k]);
-		for (var i = 0, len = list.length; i < len; i++) {
-			var child = list[i];
-			if (child.nodeType != 1) {
-				continue;
-			}
-			if (child.getAttribute("rowFunction") != null) {
-				if (typeof (this.myObject[child.getAttribute("rowFunction")]) == "undefined") {
-					dojo.debug("Function " + child.getAttribute("rowFunction") + " not found");
-				} else {
-					this.myObject[child.getAttribute("rowFunction")](child);
-				}
-			} else {
-				if (child.getAttribute("rowAction") != null) {
-					if (child.getAttribute("rowAction") == "delete") {
-						child.name = dojo.string.substituteParams(this.pattern, {"index":"" + (this.getRowCount() - 1)});
-						dojo.event.connect(child, "onclick", this, "onDeleteRow");
-					}
-				}
-			}
-		}
-	}
-}, onAddRow:function (e) {
-}, addRow:function (doInit) {
-	if (typeof (doInit) == "undefined") {
-		doInit = true;
-	}
-	var node = document.createElement("span");
-	node.innerHTML = this.getRow();
-	if (node.childNodes.length == 1) {
-		node = node.childNodes[0];
-	}
-	this.domNode.appendChild(node);
-	var parser = new dojo.xml.Parse();
-	var frag = parser.parseElement(node, null, true);
-	dojo.widget.getParser().createSubComponents(frag, this);
-	this._reIndexRows();
-	if (doInit) {
-		this._initRow(node);
-	}
-	if (this.useDnd) {
-		node = new dojo.dnd.HtmlDragSource(node, this.widgetId);
-		dojo.event.connect(node, "onDragEnd", this, "_changeRowPosition");
-	}
-	this.onAddRow(node);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/ResizableTextarea.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ResizableTextarea.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ResizableTextarea.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,28 +8,103 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.ResizableTextarea");
+dojo.require("dojo.html");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.LayoutContainer");
 dojo.require("dojo.widget.ResizeHandle");
-dojo.widget.defineWidget("dojo.widget.ResizableTextarea", dojo.widget.HtmlWidget, {templateString:"<div>\n\t<div style=\"border: 2px solid black; width: 90%; height: 200px;\"\n\t\tdojoAttachPoint=\"rootLayoutNode\">\n\t\t<div dojoAttachPoint=\"textAreaContainerNode\" \n\t\t\tstyle=\"border: 0px; margin: 0px; overflow: hidden;\">\n\t\t</div>\n\t\t<div dojoAttachPoint=\"statusBarContainerNode\" class=\"statusBar\">\n\t\t\t<div dojoAttachPoint=\"statusLabelNode\" \n\t\t\t\tclass=\"statusPanel\"\n\t\t\t\tstyle=\"padding-right: 0px; z-index: 1;\">drag to resize</div>\n\t\t\t<div dojoAttachPoint=\"resizeHandleNode\"></div>\n\t\t</div>\n\t</div>\n</div>\n", templateCssString:"div.statusBar {\n\tbackground-color: ThreeDFace;\n\theight: 28px;\n\tpadding: 1px;\n\toverflow: hidden;\n\tfont-size: 12px;\n}\n\ndiv.statusPanel {\n\tbackground-color: ThreeDFace;\n\tborder: 1px solid;\n\tborder-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;\n\tmargin: 1px;\n\tpadding: 2px!
  6px;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/ResizableTextarea.css"), fillInTemplate:function (args, frag) {
-	this.textAreaNode = this.getFragNodeRef(frag).cloneNode(true);
-	dojo.body().appendChild(this.domNode);
-	this.rootLayout = dojo.widget.createWidget("LayoutContainer", {minHeight:50, minWidth:100}, this.rootLayoutNode);
-	this.textAreaContainer = dojo.widget.createWidget("LayoutContainer", {layoutAlign:"client"}, this.textAreaContainerNode);
-	this.rootLayout.addChild(this.textAreaContainer);
-	this.textAreaContainer.domNode.appendChild(this.textAreaNode);
-	with (this.textAreaNode.style) {
-		width = "100%";
-		height = "100%";
+
+dojo.widget.tags.addParseTreeHandler("dojo:resizabletextarea");
+
+dojo.widget.ResizableTextarea = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.ResizableTextarea, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.ResizableTextarea, {
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlResizableTextarea.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlResizableTextarea.css"),
+	widgetType: "ResizableTextarea",
+	tagName: "dojo:resizabletextarea",
+	isContainer: false,
+	textAreaNode: null,
+	textAreaContainer: null,
+	textAreaContainerNode: null,
+	statusBar: null,
+	statusBarContainerNode: null,
+	statusLabelNode: null,
+	statusLabel: null,
+	rootLayoutNode: null,
+	resizeHandleNode: null,
+	resizeHandle: null,
+
+	fillInTemplate: function(args, frag){
+		this.textAreaNode = this.getFragNodeRef(frag).cloneNode(true);
+
+		// FIXME: Safari apparently needs this!
+		document.body.appendChild(this.domNode);
+
+		this.rootLayout = dojo.widget.createWidget(
+			"LayoutContainer",
+			{
+				minHeight: 50,
+				minWidth: 100
+			},
+			this.rootLayoutNode
+		);
+
+
+		this.textAreaContainer = dojo.widget.createWidget(
+			"LayoutContainer",
+			{ layoutAlign: "client" },
+			this.textAreaContainerNode
+		);
+		this.rootLayout.addChild(this.textAreaContainer);
+
+		this.textAreaContainer.domNode.appendChild(this.textAreaNode);
+		with(this.textAreaNode.style){
+			width="100%";
+			height="100%";
+		}
+
+		this.statusBar = dojo.widget.createWidget(
+			"LayoutContainer",
+			{ 
+				layoutAlign: "bottom", 
+				minHeight: 28
+			},
+			this.statusBarContainerNode
+		);
+		this.rootLayout.addChild(this.statusBar);
+
+		this.statusLabel = dojo.widget.createWidget(
+			"LayoutContainer",
+			{ 
+				layoutAlign: "client", 
+				minWidth: 50
+			},
+			this.statusLabelNode
+		);
+		this.statusBar.addChild(this.statusLabel);
+
+		this.resizeHandle = dojo.widget.createWidget(
+			"ResizeHandle", 
+			{ targetElmId: this.rootLayout.widgetId },
+			this.resizeHandleNode
+		);
+		this.statusBar.addChild(this.resizeHandle);
+		// dojo.debug(this.rootLayout.widgetId);
+
+		// dojo.event.connect(this.resizeHandle, "beginSizing", this, "hideContent");
+		// dojo.event.connect(this.resizeHandle, "endSizing", this, "showContent");
+	},
+
+	hideContent: function(){
+		this.textAreaNode.style.display = "none";
+	},
+
+	showContent: function(){
+		this.textAreaNode.style.display = "";
 	}
-	this.statusBar = dojo.widget.createWidget("LayoutContainer", {layoutAlign:"bottom", minHeight:28}, this.statusBarContainerNode);
-	this.rootLayout.addChild(this.statusBar);
-	this.statusLabel = dojo.widget.createWidget("LayoutContainer", {layoutAlign:"client", minWidth:50}, this.statusLabelNode);
-	this.statusBar.addChild(this.statusLabel);
-	this.resizeHandle = dojo.widget.createWidget("ResizeHandle", {targetElmId:this.rootLayout.widgetId}, this.resizeHandleNode);
-	this.statusBar.addChild(this.resizeHandle);
-}});
-
+});

Modified: tags/parley-0.53/root/static/magic/src/widget/ResizeHandle.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ResizeHandle.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ResizeHandle.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,61 +8,105 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.ResizeHandle");
+dojo.provide("dojo.widget.html.ResizeHandle");
 
+dojo.require("dojo.widget.*");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.dom");
+dojo.require("dojo.event");
 
-dojo.provide("dojo.widget.ResizeHandle");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.event.*");
-dojo.widget.defineWidget("dojo.widget.ResizeHandle", dojo.widget.HtmlWidget, {targetElmId:"", templateCssString:".dojoHtmlResizeHandle {\n\tfloat: right;\n\tposition: absolute;\n\tright: 2px;\n\tbottom: 2px;\n\twidth: 13px;\n\theight: 13px;\n\tz-index: 20;\n\tcursor: nw-resize;\n\tbackground-image: url(grabCorner.gif);\n\tline-height: 0px;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/ResizeHandle.css"), templateString:"<div class=\"dojoHtmlResizeHandle\"><div></div></div>", postCreate:function () {
-	dojo.event.connect(this.domNode, "onmousedown", this, "_beginSizing");
-}, _beginSizing:function (e) {
-	if (this._isSizing) {
-		return false;
-	}
-	this.targetWidget = dojo.widget.byId(this.targetElmId);
-	this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : dojo.byId(this.targetElmId);
-	if (!this.targetDomNode) {
-		return;
-	}
-	this._isSizing = true;
-	this.startPoint = {"x":e.clientX, "y":e.clientY};
-	var mb = dojo.html.getMarginBox(this.targetDomNode);
-	this.startSize = {"w":mb.width, "h":mb.height};
-	dojo.event.kwConnect({srcObj:dojo.body(), srcFunc:"onmousemove", targetObj:this, targetFunc:"_changeSizing", rate:25});
-	dojo.event.connect(dojo.body(), "onmouseup", this, "_endSizing");
-	e.preventDefault();
-}, _changeSizing:function (e) {
-	try {
-		if (!e.clientX || !e.clientY) {
+dojo.widget.html.ResizeHandle = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.ResizeHandle, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.ResizeHandle, {
+	widgetType: "ResizeHandle",
+
+	isSizing: false,
+	startPoint: null,
+	startSize: null,
+	minSize: null,
+
+	targetElmId: '',
+
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlResizeHandle.css"),
+	templateString: '<div class="dojoHtmlResizeHandle"><div></div></div>',
+
+	postCreate: function(){
+		dojo.event.connect(this.domNode, "onmousedown", this, "beginSizing");
+	},
+
+	beginSizing: function(e){
+		if (this.isSizing){ return false; }
+
+		// get the target dom node to adjust.  targetElmId can refer to either a widget or a simple node
+		this.targetWidget = dojo.widget.byId(this.targetElmId);
+		this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : dojo.byId(this.targetElmId);
+		if (!this.targetDomNode){ return; }
+
+		this.isSizing = true;
+		this.startPoint  = {'x':e.clientX, 'y':e.clientY};
+		this.startSize  = {'w':dojo.style.getOuterWidth(this.targetDomNode), 'h':dojo.style.getOuterHeight(this.targetDomNode)};
+
+		dojo.event.kwConnect({
+			srcObj: document.body, 
+			srcFunc: "onmousemove",
+			targetObj: this,
+			targetFunc: "changeSizing",
+			rate: 25
+		});
+		dojo.event.connect(document.body, "onmouseup", this, "endSizing");
+
+		e.preventDefault();
+	},
+
+	changeSizing: function(e){
+		// On IE, if you move the mouse above/to the left of the object being resized,
+		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
+		try{
+			if(!e.clientX  || !e.clientY){ return; }
+		}catch(e){
+			// sometimes you get an exception accessing above fields...
 			return;
 		}
-	}
-	catch (e) {
-		return;
-	}
-	var dx = this.startPoint.x - e.clientX;
-	var dy = this.startPoint.y - e.clientY;
-	var newW = this.startSize.w - dx;
-	var newH = this.startSize.h - dy;
-	if (this.minSize) {
-		var mb = dojo.html.getMarginBox(this.targetDomNode);
-		if (newW < this.minSize.w) {
-			newW = mb.width;
+		var dx = this.startPoint.x - e.clientX;
+		var dy = this.startPoint.y - e.clientY;
+		
+		var newW = this.startSize.w - dx;
+		var newH = this.startSize.h - dy;
+
+		// minimum size check
+		if (this.minSize) {
+			if (newW < this.minSize.w) {
+				newW = dojo.style.getOuterWidth(this.targetDomNode);
+			}
+			if (newH < this.minSize.h) {
+				newH = dojo.style.getOuterHeight(this.targetDomNode);
+			}
 		}
-		if (newH < this.minSize.h) {
-			newH = mb.height;
+		
+		if(this.targetWidget){
+			this.targetWidget.resizeTo(newW, newH);
+		}else{
+			dojo.style.setOuterWidth(this.targetDomNode, newW);
+			dojo.style.setOuterHeight(this.targetDomNode, newH);
 		}
+		
+		e.preventDefault();
+	},
+
+	endSizing: function(e){
+		dojo.event.disconnect(document.body, "onmousemove", this, "changeSizing");
+		dojo.event.disconnect(document.body, "onmouseup", this, "endSizing");
+
+		this.isSizing = false;
 	}
-	if (this.targetWidget) {
-		this.targetWidget.resizeTo(newW, newH);
-	} else {
-		dojo.html.setMarginBox(this.targetDomNode, {width:newW, height:newH});
-	}
-	e.preventDefault();
-}, _endSizing:function (e) {
-	dojo.event.disconnect(dojo.body(), "onmousemove", this, "_changeSizing");
-	dojo.event.disconnect(dojo.body(), "onmouseup", this, "_endSizing");
-	this._isSizing = false;
-}});
 
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:ResizeHandle");

Modified: tags/parley-0.53/root/static/magic/src/widget/RichText.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/RichText.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/RichText.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,1160 +8,1444 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+ /* -*- tab-width: 4 -*- */
+dojo.provide("dojo.widget.RichText");
+dojo.provide("dojo.widget.html.RichText");
 
-
-dojo.provide("dojo.widget.RichText");
 dojo.require("dojo.widget.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.selection");
+dojo.require("dojo.dom");
+dojo.require("dojo.html");
 dojo.require("dojo.event.*");
-dojo.require("dojo.string.extras");
-dojo.require("dojo.uri.Uri");
-dojo.require("dojo.Deferred");
-if (!djConfig["useXDomain"] || djConfig["allowXdRichTextSave"]) {
-	if (dojo.hostenv.post_load_) {
-		(function () {
-			var savetextarea = dojo.doc().createElement("textarea");
-			savetextarea.id = "dojo.widget.RichText.savedContent";
-			savetextarea.style = "display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;";
-			dojo.body().appendChild(savetextarea);
-		})();
-	} else {
-		try {
-			dojo.doc().write("<textarea id=\"dojo.widget.RichText.savedContent\" " + "style=\"display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;\"></textarea>");
-		}
-		catch (e) {
-		}
-	}
-}
-dojo.widget.defineWidget("dojo.widget.RichText", dojo.widget.HtmlWidget, function () {
-	this.contentPreFilters = [];
-	this.contentPostFilters = [];
-	this.contentDomPreFilters = [];
-	this.contentDomPostFilters = [];
-	this.editingAreaStyleSheets = [];
-	if (dojo.render.html.moz) {
-		this.contentPreFilters.push(this._fixContentForMoz);
-	}
-	this._keyHandlers = {};
-	if (dojo.Deferred) {
-		this.onLoadDeferred = new dojo.Deferred();
-	}
-}, {inheritWidth:false, focusOnLoad:false, saveName:"", styleSheets:"", _content:"", height:"", minHeight:"1em", isClosed:true, isLoaded:false, useActiveX:false, relativeImageUrls:false, _SEPARATOR:"@@**%%__RICHTEXTBOUNDRY__%%**@@", onLoadDeferred:null, fillInTemplate:function () {
-	dojo.event.topic.publish("dojo.widget.RichText::init", this);
-	this.open();
-	dojo.event.connect(this, "onKeyPressed", this, "afterKeyPress");
-	dojo.event.connect(this, "onKeyPress", this, "keyPress");
-	dojo.event.connect(this, "onKeyDown", this, "keyDown");
-	dojo.event.connect(this, "onKeyUp", this, "keyUp");
-	this.setupDefaultShortcuts();
-}, setupDefaultShortcuts:function () {
-	var ctrl = this.KEY_CTRL;
-	var exec = function (cmd, arg) {
-		return arguments.length == 1 ? function () {
-			this.execCommand(cmd);
-		} : function () {
-			this.execCommand(cmd, arg);
-		};
-	};
-	this.addKeyHandler("b", ctrl, exec("bold"));
-	this.addKeyHandler("i", ctrl, exec("italic"));
-	this.addKeyHandler("u", ctrl, exec("underline"));
-	this.addKeyHandler("a", ctrl, exec("selectall"));
-	this.addKeyHandler("s", ctrl, function () {
-		this.save(true);
-	});
-	this.addKeyHandler("1", ctrl, exec("formatblock", "h1"));
-	this.addKeyHandler("2", ctrl, exec("formatblock", "h2"));
-	this.addKeyHandler("3", ctrl, exec("formatblock", "h3"));
-	this.addKeyHandler("4", ctrl, exec("formatblock", "h4"));
-	this.addKeyHandler("\\", ctrl, exec("insertunorderedlist"));
-	if (!dojo.render.html.ie) {
-		this.addKeyHandler("Z", ctrl, exec("redo"));
-	}
-}, events:["onBlur", "onFocus", "onKeyPress", "onKeyDown", "onKeyUp", "onClick"], open:function (element) {
-	if (this.onLoadDeferred.fired >= 0) {
-		this.onLoadDeferred = new dojo.Deferred();
-	}
-	var h = dojo.render.html;
-	if (!this.isClosed) {
-		this.close();
-	}
-	dojo.event.topic.publish("dojo.widget.RichText::open", this);
-	this._content = "";
-	if ((arguments.length == 1) && (element["nodeName"])) {
-		this.domNode = element;
-	}
-	if ((this.domNode["nodeName"]) && (this.domNode.nodeName.toLowerCase() == "textarea")) {
-		this.textarea = this.domNode;
-		var html = this._preFilterContent(this.textarea.value);
-		this.domNode = dojo.doc().createElement("div");
-		dojo.html.copyStyle(this.domNode, this.textarea);
-		var tmpFunc = dojo.lang.hitch(this, function () {
-			with (this.textarea.style) {
-				display = "block";
-				position = "absolute";
-				left = top = "-1000px";
-				if (h.ie) {
-					this.__overflow = overflow;
-					overflow = "hidden";
-				}
+dojo.require("dojo.style");
+dojo.require("dojo.string");
+
+// used to save content
+try {
+	document.write('<textarea id="dojo.widget.RichText.savedContent" ' +
+		'style="display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;"></textarea>');
+}catch(e){ }
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.RichText",
+	dojo.widget.HtmlWidget,
+	{
+		/** whether to inherit the parent's width or simply use 100% */
+		inheritWidth: false,
+		focusOnLoad: true,
+		
+		/**
+		 * If a save name is specified the content is saved and restored if the
+		 * editor is not properly closed after editing has started.
+		 */
+		saveName: "",
+		_content: "",
+		
+		/* set height to fix the editor at a specific height, with scrolling */
+		height: null,
+
+		/** The minimum height that the editor should have */
+		minHeight: "1em",
+		
+		isClosed: true,
+		isLoaded: false,
+		
+		/** whether to use the active-x object in IE */
+		useActiveX: false,
+
+		/* whether to use relative URLs for images - if this is enabled
+       	images will be given absolute URLs when inside the editor but
+       	will be changed to use relative URLs (to the current page) on save
+		*/
+		relativeImageUrls: false,
+		
+		_SEPARATOR: "@@**%%__RICHTEXTBOUNDRY__%%**@@",
+
+		// contentFilters: [],
+
+		/*
+		defaultContentCleaner: function(content){
+			if(!dojo.render.html.ie){
+				return content;
 			}
-		});
-		if (h.ie) {
-			setTimeout(tmpFunc, 10);
-		} else {
-			tmpFunc();
-		}
-		if (!h.safari) {
-			dojo.html.insertBefore(this.domNode, this.textarea);
-		}
-		if (this.textarea.form) {
-			dojo.event.connect("before", this.textarea.form, "onsubmit", dojo.lang.hitch(this, function () {
-				this.textarea.value = this.getEditorContent();
-			}));
-		}
-		var editor = this;
-		dojo.event.connect(this, "postCreate", function () {
-			dojo.html.insertAfter(editor.textarea, editor.domNode);
-		});
-	} else {
-		var html = this._preFilterContent(dojo.string.trim(this.domNode.innerHTML));
-	}
-	if (html == "") {
-		html = "&nbsp;";
-	}
-	var content = dojo.html.getContentBox(this.domNode);
-	this._oldHeight = content.height;
-	this._oldWidth = content.width;
-	this._firstChildContributingMargin = this._getContributingMargin(this.domNode, "top");
-	this._lastChildContributingMargin = this._getContributingMargin(this.domNode, "bottom");
-	this.savedContent = html;
-	this.domNode.innerHTML = "";
-	this.editingArea = dojo.doc().createElement("div");
-	this.domNode.appendChild(this.editingArea);
-	if ((this.domNode["nodeName"]) && (this.domNode.nodeName == "LI")) {
-		this.domNode.innerHTML = " <br>";
-	}
-	if (this.saveName != "" && (!djConfig["useXDomain"] || djConfig["allowXdRichTextSave"])) {
-		var saveTextarea = dojo.doc().getElementById("dojo.widget.RichText.savedContent");
-		if (saveTextarea.value != "") {
-			var datas = saveTextarea.value.split(this._SEPARATOR);
-			for (var i = 0; i < datas.length; i++) {
-				var data = datas[i].split(":");
-				if (data[0] == this.saveName) {
-					html = data[1];
-					datas.splice(i, 1);
-					break;
-				}
+
+			content = content.replace(/\x20/g, " ");
+			// alert(content);
+			return content;
+		},
+		*/
+
+	/* Init
+	 *******/
+
+		fillInTemplate: function(){
+			this.open();
+
+			// add the formatting functions
+			var funcs = ["queryCommandEnabled", "queryCommandState",
+				"queryCommandValue", "execCommand"];
+			for(var i = 0; i < funcs.length; i++){
+				dojo.event.connect("around", this, funcs[i], this, "_normalizeCommand");
 			}
-		}
-		dojo.event.connect("before", window, "onunload", this, "_saveContent");
-	}
-	if (h.ie70 && this.useActiveX) {
-		dojo.debug("activeX in ie70 is not currently supported, useActiveX is ignored for now.");
-		this.useActiveX = false;
-	}
-	if (this.useActiveX && h.ie) {
-		var self = this;
-		setTimeout(function () {
-			self._drawObject(html);
-		}, 0);
-	} else {
-		if (h.ie || this._safariIsLeopard() || h.opera) {
-			this.iframe = dojo.doc().createElement("iframe");
-			this.iframe.src = "javascript:void(0)";
-			this.editorObject = this.iframe;
-			with (this.iframe.style) {
-				border = "0";
-				width = "100%";
+			
+			// backwards compatibility, needs to be removed
+			dojo.event.connect(this, "onKeyPressed", this, "afterKeyPress");
+			dojo.event.connect(this, "onKeyPress", this, "keyPress");
+			dojo.event.connect(this, "onKeyDown", this, "keyDown");
+			dojo.event.connect(this, "onKeyUp", this, "keyUp");
+
+			// add default some key handlers		
+			var ctrl = this.KEY_CTRL;
+			var exec = function (cmd, arg) {
+				return arguments.length == 1 ? function () { this.execCommand(cmd); } :
+					function () { this.execCommand(cmd, arg); }
 			}
-			this.iframe.frameBorder = 0;
-			this.editingArea.appendChild(this.iframe);
-			this.window = this.iframe.contentWindow;
-			this.document = this.window.document;
-			this.document.open();
-			this.document.write("<html><head><style>body{margin:0;padding:0;border:0;overflow:hidden;}</style></head><body><div></div></body></html>");
-			this.document.close();
-			this.editNode = this.document.body.firstChild;
-			this.editNode.contentEditable = true;
-			with (this.iframe.style) {
-				if (h.ie70) {
-					if (this.height) {
-						height = this.height;
+				
+			this.addKeyHandler("b", ctrl, exec("bold"));
+			this.addKeyHandler("i", ctrl, exec("italic"));
+			this.addKeyHandler("u", ctrl, exec("underline"));
+			this.addKeyHandler("a", ctrl, exec("selectall"));
+			//this.addKeyHandler("k", ctrl, exec("createlink", ""));
+			//this.addKeyHandler("K", ctrl, exec("unlink"));
+			this.addKeyHandler("s", ctrl, function () { this.save(true); });
+			
+			this.addKeyHandler("1", ctrl, exec("formatblock", "h1"));
+			this.addKeyHandler("2", ctrl, exec("formatblock", "h2"));
+			this.addKeyHandler("3", ctrl, exec("formatblock", "h3"));
+			this.addKeyHandler("4", ctrl, exec("formatblock", "h4"));
+					
+			this.addKeyHandler("\\", ctrl, exec("insertunorderedlist"));
+			if(!dojo.render.html.ie){
+				this.addKeyHandler("Z", ctrl, exec("redo"));
+			}
+		},
+
+
+		events: ["onBlur", "onFocus", "onKeyPress", "onKeyDown", "onKeyUp", "onClick"],
+
+		/**
+		 * Transforms the node referenced in this.domNode into a rich text editing
+		 * node. This can result in the creation and replacement with an <iframe> if
+		 * designMode is used, an <object> and active-x component if inside of IE or
+		 * a reguler element if contentEditable is available.
+		 */
+		open: function (element) {
+			dojo.event.topic.publish("dojo.widget.RichText::open", this);
+
+			if (!this.isClosed) { this.close(); }
+			this._content = "";
+			if((arguments.length == 1)&&(element["nodeName"])){ this.domNode = element; } // else unchanged
+
+			if(	(this.domNode["nodeName"])&&
+				(this.domNode.nodeName.toLowerCase() == "textarea")){
+				this.textarea = this.domNode;
+				var html = dojo.string.trim(this.textarea.value);
+				if(html == ""){ html = "&nbsp;"; }
+				this.domNode = document.createElement("div");
+				with(this.textarea.style){
+					display = "block";
+					position = "absolute";
+					width = "1px";
+					height = "1px";
+					border = margin = padding = "0px";
+					visiblity = "hidden";
+					if(dojo.render.html.ie){
+						overflow = "hidden";
 					}
-					if (this.minHeight) {
-						minHeight = this.minHeight;
-					}
-				} else {
-					height = this.height ? this.height : this.minHeight;
 				}
-			}
-			var formats = ["p", "pre", "address", "h1", "h2", "h3", "h4", "h5", "h6", "ol", "div", "ul"];
-			var localhtml = "";
-			for (var i in formats) {
-				if (formats[i].charAt(1) != "l") {
-					localhtml += "<" + formats[i] + "><span>content</span></" + formats[i] + ">";
-				} else {
-					localhtml += "<" + formats[i] + "><li>content</li></" + formats[i] + ">";
+				dojo.dom.insertBefore(this.domNode, this.textarea);
+				this.domNode.innerHTML = html;
+				
+				if(this.textarea.form){
+					dojo.event.connect(this.textarea.form, "onsubmit", 
+						// FIXME: should we be calling close() here instead?
+						dojo.lang.hitch(this, function(){
+							this.textarea.value = this.getEditorContent();
+						})
+					);
 				}
+				
+				// dojo plucks our original domNode from the document so we need
+				// to go back and put ourselves back in
+				var editor = this;
+				dojo.event.connect(this, "postCreate", function (){
+					dojo.dom.insertAfter(editor.textarea, editor.domNode);
+				});
+			}else{
+				var html = dojo.string.trim(this.domNode.innerHTML);
+				if(html == ""){ html = "&nbsp;"; }
 			}
-			with (this.editNode.style) {
-				position = "absolute";
-				left = "-2000px";
-				top = "-2000px";
+					
+			this._oldHeight = dojo.style.getContentHeight(this.domNode);
+			this._oldWidth = dojo.style.getContentWidth(this.domNode);
+
+			this._firstChildContributingMargin = this._getContributingMargin(this.domNode, "top");
+			this._lastChildContributingMargin = this._getContributingMargin(this.domNode, "bottom");
+
+			this.savedContent = document.createElement("div");
+			while (this.domNode.hasChildNodes()) {
+				this.savedContent.appendChild(this.domNode.firstChild);
 			}
-			this.editNode.innerHTML = localhtml;
-			var node = this.editNode.firstChild;
-			while (node) {
-				dojo.withGlobal(this.window, "selectElement", dojo.html.selection, [node.firstChild]);
-				var nativename = node.tagName.toLowerCase();
-				this._local2NativeFormatNames[nativename] = this.queryCommandValue("formatblock");
-				this._native2LocalFormatNames[this._local2NativeFormatNames[nativename]] = nativename;
-				node = node.nextSibling;
+			
+			// If we're a list item we have to put in a blank line to force the
+			// bullet to nicely align at the top of text
+			if(	(this.domNode["nodeName"])&&
+				(this.domNode.nodeName == "LI")){
+				this.domNode.innerHTML = " <br>";
 			}
-			with (this.editNode.style) {
-				position = "";
-				left = "";
-				top = "";
+					
+			if(this.saveName != ""){
+				var saveTextarea = document.getElementById("dojo.widget.RichText.savedContent");
+				if (saveTextarea.value != "") {
+					var datas = saveTextarea.value.split(this._SEPARATOR);
+					for (var i = 0; i < datas.length; i++) {
+						var data = datas[i].split(":");
+						if (data[0] == this.saveName) {
+							html = data[1];
+							datas.splice(i, 1);
+							break;
+						}
+					}				
+				}
+				dojo.event.connect("before", window, "onunload", this, "_saveContent");
+				// dojo.event.connect(window, "onunload", this, "_saveContent");
 			}
-			this.editNode.innerHTML = html;
-			if (this.height) {
-				this.document.body.style.overflowY = "scroll";
+
+			// Safari's selections go all out of whack if we do it inline,
+			// so for now IE is our only hero
+			//if (typeof document.body.contentEditable != "undefined") {
+			if (this.useActiveX && dojo.render.html.ie) { // active-x
+				this._drawObject(html);
+				// dojo.debug(this.object.document);
+			} else if (dojo.render.html.ie) { // contentEditable, easy
+				this.editNode = document.createElement("div");
+				with (this.editNode) {
+					innerHTML = html;
+					contentEditable = true;
+					style.height = this.height ? this.height : this.minHeight;
+				}
+
+				if(this.height){ this.editNode.style.overflowY="scroll"; }
+				// FIXME: setting contentEditable on switches this element to
+				// IE's hasLayout mode, triggering weird margin collapsing
+				// behavior. It's particularly bad if the element you're editing
+				// contains childnodes that don't have margin: defined in local
+				// css rules. It would be nice if it was possible to hack around
+				// this. Sadly _firstChildContributingMargin and 
+				// _lastChildContributingMargin don't work on IE unless all
+				// elements have margins set in CSS :-(
+
+				this.domNode.appendChild(this.editNode);
+
+				dojo.lang.forEach(this.events, function(e){
+					dojo.event.connect(this.editNode, e.toLowerCase(), this, e);
+				}, this);
+			
+				this.window = window;
+				this.document = document;
+				
+				this.onLoad();
+			} else { // designMode in iframe
+				this._drawIframe(html);
 			}
-			dojo.lang.forEach(this.events, function (e) {
-				dojo.event.connect(this.editNode, e.toLowerCase(), this, e);
-			}, this);
-			this.onLoad();
-		} else {
-			this._drawIframe(html);
-			this.editorObject = this.iframe;
-		}
-	}
-	if (this.domNode.nodeName == "LI") {
-		this.domNode.lastChild.style.marginTop = "-1.2em";
-	}
-	dojo.html.addClass(this.domNode, "RichTextEditable");
-	this.isClosed = false;
-}, _hasCollapseableMargin:function (element, side) {
-	if (dojo.html.getPixelValue(element, "border-" + side + "-width", false)) {
-		return false;
-	} else {
-		if (dojo.html.getPixelValue(element, "padding-" + side, false)) {
-			return false;
-		} else {
-			return true;
-		}
-	}
-}, _getContributingMargin:function (element, topOrBottom) {
-	if (topOrBottom == "top") {
-		var siblingAttr = "previousSibling";
-		var childSiblingAttr = "nextSibling";
-		var childAttr = "firstChild";
-		var marginProp = "margin-top";
-		var siblingMarginProp = "margin-bottom";
-	} else {
-		var siblingAttr = "nextSibling";
-		var childSiblingAttr = "previousSibling";
-		var childAttr = "lastChild";
-		var marginProp = "margin-bottom";
-		var siblingMarginProp = "margin-top";
-	}
-	var elementMargin = dojo.html.getPixelValue(element, marginProp, false);
-	function isSignificantNode(element) {
-		return !(element.nodeType == 3 && dojo.string.isBlank(element.data)) && dojo.html.getStyle(element, "display") != "none" && !dojo.html.isPositionAbsolute(element);
-	}
-	var childMargin = 0;
-	var child = element[childAttr];
-	while (child) {
-		while ((!isSignificantNode(child)) && child[childSiblingAttr]) {
-			child = child[childSiblingAttr];
-		}
-		childMargin = Math.max(childMargin, dojo.html.getPixelValue(child, marginProp, false));
-		if (!this._hasCollapseableMargin(child, topOrBottom)) {
-			break;
-		}
-		child = child[childAttr];
-	}
-	if (!this._hasCollapseableMargin(element, topOrBottom)) {
-		return parseInt(childMargin);
-	}
-	var contextMargin = 0;
-	var sibling = element[siblingAttr];
-	while (sibling) {
-		if (isSignificantNode(sibling)) {
-			contextMargin = dojo.html.getPixelValue(sibling, siblingMarginProp, false);
-			break;
-		}
-		sibling = sibling[siblingAttr];
-	}
-	if (!sibling) {
-		contextMargin = dojo.html.getPixelValue(element.parentNode, marginProp, false);
-	}
-	if (childMargin > elementMargin) {
-		return parseInt(Math.max((childMargin - elementMargin) - contextMargin, 0));
-	} else {
-		return 0;
-	}
-}, _drawIframe:function (html) {
-	var oldMoz = Boolean(dojo.render.html.moz && (typeof window.XML == "undefined"));
-	if (!this.iframe) {
-		var currentDomain = (new dojo.uri.Uri(dojo.doc().location)).host;
-		this.iframe = dojo.doc().createElement("iframe");
-		with (this.iframe) {
-			style.border = "none";
-			style.lineHeight = "0";
-			style.verticalAlign = "bottom";
-			scrolling = this.height ? "auto" : "no";
-		}
-	}
-	if (djConfig["useXDomain"] && !djConfig["dojoRichTextFrameUrl"]) {
-		dojo.debug("dojo.widget.RichText: When using cross-domain Dojo builds," + " please save src/widget/templates/richtextframe.html to your domain and set djConfig.dojoRichTextFrameUrl" + " to the path on your domain to richtextframe.html");
-	}
-	this.iframe.src = (djConfig["dojoRichTextFrameUrl"] || dojo.uri.moduleUri("dojo.widget", "templates/richtextframe.html")) + ((dojo.doc().domain != currentDomain) ? ("#" + dojo.doc().domain) : "");
-	this.iframe.width = this.inheritWidth ? this._oldWidth : "100%";
-	if (this.height) {
-		this.iframe.style.height = this.height;
-	} else {
-		var height = this._oldHeight;
-		if (this._hasCollapseableMargin(this.domNode, "top")) {
-			height += this._firstChildContributingMargin;
-		}
-		if (this._hasCollapseableMargin(this.domNode, "bottom")) {
-			height += this._lastChildContributingMargin;
-		}
-		this.iframe.height = height;
-	}
-	var tmpContent = dojo.doc().createElement("div");
-	tmpContent.innerHTML = html;
-	this.editingArea.appendChild(tmpContent);
-	if (this.relativeImageUrls) {
-		var imgs = tmpContent.getElementsByTagName("img");
-		for (var i = 0; i < imgs.length; i++) {
-			imgs[i].src = (new dojo.uri.Uri(dojo.global().location, imgs[i].src)).toString();
-		}
-		html = tmpContent.innerHTML;
-	}
-	var firstChild = dojo.html.firstElement(tmpContent);
-	var lastChild = dojo.html.lastElement(tmpContent);
-	if (firstChild) {
-		firstChild.style.marginTop = this._firstChildContributingMargin + "px";
-	}
-	if (lastChild) {
-		lastChild.style.marginBottom = this._lastChildContributingMargin + "px";
-	}
-	this.editingArea.appendChild(this.iframe);
-	if (dojo.render.html.safari) {
-		this.iframe.src = this.iframe.src;
-	}
-	var _iframeInitialized = false;
-	var ifrFunc = dojo.lang.hitch(this, function () {
-		if (!_iframeInitialized) {
-			_iframeInitialized = true;
-		} else {
-			return;
-		}
-		if (!this.editNode) {
-			if (this.iframe.contentWindow) {
-				this.window = this.iframe.contentWindow;
-				this.document = this.iframe.contentWindow.document;
+
+			// TODO: this is a guess at the default line-height, kinda works
+			if (this.domNode.nodeName == "LI") { this.domNode.lastChild.style.marginTop = "-1.2em"; }
+			dojo.html.addClass(this.domNode, "RichTextEditable");
+			
+			this.isClosed = false;
+		},
+
+		_hasCollapseableMargin: function(element, side) {
+			// check if an element has padding or borders on the given side
+			// which would prevent it from collapsing margins
+			if (dojo.style.getPixelValue(element, 
+										 'border-'+side+'-width', 
+										 false)) {
+				return false;
+			} else if (dojo.style.getPixelValue(element, 
+												'padding-'+side,
+												false)) {
+				return false;
 			} else {
-				if (this.iframe.contentDocument) {
-					this.window = this.iframe.contentDocument.window;
-					this.document = this.iframe.contentDocument;
-				}
+				return true;
 			}
-			var getStyle = (function (domNode) {
-				return function (style) {
-					return dojo.html.getStyle(domNode, style);
-				};
-			})(this.domNode);
-			var font = getStyle("font-weight") + " " + getStyle("font-size") + " " + getStyle("font-family");
-			var lineHeight = "1.0";
-			var lineHeightStyle = dojo.html.getUnitValue(this.domNode, "line-height");
-			if (lineHeightStyle.value && lineHeightStyle.units == "") {
-				lineHeight = lineHeightStyle.value;
+		},
+
+		_getContributingMargin:	function(element, topOrBottom) {
+			// calculate how much margin this element and its first or last
+			// child are contributing to the total margin between this element
+			// and the adjacent node. CSS border collapsing makes this
+			// necessary.
+
+			if (topOrBottom == "top") {
+				var siblingAttr = "previousSibling";
+				var childSiblingAttr = "nextSibling";
+				var childAttr = "firstChild";
+				var marginProp = "margin-top";
+				var siblingMarginProp = "margin-bottom";
+			} else {
+				var siblingAttr = "nextSibling";
+				var childSiblingAttr = "previousSibling";
+				var childAttr = "lastChild";
+				var marginProp = "margin-bottom";
+				var siblingMarginProp = "margin-top";
 			}
-			dojo.html.insertCssText("body,html{background:transparent;padding:0;margin:0;}" + "body{top:0;left:0;right:0;" + (((this.height) || (dojo.render.html.opera)) ? "" : "position:fixed;") + "font:" + font + ";" + "min-height:" + this.minHeight + ";" + "line-height:" + lineHeight + "}" + "p{margin: 1em 0 !important;}" + "body > *:first-child{padding-top:0 !important;margin-top:" + this._firstChildContributingMargin + "px !important;}" + "body > *:last-child{padding-bottom:0 !important;margin-bottom:" + this._lastChildContributingMargin + "px !important;}" + "li > ul:-moz-first-node, li > ol:-moz-first-node{padding-top:1.2em;}\n" + "li{min-height:1.2em;}" + "", this.document);
-			dojo.html.removeNode(tmpContent);
-			this.document.body.innerHTML = html;
-			if (oldMoz || dojo.render.html.safari) {
-				this.document.designMode = "on";
+
+			var elementMargin = dojo.style.getPixelValue(element, marginProp, false);
+
+			function isSignificantNode(element) {
+				// see if an node is significant in the current context
+				// for calulating margins
+				return !(element.nodeType==3 && dojo.string.isBlank(element.data)) 
+					&& dojo.style.getStyle(element, "display") != "none" 
+					&& !dojo.style.isPositionAbsolute(element);
 			}
-			this.onLoad();
-		} else {
-			dojo.html.removeNode(tmpContent);
-			this.editNode.innerHTML = html;
-			this.onDisplayChanged();
-		}
-	});
-	if (this.editNode) {
-		ifrFunc();
-	} else {
-		if (dojo.render.html.moz) {
-			this.iframe.onload = function () {
-				setTimeout(ifrFunc, 250);
-			};
-		} else {
-			this.iframe.onload = ifrFunc;
-		}
-	}
-}, _applyEditingAreaStyleSheets:function () {
-	var files = [];
-	if (this.styleSheets) {
-		files = this.styleSheets.split(";");
-		this.styleSheets = "";
-	}
-	files = files.concat(this.editingAreaStyleSheets);
-	this.editingAreaStyleSheets = [];
-	if (files.length > 0) {
-		for (var i = 0; i < files.length; i++) {
-			var url = files[i];
-			if (url) {
-				this.addStyleSheet(dojo.uri.dojoUri(url));
+
+			// walk throuh first/last children to find total collapsed margin size
+			var childMargin = 0;
+			var child = element[childAttr];
+			while (child) {
+				// skip over insignificant elements (whitespace, etc)
+				while ((!isSignificantNode(child)) && child[childSiblingAttr]) {
+					child = child[childSiblingAttr];
+				}
+						  
+				childMargin = Math.max(childMargin, dojo.style.getPixelValue(child, marginProp, false));
+				// stop if we hit a bordered/padded element
+				if (!this._hasCollapseableMargin(child, topOrBottom)) break;
+				child = child[childAttr];								   
 			}
-		}
-	}
-}, addStyleSheet:function (uri) {
-	var url = uri.toString();
-	if (dojo.lang.find(this.editingAreaStyleSheets, url) > -1) {
-		dojo.debug("dojo.widget.RichText.addStyleSheet: Style sheet " + url + " is already applied to the editing area!");
-		return;
-	}
-	if (url.charAt(0) == "." || (url.charAt(0) != "/" && !uri.host)) {
-		url = (new dojo.uri.Uri(dojo.global().location, url)).toString();
-	}
-	this.editingAreaStyleSheets.push(url);
-	if (this.document.createStyleSheet) {
-		this.document.createStyleSheet(url);
-	} else {
-		var head = this.document.getElementsByTagName("head")[0];
-		var stylesheet = this.document.createElement("link");
-		with (stylesheet) {
-			rel = "stylesheet";
-			type = "text/css";
-			href = url;
-		}
-		head.appendChild(stylesheet);
-	}
-}, removeStyleSheet:function (uri) {
-	var url = uri.toString();
-	if (url.charAt(0) == "." || (url.charAt(0) != "/" && !uri.host)) {
-		url = (new dojo.uri.Uri(dojo.global().location, url)).toString();
-	}
-	var index = dojo.lang.find(this.editingAreaStyleSheets, url);
-	if (index == -1) {
-		dojo.debug("dojo.widget.RichText.removeStyleSheet: Style sheet " + url + " is not applied to the editing area so it can not be removed!");
-		return;
-	}
-	delete this.editingAreaStyleSheets[index];
-	var links = this.document.getElementsByTagName("link");
-	for (var i = 0; i < links.length; i++) {
-		if (links[i].href == url) {
-			if (dojo.render.html.ie) {
-				links[i].href = "";
+
+			// if this element has a border, return full child margin immediately
+			// as there won't be any margin collapsing
+			if (!this._hasCollapseableMargin(element, topOrBottom)){ return parseInt(childMargin); }
+
+			// find margin supplied by nearest sibling
+			var contextMargin = 0;
+			var sibling = element[siblingAttr];
+			while (sibling) {
+				if (isSignificantNode(sibling)) {
+					contextMargin = dojo.style.getPixelValue(sibling, 
+															 siblingMarginProp, 
+															 false);
+					break;
+				}
+				sibling = sibling[siblingAttr];
 			}
-			dojo.html.removeNode(links[i]);
-			break;
-		}
-	}
-}, _drawObject:function (html) {
-	this.object = dojo.html.createExternalElement(dojo.doc(), "object");
-	with (this.object) {
-		classid = "clsid:2D360201-FFF5-11D1-8D03-00A0C959BC0A";
-		width = this.inheritWidth ? this._oldWidth : "100%";
-		style.height = this.height ? this.height : (this._oldHeight + "px");
-		Scrollbars = this.height ? true : false;
-		Appearance = this._activeX.appearance.flat;
-	}
-	this.editorObject = this.object;
-	this.editingArea.appendChild(this.object);
-	this.object.attachEvent("DocumentComplete", dojo.lang.hitch(this, "onLoad"));
-	dojo.lang.forEach(this.events, function (e) {
-		this.object.attachEvent(e.toLowerCase(), dojo.lang.hitch(this, e));
-	}, this);
-	this.object.DocumentHTML = "<!doctype HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">" + "<html><title></title>" + "<style type=\"text/css\">" + "	body,html { padding: 0; margin: 0; }" + (this.height ? "" : "	body,  { overflow: hidden; }") + "</style>" + "<body><div>" + html + "<div></body></html>";
-	this._cacheLocalBlockFormatNames();
-}, _local2NativeFormatNames:{}, _native2LocalFormatNames:{}, _cacheLocalBlockFormatNames:function () {
-	if (!this._native2LocalFormatNames["p"]) {
-		var obj = this.object;
-		var error = false;
-		if (!obj) {
-			try {
-				obj = dojo.html.createExternalElement(dojo.doc(), "object");
-				obj.classid = "clsid:2D360201-FFF5-11D1-8D03-00A0C959BC0A";
-				dojo.body().appendChild(obj);
-				obj.DocumentHTML = "<html><head></head><body></body></html>";
+			if (!sibling) { // no sibling, look at parent's margin instead
+				contextMargin = dojo.style.getPixelValue(element.parentNode, 
+												marginProp, false);
 			}
-			catch (e) {
-				error = true;
+
+			if (childMargin > elementMargin) {
+				return parseInt(Math.max((childMargin-elementMargin)-contextMargin, 0));
+			} else {
+				return 0;
 			}
-		}
-		try {
-			var oNamesParm = new ActiveXObject("DEGetBlockFmtNamesParam.DEGetBlockFmtNamesParam");
-			obj.ExecCommand(this._activeX.command["getblockformatnames"], 0, oNamesParm);
-			var vbNamesArray = new VBArray(oNamesParm.Names);
-			var localFormats = vbNamesArray.toArray();
-			var nativeFormats = ["p", "pre", "address", "h1", "h2", "h3", "h4", "h5", "h6", "ol", "ul", "", "", "", "", "div"];
-			for (var i = 0; i < nativeFormats.length; ++i) {
-				if (nativeFormats[i].length > 0) {
-					this._local2NativeFormatNames[localFormats[i]] = nativeFormats[i];
-					this._native2LocalFormatNames[nativeFormats[i]] = localFormats[i];
+			
+		},
+		
+		/** Draws an iFrame using the existing one if one exists. 
+			Used by Mozilla, Safari, and Opera */
+		_drawIframe: function (html) {
+
+			// detect firefox < 1.5, which has some iframe loading issues
+			var oldMoz = Boolean(dojo.render.html.moz && (
+									typeof window.XML == 'undefined'))
+
+			if (!this.iframe) {
+				var currentDomain = (new dojo.uri.Uri(document.location)).host;
+				this.iframe = document.createElement("iframe");
+				with (this.iframe) {
+					scrolling = this.height ? "auto" : "no";
+					style.border = "none";
+					style.lineHeight = "0"; // squash line height
+					style.verticalAlign = "bottom";
 				}
 			}
-		}
-		catch (e) {
-			error = true;
-		}
-		if (obj && !this.object) {
-			dojo.body().removeChild(obj);
-		}
-	}
-	return !error;
-}, _isResized:function () {
-	return false;
-}, onLoad:function (e) {
-	this.isLoaded = true;
-	if (this.object) {
-		this.document = this.object.DOM;
-		this.window = this.document.parentWindow;
-		this.editNode = this.document.body.firstChild;
-		this.editingArea.style.height = this.height ? this.height : this.minHeight;
-		if (!this.height) {
-			this.connect(this, "onDisplayChanged", "_updateHeight");
-		}
-		this.window._frameElement = this.object;
-	} else {
-		if (this.iframe && !dojo.render.html.ie) {
-			this.editNode = this.document.body;
-			if (!this.height) {
-				this.connect(this, "onDisplayChanged", "_updateHeight");
+			// opera likes this to be outside the with block
+			this.iframe.src = dojo.uri.dojoUri("src/widget/templates/richtextframe.html") + "#" + ((document.domain != currentDomain) ? document.domain : "");
+			this.iframe.width = this.inheritWidth ? this._oldWidth : "100%";
+			if (this.height) {
+				this.iframe.style.height = this.height;
+			} else {
+				var height = this._oldHeight;
+				if (this._hasCollapseableMargin(this.domNode, 'top')) {
+					height += this._firstChildContributingMargin;
+				}
+				if (this._hasCollapseableMargin(this.domNode, 'bottom')) {
+					height += this._lastChildContributingMargin;
+				}
+				this.iframe.height = height;
 			}
-			try {
-				this.document.execCommand("useCSS", false, true);
-				this.document.execCommand("styleWithCSS", false, false);
+
+			var tmpContent = document.createElement('div');
+			tmpContent.innerHTML = html;
+
+			// make relative image urls absolute
+			if (this.relativeImageUrls) {
+				var imgs = tmpContent.getElementsByTagName('img');
+				for (var i=0; i<imgs.length; i++) {
+					imgs[i].src = (new dojo.uri.Uri(window.location, imgs[i].src)).toString();
+				}
+				html = tmpContent.innerHTML;
 			}
-			catch (e2) {
+
+			// fix margins on tmpContent
+			var firstChild = dojo.dom.firstElement(tmpContent);
+			var lastChild = dojo.dom.lastElement(tmpContent);
+			if(firstChild){
+				firstChild.style.marginTop = this._firstChildContributingMargin+"px";
 			}
-			if (dojo.render.html.safari) {
-				this.connect(this.editNode, "onblur", "onBlur");
-				this.connect(this.editNode, "onfocus", "onFocus");
-				this.connect(this.editNode, "onclick", "onFocus");
-				this.interval = setInterval(dojo.lang.hitch(this, "onDisplayChanged"), 750);
-			} else {
-				if (dojo.render.html.mozilla || dojo.render.html.opera) {
+			if(lastChild){
+				lastChild.style.marginBottom = this._lastChildContributingMargin+"px";
+			}
+
+			// show existing content behind iframe for now
+			tmpContent.style.position = "absolute";
+			this.domNode.appendChild(tmpContent);
+			this.domNode.appendChild(this.iframe);
+
+			var _iframeInitialized = false;
+
+			// now we wait for onload. Janky hack!
+			var ifrFunc = dojo.lang.hitch(this, function(){
+				if(!_iframeInitialized){
+					_iframeInitialized = true;
+				}else{ return; }
+				if(!this.editNode){
+					if(this.iframe.contentWindow){
+						this.window = this.iframe.contentWindow;
+					}else{
+						// for opera
+						this.window = this.iframe.contentDocument.window;
+					}
+					if(dojo.render.html.moz){
+						this.document = this.iframe.contentWindow.document
+					}else{
+						this.document = this.iframe.contentDocument;
+					}
+
+					// curry the getStyle function
+					var getStyle = (function (domNode) { return function (style) {
+						return dojo.style.getStyle(domNode, style);
+					}; })(this.domNode);
+
+					var font =
+						getStyle('font-weight') + " " +
+						getStyle('font-size') + " " +
+						getStyle('font-family');
+					
+					// line height is tricky - applying a units value will mess things up.
+					// if we can't get a non-units value, bail out.
+					var lineHeight = "1.0";
+					var lineHeightStyle = dojo.style.getUnitValue(this.domNode, 'line-height');
+					if (lineHeightStyle.value && lineHeightStyle.units=="") {
+						lineHeight = lineHeightStyle.value;
+					}
+
+					dojo.style.insertCssText(
+						'    body,html { background: transparent; padding: 0; margin: 0; }\n' +
+						// TODO: left positioning will case contents to disappear out of view
+						//       if it gets too wide for the visible area
+						'    body { top: 0; left: 0; right: 0;' +
+						(this.height ? '' : ' position: fixed; ') + 
+						'        font: ' + font + ';\n' + 
+						'        min-height: ' + this.minHeight + '; \n' +
+						'        line-height: ' + lineHeight + '} \n' +
+						'    p { margin: 1em 0 !important; }\n' +
+						'    body > *:first-child { padding-top: 0 !important; margin-top: ' + this._firstChildContributingMargin + 'px !important; }\n' + // FIXME: test firstChild nodeType
+						'    body > *:last-child { padding-bottom: 0 !important; margin-bottom: ' + this._lastChildContributingMargin + 'px !important; }\n' +
+						'    li > ul:-moz-first-node, li > ol:-moz-first-node { padding-top: 1.2em; }\n' +
+						'    li { min-height: 1.2em; }\n' +
+						//'    p,ul,li { padding-top: 0; padding-bottom: 0; margin-top:0; margin-bottom: 0; }\n' + 
+						'', this.document);
+
+					tmpContent.parentNode.removeChild(tmpContent);
+					this.document.body.innerHTML = html;
+					if(oldMoz){
+						this.document.designMode = "on";
+					}
+					this.onLoad();
+				}else{
+					tmpContent.parentNode.removeChild(tmpContent);
+					this.editNode.innerHTML = html;
+					this.onDisplayChanged();
+				}
+			});
+
+			if(this.editNode){
+				ifrFunc(); // iframe already exists, just set content
+			}else if(dojo.render.html.moz){
+				// FIXME: if we put this on a delay, we get a height of 20px.
+				// Otherwise we get the correctly specified minHeight value.
+				this.iframe.onload = function(){
+					setTimeout(ifrFunc, 250);
+				}
+			}else{ // new mozillas, opera, safari
+				this.iframe.onload = ifrFunc;
+			}
+		},
+		
+		/** Draws an active x object, used by IE */
+		_drawObject: function (html) {
+			this.object = document.createElement("object");
+
+			with (this.object) {
+				classid = "clsid:2D360201-FFF5-11D1-8D03-00A0C959BC0A";
+				width = this.inheritWidth ? this._oldWidth : "100%";
+				style.height = this.height ? this.height : (this._oldHeight+"px");
+				Scrollbars = this.height ? true : false;
+				Appearance = this._activeX.appearance.flat;
+			}
+			this.domNode.appendChild(this.object);
+
+			this.object.attachEvent("DocumentComplete", dojo.lang.hitch(this, "onLoad"));
+			this.object.attachEvent("DisplayChanged", dojo.lang.hitch(this, "_updateHeight"));
+			this.object.attachEvent("DisplayChanged", dojo.lang.hitch(this, "onDisplayChanged"));
+
+			dojo.lang.forEach(this.events, function(e){
+				this.object.attachEvent(e.toLowerCase(), dojo.lang.hitch(this, e));
+			}, this);
+
+			this.object.DocumentHTML = '<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">' +
+				'<title></title>' +
+				'<style type="text/css">' +
+				'    body,html { padding: 0; margin: 0; }' + //font: ' + font + '; }' +
+				(this.height ? '' : '    body { overflow: hidden; }') +
+				//'    #bodywrapper {  }' +
+				'</style>' +
+				//'<base href="' + window.location + '">' +
+				'<body><div id="bodywrapper">' + html + '</div></body>';
+		},
+
+	/* Event handlers
+	 *****************/
+
+	 	_isResized: function(){ return false; },
+
+		onLoad: function(e){
+			this.isLoaded = true;
+			if (this.object){
+				this.document = this.object.DOM;
+				this.window = this.document.parentWindow;
+				this.editNode = this.document.body.firstChild;
+				this.domNode.style.height = this.height ? this.height : this.minHeight;
+				this.connect(this, "onDisplayChanged", "_updateHeight");
+			}else if (this.iframe){
+				this.editNode = this.document.body;
+				this.connect(this, "onDisplayChanged", "_updateHeight");
+		
+				try { // sanity check for Mozilla
+					this.document.execCommand("useCSS", false, true); // old moz call
+					this.document.execCommand("styleWithCSS", false, false); // new moz call
+					//this.document.execCommand("insertBrOnReturn", false, false); // new moz call
+				}catch(e2){ }
+				
+				if (dojo.render.html.safari) {
+					/*
+					this.iframe.style.visiblity = "visible";
+					this.iframe.style.border = "1px solid black";
+					this.editNode.style.visiblity = "visible";
+					this.editNode.style.border = "1px solid black";
+					*/
+					// this.onDisplayChanged();
+					this.connect(this.editNode, "onblur", "onBlur");
+					this.connect(this.editNode, "onfocus", "onFocus");
+				
+					this.interval = setInterval(dojo.lang.hitch(this, "onDisplayChanged"), 750);
+					// dojo.raise("onload");
+					// dojo.debug(this.editNode.parentNode.parentNode.parentNode.nodeName);
+				} else if (dojo.render.html.mozilla || dojo.render.html.opera) {
+
+					// We need to unhook the blur event listener on close as we
+					// can encounter a garunteed crash in FF if another event is
+					// also fired
 					var doc = this.document;
+					var blurfp = dojo.event.browser.addListener(this.document, "blur", dojo.lang.hitch(this, "onBlur"));
+					var unBlur = { unBlur: function(e){
+							dojo.event.browser.removeListener(doc, "blur", blurfp);
+					} };
+					dojo.event.connect("before", this, "close", unBlur, "unBlur");
+					dojo.event.browser.addListener(this.document, "focus", dojo.lang.hitch(this, "onFocus"));
+				
+					// safari can't handle key listeners, it kills the speed
 					var addListener = dojo.event.browser.addListener;
-					var self = this;
-					dojo.lang.forEach(this.events, function (e) {
-						var l = addListener(self.document, e.substr(2).toLowerCase(), dojo.lang.hitch(self, e));
-						if (e == "onBlur") {
-							var unBlur = {unBlur:function (e) {
-								dojo.event.browser.removeListener(doc, "blur", l);
-							}};
-							dojo.event.connect("before", self, "close", unBlur, "unBlur");
-						}
-					});
+					addListener(this.document, "keypress", dojo.lang.hitch(this, "onKeyPress"));
+					addListener(this.document, "keydown", dojo.lang.hitch(this, "onKeyDown"));
+					addListener(this.document, "keyup", dojo.lang.hitch(this, "onKeyUp"));
+					addListener(this.document, "click", dojo.lang.hitch(this, "onClick"));
 				}
+
+				// FIXME: when scrollbars appear/disappear this needs to be fired						
+			}else if(dojo.render.html.ie){
+				// IE contentEditable
+				this.editNode.style.zoom = 1.0;
 			}
-		} else {
-			if (dojo.render.html.ie) {
-				if (!this.height) {
-					this.connect(this, "onDisplayChanged", "_updateHeight");
-				}
-				this.editNode.style.zoom = 1;
+			
+			if(this.focusOnLoad){
+				this.focus();
 			}
-		}
-	}
-	this._applyEditingAreaStyleSheets();
-	if (this.focusOnLoad) {
-		this.focus();
-	}
-	this.onDisplayChanged(e);
-	if (this.onLoadDeferred) {
-		this.onLoadDeferred.callback(true);
-	}
-}, onKeyDown:function (e) {
-	if ((!e) && (this.object)) {
-		e = dojo.event.browser.fixEvent(this.window.event);
-	}
-	if ((dojo.render.html.ie) && (e.keyCode == e.KEY_TAB)) {
-		e.preventDefault();
-		e.stopPropagation();
-		this.execCommand((e.shiftKey ? "outdent" : "indent"));
-	} else {
-		if (dojo.render.html.ie) {
-			if ((65 <= e.keyCode) && (e.keyCode <= 90)) {
-				e.charCode = e.keyCode;
-				this.onKeyPress(e);
+			this.onDisplayChanged(e);
+		},
+
+		/** Fired on keydown */
+		onKeyDown: function(e){
+			if((!e)&&(this.object)){
+				e = dojo.event.browser.fixEvent(this.window.event);
 			}
-		}
-	}
-}, onKeyUp:function (e) {
-	return;
-}, KEY_CTRL:1, onKeyPress:function (e) {
-	if ((!e) && (this.object)) {
-		e = dojo.event.browser.fixEvent(this.window.event);
-	}
-	var modifiers = e.ctrlKey ? this.KEY_CTRL : 0;
-	if (this._keyHandlers[e.key]) {
-		var handlers = this._keyHandlers[e.key], i = 0, handler;
-		while (handler = handlers[i++]) {
-			if (modifiers == handler.modifiers) {
+			dojo.debug("onkeydown:", e.keyCode);
+			// we need this event at the moment to get the events from control keys
+			// such as the backspace. It might be possible to add this to Dojo, so that
+			// keyPress events can be emulated by the keyDown and keyUp detection.
+			if((dojo.render.html.ie)&&(e.keyCode == e.KEY_TAB)){
 				e.preventDefault();
-				handler.handler.call(this);
-				break;
+				e.stopPropagation();
+				// FIXME: this is a poor-man's indent/outdent. It would be
+				// better if it added 4 "&nbsp;" chars in an undoable way.
+				// Unfortuantly pasteHTML does not prove to be undoable 
+				this.execCommand((e.shiftKey ? "outdent" : "indent"));
+			}else if(dojo.render.html.ie){
+				if((65 <= e.keyCode)&&(e.keyCode <= 90)){
+					e.charCode = e.keyCode;
+					this.onKeyPress(e);
+				}
+				// dojo.debug(e.ctrlKey);
+				// dojo.debug(e.keyCode);
+				// dojo.debug(e.charCode);
+				// this.onKeyPress(e);
 			}
-		}
-	}
-	dojo.lang.setTimeout(this, this.onKeyPressed, 1, e);
-}, addKeyHandler:function (key, modifiers, handler) {
-	if (!(this._keyHandlers[key] instanceof Array)) {
-		this._keyHandlers[key] = [];
-	}
-	this._keyHandlers[key].push({modifiers:modifiers || 0, handler:handler});
-}, onKeyPressed:function (e) {
-	this.onDisplayChanged();
-}, onClick:function (e) {
-	this.onDisplayChanged(e);
-}, onBlur:function (e) {
-}, _initialFocus:true, onFocus:function (e) {
-	if ((dojo.render.html.mozilla) && (this._initialFocus)) {
-		this._initialFocus = false;
-		if (dojo.string.trim(this.editNode.innerHTML) == "&nbsp;") {
-			this.placeCursorAtStart();
-		}
-	}
-}, blur:function () {
-	if (this.iframe) {
-		this.window.blur();
-	} else {
-		if (this.object) {
-			this.document.body.blur();
-		} else {
-			if (this.editNode) {
-				this.editNode.blur();
+		},
+		
+		/** Fired on keyup */
+		onKeyUp: function(e){
+			return;
+		},
+		
+		KEY_CTRL: 1,
+		
+		/** Fired on keypress. */
+		onKeyPress: function(e){
+			if((!e)&&(this.object)){
+				e = dojo.event.browser.fixEvent(this.window.event);
 			}
-		}
-	}
-}, focus:function () {
-	if (this.iframe && !dojo.render.html.ie) {
-		this.window.focus();
-	} else {
-		if (this.object) {
-			this.document.focus();
-		} else {
-			if (this.editNode && this.editNode.focus) {
-				this.editNode.focus();
+			// handle the various key events
+
+			var character = e.charCode > 0 ? String.fromCharCode(e.charCode) : null;
+			var code = e.keyCode;
+
+			var modifiers = e.ctrlKey ? this.KEY_CTRL : 0;
+
+			if (this._keyHandlers[character]) {
+				dojo.debug("char:", character);
+				var handlers = this._keyHandlers[character], i = 0, handler;
+				while (handler = handlers[i++]) {
+					if (modifiers == handler.modifiers) {
+						handler.handler.call(this);
+						e.preventDefault();
+						break;
+					}
+				}
+			}
+			
+			/*
+			// define some key combos
+			if (e.ctrlKey || e.metaKey) { // modifier pressed
+				switch (character) {
+					case "b": this.execCommand("bold"); break;
+					case "i": this.execCommand("italic"); break;
+					case "u": this.execCommand("underline"); break;
+					//case "a": this.execCommand("selectall"); break;
+					//case "k": this.execCommand("createlink", ""); break;
+					//case "K": this.execCommand("unlink"); break;
+					case "Z": this.execCommand("redo"); break;
+					case "s": this.close(true); break; // saves
+					
+					case "1": this.execCommand("formatblock", "h1"); break;
+					case "2": this.execCommand("formatblock", "h2"); break;
+					case "3": this.execCommand("formatblock", "h3"); break;
+					case "4": this.execCommand("formatblock", "h4"); break;
+					
+					case "\\": this.execCommand("insertunorderedlist"); break;
+					
+					default: switch (code) {
+						case e.KEY_LEFT_ARROW:
+						case e.KEY_RIGHT_ARROW:
+							//break; // preventDefault stops the browser
+								   // going through its history
+						default:
+							preventDefault = false; break; // didn't handle here
+					}
+				}
 			} else {
-				dojo.debug("Have no idea how to focus into the editor!");
+				switch (code) {
+					case e.KEY_TAB:
+					  // commenting out bcs it's crashing FF
+						// this.execCommand(e.shiftKey ? "unindent" : "indent");
+						// break;
+					default:
+						preventDefault = false; break; // didn't handle here
+				}
 			}
-		}
-	}
-}, onDisplayChanged:function (e) {
-}, _activeX:{command:{bold:5000, italic:5023, underline:5048, justifycenter:5024, justifyleft:5025, justifyright:5026, cut:5003, copy:5002, paste:5032, "delete":5004, undo:5049, redo:5033, removeformat:5034, selectall:5035, unlink:5050, indent:5018, outdent:5031, insertorderedlist:5030, insertunorderedlist:5051, inserttable:5022, insertcell:5019, insertcol:5020, insertrow:5021, deletecells:5005, deletecols:5006, deleterows:5007, mergecells:5029, splitcell:5047, setblockformat:5043, getblockformat:5011, getblockformatnames:5012, setfontname:5044, getfontname:5013, setfontsize:5045, getfontsize:5014, setbackcolor:5042, getbackcolor:5010, setforecolor:5046, getforecolor:5015, findtext:5008, font:5009, hyperlink:5016, image:5017, lockelement:5027, makeabsolute:5028, sendbackward:5036, bringforward:5037, sendbelowtext:5038, bringabovetext:5039, sendtoback:5040, bringtofront:5041, properties:5052}, ui:{"default":0, prompt:1, noprompt:2}, status:{notsupported:0, disabled:1, enable!
 d:3, latched:7, ninched:11}, appearance:{flat:0, inset:1}, state:{unchecked:0, checked:1, gray:2}}, _normalizeCommand:function (cmd) {
-	var drh = dojo.render.html;
-	var command = cmd.toLowerCase();
-	if (command == "formatblock") {
-		if (drh.safari) {
-			command = "heading";
-		}
-	} else {
-		if (this.object) {
-			switch (command) {
-			  case "createlink":
-				command = "hyperlink";
-				break;
-			  case "insertimage":
-				command = "image";
-				break;
+			
+			if (preventDefault) { e.preventDefault(); }
+			*/
+
+			// function call after the character has been inserted
+			dojo.lang.setTimeout(this, this.onKeyPressed, 1, e);
+		},
+		
+		addKeyHandler: function (key, modifiers, handler) {
+			if (!(this._keyHandlers[key] instanceof Array)) { this._keyHandlers[key] = []; }
+			this._keyHandlers[key].push({
+				modifiers: modifiers || 0,
+				handler: handler
+			});
+		},
+		
+		
+		
+		/**
+		 * Fired after a keypress event has occured and it's action taken. This
+		 * is useful if action needs to be taken after text operations have
+		 * finished
+		 */
+		onKeyPressed: function (e) {
+			// Mozilla adds a single <p> with an embedded <br> when you hit enter once:
+			//   <p><br>\n</p>
+			// when you hit enter again it adds another <br> inside your enter
+			//   <p><br>\n<br>\n</p>
+			// and if you hit enter again it splits the <br>s over 2 <p>s
+			//   <p><br>\n</p>\n<p><br>\n</p>
+			// now this assumes that <p>s have double the line-height of <br>s to work
+			// and so we need to remove the <p>s to ensure the position of the cursor
+			// changes from the users perspective when they hit enter, as the second two
+			// html snippets render the same when margins are set to 0.
+			
+			// TODO: doesn't really work; is this really needed?
+			//if (dojo.render.html.moz) {
+			//	for (var i = 0; i < this.document.getElementsByTagName("p").length; i++) {
+			//		var p = this.document.getElementsByTagName("p")[i];
+			//		if (p.innerHTML.match(/^<br>\s$/m)) {
+			//			while (p.hasChildNodes()) { p.parentNode.insertBefore(p.firstChild, p); }
+			//			p.parentNode.removeChild(p);
+			//		}
+			//	}
+			//}
+			this.onDisplayChanged(/*e*/); // can't pass in e
+		},
+		
+		onClick: function(e){ this.onDisplayChanged(e); },
+		onBlur: function(e){ },
+		_initialFocus: true,
+		onFocus: function(e){ 
+			if( (dojo.render.html.mozilla)&&(this._initialFocus) ){
+				this._initialFocus = false;
+				if(dojo.string.trim(this.editNode.innerHTML) == "&nbsp;"){
+					this.execCommand("selectall");
+					this.window.getSelection().collapseToStart();
+				}
 			}
-		} else {
-			if (command == "hilitecolor" && !drh.mozilla) {
-				command = "backcolor";
+		},
+
+		blur: function () {
+			if (this.iframe) { this.window.blur(); }
+			else if (this.editNode) { this.editNode.blur(); }
+		},
+		
+		focus: function () {
+			if(this.iframe){
+				this.window.focus();
+			}else if(this.editNode){
+				this.editNode.focus();
 			}
-		}
-	}
-	return command;
-}, _safariIsLeopard:function () {
-	var gt420 = false;
-	if (dojo.render.html.safari) {
-		var tmp = dojo.render.html.UA.split("AppleWebKit/")[1];
-		var ver = parseFloat(tmp.split(" ")[0]);
-		if (ver >= 420) {
-			gt420 = true;
-		}
-	}
-	return gt420;
-}, queryCommandAvailable:function (command) {
-	var ie = 1;
-	var mozilla = 1 << 1;
-	var safari = 1 << 2;
-	var opera = 1 << 3;
-	var safari420 = 1 << 4;
-	var gt420 = this._safariIsLeopard();
-	function isSupportedBy(browsers) {
-		return {ie:Boolean(browsers & ie), mozilla:Boolean(browsers & mozilla), safari:Boolean(browsers & safari), safari420:Boolean(browsers & safari420), opera:Boolean(browsers & opera)};
-	}
-	var supportedBy = null;
-	switch (command.toLowerCase()) {
-	  case "bold":
-	  case "italic":
-	  case "underline":
-	  case "subscript":
-	  case "superscript":
-	  case "fontname":
-	  case "fontsize":
-	  case "forecolor":
-	  case "hilitecolor":
-	  case "justifycenter":
-	  case "justifyfull":
-	  case "justifyleft":
-	  case "justifyright":
-	  case "delete":
-	  case "selectall":
-		supportedBy = isSupportedBy(mozilla | ie | safari | opera);
-		break;
-	  case "createlink":
-	  case "unlink":
-	  case "removeformat":
-	  case "inserthorizontalrule":
-	  case "insertimage":
-	  case "insertorderedlist":
-	  case "insertunorderedlist":
-	  case "indent":
-	  case "outdent":
-	  case "formatblock":
-	  case "inserthtml":
-	  case "undo":
-	  case "redo":
-	  case "strikethrough":
-		supportedBy = isSupportedBy(mozilla | ie | opera | safari420);
-		break;
-	  case "blockdirltr":
-	  case "blockdirrtl":
-	  case "dirltr":
-	  case "dirrtl":
-	  case "inlinedirltr":
-	  case "inlinedirrtl":
-		supportedBy = isSupportedBy(ie);
-		break;
-	  case "cut":
-	  case "copy":
-	  case "paste":
-		supportedBy = isSupportedBy(ie | mozilla | safari420);
-		break;
-	  case "inserttable":
-		supportedBy = isSupportedBy(mozilla | (this.object ? ie : 0));
-		break;
-	  case "insertcell":
-	  case "insertcol":
-	  case "insertrow":
-	  case "deletecells":
-	  case "deletecols":
-	  case "deleterows":
-	  case "mergecells":
-	  case "splitcell":
-		supportedBy = isSupportedBy(this.object ? ie : 0);
-		break;
-	  default:
-		return false;
-	}
-	return (dojo.render.html.ie && supportedBy.ie) || (dojo.render.html.mozilla && supportedBy.mozilla) || (dojo.render.html.safari && supportedBy.safari) || (gt420 && supportedBy.safari420) || (dojo.render.html.opera && supportedBy.opera);
-}, execCommand:function (command, argument) {
-	var returnValue;
-	this.focus();
-	command = this._normalizeCommand(command);
-	if (argument != undefined) {
-		if (command == "heading") {
-			throw new Error("unimplemented");
-		} else {
-			if (command == "formatblock") {
-				if (this.object) {
-					argument = this._native2LocalFormatNames[argument];
-				} else {
-					if (dojo.render.html.ie) {
-						argument = "<" + argument + ">";
-					}
-				}
+		},
+		
+		/** this event will be fired everytime the display context changes and the
+		 result needs to be reflected in the UI */
+		onDisplayChanged: function (e){ },
+		
+
+	/* Formatting commands
+	 **********************/
+		
+		/** IE's Active X codes */
+		_activeX: {
+			command: {
+				bold: 5000,
+				italic: 5023,
+				underline: 5048,
+
+				justifycenter: 5024,
+				justifyleft: 5025,
+				justifyright: 5026,
+
+				cut: 5003,
+				copy: 5002,
+				paste: 5032,
+				"delete": 5004,
+
+				undo: 5049,
+				redo: 5033,
+
+				removeformat: 5034,
+				selectall: 5035,
+				unlink: 5050,
+
+				indent: 5018,
+				outdent: 5031,
+
+				insertorderedlist: 5030,
+				insertunorderedlist: 5051,
+
+				// table commands
+				inserttable: 5022,
+				insertcell: 5019,
+				insertcol: 5020,
+				insertrow: 5021,
+				deletecells: 5005,
+				deletecols: 5006,
+				deleterows: 5007,
+				mergecells: 5029,
+				splitcell: 5047,
+				
+				// the command need mapping, they don't translate directly
+				// to the contentEditable commands
+				setblockformat: 5043,
+				getblockformat: 5011,
+				getblockformatnames: 5012,
+				setfontname: 5044,
+				getfontname: 5013,
+				setfontsize: 5045,
+				getfontsize: 5014,
+				setbackcolor: 5042,
+				getbackcolor: 5010,
+				setforecolor: 5046,
+				getforecolor: 5015,
+				
+				findtext: 5008,
+				font: 5009,
+				hyperlink: 5016,
+				image: 5017,
+				
+				lockelement: 5027,
+				makeabsolute: 5028,
+				sendbackward: 5036,
+				bringforward: 5037,
+				sendbelowtext: 5038,
+				bringabovetext: 5039,
+				sendtoback: 5040,
+				bringtofront: 5041,
+				
+				properties: 5052
+			},
+			
+			ui: {
+				"default": 0,
+				prompt: 1,
+				noprompt: 2
+			},
+			
+			status: {
+				notsupported: 0,
+				disabled: 1,
+				enabled: 3,
+				latched: 7,
+				ninched: 11
+			},
+			
+			appearance: {
+				flat: 0,
+				inset: 1
+			},
+			
+			state: {
+				unchecked: 0,
+				checked: 1,
+				gray: 2
 			}
-		}
-	}
-	if (this.object) {
-		switch (command) {
-		  case "hilitecolor":
-			command = "setbackcolor";
-			break;
-		  case "forecolor":
-		  case "backcolor":
-		  case "fontsize":
-		  case "fontname":
-			command = "set" + command;
-			break;
-		  case "formatblock":
-			command = "setblockformat";
-		}
-		if (command == "strikethrough") {
-			command = "inserthtml";
-			var range = this.document.selection.createRange();
-			if (!range.htmlText) {
-				return;
+		},
+		
+		/**
+		 * Used as the advice function by dojo.event.connect to map our
+		 * normalized set of commands to those supported by the target
+		 * browser
+		 *
+		 * @param arugments The arguments Array, containing at least one
+		 *                  item, the command and an optional second item,
+		 *                  an argument.
+		 */
+		_normalizeCommand: function (joinObject){
+			var drh = dojo.render.html;
+			
+			var command = joinObject.args[0].toLowerCase();
+			if(command == "formatblock"){
+				if(drh.safari){ command = "heading"; }
+				if(drh.ie){ joinObject.args[1] = "<"+joinObject.args[1]+">"; }
 			}
-			argument = range.htmlText.strike();
-		} else {
-			if (command == "inserthorizontalrule") {
-				command = "inserthtml";
-				argument = "<hr>";
+			if (command == "hilitecolor" && !drh.mozilla) { command = "backcolor"; }
+			joinObject.args[0] = command;
+			
+			if (joinObject.args.length > 1) { // a command was specified
+				var argument = joinObject.args[1];
+				if (command == "heading") { throw new Error("unimplemented"); }
+				joinObject.args[1] = argument;
 			}
-		}
-		if (command == "inserthtml") {
-			var range = this.document.selection.createRange();
-			if (this.document.selection.type.toUpperCase() == "CONTROL") {
-				for (var i = 0; i < range.length; i++) {
-					range.item(i).outerHTML = argument;
+			
+			return joinObject.proceed();
+		},
+		
+		/**
+		 * Tests whether a command is supported by the host. Clients SHOULD check
+		 * whether a command is supported before attempting to use it, behaviour
+		 * for unsupported commands is undefined.
+		 *
+		 * @param command The command to test for
+		 * @return true if the command is supported, false otherwise
+		 */
+		queryCommandAvailable: function (command) {
+			var ie = 1;
+			var mozilla = 1 << 1;
+			var safari = 1 << 2;
+			var opera = 1 << 3;
+			function isSupportedBy (browsers) {
+				return {
+					ie: Boolean(browsers & ie),
+					mozilla: Boolean(browsers & mozilla),
+					safari: Boolean(browsers & safari),
+					opera: Boolean(browsers & opera)
 				}
-			} else {
-				range.pasteHTML(argument);
-				range.select();
 			}
-			returnValue = true;
-		} else {
-			if (arguments.length == 1) {
-				returnValue = this.object.ExecCommand(this._activeX.command[command], this._activeX.ui.noprompt);
-			} else {
-				returnValue = this.object.ExecCommand(this._activeX.command[command], this._activeX.ui.noprompt, argument);
+
+			var supportedBy = null;
+			
+			switch (command.toLowerCase()) {
+				case "bold": case "italic": case "underline":
+				case "subscript": case "superscript":
+				case "fontname": case "fontsize":
+				case "forecolor": case "hilitecolor":
+				case "justifycenter": case "justifyfull": case "justifyleft": 
+				case "justifyright": case "delete": case "undo": case "redo":
+					supportedBy = isSupportedBy(mozilla | ie | safari | opera);
+					break;
+					
+				case "createlink": case "unlink": case "removeformat":
+				case "inserthorizontalrule": case "insertimage":
+				case "insertorderedlist": case "insertunorderedlist":
+				case "indent": case "outdent": case "formatblock": 
+				case "inserthtml":
+					supportedBy = isSupportedBy(mozilla | ie | opera);
+					break;
+					
+				case "strikethrough": 
+					supportedBy = isSupportedBy(mozilla |  opera | (this.object ? 0 : ie));
+					break;
+
+				case "blockdirltr": case "blockdirrtl":
+				case "dirltr": case "dirrtl":
+				case "inlinedirltr": case "inlinedirrtl":
+				case "cut": case "copy": case "paste": 
+					supportedBy = isSupportedBy(ie);
+					break;
+				
+				case "inserttable":
+					supportedBy = isSupportedBy(mozilla | (this.object ? ie : 0));
+					break;
+				
+				case "insertcell": case "insertcol": case "insertrow":
+				case "deletecells": case "deletecols": case "deleterows":
+				case "mergecells": case "splitcell":
+					supportedBy = isSupportedBy(this.object ? ie : 0);
+					break;
+				
+				default: return false;
 			}
-		}
-	} else {
-		if (command == "inserthtml") {
-			if (dojo.render.html.ie) {
-				var insertRange = this.document.selection.createRange();
-				insertRange.pasteHTML(argument);
-				insertRange.select();
-				return true;
-			} else {
-				return this.document.execCommand(command, false, argument);
-			}
-		} else {
-			if ((command == "unlink") && (this.queryCommandEnabled("unlink")) && (dojo.render.html.mozilla)) {
+			
+			return (dojo.render.html.ie && supportedBy.ie) ||
+				(dojo.render.html.mozilla && supportedBy.mozilla) ||
+				(dojo.render.html.safari && supportedBy.safari) ||
+				(dojo.render.html.opera && supportedBy.opera);
+		},
+
+		/**
+		 * Executes a command in the Rich Text area
+		 *
+		 * @param command The command to execute
+		 * @param argument An optional argument to the command
+		 */
+		execCommand: function (command, argument){
+			var returnValue;
+			if(this.object){
+				if(command == "forecolor"){
+					command = "setforecolor";
+				}else if(command == "backcolor"){
+					command = "setbackcolor";
+				}
+			
+				//if (typeof this._activeX.command[command] == "undefined") { return null; }
+			
+				if(command == "inserttable"){
+					var tableInfo = this.constructor._tableInfo;
+					if(!tableInfo){
+						tableInfo = document.createElement("object");
+						tableInfo.classid = "clsid:47B0DFC7-B7A3-11D1-ADC5-006008A5848C";
+						document.body.appendChild(tableInfo);
+						this.constructor._table = tableInfo;
+					}
+					
+					tableInfo.NumRows = argument["rows"];
+					tableInfo.NumCols = argument["cols"];
+					tableInfo.TableAttrs = argument["TableAttrs"];
+					tableInfo.CellAttrs = argument["CellAttrs"];
+					tableInfo.Caption = argument["Caption"];
+				}
+			
+				if(command == "inserthtml"){
+					var insertRange = this.document.selection.createRange();
+					insertRange.select();
+					insertRange.pasteHTML(argument);
+					insertRange.collapse(true);
+					return true;
+				}else if(arguments.length == 1){
+					return this.object.ExecCommand(this._activeX.command[command],
+						this._activeX.ui.noprompt);
+				}else{
+					return this.object.ExecCommand(this._activeX.command[command],
+						this._activeX.ui.noprompt, argument);
+				}
+		
+			/* */
+			}else if(command == "inserthtml"){
+				// on IE, we can use the pasteHTML method of the textRange object
+				// to get an undo-able innerHTML modification
+				if(dojo.render.html.ie){
+					dojo.debug("inserthtml breaks the undo stack when not using the ActiveX version of the control!");
+					var insertRange = this.document.selection.createRange();
+					insertRange.select();
+					insertRange.pasteHTML(argument);
+					insertRange.collapse(true);
+					return true;
+				}else{
+					return this.document.execCommand(command, false, argument);			
+				}
+			/* */
+			// fix up unlink in Mozilla to unlink the link and not just the selection
+			}else if((command == "unlink")&&
+				(this.queryCommandEnabled("unlink"))&&
+				(dojo.render.html.mozilla)){
+				// grab selection
+				// Mozilla gets upset if we just store the range so we have to
+				// get the basic properties and recreate to save the selection
 				var selection = this.window.getSelection();
 				var selectionRange = selection.getRangeAt(0);
 				var selectionStartContainer = selectionRange.startContainer;
 				var selectionStartOffset = selectionRange.startOffset;
 				var selectionEndContainer = selectionRange.endContainer;
 				var selectionEndOffset = selectionRange.endOffset;
-				var a = dojo.withGlobal(this.window, "getAncestorElement", dojo.html.selection, ["a"]);
-				dojo.withGlobal(this.window, "selectElement", dojo.html.selection, [a]);
+				
+				// select our link and unlink
+				var range = document.createRange();
+				var a = this.getSelectedNode();
+				while(a.nodeName != "A"){ a = a.parentNode; }
+				range.selectNode(a);
+				selection.removeAllRanges();
+				selection.addRange(range);
+				
 				returnValue = this.document.execCommand("unlink", false, null);
-				var selectionRange = this.document.createRange();
+				
+				// restore original selection
+				var selectionRange = document.createRange();
 				selectionRange.setStart(selectionStartContainer, selectionStartOffset);
 				selectionRange.setEnd(selectionEndContainer, selectionEndOffset);
 				selection.removeAllRanges();
 				selection.addRange(selectionRange);
+				
 				return returnValue;
-			} else {
-				if ((command == "hilitecolor") && (dojo.render.html.mozilla)) {
-					this.document.execCommand("useCSS", false, false);
-					returnValue = this.document.execCommand(command, false, argument);
-					this.document.execCommand("useCSS", false, true);
-				} else {
-					if ((dojo.render.html.ie) && ((command == "backcolor") || (command == "forecolor"))) {
-						argument = arguments.length > 1 ? argument : null;
-						returnValue = this.document.execCommand(command, false, argument);
-					} else {
-						argument = arguments.length > 1 ? argument : null;
-						if (argument || command != "createlink") {
-							returnValue = this.document.execCommand(command, false, argument);
-						}
-					}
+			}else if((command == "inserttable")&&(dojo.render.html.mozilla)){
+
+				var cols = "<tr>";
+				for (var i = 0; i < argument.cols; i++) { cols += "<td></td>"; }
+				cols += "</tr>";
+			
+				var table = "<table><tbody>";
+				for (var i = 0; i < argument.rows; i++) { table += cols; }
+				table += "</tbody></table>";
+				returnValue = this.document.execCommand("inserthtml", false, table);
+
+			}else if((command == "hilitecolor")&&(dojo.render.html.mozilla)){
+				// mozilla doesn't support hilitecolor properly when useCSS is
+				// set to false (bugzilla #279330)
+				
+				this.document.execCommand("useCSS", false, false);
+				returnValue = this.document.execCommand(command, false, argument);			
+				this.document.execCommand("useCSS", false, true);
+			
+			}else if((dojo.render.html.ie)&&( (command == "backcolor")||(command == "forecolor") )){
+				// IE weirdly collapses ranges when we exec these commands, so prevent it	
+				var tr = this.document.selection.createRange();
+				argument = arguments.length > 1 ? argument : null;
+				returnValue = this.document.execCommand(command, false, argument);
+				// timeout is workaround for weird IE behavior were the text
+				// selection gets correctly re-created, but subsequent input
+				// apparently isn't bound to it
+				setTimeout(function(){tr.select();}, 1);
+			}else{
+				// dojo.debug("command:", command, "arg:", argument);
+
+				argument = arguments.length > 1 ? argument : null;
+				if(dojo.render.html.moz){
+					this.document = this.iframe.contentWindow.document
 				}
+				returnValue = this.document.execCommand(command, false, argument);
+
+				// try{
+				// }catch(e){
+				// 	dojo.debug(e);
+				// }
 			}
-		}
-	}
-	this.onDisplayChanged();
-	return returnValue;
-}, queryCommandEnabled:function (command) {
-	command = this._normalizeCommand(command);
-	if (this.object) {
-		switch (command) {
-		  case "hilitecolor":
-			command = "setbackcolor";
-			break;
-		  case "forecolor":
-		  case "backcolor":
-		  case "fontsize":
-		  case "fontname":
-			command = "set" + command;
-			break;
-		  case "formatblock":
-			command = "setblockformat";
-			break;
-		  case "strikethrough":
-			command = "bold";
-			break;
-		  case "inserthorizontalrule":
-			return true;
-		}
-		if (typeof this._activeX.command[command] == "undefined") {
-			return false;
-		}
-		var status = this.object.QueryStatus(this._activeX.command[command]);
-		return ((status != this._activeX.status.notsupported) && (status != this._activeX.status.disabled));
-	} else {
-		if (dojo.render.html.mozilla) {
-			if (command == "unlink") {
-				return dojo.withGlobal(this.window, "hasAncestorElement", dojo.html.selection, ["a"]);
-			} else {
-				if (command == "inserttable") {
+			
+			this.onDisplayChanged();
+			return returnValue;
+		},
+
+		queryCommandEnabled: function(command, argument){
+			if(this.object){
+				if(command == "forecolor"){
+					command = "setforecolor";
+				}else if(command == "backcolor"){
+					command = "setbackcolor";
+				}
+
+				if(typeof this._activeX.command[command] == "undefined"){ return false; }
+				var status = this.object.QueryStatus(this._activeX.command[command]);
+				return ((status != this.activeX.status.notsupported)&& 
+					(status != this.activeX.status.diabled));
+			}else{
+				// mozilla returns true always
+				if(command == "unlink" && dojo.render.html.mozilla){
+					var node = this.getSelectedNode();
+					while (node.parentNode && node.nodeName != "A") { node = node.parentNode; }
+					return node.nodeName == "A";
+				} else if (command == "inserttable" && dojo.render.html.mozilla) {
 					return true;
 				}
+
+				// return this.document.queryCommandEnabled(command);
+				var elem = (dojo.render.html.ie) ? this.document.selection.createRange() : this.document;
+				return elem.queryCommandEnabled(command);
 			}
-		}
-		var elem = (dojo.render.html.ie) ? this.document.selection.createRange() : this.document;
-		return elem.queryCommandEnabled(command);
-	}
-}, queryCommandState:function (command) {
-	command = this._normalizeCommand(command);
-	if (this.object) {
-		if (command == "forecolor") {
-			command = "setforecolor";
-		} else {
-			if (command == "backcolor") {
-				command = "setbackcolor";
+		},
+
+		queryCommandState: function(command, argument){
+			if(this.object){
+				if(command == "forecolor"){
+					command = "setforecolor";
+				}else if(command == "backcolor"){
+					command = "setbackcolor";
+				}
+
+				if(typeof this._activeX.command[command] == "undefined"){ return null; }
+				var status = this.object.QueryStatus(this._activeX.command[command]);
+				return ((status == this._activeX.status.enabled)||
+					(status == this._activeX.status.ninched));
+			}else{
+				return this.document.queryCommandState(command);
+			}
+		},
+
+		queryCommandValue: function (command, argument) {
+			if (this.object) {
+				switch (command) {
+					case "forecolor":
+					case "backcolor":
+					case "fontsize":
+					case "fontname":
+					case "blockformat":
+						command = "get" + command;
+						return this.object.execCommand(
+							this._activeX.command[command],
+							this._activeX.ui.noprompt);
+				}			
+			
+				//var status = this.object.QueryStatus(this._activeX.command[command]);
 			} else {
-				if (command == "strikethrough") {
-					return dojo.withGlobal(this.window, "hasAncestorElement", dojo.html.selection, ["strike"]);
+				return this.document.queryCommandValue(command);
+			}
+		},
+		
+		
+	/* Misc.
+	 ********/
+
+		getSelectedNode: function(){
+			if(!this.isLoaded){ return; }
+			if(this.document.selection){
+				return this.document.selection.createRange().parentElement();
+			}else if(dojo.render.html.mozilla){
+				return this.window.getSelection().getRangeAt(0).commonAncestorContainer;
+			}
+			return this.editNode;
+		},
+		
+		placeCursorAtStart: function(){
+			if(!this.isLoaded){
+				dojo.event.connect(this, "onLoad", this, "placeCursorAtEnd");
+				return;
+			}
+			dojo.event.disconnect(this, "onLoad", this, "placeCursorAtEnd");
+			if(this.window.getSelection){
+				var selection = this.window.getSelection;
+				if(selection.removeAllRanges){ // Mozilla
+					var range = this.document.createRange();
+					range.selectNode(this.editNode.firstChild);
+					range.collapse(true);
+					var selection = this.window.getSelection();
+					selection.removeAllRanges();
+					selection.addRange(range);
+				}else{ // Safari
+					// not a great deal we can do
+				}
+			}else if(this.document.selection){ // IE
+				var range = this.document.body.createTextRange();
+				range.moveToElementText(this.editNode);
+				range.collapse(true);
+				range.select();
+			}
+		},
+
+		replaceEditorContent: function(html){
+			if(this.window.getSelection){
+				var selection = this.window.getSelection;
+				// if(selection.removeAllRanges){ // Mozilla			
+				if(dojo.render.html.moz){ // Mozilla			
+					var range = this.document.createRange();
+					range.selectNodeContents(this.editNode);
+					var selection = this.window.getSelection();
+					selection.removeAllRanges();
+					selection.addRange(range);
+					this.execCommand("inserthtml", html);
+				}else{ // Safari
+					// look ma! it's a totally f'd browser!
+					this.editNode.innerHTML = html;
+				}
+			}else if(this.document.selection){ // IE
+				var range = this.document.body.createTextRange();
+				range.moveToElementText(this.editNode);
+				range.select();
+				this.execCommand("inserthtml", html);
+			}
+		},
+		
+		placeCursorAtEnd: function(){
+			if(!this.isLoaded){
+				dojo.event.connect(this, "onLoad", this, "placeCursorAtEnd");
+				return;
+			}
+			dojo.event.disconnect(this, "onLoad", this, "placeCursorAtEnd");
+			if(this.window.getSelection){
+				var selection = this.window.getSelection;
+				if(selection.removeAllRanges){ // Mozilla
+					var range = this.document.createRange();
+					range.selectNode(this.editNode.lastChild);
+					range.collapse(false);
+					var selection = this.window.getSelection();
+					selection.removeAllRanges();
+					selection.addRange(range);
+				}else{ // Safari
+					// not a great deal we can do
+				}
+			}else if(this.document.selection){ // IE
+				var range = this.document.body.createTextRange();
+				range.moveToElementText(this.editNode);
+				range.collapse(true);
+				range.select();
+			}
+		},
+
+		_lastHeight: 0,
+
+		/** Updates the height of the iframe to fit the contents. */
+		_updateHeight: function(){
+			if(!this.isLoaded){ return; }
+			if(this.height){ return; }
+			if(this.iframe){
+				/*
+				if(!this.document.body["offsetHeight"]){
+					return;
+				}
+				*/
+				// The height includes the padding, borders and margins so these
+				// need to be added on
+				var heights = ["margin-top", "margin-bottom",
+					"padding-bottom", "padding-top",
+					"border-width-bottom", "border-width-top"];
+				for(var i = 0, chromeheight = 0; i < heights.length; i++){
+					var height = dojo.style.getStyle(this.iframe, heights[i]);
+					// Safari doesn't have all the heights so we have to test
+					if(height){
+						chromeheight += Number(height.replace(/[^0-9]/g, ""));
+					}
+				}
+
+				if(this.document.body["offsetHeight"]){
+					this._lastHeight = Math.max(this.document.body.scrollHeight, this.document.body.offsetHeight) + chromeheight;
+					this.iframe.height = this._lastHeight + "px";
+					this.window.scrollTo(0, 0);
+				}
+				// dojo.debug(this.iframe.height);
+			}else if(this.object){
+				this.object.style.height = dojo.style.getInnerHeight(this.editNode)+"px";
+			}
+		},
+		
+		/**
+		 * Saves the content in an onunload event if the editor has not been closed
+		 */
+		_saveContent: function(e){
+			var saveTextarea = document.getElementById("dojo.widget.RichText.savedContent");
+			saveTextarea.value += this._SEPARATOR + this.saveName + ":" + this.getEditorContent();
+		},
+
+		getEditorContent: function(){
+			var ec = "";
+			try{
+				ec = (this._content.length > 0) ? this._content : this.editNode.innerHTML;
+				if(dojo.string.trim(ec) == "&nbsp;"){ ec = ""; }
+			}catch(e){ /* squelch */ }
+
+			dojo.lang.forEach(this.contentFilters, function(ef){
+				ec = ef(ec);
+			});
+
+			if (this.relativeImageUrls) {
+				// why use a regexp instead of dom? because IE is stupid 
+				// and won't let us set img.src to a relative URL
+				// this comes after contentFilters because once content
+				// gets innerHTML'd img urls will be fully qualified
+				var siteBase = window.location.protocol + "//" + window.location.host;
+				var pathBase = window.location.pathname;
+				if (pathBase.match(/\/$/)) {
+					// ends with slash, match full path
 				} else {
-					if (command == "inserthorizontalrule") {
-						return false;
+					// match parent path to find siblings
+					var pathParts = pathBase.split("/");
+					if (pathParts.length) {
+						pathParts.pop();
 					}
+					pathBase = pathParts.join("/") + "/";
+
 				}
+				
+				var sameSite = new RegExp("(<img[^>]*\ src=[\"'])("+siteBase+"("+pathBase+")?)", "ig");
+				ec = ec.replace(sameSite, "$1");
 			}
-		}
-		if (typeof this._activeX.command[command] == "undefined") {
-			return null;
-		}
-		var status = this.object.QueryStatus(this._activeX.command[command]);
-		return ((status == this._activeX.status.latched) || (status == this._activeX.status.ninched));
-	} else {
-		return this.document.queryCommandState(command);
-	}
-}, queryCommandValue:function (command) {
-	command = this._normalizeCommand(command);
-	if (this.object) {
-		switch (command) {
-		  case "forecolor":
-		  case "backcolor":
-		  case "fontsize":
-		  case "fontname":
-			command = "get" + command;
-			return this.object.execCommand(this._activeX.command[command], this._activeX.ui.noprompt);
-		  case "formatblock":
-			var retvalue = this.object.execCommand(this._activeX.command["getblockformat"], this._activeX.ui.noprompt);
-			if (retvalue) {
-				return this._local2NativeFormatNames[retvalue];
+			return ec;
+		},
+		
+		/**
+		 * Kills the editor and optionally writes back the modified contents to the 
+		 * element from which it originated.
+		 *
+		 * @param save Whether or not to save the changes. If false, the changes are
+		 *             discarded.
+		 * @return true if the contents has been modified, false otherwise
+		 */
+		close: function(save, force){
+			if(this.isClosed){return false; }
+
+			if (arguments.length == 0) { save = true; }
+			this._content = this.editNode.innerHTML;
+			var changed = (this.savedContent.innerHTML != this._content);
+			
+			// line height is squashed for iframes
+			// FIXME: why was this here? if (this.iframe){ this.domNode.style.lineHeight = null; }
+
+			if(this.interval){ clearInterval(this.interval); }
+			
+			if(dojo.render.html.ie && !this.object){
+				dojo.event.browser.clean(this.editNode);
 			}
-		}
-	} else {
-		if (dojo.render.html.ie && command == "formatblock") {
-			return this._local2NativeFormatNames[this.document.queryCommandValue(command)] || this.document.queryCommandValue(command);
-		}
-		return this.document.queryCommandValue(command);
-	}
-}, placeCursorAtStart:function () {
-	this.focus();
-	if (dojo.render.html.moz && this.editNode.firstChild && this.editNode.firstChild.nodeType != dojo.dom.TEXT_NODE) {
-		dojo.withGlobal(this.window, "selectElementChildren", dojo.html.selection, [this.editNode.firstChild]);
-	} else {
-		dojo.withGlobal(this.window, "selectElementChildren", dojo.html.selection, [this.editNode]);
-	}
-	dojo.withGlobal(this.window, "collapse", dojo.html.selection, [true]);
-}, placeCursorAtEnd:function () {
-	this.focus();
-	if (dojo.render.html.moz && this.editNode.lastChild && this.editNode.lastChild.nodeType != dojo.dom.TEXT_NODE) {
-		dojo.withGlobal(this.window, "selectElementChildren", dojo.html.selection, [this.editNode.lastChild]);
-	} else {
-		dojo.withGlobal(this.window, "selectElementChildren", dojo.html.selection, [this.editNode]);
-	}
-	dojo.withGlobal(this.window, "collapse", dojo.html.selection, [false]);
-}, replaceEditorContent:function (html) {
-	html = this._preFilterContent(html);
-	if (this.isClosed) {
-		this.domNode.innerHTML = html;
-	} else {
-		if (this.window && this.window.getSelection && !dojo.render.html.moz) {
-			this.editNode.innerHTML = html;
-		} else {
-			if ((this.window && this.window.getSelection) || (this.document && this.document.selection)) {
-				this.execCommand("selectall");
-				if (dojo.render.html.moz && !html) {
-					html = "&nbsp;";
+			
+			if (this.iframe) {
+				// FIXME: should keep iframe around for later re-use
+				delete this.iframe;
+			}
+			this.domNode.innerHTML = "";
+
+			if(save){
+				// kill listeners on the saved content
+				dojo.event.browser.clean(this.savedContent);
+				if(dojo.render.html.moz){
+					var nc = document.createElement("span");
+					this.domNode.appendChild(nc);
+					nc.innerHTML = this.editNode.innerHTML;
+				}else{
+					this.domNode.innerHTML = this._content;
 				}
-				this.execCommand("inserthtml", html);
+			} else {
+				while (this.savedContent.hasChildNodes()) {
+					this.domNode.appendChild(this.savedContent.firstChild);
+				}
 			}
-		}
-	}
-}, _preFilterContent:function (html) {
-	var ec = html;
-	dojo.lang.forEach(this.contentPreFilters, function (ef) {
-		ec = ef(ec);
-	});
-	if (this.contentDomPreFilters.length > 0) {
-		var dom = dojo.doc().createElement("div");
-		dom.style.display = "none";
-		dojo.body().appendChild(dom);
-		dom.innerHTML = ec;
-		dojo.lang.forEach(this.contentDomPreFilters, function (ef) {
-			dom = ef(dom);
-		});
-		ec = dom.innerHTML;
-		dojo.body().removeChild(dom);
-	}
-	return ec;
-}, _postFilterContent:function (html) {
-	var ec = html;
-	if (this.contentDomPostFilters.length > 0) {
-		var dom = this.document.createElement("div");
-		dom.innerHTML = ec;
-		dojo.lang.forEach(this.contentDomPostFilters, function (ef) {
-			dom = ef(dom);
-		});
-		ec = dom.innerHTML;
-	}
-	dojo.lang.forEach(this.contentPostFilters, function (ef) {
-		ec = ef(ec);
-	});
-	return ec;
-}, _lastHeight:0, _updateHeight:function () {
-	if (!this.isLoaded) {
-		return;
-	}
-	if (this.height) {
-		return;
-	}
-	var height = dojo.html.getBorderBox(this.editNode).height;
-	if (!height) {
-		height = dojo.html.getBorderBox(this.document.body).height;
-	}
-	if (height == 0) {
-		dojo.debug("Can not figure out the height of the editing area!");
-		return;
-	}
-	this._lastHeight = height;
-	this.editorObject.style.height = this._lastHeight + "px";
-	this.window.scrollTo(0, 0);
-}, _saveContent:function (e) {
-	var saveTextarea = dojo.doc().getElementById("dojo.widget.RichText.savedContent");
-	saveTextarea.value += this._SEPARATOR + this.saveName + ":" + this.getEditorContent();
-}, getEditorContent:function () {
-	var ec = "";
-	try {
-		ec = (this._content.length > 0) ? this._content : this.editNode.innerHTML;
-		if (dojo.string.trim(ec) == "&nbsp;") {
-			ec = "";
-		}
-	}
-	catch (e) {
-	}
-	if (dojo.render.html.ie && !this.object) {
-		var re = new RegExp("(?:<p>&nbsp;</p>[\n\r]*)+$", "i");
-		ec = ec.replace(re, "");
-	}
-	ec = this._postFilterContent(ec);
-	if (this.relativeImageUrls) {
-		var siteBase = dojo.global().location.protocol + "//" + dojo.global().location.host;
-		var pathBase = dojo.global().location.pathname;
-		if (pathBase.match(/\/$/)) {
-		} else {
-			var pathParts = pathBase.split("/");
-			if (pathParts.length) {
-				pathParts.pop();
+			delete this.savedContent;
+			
+			dojo.html.removeClass(this.domNode, "RichTextEditable");
+			this.isClosed = true;
+			this.isLoaded = false;
+			// FIXME: is this always the right thing to do?
+			delete this.editNode;
+
+			return changed;
+		},
+
+		destroyRendering: function(){}, // stub!
+		
+		destroy: function (){
+			this.destroyRendering();
+			if(!this.isClosed){ this.close(false); }
+		
+			// disconnect those listeners.
+			while(this._connected.length){
+				this.disconnect(this._connected[0],
+					this._connected[1], this._connected[2]);
 			}
-			pathBase = pathParts.join("/") + "/";
-		}
-		var sameSite = new RegExp("(<img[^>]* src=[\"'])(" + siteBase + "(" + pathBase + ")?)", "ig");
-		ec = ec.replace(sameSite, "$1");
-	}
-	return ec;
-}, close:function (save, force) {
-	if (this.isClosed) {
-		return false;
-	}
-	if (arguments.length == 0) {
-		save = true;
-	}
-	this._content = this._postFilterContent(this.editNode.innerHTML);
-	var changed = (this.savedContent != this._content);
-	if (this.interval) {
-		clearInterval(this.interval);
-	}
-	if (dojo.render.html.ie && !this.object) {
-		dojo.event.browser.clean(this.editNode);
-	}
-	if (this.iframe) {
-		delete this.iframe;
-	}
-	if (this.textarea) {
-		with (this.textarea.style) {
-			position = "";
-			left = top = "";
-			if (dojo.render.html.ie) {
-				overflow = this.__overflow;
-				this.__overflow = null;
+		},
+
+		_connected: [],
+		connect: function (targetObj, targetFunc, thisFunc) {
+			dojo.event.connect(targetObj, targetFunc, this, thisFunc);
+			// this._connected.push([targetObj, targetFunc, thisFunc]);	
+		},
+		
+		// FIXME: below two functions do not work with the above line commented out
+		disconnect: function (targetObj, targetFunc, thisFunc) {
+			for (var i = 0; i < this._connected.length; i++) {
+				if (this._connected[0] == targetObj &&
+					this._connected[1] == targetFunc &&
+					this._connected[2] == thisFunc) {
+					dojo.event.disconnect(targetObj, targetFunc, this, thisFunc);
+					this._connected.splice(i, 1);
+					break;
+				}
 			}
+		},
+		
+		disconnectAllWithRoot: function (targetObj) {
+			for (var i = 0; i < this._connected.length; i++) {
+				if (this._connected[0] == targetObj) {
+					dojo.event.disconnect(targetObj,
+						this._connected[1], this, this._connected[2]);
+					this._connected.splice(i, 1);
+				}
+			}	
 		}
-		if (save) {
-			this.textarea.value = this._content;
-		} else {
-			this.textarea.value = this.savedContent;
-		}
-		dojo.html.removeNode(this.domNode);
-		this.domNode = this.textarea;
-	} else {
-		if (save) {
-			if (dojo.render.html.moz) {
-				var nc = dojo.doc().createElement("span");
-				this.domNode.appendChild(nc);
-				nc.innerHTML = this.editNode.innerHTML;
-			} else {
-				this.domNode.innerHTML = this._content;
-			}
-		} else {
-			this.domNode.innerHTML = this.savedContent;
-		}
+		
+	},
+	"html",
+	function(){
+		this.contentFilters = [];
+		// this.contentFilters.push(this.defaultContentCleaner);
+		
+		this._keyHandlers = {};
 	}
-	dojo.html.removeClass(this.domNode, "RichTextEditable");
-	this.isClosed = true;
-	this.isLoaded = false;
-	delete this.editNode;
-	if (this.window._frameElement) {
-		this.window._frameElement = null;
-	}
-	this.window = null;
-	this.document = null;
-	this.object = null;
-	this.editingArea = null;
-	this.editorObject = null;
-	return changed;
-}, destroyRendering:function () {
-}, destroy:function () {
-	this.destroyRendering();
-	if (!this.isClosed) {
-		this.close(false);
-	}
-	dojo.widget.RichText.superclass.destroy.call(this);
-}, connect:function (targetObj, targetFunc, thisFunc) {
-	dojo.event.connect(targetObj, targetFunc, this, thisFunc);
-}, disconnect:function (targetObj, targetFunc, thisFunc) {
-	dojo.event.disconnect(targetObj, targetFunc, this, thisFunc);
-}, disconnectAllWithRoot:function (targetObj) {
-	dojo.deprecated("disconnectAllWithRoot", "is deprecated. No need to disconnect manually", "0.5");
-}, _fixContentForMoz:function (html) {
-	html = html.replace(/<strong([ \>])/gi, "<b$1");
-	html = html.replace(/<\/strong>/gi, "</b>");
-	html = html.replace(/<em([ \>])/gi, "<i$1");
-	html = html.replace(/<\/em>/gi, "</i>");
-	return html;
-}});
-
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/Rounded.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Rounded.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Rounded.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,522 +8,706 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Rounded");
 dojo.widget.tags.addParseTreeHandler("dojo:rounded");
+
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.ContentPane");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.display");
-dojo.require("dojo.gfx.color");
-dojo.deprecated("dojo.widget.Rounded will be removed in version 0.5; you can now apply rounded corners to any block element using dojo.lfx.rounded.", "0.5");
-dojo.widget.defineWidget("dojo.widget.Rounded", dojo.widget.ContentPane, {isSafari:dojo.render.html.safari, boxMargin:"50px", radius:14, domNode:"", corners:"TR,TL,BR,BL", antiAlias:true, fillInTemplate:function (args, frag) {
-	dojo.widget.Rounded.superclass.fillInTemplate.call(this, args, frag);
-	dojo.html.insertCssFile(this.templateCssPath);
-	if (this.domNode.style.height <= 0) {
-		var minHeight = (this.radius * 1) + this.domNode.clientHeight;
-		this.domNode.style.height = minHeight + "px";
-	}
-	if (this.domNode.style.width <= 0) {
-		var minWidth = (this.radius * 1) + this.domNode.clientWidth;
-		this.domNode.style.width = minWidth + "px";
-	}
-	var cornersAvailable = ["TR", "TL", "BR", "BL"];
-	var cornersPassed = this.corners.split(",");
-	this.settings = {antiAlias:this.antiAlias};
-	var setCorner = function (currentCorner) {
-		var val = currentCorner.toLowerCase();
-		if (dojo.lang.inArray(cornersPassed, currentCorner)) {
-			this.settings[val] = {radius:this.radius, enabled:true};
-		} else {
-			this.settings[val] = {radius:0};
+dojo.require("dojo.widget.html.ContentPane");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+
+/*
+ *	The following script is derived (with permission) from curvyCorners,
+ *	written by Cameron Cooke (CLA on file) and was adapted to Dojo by Brian
+ *	Lucas (CLA on file)
+ */
+
+dojo.widget.Rounded = function() {
+	dojo.widget.html.ContentPane.call(this);
+}
+
+dojo.inherits(dojo.widget.Rounded, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.Rounded, {
+	isSafari: dojo.render.html.safari,
+	widgetType: "Rounded",
+	boxMargin: "50px", // margin outside rounded corner box
+	radius: 14, // radius of corners
+	domNode: "",
+	corners: "TR,TL,BR,BL", // corner string to render
+	antiAlias: true, // false to disable anti-aliasing
+
+	fillInTemplate: function(args, frag) {
+		dojo.widget.Rounded.superclass.fillInTemplate.call(this, args, frag);
+
+		dojo.style.insertCssFile(this.templateCssPath);
+
+		// Magic to automatically calculate the box height/width if not supplied
+		if (this.domNode.style.height<=0) {
+			var minHeight = (this.radius*1)+this.domNode.clientHeight;
+			this.domNode.style.height = minHeight+"px";
 		}
-	};
-	dojo.lang.forEach(cornersAvailable, setCorner, this);
-	this.domNode.style.margin = this.boxMargin;
-	this.curvyCorners(this.settings);
-	this.applyCorners();
-}, curvyCorners:function (settings) {
-	this.box = this.domNode;
-	this.topContainer = null;
-	this.bottomContainer = null;
-	this.masterCorners = [];
-	var boxHeight = dojo.html.getStyle(this.box, "height");
-	if (boxHeight == "") {
-		boxHeight = "0px";
-	}
-	var boxWidth = dojo.html.getStyle(this.box, "width");
-	var borderWidth = dojo.html.getStyle(this.box, "borderTopWidth");
-	if (borderWidth == "") {
-		borderWidth = "0px";
-	}
-	var borderColour = dojo.html.getStyle(this.box, "borderTopColor");
-	if (borderWidth > 0) {
-		this.antiAlias = true;
-	}
-	var boxColour = dojo.html.getStyle(this.box, "backgroundColor");
-	var backgroundImage = dojo.html.getStyle(this.box, "backgroundImage");
-	var boxPosition = dojo.html.getStyle(this.box, "position");
-	this.boxHeight = parseInt(((boxHeight != "" && boxHeight != "auto" && boxHeight.indexOf("%") == -1) ? boxHeight.substring(0, boxHeight.indexOf("px")) : this.box.scrollHeight));
-	this.boxWidth = parseInt(((boxWidth != "" && boxWidth != "auto" && boxWidth.indexOf("%") == -1) ? boxWidth.substring(0, boxWidth.indexOf("px")) : this.box.scrollWidth));
-	this.borderWidth = parseInt(((borderWidth != "" && borderWidth.indexOf("px") !== -1) ? borderWidth.slice(0, borderWidth.indexOf("px")) : 0));
-	var test = new dojo.gfx.color.Color(boxColour);
-	this.boxColour = ((boxColour != "" && boxColour != "transparent") ? ((boxColour.substr(0, 3) == "rgb") ? this.rgb2Hex(boxColour) : boxColour) : "#ffffff");
-	this.borderColour = ((borderColour != "" && borderColour != "transparent" && this.borderWidth > 0) ? ((borderColour.substr(0, 3) == "rgb") ? this.rgb2Hex(borderColour) : borderColour) : this.boxColour);
-	this.borderString = this.borderWidth + "px" + " solid " + this.borderColour;
-	this.backgroundImage = ((backgroundImage != "none") ? backgroundImage : "");
-	if (boxPosition != "absolute") {
-		this.box.style.position = "relative";
-	}
-	this.applyCorners = function () {
-		for (var t = 0; t < 2; t++) {
-			switch (t) {
-			  case 0:
-				if (this.settings.tl.enabled || this.settings.tr.enabled) {
-					var newMainContainer = document.createElement("DIV");
-					with (newMainContainer.style) {
-						width = "100%";
-						fontSize = "1px";
-						overflow = "hidden";
-						position = "absolute";
-						paddingLeft = this.borderWidth + "px";
-						paddingRight = this.borderWidth + "px";
-						var topMaxRadius = Math.max(this.settings.tl ? this.settings.tl.radius : 0, this.settings.tr ? this.settings.tr.radius : 0);
-						height = topMaxRadius + "px";
-						top = 0 - topMaxRadius + "px";
-						left = 0 - this.borderWidth + "px";
-					}
-					this.topContainer = this.box.appendChild(newMainContainer);
-				}
-				break;
-			  case 1:
-				if (this.settings.bl.enabled || this.settings.br.enabled) {
-					var newMainContainer = document.createElement("DIV");
-					with (newMainContainer.style) {
-						width = "100%";
-						fontSize = "1px";
-						overflow = "hidden";
-						position = "absolute";
-						paddingLeft = this.borderWidth + "px";
-						paddingRight = this.borderWidth + "px";
-						var botMaxRadius = Math.max(this.settings.bl ? this.settings.bl.radius : 0, this.settings.br ? this.settings.br.radius : 0);
-						height = botMaxRadius + "px";
-						bottom = 0 - botMaxRadius + "px";
-						left = 0 - this.borderWidth + "px";
-					}
-					this.bottomContainer = this.box.appendChild(newMainContainer);
-				}
-				break;
+
+		if (this.domNode.style.width<=0) {
+			var minWidth = (this.radius*1)+this.domNode.clientWidth;
+			this.domNode.style.width = minWidth+"px";
+		}
+
+		var cornersAvailable = ["TR", "TL", "BR", "BL"];
+		var cornersPassed = this.corners.split(",");
+
+		this.settings = {
+			antiAlias: this.antiAlias
+		};
+
+		var setCorner = function(currentCorner) {
+			var val = currentCorner.toLowerCase();
+			if(dojo.lang.inArray(cornersPassed, currentCorner)) {
+				this.settings[val] = { radius: this.radius, enabled: true };
+			} else {
+				this.settings[val] = { radius: 0 }
 			}
 		}
-		if (this.topContainer) {
-			this.box.style.borderTopWidth = "0px";
-		}
-		if (this.bottomContainer) {
-			this.box.style.borderBottomWidth = "0px";
-		}
-		var corners = ["tr", "tl", "br", "bl"];
-		for (var i in corners) {
-			var cc = corners[i];
-			if (!this.settings[cc]) {
-				if (((cc == "tr" || cc == "tl") && this.topContainer != null) || ((cc == "br" || cc == "bl") && this.bottomContainer != null)) {
-					var newCorner = document.createElement("DIV");
-					newCorner.style.position = "relative";
-					newCorner.style.fontSize = "1px";
-					newCorner.style.overflow = "hidden";
-					if (this.backgroundImage == "") {
-						newCorner.style.backgroundColor = this.boxColour;
-					} else {
-						newCorner.style.backgroundImage = this.backgroundImage;
-					}
-					switch (cc) {
-					  case "tl":
-						with (newCorner.style) {
-							height = topMaxRadius - this.borderWidth + "px";
-							marginRight = this.settings.tr.radius - (this.borderWidth * 2) + "px";
-							borderLeft = this.borderString;
-							borderTop = this.borderString;
-							left = -this.borderWidth + "px";
+		dojo.lang.forEach(cornersAvailable, setCorner, this);
+
+		this.domNode.style.margin = this.boxMargin;
+		this.curvyCorners(this.settings);
+		this.applyCorners();
+	},
+
+	// ------------- curvyCorners OBJECT
+
+	curvyCorners: function(settings){	
+
+		// Setup Globals
+		this.box             = this.domNode;
+		this.topContainer    = null;
+		this.bottomContainer = null;
+		this.masterCorners   = [];
+
+		// Get box formatting details
+		var boxHeight       = dojo.style.getStyle(this.box, "height");
+		if(boxHeight=="") boxHeight="0px";
+		var boxWidth        = dojo.style.getStyle(this.box, "width");
+		var borderWidth     = dojo.style.getStyle(this.box, "borderTopWidth");
+		if(borderWidth=="") borderWidth="0px";
+		//alert(borderWidth);
+
+		var borderColour    = dojo.style.getStyle(this.box, "borderTopColor");
+		// Set to true if we have a border
+		if(borderWidth>0) this.antiAlias=true;
+
+		var boxColour       = dojo.style.getStyle(this.box, "backgroundColor");
+		var backgroundImage = dojo.style.getStyle(this.box, "backgroundImage");
+		var boxPosition     = dojo.style.getStyle(this.box, "position");
+
+		// Set formatting propertes
+		this.boxHeight       = parseInt(((boxHeight != "" && boxHeight != "auto" && boxHeight.indexOf("%") == -1)? boxHeight.substring(0, boxHeight.indexOf("px")) : this.box.scrollHeight));
+		this.boxWidth        = parseInt(((boxWidth != "" && boxWidth != "auto" && boxWidth.indexOf("%") == -1)? boxWidth.substring(0, boxWidth.indexOf("px")) : this.box.scrollWidth));
+		this.borderWidth     = parseInt(((borderWidth != "" && borderWidth.indexOf("px") !== -1)? borderWidth.slice(0, borderWidth.indexOf("px")) : 0));
+
+		// DEBUG ME?
+
+		//dojo.debug(this.rgb2Hex(boxColour));
+		var test  = new dojo.graphics.color.Color(boxColour);
+		//dojo.debug(test.toHex()); 
+
+		this.boxColour       = ((boxColour != "" && boxColour != "transparent")? ((boxColour.substr(0, 3) == "rgb")? this.rgb2Hex(boxColour) : boxColour) : "#ffffff");
+		this.borderColour    = ((borderColour != "" && borderColour != "transparent" && this.borderWidth > 0)? ((borderColour.substr(0, 3) == "rgb")? this.rgb2Hex(borderColour)  : borderColour) : this.boxColour);
+		this.borderString    = this.borderWidth + "px" + " solid " + this.borderColour;
+		this.backgroundImage = ((backgroundImage != "none")? backgroundImage : "");
+
+		// Make box relative if not already absolute
+		if(boxPosition != "absolute") this.box.style.position = "relative";
+
+		//This method creates the corners and
+		//applies them to the div element.
+
+		this.applyCorners = function() {
+			// Create top and bottom containers.
+			// These will be used as a parent for the corners and bars.
+			for(var t = 0; t < 2; t++) {
+			    switch(t) {
+			        // Top
+			        case 0:
+						// Only build top bar if a top corner is to be draw
+						if(this.settings.tl.enabled || this.settings.tr.enabled ) {
+							var newMainContainer = document.createElement("DIV");
+			
+							with(newMainContainer.style){
+								width    = "100%";
+								fontSize = "1px";
+								overflow = "hidden";
+								position = "absolute";
+								//backgroundColor = "#FFFFC4";
+								paddingLeft  = this.borderWidth + "px";
+								paddingRight = this.borderWidth + "px";
+								var topMaxRadius = Math.max(this.settings.tl ? this.settings.tl.radius : 0, this.settings.tr ? this.settings.tr.radius : 0);
+								height = topMaxRadius + "px";
+								top    = 0 - topMaxRadius + "px";
+								left   = 0 - this.borderWidth + "px";
+							}
+							
+							this.topContainer = this.box.appendChild(newMainContainer);
 						}
-						break;
-					  case "tr":
-						with (newCorner.style) {
-							height = topMaxRadius - this.borderWidth + "px";
-							marginLeft = this.settings.tl.radius - (this.borderWidth * 2) + "px";
-							borderRight = this.borderString;
-							borderTop = this.borderString;
-							backgroundPosition = "-" + this.boxWidth + "px 0px";
-							left = this.borderWidth + "px";
+			            break;
+	
+			        // Bottom
+			        case 1:      
+			            // Only build bottom bar if a top corner is to be draw
+			            if(this.settings.bl.enabled || this.settings.br.enabled) {
+							var newMainContainer = document.createElement("DIV");
+							with(newMainContainer.style){
+								width    = "100%";
+								fontSize = "1px";
+								overflow = "hidden";
+								position = "absolute";
+								//backgroundColor = "#FFFFC4";
+								paddingLeft  = this.borderWidth + "px";
+								paddingRight = this.borderWidth + "px";
+								var botMaxRadius = Math.max(this.settings.bl ? this.settings.bl.radius : 0, this.settings.br ? this.settings.br.radius : 0);
+								height  = botMaxRadius + "px";
+								bottom  =  0 - botMaxRadius + "px";
+								left    =  0 - this.borderWidth + "px";
+							}
+						this.bottomContainer = this.box.appendChild(newMainContainer);
+			            }
+		            break;
+			    }
+			}
+	
+			// Turn off current borders
+			if(this.topContainer) this.box.style.borderTopWidth = "0px";
+			if(this.bottomContainer) this.box.style.borderBottomWidth = "0px";
+	
+			// Create array of available corners
+			var corners = ["tr", "tl", "br", "bl"];
+		
+			//Loop for each corner
+	
+			for(var i in corners) {
+			    // Get current corner type from array
+			    var cc = corners[i];
+
+			    // Has the user requested the currentCorner be round?
+			    if(!this.settings[cc]) {
+			        // No
+			        if(((cc == "tr" || cc == "tl") && this.topContainer != null) || ((cc == "br" || cc == "bl") && this.bottomContainer != null)) {
+						// We need to create a filler div to fill the space upto the next horzontal corner.
+						var newCorner = document.createElement("DIV");
+		
+						// Setup corners properties
+						newCorner.style.position = "relative";
+						newCorner.style.fontSize = "1px";
+						newCorner.style.overflow = "hidden";
+		
+						// Add background image?
+						if(this.backgroundImage == "") {
+							newCorner.style.backgroundColor = this.boxColour;
+						} else {
+							newCorner.style.backgroundImage = this.backgroundImage;
 						}
-						break;
-					  case "bl":
-						with (newCorner.style) {
-							height = botMaxRadius - this.borderWidth + "px";
-							marginRight = this.settings.br.radius - (this.borderWidth * 2) + "px";
-							borderLeft = this.borderString;
-							borderBottom = this.borderString;
-							left = -this.borderWidth + "px";
+
+			            switch(cc) {
+							case "tl":
+								with(newCorner.style){
+									height      = topMaxRadius - this.borderWidth + "px";
+									marginRight = this.settings.tr.radius - (this.borderWidth*2) + "px";
+									borderLeft  = this.borderString;
+									borderTop   = this.borderString;
+									left         = -this.borderWidth + "px";
+								}
+							break;
+			
+							case "tr":
+								with(newCorner.style){
+									height      = topMaxRadius - this.borderWidth + "px";
+									marginLeft  = this.settings.tl.radius - (this.borderWidth*2) + "px";
+									borderRight = this.borderString;
+									borderTop   = this.borderString;
+									backgroundPosition  = "-" + this.boxWidth + "px 0px";
+									left         = this.borderWidth + "px";
+								}
+							break;
+	
+							case "bl":
+								with(newCorner.style){
+									height       = botMaxRadius - this.borderWidth + "px";
+									marginRight  = this.settings.br.radius - (this.borderWidth*2) + "px";
+									borderLeft   = this.borderString;
+									borderBottom = this.borderString;
+									left         = -this.borderWidth + "px";
+								}
+							break;
+			
+							case "br":
+								with(newCorner.style){
+									height       = botMaxRadius - this.borderWidth + "px";
+									marginLeft   = this.settings.bl.radius - (this.borderWidth*2) + "px";
+									borderRight  = this.borderString;
+									borderBottom = this.borderString;
+									left         = this.borderWidth + "px"
+								}
+							break;
+			            }
+			        }
+			    } else {
+			        /*
+			        PERFORMANCE NOTE:
+
+			        If more than one corner is requested and a corner has been already
+			        created for the same radius then that corner will be used as a master and cloned.
+			        The pixel bars will then be repositioned to form the new corner type.
+			        All new corners start as a bottom right corner.
+			        */
+			        if(this.masterCorners[this.settings[cc].radius]) {
+			            // Create clone of the master corner
+			            var newCorner = this.masterCorners[this.settings[cc].radius].cloneNode(true);
+			        } else {
+			            // Yes, we need to create a new corner
+			            var newCorner = document.createElement("DIV");
+						with(newCorner.style){
+							height = this.settings[cc].radius + "px";
+							width  = this.settings[cc].radius + "px";
+							position = "absolute";
+							fontSize = "1px";
+							overflow = "hidden";
 						}
-						break;
-					  case "br":
-						with (newCorner.style) {
-							height = botMaxRadius - this.borderWidth + "px";
-							marginLeft = this.settings.bl.radius - (this.borderWidth * 2) + "px";
-							borderRight = this.borderString;
-							borderBottom = this.borderString;
-							left = this.borderWidth + "px";
-						}
-						break;
-					}
-				}
-			} else {
-				if (this.masterCorners[this.settings[cc].radius]) {
-					var newCorner = this.masterCorners[this.settings[cc].radius].cloneNode(true);
-				} else {
-					var newCorner = document.createElement("DIV");
-					with (newCorner.style) {
-						height = this.settings[cc].radius + "px";
-						width = this.settings[cc].radius + "px";
-						position = "absolute";
-						fontSize = "1px";
-						overflow = "hidden";
-					}
-					var borderRadius = parseInt(this.settings[cc].radius - this.borderWidth);
-					for (var intx = 0, j = this.settings[cc].radius; intx < j; intx++) {
-						if ((intx + 1) >= borderRadius) {
-							var y1 = -1;
-						} else {
-							var y1 = (Math.floor(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow((intx + 1), 2))) - 1);
-						}
-						if (borderRadius != j) {
-							if ((intx) >= borderRadius) {
-								var y2 = -1;
+						// THE FOLLOWING BLOCK OF CODE CREATES A ROUNDED CORNER
+						// ---------------------------------------------------- TOP
+			
+						// Get border radius
+						var borderRadius = parseInt(this.settings[cc].radius - this.borderWidth);
+			
+						// Cycle the x-axis
+						for(var intx = 0, j = this.settings[cc].radius; intx < j; intx++) {
+							// Calculate the value of y1 which identifies the pixels inside the border
+							if((intx +1) >= borderRadius) {
+								var y1 = -1;
 							} else {
-								var y2 = Math.ceil(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow(intx, 2)));
+								var y1 = (Math.floor(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow((intx+1), 2))) - 1);
 							}
-							if ((intx + 1) >= j) {
-								var y3 = -1;
+			
+							// Only calculate y2 and y3 if there is a border defined
+							if(borderRadius != j) {
+								if((intx) >= borderRadius) {
+									var y2 = -1;
+								} else {
+									var y2 = Math.ceil(Math.sqrt(Math.pow(borderRadius,2) - Math.pow(intx, 2)));
+								}
+			
+								if((intx+1) >= j) {
+									var y3 = -1;
+								} else {
+									var y3 = (Math.floor(Math.sqrt(Math.pow(j ,2) - Math.pow((intx+1), 2))) - 1);
+								}
+							}
+
+							// Calculate y4
+							if((intx) >= j) {
+								var y4 = -1;
 							} else {
-								var y3 = (Math.floor(Math.sqrt(Math.pow(j, 2) - Math.pow((intx + 1), 2))) - 1);
+								var y4 = Math.ceil(Math.sqrt(Math.pow(j ,2) - Math.pow(intx, 2)));
 							}
-						}
-						if ((intx) >= j) {
-							var y4 = -1;
-						} else {
-							var y4 = Math.ceil(Math.sqrt(Math.pow(j, 2) - Math.pow(intx, 2)));
-						}
-						if (y1 > -1) {
-							this.drawPixel(intx, 0, this.boxColour, 100, (y1 + 1), newCorner, -1, this.settings[cc].radius);
-						}
-						if (borderRadius != j) {
-							if (this.antiAlias) {
-								for (var inty = (y1 + 1); inty < y2; inty++) {
-									if (this.backgroundImage != "") {
-										var borderFract = (this.pixelFraction(intx, inty, borderRadius) * 100);
-										if (borderFract < 30) {
-											this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, 0, this.settings[cc].radius);
+
+							// Draw bar on inside of the border with foreground colour
+							if(y1 > -1) this.drawPixel(intx, 0, this.boxColour, 100, (y1+1), newCorner, -1, this.settings[cc].radius);
+	
+							// Only draw border/foreground antialiased pixels and border if there is a border defined
+							if(borderRadius != j) {
+								// Draw aa pixels?
+								if(this.antiAlias) {
+									// Cycle the y-axis
+									for(var inty = (y1 + 1); inty < y2; inty++) {
+										// For each of the pixels that need anti aliasing between the foreground and border colour draw single pixel divs
+										if(this.backgroundImage != "") {					
+											var borderFract = (this.pixelFraction(intx, inty, borderRadius) * 100);
+					
+											if (borderFract < 30) {
+												this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, 0, this.settings[cc].radius);
+											} else {
+												this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, -1, this.settings[cc].radius);
+											}
 										} else {
-											this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, -1, this.settings[cc].radius);
+											var pixelcolour = dojo.graphics.color.blend(this.boxColour, this.borderColour, this.pixelFraction(intx, inty, borderRadius));
+											this.drawPixel(intx, inty, pixelcolour, 100, 1, newCorner, 0, this.settings[cc].radius);
 										}
-									} else {
-										var pixelcolour = dojo.gfx.color.blend(this.boxColour, this.borderColour, this.pixelFraction(intx, inty, borderRadius));
-										this.drawPixel(intx, inty, pixelcolour, 100, 1, newCorner, 0, this.settings[cc].radius);
 									}
 								}
+
+								// Draw bar for the border
+								if(y3 >= y2) {
+									if (y1 == -1) {
+										y1 = 0;
+									}
+									this.drawPixel(intx, y2, this.borderColour, 100, (y3 - y2 + 1), newCorner, 0, this.settings[cc].radius);
+								}	
+								// Set the colour for the outside curve
+								var outsideColour = this.borderColour;
+							} else {
+								// Set the coour for the outside curve
+								var outsideColour = this.boxColour;
+								var y3 = y1;
 							}
-							if (y3 >= y2) {
-								if (y1 == -1) {
-									y1 = 0;
+			
+							// Draw aa pixels?
+							if(this.antiAlias) {		
+								// Cycle the y-axis and draw the anti aliased pixels on the
+								// outside of the curve
+								for(var inty = (y3 + 1); inty < y4; inty++) {
+									// For each of the pixels that need anti aliasing between 
+									//the foreground/border colour & background draw single pixel divs
+									this.drawPixel(intx, inty, outsideColour, (this.pixelFraction(intx, inty , j) * 100), 1, newCorner, ((this.borderWidth > 0)? 0 : -1), this.settings[cc].radius);
 								}
-								this.drawPixel(intx, y2, this.borderColour, 100, (y3 - y2 + 1), newCorner, 0, this.settings[cc].radius);
 							}
-							var outsideColour = this.borderColour;
-						} else {
-							var outsideColour = this.boxColour;
-							var y3 = y1;
-						}
-						if (this.antiAlias) {
-							for (var inty = (y3 + 1); inty < y4; inty++) {
-								this.drawPixel(intx, inty, outsideColour, (this.pixelFraction(intx, inty, j) * 100), 1, newCorner, ((this.borderWidth > 0) ? 0 : -1), this.settings[cc].radius);
+			            }
+
+			            // END OF CORNER CREATION
+			            // ---------------------------------------------------- END
+
+			            // We now need to store the current corner in the masterConers array
+			            this.masterCorners[this.settings[cc].radius] = newCorner.cloneNode(true);
+			        }
+			
+					//Now we have a new corner we need to reposition all the pixels unless
+					//the current corner is the bottom right.
+			        if(cc != "br") {	
+						// Loop through all children (pixel bars)
+						for(var t = 0, k = newCorner.childNodes.length; t < k; t++) {
+							// Get current pixel bar
+							var pixelBar = newCorner.childNodes[t];
+	
+							// Get current top and left properties
+							var pixelBarTop    = parseInt(pixelBar.style.top.substring(0, pixelBar.style.top.indexOf("px")));
+							var pixelBarLeft   = parseInt(pixelBar.style.left.substring(0, pixelBar.style.left.indexOf("px")));
+							var pixelBarHeight = parseInt(pixelBar.style.height.substring(0, pixelBar.style.height.indexOf("px")));
+							
+							// Reposition pixels
+							if(cc == "tl" || cc == "bl") {
+								pixelBar.style.left = this.settings[cc].radius -pixelBarLeft -1 + "px"; // Left
 							}
+							if(cc == "tr" || cc == "tl") {
+								pixelBar.style.top =  this.settings[cc].radius -pixelBarHeight -pixelBarTop + "px"; // Top
+							}
+							var value;
+					
+							switch(cc) {
+								case "tr":
+									value = (-1 *( Math.abs((this.boxWidth - this.settings[cc].radius + this.borderWidth) + pixelBarLeft) - (Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - this.borderWidth))));
+									pixelBar.style.backgroundPosition  = value + "px";
+									
+								break;
+				
+								case "tl":
+									value = (-1 *( Math.abs((this.settings[cc].radius -pixelBarLeft -1)  - this.borderWidth) - (Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - this.borderWidth))));
+									pixelBar.style.backgroundPosition  = value + "px";
+
+								break;
+				
+								case "bl":
+									value = (-1 *( Math.abs((this.settings[cc].radius -pixelBarLeft -1) - this.borderWidth) - (Math.abs((this.boxHeight + this.settings[cc].radius + pixelBarTop) -this.borderWidth))));
+									pixelBar.style.backgroundPosition  = value + "px";
+
+								break;
+							}
 						}
 					}
-					this.masterCorners[this.settings[cc].radius] = newCorner.cloneNode(true);
 				}
-				if (cc != "br") {
-					for (var t = 0, k = newCorner.childNodes.length; t < k; t++) {
-						var pixelBar = newCorner.childNodes[t];
-						var pixelBarTop = parseInt(pixelBar.style.top.substring(0, pixelBar.style.top.indexOf("px")));
-						var pixelBarLeft = parseInt(pixelBar.style.left.substring(0, pixelBar.style.left.indexOf("px")));
-						var pixelBarHeight = parseInt(pixelBar.style.height.substring(0, pixelBar.style.height.indexOf("px")));
-						if (cc == "tl" || cc == "bl") {
-							pixelBar.style.left = this.settings[cc].radius - pixelBarLeft - 1 + "px";
-						}
-						if (cc == "tr" || cc == "tl") {
-							pixelBar.style.top = this.settings[cc].radius - pixelBarHeight - pixelBarTop + "px";
-						}
-						var value;
-						switch (cc) {
-						  case "tr":
-							value = (-1 * (Math.abs((this.boxWidth - this.settings[cc].radius + this.borderWidth) + pixelBarLeft) - (Math.abs(this.settings[cc].radius - pixelBarHeight - pixelBarTop - this.borderWidth))));
-							pixelBar.style.backgroundPosition = value + "px";
-							break;
-						  case "tl":
-							value = (-1 * (Math.abs((this.settings[cc].radius - pixelBarLeft - 1) - this.borderWidth) - (Math.abs(this.settings[cc].radius - pixelBarHeight - pixelBarTop - this.borderWidth))));
-							pixelBar.style.backgroundPosition = value + "px";
-							break;
-						  case "bl":
-							value = (-1 * (Math.abs((this.settings[cc].radius - pixelBarLeft - 1) - this.borderWidth) - (Math.abs((this.boxHeight + this.settings[cc].radius + pixelBarTop) - this.borderWidth))));
-							pixelBar.style.backgroundPosition = value + "px";
-							break;
-						}
+				if(newCorner) {
+					// Position the container
+					switch(cc) {
+						case "tl":
+							if(newCorner.style.position == "absolute") newCorner.style.top  = "0px";
+							if(newCorner.style.position == "absolute") newCorner.style.left = "0px";
+							if(this.topContainer) this.topContainer.appendChild(newCorner);
+						break;
+
+						case "tr":
+							if(newCorner.style.position == "absolute") newCorner.style.top  = "0px";
+							if(newCorner.style.position == "absolute") newCorner.style.right = "0px";
+							if(this.topContainer) this.topContainer.appendChild(newCorner);
+						break;
+		
+						case "bl":
+							if(newCorner.style.position == "absolute") newCorner.style.bottom  = "0px";
+							if(newCorner.style.position == "absolute") newCorner.style.left = "0px";
+							if(this.bottomContainer) this.bottomContainer.appendChild(newCorner);
+						break;
+						
+						case "br":
+							if(newCorner.style.position == "absolute") newCorner.style.bottom = "0px";
+							if(newCorner.style.position == "absolute") newCorner.style.right = "0px";
+							if(this.bottomContainer) this.bottomContainer.appendChild(newCorner);
+						break;
 					}
 				}
 			}
-			if (newCorner) {
-				switch (cc) {
-				  case "tl":
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.top = "0px";
+			//The last thing to do is draw the rest of the filler DIVs.
+			//We only need to create a filler DIVs when two corners have
+			//diffrent radiuses in either the top or bottom container.
+	
+			// Find out which corner has the biiger radius and get the difference amount
+			var radiusDiff = [];
+			radiusDiff["t"] = this.settings.tl.enabled && this.settings.tr.enabled ? Math.abs(this.settings.tl.radius - this.settings.tr.radius) : 0;
+			radiusDiff["b"] = this.settings.bl.enabled && this.settings.br.enabled ? Math.abs(this.settings.bl.radius - this.settings.br.radius) : 0;
+
+			for(var z in radiusDiff) {
+				if(radiusDiff[z]) {
+					// Get the type of corner that is the smaller one
+					var smallerCornerType = ((this.settings[z + "l"].radius < this.settings[z + "r"].radius)? z +"l" : z +"r");
+
+					// First we need to create a DIV for the space under the smaller corner
+					var newFiller = document.createElement("DIV");
+					with(newFiller.style) {
+						height = radiusDiff[z] + "px";
+						width  =  this.settings[smallerCornerType].radius+ "px"
+						position = "absolute";
+						fontSize = "1px";
+						overflow = "hidden";
+						backgroundColor = this.boxColour;
 					}
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.left = "0px";
+
+					// Position filler
+					switch(smallerCornerType) {
+						case "tl":
+							with(newFiller.style) {
+								bottom = "0px";
+								left   = "0px";
+								borderLeft = this.borderString;
+							}
+							this.topContainer.appendChild(newFiller);
+						break;
+	
+						case "tr":
+							with(newFiller.style) {
+								bottom = "0px";
+								right  = "0px";
+								borderRight = this.borderString;
+							}
+							this.topContainer.appendChild(newFiller);
+						break;
+
+						case "bl":
+							with(newFiller.style) {
+								top    = "0px";
+								left   = "0px";
+								borderLeft = this.borderString;
+							}
+							this.bottomContainer.appendChild(newFiller);
+						break;
+
+						case "br":
+							with(newFiller.style) {
+								top    = "0px";
+								right  = "0px";
+								borderRight = this.borderString;
+							}
+							this.bottomContainer.appendChild(newFiller);
+						break;
 					}
-					if (this.topContainer) {
-						this.topContainer.appendChild(newCorner);
-					}
-					break;
-				  case "tr":
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.top = "0px";
-					}
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.right = "0px";
-					}
-					if (this.topContainer) {
-						this.topContainer.appendChild(newCorner);
-					}
-					break;
-				  case "bl":
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.bottom = "0px";
-					}
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.left = "0px";
-					}
-					if (this.bottomContainer) {
-						this.bottomContainer.appendChild(newCorner);
-					}
-					break;
-				  case "br":
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.bottom = "0px";
-					}
-					if (newCorner.style.position == "absolute") {
-						newCorner.style.right = "0px";
-					}
-					if (this.bottomContainer) {
-						this.bottomContainer.appendChild(newCorner);
-					}
-					break;
-				}
-			}
-		}
-		var radiusDiff = [];
-		radiusDiff["t"] = this.settings.tl.enabled && this.settings.tr.enabled ? Math.abs(this.settings.tl.radius - this.settings.tr.radius) : 0;
-		radiusDiff["b"] = this.settings.bl.enabled && this.settings.br.enabled ? Math.abs(this.settings.bl.radius - this.settings.br.radius) : 0;
-		for (var z in radiusDiff) {
-			if (radiusDiff[z]) {
-				var smallerCornerType = ((this.settings[z + "l"].radius < this.settings[z + "r"].radius) ? z + "l" : z + "r");
-				var newFiller = document.createElement("DIV");
-				with (newFiller.style) {
-					height = radiusDiff[z] + "px";
-					width = this.settings[smallerCornerType].radius + "px";
-					position = "absolute";
+			    }
+
+				// Create the bar to fill the gap between each corner horizontally
+				var newFillerBar = document.createElement("DIV");
+				with(newFillerBar.style) {
+					position = "relative";
 					fontSize = "1px";
 					overflow = "hidden";
 					backgroundColor = this.boxColour;
 				}
-				switch (smallerCornerType) {
-				  case "tl":
-					with (newFiller.style) {
-						bottom = "0px";
-						left = "0px";
-						borderLeft = this.borderString;
-					}
-					this.topContainer.appendChild(newFiller);
+
+				switch(z) {
+					case "t":
+						// Top Bar
+						if(this.topContainer) {
+							with(newFillerBar.style) {
+								height      = topMaxRadius - this.borderWidth + "px";
+								marginLeft  = this.settings.tl.radius - this.borderWidth + "px";
+								marginRight = this.settings.tr.radius - this.borderWidth + "px";
+								borderTop   = this.borderString;
+							}
+						this.topContainer.appendChild(newFillerBar);
+						}
 					break;
-				  case "tr":
-					with (newFiller.style) {
-						bottom = "0px";
-						right = "0px";
-						borderRight = this.borderString;
+
+					case "b":
+						if(this.bottomContainer) {
+						// Bottom Bar
+						with(newFillerBar.style) {
+							height       = botMaxRadius - this.borderWidth + "px";
+							marginLeft   = this.settings.bl.radius - this.borderWidth + "px";
+							marginRight  = this.settings.br.radius - this.borderWidth + "px";
+							borderBottom = this.borderString;
+						}
+						this.bottomContainer.appendChild(newFillerBar);
 					}
-					this.topContainer.appendChild(newFiller);
 					break;
-				  case "bl":
-					with (newFiller.style) {
-						top = "0px";
-						left = "0px";
-						borderLeft = this.borderString;
-					}
-					this.bottomContainer.appendChild(newFiller);
-					break;
-				  case "br":
-					with (newFiller.style) {
-						top = "0px";
-						right = "0px";
-						borderRight = this.borderString;
-					}
-					this.bottomContainer.appendChild(newFiller);
-					break;
 				}
 			}
-			var newFillerBar = document.createElement("DIV");
-			with (newFillerBar.style) {
-				position = "relative";
-				fontSize = "1px";
-				overflow = "hidden";
-				backgroundColor = this.boxColour;
+		}
+
+		// This function draws the pixles
+		this.drawPixel = function(intx, inty, colour, transAmount, height, newCorner, image, cornerRadius) {
+			// Create pixel
+			var pixel = document.createElement("DIV");
+
+			
+			// Section doesn't like with (pixel.style) { DEBUG?
+			pixel.style.height   = height + "px";
+			pixel.style.width    = "1px";
+			pixel.style.position = "absolute";
+			pixel.style.fontSize = "1px";
+			pixel.style.overflow = "hidden";
+			
+			// Dont apply background image to border pixels
+			if(image == -1 && this.backgroundImage != "") {
+				pixel.style.backgroundImage = this.backgroundImage;
+				pixel.style.backgroundPosition  = "-" + (this.boxWidth - (cornerRadius - intx) + this.borderWidth) + "px -" + ((this.boxHeight + cornerRadius + inty) -this.borderWidth) + "px";
+			} else {
+				pixel.style.backgroundColor = colour;
 			}
-			switch (z) {
-			  case "t":
-				if (this.topContainer) {
-					with (newFillerBar.style) {
-						height = topMaxRadius - this.borderWidth + "px";
-						marginLeft = this.settings.tl.radius - this.borderWidth + "px";
-						marginRight = this.settings.tr.radius - this.borderWidth + "px";
-						borderTop = this.borderString;
-					}
-					this.topContainer.appendChild(newFillerBar);
-				}
-				break;
-			  case "b":
-				if (this.bottomContainer) {
-					with (newFillerBar.style) {
-						height = botMaxRadius - this.borderWidth + "px";
-						marginLeft = this.settings.bl.radius - this.borderWidth + "px";
-						marginRight = this.settings.br.radius - this.borderWidth + "px";
-						borderBottom = this.borderString;
-					}
-					this.bottomContainer.appendChild(newFillerBar);
-				}
-				break;
+			
+			// Set opacity if the transparency is anything other than 100
+			if (transAmount != 100) {
+				dojo.style.setOpacity(pixel, transAmount);
 			}
+			// Set the pixels position
+			pixel.style.top = inty + "px";
+			pixel.style.left = intx + "px";
+		
+			newCorner.appendChild(pixel);
 		}
-	};
-	this.drawPixel = function (intx, inty, colour, transAmount, height, newCorner, image, cornerRadius) {
-		var pixel = document.createElement("DIV");
-		pixel.style.height = height + "px";
-		pixel.style.width = "1px";
-		pixel.style.position = "absolute";
-		pixel.style.fontSize = "1px";
-		pixel.style.overflow = "hidden";
-		if (image == -1 && this.backgroundImage != "") {
-			pixel.style.backgroundImage = this.backgroundImage;
-			pixel.style.backgroundPosition = "-" + (this.boxWidth - (cornerRadius - intx) + this.borderWidth) + "px -" + ((this.boxHeight + cornerRadius + inty) - this.borderWidth) + "px";
-		} else {
-			pixel.style.backgroundColor = colour;
+	},
+
+	//For a pixel cut by the line determines the fraction of the pixel on the 'inside' of the
+	//line.  Returns a number between 0 and 1
+	pixelFraction: function(x, y, r) {
+		var pixelfraction = 0;
+		
+		//determine the co-ordinates of the two points on the perimeter of the pixel that the
+		//circle crosses
+		
+		var xvalues = [];
+		var yvalues = [];
+		var point = 0;
+		var whatsides = "";
+
+		// x + 0 = Left
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(x,2)));
+
+		if ((intersect >= y) && (intersect < (y+1))) {
+			whatsides = "Left";
+			xvalues[point] = 0;
+			yvalues[point] = intersect - y;
+			point =  point + 1;
 		}
-		if (transAmount != 100) {
-			dojo.html.setOpacity(pixel, transAmount);
+
+		// y + 1 = Top
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(y+1,2)));
+		
+		if ((intersect >= x) && (intersect < (x+1))) {
+			whatsides = whatsides + "Top";
+			xvalues[point] = intersect - x;
+			yvalues[point] = 1;
+			point = point + 1;
 		}
-		pixel.style.top = inty + "px";
-		pixel.style.left = intx + "px";
-		newCorner.appendChild(pixel);
-	};
-}, pixelFraction:function (x, y, r) {
-	var pixelfraction = 0;
-	var xvalues = [];
-	var yvalues = [];
-	var point = 0;
-	var whatsides = "";
-	var intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(x, 2)));
-	if ((intersect >= y) && (intersect < (y + 1))) {
-		whatsides = "Left";
-		xvalues[point] = 0;
-		yvalues[point] = intersect - y;
-		point = point + 1;
-	}
-	var intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(y + 1, 2)));
-	if ((intersect >= x) && (intersect < (x + 1))) {
-		whatsides = whatsides + "Top";
-		xvalues[point] = intersect - x;
-		yvalues[point] = 1;
-		point = point + 1;
-	}
-	var intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(x + 1, 2)));
-	if ((intersect >= y) && (intersect < (y + 1))) {
-		whatsides = whatsides + "Right";
-		xvalues[point] = 1;
-		yvalues[point] = intersect - y;
-		point = point + 1;
-	}
-	var intersect = Math.sqrt((Math.pow(r, 2) - Math.pow(y, 2)));
-	if ((intersect >= x) && (intersect < (x + 1))) {
-		whatsides = whatsides + "Bottom";
-		xvalues[point] = intersect - x;
-		yvalues[point] = 0;
-	}
-	switch (whatsides) {
-	  case "LeftRight":
-		pixelfraction = Math.min(yvalues[0], yvalues[1]) + ((Math.max(yvalues[0], yvalues[1]) - Math.min(yvalues[0], yvalues[1])) / 2);
-		break;
-	  case "TopRight":
-		pixelfraction = 1 - (((1 - xvalues[0]) * (1 - yvalues[1])) / 2);
-		break;
-	  case "TopBottom":
-		pixelfraction = Math.min(xvalues[0], xvalues[1]) + ((Math.max(xvalues[0], xvalues[1]) - Math.min(xvalues[0], xvalues[1])) / 2);
-		break;
-	  case "LeftBottom":
-		pixelfraction = (yvalues[0] * xvalues[1]) / 2;
-		break;
-	  default:
-		pixelfraction = 1;
-	}
-	return pixelfraction;
-}, rgb2Hex:function (rgbColour) {
-	try {
-		var rgbArray = this.rgb2Array(rgbColour);
-		var red = parseInt(rgbArray[0]);
-		var green = parseInt(rgbArray[1]);
-		var blue = parseInt(rgbArray[2]);
-		var hexColour = "#" + this.intToHex(red) + this.intToHex(green) + this.intToHex(blue);
-	}
-	catch (e) {
-		alert("There was an error converting the RGB value to Hexadecimal in function rgb2Hex");
-	}
-	return hexColour;
-}, intToHex:function (strNum) {
-	var base = strNum / 16;
-	var rem = strNum % 16;
-	var base = base - (rem / 16);
-	var baseS = this.makeHex(base);
-	var remS = this.makeHex(rem);
-	return baseS + "" + remS;
-}, makeHex:function (x) {
-	if ((x >= 0) && (x <= 9)) {
-		return x;
-	} else {
-		switch (x) {
-		  case 10:
-			return "A";
-		  case 11:
-			return "B";
-		  case 12:
-			return "C";
-		  case 13:
-			return "D";
-		  case 14:
-			return "E";
-		  case 15:
-			return "F";
+		// x + 1 = Right
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(x+1,2)));
+
+		if ((intersect >= y) && (intersect < (y+1))) {
+			whatsides = whatsides + "Right";
+			xvalues[point] = 1;
+			yvalues[point] = intersect - y;
+			point =  point + 1;
 		}
+		// y + 0 = Bottom
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(y,2)));
+
+		if ((intersect >= x) && (intersect < (x+1))) {
+			whatsides = whatsides + "Bottom";
+			xvalues[point] = intersect - x;
+			yvalues[point] = 0;
+		}
+
+	    //depending on which sides of the perimeter of the pixel the circle crosses calculate the
+	    //fraction of the pixel inside the circle
+
+		switch (whatsides) {
+			case "LeftRight":
+				pixelfraction = Math.min(yvalues[0],yvalues[1]) + ((Math.max(yvalues[0],yvalues[1]) - Math.min(yvalues[0],yvalues[1]))/2);
+			break;
+			
+			case "TopRight":
+				pixelfraction = 1-(((1-xvalues[0])*(1-yvalues[1]))/2);
+			break;
+			
+			case "TopBottom":
+				pixelfraction = Math.min(xvalues[0],xvalues[1]) + ((Math.max(xvalues[0],xvalues[1]) - Math.min(xvalues[0],xvalues[1]))/2);
+			break;
+			
+			case "LeftBottom":
+				pixelfraction = (yvalues[0]*xvalues[1])/2;
+			break;
+			
+			default:
+				pixelfraction = 1;
+	    }
+	    return pixelfraction;
+	},
+
+	// This function converts CSS rgb(x, x, x) to hexadecimal
+	rgb2Hex: function (rgbColour) {
+		try{	
+			// Get array of RGB values
+			var rgbArray = this.rgb2Array(rgbColour);
+			
+			// Get RGB values
+			var red   = parseInt(rgbArray[0]);
+			var green = parseInt(rgbArray[1]);
+			var blue  = parseInt(rgbArray[2]);
+			
+			// Build hex colour code
+			var hexColour = "#" + this.intToHex(red) + this.intToHex(green) + this.intToHex(blue);
+		}
+		catch(e){ alert("There was an error converting the RGB value to Hexadecimal in function rgb2Hex");
+		}
+		return hexColour;
+	},
+
+	//Converts a number to hexadecimal format
+
+	intToHex: function (strNum) {
+		var base = strNum / 16;
+		var rem = strNum % 16;
+		var base = base - (rem / 16);
+		var baseS = this.makeHex(base);
+		var remS = this.makeHex(rem);
+		return baseS + '' + remS;
+	},
+	//gets the hex bits of a number
+
+	makeHex: function(x) {
+		if((x >= 0) && (x <= 9)) {
+			return x;
+		} else {
+			switch(x) {
+				case 10: return "A";
+				case 11: return "B";
+				case 12: return "C";
+				case 13: return "D";
+				case 14: return "E";
+				case 15: return "F";
+			}
+		}
+	},
+
+	// Returns an array of rbg values
+	rgb2Array: function(rgbColour) {
+		// Remove rgb()
+		var rgbValues = rgbColour.substring(4, rgbColour.indexOf(")"));
+	
+		// Split RGB into array
+		var rgbArray = rgbValues.split(", ");
+		return rgbArray;
 	}
-}, rgb2Array:function (rgbColour) {
-	var rgbValues = rgbColour.substring(4, rgbColour.indexOf(")"));
-	var rgbArray = rgbValues.split(", ");
-	return rgbArray;
-}});
-
+}); // end function

Modified: tags/parley-0.53/root/static/magic/src/widget/Select.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Select.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Select.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,32 +8,69 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.Select");
-dojo.require("dojo.widget.ComboBox");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.html.stabile");
-dojo.widget.defineWidget("dojo.widget.Select", dojo.widget.ComboBox, {forceValidOption:true, setValue:function (value) {
-	this.comboBoxValue.value = value;
-	dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
-	this.onValueChanged(value);
-}, setLabel:function (value) {
-	this.comboBoxSelectionValue.value = value;
-	if (this.textInputNode.value != value) {
-		this.textInputNode.value = value;
-	}
-}, getLabel:function () {
-	return this.comboBoxSelectionValue.value;
-}, getState:function () {
-	return {value:this.getValue(), label:this.getLabel()};
-}, onKeyUp:function (evt) {
-	this.setLabel(this.textInputNode.value);
-}, setState:function (state) {
-	this.setValue(state.value);
-	this.setLabel(state.label);
-}, setAllValues:function (value1, value2) {
-	this.setLabel(value1);
-	this.setValue(value2);
-}});
-
+dojo.provide("dojo.widget.Select");
+dojo.provide("dojo.widget.html.Select");
+
+dojo.require("dojo.widget.html.ComboBox");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.html.stabile");
+
+/*
+ * The Select widget is an enhanced version of HTML's <select> tag.
+ *
+ * Similar features:
+ *   - There is a drop down list of possible values.
+ *   - You can only enter a value from the drop down list.  (You can't enter an arbitrary value.)
+ *   - The value submitted with the form is the hidden value (ex: CA),
+       not the displayed value a.k.a. label (ex: California)
+ *
+ * Enhancements over plain HTML version:
+ *   - If you type in some text then it will filter down the list of possible values in the drop down list.
+ *   - List can be specified either as a static list or via a javascript function (that can get the list from a server)
+ */
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Select",
+	dojo.widget.html.ComboBox,
+	{
+		widgetType: "Select",
+		forceValidOption: true,
+
+		setValue: function(value) {
+			this.comboBoxValue.value = value;
+			dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
+		},
+
+		setLabel: function(value){
+			// FIXME, not sure what to do here!
+			this.comboBoxSelectionValue.value = value;
+			if (this.textInputNode.value != value) { // prevent mucking up of selection
+				this.textInputNode.value = value;
+			}
+		},	  
+
+		getLabel: function(){
+			return this.comboBoxSelectionValue.value;
+		},
+
+		getState: function() {
+			return {
+				value: this.getValue(),
+				label: this.getLabel()
+			};
+		},
+
+		onKeyUp: function(evt){
+			this.setLabel(this.textInputNode.value);
+		},
+
+		setState: function(state) {
+			this.setValue(state.value);
+			this.setLabel(state.label);
+		},
+
+		setAllValues: function(value1, value2){
+			this.setValue(value2);
+			this.setLabel(value1);
+		}
+	});

Modified: tags/parley-0.53/root/static/magic/src/widget/Show.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Show.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Show.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,204 +8,38 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Show");
+
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.uri.Uri");
-dojo.require("dojo.event.*");
-dojo.require("dojo.lfx.*");
-dojo.require("dojo.math.curves");
 dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.func");
-dojo.widget.defineWidget("dojo.widget.Show", dojo.widget.HtmlWidget, function () {
-	this._slides = [];
-}, {isContainer:true, _slide:-1, body:null, nav:null, hider:null, select:null, option:null, inNav:false, debugPane:null, noClick:false, templateString:"<div class=\"dojoShow\">\n\t<div dojoAttachPoint=\"contentNode\"></div>\n\t<div class=\"dojoShowNav\" dojoAttachPoint=\"nav\">\n\t\t<div class=\"dojoShowHider\" dojoAttachPoint=\"hider\"></div>\n\t\t<span unselectable=\"on\" style=\"cursor: default;\" dojoAttachEvent=\"onClick:previousSlide\">&lt;</span>\n\t\t<select dojoAttachEvent=\"onClick:gotoSlideByEvent\" dojoAttachPoint=\"select\">\n\t\t\t<option dojoAttachPoint=\"option\">Title</option>\n\t\t</select>\n\t\t<span unselectable=\"on\" style=\"cursor: default;\" dojoAttachEvent=\"onClick:nextSlide\">&gt;</span>\n\t</div>\n</div>\n", templateCssString:"@media screen {\n\thtml, body {\n\t\tmargin: 0px;\n\t\tpadding: 0px;\n\t\twidth: 100%;\n\t}\n\th1 {\n\t\tfont-size: 50px;\n\t}\n\tp, li {\n\t\tfont-size: 30px;\n\t}\n\t.dojoShowNav {\n\t\tbackground: #369;\n\t\toverflow: hi!
 dden;\n\t\tposition: absolute;\n\t\theight: 5px;\n\t\tbottom: 0px;\n\t\tleft: 0px;\n\t\twidth: 100%;\n\t\ttext-align: center;\n\t}\n\t.dojoShowNav input {\n\t\tmargin: 0px;\n\t}\n\t.dojoShowHider {\n\t\theight: 5px;\n\t\toverflow: hidden;\n\t\twidth: 100%;\n\t}\n\t.dojoShowPrint {\n\t\tposition: absolute;\n\t\tleft: 5px;\n\t\ttop: 0px;\n\t}\n\t.dojoShow {\n\t\tdisplay: none;\n\t}\n}\n at media print {\n\t.dojoShow {\n\t\tdisplay: none !important;\n\t}\n\t.dojoShowPrint {\n\t\tdisplay: block !important;\n\t}\n\t.dojoShowPrintSlide {\n\t\tborder: 1px solid #aaa;\n\t\tpadding: 10px;\n\t\tmargin-bottom: 15px;\n\t}\n\t.dojoShowPrintSlide, ul {\n\tpage-break-inside: avoid;\n\t}\n\th1 {\n\t\tmargin-top: 0;\n\t\tpage-break-after: avoid;\n\t}\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Show.css"), fillInTemplate:function (args, frag) {
-	if (args.debugPane) {
-		var dp = this.debugPane = dojo.widget.byId(args.debugPane);
-		dp.hide();
-		dojo.event.connect(dp, "closeWindow", dojo.lang.hitch(this, function () {
-			this.debugPane = false;
-		}));
-	}
-	var source = this.getFragNodeRef(frag);
-	this.sourceNode = dojo.body().appendChild(source.cloneNode(true));
-	for (var i = 0, child; child = this.sourceNode.childNodes[i]; i++) {
-		if (child.tagName && child.getAttribute("dojotype").toLowerCase() == "showslide") {
-			child.className = "dojoShowPrintSlide";
-			child.innerHTML = "<h1>" + child.title + "</h1>" + child.innerHTML;
-		}
-	}
-	this.sourceNode.className = "dojoShowPrint";
-	this.sourceNode.style.display = "none";
-	dojo.event.connect(document, "onclick", this, "gotoSlideByEvent");
-	if (dojo.render.html.ie) {
-		dojo.event.connect(document, "onkeydown", this, "gotoSlideByEvent");
-	} else {
-		dojo.event.connect(document, "onkeypress", this, "gotoSlideByEvent");
-	}
-	dojo.event.connect(window, "onresize", this, "resizeWindow");
-	dojo.event.connect(this.nav, "onmousemove", this, "popUpNav");
-}, postCreate:function () {
-	this._slides = [];
-	for (var i = 0, child; child = this.children[i]; i++) {
-		if (child.widgetType == "ShowSlide") {
-			this._slides.push(child);
-			this.option.text = child.title + " (" + (i + 1) + ")";
-			this.option.parentNode.insertBefore(this.option.cloneNode(true), this.option);
-		}
-	}
-	this.option.parentNode.removeChild(this.option);
-	this.domNode.style.display = "block";
-	this.resizeWindow();
-	this.gotoSlide(0, true);
-	dojo.addOnLoad(dojo.lang.hitch(this, function () {
-		var th = window.location.hash;
-		if (th.length) {
-			var parts = ("" + window.location).split(this.widgetId + "_SlideNo_");
-			if (parts.length > 1) {
-				setTimeout(dojo.lang.hitch(this, function () {
-					this.gotoSlide(parseInt(parts[1]), true);
-				}), 300);
+
+dojo.widget.Show = function(){}
+dojo.lang.extend(dojo.widget.Show, {
+	isContainer: true,
+	_slide: -1,
+	_slides: [],
+	gotoSlide: function(/*int*/ slide){
+		this._slide = slide;
+		// summary: Placeholder
+	},
+	nextSlide: function(/*Event?*/ event){
+		if(!this._slides[this._slide].nextAction(event)){
+			if((this._slide + 1) != this._slides.length){
+				this.gotoSlide(this._slide + 1);
+				return true; // boolean
 			}
+			return false; // boolean
 		}
-	}));
-}, gotoSlide:function (slide, preventSetHash) {
-	if (slide == this._slide) {
-		return;
-	}
-	if (!this._slides[slide]) {
-		for (var i = 0, child; child = this._slides[i]; i++) {
-			if (child.title == slide) {
-				slide = i;
-				break;
+	},
+	previousSlide: function(/*Event?*/ event){
+		if(!this._slides[this._slide].previousAction(event)){
+			if((this._slide - 1) != -1){
+				this.gotoSlide(this._slide - 1);
+				return true; // boolean
 			}
+			return false; // boolean
 		}
 	}
-	if (!this._slides[slide]) {
-		return;
-	}
-	if (this.debugPane) {
-		if (this._slides[slide].debug) {
-			this.debugPane.show();
-		} else {
-			this.debugPane.hide();
-		}
-	}
-	if (this._slide != -1) {
-		while (this._slides[this._slide].previousAction()) {
-		}
-	}
-	if (!preventSetHash) {
-		window.location.href = "#" + this.widgetId + "_SlideNo_" + slide;
-	}
-	if (this._slides[this._slide]) {
-		this._slides[this._slide].hide();
-	}
-	this._slide = slide;
-	this.select.selectedIndex = slide;
-	var cn = this.contentNode;
-	while (cn.firstChild) {
-		cn.removeChild(cn.firstChild);
-	}
-	cn.appendChild(this._slides[slide].domNode);
-	this._slides[slide].show();
-}, gotoSlideByEvent:function (event) {
-	var node = event.target;
-	var type = event.type;
-	if (type == "click") {
-		if (node.tagName == "OPTION" && node.parentNode == this.select) {
-			this.gotoSlide(node.index);
-		} else {
-			if (node == this.select) {
-				this.gotoSlide(node.selectedIndex);
-			} else {
-				this.nextSlide(event);
-			}
-		}
-	} else {
-		if (type == "keydown" || type == "keypress") {
-			var key = event.keyCode;
-			var ch = event.charCode;
-			if (key == 63234 || key == 37) {
-				this.previousSlide(event);
-			} else {
-				if (key == 63235 || key == 39 || ch == 32) {
-					this.nextSlide(event);
-				}
-			}
-		}
-	}
-}, nextSlide:function (event) {
-	if (!this.stopEvent(event)) {
-		return false;
-	}
-	if (!this._slides[this._slide].nextAction(event)) {
-		if ((this._slide + 1) != this._slides.length) {
-			this.gotoSlide(this._slide + 1);
-			return true;
-		}
-		return false;
-	}
-}, previousSlide:function (event) {
-	if (!this.stopEvent(event)) {
-		return false;
-	}
-	if (!this._slides[this._slide].previousAction(event)) {
-		if ((this._slide - 1) != -1) {
-			this.gotoSlide(this._slide - 1);
-			return true;
-		}
-		return false;
-	}
-}, stopEvent:function (ev) {
-	if (!ev) {
-		return true;
-	}
-	if (ev.type == "click" && (this._slides[this._slide].noClick || this.noClick)) {
-		return false;
-	}
-	var target = ev.target;
-	while (target != null) {
-		if (target == this.domNode) {
-			target = ev.target;
-			break;
-		}
-		target = target.parentNode;
-	}
-	if (!dojo.dom.isDescendantOf(target, this.nav)) {
-		while (target && target != this.domNode) {
-			if (target.tagName == "A" || target.tagName == "INPUT" || target.tagName == "TEXTAREA" || target.tagName == "SELECT") {
-				return false;
-			}
-			if (typeof target.onclick == "function" || typeof target.onkeypress == "function") {
-				return false;
-			}
-			target = target.parentNode;
-		}
-	}
-	if (window.event) {
-		ev.returnValue = false;
-		ev.cancelBubble = true;
-	} else {
-		ev.preventDefault();
-		ev.stopPropagation();
-	}
-	return true;
-}, popUpNav:function () {
-	if (!this.inNav) {
-		dojo.lfx.propertyAnimation(this.nav, {"height":{start:5, end:30}}, 250).play();
-	}
-	clearTimeout(this.inNav);
-	this.inNav = setTimeout(dojo.lang.hitch(this, "hideNav"), 2000);
-}, hideNav:function () {
-	clearTimeout(this.inNav);
-	this.inNav = false;
-	dojo.lfx.propertyAnimation(this.nav, {"height":{start:30, end:5}}, 250).play();
-}, resizeWindow:function (ev) {
-	dojo.body().style.height = "auto";
-	var h = Math.max(document.documentElement.scrollHeight || dojo.body().scrollHeight, dojo.html.getViewport().height);
-	dojo.body().style.height = h + "px";
-}});
+});
 
+dojo.requireAfterIf("html", "dojo.widget.html.Show");
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/widget/ShowAction.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ShowAction.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ShowAction.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,13 +8,19 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.ShowAction");
 
-
-dojo.provide("dojo.widget.ShowAction");
 dojo.require("dojo.widget.*");
-dojo.widget.defineWidget("dojo.widget.ShowAction", dojo.widget.HtmlWidget, {on:"", action:"fade", duration:350, from:"", to:"", auto:"false", postMixInProperties:function () {
-	if (dojo.render.html.opera) {
-		this.action = this.action.split("/").pop();
-	}
-}});
+dojo.require("dojo.lang.common");
 
+dojo.widget.ShowAction = function(){}
+dojo.lang.extend(dojo.widget.ShowAction, {
+	on: "",
+	action: "",
+	duration: 0,
+	from: "",
+	to: "",
+	auto: "false"
+});
+
+dojo.requireAfterIf("html", "dojo.widget.html.ShowAction");
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/widget/ShowSlide.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ShowSlide.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ShowSlide.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,194 +8,36 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.ShowSlide");
+
 dojo.require("dojo.widget.*");
 dojo.require("dojo.lang.common");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.lfx.html");
-dojo.require("dojo.html.display");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.animation.Animation");
-dojo.require("dojo.gfx.color");
-dojo.widget.defineWidget("dojo.widget.ShowSlide", dojo.widget.HtmlWidget, {title:"", _action:-1, isContainer:true, _components:{}, _actions:[], gotoAction:function (action) {
-	this._action = action;
-}, _nextAction:function (event) {
-	if ((this._action + 1) != this._actions.length) {
-		++this._action;
-		return true;
-	}
-	return false;
-}, _previousAction:function (event) {
-	if ((this._action - 1) != -1) {
-		--this._action;
-		return true;
-	}
-	return false;
-}, htmlTitle:null, debug:false, noClick:false, templateString:"<div class=\"dojoShowSlide\">\n\t<div class=\"dojoShowSlideTitle\">\n\t\t<h1 dojoAttachPoint=\"htmlTitle\">Title</h1>\n\t</div>\n\t<div class=\"dojoShowSlideBody\" dojoAttachPoint=\"containerNode\"></div>\n</div>\n", templateCssString:".dojoShowSlideTitle {\n\theight: 100px;\n\tbackground: #369;\n}\n.dojoShowSlideTitle h1 {\n\tmargin-top: 0;\n\tline-height: 100px;\n\tmargin-left: 30px;\n}\n.dojoShowSlideBody {\n\tmargin: 15px;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/ShowSlide.css"), postCreate:function () {
-	this.htmlTitle.innerHTML = this.title;
-	var actions = this.getChildrenOfType("ShowAction", false);
-	var atypes = {};
-	dojo.lang.forEach(actions, function (act) {
-		atypes[act.on] = true;
-	});
-	this._components = {};
-	var cn = this.containerNode;
-	var nodes = dojo.render.html.ie ? cn.all : cn.getElementsByTagName("*");
-	dojo.lang.forEach(nodes, function (node) {
-		var as = node.getAttribute("as");
-		if (as) {
-			if (!this._components[as]) {
-				this._components[as] = [];
-			}
-			this._components[as].push(node);
-			if (!atypes[as]) {
-				var tmpAction = dojo.widget.createWidget("ShowAction", {on:as});
-				this.addChild(tmpAction);
-				atypes[as] = true;
-			}
+
+dojo.widget.ShowSlide = function(){
+}
+dojo.lang.extend(dojo.widget.ShowSlide, {
+	title: "",
+	_action: -1,
+	isContainer: true,
+	_components: {},
+	_actions: [],
+	gotoAction: function(/*int*/ action){
+		this._action = action;
+	},
+	nextAction: function(/*Event?*/ event){
+		if((this._action + 1) != this._actions.length){
+			++this._action;
+			return true; // boolean
 		}
-	}, this);
-	this._actions = [];
-	actions = this.getChildrenOfType("ShowAction", false);
-	dojo.lang.forEach(actions, function (child) {
-		this._actions.push(child);
-		var components = this._components[child.on];
-		for (var j = 0, component; component = components[j]; j++) {
-			if (child["action"] && ((child.action != "remove") && (child.action != "fadeout") && (child.action != "wipeout"))) {
-				this.hideComponent(component);
-			}
+		return false; // boolean
+	},
+	previousAction: function(/*Event?*/ event){
+		if((this._action - 1) != -1){
+			--this._action;
+			return true; // boolean
 		}
-	}, this);
-}, previousAction:function (event) {
-	if (!this.parent.stopEvent(event)) {
-		return false;
+		return false; // boolean
 	}
-	var action = this._actions[this._action];
-	if (!action) {
-		return false;
-	}
-	var on = action.on;
-	while (action.on == on) {
-		var components = this._components[on];
-		for (var i = 0, component; component = components[i]; i++) {
-			if ((action.action == "remove") || (action.action == "fadeout") || (action.action == "wipeout")) {
-				if (component.style.display == "none") {
-					component.style.display = "";
-					component.style.visibility = "visible";
-					var exits = true;
-				}
-				dojo.html.setOpacity(component, 1);
-			} else {
-				if (action.action) {
-					this.hideComponent(component);
-				}
-			}
-		}
-		--this._action;
-		if (exits) {
-			return true;
-		}
-		if (action.auto == "true") {
-			on = this._actions[this._action].on;
-		}
-		action = this._actions[this._action];
-		if (!action) {
-			return false;
-		}
-	}
-	return true;
-}, hideComponent:function (component) {
-	component.style.visibility = "hidden";
-	component.style.backgroundColor = "transparent";
-	var parent = component.parentNode;
-	if ((parent) && (parent.tagName.toLowerCase() == "li")) {
-		parent.oldType = parent.style.listStyleType;
-		parent.style.listStyleType = "none";
-	}
-}, nextAction:function (event) {
-	if (!this.parent.stopEvent(event)) {
-		return false;
-	}
-	if (!this._nextAction(this)) {
-		return false;
-	}
-	var action = this._actions[this._action];
-	if (!action) {
-		return false;
-	}
-	var tmpAction = action["action"];
-	var components = this._components[action.on];
-	for (var i = 0, component; component = components[i]; i++) {
-		if (tmpAction) {
-			var duration = action.duration || 1000;
-			if ((tmpAction == "fade") || (tmpAction == "fadeIn")) {
-				dojo.html.setOpacity(component, 0);
-				dojo.lfx.html.fadeShow(component, duration).play(true);
-			} else {
-				if (tmpAction == "fadeout") {
-					dojo.lfx.html.fadeHide(component, duration).play(true);
-				} else {
-					if (tmpAction == "fly") {
-						var width = dojo.html.getMarginBox(component).width;
-						var position = dojo.html.getAbsolutePosition(component);
-						component.style.position = "relative";
-						component.style.left = -(width + position.x) + "px";
-						dojo.lfx.html.slideBy(component, {top:0, left:(width + position.x)}, duration, -1, this.callWith).play(true);
-					} else {
-						if ((tmpAction == "wipe") || (tmpAction == "wipein")) {
-							dojo.lfx.html.wipeIn(component, duration).play();
-						} else {
-							if (tmpAction == "wipeout") {
-								dojo.lfx.html.wipeOut(component, duration).play();
-							} else {
-								if (tmpAction == "color") {
-									var from = new dojo.gfx.color.Color(action.from).toRgb();
-									var to = new dojo.gfx.color.Color(action.to).toRgb();
-									var anim = new dojo.animation.Animation(new dojo.math.curves.Line(from, to), duration, 0);
-									var node = component;
-									dojo.event.connect(anim, "onAnimate", function (e) {
-										node.style.color = "rgb(" + e.coordsAsInts().join(",") + ")";
-									});
-									anim.play(true);
-								} else {
-									if (tmpAction == "bgcolor") {
-										dojo.lfx.html.unhighlight(component, action.to, duration).play();
-									} else {
-										if (tmpAction == "remove") {
-											component.style.display = "none";
-										}
-									}
-								}
-							}
-						}
-					}
-				}
-			}
-			if (tmpAction == "hide") {
-				component.style.visibility = "hidden";
-			} else {
-				component.style.visibility = "visible";
-			}
-		}
-	}
-	action = this._actions[this._action + 1];
-	if (action && action.auto == "true") {
-		this.nextAction();
-	}
-	return true;
-}, callWith:function (node) {
-	if (!node) {
-		return;
-	}
-	if (dojo.lang.isArray(node)) {
-		dojo.lang.forEach(node, arguments.callee);
-		return;
-	}
-	var parent = node.parentNode;
-	if ((parent) && (parent.tagName.toLowerCase() == "li")) {
-		parent.style.listStyleType = parent.oldType;
-	}
-}});
+});
 
+dojo.requireAfterIf("html", "dojo.widget.html.ShowSlide");
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/SimpleDropdownButtons.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SimpleDropdownButtons.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SimpleDropdownButtons.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,158 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+/* TODO:
+ * - make the dropdowns "smart" so they can't get cutoff on bottom of page, sides of page, etc.
+ * - unify menus with the MenuItem and Menu classes so we can add stuff to all menus at once
+ * - allow buttons to be enabled/disabled at runtime
+ *     - this probably means creating all menus upfront and then triggering a disable action
+ *       for disabled buttons in the constructor loop. we'll need a disable and enable action anyway
+ * - should each button with menu be a widget object of it's own?
+ */
+dojo.provide("dojo.widget.SimpleDropdownButtons");
+dojo.provide("dojo.widget.HtmlSimpleDropdownButtons");
+
+dojo.deprecated("dojo.widget.SimpleDropdownButtons",  "use dojo.widget.DropDownButton", "0.4");
+
+dojo.require("dojo.event.*");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.uri.Uri");
+dojo.require("dojo.dom");
+dojo.require("dojo.style");
+dojo.require("dojo.html");
+
+dojo.widget.tags.addParseTreeHandler("dojo:simpledropdownbuttons");
+
+dojo.widget.HtmlSimpleDropdownButtons = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+	this.widgetType = "SimpleDropdownButtons";
+	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlSimpleDropdownButtons.css");
+
+	this.menuTriggerClass = "dojoSimpleDropdownButtons";
+	this.menuClass = "dojoSimpleDropdownButtonsMenu";
+
+	// overwrite buildRendering so we don't clobber our list
+	this.buildRendering = function(args, frag) {
+		if(this.templateCssPath) {
+			dojo.style.insertCssFile(this.templateCssPath, null, true);
+		}
+		this.domNode = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
+
+		var menu = this.domNode;
+		if( !dojo.html.hasClass(menu, this.menuTriggerClass) ) {
+			dojo.html.addClass(menu, this.menuTriggerClass);
+		}
+		var li = dojo.dom.getFirstChildElement(menu);
+		var menuIDs = [];
+		var arrowIDs = [];
+
+		while(li) {
+			if(li.getElementsByTagName("ul").length > 0) {
+				var a = dojo.dom.getFirstChildElement(li);
+				var arrow = document.createElement("a");
+				arrow.href = "javascript:;";
+				arrow.innerHTML = "&nbsp;";
+				dojo.html.setClass(arrow, "downArrow");
+				if(!arrow.id) {
+					arrow.id = dojo.dom.getUniqueId();
+				}
+				arrowIDs.push(arrow.id);
+				var submenu = dojo.dom.getNextSiblingElement(a);
+				if(!submenu.id) {
+					submenu.id = dojo.dom.getUniqueId();
+				}
+				menuIDs.push(submenu.id);
+
+				if( dojo.html.hasClass(a, "disabled") ) {
+					dojo.html.addClass(arrow, "disabled");
+					dojo.html.disableSelection(li);
+					arrow.onfocus = function(){ this.blur(); }
+				} else {
+					dojo.html.addClass(submenu, this.menuClass);
+					document.body.appendChild(submenu);
+					dojo.event.connect(arrow, "onmousedown", (function() {
+						var ar = arrow;
+						return function(e) {
+							dojo.html.addClass(ar, "pressed");
+						}
+					})());
+					dojo.event.connect(arrow, "onclick", (function() {
+						var aa = a;
+						var ar = arrow;
+						var sm = submenu;
+						var setWidth = false;
+
+						return function(e) {
+							hideAll(sm, ar);
+							sm.style.left = (dojo.html.getScrollLeft()
+								+ e.clientX - e.layerX + aa.offsetLeft) + "px";
+							sm.style.top = (dojo.html.getScrollTop() + e.clientY
+								- e.layerY + aa.offsetTop + aa.offsetHeight) + "px";
+							sm.style.display = sm.style.display == "block" ? "none" : "block";
+							if(sm.style.display == "none") {
+								dojo.html.removeClass(ar, "pressed");
+								e.target.blur()
+							}
+							if(!setWidth && sm.style.display == "block"
+								&& sm.offsetWidth < aa.offsetWidth + ar.offsetWidth) {
+								sm.style.width = aa.offsetWidth + ar.offsetWidth + "px";
+								setWidth = true;
+							}
+							e.preventDefault();
+						}
+					})());
+				}
+
+				dojo.event.connect(a, "onclick", function(e) {
+					if(e && e.target && e.target.blur) {
+						e.target.blur();
+					}
+				});
+
+				if(a.nextSibling) {
+					li.insertBefore(arrow, a.nextSibling);
+				} else {
+					li.appendChild(arrow);
+				}
+
+			}
+			li = dojo.dom.getNextSiblingElement(li);
+		}
+
+		function hideAll(excludeMenu, excludeArrow) {
+			// hide menus
+			for(var i = 0; i < menuIDs.length; i++) {
+				var m = document.getElementById(menuIDs[i]);
+				if(!excludeMenu || m != excludeMenu) {
+					document.getElementById(menuIDs[i]).style.display = "none";
+				}
+			}
+			// restore arrows to non-pressed state
+			for(var i = 0; i < arrowIDs.length; i++) {
+				var m = document.getElementById(arrowIDs[i]);
+				if(!excludeArrow || m != excludeArrow) {
+					dojo.html.removeClass(m, "pressed");
+				}
+			}
+		}
+
+		dojo.event.connect(document.documentElement, "onmousedown", function(e) {
+			if( dojo.html.hasClass(e.target, "downArrow") ) { return };
+			for(var i = 0; i < menuIDs.length; i++) {
+				if( dojo.dom.isDescendantOf(e.target, document.getElementById(menuIDs[i])) ) {
+					return;
+				}
+			}
+			hideAll();
+		});
+	}
+}
+dojo.inherits(dojo.widget.HtmlSimpleDropdownButtons, dojo.widget.HtmlWidget);

Modified: tags/parley-0.53/root/static/magic/src/widget/SlideShow.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SlideShow.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SlideShow.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,70 +8,125 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.SlideShow");
+dojo.provide("dojo.widget.html.SlideShow");
 
-
-dojo.provide("dojo.widget.SlideShow");
-dojo.require("dojo.event.*");
+dojo.require("dojo.event");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.lfx.*");
-dojo.require("dojo.html.display");
-dojo.widget.defineWidget("dojo.widget.SlideShow", dojo.widget.HtmlWidget, {templateString:"<div style=\"position: relative; padding: 3px;\">\n\t\t<div>\n\t\t\t<input type=\"button\" value=\"pause\" \n\t\t\t\tdojoAttachPoint=\"startStopButton\"\n\t\t\t\tdojoAttachEvent=\"onClick: togglePaused;\">\n\t\t</div>\n\t\t<div style=\"position: relative; width: ${this.width}; height: ${this.height};\"\n\t\t\tdojoAttachPoint=\"imagesContainer\"\n\t\t\tdojoAttachEvent=\"onClick: togglePaused;\">\n\t\t\t<img dojoAttachPoint=\"img1\" class=\"slideShowImg\" \n\t\t\t\tstyle=\"z-index: 1; width: ${this.width}; height: ${this.height};\"  />\n\t\t\t<img dojoAttachPoint=\"img2\" class=\"slideShowImg\" \n\t\t\t\tstyle=\"z-index: 0; width: ${this.width}; height: ${this.height};\" />\n\t\t</div>\t\n</div>\n", templateCssString:".slideShowImg {\n\tposition: absolute;\n\tleft: 0px;\n\ttop: 0px; \n\tborder: 2px solid #4d4d4d;\n\tpadding: 0px;\n\tmargin: 0px;\n}\n\n", templateCssPath:dojo.uri.moduleU!
 ri("dojo.widget", "templates/SlideShow.css"), imgUrls:[], imgUrlBase:"", delay:4000, transitionInterval:2000, imgWidth:800, imgHeight:600, preventCache:false, stopped:false, _urlsIdx:0, _background:"img2", _foreground:"img1", fadeAnim:null, startStopButton:null, img1:null, img2:null, postMixInProperties:function () {
-	this.width = this.imgWidth + "px";
-	this.height = this.imgHeight + "px";
-}, fillInTemplate:function () {
-	if (dojo.render.html.safari && this.imgUrls.length == 2) {
-		this.preventCache = true;
+dojo.require("dojo.style");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.SlideShow",
+	dojo.widget.HtmlWidget,
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlSlideShow.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlSlideShow.css"),
+
+		// over-ride some defaults
+		isContainer: false,
+		widgetType: "SlideShow",
+
+		// useful properties
+		imgUrls: [],		// the images we'll go through
+		imgUrlBase: "",
+		urlsIdx: 0,		// where in the images we are
+		delay: 4000, 		// give it 4 seconds
+		transitionInterval: 2000, // 2 seconds
+		imgWidth: 800,	// img width
+		imgHeight: 600,	// img height
+		background: "img2", // what's in the bg
+		foreground: "img1", // what's in the fg
+		stopped: false,	// should I stay or should I go?
+		fadeAnim: null, // references our animation
+
+		// our DOM nodes:
+		imagesContainer: null,
+		startStopButton: null,
+		controlsContainer: null,
+		img1: null,
+		img2: null,
+
+		fillInTemplate: function(){
+			dojo.style.setOpacity(this.img1, 0.9999);
+			dojo.style.setOpacity(this.img2, 0.9999);
+			with(this.imagesContainer.style){
+				width = this.imgWidth+"px";
+				height = this.imgHeight+"px";
+			}
+			with(this.img1.style){
+				width = this.imgWidth+"px";
+				height = this.imgHeight+"px";
+			}
+			with(this.img2.style){
+				width = this.imgWidth+"px";
+				height = this.imgHeight+"px";
+			}
+			if(this.imgUrls.length>1){
+				this.img2.src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
+				this.endTransition();
+			}else{
+				this.img1.src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
+			}
+		},
+
+		togglePaused: function(){
+			if(this.stopped){
+				this.stopped = false;
+				this.backgroundImageLoaded();
+				this.startStopButton.value= "pause";
+			}else{
+				this.stopped = true;
+				this.startStopButton.value= "play";
+			}
+		},
+
+		backgroundImageLoaded: function(){
+			// start fading out the foreground image
+			if(this.stopped){ return; }
+
+			// actually start the fadeOut effect
+			// NOTE: if we wanted to use other transition types, we'd set them up
+			// 		 here as well
+			if(this.fadeAnim) {
+				this.fadeAnim.stop();
+			}
+			this.fadeAnim = dojo.lfx.fadeOut(this[this.foreground], 
+				this.transitionInterval, null);
+			dojo.event.connect(this.fadeAnim,"onEnd",this,"endTransition");
+			this.fadeAnim.play();
+		},
+
+		endTransition: function(){
+			// move the foreground image to the background 
+			with(this[this.background].style){ zIndex = parseInt(zIndex)+1; }
+			with(this[this.foreground].style){ zIndex = parseInt(zIndex)-1; }
+
+			// fg/bg book-keeping
+			var tmp = this.foreground;
+			this.foreground = this.background;
+			this.background = tmp;
+
+			// keep on truckin
+			this.loadNextImage();
+		},
+
+		loadNextImage: function(){
+			// load a new image in that container, and make sure it informs
+			// us when it finishes loading
+			dojo.event.kwConnect({
+				srcObj: this[this.background],
+				srcFunc: "onload",
+				adviceObj: this,
+				adviceFunc: "backgroundImageLoaded",
+				once: true, // make sure we only ever hear about it once
+				delay: this.delay
+			});
+			dojo.style.setOpacity(this[this.background], 1.0);
+			this[this.background].src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
+			if(this.urlsIdx>(this.imgUrls.length-1)){
+				this.urlsIdx = 0;
+			}
+		}
 	}
-	dojo.html.setOpacity(this.img1, 0.9999);
-	dojo.html.setOpacity(this.img2, 0.9999);
-	if (this.imgUrls.length > 1) {
-		this.img2.src = this.imgUrlBase + this.imgUrls[this._urlsIdx++] + this._getUrlSuffix();
-		this._endTransition();
-	} else {
-		this.img1.src = this.imgUrlBase + this.imgUrls[this._urlsIdx++] + this._getUrlSuffix();
-	}
-}, _getUrlSuffix:function () {
-	if (this.preventCache) {
-		return "?ts=" + (new Date()).getTime();
-	} else {
-		return "";
-	}
-}, togglePaused:function () {
-	if (this.stopped) {
-		this.stopped = false;
-		this._backgroundImageLoaded();
-		this.startStopButton.value = "pause";
-	} else {
-		this.stopped = true;
-		this.startStopButton.value = "play";
-	}
-}, _backgroundImageLoaded:function () {
-	if (this.stopped) {
-		return;
-	}
-	if (this.fadeAnim) {
-		this.fadeAnim.stop();
-	}
-	this.fadeAnim = dojo.lfx.fadeOut(this[this._foreground], this.transitionInterval, null);
-	dojo.event.connect(this.fadeAnim, "onEnd", this, "_endTransition");
-	this.fadeAnim.play();
-}, _endTransition:function () {
-	with (this[this._background].style) {
-		zIndex = parseInt(zIndex) + 1;
-	}
-	with (this[this._foreground].style) {
-		zIndex = parseInt(zIndex) - 1;
-	}
-	var tmp = this._foreground;
-	this._foreground = this._background;
-	this._background = tmp;
-	this._loadNextImage();
-}, _loadNextImage:function () {
-	dojo.event.kwConnect({srcObj:this[this._background], srcFunc:"onload", adviceObj:this, adviceFunc:"_backgroundImageLoaded", once:true, delay:this.delay});
-	dojo.html.setOpacity(this[this._background], 1);
-	this[this._background].src = this.imgUrlBase + this.imgUrls[this._urlsIdx++];
-	if (this._urlsIdx > (this.imgUrls.length - 1)) {
-		this._urlsIdx = 0;
-	}
-}});
-
+);

Deleted: tags/parley-0.53/root/static/magic/src/widget/Slider.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Slider.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Slider.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,475 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.Slider");
-dojo.require("dojo.event.*");
-dojo.require("dojo.dnd.*");
-dojo.require("dojo.dnd.HtmlDragMove");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.html.layout");
-dojo.widget.defineWidget("dojo.widget.Slider", dojo.widget.HtmlWidget, {minimumX:0, minimumY:0, maximumX:10, maximumY:10, snapValuesX:0, snapValuesY:0, _snapToGrid:true, isEnableX:true, isEnableY:true, _valueSizeX:0, _valueSizeY:0, _minX:0, _minY:0, _constraintWidth:0, _constraintHeight:0, _clipLeft:0, _clipRight:0, _clipTop:0, _clipBottom:0, _clipXdelta:0, _clipYdelta:0, initialValueX:0, initialValueY:0, flipX:false, flipY:false, clickSelect:true, activeDrag:false, templateCssString:".sliderMain {\n  border: 0px !important;\n  border-spacing: 0px !important;\n  line-height: 0px !important;\n  padding: 0px !important;\n  display: -moz-inline-table !important;\n  display: inline !important;\n  -moz-user-focus: normal !important;\n}\n\n.sliderComponent {\n  border: 0px;\n  padding: 0px;\n  margin: 0px;\n}\n\n.sliderHandle { \n  top: 0px;\n  left: 0px;\n  z-index: 1000;\n  position: absolute !important;\n}\n\n.sliderOutsetButton { \n  border-style: outset;\n  border-width: 0px!
  1px 1px 0px;\n  border-color: black;\n}\n\n.sliderInsetButton { \n  border-style: inset;\n  border-width: 1px 0px 0px 1px;\n  border-color: black;\n}\n\n.sliderButtonY {\n  margin: 0px;\n  padding: 0px;\n  z-index: 900;\n}\n\n.sliderButtonX {\n  margin: 0px;\n  padding: 0px;\n  z-index: 900;\n}\n\n.sliderBackground { \n  z-index: 0;\n  display: block !important;\n  position: relative !important;\n}\n\n.sliderProgressBackground { \n  z-index: 800;\n  position: absolute !important;\n  clip: rect(0px,0px,0px,0px);\n}\n\n.sliderBackgroundSizeOnly { \n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Slider.css"), templateString:"<table _=\"weird end tag formatting is to prevent whitespace from becoming &nbsp;\" \n\tclass=\"sliderMain\" \n\tdojoAttachPoint=\"focusNode\" \n\tdojoAttachEvent=\"onmousedown:_setFocus; onkey:_handleKeyEvents; onkeyup:_buttonReleased; onmouseup:_buttonReleased; onmousewheel:_mouseWheeled;\"\n\ttabindex=\"0\" cols=3 cellpadding=0 cell!
 spacing=0 style=\"\">\n\t<tr valign=middle align=center>\n\t\t!
 <td clas
s=\"sliderComponent\" colspan=3 dojoAttachPoint=topBorderNode style=\"\"\n\t\t\t><img class=\"sliderOutsetButton sliderButtonY\"\n\t\t\t\tdojoAttachPoint=topButtonNode \n\t\t\t\tdojoAttachEvent=\"onmousedown:_topButtonPressed; onmousemove:_discardEvent; ondblclick:_topButtonDoubleClicked;\"\n\t\t\t\tsrc=\"${this.topButtonSrc}\" \n\t\t\t\tstyle=\"${this.buttonStyleY}\"\n\t\t></td>\n\t</tr>\n\t<tr valign=middle align=center>\n\t\t<td class=\"sliderComponent\" dojoAttachPoint=leftBorderNode style=\"\"\n\t\t\t><img class=\"sliderOutsetButton sliderButtonX\"\n\t\t\t\tdojoAttachPoint=leftButtonNode\n\t\t\t\tdojoAttachEvent=\"onmousedown:_leftButtonPressed; onmousemove:_discardEvent; ondblclick:_leftButtonDoubleClicked;\"\n\t\t\t\tsrc=\"${this.leftButtonSrc}\" \n\t\t\t\tstyle=\"${this.buttonStyleX}\"\n\t\t></td>\n\t\t<td dojoAttachPoint=constrainingContainerNode \n\t\t\tclass=\"sliderComponent sliderBackground\"\n\t\t\tstyle=\"${this.backgroundStyle}\"\n\t\t\t><img src=\"${this.han!
 dleSrc}\" \n\t\t\t\tclass=sliderHandle\n\t\t\t\tdojoAttachPoint=sliderHandleNode\n\t\t\t\tstyle=\"${this.handleStyle}\"\n\t\t\t><img src=\"${this.progressBackgroundSrc}\"\n\t\t\t\tclass=\"sliderBackgroundSizeOnly sliderProgressBackground\"\n\t\t\t\tdojoAttachPoint=progressBackgroundNode\n\t\t\t\tstyle=\"${this.backgroundSize}\"\n\t\t\t><img src=\"${this.backgroundSrc}\" \n\t\t\t\tclass=sliderBackgroundSizeOnly\n\t\t\t\tdojoAttachPoint=sliderBackgroundNode\n\t\t\t\tstyle=\"${this.backgroundSize}\"\n\t\t></td>\n\t\t<td class=\"sliderComponent\" dojoAttachPoint=rightBorderNode style=\"\"\n\t\t\t><img class=\"sliderOutsetButton sliderButtonX\"\n\t\t\t\tdojoAttachPoint=rightButtonNode\n\t\t\t\tdojoAttachEvent=\"onmousedown:_rightButtonPressed; onmousemove:_discardEvent; ondblclick:_rightButtonDoubleClicked;\"\n\t\t\t\tsrc=\"${this.rightButtonSrc}\" \n\t\t\t\tstyle=\"${this.buttonStyleX}\"\n\t\t></td>\n\t</tr>\n\t<tr valign=middle align=center>\n\t\t<td class=\"sliderComponent\" !
 colspan=3 dojoAttachPoint=bottomBorderNode style=\"\"\n\t\t\t>!
 <img cla
ss=\"sliderOutsetButton sliderButtonY\"\n\t\t\t\tdojoAttachPoint=bottomButtonNode \n\t\t\t\tdojoAttachEvent=\"onmousedown:_bottomButtonPressed; onmousemove:_discardEvent; ondblclick:_bottomButtonDoubleClicked;\"\n\t\t\t\tsrc=\"${this.bottomButtonSrc}\" \n\t\t\t\tstyle=\"${this.buttonStyleY}\"\n\t\t></td>\n\t</tr>\n</table>\n", _isDragInProgress:false, bottomButtonSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider_down_arrow.png"), topButtonSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider_up_arrow.png"), leftButtonSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider_left_arrow.png"), rightButtonSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider_right_arrow.png"), backgroundSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/blank.gif"), progressBackgroundSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/blank.gif"), backgroundSize:"width:200px;height:200px;", backgroundStyle:"", buttonStyleX:"", buttonStyleY:"", handle!
 Style:"", handleSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider-button.png"), showButtons:true, _eventCount:0, _typamaticTimer:null, _typamaticFunction:null, defaultTimeout:500, timeoutChangeRate:0.9, _currentTimeout:this.defaultTimeout, _handleKeyEvents:function (evt) {
-	if (!evt.key) {
-		return;
-	}
-	if (!evt.ctrlKey && !evt.altKey) {
-		switch (evt.key) {
-		  case evt.KEY_LEFT_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			this._leftButtonPressed(evt);
-			return;
-		  case evt.KEY_RIGHT_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			this._rightButtonPressed(evt);
-			return;
-		  case evt.KEY_DOWN_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			this._bottomButtonPressed(evt);
-			return;
-		  case evt.KEY_UP_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			this._topButtonPressed(evt);
-			return;
-		}
-	}
-	this._eventCount++;
-}, _pressButton:function (buttonNode) {
-	buttonNode.className = buttonNode.className.replace("Outset", "Inset");
-}, _releaseButton:function (buttonNode) {
-	buttonNode.className = buttonNode.className.replace("Inset", "Outset");
-}, _buttonPressed:function (evt, buttonNode) {
-	this._setFocus();
-	if (typeof evt == "object") {
-		if (this._typamaticTimer != null) {
-			if (this._typamaticNode == buttonNode) {
-				return;
-			}
-			clearTimeout(this._typamaticTimer);
-		}
-		this._buttonReleased(null);
-		this._eventCount++;
-		this._typamaticTimer = null;
-		this._currentTimeout = this.defaultTimeout;
-		dojo.event.browser.stopEvent(evt);
-	} else {
-		if (evt != this._eventCount) {
-			this._buttonReleased(null);
-			return false;
-		}
-	}
-	if (buttonNode == this.leftButtonNode && this.isEnableX) {
-		this._snapX(dojo.html.getPixelValue(this.sliderHandleNode, "left") - this._valueSizeX);
-	} else {
-		if (buttonNode == this.rightButtonNode && this.isEnableX) {
-			this._snapX(dojo.html.getPixelValue(this.sliderHandleNode, "left") + this._valueSizeX);
-		} else {
-			if (buttonNode == this.topButtonNode && this.isEnableY) {
-				this._snapY(dojo.html.getPixelValue(this.sliderHandleNode, "top") - this._valueSizeY);
-			} else {
-				if (buttonNode == this.bottomButtonNode && this.isEnableY) {
-					this._snapY(dojo.html.getPixelValue(this.sliderHandleNode, "top") + this._valueSizeY);
-				} else {
-					return false;
-				}
-			}
-		}
-	}
-	this._pressButton(buttonNode);
-	this.notifyListeners();
-	this._typamaticNode = buttonNode;
-	this._typamaticTimer = dojo.lang.setTimeout(this, "_buttonPressed", this._currentTimeout, this._eventCount, buttonNode);
-	this._currentTimeout = Math.round(this._currentTimeout * this.timeoutChangeRate);
-	return false;
-}, _bottomButtonPressed:function (evt) {
-	return this._buttonPressed(evt, this.bottomButtonNode);
-}, _bottomButtonDoubleClicked:function (evt) {
-	var rc = this._bottomButtonPressed(evt);
-	dojo.lang.setTimeout(this, "_buttonReleased", 50, null);
-	return rc;
-}, _topButtonPressed:function (evt) {
-	return this._buttonPressed(evt, this.topButtonNode);
-}, _topButtonDoubleClicked:function (evt) {
-	var rc = this._topButtonPressed(evt);
-	dojo.lang.setTimeout(this, "_buttonReleased", 50, null);
-	return rc;
-}, _leftButtonPressed:function (evt) {
-	return this._buttonPressed(evt, this.leftButtonNode);
-}, _leftButtonDoubleClicked:function (evt) {
-	var rc = this._leftButtonPressed(evt);
-	dojo.lang.setTimeout(this, "_buttonReleased", 50, null);
-	return rc;
-}, _rightButtonPressed:function (evt) {
-	return this._buttonPressed(evt, this.rightButtonNode);
-}, _rightButtonDoubleClicked:function (evt) {
-	var rc = this._rightButtonPressed(evt);
-	dojo.lang.setTimeout(this, "_buttonReleased", 50, null);
-	return rc;
-}, _buttonReleased:function (evt) {
-	if (typeof evt == "object" && evt != null && typeof evt.keyCode != "undefined" && evt.keyCode != null) {
-		var keyCode = evt.keyCode;
-		switch (keyCode) {
-		  case evt.KEY_LEFT_ARROW:
-		  case evt.KEY_RIGHT_ARROW:
-		  case evt.KEY_DOWN_ARROW:
-		  case evt.KEY_UP_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			break;
-		}
-	}
-	this._releaseButton(this.topButtonNode);
-	this._releaseButton(this.bottomButtonNode);
-	this._releaseButton(this.leftButtonNode);
-	this._releaseButton(this.rightButtonNode);
-	this._eventCount++;
-	if (this._typamaticTimer != null) {
-		clearTimeout(this._typamaticTimer);
-	}
-	this._typamaticTimer = null;
-	this._currentTimeout = this.defaultTimeout;
-}, _mouseWheeled:function (evt) {
-	var scrollAmount = 0;
-	if (typeof evt.wheelDelta == "number") {
-		scrollAmount = evt.wheelDelta;
-	} else {
-		if (typeof evt.detail == "number") {
-			scrollAmount = -evt.detail;
-		}
-	}
-	if (this.isEnableY) {
-		if (scrollAmount > 0) {
-			this._topButtonPressed(evt);
-			this._buttonReleased(evt);
-		} else {
-			if (scrollAmount < 0) {
-				this._bottomButtonPressed(evt);
-				this._buttonReleased(evt);
-			}
-		}
-	} else {
-		if (this.isEnableX) {
-			if (scrollAmount > 0) {
-				this._rightButtonPressed(evt);
-				this._buttonReleased(evt);
-			} else {
-				if (scrollAmount < 0) {
-					this._leftButtonPressed(evt);
-					this._buttonReleased(evt);
-				}
-			}
-		}
-	}
-}, _discardEvent:function (evt) {
-	dojo.event.browser.stopEvent(evt);
-}, _setFocus:function () {
-	if (this.focusNode.focus) {
-		this.focusNode.focus();
-	}
-}, fillInTemplate:function (args, frag) {
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-	var padding = this.domNode.style.padding;
-	if (dojo.lang.isString(padding) && padding != "" && padding != "0px" && padding != "0px 0px 0px 0px") {
-		this.topBorderNode.style.padding = this.bottomBorderNode.style.padding = padding;
-		this.topBorderNode.style.paddingBottom = "0px";
-		this.bottomBorderNode.style.paddingTop = "0px";
-		this.rightBorderNode.style.paddingRight = this.domNode.style.paddingRight;
-		this.leftBorderNode.style.paddingLeft = this.domNode.style.paddingLeft;
-		this.domNode.style.padding = "0px 0px 0px 0px";
-	}
-	var borderWidth = this.domNode.style.borderWidth;
-	if (dojo.lang.isString(borderWidth) && borderWidth != "" && borderWidth != "0px" && borderWidth != "0px 0px 0px 0px") {
-		this.topBorderNode.style.borderStyle = this.rightBorderNode.style.borderStyle = this.bottomBorderNode.style.borderStyle = this.leftBorderNode.style.borderStyle = this.domNode.style.borderStyle;
-		this.topBorderNode.style.borderColor = this.rightBorderNode.style.borderColor = this.bottomBorderNode.style.borderColor = this.leftBorderNode.style.borderColor = this.domNode.style.borderColor;
-		this.topBorderNode.style.borderWidth = this.bottomBorderNode.style.borderWidth = borderWidth;
-		this.topBorderNode.style.borderBottomWidth = "0px";
-		this.bottomBorderNode.style.borderTopWidth = "0px";
-		this.rightBorderNode.style.borderRightWidth = this.domNode.style.borderRightWidth;
-		this.leftBorderNode.style.borderLeftWidth = this.domNode.style.borderLeftWidth;
-		this.domNode.style.borderWidth = "0px 0px 0px 0px";
-	}
-	this._handleMove = new dojo.widget._SliderDragMoveSource(this.sliderHandleNode);
-	this._handleMove.setParent(this);
-	if (this.clickSelect) {
-		dojo.event.connect(this.constrainingContainerNode, "onmousedown", this, "_onClick");
-	}
-	if (this.isEnableX) {
-		this.setValueX(!isNaN(this.initialValueX) ? this.initialValueX : (!isNaN(this.minimumX) ? this.minimumX : 0));
-	}
-	if (!this.isEnableX || !this.showButtons) {
-		this.rightButtonNode.style.width = "1px";
-		this.rightButtonNode.style.visibility = "hidden";
-		this.leftButtonNode.style.width = "1px";
-		this.leftButtonNode.style.visibility = "hidden";
-	}
-	if (this.isEnableY) {
-		this.setValueY(!isNaN(this.initialValueY) ? this.initialValueY : (!isNaN(this.minimumY) ? this.minimumY : 0));
-	}
-	if (!this.isEnableY || !this.showButtons) {
-		this.bottomButtonNode.style.width = "1px";
-		this.bottomButtonNode.style.visibility = "hidden";
-		this.topButtonNode.style.width = "1px";
-		this.topButtonNode.style.visibility = "hidden";
-	}
-	if (this.focusNode.addEventListener) {
-		this.focusNode.addEventListener("DOMMouseScroll", dojo.lang.hitch(this, "_mouseWheeled"), false);
-	}
-}, _snapX:function (x) {
-	if (x < 0) {
-		x = 0;
-	} else {
-		if (x > this._constraintWidth) {
-			x = this._constraintWidth;
-		} else {
-			var selectedValue = Math.round(x / this._valueSizeX);
-			x = Math.round(selectedValue * this._valueSizeX);
-		}
-	}
-	this.sliderHandleNode.style.left = x + "px";
-	if (this.flipX) {
-		this._clipLeft = x + this._clipXdelta;
-	} else {
-		this._clipRight = x + this._clipXdelta;
-	}
-	this.progressBackgroundNode.style.clip = "rect(" + this._clipTop + "px," + this._clipRight + "px," + this._clipBottom + "px," + this._clipLeft + "px)";
-}, _calc_valueSizeX:function () {
-	var constrainingCtrBox = dojo.html.getContentBox(this.constrainingContainerNode);
-	var sliderHandleBox = dojo.html.getContentBox(this.sliderHandleNode);
-	if (isNaN(constrainingCtrBox.width) || isNaN(sliderHandleBox.width) || constrainingCtrBox.width <= 0 || sliderHandleBox.width <= 0) {
-		return false;
-	}
-	this._constraintWidth = constrainingCtrBox.width + dojo.html.getPadding(this.constrainingContainerNode).width - sliderHandleBox.width;
-	if (this.flipX) {
-		this._clipLeft = this._clipRight = constrainingCtrBox.width;
-	} else {
-		this._clipLeft = this._clipRight = 0;
-	}
-	this._clipXdelta = sliderHandleBox.width >> 1;
-	if (!this.isEnableY) {
-		this._clipTop = 0;
-		this._clipBottom = constrainingCtrBox.height;
-	}
-	if (this._constraintWidth <= 0) {
-		return false;
-	}
-	if (this.snapValuesX == 0) {
-		this.snapValuesX = this._constraintWidth + 1;
-	}
-	this._valueSizeX = this._constraintWidth / (this.snapValuesX - 1);
-	return true;
-}, setValueX:function (value) {
-	if (0 == this._valueSizeX) {
-		if (this._calc_valueSizeX() == false) {
-			dojo.lang.setTimeout(this, "setValueX", 100, value);
-			return;
-		}
-	}
-	if (isNaN(value)) {
-		value = 0;
-	}
-	if (value > this.maximumX) {
-		value = this.maximumX;
-	} else {
-		if (value < this.minimumX) {
-			value = this.minimumX;
-		}
-	}
-	var pixelPercent = (value - this.minimumX) / (this.maximumX - this.minimumX);
-	if (this.flipX) {
-		pixelPercent = 1 - pixelPercent;
-	}
-	this._snapX(pixelPercent * this._constraintWidth);
-	this.notifyListeners();
-}, getValueX:function () {
-	var pixelPercent = dojo.html.getPixelValue(this.sliderHandleNode, "left") / this._constraintWidth;
-	if (this.flipX) {
-		pixelPercent = 1 - pixelPercent;
-	}
-	return Math.round(pixelPercent * (this.snapValuesX - 1)) * ((this.maximumX - this.minimumX) / (this.snapValuesX - 1)) + this.minimumX;
-}, _snapY:function (y) {
-	if (y < 0) {
-		y = 0;
-	} else {
-		if (y > this._constraintHeight) {
-			y = this._constraintHeight;
-		} else {
-			var selectedValue = Math.round(y / this._valueSizeY);
-			y = Math.round(selectedValue * this._valueSizeY);
-		}
-	}
-	this.sliderHandleNode.style.top = y + "px";
-	if (this.flipY) {
-		this._clipTop = y + this._clipYdelta;
-	} else {
-		this._clipBottom = y + this._clipYdelta;
-	}
-	this.progressBackgroundNode.style.clip = "rect(" + this._clipTop + "px," + this._clipRight + "px," + this._clipBottom + "px," + this._clipLeft + "px)";
-}, _calc_valueSizeY:function () {
-	var constrainingCtrBox = dojo.html.getContentBox(this.constrainingContainerNode);
-	var sliderHandleBox = dojo.html.getContentBox(this.sliderHandleNode);
-	if (isNaN(constrainingCtrBox.height) || isNaN(sliderHandleBox.height) || constrainingCtrBox.height <= 0 || sliderHandleBox.height <= 0) {
-		return false;
-	}
-	this._constraintHeight = constrainingCtrBox.height + dojo.html.getPadding(this.constrainingContainerNode).height - sliderHandleBox.height;
-	if (this.flipY) {
-		this._clipTop = this._clipBottom = constrainingCtrBox.height;
-	} else {
-		this._clipTop = this._clipBottom = 0;
-	}
-	this._clipYdelta = sliderHandleBox.height >> 1;
-	if (!this.isEnableX) {
-		this._clipLeft = 0;
-		this._clipRight = constrainingCtrBox.width;
-	}
-	if (this._constraintHeight <= 0) {
-		return false;
-	}
-	if (this.snapValuesY == 0) {
-		this.snapValuesY = this._constraintHeight + 1;
-	}
-	this._valueSizeY = this._constraintHeight / (this.snapValuesY - 1);
-	return true;
-}, setValueY:function (value) {
-	if (0 == this._valueSizeY) {
-		if (this._calc_valueSizeY() == false) {
-			dojo.lang.setTimeout(this, "setValueY", 100, value);
-			return;
-		}
-	}
-	if (isNaN(value)) {
-		value = 0;
-	}
-	if (value > this.maximumY) {
-		value = this.maximumY;
-	} else {
-		if (value < this.minimumY) {
-			value = this.minimumY;
-		}
-	}
-	var pixelPercent = (value - this.minimumY) / (this.maximumY - this.minimumY);
-	if (this.flipY) {
-		pixelPercent = 1 - pixelPercent;
-	}
-	this._snapY(pixelPercent * this._constraintHeight);
-	this.notifyListeners();
-}, getValueY:function () {
-	var pixelPercent = dojo.html.getPixelValue(this.sliderHandleNode, "top") / this._constraintHeight;
-	if (this.flipY) {
-		pixelPercent = 1 - pixelPercent;
-	}
-	return Math.round(pixelPercent * (this.snapValuesY - 1)) * ((this.maximumY - this.minimumY) / (this.snapValuesY - 1)) + this.minimumY;
-}, _onClick:function (evt) {
-	if (this._isDragInProgress) {
-		return;
-	}
-	var parent = dojo.html.getAbsolutePosition(this.constrainingContainerNode, true, dojo.html.boxSizing.MARGIN_BOX);
-	var content = dojo.html.getContentBox(this._handleMove.domNode);
-	if (this.isEnableX) {
-		var x = evt.pageX - parent.x - (content.width >> 1);
-		this._snapX(x);
-	}
-	if (this.isEnableY) {
-		var y = evt.pageY - parent.y - (content.height >> 1);
-		this._snapY(y);
-	}
-	this.notifyListeners();
-}, notifyListeners:function () {
-	this.onValueChanged(this.getValueX(), this.getValueY());
-}, onValueChanged:function (x, y) {
-}});
-dojo.widget.defineWidget("dojo.widget.SliderHorizontal", dojo.widget.Slider, {isEnableX:true, isEnableY:false, initialValue:"", snapValues:"", minimum:"", maximum:"", buttonStyle:"", backgroundSize:"height:10px;width:200px;", backgroundSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider-bg.gif"), flip:false, postMixInProperties:function () {
-	dojo.widget.SliderHorizontal.superclass.postMixInProperties.apply(this, arguments);
-	if (!isNaN(parseFloat(this.initialValue))) {
-		this.initialValueX = parseFloat(this.initialValue);
-	}
-	if (!isNaN(parseFloat(this.minimum))) {
-		this.minimumX = parseFloat(this.minimum);
-	}
-	if (!isNaN(parseFloat(this.maximum))) {
-		this.maximumX = parseFloat(this.maximum);
-	}
-	if (!isNaN(parseInt(this.snapValues))) {
-		this.snapValuesX = parseInt(this.snapValues);
-	}
-	if (dojo.lang.isString(this.buttonStyle) && this.buttonStyle != "") {
-		this.buttonStyleX = this.buttonStyle;
-	}
-	if (dojo.lang.isBoolean(this.flip)) {
-		this.flipX = this.flip;
-	}
-}, notifyListeners:function () {
-	this.onValueChanged(this.getValueX());
-}, getValue:function () {
-	return this.getValueX();
-}, setValue:function (value) {
-	this.setValueX(value);
-}, onValueChanged:function (value) {
-}});
-dojo.widget.defineWidget("dojo.widget.SliderVertical", dojo.widget.Slider, {isEnableX:false, isEnableY:true, initialValue:"", snapValues:"", minimum:"", maximum:"", buttonStyle:"", backgroundSize:"width:10px;height:200px;", backgroundSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/slider-bg-vert.gif"), flip:false, postMixInProperties:function () {
-	dojo.widget.SliderVertical.superclass.postMixInProperties.apply(this, arguments);
-	if (!isNaN(parseFloat(this.initialValue))) {
-		this.initialValueY = parseFloat(this.initialValue);
-	}
-	if (!isNaN(parseFloat(this.minimum))) {
-		this.minimumY = parseFloat(this.minimum);
-	}
-	if (!isNaN(parseFloat(this.maximum))) {
-		this.maximumY = parseFloat(this.maximum);
-	}
-	if (!isNaN(parseInt(this.snapValues))) {
-		this.snapValuesY = parseInt(this.snapValues);
-	}
-	if (dojo.lang.isString(this.buttonStyle) && this.buttonStyle != "") {
-		this.buttonStyleY = this.buttonStyle;
-	}
-	if (dojo.lang.isBoolean(this.flip)) {
-		this.flipY = this.flip;
-	}
-}, notifyListeners:function () {
-	this.onValueChanged(this.getValueY());
-}, getValue:function () {
-	return this.getValueY();
-}, setValue:function (value) {
-	this.setValueY(value);
-}, onValueChanged:function (value) {
-}});
-dojo.declare("dojo.widget._SliderDragMoveSource", dojo.dnd.HtmlDragMoveSource, {slider:null, onDragStart:function (evt) {
-	this.slider._isDragInProgress = true;
-	var dragObj = this.createDragMoveObject();
-	this.slider.notifyListeners();
-	return dragObj;
-}, onDragEnd:function (evt) {
-	this.slider._isDragInProgress = false;
-	this.slider.notifyListeners();
-}, createDragMoveObject:function () {
-	var dragObj = new dojo.widget._SliderDragMoveObject(this.dragObject, this.type);
-	dragObj.slider = this.slider;
-	if (this.dragClass) {
-		dragObj.dragClass = this.dragClass;
-	}
-	return dragObj;
-}, setParent:function (slider) {
-	this.slider = slider;
-}});
-dojo.declare("dojo.widget._SliderDragMoveObject", dojo.dnd.HtmlDragMoveObject, {slider:null, onDragMove:function (evt) {
-	this.updateDragOffset();
-	if (this.slider.isEnableX) {
-		var x = this.dragOffset.x + evt.pageX;
-		this.slider._snapX(x);
-	}
-	if (this.slider.isEnableY) {
-		var y = this.dragOffset.y + evt.pageY;
-		this.slider._snapY(y);
-	}
-	if (this.slider.activeDrag) {
-		this.slider.notifyListeners();
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/SortableTable.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SortableTable.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SortableTable.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,493 +8,31 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.SortableTable");
-dojo.deprecated("SortableTable will be removed in favor of FilteringTable.", "0.5");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.date.format");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.html.util");
-dojo.require("dojo.html.style");
-dojo.require("dojo.event.*");
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.SortableTable", dojo.widget.HtmlWidget, function () {
-	this.data = [];
-	this.selected = [];
-	this.columns = [];
-}, {enableMultipleSelect:false, maximumNumberOfSelections:0, enableAlternateRows:false, minRows:0, defaultDateFormat:"%D", sortIndex:0, sortDirection:0, valueField:"Id", headClass:"", tbodyClass:"", headerClass:"", headerSortUpClass:"selected", headerSortDownClass:"selected", rowClass:"", rowAlternateClass:"alt", rowSelectedClass:"selected", columnSelected:"sorted-column", isContainer:false, templatePath:null, templateCssPath:null, getTypeFromString:function (s) {
-	var parts = s.split("."), i = 0, obj = dj_global;
-	do {
-		obj = obj[parts[i++]];
-	} while (i < parts.length && obj);
-	return (obj != dj_global) ? obj : null;
-}, compare:function (o1, o2) {
-	for (var p in o1) {
-		if (!(p in o2)) {
-			return false;
-		}
-		if (o1[p].valueOf() != o2[p].valueOf()) {
-			return false;
-		}
-	}
-	return true;
-}, isSelected:function (o) {
-	for (var i = 0; i < this.selected.length; i++) {
-		if (this.compare(this.selected[i], o)) {
-			return true;
-		}
-	}
-	return false;
-}, removeFromSelected:function (o) {
-	var idx = -1;
-	for (var i = 0; i < this.selected.length; i++) {
-		if (this.compare(this.selected[i], o)) {
-			idx = i;
-			break;
-		}
-	}
-	if (idx >= 0) {
-		this.selected.splice(idx, 1);
-	}
-}, getSelection:function () {
-	return this.selected;
-}, getValue:function () {
-	var a = [];
-	for (var i = 0; i < this.selected.length; i++) {
-		if (this.selected[i][this.valueField]) {
-			a.push(this.selected[i][this.valueField]);
-		}
-	}
-	return a.join();
-}, reset:function () {
-	this.columns = [];
-	this.data = [];
-	this.resetSelections(this.domNode.getElementsByTagName("tbody")[0]);
-}, resetSelections:function (body) {
-	this.selected = [];
-	var idx = 0;
-	var rows = body.getElementsByTagName("tr");
-	for (var i = 0; i < rows.length; i++) {
-		if (rows[i].parentNode == body) {
-			rows[i].removeAttribute("selected");
-			if (this.enableAlternateRows && idx % 2 == 1) {
-				rows[i].className = this.rowAlternateClass;
-			} else {
-				rows[i].className = "";
-			}
-			idx++;
-		}
-	}
-}, getObjectFromRow:function (row) {
-	var cells = row.getElementsByTagName("td");
-	var o = {};
-	for (var i = 0; i < this.columns.length; i++) {
-		if (this.columns[i].sortType == "__markup__") {
-			o[this.columns[i].getField()] = cells[i].innerHTML;
-		} else {
-			var text = dojo.html.renderedTextContent(cells[i]);
-			var val = text;
-			if (this.columns[i].getType() != String) {
-				var val = new (this.columns[i].getType())(text);
-			}
-			o[this.columns[i].getField()] = val;
-		}
-	}
-	if (dojo.html.hasAttribute(row, "value")) {
-		o[this.valueField] = dojo.html.getAttribute(row, "value");
-	}
-	return o;
-}, setSelectionByRow:function (row) {
-	var o = this.getObjectFromRow(row);
-	var b = false;
-	for (var i = 0; i < this.selected.length; i++) {
-		if (this.compare(this.selected[i], o)) {
-			b = true;
-			break;
-		}
-	}
-	if (!b) {
-		this.selected.push(o);
-	}
-}, parseColumns:function (node) {
-	this.reset();
-	var row = node.getElementsByTagName("tr")[0];
-	var cells = row.getElementsByTagName("td");
-	if (cells.length == 0) {
-		cells = row.getElementsByTagName("th");
-	}
-	for (var i = 0; i < cells.length; i++) {
-		var o = {field:null, format:null, noSort:false, sortType:"String", dataType:String, sortFunction:null, label:null, align:"left", valign:"middle", getField:function () {
-			return this.field || this.label;
-		}, getType:function () {
-			return this.dataType;
-		}};
-		if (dojo.html.hasAttribute(cells[i], "align")) {
-			o.align = dojo.html.getAttribute(cells[i], "align");
-		}
-		if (dojo.html.hasAttribute(cells[i], "valign")) {
-			o.valign = dojo.html.getAttribute(cells[i], "valign");
-		}
-		if (dojo.html.hasAttribute(cells[i], "nosort")) {
-			o.noSort = dojo.html.getAttribute(cells[i], "nosort") == "true";
-		}
-		if (dojo.html.hasAttribute(cells[i], "sortusing")) {
-			var trans = dojo.html.getAttribute(cells[i], "sortusing");
-			var f = this.getTypeFromString(trans);
-			if (f != null && f != window && typeof (f) == "function") {
-				o.sortFunction = f;
-			}
-		}
-		if (dojo.html.hasAttribute(cells[i], "field")) {
-			o.field = dojo.html.getAttribute(cells[i], "field");
-		}
-		if (dojo.html.hasAttribute(cells[i], "format")) {
-			o.format = dojo.html.getAttribute(cells[i], "format");
-		}
-		if (dojo.html.hasAttribute(cells[i], "dataType")) {
-			var sortType = dojo.html.getAttribute(cells[i], "dataType");
-			if (sortType.toLowerCase() == "html" || sortType.toLowerCase() == "markup") {
-				o.sortType = "__markup__";
-				o.noSort = true;
-			} else {
-				var type = this.getTypeFromString(sortType);
-				if (type) {
-					o.sortType = sortType;
-					o.dataType = type;
-				}
-			}
-		}
-		o.label = dojo.html.renderedTextContent(cells[i]);
-		this.columns.push(o);
-		if (dojo.html.hasAttribute(cells[i], "sort")) {
-			this.sortIndex = i;
-			var dir = dojo.html.getAttribute(cells[i], "sort");
-			if (!isNaN(parseInt(dir))) {
-				dir = parseInt(dir);
-				this.sortDirection = (dir != 0) ? 1 : 0;
-			} else {
-				this.sortDirection = (dir.toLowerCase() == "desc") ? 1 : 0;
-			}
-		}
-	}
-}, parseData:function (data) {
-	this.data = [];
-	this.selected = [];
-	for (var i = 0; i < data.length; i++) {
-		var o = {};
-		for (var j = 0; j < this.columns.length; j++) {
-			var field = this.columns[j].getField();
-			if (this.columns[j].sortType == "__markup__") {
-				o[field] = String(data[i][field]);
-			} else {
-				var type = this.columns[j].getType();
-				var val = data[i][field];
-				var t = this.columns[j].sortType.toLowerCase();
-				if (type == String) {
-					o[field] = val;
-				} else {
-					if (val != null) {
-						o[field] = new type(val);
-					} else {
-						o[field] = new type();
-					}
-				}
-			}
-		}
-		if (data[i][this.valueField] && !o[this.valueField]) {
-			o[this.valueField] = data[i][this.valueField];
-		}
-		this.data.push(o);
-	}
-}, parseDataFromTable:function (tbody) {
-	this.data = [];
-	this.selected = [];
-	var rows = tbody.getElementsByTagName("tr");
-	for (var i = 0; i < rows.length; i++) {
-		if (dojo.html.getAttribute(rows[i], "ignoreIfParsed") == "true") {
-			continue;
-		}
-		var o = {};
-		var cells = rows[i].getElementsByTagName("td");
-		for (var j = 0; j < this.columns.length; j++) {
-			var field = this.columns[j].getField();
-			if (this.columns[j].sortType == "__markup__") {
-				o[field] = cells[j].innerHTML;
-			} else {
-				var type = this.columns[j].getType();
-				var val = dojo.html.renderedTextContent(cells[j]);
-				if (type == String) {
-					o[field] = val;
-				} else {
-					if (val != null) {
-						o[field] = new type(val);
-					} else {
-						o[field] = new type();
-					}
-				}
-			}
-		}
-		if (dojo.html.hasAttribute(rows[i], "value") && !o[this.valueField]) {
-			o[this.valueField] = dojo.html.getAttribute(rows[i], "value");
-		}
-		this.data.push(o);
-		if (dojo.html.getAttribute(rows[i], "selected") == "true") {
-			this.selected.push(o);
-		}
-	}
-}, showSelections:function () {
-	var body = this.domNode.getElementsByTagName("tbody")[0];
-	var rows = body.getElementsByTagName("tr");
-	var idx = 0;
-	for (var i = 0; i < rows.length; i++) {
-		if (rows[i].parentNode == body) {
-			if (dojo.html.getAttribute(rows[i], "selected") == "true") {
-				rows[i].className = this.rowSelectedClass;
-			} else {
-				if (this.enableAlternateRows && idx % 2 == 1) {
-					rows[i].className = this.rowAlternateClass;
-				} else {
-					rows[i].className = "";
-				}
-			}
-			idx++;
-		}
-	}
-}, render:function (bDontPreserve) {
-	var data = [];
-	var body = this.domNode.getElementsByTagName("tbody")[0];
-	if (!bDontPreserve) {
-		this.parseDataFromTable(body);
-	}
-	for (var i = 0; i < this.data.length; i++) {
-		data.push(this.data[i]);
-	}
-	var col = this.columns[this.sortIndex];
-	if (!col.noSort) {
-		var field = col.getField();
-		if (col.sortFunction) {
-			var sort = col.sortFunction;
-		} else {
-			var sort = function (a, b) {
-				if (a[field] > b[field]) {
-					return 1;
-				}
-				if (a[field] < b[field]) {
-					return -1;
-				}
-				return 0;
-			};
-		}
-		data.sort(sort);
-		if (this.sortDirection != 0) {
-			data.reverse();
-		}
-	}
-	while (body.childNodes.length > 0) {
-		body.removeChild(body.childNodes[0]);
-	}
-	for (var i = 0; i < data.length; i++) {
-		var row = document.createElement("tr");
-		dojo.html.disableSelection(row);
-		if (data[i][this.valueField]) {
-			row.setAttribute("value", data[i][this.valueField]);
-		}
-		if (this.isSelected(data[i])) {
-			row.className = this.rowSelectedClass;
-			row.setAttribute("selected", "true");
-		} else {
-			if (this.enableAlternateRows && i % 2 == 1) {
-				row.className = this.rowAlternateClass;
-			}
-		}
-		for (var j = 0; j < this.columns.length; j++) {
-			var cell = document.createElement("td");
-			cell.setAttribute("align", this.columns[j].align);
-			cell.setAttribute("valign", this.columns[j].valign);
-			dojo.html.disableSelection(cell);
-			if (this.sortIndex == j) {
-				cell.className = this.columnSelected;
-			}
-			if (this.columns[j].sortType == "__markup__") {
-				cell.innerHTML = data[i][this.columns[j].getField()];
-				for (var k = 0; k < cell.childNodes.length; k++) {
-					var node = cell.childNodes[k];
-					if (node && node.nodeType == dojo.html.ELEMENT_NODE) {
-						dojo.html.disableSelection(node);
-					}
-				}
-			} else {
-				if (this.columns[j].getType() == Date) {
-					var format = this.defaultDateFormat;
-					if (this.columns[j].format) {
-						format = this.columns[j].format;
-					}
-					cell.appendChild(document.createTextNode(dojo.date.strftime(data[i][this.columns[j].getField()], format)));
-				} else {
-					cell.appendChild(document.createTextNode(data[i][this.columns[j].getField()]));
-				}
-			}
-			row.appendChild(cell);
-		}
-		body.appendChild(row);
-		dojo.event.connect(row, "onclick", this, "onUISelect");
-	}
-	var minRows = parseInt(this.minRows);
-	if (!isNaN(minRows) && minRows > 0 && data.length < minRows) {
-		var mod = 0;
-		if (data.length % 2 == 0) {
-			mod = 1;
-		}
-		var nRows = minRows - data.length;
-		for (var i = 0; i < nRows; i++) {
-			var row = document.createElement("tr");
-			row.setAttribute("ignoreIfParsed", "true");
-			if (this.enableAlternateRows && i % 2 == mod) {
-				row.className = this.rowAlternateClass;
-			}
-			for (var j = 0; j < this.columns.length; j++) {
-				var cell = document.createElement("td");
-				cell.appendChild(document.createTextNode("\xa0"));
-				row.appendChild(cell);
-			}
-			body.appendChild(row);
-		}
-	}
-}, onSelect:function (e) {
-}, onUISelect:function (e) {
-	var row = dojo.html.getParentByType(e.target, "tr");
-	var body = dojo.html.getParentByType(row, "tbody");
-	if (this.enableMultipleSelect) {
-		if (e.metaKey || e.ctrlKey) {
-			if (this.isSelected(this.getObjectFromRow(row))) {
-				this.removeFromSelected(this.getObjectFromRow(row));
-				row.removeAttribute("selected");
-			} else {
-				this.setSelectionByRow(row);
-				row.setAttribute("selected", "true");
-			}
-		} else {
-			if (e.shiftKey) {
-				var startRow;
-				var rows = body.getElementsByTagName("tr");
-				for (var i = 0; i < rows.length; i++) {
-					if (rows[i].parentNode == body) {
-						if (rows[i] == row) {
-							break;
-						}
-						if (dojo.html.getAttribute(rows[i], "selected") == "true") {
-							startRow = rows[i];
-						}
-					}
-				}
-				if (!startRow) {
-					startRow = row;
-					for (; i < rows.length; i++) {
-						if (dojo.html.getAttribute(rows[i], "selected") == "true") {
-							row = rows[i];
-							break;
-						}
-					}
-				}
-				this.resetSelections(body);
-				if (startRow == row) {
-					row.setAttribute("selected", "true");
-					this.setSelectionByRow(row);
-				} else {
-					var doSelect = false;
-					for (var i = 0; i < rows.length; i++) {
-						if (rows[i].parentNode == body) {
-							rows[i].removeAttribute("selected");
-							if (rows[i] == startRow) {
-								doSelect = true;
-							}
-							if (doSelect) {
-								this.setSelectionByRow(rows[i]);
-								rows[i].setAttribute("selected", "true");
-							}
-							if (rows[i] == row) {
-								doSelect = false;
-							}
-						}
-					}
-				}
-			} else {
-				this.resetSelections(body);
-				row.setAttribute("selected", "true");
-				this.setSelectionByRow(row);
-			}
-		}
-	} else {
-		this.resetSelections(body);
-		row.setAttribute("selected", "true");
-		this.setSelectionByRow(row);
-	}
-	this.showSelections();
-	this.onSelect(e);
-	e.stopPropagation();
-	e.preventDefault();
-}, onHeaderClick:function (e) {
-	var oldIndex = this.sortIndex;
-	var oldDirection = this.sortDirection;
-	var source = e.target;
-	var row = dojo.html.getParentByType(source, "tr");
-	var cellTag = "td";
-	if (row.getElementsByTagName(cellTag).length == 0) {
-		cellTag = "th";
-	}
-	var headers = row.getElementsByTagName(cellTag);
-	var header = dojo.html.getParentByType(source, cellTag);
-	for (var i = 0; i < headers.length; i++) {
-		if (headers[i] == header) {
-			if (i != oldIndex) {
-				this.sortIndex = i;
-				this.sortDirection = 0;
-				headers[i].className = this.headerSortDownClass;
-			} else {
-				this.sortDirection = (oldDirection == 0) ? 1 : 0;
-				if (this.sortDirection == 0) {
-					headers[i].className = this.headerSortDownClass;
-				} else {
-					headers[i].className = this.headerSortUpClass;
-				}
-			}
-		} else {
-			headers[i].className = this.headerClass;
-		}
-	}
-	this.render();
-}, postCreate:function () {
-	var thead = this.domNode.getElementsByTagName("thead")[0];
-	if (this.headClass.length > 0) {
-		thead.className = this.headClass;
-	}
-	dojo.html.disableSelection(this.domNode);
-	this.parseColumns(thead);
-	var header = "td";
-	if (thead.getElementsByTagName(header).length == 0) {
-		header = "th";
-	}
-	var headers = thead.getElementsByTagName(header);
-	for (var i = 0; i < headers.length; i++) {
-		if (!this.columns[i].noSort) {
-			dojo.event.connect(headers[i], "onclick", this, "onHeaderClick");
-		}
-		if (this.sortIndex == i) {
-			if (this.sortDirection == 0) {
-				headers[i].className = this.headerSortDownClass;
-			} else {
-				headers[i].className = this.headerSortUpClass;
-			}
-		}
-	}
-	var tbody = this.domNode.getElementsByTagName("tbody")[0];
-	if (this.tbodyClass.length > 0) {
-		tbody.className = this.tbodyClass;
-	}
-	this.parseDataFromTable(tbody);
-	this.render(true);
-}});
+dojo.requireAfterIf("html", "dojo.widget.html.SortableTable");
+dojo.widget.tags.addParseTreeHandler("dojo:sortableTable");
 
+//	set up the general widget
+dojo.widget.SortableTable=function(){
+	//	summary
+	//	base class for the SortableTable
+	dojo.widget.Widget.call(this);
+	this.widgetType="SortableTable";
+	this.isContainer=false;
+
+	//	custom properties
+	this.enableMultipleSelect=false;
+	this.maximumNumberOfSelections=0;	//	0 for unlimited, is the default.
+	this.enableAlternateRows=false;
+	this.minRows=0;	//	0 means ignore.
+	this.defaultDateFormat="%D";
+	this.data=[];
+	this.selected=[];		//	always an array to handle multiple selections.
+	this.columns=[];
+	this.sortIndex=0;		//	index of the column sorted on, first is the default.
+	this.sortDirection=0;	//	0==asc, 1==desc
+	this.valueField="Id";	//	if a JSON structure is parsed and there is a field of this name,
+							//	a value attribute will be added to the row (tr value="{Id}")
+};
+dojo.inherits(dojo.widget.SortableTable, dojo.widget.Widget);

Modified: tags/parley-0.53/root/static/magic/src/widget/Spinner.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Spinner.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Spinner.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,519 +8,187 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.Spinner");
-dojo.require("dojo.io.*");
-dojo.require("dojo.lfx.*");
-dojo.require("dojo.html.*");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.string");
+dojo.provide("dojo.widget.AdjustableIntegerTextbox");
+
+dojo.require("dojo.widget.validate.IntegerTextbox");
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.IntegerTextbox");
-dojo.require("dojo.widget.RealNumberTextbox");
-dojo.require("dojo.widget.DateTextbox");
-dojo.require("dojo.experimental");
-dojo.declare("dojo.widget.Spinner", null, {_typamaticTimer:null, _typamaticFunction:null, _currentTimeout:this.defaultTimeout, _eventCount:0, defaultTimeout:500, timeoutChangeRate:0.9, templateString:"<span _=\"weird end tag formatting is to prevent whitespace from becoming &nbsp;\"\n\tstyle='float:${this.htmlfloat};'\n\t><table cellpadding=0 cellspacing=0 class=\"dojoSpinner\">\n\t\t<tr>\n\t\t\t<td\n\t\t\t\t><input\n\t\t\t\t\tdojoAttachPoint='textbox' type='${this.type}'\n\t\t\t\t\tdojoAttachEvent='onblur;onfocus;onkey:_handleKeyEvents;onKeyUp:_onSpinnerKeyUp;onresize:_resize'\n\t\t\t\t\tid='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'\n\t\t\t\t\tvalue='${this.value}' class='${this.className}' autocomplete=\"off\"\n\t\t\t></td>\n\t\t\t<td\n\t\t\t\t><img dojoAttachPoint=\"upArrowNode\"\n\t\t\t\t\tdojoAttachEvent=\"onDblClick: _upArrowDoubleClicked;  onMouseDown: _upArrowPressed; onMouseUp: _arrowReleased; onMouseOut: _arrowReleased!
 ; onMouseMove: _discardEvent;\"\n\t\t\t\t\tsrc=\"${this.incrementSrc}\" style=\"width: ${this.buttonSize.width}px; height: ${this.buttonSize.height}px;\"\n\t\t\t\t><img dojoAttachPoint=\"downArrowNode\"\n\t\t\t\t\tdojoAttachEvent=\"onDblClick: _downArrowDoubleClicked;  onMouseDown: _downArrowPressed; onMouseUp: _arrowReleased; onMouseOut: _arrowReleased; onMouseMove: _discardEvent;\"\n\t\t\t\t\tsrc=\"${this.decrementSrc}\" style=\"width: ${this.buttonSize.width}px; height: ${this.buttonSize.height}px;\"\n\t\t\t></td>\n\t\t</tr>\n\t</table\n\t><span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'>${this.messages.invalidMessage}</span\n\t><span dojoAttachPoint='missingSpan' class='${this.missingClass}'>${this.messages.missingMessage}</span\n\t><span dojoAttachPoint='rangeSpan' class='${this.rangeClass}'>${this.messages.rangeMessage}</span\n></span>\n", templateCssString:"/* inline the table holding the <input> and buttons (method varies by browser) */\n.ie .dojoSpi!
 nner, .safari .dojoSpinner {\n\tdisplay: inline;\n}\n\n.moz .d!
 ojoSpinn
er {\n\tdisplay: -moz-inline-box;\n}\n\n.opera .dojoSpinner {\n\tdisplay: inline-table;\n}\n\n/* generic stuff for the table */\n.dojoSpinner td {\n\tpadding:0px;\n\tmargin:0px;\n\tvertical-align: middle;\n}\ntable.dojoSpinner {\n\tborder:0px;\n\tborder-spacing:0px;\n\tline-height:0px;\n\tpadding:0px;\n\tmargin: 0px;\n\tvertical-align: middle;\n}\n\n/* the buttons */\n.dojoSpinner img {\n\tdisplay: block;\n\tborder-width:0px 1px 1px 0px;\n\tborder-style:outset;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Spinner.css"), incrementSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/spinnerIncrement.gif"), decrementSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/spinnerDecrement.gif"), _handleKeyEvents:function (evt) {
-	if (!evt.key) {
-		return;
-	}
-	if (!evt.ctrlKey && !evt.altKey) {
-		switch (evt.key) {
-		  case evt.KEY_DOWN_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			this._downArrowPressed(evt);
-			return;
-		  case evt.KEY_UP_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			this._upArrowPressed(evt);
-			return;
-		}
-	}
-	this._eventCount++;
-}, _onSpinnerKeyUp:function (evt) {
-	this._arrowReleased(evt);
-	this.onkeyup(evt);
-}, _resize:function () {
-	var inputSize = dojo.html.getBorderBox(this.textbox);
-	this.buttonSize = {width:inputSize.height / 2, height:inputSize.height / 2};
-	if (this.upArrowNode) {
-		dojo.html.setMarginBox(this.upArrowNode, this.buttonSize);
-		dojo.html.setMarginBox(this.downArrowNode, this.buttonSize);
-	}
-}, _pressButton:function (node) {
-	node.style.borderWidth = "1px 0px 0px 1px";
-	node.style.borderStyle = "inset";
-}, _releaseButton:function (node) {
-	node.style.borderWidth = "0px 1px 1px 0px";
-	node.style.borderStyle = "outset";
-}, _arrowPressed:function (evt, direction) {
-	var nodePressed = (direction == -1) ? this.downArrowNode : this.upArrowNode;
-	var nodeReleased = (direction == +1) ? this.downArrowNode : this.upArrowNode;
-	if (typeof evt != "number") {
-		if (this._typamaticTimer != null) {
-			if (this._typamaticNode == nodePressed) {
-				return;
+dojo.require("dojo.event.*");
+
+/*
+  ****** AdjustableIntegerTextbox ******
+
+  A subclass of IntegerTextbox.
+*/
+dojo.widget.AdjustableIntegerTextbox = function(node) {
+        // this property isn't a primitive and needs to be created on a per-item basis.
+        this.flags = {};
+}
+dojo.inherits(dojo.widget.AdjustableIntegerTextbox, dojo.widget.validate.IntegerTextbox);
+dojo.lang.extend(dojo.widget.AdjustableIntegerTextbox, {
+        // new subclass properties
+        widgetType: "AdjustableIntegerTextbox",
+		delta: "1",
+
+        adjustValue: function(direction, x){
+			var val = this.getValue().replace(/[^\-+\d]/g, "");
+			if(val.length == 0){ return; }
+
+			num = Math.min(Math.max((parseInt(val)+(parseInt(this.delta) * direction)), this.flags.min), this.flags.max);
+			val = (new Number(num)).toString();
+
+			if(num >= 0){
+				val = ((this.flags.signed == true)?'+':' ')+val; // make sure first char is a nondigit
 			}
-			dojo.lang.clearTimeout(this._typamaticTimer);
-		}
-		this._releaseButton(nodeReleased);
-		this._eventCount++;
-		this._typamaticTimer = null;
-		this._currentTimeout = this.defaultTimeout;
-	} else {
-		if (evt != this._eventCount) {
-			this._releaseButton(nodePressed);
-			return;
-		}
-	}
-	this._pressButton(nodePressed);
-	this._setCursorX(this.adjustValue(direction, this._getCursorX()));
-	this._typamaticNode = nodePressed;
-	this._typamaticTimer = dojo.lang.setTimeout(this, "_arrowPressed", this._currentTimeout, this._eventCount, direction);
-	this._currentTimeout = Math.round(this._currentTimeout * this.timeoutChangeRate);
-}, _downArrowPressed:function (evt) {
-	return this._arrowPressed(evt, -1);
-}, _downArrowDoubleClicked:function (evt) {
-	var rc = this._downArrowPressed(evt);
-	dojo.lang.setTimeout(this, "_arrowReleased", 50, null);
-	return rc;
-}, _upArrowPressed:function (evt) {
-	return this._arrowPressed(evt, +1);
-}, _upArrowDoubleClicked:function (evt) {
-	var rc = this._upArrowPressed(evt);
-	dojo.lang.setTimeout(this, "_arrowReleased", 50, null);
-	return rc;
-}, _arrowReleased:function (evt) {
-	this.textbox.focus();
-	if (evt != null && typeof evt == "object" && evt.keyCode && evt.keyCode != null) {
-		var keyCode = evt.keyCode;
-		var k = dojo.event.browser.keys;
-		switch (keyCode) {
-		  case k.KEY_DOWN_ARROW:
-		  case k.KEY_UP_ARROW:
-			dojo.event.browser.stopEvent(evt);
-			break;
-		}
-	}
-	this._releaseButton(this.upArrowNode);
-	this._releaseButton(this.downArrowNode);
-	this._eventCount++;
-	if (this._typamaticTimer != null) {
-		dojo.lang.clearTimeout(this._typamaticTimer);
-	}
-	this._typamaticTimer = null;
-	this._currentTimeout = this.defaultTimeout;
-}, _mouseWheeled:function (evt) {
-	var scrollAmount = 0;
-	if (typeof evt.wheelDelta == "number") {
-		scrollAmount = evt.wheelDelta;
-	} else {
-		if (typeof evt.detail == "number") {
-			scrollAmount = -evt.detail;
-		}
-	}
-	if (scrollAmount > 0) {
-		this._upArrowPressed(evt);
-		this._arrowReleased(evt);
-	} else {
-		if (scrollAmount < 0) {
-			this._downArrowPressed(evt);
-			this._arrowReleased(evt);
-		}
-	}
-}, _discardEvent:function (evt) {
-	dojo.event.browser.stopEvent(evt);
-}, _getCursorX:function () {
-	var x = -1;
-	try {
-		this.textbox.focus();
-		if (typeof this.textbox.selectionEnd == "number") {
-			x = this.textbox.selectionEnd;
-		} else {
-			if (document.selection && document.selection.createRange) {
-				var range = document.selection.createRange().duplicate();
-				if (range.parentElement() == this.textbox) {
-					range.moveStart("textedit", -1);
-					x = range.text.length;
+
+			if(this.flags.separator.length > 0){
+				for (var i=val.length-3; i > 1; i-=3){
+					val = val.substr(0,i)+this.flags.separator+val.substr(i);
 				}
 			}
-		}
+
+			if(val.substr(0,1) == ' '){ val = val.substr(1); } // remove space
+
+			this.setValue(val);
+
+			return val.length;
 	}
-	catch (e) {
-	}
-	return x;
-}, _setCursorX:function (x) {
-	try {
-		this.textbox.focus();
-		if (!x) {
-			x = 0;
-		}
-		if (typeof this.textbox.selectionEnd == "number") {
-			this.textbox.selectionEnd = x;
-		} else {
-			if (this.textbox.createTextRange) {
-				var range = this.textbox.createTextRange();
-				range.collapse(true);
-				range.moveEnd("character", x);
-				range.moveStart("character", x);
-				range.select();
+});
+dojo.widget.tags.addParseTreeHandler("dojo:AdjustableIntegerTextbox");
+
+/*
+  ****** AdjustableRealNumberTextbox ******
+
+  A subclass of RealNumberTextbox.
+  @attr places    The exact number of decimal places.  If omitted, it's unlimited and optional.
+  @attr exponent  Can be true or false.  If omitted the exponential part is optional.
+  @attr eSigned   Is the exponent signed?  Can be true or false, if omitted the sign is optional.
+*/
+dojo.widget.AdjustableRealNumberTextbox = function(node) {
+        // this property isn't a primitive and needs to be created on a per-item basis.
+        this.flags = {};
+}
+dojo.inherits(dojo.widget.AdjustableRealNumberTextbox, dojo.widget.validate.RealNumberTextbox);
+dojo.lang.extend(dojo.widget.AdjustableRealNumberTextbox, {
+        // new subclass properties
+        widgetType: "AdjustableRealNumberTextbox",
+		delta: "1e1",
+
+        adjustValue: function(direction, x){
+			var val = this.getValue().replace(/[^\-+\.eE\d]/g, "");
+			if(!val.length){ return; }
+
+			var num = parseFloat(val);
+			if(isNaN(num)){ return; }
+			var delta = this.delta.split(/[eE]/);
+			if(!delta.length){
+				delta = [1, 1];
+			}else{
+				delta[0] = parseFloat(delta[0].replace(/[^\-+\.\d]/g, ""));
+				if(isNaN(delta[0])){ delta[0] = 1; }
+				if(delta.length > 1){
+					delta[1] = parseInt(delta[1]);
+				}
+				if(isNaN(delta[1])){ delta[1] = 1; }
 			}
-		}
-	}
-	catch (e) {
-	}
-}, _spinnerPostMixInProperties:function (args, frag) {
-	var inputNode = this.getFragNodeRef(frag);
-	var inputSize = dojo.html.getBorderBox(inputNode);
-	this.buttonSize = {width:inputSize.height / 2 - 1, height:inputSize.height / 2 - 1};
-}, _spinnerPostCreate:function (args, frag) {
-	if (this.textbox.addEventListener) {
-		this.textbox.addEventListener("DOMMouseScroll", dojo.lang.hitch(this, "_mouseWheeled"), false);
-	} else {
-		dojo.event.connect(this.textbox, "onmousewheel", this, "_mouseWheeled");
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.IntegerSpinner", [dojo.widget.IntegerTextbox, dojo.widget.Spinner], {delta:"1", postMixInProperties:function (args, frag) {
-	dojo.widget.IntegerSpinner.superclass.postMixInProperties.apply(this, arguments);
-	this._spinnerPostMixInProperties(args, frag);
-}, postCreate:function (args, frag) {
-	dojo.widget.IntegerSpinner.superclass.postCreate.apply(this, arguments);
-	this._spinnerPostCreate(args, frag);
-}, adjustValue:function (direction, x) {
-	var val = this.getValue().replace(/[^\-+\d]/g, "");
-	if (val.length == 0) {
-		return;
-	}
-	var num = Math.min(Math.max((parseInt(val) + (parseInt(this.delta) * direction)), (this.flags.min ? this.flags.min : -Infinity)), (this.flags.max ? this.flags.max : +Infinity));
-	val = num.toString();
-	if (num >= 0) {
-		val = ((this.flags.signed == true) ? "+" : " ") + val;
-	}
-	if (this.flags.separator.length > 0) {
-		for (var i = val.length - 3; i > 1; i -= 3) {
-			val = val.substr(0, i) + this.flags.separator + val.substr(i);
-		}
-	}
-	if (val.substr(0, 1) == " ") {
-		val = val.substr(1);
-	}
-	this.setValue(val);
-	return val.length;
-}});
-dojo.widget.defineWidget("dojo.widget.RealNumberSpinner", [dojo.widget.RealNumberTextbox, dojo.widget.Spinner], function () {
-	dojo.experimental("dojo.widget.RealNumberSpinner");
-}, {delta:"1e1", postMixInProperties:function (args, frag) {
-	dojo.widget.RealNumberSpinner.superclass.postMixInProperties.apply(this, arguments);
-	this._spinnerPostMixInProperties(args, frag);
-}, postCreate:function (args, frag) {
-	dojo.widget.RealNumberSpinner.superclass.postCreate.apply(this, arguments);
-	this._spinnerPostCreate(args, frag);
-}, adjustValue:function (direction, x) {
-	var val = this.getValue().replace(/[^\-+\.eE\d]/g, "");
-	if (!val.length) {
-		return;
-	}
-	var num = parseFloat(val);
-	if (isNaN(num)) {
-		return;
-	}
-	var delta = this.delta.split(/[eE]/);
-	if (!delta.length) {
-		delta = [1, 1];
-	} else {
-		delta[0] = parseFloat(delta[0].replace(/[^\-+\.\d]/g, ""));
-		if (isNaN(delta[0])) {
-			delta[0] = 1;
-		}
-		if (delta.length > 1) {
-			delta[1] = parseInt(delta[1]);
-		}
-		if (isNaN(delta[1])) {
-			delta[1] = 1;
-		}
-	}
-	val = this.getValue().split(/[eE]/);
-	if (!val.length) {
-		return;
-	}
-	var numBase = parseFloat(val[0].replace(/[^\-+\.\d]/g, ""));
-	if (val.length == 1) {
-		var numExp = 0;
-	} else {
-		var numExp = parseInt(val[1].replace(/[^\-+\d]/g, ""));
-	}
-	if (x <= val[0].length) {
-		x = 0;
-		numBase += delta[0] * direction;
-	} else {
-		x = Number.MAX_VALUE;
-		numExp += delta[1] * direction;
-		if (this.flags.eSigned == false && numExp < 0) {
-			numExp = 0;
-		}
-	}
-	num = Math.min(Math.max((numBase * Math.pow(10, numExp)), (this.flags.min ? this.flags.min : -Infinity)), (this.flags.max ? this.flags.max : +Infinity));
-	if ((this.flags.exponent == true || (this.flags.exponent != false && x != 0)) && num.toExponential) {
-		if (isNaN(this.flags.places) || this.flags.places == Infinity) {
-			val = num.toExponential();
-		} else {
-			val = num.toExponential(this.flags.places);
-		}
-	} else {
-		if (num.toFixed && num.toPrecision) {
-			if (isNaN(this.flags.places) || this.flags.places == Infinity) {
-				val = num.toPrecision((1 / 3).toString().length - 1);
-			} else {
-				val = num.toFixed(this.flags.places);
+			val = this.getValue().split(/[eE]/);
+			if(!val.length){ return; }
+			var numBase = parseFloat(val[0].replace(/[^\-+\.\d]/g, ""));
+			if(val.length == 1){
+				var numExp = 0;
+			}else{
+				var numExp = parseInt(val[1].replace(/[^\-+\d]/g, ""));
 			}
-		} else {
-			val = num.toString();
-		}
-	}
-	if (num >= 0) {
-		if (this.flags.signed == true) {
-			val = "+" + val;
-		}
-	}
-	val = val.split(/[eE]/);
-	if (this.flags.separator.length > 0) {
-		if (num >= 0 && val[0].substr(0, 1) != "+") {
-			val[0] = " " + val[0];
-		}
-		var i = val[0].lastIndexOf(".");
-		if (i >= 0) {
-			i -= 3;
-		} else {
-			i = val[0].length - 3;
-		}
-		for (; i > 1; i -= 3) {
-			val[0] = val[0].substr(0, i) + this.flags.separator + val[0].substr(i);
-		}
-		if (val[0].substr(0, 1) == " ") {
-			val[0] = val[0].substr(1);
-		}
-	}
-	if (val.length > 1) {
-		if ((this.flags.eSigned == true) && (val[1].substr(0, 1) != "+")) {
-			val[1] = "+" + val[1];
-		} else {
-			if ((!this.flags.eSigned) && (val[1].substr(0, 1) == "+")) {
-				val[1] = val[1].substr(1);
-			} else {
-				if ((!this.flags.eSigned) && (val[1].substr(0, 1) == "-") && (num.toFixed && num.toPrecision)) {
-					if (isNaN(this.flags.places)) {
-						val[0] = num.toPrecision((1 / 3).toString().length - 1);
-					} else {
-						val[0] = num.toFixed(this.flags.places).toString();
-					}
-					val[1] = "0";
+			if(x <= val[0].length){
+				x = 0;
+				numBase += delta[0] * direction;
+			}else{
+				x = Number.MAX_VALUE;
+				numExp += delta[1] * direction;
+				if(this.flags.eSigned == false && numExp < 0){
+					numExp = 0;
 				}
 			}
-		}
-		val[0] += "e" + val[1];
-	}
-	this.setValue(val[0]);
-	if (x > val[0].length) {
-		x = val[0].length;
-	}
-	return x;
-}});
-dojo.widget.defineWidget("dojo.widget.TimeSpinner", [dojo.widget.TimeTextbox, dojo.widget.Spinner], function () {
-	dojo.experimental("dojo.widget.TimeSpinner");
-}, {postMixInProperties:function (args, frag) {
-	dojo.widget.TimeSpinner.superclass.postMixInProperties.apply(this, arguments);
-	this._spinnerPostMixInProperties(args, frag);
-}, postCreate:function (args, frag) {
-	dojo.widget.TimeSpinner.superclass.postCreate.apply(this, arguments);
-	this._spinnerPostCreate(args, frag);
-}, adjustValue:function (direction, x) {
-	var val = this.getValue();
-	var format = (this.flags.format && this.flags.format.search(/[Hhmst]/) >= 0) ? this.flags.format : "hh:mm:ss t";
-	if (direction == 0 || !val.length || !this.isValid()) {
-		return;
-	}
-	if (!this.flags.amSymbol) {
-		this.flags.amSymbol = "AM";
-	}
-	if (!this.flags.pmSymbol) {
-		this.flags.pmSymbol = "PM";
-	}
-	var re = dojo.regexp.time(this.flags);
-	var qualifiers = format.replace(/H/g, "h").replace(/[^hmst]/g, "").replace(/([hmst])\1/g, "$1");
-	var hourPos = qualifiers.indexOf("h") + 1;
-	var minPos = qualifiers.indexOf("m") + 1;
-	var secPos = qualifiers.indexOf("s") + 1;
-	var ampmPos = qualifiers.indexOf("t") + 1;
-	var cursorFormat = format;
-	var ampm = "";
-	if (ampmPos > 0) {
-		ampm = val.replace(new RegExp(re), "$" + ampmPos);
-		cursorFormat = cursorFormat.replace(/t+/, ampm.replace(/./g, "t"));
-	}
-	var hour = 0;
-	var deltaHour = 1;
-	if (hourPos > 0) {
-		hour = val.replace(new RegExp(re), "$" + hourPos);
-		if (dojo.lang.isString(this.delta)) {
-			deltaHour = this.delta.replace(new RegExp(re), "$" + hourPos);
-		}
-		if (isNaN(deltaHour)) {
-			deltaHour = 1;
-		} else {
-			deltaHour = parseInt(deltaHour);
-		}
-		if (hour.length == 2) {
-			cursorFormat = cursorFormat.replace(/([Hh])+/, "$1$1");
-		} else {
-			cursorFormat = cursorFormat.replace(/([Hh])+/, "$1");
-		}
-		if (isNaN(hour)) {
-			hour = 0;
-		} else {
-			hour = parseInt(hour.replace(/^0(\d)/, "$1"));
-		}
-	}
-	var min = 0;
-	var deltaMin = 1;
-	if (minPos > 0) {
-		min = val.replace(new RegExp(re), "$" + minPos);
-		if (dojo.lang.isString(this.delta)) {
-			deltaMin = this.delta.replace(new RegExp(re), "$" + minPos);
-		}
-		if (isNaN(deltaMin)) {
-			deltaMin = 1;
-		} else {
-			deltaMin = parseInt(deltaMin);
-		}
-		cursorFormat = cursorFormat.replace(/m+/, min.replace(/./g, "m"));
-		if (isNaN(min)) {
-			min = 0;
-		} else {
-			min = parseInt(min.replace(/^0(\d)/, "$1"));
-		}
-	}
-	var sec = 0;
-	var deltaSec = 1;
-	if (secPos > 0) {
-		sec = val.replace(new RegExp(re), "$" + secPos);
-		if (dojo.lang.isString(this.delta)) {
-			deltaSec = this.delta.replace(new RegExp(re), "$" + secPos);
-		}
-		if (isNaN(deltaSec)) {
-			deltaSec = 1;
-		} else {
-			deltaSec = parseInt(deltaSec);
-		}
-		cursorFormat = cursorFormat.replace(/s+/, sec.replace(/./g, "s"));
-		if (isNaN(sec)) {
-			sec = 0;
-		} else {
-			sec = parseInt(sec.replace(/^0(\d)/, "$1"));
-		}
-	}
-	if (isNaN(x) || x >= cursorFormat.length) {
-		x = cursorFormat.length - 1;
-	}
-	var cursorToken = cursorFormat.charAt(x);
-	switch (cursorToken) {
-	  case "t":
-		if (ampm == this.flags.amSymbol) {
-			ampm = this.flags.pmSymbol;
-		} else {
-			if (ampm == this.flags.pmSymbol) {
-				ampm = this.flags.amSymbol;
+			num = Math.min(Math.max((numBase * Math.pow(10,numExp)), this.flags.min), this.flags.max);
+			if((this.flags.exponent == true || (this.flags.exponent != false && x != 0)) && num.toExponential){
+				if (isNaN(this.flags.places) || this.flags.places == Infinity){
+					val = num.toExponential();
+				}else{
+					val = num.toExponential(this.flags.places);
+				}
+			}else if(num.toFixed && num.toPrecision){
+				if(isNaN(this.flags.places)){
+					val = num.toPrecision((1/3).toString().length-1);
+				}else{
+					val = num.toFixed(this.flags.places);
+				}
+			}else{
+				val = num.toString();
 			}
-		}
-		break;
-	  default:
-		if (hour >= 1 && hour < 12 && ampm == this.flags.pmSymbol) {
-			hour += 12;
-		}
-		if (hour == 12 && ampm == this.flags.amSymbol) {
-			hour = 0;
-		}
-		switch (cursorToken) {
-		  case "s":
-			sec += deltaSec * direction;
-			while (sec < 0) {
-				min--;
-				sec += 60;
+
+			if(num >= 0){
+				if(this.flags.signed == true){
+					val = '+' + val;
+				}
 			}
-			while (sec >= 60) {
-				min++;
-				sec -= 60;
+			val = val.split(/[eE]/);
+			if(this.flags.separator.length > 0){
+				if(num >= 0 && val[0].substr(0,1) != '+'){
+					val[0] = ' ' + val[0]; // make sure first char is nondigit for easy algorithm
+				}
+				var i = val[0].lastIndexOf('.');
+				if(i >= 0){
+					i -= 3;
+				}else{
+					i = val[0].length-3;
+				}
+				for (; i > 1; i-=3){
+					val[0] = val[0].substr(0,i)+this.flags.separator+val[0].substr(i);
+				}
+				if(val[0].substr(0,1) == ' '){ val[0] = val[0].substr(1); } // remove space
 			}
-		  case "m":
-			if (cursorToken == "m") {
-				min += deltaMin * direction;
+			if(val.length > 1){
+				if((this.flags.eSigned == true)&&(val[1].substr(0,1) != '+')){
+					val[1] = '+' + val[1];
+				}else if((!this.flags.eSigned)&&(val[1].substr(0,1) == '+')){
+					val[1] = val[1].substr(1);
+				}else if((!this.flags.eSigned)&&(val[1].substr(0,1) == '-')&&(num.toFixed && num.toPrecision)){
+					if(isNaN(this.flags.places)){
+						val[0] = num.toPrecision((1/3).toString().length-1);
+					}else{
+						val[0] = num.toFixed(this.flags.places).toString();
+					}
+					val[1] = "0";
+				}
+				val[0] += 'e' + val[1];
 			}
-			while (min < 0) {
-				hour--;
-				min += 60;
-			}
-			while (min >= 60) {
-				hour++;
-				min -= 60;
-			}
-		  case "h":
-		  case "H":
-			if (cursorToken == "h" || cursorToken == "H") {
-				hour += deltaHour * direction;
-			}
-			while (hour < 0) {
-				hour += 24;
-			}
-			while (hour >= 24) {
-				hour -= 24;
-			}
-			break;
-		  default:
-			return;
-		}
-		if (hour >= 12) {
-			ampm = this.flags.pmSymbol;
-			if (format.indexOf("h") >= 0 && hour >= 13) {
-				hour -= 12;
-			}
-		} else {
-			ampm = this.flags.amSymbol;
-			if (format.indexOf("h") >= 0 && hour == 0) {
-				hour = 12;
-			}
-		}
+			this.setValue(val[0]);
+			if(x > val[0].length){ x = val[0].length; }
+			return x;
 	}
-	cursorFormat = format;
-	if (hour >= 0 && hour < 10 && format.search(/[hH]{2}/) >= 0) {
-		hour = "0" + hour.toString();
-	}
-	if (hour >= 10 && cursorFormat.search(/[hH]{2}/) < 0) {
-		cursorFormat = cursorFormat.replace(/(h|H)/, "$1$1");
-	}
-	if (min >= 0 && min < 10 && cursorFormat.search(/mm/) >= 0) {
-		min = "0" + min.toString();
-	}
-	if (min >= 10 && cursorFormat.search(/mm/) < 0) {
-		cursorFormat = cursorFormat.replace(/m/, "$1$1");
-	}
-	if (sec >= 0 && sec < 10 && cursorFormat.search(/ss/) >= 0) {
-		sec = "0" + sec.toString();
-	}
-	if (sec >= 10 && cursorFormat.search(/ss/) < 0) {
-		cursorFormat = cursorFormat.replace(/s/, "$1$1");
-	}
-	x = cursorFormat.indexOf(cursorToken);
-	if (x == -1) {
-		x = format.length;
-	}
-	format = format.replace(/[hH]+/, hour);
-	format = format.replace(/m+/, min);
-	format = format.replace(/s+/, sec);
-	format = format.replace(/t/, ampm);
-	this.setValue(format);
-	if (x > format.length) {
-		x = format.length;
-	}
-	return x;
-}});
+});
+dojo.widget.tags.addParseTreeHandler("dojo:AdjustableRealNumberTextbox");
 
+dojo.widget.Spinner = function(){
+	dojo.widget.Widget.call(this);
+}
+
+dojo.inherits(dojo.widget.Spinner, dojo.widget.Widget);
+
+dojo.widget.Spinner.defaults = {
+	widgetType: "Spinner",
+	isContainer: false
+};
+
+dojo.lang.extend(dojo.widget.Spinner, dojo.widget.Spinner.defaults);
+
+dojo.widget.DomSpinner = function(){
+	dojo.widget.Spinner.call(this);
+	dojo.widget.DomWidget.call(this, true);
+}
+
+dojo.inherits(dojo.widget.DomSpinner, dojo.widget.DomWidget);
+dojo.widget.tags.addParseTreeHandler("dojo:Spinner");
+
+// render-specific includes
+dojo.requireAfterIf("html", "dojo.widget.html.Spinner");

Modified: tags/parley-0.53/root/static/magic/src/widget/SplitContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SplitContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SplitContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,318 +8,572 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.SplitContainer");
+dojo.provide("dojo.widget.SplitContainerPanel");
+dojo.provide("dojo.widget.html.SplitContainer");
+dojo.provide("dojo.widget.html.SplitContainerPanel");
 
+//
+// TODO
+// make it prettier
+// active dragging upwards doesn't always shift other bars (direction calculation is wrong in this case)
+//
 
-dojo.provide("dojo.widget.SplitContainer");
 dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.ContentPane");
+dojo.require("dojo.widget.LayoutContainer");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.html.selection");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.dom");
+dojo.require("dojo.io");	// workaround dojo bug. dojo.io.cookie requires dojo.io but it still doesn't get pulled in
 dojo.require("dojo.io.cookie");
-dojo.widget.defineWidget("dojo.widget.SplitContainer", dojo.widget.HtmlWidget, function () {
+
+dojo.widget.html.SplitContainer = function(){
+
+	dojo.widget.HtmlWidget.call(this);
+
 	this.sizers = [];
-}, {isContainer:true, templateCssString:".dojoSplitContainer{\n\tposition: relative;\n\toverflow: hidden;\n\tdisplay: block;\n}\n\n.dojoSplitPane{\n\tposition: absolute;\n}\n\n.dojoSplitContainerSizerH,\n.dojoSplitContainerSizerV {\n\tfont-size: 1px;\n\tcursor: move;\n\tcursor: w-resize;\n\tbackground-color: ThreeDFace;\n\tborder: 1px solid;\n\tborder-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;\n\tmargin: 0;\n}\n\n.dojoSplitContainerSizerV {\n\tcursor: n-resize;\n}\n\n.dojoSplitContainerVirtualSizerH,\n.dojoSplitContainerVirtualSizerV {\n\tfont-size: 1px;\n\tcursor: move;\n\tcursor: w-resize;\n\tbackground-color: ThreeDShadow;\n\t-moz-opacity: 0.5;\n\topacity: 0.5;\n\tfilter: Alpha(Opacity=50);\n\tmargin: 0;\n}\n\n.dojoSplitContainerVirtualSizerV {\n\tcursor: n-resize;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/SplitContainer.css"), activeSizing:false, sizerWidth:15, orientation:"horizontal", persist:true, postMixInProperties:f!
 unction () {
-	dojo.widget.SplitContainer.superclass.postMixInProperties.apply(this, arguments);
-	this.isHorizontal = (this.orientation == "horizontal");
-}, fillInTemplate:function () {
-	dojo.widget.SplitContainer.superclass.fillInTemplate.apply(this, arguments);
-	dojo.html.addClass(this.domNode, "dojoSplitContainer");
-	if (dojo.render.html.moz) {
-		this.domNode.style.overflow = "-moz-scrollbars-none";
-	}
-	var content = dojo.html.getContentBox(this.domNode);
-	this.paneWidth = content.width;
-	this.paneHeight = content.height;
-}, onResized:function (e) {
-	var content = dojo.html.getContentBox(this.domNode);
-	this.paneWidth = content.width;
-	this.paneHeight = content.height;
-	this._layoutPanels();
-}, postCreate:function (args, fragment, parentComp) {
-	dojo.widget.SplitContainer.superclass.postCreate.apply(this, arguments);
-	for (var i = 0; i < this.children.length; i++) {
-		with (this.children[i].domNode.style) {
-			position = "absolute";
+}
+
+dojo.inherits(dojo.widget.html.SplitContainer, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.SplitContainer, {
+	widgetType: "SplitContainer",
+	isContainer: true,
+
+	virtualSizer: null,
+	isHorizontal: 0,
+	paneBefore: null,
+	paneAfter: null,
+	isSizing: false,
+	dragOffset: null,
+	startPoint: null,
+	lastPoint: null,
+	sizingSplitter: null,
+	isActiveResize: 0,
+	offsetX: 0,
+	offsetY: 0,
+	isDraggingLeft: 0,
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlSplitContainer.css"),
+	originPos: null,
+	persist: true,		// save splitter positions in a cookie
+
+	activeSizing: '',
+	sizerWidth: 15,
+	orientation: 'horizontal',
+
+	debugName: '',
+
+	fillInTemplate: function(){
+
+		dojo.style.insertCssFile(this.templateCssPath, null, true);
+		dojo.html.addClass(this.domNode, "dojoSplitContainer");
+		this.domNode.style.overflow='hidden';	// workaround firefox bug
+
+		this.paneWidth = dojo.style.getContentWidth(this.domNode);
+		this.paneHeight = dojo.style.getContentHeight(this.domNode);
+
+		this.isHorizontal = (this.orientation == 'horizontal') ? 1 : 0;
+		this.isActiveResize = (this.activeSizing == '1') ? 1 : 0;
+
+		//dojo.debug("fillInTemplate for "+this.debugName);
+	},
+
+	onResized: function(e){
+		this.paneWidth = dojo.style.getContentWidth(this.domNode);
+		this.paneHeight = dojo.style.getContentHeight(this.domNode);
+		this.layoutPanels();
+	},
+
+	postCreate: function(args, fragment, parentComp){
+
+		// dojo.debug("post create for "+this.debugName);
+
+		// attach the children and create the draggers
+		for(var i=0; i<this.children.length; i++){
+            with(this.children[i].domNode.style){
+                position = "absolute";
+            }
+            dojo.html.addClass(this.children[i].domNode,
+                "dojoSplitPane");
+
+            if(i == this.children.length-1){
+                break;
+            }
+
+            this._addSizer();
 		}
-		dojo.html.addClass(this.children[i].domNode, "dojoSplitPane");
-		if (i == this.children.length - 1) {
-			break;
+
+		// create the fake dragger
+		this.virtualSizer = document.createElement('div');
+		this.virtualSizer.style.position = 'absolute';
+		this.virtualSizer.style.display = 'none';
+		//this.virtualSizer.style.backgroundColor = 'lime';
+		this.virtualSizer.style.zIndex = 10;
+		this.virtualSizer.className = this.isHorizontal ? 'dojoSplitContainerVirtualSizerH' : 'dojoSplitContainerVirtualSizerV';
+		this.domNode.appendChild(this.virtualSizer);
+
+		dojo.html.disableSelection(this.virtualSizer);
+
+		if(this.persist){
+			this.restoreState();
 		}
-		this._addSizer();
-	}
-	if (typeof this.sizerWidth == "object") {
-		try {
-			this.sizerWidth = parseInt(this.sizerWidth.toString());
+
+		// size the panels once the browser has caught up
+		this.resizeSoon();
+	},
+
+    _injectChild: function(child) {
+        with(child.domNode.style){
+            position = "absolute";
+        }
+        dojo.html.addClass(child.domNode,
+            "dojoSplitPane");
+    },
+
+    _addSizer: function() {
+        var i = this.sizers.length;
+
+        this.sizers[i] = document.createElement('div');
+        this.sizers[i].style.position = 'absolute';
+        this.sizers[i].className = this.isHorizontal ? 'dojoSplitContainerSizerH' : 'dojoSplitContainerSizerV';
+
+        var self = this;
+        var handler = (function(){ var sizer_i = i; return function(e){ self.beginSizing(e, sizer_i); } })();
+        dojo.event.connect(this.sizers[i], "onmousedown", handler);
+
+        this.domNode.appendChild(this.sizers[i]);
+        dojo.html.disableSelection(this.sizers[i]);
+    },
+
+    removeChild: function(widget){
+        // Remove sizer, but only if widget is really our child and
+        // we have at least one sizer to throw away
+        if (this.sizers.length > 0) {
+            for(var x=0; x<this.children.length; x++){
+                if(this.children[x] === widget){
+                    var i = this.sizers.length - 1;
+                    this.domNode.removeChild(this.sizers[i]);
+                    this.sizers.length = i;
+                    break;
+                }
+            }
+        }
+
+        // Remove widget and repaint
+        dojo.widget.html.SplitContainer.superclass.removeChild.call(this, widget, arguments);
+        this.onResized();
+    },
+
+    addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+        dojo.widget.html.SplitContainer.superclass.addChild.call(this, widget, overrideContainerNode, pos, ref, insertIndex);
+        this._injectChild(widget);
+
+        if (this.children.length > 1) {
+            this._addSizer();
+        }
+
+        this.layoutPanels();
+    },
+
+    layoutPanels: function(){
+        if (this.children.length == 0){ return; }
+
+		//
+		// calculate space
+		//
+
+		var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
+
+		if (this.children.length > 1){
+
+			space -= this.sizerWidth * (this.children.length - 1);
 		}
-		catch (e) {
-			this.sizerWidth = 15;
+
+
+		//
+		// calculate total of SizeShare values
+		//
+
+		var out_of = 0;
+
+		for(var i=0; i<this.children.length; i++){
+
+			out_of += this.children[i].sizeShare;
 		}
-	}
-	this.virtualSizer = document.createElement("div");
-	this.virtualSizer.style.position = "absolute";
-	this.virtualSizer.style.display = "none";
-	this.virtualSizer.style.zIndex = 10;
-	this.virtualSizer.className = this.isHorizontal ? "dojoSplitContainerVirtualSizerH" : "dojoSplitContainerVirtualSizerV";
-	this.domNode.appendChild(this.virtualSizer);
-	dojo.html.disableSelection(this.virtualSizer);
-	if (this.persist) {
-		this._restoreState();
-	}
-	this.resizeSoon();
-}, _injectChild:function (child) {
-	with (child.domNode.style) {
-		position = "absolute";
-	}
-	dojo.html.addClass(child.domNode, "dojoSplitPane");
-}, _addSizer:function () {
-	var i = this.sizers.length;
-	this.sizers[i] = document.createElement("div");
-	this.sizers[i].style.position = "absolute";
-	this.sizers[i].className = this.isHorizontal ? "dojoSplitContainerSizerH" : "dojoSplitContainerSizerV";
-	var self = this;
-	var handler = (function () {
-		var sizer_i = i;
-		return function (e) {
-			self.beginSizing(e, sizer_i);
-		};
-	})();
-	dojo.event.connect(this.sizers[i], "onmousedown", handler);
-	this.domNode.appendChild(this.sizers[i]);
-	dojo.html.disableSelection(this.sizers[i]);
-}, removeChild:function (widget) {
-	if (this.sizers.length > 0) {
-		for (var x = 0; x < this.children.length; x++) {
-			if (this.children[x] === widget) {
-				var i = this.sizers.length - 1;
-				this.domNode.removeChild(this.sizers[i]);
-				this.sizers.length = i;
-				break;
-			}
+
+
+		//
+		// work out actual pixels per sizeshare unit
+		//
+
+		var pix_per_unit = space / out_of;
+
+
+		//
+		// set the SizeActual member of each pane
+		//
+
+		var total_size = 0;
+
+		for(var i=0; i<this.children.length-1; i++){
+
+			var size = Math.round(pix_per_unit * this.children[i].sizeShare);
+			this.children[i].sizeActual = size;
+			total_size += size;
 		}
-	}
-	dojo.widget.SplitContainer.superclass.removeChild.call(this, widget, arguments);
-	this.onResized();
-}, addChild:function (widget) {
-	dojo.widget.SplitContainer.superclass.addChild.apply(this, arguments);
-	this._injectChild(widget);
-	if (this.children.length > 1) {
-		this._addSizer();
-	}
-	this._layoutPanels();
-}, _layoutPanels:function () {
-	if (this.children.length == 0) {
-		return;
-	}
-	var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
-	if (this.children.length > 1) {
-		space -= this.sizerWidth * (this.children.length - 1);
-	}
-	var out_of = 0;
-	for (var i = 0; i < this.children.length; i++) {
-		out_of += this.children[i].sizeShare;
-	}
-	var pix_per_unit = space / out_of;
-	var total_size = 0;
-	for (var i = 0; i < this.children.length - 1; i++) {
-		var size = Math.round(pix_per_unit * this.children[i].sizeShare);
-		this.children[i].sizeActual = size;
-		total_size += size;
-	}
-	this.children[this.children.length - 1].sizeActual = space - total_size;
-	this._checkSizes();
-	var pos = 0;
-	var size = this.children[0].sizeActual;
-	this._movePanel(this.children[0], pos, size);
-	this.children[0].position = pos;
-	pos += size;
-	for (var i = 1; i < this.children.length; i++) {
-		this._moveSlider(this.sizers[i - 1], pos, this.sizerWidth);
-		this.sizers[i - 1].position = pos;
-		pos += this.sizerWidth;
-		size = this.children[i].sizeActual;
-		this._movePanel(this.children[i], pos, size);
-		this.children[i].position = pos;
+		this.children[this.children.length-1].sizeActual = space - total_size;
+
+		//
+		// make sure the sizes are ok
+		//
+
+		this.checkSizes();
+
+
+		//
+		// now loop, positioning each pane and letting children resize themselves
+		//
+
+		var pos = 0;
+		var size = this.children[0].sizeActual;
+		this.movePanel(this.children[0].domNode, pos, size);
+		this.children[0].position = pos;
+        this.children[0].checkSize();
 		pos += size;
-	}
-}, _movePanel:function (panel, pos, size) {
-	if (this.isHorizontal) {
-		panel.domNode.style.left = pos + "px";
-		panel.domNode.style.top = 0;
-		panel.resizeTo(size, this.paneHeight);
-	} else {
-		panel.domNode.style.left = 0;
-		panel.domNode.style.top = pos + "px";
-		panel.resizeTo(this.paneWidth, size);
-	}
-}, _moveSlider:function (slider, pos, size) {
-	if (this.isHorizontal) {
-		slider.style.left = pos + "px";
-		slider.style.top = 0;
-		dojo.html.setMarginBox(slider, {width:size, height:this.paneHeight});
-	} else {
-		slider.style.left = 0;
-		slider.style.top = pos + "px";
-		dojo.html.setMarginBox(slider, {width:this.paneWidth, height:size});
-	}
-}, _growPane:function (growth, pane) {
-	if (growth > 0) {
-		if (pane.sizeActual > pane.sizeMin) {
-			if ((pane.sizeActual - pane.sizeMin) > growth) {
-				pane.sizeActual = pane.sizeActual - growth;
-				growth = 0;
-			} else {
-				growth -= pane.sizeActual - pane.sizeMin;
-				pane.sizeActual = pane.sizeMin;
-			}
+
+		for(var i=1; i<this.children.length; i++){
+
+			// first we position the sizing handle before this pane
+			this.movePanel(this.sizers[i-1], pos, this.sizerWidth);
+			this.sizers[i-1].position = pos;
+			pos += this.sizerWidth;
+
+			size = this.children[i].sizeActual;
+			this.movePanel(this.children[i].domNode, pos, size);
+			this.children[i].position = pos;
+            this.children[i].checkSize();
+			pos += size;
 		}
-	}
-	return growth;
-}, _checkSizes:function () {
-	var total_min_size = 0;
-	var total_size = 0;
-	for (var i = 0; i < this.children.length; i++) {
-		total_size += this.children[i].sizeActual;
-		total_min_size += this.children[i].sizeMin;
-	}
-	if (total_min_size <= total_size) {
-		var growth = 0;
-		for (var i = 0; i < this.children.length; i++) {
-			if (this.children[i].sizeActual < this.children[i].sizeMin) {
-				growth += this.children[i].sizeMin - this.children[i].sizeActual;
-				this.children[i].sizeActual = this.children[i].sizeMin;
+	},
+
+	movePanel: function(panel, pos, size){
+		if (this.isHorizontal){
+			panel.style.left = pos + 'px';
+			panel.style.top = 0;
+
+			dojo.style.setOuterWidth(panel, size);
+			dojo.style.setOuterHeight(panel, this.paneHeight);
+		}else{
+			panel.style.left = 0;
+			panel.style.top = pos + 'px';
+
+			dojo.style.setOuterWidth(panel, this.paneWidth);
+			dojo.style.setOuterHeight(panel, size);
+		}
+	},
+
+	growPane: function(growth, pane){
+
+		if (growth > 0){
+			if (pane.sizeActual > pane.sizeMin){
+				if ((pane.sizeActual - pane.sizeMin) > growth){
+
+					// stick all the growth in this pane
+					pane.sizeActual = pane.sizeActual - growth;
+					growth = 0;
+				}else{
+					// put as much growth in here as we can
+					growth -= pane.sizeActual - pane.sizeMin;
+					pane.sizeActual = pane.sizeMin;
+				}
 			}
 		}
-		if (growth > 0) {
-			if (this.isDraggingLeft) {
-				for (var i = this.children.length - 1; i >= 0; i--) {
-					growth = this._growPane(growth, this.children[i]);
+		return growth;
+	},
+
+	checkSizes: function(){
+
+		var total_min_size = 0;
+		var total_size = 0;
+
+		for(var i=0; i<this.children.length; i++){
+
+			total_size += this.children[i].sizeActual;
+			total_min_size += this.children[i].sizeMin;
+		}
+
+		// only make adjustments if we have enough space for all the minimums
+
+		if (total_min_size <= total_size){
+
+			var growth = 0;
+
+			for(var i=0; i<this.children.length; i++){
+
+				if (this.children[i].sizeActual < this.children[i].sizeMin){
+
+					growth += this.children[i].sizeMin - this.children[i].sizeActual;
+					this.children[i].sizeActual = this.children[i].sizeMin;
 				}
-			} else {
-				for (var i = 0; i < this.children.length; i++) {
-					growth = this._growPane(growth, this.children[i]);
+			}
+
+			if (growth > 0){
+				if (this.isDraggingLeft){
+					for(var i=this.children.length-1; i>=0; i--){
+						growth = this.growPane(growth, this.children[i]);
+					}
+				}else{
+					for(var i=0; i<this.children.length; i++){
+						growth = this.growPane(growth, this.children[i]);
+					}
 				}
 			}
+		}else{
+
+			for(var i=0; i<this.children.length; i++){
+				this.children[i].sizeActual = Math.round(total_size * (this.children[i].sizeMin / total_min_size));
+			}
 		}
-	} else {
-		for (var i = 0; i < this.children.length; i++) {
-			this.children[i].sizeActual = Math.round(total_size * (this.children[i].sizeMin / total_min_size));
+	},
+
+	beginSizing: function(e, i){
+		var clientX = e.layerX;
+		var clientY = e.layerY;
+		var screenX = e.pageX;
+		var screenY = e.pageY;
+
+		this.paneBefore = this.children[i];
+		this.paneAfter = this.children[i+1];
+
+		this.isSizing = true;
+		this.sizingSplitter = this.sizers[i];
+		this.originPos = dojo.style.getAbsolutePosition(this.domNode, true);
+		this.dragOffset = {'x':clientX, 'y':clientY};
+		this.startPoint  = {'x':screenX, 'y':screenY};
+		this.lastPoint  = {'x':screenX, 'y':screenY};
+
+		this.offsetX = screenX - clientX;
+		this.offsetY = screenY - clientY;
+
+		if (!this.isActiveResize){
+			this.showSizingLine();
 		}
-	}
-}, beginSizing:function (e, i) {
-	this.paneBefore = this.children[i];
-	this.paneAfter = this.children[i + 1];
-	this.isSizing = true;
-	this.sizingSplitter = this.sizers[i];
-	this.originPos = dojo.html.getAbsolutePosition(this.children[0].domNode, true, dojo.html.boxSizing.MARGIN_BOX);
-	if (this.isHorizontal) {
-		var client = (e.layerX ? e.layerX : e.offsetX);
-		var screen = e.pageX;
-		this.originPos = this.originPos.x;
-	} else {
-		var client = (e.layerY ? e.layerY : e.offsetY);
-		var screen = e.pageY;
-		this.originPos = this.originPos.y;
-	}
-	this.startPoint = this.lastPoint = screen;
-	this.screenToClientOffset = screen - client;
-	this.dragOffset = this.lastPoint - this.paneBefore.sizeActual - this.originPos - this.paneBefore.position;
-	if (!this.activeSizing) {
-		this._showSizingLine();
-	}
-	dojo.event.connect(document.documentElement, "onmousemove", this, "changeSizing");
-	dojo.event.connect(document.documentElement, "onmouseup", this, "endSizing");
-	dojo.event.browser.stopEvent(e);
-}, changeSizing:function (e) {
-	this.lastPoint = this.isHorizontal ? e.pageX : e.pageY;
-	if (this.activeSizing) {
-		this.movePoint();
-		this._updateSize();
-	} else {
-		this.movePoint();
-		this._moveSizingLine();
-	}
-	dojo.event.browser.stopEvent(e);
-}, endSizing:function (e) {
-	if (!this.activeSizing) {
-		this._hideSizingLine();
-	}
-	this._updateSize();
-	this.isSizing = false;
-	dojo.event.disconnect(document.documentElement, "onmousemove", this, "changeSizing");
-	dojo.event.disconnect(document.documentElement, "onmouseup", this, "endSizing");
-	if (this.persist) {
-		this._saveState(this);
-	}
-}, movePoint:function () {
-	var p = this.lastPoint - this.screenToClientOffset;
-	var a = p - this.dragOffset;
-	a = this.legaliseSplitPoint(a);
-	p = a + this.dragOffset;
-	this.lastPoint = p + this.screenToClientOffset;
-}, legaliseSplitPoint:function (a) {
-	a += this.sizingSplitter.position;
-	this.isDraggingLeft = (a > 0) ? true : false;
-	if (!this.activeSizing) {
-		if (a < this.paneBefore.position + this.paneBefore.sizeMin) {
-			a = this.paneBefore.position + this.paneBefore.sizeMin;
+
+		//
+		// attach mouse events
+		//
+
+		dojo.event.connect(document.documentElement, "onmousemove", this, "changeSizing");
+		dojo.event.connect(document.documentElement, "onmouseup", this, "endSizing");
+	},
+
+	changeSizing: function(e){
+		var screenX = e.pageX;
+		var screenY = e.pageY;
+
+		if (this.isActiveResize){
+			this.lastPoint = {'x':screenX, 'y':screenY};
+			this.movePoint();
+			this.updateSize();
+		}else{
+			this.lastPoint = {'x':screenX, 'y':screenY};
+			this.movePoint();
+			this.moveSizingLine();
 		}
-		if (a > this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin))) {
-			a = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
+	},
+
+	endSizing: function(e){
+
+		if (!this.isActiveResize){
+			this.hideSizingLine();
 		}
-	}
-	a -= this.sizingSplitter.position;
-	this._checkSizes();
-	return a;
-}, _updateSize:function () {
-	var pos = this.lastPoint - this.dragOffset - this.originPos;
-	var start_region = this.paneBefore.position;
-	var end_region = this.paneAfter.position + this.paneAfter.sizeActual;
-	this.paneBefore.sizeActual = pos - start_region;
-	this.paneAfter.position = pos + this.sizerWidth;
-	this.paneAfter.sizeActual = end_region - this.paneAfter.position;
-	for (var i = 0; i < this.children.length; i++) {
-		this.children[i].sizeShare = this.children[i].sizeActual;
-	}
-	this._layoutPanels();
-}, _showSizingLine:function () {
-	this._moveSizingLine();
-	if (this.isHorizontal) {
-		dojo.html.setMarginBox(this.virtualSizer, {width:this.sizerWidth, height:this.paneHeight});
-	} else {
-		dojo.html.setMarginBox(this.virtualSizer, {width:this.paneWidth, height:this.sizerWidth});
-	}
-	this.virtualSizer.style.display = "block";
-}, _hideSizingLine:function () {
-	this.virtualSizer.style.display = "none";
-}, _moveSizingLine:function () {
-	var pos = this.lastPoint - this.startPoint + this.sizingSplitter.position;
-	if (this.isHorizontal) {
-		this.virtualSizer.style.left = pos + "px";
-	} else {
-		var pos = (this.lastPoint - this.startPoint) + this.sizingSplitter.position;
-		this.virtualSizer.style.top = pos + "px";
-	}
-}, _getCookieName:function (i) {
-	return this.widgetId + "_" + i;
-}, _restoreState:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		var cookieName = this._getCookieName(i);
-		var cookieValue = dojo.io.cookie.getCookie(cookieName);
-		if (cookieValue != null) {
-			var pos = parseInt(cookieValue);
-			if (typeof pos == "number") {
-				this.children[i].sizeShare = pos;
+
+		this.updateSize();
+
+		this.isSizing = false;
+
+		dojo.event.disconnect(document.documentElement, "onmousemove", this, "changeSizing");
+		dojo.event.disconnect(document.documentElement, "onmouseup", this, "endSizing");
+		
+		if(this.persist){
+			this.saveState(this);
+		}
+	},
+
+	movePoint: function(){
+
+		// make sure FLastPoint is a legal point to drag to
+		var p = this.screenToMainClient(this.lastPoint);
+
+		if (this.isHorizontal){
+
+			var a = p.x - this.dragOffset.x;
+			a = this.legaliseSplitPoint(a);
+			p.x = a + this.dragOffset.x;
+		}else{
+			var a = p.y - this.dragOffset.y;
+			a = this.legaliseSplitPoint(a);
+			p.y = a + this.dragOffset.y;
+		}
+
+		this.lastPoint = this.mainClientToScreen(p);
+	},
+
+	screenToClient: function(pt){
+
+		pt.x -= (this.offsetX + this.sizingSplitter.position);
+		pt.y -= (this.offsetY + this.sizingSplitter.position);
+
+		return pt;
+	},
+
+	clientToScreen: function(pt){
+
+		pt.x += (this.offsetX + this.sizingSplitter.position);
+		pt.y += (this.offsetY + this.sizingSplitter.position);
+
+		return pt;
+	},
+
+	screenToMainClient: function(pt){
+
+		pt.x -= this.offsetX;
+		pt.y -= this.offsetY;
+
+		return pt;
+	},
+
+	mainClientToScreen: function(pt){
+
+		pt.x += this.offsetX;
+		pt.y += this.offsetY;
+
+		return pt;
+	},
+
+	legaliseSplitPoint: function(a){
+
+		a += this.sizingSplitter.position;
+
+		this.isDraggingLeft = (a > 0) ? 1 : 0;
+
+		if (!this.isActiveResize){
+
+			if (a < this.paneBefore.position + this.paneBefore.sizeMin){
+
+				a = this.paneBefore.position + this.paneBefore.sizeMin;
 			}
+
+			if (a > this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin))){
+
+				a = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
+			}
 		}
+
+		a -= this.sizingSplitter.position;
+
+		this.checkSizes();
+
+		return a;
+	},
+
+	updateSize: function(){
+
+		var p = this.clientToScreen(this.lastPoint);
+		var p = this.screenToClient(this.lastPoint);
+
+		var pos = this.isHorizontal ? p.x - (this.dragOffset.x + this.originPos.x) : p.y - (this.dragOffset.y + this.originPos.y);
+
+		var start_region = this.paneBefore.position;
+		var end_region   = this.paneAfter.position + this.paneAfter.sizeActual;
+
+		this.paneBefore.sizeActual = pos - start_region;
+		this.paneAfter.position    = pos + this.sizerWidth;
+		this.paneAfter.sizeActual  = end_region - this.paneAfter.position;
+
+		for(var i=0; i<this.children.length; i++){
+
+			this.children[i].sizeShare = this.children[i].sizeActual;
+		}
+
+		this.layoutPanels();
+	},
+
+	showSizingLine: function(){
+
+		this.moveSizingLine();
+
+		if (this.isHorizontal){
+			dojo.style.setOuterWidth(this.virtualSizer, this.sizerWidth);
+			dojo.style.setOuterHeight(this.virtualSizer, this.paneHeight);
+		}else{
+			dojo.style.setOuterWidth(this.virtualSizer, this.paneWidth);
+			dojo.style.setOuterHeight(this.virtualSizer, this.sizerWidth);
+		}
+
+		this.virtualSizer.style.display = 'block';
+	},
+
+	hideSizingLine: function(){
+
+		this.virtualSizer.style.display = 'none';
+	},
+
+	moveSizingLine: function(){
+
+		var origin = {'x':0, 'y':0};
+
+		if (this.isHorizontal){
+			origin.x += (this.lastPoint.x - this.startPoint.x) + this.sizingSplitter.position;
+		}else{
+			origin.y += (this.lastPoint.y - this.startPoint.y) + this.sizingSplitter.position;
+		}
+
+		this.virtualSizer.style.left = origin.x + 'px';
+		this.virtualSizer.style.top = origin.y + 'px';
+	},
+	
+	_getCookieName: function(i) {
+		return this.widgetId + "_" + i;
+	},
+
+	restoreState: function () {
+		for(var i=0; i<this.children.length; i++) {
+			var cookieName = this._getCookieName(i);
+			var cookieValue = dojo.io.cookie.getCookie(cookieName);
+			if (cookieValue != null) {
+				var pos = parseInt(cookieValue);
+				this.children[i].sizeShare=pos;
+			}
+		}
+	},
+
+	saveState: function (){
+		for(var i=0; i<this.children.length; i++) {
+			var cookieName = this._getCookieName(i);
+			dojo.io.cookie.setCookie(cookieName, this.children[i].sizeShare, null, null, null, null);
+		}
 	}
-}, _saveState:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		var cookieName = this._getCookieName(i);
-		dojo.io.cookie.setCookie(cookieName, this.children[i].sizeShare, null, null, null, null);
-	}
-}});
-dojo.lang.extend(dojo.widget.Widget, {sizeMin:10, sizeShare:10});
-dojo.widget.defineWidget("dojo.widget.SplitContainerPanel", dojo.widget.ContentPane, {});
+});
 
+// These arguments can be specified for the children of a SplitContainer.
+// Since any widget can be specified as a SplitContainer child, mix them
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	sizeMin: 10,
+	sizeShare: 10
+});
+
+// Deprecated class for split pane children.
+// Actually any widget can be the child of a split pane
+dojo.widget.html.SplitContainerPanel = function(){
+	dojo.widget.html.LayoutContainer.call(this);
+}
+dojo.inherits(dojo.widget.html.SplitContainerPanel, dojo.widget.html.LayoutContainer);
+dojo.lang.extend(dojo.widget.html.SplitContainerPanel, {
+	widgetType: "SplitContainerPanel"
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:SplitContainer");
+dojo.widget.tags.addParseTreeHandler("dojo:SplitContainerPanel");

Modified: tags/parley-0.53/root/static/magic/src/widget/SvgButton.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SvgButton.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SvgButton.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,93 +8,134 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+// FIXME: not yet functional
 
+dojo.provide("dojo.widget.SvgButton");
 
-dojo.provide("dojo.widget.SvgButton");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.widget.SvgButton");
-dojo.widget.SvgButton = function () {
+dojo.require("dojo.widget.Button");
+
+dojo.widget.SvgButton = function(){
+	// FIXME: this is incomplete and doesn't work yet
+	// if DOMButton turns into a mixin, we should subclass Button instead and
+	// just mix in the DOMButton properties.
+
 	dojo.widget.DomButton.call(this);
 	dojo.widget.SvgWidget.call(this);
-	this.onFoo = function () {
-		alert("bar");
-	};
+
+	// FIXME: freaking implement this already!
+	this.onFoo = function(){ alert("bar"); }
+
 	this.label = "huzzah!";
-	this.setLabel = function (x, y, textSize, label, shape) {
+
+	this.setLabel = function(x, y, textSize, label, shape){
+		//var labelNode = this.domNode.ownerDocument.createTextNode(this.label);
+		//var textNode = this.domNode.ownerDocument.createElement("text");
 		var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
 		var textString = "";
-		switch (shape) {
-		  case "ellipse":
-			textString = "<text x='" + coords[6] + "' y='" + coords[7] + "'>" + label + "</text>";
-			break;
-		  case "rectangle":
-			textString = "";
-			break;
-		  case "circle":
-			textString = "";
-			break;
+		switch(shape) {
+			case "ellipse":
+				textString = "<text x='"+ coords[6] + "' y='"+ coords[7] + "'>"+ label + "</text>";
+				//textNode.setAttribute("x", coords[6]);
+				//textNode.setAttribute("y", coords[7]);
+				break;
+			case "rectangle":
+				//FIXME: implement
+				textString = "";
+				//textNode.setAttribute("x", coords[6]);
+				//textNode.setAttribute("y", coords[7]);
+				break;
+			case "circle":
+				//FIXME: implement
+				textString = "";
+				//textNode.setAttribute("x", coords[6]);
+				//textNode.setAttribute("y", coords[7]);
+				break;
 		}
+		//textNode.appendChild(labelNode);
+		//this.domNode.appendChild(textNode);
 		return textString;
-	};
-	this.fillInTemplate = function (x, y, textSize, label, shape) {
+		//alert(textNode.getComputedTextLength());
+	}
+
+	this.fillInTemplate = function(x, y, textSize, label, shape){
+		// the idea is to set the text to the appropriate place given its length
+		// and the template shape
+		
+		// FIXME: For now, assuming text sizes are integers in SVG units
 		this.textSize = textSize || 12;
 		this.label = label;
-		var textWidth = this.label.length * this.textSize;
-	};
-};
+		// FIXEME: for now, I'm going to fake this... need to come up with a real way to 
+		// determine the actual width of the text, such as computedStyle
+		var textWidth = this.label.length*this.textSize ;
+		//this.setLabel();
+	}
+}
+
 dojo.inherits(dojo.widget.SvgButton, dojo.widget.DomButton);
-dojo.widget.SvgButton.prototype.shapeString = function (x, y, textSize, label, shape) {
-	switch (shape) {
-	  case "ellipse":
-		var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
-		return "<ellipse cx='" + coords[4] + "' cy='" + coords[5] + "' rx='" + coords[2] + "' ry='" + coords[3] + "'/>";
-		break;
-	  case "rect":
-		return "";
-		break;
-	  case "circle":
-		return "";
-		break;
+
+// FIXME
+dojo.widget.SvgButton.prototype.shapeString = function(x, y, textSize, label, shape) {
+	switch(shape) {
+		case "ellipse":
+			var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape)
+			return "<ellipse cx='"+ coords[4]+"' cy='"+ coords[5]+"' rx='"+ coords[2]+"' ry='"+ coords[3]+"'/>";
+			break;
+		case "rect":
+			//FIXME: implement
+			return "";
+			//return "<rect x='110' y='45' width='70' height='30'/>";
+			break;
+		case "circle":
+			//FIXME: implement
+			return "";
+			//return "<circle cx='210' cy='60' r='23'/>";
+			break;
 	}
-};
-dojo.widget.SvgButton.prototype.coordinates = function (x, y, textSize, label, shape) {
-	switch (shape) {
-	  case "ellipse":
-		var buttonWidth = label.length * textSize;
-		var buttonHeight = textSize * 2.5;
-		var rx = buttonWidth / 2;
-		var ry = buttonHeight / 2;
-		var cx = rx + x;
-		var cy = ry + y;
-		var textX = cx - rx * textSize / 25;
-		var textY = cy * 1.1;
-		return [buttonWidth, buttonHeight, rx, ry, cx, cy, textX, textY];
-		break;
-	  case "rectangle":
-		return "";
-		break;
-	  case "circle":
-		return "";
-		break;
+}
+
+dojo.widget.SvgButton.prototype.coordinates = function(x, y, textSize, label, shape) {
+	switch(shape) {
+		case "ellipse":
+			var buttonWidth = label.length*textSize;
+			var buttonHeight = textSize*2.5
+			var rx = buttonWidth/2;
+			var ry = buttonHeight/2;
+			var cx = rx + x;
+			var cy = ry + y;
+			var textX = cx - rx*textSize/25;
+			var textY = cy*1.1;
+			return [buttonWidth, buttonHeight, rx, ry, cx, cy, textX, textY];
+			break;
+		case "rectangle":
+			//FIXME: implement
+			return "";
+			break;
+		case "circle":
+			//FIXME: implement
+			return "";
+			break;
 	}
-};
-dojo.widget.SvgButton.prototype.labelString = function (x, y, textSize, label, shape) {
+}
+
+dojo.widget.SvgButton.prototype.labelString = function(x, y, textSize, label, shape){
 	var textString = "";
 	var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
-	switch (shape) {
-	  case "ellipse":
-		textString = "<text x='" + coords[6] + "' y='" + coords[7] + "'>" + label + "</text>";
-		break;
-	  case "rectangle":
-		textString = "";
-		break;
-	  case "circle":
-		textString = "";
-		break;
+	switch(shape) {
+		case "ellipse":
+			textString = "<text x='"+ coords[6] + "' y='"+ coords[7] + "'>"+ label + "</text>";
+			break;
+		case "rectangle":
+			//FIXME: implement
+			textString = "";
+			break;
+		case "circle":
+			//FIXME: implement
+			textString = "";
+			break;
 	}
 	return textString;
-};
-dojo.widget.SvgButton.prototype.templateString = function (x, y, textSize, label, shape) {
-	return "<g class='dojoButton' dojoAttachEvent='onClick; onMouseMove: onFoo;' dojoAttachPoint='labelNode'>" + dojo.widgets.SVGButton.prototype.shapeString(x, y, textSize, label, shape) + dojo.widget.SVGButton.prototype.labelString(x, y, textSize, label, shape) + "</g>";
-};
+}
 
+dojo.widget.SvgButton.prototype.templateString = function(x, y, textSize, label, shape) {
+	return "<g class='dojoButton' dojoAttachEvent='onClick; onMouseMove: onFoo;' dojoAttachPoint='labelNode'>"+ dojo.widgets.SVGButton.prototype.shapeString(x, y, textSize, label, shape) + dojo.widget.SVGButton.prototype.labelString(x, y, textSize, label, shape) + "</g>";
+}

Modified: tags/parley-0.53/root/static/magic/src/widget/SvgWidget.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SvgWidget.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SvgWidget.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,64 +8,85 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.require("dojo.widget.DomWidget");
 dojo.provide("dojo.widget.SvgWidget");
-dojo.provide("dojo.widget.SVGWidget");
+dojo.provide("dojo.widget.SVGWidget"); // back compat
+
 dojo.require("dojo.dom");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.widget.SvgWidget");
-dojo.widget.declare("dojo.widget.SvgWidget", dojo.widget.DomWidget, {createNodesFromText:function (txt, wrap) {
-	return dojo.svg.createNodesFromText(txt, wrap);
-}});
+
+// SVGWidget is a mixin ONLY
+dojo.widget.SvgWidget = function(args){
+	// mix in the parent type
+	// dojo.widget.DomWidget.call(this);
+}
+dojo.inherits(dojo.widget.SvgWidget, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.SvgWidget, {
+	getContainerHeight: function(){
+		// NOTE: container height must be returned as the INNER height
+		dojo.unimplemented("dojo.widget.SvgWidget.getContainerHeight");
+	},
+
+	getContainerWidth: function(){
+		// return this.parent.domNode.offsetWidth;
+		dojo.unimplemented("dojo.widget.SvgWidget.getContainerWidth");
+	},
+
+	setNativeHeight: function(height){
+		// var ch = this.getContainerHeight();
+		dojo.unimplemented("dojo.widget.SVGWidget.setNativeHeight");
+	},
+
+	createNodesFromText: function(txt, wrap){
+		return dojo.dom.createNodesFromText(txt, wrap);
+	}
+});
+
 dojo.widget.SVGWidget = dojo.widget.SvgWidget;
-try {
-	(function () {
-		var tf = function () {
-			var rw = new function () {
-				dojo.widget.SvgWidget.call(this);
-				this.buildRendering = function () {
-					return;
-				};
-				this.destroyRendering = function () {
-					return;
-				};
-				this.postInitialize = function () {
-					return;
-				};
-				this.widgetType = "SVGRootWidget";
-				this.domNode = document.documentElement;
-			};
-			var wm = dojo.widget.manager;
-			wm.root = rw;
-			wm.add(rw);
-			wm.getWidgetFromNode = function (node) {
-				var filter = function (x) {
-					if (x.domNode == node) {
-						return true;
-					}
-				};
-				var widgets = [];
-				while ((node) && (widgets.length < 1)) {
-					widgets = this.getWidgetsByFilter(filter);
-					node = node.parentNode;
+
+try{
+(function(){
+	var tf = function(){
+		// FIXME: fill this in!!!
+		var rw = new function(){
+			dojo.widget.SvgWidget.call(this);
+			this.buildRendering = function(){ return; }
+			this.destroyRendering = function(){ return; }
+			this.postInitialize = function(){ return; }
+			this.cleanUp = function(){ return; }
+			this.widgetType = "SVGRootWidget";
+			this.domNode = document.documentElement;
+		}
+		var wm = dojo.widget.manager;
+		wm.root = rw;
+		wm.add(rw);
+
+		// extend the widgetManager with a getWidgetFromNode method
+		wm.getWidgetFromNode = function(node){
+			var filter = function(x){
+				if(x.domNode == node){
+					return true;
 				}
-				if (widgets.length > 0) {
-					return widgets[0];
-				} else {
-					return null;
-				}
-			};
-			wm.getWidgetFromEvent = function (domEvt) {
-				return this.getWidgetFromNode(domEvt.target);
-			};
-			wm.getWidgetFromPrimitive = wm.getWidgetFromNode;
-		};
-		dojo.event.connect(dojo.hostenv, "loaded", tf);
-	})();
-}
-catch (e) {
-	alert(e);
-}
+			}
+			var widgets = [];
+			while((node)&&(widgets.length < 1)){
+				widgets = this.getWidgetsByFilter(filter);
+				node = node.parentNode;
+			}
+			if(widgets.length > 0){
+				return widgets[0];
+			}else{
+				return null;
+			}
+		}
 
+		wm.getWidgetFromEvent = function(domEvt){
+			return this.getWidgetFromNode(domEvt.target);
+		}
+
+		wm.getWidgetFromPrimitive = wm.getWidgetFromNode;
+	}
+	// make sure we get called when the time is right
+	dojo.event.connect(dojo.hostenv, "loaded", tf);
+})();
+}catch(e){ alert(e); }

Modified: tags/parley-0.53/root/static/magic/src/widget/SwtWidget.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/SwtWidget.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/SwtWidget.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,47 +8,57 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.SwtWidget");
 
-
-dojo.provide("dojo.widget.SwtWidget");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.widget.SwtWidget");
 dojo.require("dojo.event.*");
 dojo.require("dojo.widget.Widget");
 dojo.require("dojo.uri.*");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.lang.extras");
-try {
+
+try{
 	importPackage(Packages.org.eclipse.swt.widgets);
-	dojo.declare("dojo.widget.SwtWidget", dojo.widget.Widget, function () {
-		if ((arguments.length > 0) && (typeof arguments[0] == "object")) {
-			this.create(arguments[0]);
-		}
-	}, {display:null, shell:null, show:function () {
-	}, hide:function () {
-	}, addChild:function () {
-	}, registerChild:function () {
-	}, addWidgetAsDirectChild:function () {
-	}, removeChild:function () {
-	}, destroyRendering:function () {
-	}, postInitialize:function () {
-	}});
+
+	dojo.declare("dojo.widget.SwtWidget", dojo.widget.Widget, {
+		initializer: function() {
+			if((arguments.length>0)&&(typeof arguments[0] == "object")){
+				this.create(arguments[0]);
+			}
+		},
+
+		display: null,
+		shell: null,
+
+		show: function(){ },
+		hide: function(){ },
+
+		addChild: function(){ },
+		registerChild: function(){ },
+		addWidgetAsDirectChild: function(){ },
+		removeChild: function(){ },
+		cleanUp: function(){ },
+		destroyRendering: function(){ },
+		postInitialize: function(){ },
+	});
+
+	// initialize SWT runtime
+
 	dojo.widget.SwtWidget.prototype.display = new Display();
 	dojo.widget.SwtWidget.prototype.shell = new Shell(dojo.widget.SwtWidget.prototype.display);
-	dojo.widget.manager.startShell = function () {
+
+	dojo.widget.manager.startShell = function(){
 		var sh = dojo.widget.SwtWidget.prototype.shell;
 		var d = dojo.widget.SwtWidget.prototype.display;
 		sh.open();
-		while (!sh.isDisposed()) {
+		while(!sh.isDisposed()){
 			dojo.widget.manager.doNext();
-			if (!d.readAndDispatch()) {
+			if(!d.readAndDispatch()){
 				d.sleep();
 			}
 		}
 		d.dispose();
 	};
-}
-catch (e) {
+}catch(e){
+	// seems we didn't have the SWT classes in the environment. Log it.
 	dojo.debug("dojo.widget.SwtWidget not loaded. SWT classes not available");
 }
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TabContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TabContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TabContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,82 +8,254 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.TabContainer");
-dojo.require("dojo.lang.func");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.PageContainer");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.selection");
-dojo.require("dojo.widget.html.layout");
-dojo.widget.defineWidget("dojo.widget.TabContainer", dojo.widget.PageContainer, {labelPosition:"top", closeButton:"none", templateString:null, templateString:"<div id=\"${this.widgetId}\" class=\"dojoTabContainer\">\n\t<div dojoAttachPoint=\"tablistNode\"></div>\n\t<div class=\"dojoTabPaneWrapper\" dojoAttachPoint=\"containerNode\" dojoAttachEvent=\"onKey\" waiRole=\"tabpanel\"></div>\n</div>\n", templateCssString:".dojoTabContainer {\n\tposition : relative;\n}\n\n.dojoTabPaneWrapper {\n\tborder : 1px solid #6290d2;\n\t_zoom: 1; /* force IE6 layout mode so top border doesnt disappear */\n\tdisplay: block;\n\tclear: both;\n\toverflow: hidden;\n}\n\n.dojoTabLabels-top {\n\tposition : relative;\n\ttop : 0px;\n\tleft : 0px;\n\toverflow : visible;\n\tmargin-bottom : -1px;\n\twidth : 100%;\n\tz-index: 2;\t/* so the bottom of the tab label will cover up the border of dojoTabPaneWrapper */\n}\n\n.dojoTabNoLayout.dojoTabLabels-top .dojoTab {\n\tmargin-bottom: -1px;\n\t_margin-bottom!
 : 0px; /* IE filter so top border lines up correctly */\n}\n\n.dojoTab {\n\tposition : relative;\n\tfloat : left;\n\tpadding-left : 9px;\n\tborder-bottom : 1px solid #6290d2;\n\tbackground : url(images/tab_left.gif) no-repeat left top;\n\tcursor: pointer;\n\twhite-space: nowrap;\n\tz-index: 3;\n}\n\n.dojoTab div {\n\tdisplay : block;\n\tpadding : 4px 15px 4px 6px;\n\tbackground : url(images/tab_top_right.gif) no-repeat right top;\n\tcolor : #333;\n\tfont-size : 90%;\n}\n\n.dojoTab .close {\n\tdisplay : inline-block;\n\theight : 12px;\n\twidth : 12px;\n\tpadding : 0 12px 0 0;\n\tmargin : 0 -10px 0 10px;\n\tcursor : default;\n\tfont-size: small;\n}\n\n.dojoTab .closeImage {\n\tbackground : url(images/tab_close.gif) no-repeat right top;\n}\n\n.dojoTab .closeHover {\n\tbackground-image : url(images/tab_close_h.gif);\n}\n\n.dojoTab.current {\n\tpadding-bottom : 1px;\n\tborder-bottom : 0;\n\tbackground-position : 0 -150px;\n}\n\n.dojoTab.current div {\n\tpadding-bottom : 5px;\n\t!
 margin-bottom : -1px;\n\tbackground-position : 100% -150px;\n}!
 \n\n/* b
ottom tabs */\n\n.dojoTabLabels-bottom {\n\tposition : relative;\n\tbottom : 0px;\n\tleft : 0px;\n\toverflow : visible;\n\tmargin-top : -1px;\n\twidth : 100%;\n\tz-index: 2;\n}\n\n.dojoTabNoLayout.dojoTabLabels-bottom {\n\tposition : relative;\n}\n\n.dojoTabLabels-bottom .dojoTab {\n\tborder-top :  1px solid #6290d2;\n\tborder-bottom : 0;\n\tbackground : url(images/tab_bot_left.gif) no-repeat left bottom;\n}\n\n.dojoTabLabels-bottom .dojoTab div {\n\tbackground : url(images/tab_bot_right.gif) no-repeat right bottom;\n}\n\n.dojoTabLabels-bottom .dojoTab.current {\n\tborder-top : 0;\n\tbackground : url(images/tab_bot_left_curr.gif) no-repeat left bottom;\n}\n\n.dojoTabLabels-bottom .dojoTab.current div {\n\tpadding-top : 4px;\n\tbackground : url(images/tab_bot_right_curr.gif) no-repeat right bottom;\n}\n\n/* right-h tabs */\n\n.dojoTabLabels-right-h {\n\toverflow : visible;\n\tmargin-left : -1px;\n\tz-index: 2;\n}\n\n.dojoTabLabels-right-h .dojoTab {\n\tpadding-left : 0;\n\tbo!
 rder-left :  1px solid #6290d2;\n\tborder-bottom : 0;\n\tbackground : url(images/tab_bot_right.gif) no-repeat right bottom;\n\tfloat : none;\n}\n\n.dojoTabLabels-right-h .dojoTab div {\n\tpadding : 4px 15px 4px 15px;\n}\n\n.dojoTabLabels-right-h .dojoTab.current {\n\tborder-left :  0;\n\tborder-bottom :  1px solid #6290d2;\n}\n\n/* left-h tabs */\n\n.dojoTabLabels-left-h {\n\toverflow : visible;\n\tmargin-right : -1px;\n\tz-index: 2;\n}\n\n.dojoTabLabels-left-h .dojoTab {\n\tborder-right :  1px solid #6290d2;\n\tborder-bottom : 0;\n\tfloat : none;\n\tbackground : url(images/tab_top_left.gif) no-repeat left top;\n}\n\n.dojoTabLabels-left-h .dojoTab.current {\n\tborder-right : 0;\n\tborder-bottom :  1px solid #6290d2;\n\tpadding-bottom : 0;\n\tbackground : url(images/tab_top_left.gif) no-repeat 0 -150px;\n}\n\n.dojoTabLabels-left-h .dojoTab div {\n\tbackground : 0;\n\tborder-bottom :  1px solid #6290d2;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TabCo!
 ntainer.css"), selectedTab:"", postMixInProperties:function ()!
  {
-	if (this.selectedTab) {
-		dojo.deprecated("selectedTab deprecated, use selectedChild instead, will be removed in", "0.5");
-		this.selectedChild = this.selectedTab;
-	}
-	if (this.closeButton != "none") {
-		dojo.deprecated("closeButton deprecated, use closable='true' on each child instead, will be removed in", "0.5");
-	}
-	dojo.widget.TabContainer.superclass.postMixInProperties.apply(this, arguments);
-}, fillInTemplate:function () {
-	this.tablist = dojo.widget.createWidget("TabController", {id:this.widgetId + "_tablist", labelPosition:this.labelPosition, doLayout:this.doLayout, containerId:this.widgetId}, this.tablistNode);
-	dojo.widget.TabContainer.superclass.fillInTemplate.apply(this, arguments);
-}, postCreate:function (args, frag) {
-	dojo.widget.TabContainer.superclass.postCreate.apply(this, arguments);
-	this.onResized();
-}, _setupChild:function (tab) {
-	if (this.closeButton == "tab" || this.closeButton == "pane") {
-		tab.closable = true;
-	}
-	dojo.html.addClass(tab.domNode, "dojoTabPane");
-	dojo.widget.TabContainer.superclass._setupChild.apply(this, arguments);
-}, onResized:function () {
-	if (!this.doLayout) {
-		return;
-	}
-	var labelAlign = this.labelPosition.replace(/-h/, "");
-	var children = [{domNode:this.tablist.domNode, layoutAlign:labelAlign}, {domNode:this.containerNode, layoutAlign:"client"}];
-	dojo.widget.html.layout(this.domNode, children);
-	if (this.selectedChildWidget) {
-		var containerSize = dojo.html.getContentBox(this.containerNode);
-		this.selectedChildWidget.resizeTo(containerSize.width, containerSize.height);
-	}
-}, selectTab:function (tab, callingWidget) {
-	dojo.deprecated("use selectChild() rather than selectTab(), selectTab() will be removed in", "0.5");
-	this.selectChild(tab, callingWidget);
-}, onKey:function (e) {
-	if (e.keyCode == e.KEY_UP_ARROW && e.ctrlKey) {
-		var button = this.correspondingTabButton || this.selectedTabWidget.tabButton;
-		button.focus();
-		dojo.event.browser.stopEvent(e);
-	} else {
-		if (e.keyCode == e.KEY_DELETE && e.altKey) {
-			if (this.selectedChildWidget.closable) {
-				this.closeChild(this.selectedChildWidget);
-				dojo.event.browser.stopEvent(e);
-			}
-		}
-	}
-}, destroy:function () {
-	this.tablist.destroy();
-	dojo.widget.TabContainer.superclass.destroy.apply(this, arguments);
-}});
-dojo.widget.defineWidget("dojo.widget.TabController", dojo.widget.PageController, {templateString:"<div wairole='tablist' dojoAttachEvent='onKey'></div>", labelPosition:"top", doLayout:true, "class":"", buttonWidget:"TabButton", postMixInProperties:function () {
-	if (!this["class"]) {
-		this["class"] = "dojoTabLabels-" + this.labelPosition + (this.doLayout ? "" : " dojoTabNoLayout");
-	}
-	dojo.widget.TabController.superclass.postMixInProperties.apply(this, arguments);
-}});
-dojo.widget.defineWidget("dojo.widget.TabButton", dojo.widget.PageButton, {templateString:"<div class='dojoTab' dojoAttachEvent='onClick'>" + "<div dojoAttachPoint='innerDiv'>" + "<span dojoAttachPoint='titleNode' tabIndex='-1' waiRole='tab'>${this.label}</span>" + "<span dojoAttachPoint='closeButtonNode' class='close closeImage' style='${this.closeButtonStyle}'" + "	dojoAttachEvent='onMouseOver:onCloseButtonMouseOver; onMouseOut:onCloseButtonMouseOut; onClick:onCloseButtonClick'></span>" + "</div>" + "</div>", postMixInProperties:function () {
-	this.closeButtonStyle = this.closeButton ? "" : "display: none";
-	dojo.widget.TabButton.superclass.postMixInProperties.apply(this, arguments);
-}, fillInTemplate:function () {
-	dojo.html.disableSelection(this.titleNode);
-	dojo.widget.TabButton.superclass.fillInTemplate.apply(this, arguments);
-}, onCloseButtonClick:function (evt) {
-	evt.stopPropagation();
-	dojo.widget.TabButton.superclass.onCloseButtonClick.apply(this, arguments);
-}});
-dojo.widget.defineWidget("dojo.widget.a11y.TabButton", dojo.widget.TabButton, {imgPath:dojo.uri.moduleUri("dojo.widget", "templates/images/tab_close.gif"), templateString:"<div class='dojoTab' dojoAttachEvent='onClick;onKey'>" + "<div dojoAttachPoint='innerDiv'>" + "<span dojoAttachPoint='titleNode' tabIndex='-1' waiRole='tab'>${this.label}</span>" + "<img class='close' src='${this.imgPath}' alt='[x]' style='${this.closeButtonStyle}'" + "	dojoAttachEvent='onClick:onCloseButtonClick'>" + "</div>" + "</div>"});
-
+dojo.provide("dojo.widget.TabContainer");
+dojo.provide("dojo.widget.html.TabContainer");
+dojo.provide("dojo.widget.Tab");
+
+dojo.require("dojo.lang.func");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.event.*");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.html.layout");
+
+//////////////////////////////////////////
+// TabContainer -- a set of Tabs
+//////////////////////////////////////////
+dojo.widget.html.TabContainer = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.TabContainer, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.TabContainer, {
+	widgetType: "TabContainer",
+    isContainer: true,
+
+	// Constructor arguments
+	labelPosition: "top",
+	closeButton: "none",
+
+	useVisibility: false,		// true-->use visibility:hidden instead of display:none
+	
+	// if false, TabContainers size changes according to size of currently selected tab
+	doLayout: true,
+
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlTabContainer.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlTabContainer.css"),
+
+	selectedTab: "",		// initially selected tab (widgetId)
+
+	fillInTemplate: function(args, frag) {
+		// Copy style info from input node to output node
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+
+		dojo.widget.html.TabContainer.superclass.fillInTemplate.call(this, args, frag);
+	},
+
+	postCreate: function(args, frag) {
+		// Load all the tabs, creating a label for each one
+		for(var i=0; i<this.children.length; i++){
+			this._setupTab(this.children[i]);
+		}
+
+		if (this.closeButton=="pane") {
+			var div = document.createElement("div");
+			dojo.html.addClass(div, "dojoTabPanePaneClose");
+			var self = this;
+			dojo.event.connect(div, "onclick", function(){ self._runOnCloseTab(self.selectedTabWidget); });
+			dojo.event.connect(div, "onmouseover", function(){ dojo.html.addClass(div, "dojoTabPanePaneCloseHover"); });
+			dojo.event.connect(div, "onmouseout", function(){ dojo.html.removeClass(div, "dojoTabPanePaneCloseHover"); });
+			this.dojoTabLabels.appendChild(div);
+		}
+
+		if(this.doLayout){
+			dojo.html.addClass(this.dojoTabLabels, "dojoTabLabels-"+this.labelPosition);
+		} else {
+			dojo.html.addClass(this.dojoTabLabels, "dojoTabLabels-"+this.labelPosition+"-noLayout");
+		}
+
+        this._doSizing();
+
+		// Display the selected tab
+		if(this.selectedTabWidget){
+			this.selectTab(this.selectedTabWidget, true);
+		}
+	},
+
+	addChild: function(child, overrideContainerNode, pos, ref, insertIndex){
+		this._setupTab(child);
+		dojo.widget.html.TabContainer.superclass.addChild.call(this,child, overrideContainerNode, pos, ref, insertIndex);
+
+		// in case the tab labels have overflowed from one line to two lines
+		this._doSizing();
+	},
+
+	_setupTab: function(tab){
+		tab.domNode.style.display="none";
+
+		// Create label
+		tab.div = document.createElement("div");
+		dojo.widget.wai.setAttr(tab.div, "waiRole", "tab");
+		dojo.html.addClass(tab.div, "dojoTabPaneTab");
+		var span = document.createElement("span");
+		span.innerHTML = tab.label;
+		dojo.html.disableSelection(span);
+		if (this.closeButton=="tab") {
+			var img = document.createElement("div");
+			dojo.html.addClass(img, "dojoTabPaneTabClose");
+			var self = this;
+			dojo.event.connect(img, "onclick", function(evt){ self._runOnCloseTab(tab); dojo.event.browser.stopEvent(evt); });
+			dojo.event.connect(img, "onmouseover", function(){ dojo.html.addClass(img,"dojoTabPaneTabCloseHover"); });
+			dojo.event.connect(img, "onmouseout", function(){ dojo.html.removeClass(img,"dojoTabPaneTabCloseHover"); });
+			span.appendChild(img);
+		}
+		tab.div.appendChild(span);
+		this.dojoTabLabels.appendChild(tab.div);
+		
+		var self = this;
+		dojo.event.connect(tab.div, "onclick", function(){ self.selectTab(tab); });
+
+		if(!this.selectedTabWidget || this.selectedTab==tab.widgetId || tab.selected){
+    		this.selectedTabWidget = tab;
+        } else {
+            this._hideTab(tab);
+        }
+
+		dojo.html.addClass(tab.domNode, "dojoTabPane");
+		with(tab.domNode.style){
+			top = dojo.style.getPixelValue(this.containerNode, "padding-top", true);
+			left = dojo.style.getPixelValue(this.containerNode, "padding-left", true);
+		}
+	},
+
+	// Configure the content pane to take up all the space except for where the tab labels are
+	_doSizing: function(){
+		// position the labels and the container node
+		var labelAlign=this.labelPosition.replace(/-h/,"");
+		var children = [
+			{domNode: this.dojoTabLabels, layoutAlign: labelAlign},
+			{domNode: this.containerNode, layoutAlign: "client"}
+		];
+
+
+		if (this.doLayout) {
+			dojo.html.layout(this.domNode, children);
+		} 
+			
+		// size the current tab
+		// TODO: should have ptr to current tab rather than searching
+		var cw=dojo.style.getContentWidth(this.containerNode);
+		var ch=dojo.style.getContentHeight(this.containerNode);
+		dojo.lang.forEach(this.children, function(child){
+			//if (this.doLayout) {
+				if(child.selected){
+					child.resizeTo(cw, ch);
+				} 
+			//} else {
+			//	child.onResized();
+			//}
+		});
+		
+	},
+
+    removeChild: function(tab) {
+
+		// remove tab event handlers
+		dojo.event.disconnect(tab.div, "onclick", function () { });
+		if (this.closeButton=="tab") {
+			var img = tab.div.lastChild.lastChild;
+			if (img) {
+				dojo.html.removeClass(img, "dojoTabPaneTabClose", function () { });
+				dojo.event.disconnect(img, "onclick", function () { });
+				dojo.event.disconnect(img, "onmouseover", function () { });
+				dojo.event.disconnect(img, "onmouseout", function () { });
+			}
+		}
+
+        dojo.widget.html.TabContainer.superclass.removeChild.call(this, tab);
+
+        dojo.html.removeClass(tab.domNode, "dojoTabPane");
+        this.dojoTabLabels.removeChild(tab.div);
+        delete(tab.div);
+
+        if (this.selectedTabWidget === tab) {
+            this.selectedTabWidget = undefined;
+            if (this.children.length > 0) {
+                this.selectTab(this.children[0], true);
+            }
+        }
+
+		// in case the tab labels have overflowed from one line to two lines
+		this._doSizing();
+    },
+
+    selectTab: function(tab, _noRefresh) {
+		// Deselect old tab and select new one
+		if (this.selectedTabWidget) {
+			this._hideTab(this.selectedTabWidget);
+		}
+		this.selectedTabWidget = tab;
+		this._showTab(tab, _noRefresh);
+	},
+
+	_showTab: function(tab, _noRefresh) {
+		dojo.html.addClass(tab.div, "current");
+		tab.selected=true;
+		if ( this.useVisibility && !dojo.render.html.ie ) {
+			tab.domNode.style.visibility="visible";
+		} else {
+			// make sure we dont refresh onClose and on postCreate
+			// speeds up things a bit when using refreshOnShow and fixes #646
+			if(_noRefresh && tab.refreshOnShow){
+				var tmp = tab.refreshOnShow;
+				tab.refreshOnShow = false;
+				tab.show();
+				tab.refreshOnShow = tmp;
+			}else{
+				tab.show();
+			}
+
+			tab.resizeTo(
+				dojo.style.getContentWidth(this.containerNode),
+				dojo.style.getContentHeight(this.containerNode)
+			);
+		}
+	},
+
+	_hideTab: function(tab) {
+		dojo.html.removeClass(tab.div, "current");
+		tab.selected=false;
+		if( this.useVisibility ){
+			tab.domNode.style.visibility="hidden";
+		}else{
+			tab.hide();
+		}
+	},
+
+	_runOnCloseTab: function(tab) {
+		var onc = tab.extraArgs.onClose || tab.extraArgs.onclose;
+		var fcn = dojo.lang.isFunction(onc) ? onc : window[onc];
+		var remove = dojo.lang.isFunction(fcn) ? fcn(this,tab) : true;
+		if(remove) {
+			this.removeChild(tab);
+			// makes sure we can clean up executeScripts in ContentPane onUnLoad
+			tab.destroy();
+		}
+	},
+
+	onResized: function() {
+		this._doSizing();
+	}
+});
+dojo.widget.tags.addParseTreeHandler("dojo:TabContainer");
+
+// These arguments can be specified for the children of a TabContainer.
+// Since any widget can be specified as a TabContainer child, mix them
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	label: "",
+	selected: false	// is this tab currently selected?
+});

Modified: tags/parley-0.53/root/static/magic/src/widget/TaskBar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TaskBar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TaskBar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,42 +8,25 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.TaskBar");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.FloatingPane");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.selection");
-dojo.widget.defineWidget("dojo.widget.TaskBarItem", dojo.widget.HtmlWidget, {iconSrc:"", caption:"Untitled", templateString:"<div class=\"dojoTaskBarItem\" dojoAttachEvent=\"onClick\">\n</div>\n", templateCssString:".dojoTaskBarItem {\n\tdisplay: inline-block;\n\tbackground-color: ThreeDFace;\n\tborder: outset 2px;\n\tmargin-right: 5px;\n\tcursor: pointer;\n\theight: 35px;\n\twidth: 100px;\n\tfont-size: 10pt;\n\twhite-space: nowrap;\n\ttext-align: center;\n\tfloat: left;\n\toverflow: hidden;\n}\n\n.dojoTaskBarItem img {\n\tvertical-align: middle;\n\tmargin-right: 5px;\n\tmargin-left: 5px;\t\n\theight: 32px;\n\twidth: 32px;\n}\n\n.dojoTaskBarItem a {\n\t color: black;\n\ttext-decoration: none;\n}\n\n\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TaskBar.css"), fillInTemplate:function () {
-	if (this.iconSrc) {
-		var img = document.createElement("img");
-		img.src = this.iconSrc;
-		this.domNode.appendChild(img);
-	}
-	this.domNode.appendChild(document.createTextNode(this.caption));
-	dojo.html.disableSelection(this.domNode);
-}, postCreate:function () {
-	this.window = dojo.widget.getWidgetById(this.windowId);
-	this.window.explodeSrc = this.domNode;
-	dojo.event.connect(this.window, "destroy", this, "destroy");
-}, onClick:function () {
-	this.window.toggleDisplay();
-}});
-dojo.widget.defineWidget("dojo.widget.TaskBar", dojo.widget.FloatingPane, function () {
-	this._addChildStack = [];
-}, {resizable:false, titleBarDisplay:false, addChild:function (child) {
-	if (!this.containerNode) {
-		this._addChildStack.push(child);
-	} else {
-		if (this._addChildStack.length > 0) {
-			var oarr = this._addChildStack;
-			this._addChildStack = [];
-			dojo.lang.forEach(oarr, this.addChild, this);
-		}
-	}
-	var tbi = dojo.widget.createWidget("TaskBarItem", {windowId:child.widgetId, caption:child.title, iconSrc:child.iconSrc});
-	dojo.widget.TaskBar.superclass.addChild.call(this, tbi);
-}});
-
+dojo.provide("dojo.widget.TaskBar");
+dojo.provide("dojo.widget.TaskBarItem");
+dojo.require("dojo.widget.Widget");
+
+dojo.widget.TaskBar = function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = "TaskBar";
+	this.isContainer = true;
+}
+dojo.inherits(dojo.widget.TaskBar, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler("dojo:taskbar");
+
+dojo.widget.TaskBarItem = function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = "TaskBarItem";
+}
+dojo.inherits(dojo.widget.TaskBarItem, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler("dojo:taskbaritem");
+
+dojo.requireAfterIf("html", "dojo.widget.html.TaskBar");

Deleted: tags/parley-0.53/root/static/magic/src/widget/Textbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Textbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Textbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,52 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.Textbox");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.Manager");
-dojo.require("dojo.widget.Parse");
-dojo.require("dojo.xml.Parse");
-dojo.require("dojo.lang.array");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.i18n.common");
-dojo.requireLocalization("dojo.widget", "validate", null, "zh-cn,ja,ROOT,fr");
-dojo.widget.defineWidget("dojo.widget.Textbox", dojo.widget.HtmlWidget, {className:"", name:"", value:"", type:"", trim:false, uppercase:false, lowercase:false, ucFirst:false, digit:false, htmlfloat:"none", templateString:"<span style='float:${this.htmlfloat};'>\n\t<input dojoAttachPoint='textbox' dojoAttachEvent='onblur;onfocus'\n\t\tid='${this.widgetId}' name='${this.name}'\n\t\tclass='${this.className}' type='${this.type}' >\n</span>\n", textbox:null, fillInTemplate:function () {
-	this.textbox.value = this.value;
-}, filter:function () {
-	if (this.trim) {
-		this.textbox.value = this.textbox.value.replace(/(^\s*|\s*$)/g, "");
-	}
-	if (this.uppercase) {
-		this.textbox.value = this.textbox.value.toUpperCase();
-	}
-	if (this.lowercase) {
-		this.textbox.value = this.textbox.value.toLowerCase();
-	}
-	if (this.ucFirst) {
-		this.textbox.value = this.textbox.value.replace(/\b\w+\b/g, function (word) {
-			return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();
-		});
-	}
-	if (this.digit) {
-		this.textbox.value = this.textbox.value.replace(/\D/g, "");
-	}
-}, onfocus:function () {
-}, onblur:function () {
-	this.filter();
-}, mixInProperties:function (localProperties, frag) {
-	dojo.widget.Textbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties["class"]) {
-		this.className = localProperties["class"];
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TimePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TimePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TimePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,271 +8,75 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.TimePicker");
+dojo.provide("dojo.widget.TimePicker.util");
+dojo.require("dojo.widget.DomWidget");
+dojo.require("dojo.date");
 
+dojo.widget.TimePicker = function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = "TimePicker";
+	this.isContainer = false;
+	// the following aliases prevent breaking people using 0.2.x
+	this.toRfcDateTime = dojo.widget.TimePicker.util.toRfcDateTime;
+	this.fromRfcDateTime = dojo.widget.TimePicker.util.fromRfcDateTime;
+	this.toAmPmHour = dojo.widget.TimePicker.util.toAmPmHour;
+	this.fromAmPmHour = dojo.widget.TimePicker.util.fromAmPmHour;
+}
 
-dojo.provide("dojo.widget.TimePicker");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.event.*");
-dojo.require("dojo.date.serialize");
-dojo.require("dojo.date.format");
-dojo.require("dojo.dom");
-dojo.require("dojo.html.style");
-dojo.requireLocalization("dojo.i18n.calendar", "gregorian", null, "ko,zh-cn,zh,sv,ja,en,zh-tw,it,hu,nl,fi,zh-hk,fr,pt,ROOT,es,de,pt-br");
-dojo.requireLocalization("dojo.widget", "TimePicker", null, "ROOT");
-dojo.widget.defineWidget("dojo.widget.TimePicker", dojo.widget.HtmlWidget, function () {
-	this.time = "";
-	this.useDefaultTime = false;
-	this.useDefaultMinutes = false;
-	this.storedTime = "";
-	this.currentTime = {};
-	this.classNames = {selectedTime:"selectedItem"};
-	this.any = "any";
-	this.selectedTime = {hour:"", minute:"", amPm:"", anyTime:false};
-	this.hourIndexMap = ["", 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11, 0];
-	this.minuteIndexMap = [0, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11];
-}, {isContainer:false, templateString:"<div class=\"timePickerContainer\" dojoAttachPoint=\"timePickerContainerNode\">\n\t<table class=\"timeContainer\" cellspacing=\"0\" >\n\t\t<thead>\n\t\t\t<tr>\n\t\t\t\t<td class=\"timeCorner cornerTopLeft\" valign=\"top\">&nbsp;</td>\n\t\t\t\t<td class=\"timeLabelContainer hourSelector\">${this.calendar.field-hour}</td>\n\t\t\t\t<td class=\"timeLabelContainer minutesHeading\">${this.calendar.field-minute}</td>\n\t\t\t\t<td class=\"timeCorner cornerTopRight\" valign=\"top\">&nbsp;</td>\n\t\t\t</tr>\n\t\t</thead>\n\t\t<tbody>\n\t\t\t<tr>\n\t\t\t\t<td valign=\"top\" colspan=\"2\" class=\"hours\">\n\t\t\t\t\t<table align=\"center\">\n\t\t\t\t\t\t<tbody dojoAttachPoint=\"hourContainerNode\"  \n\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onSetSelectedHour;\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>12</td>\n\t\t\t\t\t\t\t\t<td>6</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>1</td>\n\t\t\t\t\t\t\t\t<td>7</td>\n\t\t\t\t\t\t\!
 t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>2</td>\n\t\t\t\t\t\t\t\t<td>8</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>3</td>\n\t\t\t\t\t\t\t\t<td>9</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>4</td>\n\t\t\t\t\t\t\t\t<td>10</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>5</td>\n\t\t\t\t\t\t\t\t<td>11</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t\t<td valign=\"top\" class=\"minutes\" colspan=\"2\">\n\t\t\t\t\t<table align=\"center\">\n\t\t\t\t\t\t<tbody dojoAttachPoint=\"minuteContainerNode\" \n\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onSetSelectedMinute;\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>00</td>\n\t\t\t\t\t\t\t\t<td>30</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>05</td>\n\t\t\t\t\t\t\t\t<td>35</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>10</td>\n\t\t\t\t\t\t\t\t<td>40</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t!
 \t<tr>\n\t\t\t\t\t\t\t\t<td>15</td>\n\t\t\t\t\t\t\t\t<td>45</t!
 d>\n\t\t
\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>20</td>\n\t\t\t\t\t\t\t\t<td>50</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td>25</td>\n\t\t\t\t\t\t\t\t<td>55</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td class=\"cornerBottomLeft\">&nbsp;</td>\n\t\t\t\t<td valign=\"top\" class=\"timeOptions\">\n\t\t\t\t\t<table class=\"amPmContainer\">\n\t\t\t\t\t\t<tbody dojoAttachPoint=\"amPmContainerNode\" \n\t\t\t\t\t\t\tdojoAttachEvent=\"onClick: onSetSelectedAmPm;\">\n\t\t\t\t\t\t\t<tr>\n\t\t\t\t\t\t\t\t<td id=\"am\">${this.calendar.am}</td>\n\t\t\t\t\t\t\t\t<td id=\"pm\">${this.calendar.pm}</td>\n\t\t\t\t\t\t\t</tr>\n\t\t\t\t\t\t</tbody>\n\t\t\t\t\t</table>\n\t\t\t\t</td>\n\t\t\t\t<td class=\"timeOptions\">\n\t\t\t\t\t<div dojoAttachPoint=\"anyTimeContainerNode\" \n\t\t\t\t\t\tdojoAttachEvent=\"onClick: onSetSelectedAnyTime;\" \n\t\t\t\t\t\tclass=\"anyTimeContainer\">${this.widgetSt!
 rings.any}</div>\n\t\t\t\t</td>\n\t\t\t\t<td class=\"cornerBottomRight\">&nbsp;</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n</div>\n", templateCssString:"/*Time Picker */\n.timePickerContainer {\n\twidth:122px;\n\tfont-family:Tahoma, Myriad, Helvetica, Arial, Verdana, sans-serif;\n\tfont-size:16px;\n}\n\n.timeContainer {\n\tborder-collapse:collapse;\n\tborder-spacing:0;\n}\n\n.timeContainer thead {\n\tcolor:#293a4b;\n\tfont-size:0.9em;\n\tfont-weight:700;\n}\n\n.timeContainer thead td {\n\tpadding:0.25em;\n\tfont-size:0.80em;\n\tborder-bottom:1px solid #6782A8;\n}\n\n.timeCorner {\n\twidth:10px;\n}\n\n.cornerTopLeft {\n\tbackground: url(\"images/dpCurveTL.png\") top left no-repeat;\n}\n\n.cornerTopRight {\n\tbackground: url(\"images/dpCurveTR.png\") top right no-repeat;\n}\n\n.timeLabelContainer {\n\tbackground: url(\"images/dpMonthBg.png\") top left repeat-x;\n}\n\n.hours, .minutes, .timeBorder {\n\tbackground: #7591bc url(\"images/dpBg.gif\") top left repeat-x;\n\n}\n\n.!
 hours td, .minutes td {\n\tpadding:0.2em;\n\ttext-align:center!
 ;\n\tfon
t-size:0.7em;\n\tfont-weight:bold;\n\tcursor:pointer;\n\tcursor:hand;\n\tcolor:#fff;\n}\n\n.minutes {\n\tborder-left:1px solid #f5d1db;\n}\n\n.hours {\n\tborder-right:1px solid #6782A8;\n}\n\n.hourSelector {\n\tborder-right:1px solid #6782A8;\n\tpadding:5px;\n\tpadding-right:10px;\n}\n\n.minutesSelector {\n\tpadding:5px;\n\tborder-left:1px solid #f5c7d4;\n\ttext-align:center;\n}\n\n.minutesHeading {\n\tpadding-left:9px !important;\n}\n\n.timeOptions {\n\tbackground-color:#F9C9D7;\n}\n\n.timeContainer .cornerBottomLeft, .timeContainer .cornerBottomRight, .timeContainer .timeOptions {\n\tborder-top:1px solid #6782A8;\n}\n\n.timeContainer .cornerBottomLeft {\n\tbackground: url(\"images/dpCurveBL.png\") bottom left no-repeat !important;\n\twidth:9px !important;\n\tpadding:0;\n\tmargin:0;\n}\n\n.timeContainer .cornerBottomRight {\n\tbackground: url(\"images/dpCurveBR.png\") bottom right no-repeat !important;\n\twidth:9px !important;\n\tpadding:0;\n\tmargin:0;\n}\n\n.timeOptions {!
 \n\tcolor:#fff;\n\tbackground:url(\"images/dpYearBg.png\") top left repeat-x;\n\n}\n\n.selectedItem {\n\tbackground-color:#fff;\n\tcolor:#6782a8 !important;\n}\n\n.timeOptions .selectedItem {\n\tcolor:#fff !important;\n\tbackground-color:#9ec3fb !important;\n}\n\n.anyTimeContainer {\n\ttext-align:center;\n\tfont-weight:bold;\n\tfont-size:0.7em;\n\tpadding:0.1em;\n\tcursor:pointer;\n\tcursor:hand;\n\tcolor:#fff !important;\n}\n\n.amPmContainer {\n\twidth:100%;\n}\n\n.amPmContainer td {\n\ttext-align:center;\n\tfont-size:0.7em;\n\tfont-weight:bold;\n\tcursor:pointer;\n\tcursor:hand;\n\tcolor:#fff;\n}\n\n\n\n/*.timePickerContainer {\n\tmargin:1.75em 0 0.5em 0;\n\twidth:10em;\n\tfloat:left;\n}\n\n.timeContainer {\n\tborder-collapse:collapse;\n\tborder-spacing:0;\n}\n\n.timeContainer thead td{\n\tborder-bottom:1px solid #e6e6e6;\n\tpadding:0 0.4em 0.2em 0.4em;\n}\n\n.timeContainer td {\n\tfont-size:0.9em;\n\tpadding:0 0.25em 0 0.25em;\n\ttext-align:left;\n\tcursor:pointer;cursor!
 :hand;\n}\n\n.timeContainer td.minutesHeading {\n\tborder-left!
 :1px sol
id #e6e6e6;\n\tborder-right:1px solid #e6e6e6;\t\n}\n\n.timeContainer .minutes {\n\tborder-left:1px solid #e6e6e6;\n\tborder-right:1px solid #e6e6e6;\n}\n\n.selectedItem {\n\tbackground-color:#3a3a3a;\n\tcolor:#ffffff;\n}*/\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TimePicker.css"), postMixInProperties:function (localProperties, frag) {
-	dojo.widget.TimePicker.superclass.postMixInProperties.apply(this, arguments);
-	this.calendar = dojo.i18n.getLocalization("dojo.i18n.calendar", "gregorian", this.lang);
-	this.widgetStrings = dojo.i18n.getLocalization("dojo.widget", "TimePicker", this.lang);
-}, fillInTemplate:function (args, frag) {
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-	if (args.value) {
-		if (args.value instanceof Date) {
-			this.storedTime = dojo.date.toRfc3339(args.value);
-		} else {
-			this.storedTime = args.value;
-		}
-	}
-	this.initData();
-	this.initUI();
-}, initData:function () {
-	if (this.storedTime.indexOf("T") != -1 && this.storedTime.split("T")[1] && this.storedTime != " " && this.storedTime.split("T")[1] != "any") {
-		this.time = dojo.widget.TimePicker.util.fromRfcDateTime(this.storedTime, this.useDefaultMinutes, this.selectedTime.anyTime);
-	} else {
-		if (this.useDefaultTime) {
-			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", this.useDefaultMinutes, this.selectedTime.anyTime);
-		} else {
-			this.selectedTime.anyTime = true;
-			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", 0, 1);
-		}
-	}
-}, initUI:function () {
-	if (!this.selectedTime.anyTime && this.time) {
-		var amPmHour = dojo.widget.TimePicker.util.toAmPmHour(this.time.getHours());
-		var hour = amPmHour[0];
-		var isAm = amPmHour[1];
-		var minute = this.time.getMinutes();
-		var minuteIndex = parseInt(minute / 5);
-		this.onSetSelectedHour(this.hourIndexMap[hour]);
-		this.onSetSelectedMinute(this.minuteIndexMap[minuteIndex]);
-		this.onSetSelectedAmPm(isAm);
-	} else {
-		this.onSetSelectedAnyTime();
-	}
-}, setTime:function (date) {
-	if (date) {
-		this.selectedTime.anyTime = false;
-		this.setDateTime(dojo.date.toRfc3339(date));
-	} else {
-		this.selectedTime.anyTime = true;
-	}
-	this.initData();
-	this.initUI();
-}, setDateTime:function (rfcDate) {
-	this.storedTime = rfcDate;
-}, onClearSelectedHour:function (evt) {
-	this.clearSelectedHour();
-}, onClearSelectedMinute:function (evt) {
-	this.clearSelectedMinute();
-}, onClearSelectedAmPm:function (evt) {
-	this.clearSelectedAmPm();
-}, onClearSelectedAnyTime:function (evt) {
-	this.clearSelectedAnyTime();
-	if (this.selectedTime.anyTime) {
-		this.selectedTime.anyTime = false;
-		this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", this.useDefaultMinutes);
-		this.initUI();
-	}
-}, clearSelectedHour:function () {
-	var hourNodes = this.hourContainerNode.getElementsByTagName("td");
-	for (var i = 0; i < hourNodes.length; i++) {
-		dojo.html.setClass(hourNodes.item(i), "");
-	}
-}, clearSelectedMinute:function () {
-	var minuteNodes = this.minuteContainerNode.getElementsByTagName("td");
-	for (var i = 0; i < minuteNodes.length; i++) {
-		dojo.html.setClass(minuteNodes.item(i), "");
-	}
-}, clearSelectedAmPm:function () {
-	var amPmNodes = this.amPmContainerNode.getElementsByTagName("td");
-	for (var i = 0; i < amPmNodes.length; i++) {
-		dojo.html.setClass(amPmNodes.item(i), "");
-	}
-}, clearSelectedAnyTime:function () {
-	dojo.html.setClass(this.anyTimeContainerNode, "anyTimeContainer");
-}, onSetSelectedHour:function (evt) {
-	this.onClearSelectedAnyTime();
-	this.onClearSelectedHour();
-	this.setSelectedHour(evt);
-	this.onSetTime();
-}, setSelectedHour:function (evt) {
-	if (evt && evt.target) {
-		if (evt.target.nodeType == dojo.dom.ELEMENT_NODE) {
-			var eventTarget = evt.target;
-		} else {
-			var eventTarget = evt.target.parentNode;
-		}
-		dojo.event.browser.stopEvent(evt);
-		dojo.html.setClass(eventTarget, this.classNames.selectedTime);
-		this.selectedTime["hour"] = eventTarget.innerHTML;
-	} else {
-		if (!isNaN(evt)) {
-			var hourNodes = this.hourContainerNode.getElementsByTagName("td");
-			if (hourNodes.item(evt)) {
-				dojo.html.setClass(hourNodes.item(evt), this.classNames.selectedTime);
-				this.selectedTime["hour"] = hourNodes.item(evt).innerHTML;
-			}
-		}
-	}
-	this.selectedTime.anyTime = false;
-}, onSetSelectedMinute:function (evt) {
-	this.onClearSelectedAnyTime();
-	this.onClearSelectedMinute();
-	this.setSelectedMinute(evt);
-	this.selectedTime.anyTime = false;
-	this.onSetTime();
-}, setSelectedMinute:function (evt) {
-	if (evt && evt.target) {
-		if (evt.target.nodeType == dojo.dom.ELEMENT_NODE) {
-			var eventTarget = evt.target;
-		} else {
-			var eventTarget = evt.target.parentNode;
-		}
-		dojo.event.browser.stopEvent(evt);
-		dojo.html.setClass(eventTarget, this.classNames.selectedTime);
-		this.selectedTime["minute"] = eventTarget.innerHTML;
-	} else {
-		if (!isNaN(evt)) {
-			var minuteNodes = this.minuteContainerNode.getElementsByTagName("td");
-			if (minuteNodes.item(evt)) {
-				dojo.html.setClass(minuteNodes.item(evt), this.classNames.selectedTime);
-				this.selectedTime["minute"] = minuteNodes.item(evt).innerHTML;
-			}
-		}
-	}
-}, onSetSelectedAmPm:function (evt) {
-	this.onClearSelectedAnyTime();
-	this.onClearSelectedAmPm();
-	this.setSelectedAmPm(evt);
-	this.selectedTime.anyTime = false;
-	this.onSetTime();
-}, setSelectedAmPm:function (evt) {
-	var eventTarget = evt.target;
-	if (evt && eventTarget) {
-		if (eventTarget.nodeType != dojo.dom.ELEMENT_NODE) {
-			eventTarget = eventTarget.parentNode;
-		}
-		dojo.event.browser.stopEvent(evt);
-		this.selectedTime.amPm = eventTarget.id;
-		dojo.html.setClass(eventTarget, this.classNames.selectedTime);
-	} else {
-		evt = evt ? 0 : 1;
-		var amPmNodes = this.amPmContainerNode.getElementsByTagName("td");
-		if (amPmNodes.item(evt)) {
-			this.selectedTime.amPm = amPmNodes.item(evt).id;
-			dojo.html.setClass(amPmNodes.item(evt), this.classNames.selectedTime);
-		}
-	}
-}, onSetSelectedAnyTime:function (evt) {
-	this.onClearSelectedHour();
-	this.onClearSelectedMinute();
-	this.onClearSelectedAmPm();
-	this.setSelectedAnyTime();
-	this.onSetTime();
-}, setSelectedAnyTime:function (evt) {
-	this.selectedTime.anyTime = true;
-	dojo.html.setClass(this.anyTimeContainerNode, this.classNames.selectedTime + " " + "anyTimeContainer");
-}, onClick:function (evt) {
-	dojo.event.browser.stopEvent(evt);
-}, onSetTime:function () {
-	if (this.selectedTime.anyTime) {
-		this.time = new Date();
-		var tempDateTime = dojo.widget.TimePicker.util.toRfcDateTime(this.time);
-		this.setDateTime(tempDateTime.split("T")[0]);
-	} else {
-		var hour = 12;
-		var minute = 0;
-		var isAm = false;
-		if (this.selectedTime["hour"]) {
-			hour = parseInt(this.selectedTime["hour"], 10);
-		}
-		if (this.selectedTime["minute"]) {
-			minute = parseInt(this.selectedTime["minute"], 10);
-		}
-		if (this.selectedTime["amPm"]) {
-			isAm = (this.selectedTime["amPm"].toLowerCase() == "am");
-		}
-		this.time = new Date();
-		this.time.setHours(dojo.widget.TimePicker.util.fromAmPmHour(hour, isAm));
-		this.time.setMinutes(minute);
-		this.setDateTime(dojo.widget.TimePicker.util.toRfcDateTime(this.time));
-	}
-	this.onValueChanged(this.time);
-}, onValueChanged:function (date) {
-}});
-dojo.widget.TimePicker.util = new function () {
-	this.toRfcDateTime = function (jsDate) {
-		if (!jsDate) {
+dojo.inherits(dojo.widget.TimePicker, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler("dojo:timepicker");
+
+dojo.requireAfterIf("html", "dojo.widget.html.TimePicker");
+
+dojo.widget.TimePicker.util = new function() {
+	// utility functions
+	this.toRfcDateTime = function(jsDate) {
+		if(!jsDate) {
 			jsDate = new Date();
 		}
-		jsDate.setSeconds(0);
-		return dojo.date.strftime(jsDate, "%Y-%m-%dT%H:%M:00%z");
-	};
-	this.fromRfcDateTime = function (rfcDate, useDefaultMinutes, isAnyTime) {
+		return dojo.date.format(jsDate, "%Y-%m-%dT%H:%M:00%z");
+	}
+
+	this.fromRfcDateTime = function(rfcDate, useDefaultMinutes, isAnyTime) {
 		var tempDate = new Date();
-		if (!rfcDate || rfcDate.indexOf("T") == -1) {
-			if (useDefaultMinutes) {
-				tempDate.setMinutes(Math.floor(tempDate.getMinutes() / 5) * 5);
+		if(!rfcDate || rfcDate.indexOf("T")==-1) {
+			if(useDefaultMinutes) {
+				tempDate.setMinutes(Math.floor(tempDate.getMinutes()/5)*5);
 			} else {
 				tempDate.setMinutes(0);
 			}
 		} else {
 			var tempTime = rfcDate.split("T")[1].split(":");
+			// fullYear, month, date
 			var tempDate = new Date();
 			tempDate.setHours(tempTime[0]);
 			tempDate.setMinutes(tempTime[1]);
 		}
 		return tempDate;
-	};
-	this.toAmPmHour = function (hour) {
+	}
+
+	this.toAmPmHour = function(hour) {
 		var amPmHour = hour;
 		var isAm = true;
 		if (amPmHour == 0) {
 			amPmHour = 12;
-		} else {
-			if (amPmHour > 12) {
-				amPmHour = amPmHour - 12;
-				isAm = false;
-			} else {
-				if (amPmHour == 12) {
-					isAm = false;
-				}
-			}
+		} else if (amPmHour>12) {
+			amPmHour = amPmHour - 12;
+			isAm = false;
+		} else if (amPmHour == 12) {
+			isAm = false;
 		}
 		return [amPmHour, isAm];
-	};
-	this.fromAmPmHour = function (amPmHour, isAm) {
+	}
+
+	this.fromAmPmHour = function(amPmHour, isAm) {
 		var hour = parseInt(amPmHour, 10);
-		if (isAm && hour == 12) {
+		if(isAm && hour == 12) {
 			hour = 0;
-		} else {
-			if (!isAm && hour < 12) {
-				hour = hour + 12;
-			}
+		} else if (!isAm && hour<12) {
+			hour = hour + 12;
 		}
 		return hour;
-	};
-};
-
+	}
+}

Modified: tags/parley-0.53/root/static/magic/src/widget/TitlePane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TitlePane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TitlePane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,36 +8,5 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.TitlePane");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.ContentPane");
-dojo.require("dojo.html.style");
-dojo.require("dojo.lfx.*");
-dojo.widget.defineWidget("dojo.widget.TitlePane", dojo.widget.ContentPane, {labelNodeClass:"", containerNodeClass:"", label:"", open:true, templateString:"<div dojoAttachPoint=\"domNode\">\n<div dojoAttachPoint=\"labelNode\" dojoAttachEvent=\"onclick: onLabelClick\"></div>\n<div dojoAttachPoint=\"containerNode\"></div>\n</div>\n", postCreate:function () {
-	if (this.label) {
-		this.labelNode.appendChild(document.createTextNode(this.label));
-	}
-	if (this.labelNodeClass) {
-		dojo.html.addClass(this.labelNode, this.labelNodeClass);
-	}
-	if (this.containerNodeClass) {
-		dojo.html.addClass(this.containerNode, this.containerNodeClass);
-	}
-	if (!this.open) {
-		dojo.html.hide(this.containerNode);
-	}
-	dojo.widget.TitlePane.superclass.postCreate.apply(this, arguments);
-}, onLabelClick:function () {
-	if (this.open) {
-		dojo.lfx.wipeOut(this.containerNode, 250).play();
-		this.open = false;
-	} else {
-		dojo.lfx.wipeIn(this.containerNode, 250).play();
-		this.open = true;
-	}
-}, setLabel:function (label) {
-	this.labelNode.innerHTML = label;
-}});
-
+dojo.requireAfterIf("html", "dojo.widget.html.TitlePane");

Deleted: tags/parley-0.53/root/static/magic/src/widget/Toaster.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Toaster.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Toaster.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,163 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.Toaster");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.lfx.*");
-dojo.require("dojo.html.iframe");
-dojo.widget.defineWidget("dojo.widget.Toaster", dojo.widget.HtmlWidget, {templateString:"<div dojoAttachPoint=\"clipNode\"><div dojoAttachPoint=\"containerNode\" dojoAttachEvent=\"onClick:onSelect\"><div dojoAttachPoint=\"contentNode\"></div></div></div>", templateCssString:".dojoToasterClip {\n\tposition: absolute;\n\toverflow: hidden;\n}\n\n.dojoToasterContainer {\n\tdisplay: block;\n\tposition: absolute;\n\twidth: 17.5em;\n\tz-index: 5000;\n\tmargin: 0px;\n\tfont:0.75em Tahoma, Helvetica, Verdana, Arial;\n}\n\n.dojoToasterContent{\n\tpadding:1em;\n\tpadding-top:0.25em;\n\tbackground:#73c74a;\n}\n\n.dojoToasterMessage{ \n\tcolor:#fff;\n}\n.dojoToasterWarning{ }\n.dojoToasterError,\n.dojoToasterFatal{\n\tfont-weight:bold;\n\tcolor:#fff;\n}\n\n\n.dojoToasterWarning .dojoToasterContent{\n\tpadding:1em;\n\tpadding-top:0.25em;\n\tbackground:#d4d943;\n} \n\n.dojoToasterError .dojoToasterContent{\n\tpadding:1em;\n\tpadding-top:0.25em;\n\tbackground:#c46600;\n} \n", templateCssPa!
 th:dojo.uri.moduleUri("dojo.widget", "templates/Toaster.css"), messageTopic:"", messageTypes:{MESSAGE:"MESSAGE", WARNING:"WARNING", ERROR:"ERROR", FATAL:"FATAL"}, defaultType:"MESSAGE", clipCssClass:"dojoToasterClip", containerCssClass:"dojoToasterContainer", contentCssClass:"dojoToasterContent", messageCssClass:"dojoToasterMessage", warningCssClass:"dojoToasterWarning", errorCssClass:"dojoToasterError", fatalCssClass:"dojoToasterFatal", positionDirection:"br-up", positionDirectionTypes:["br-up", "br-left", "bl-up", "bl-right", "tr-down", "tr-left", "tl-down", "tl-right"], showDelay:2000, postCreate:function () {
-	this.hide();
-	dojo.html.setClass(this.clipNode, this.clipCssClass);
-	dojo.html.addClass(this.containerNode, this.containerCssClass);
-	dojo.html.setClass(this.contentNode, this.contentCssClass);
-	if (this.messageTopic) {
-		dojo.event.topic.subscribe(this.messageTopic, this, "_handleMessage");
-	}
-	if (!this.positionDirection || !dojo.lang.inArray(this.positionDirectionTypes, this.positionDirection)) {
-		this.positionDirection = this.positionDirectionTypes.BRU;
-	}
-}, _handleMessage:function (msg) {
-	if (dojo.lang.isString(msg)) {
-		this.setContent(msg);
-	} else {
-		this.setContent(msg["message"], msg["type"], msg["delay"]);
-	}
-}, setContent:function (msg, messageType, delay) {
-	var delay = delay || this.showDelay;
-	if (this.slideAnim && this.slideAnim.status() == "playing") {
-		dojo.lang.setTimeout(50, dojo.lang.hitch(this, function () {
-			this.setContent(msg, messageType);
-		}));
-		return;
-	} else {
-		if (this.slideAnim) {
-			this.slideAnim.stop();
-			if (this.fadeAnim) {
-				this.fadeAnim.stop();
-			}
-		}
-	}
-	if (!msg) {
-		dojo.debug(this.widgetId + ".setContent() incoming content was null, ignoring.");
-		return;
-	}
-	if (!this.positionDirection || !dojo.lang.inArray(this.positionDirectionTypes, this.positionDirection)) {
-		dojo.raise(this.widgetId + ".positionDirection is an invalid value: " + this.positionDirection);
-	}
-	dojo.html.removeClass(this.containerNode, this.messageCssClass);
-	dojo.html.removeClass(this.containerNode, this.warningCssClass);
-	dojo.html.removeClass(this.containerNode, this.errorCssClass);
-	dojo.html.removeClass(this.containerNode, this.fatalCssClass);
-	dojo.html.clearOpacity(this.containerNode);
-	if (msg instanceof String || typeof msg == "string") {
-		this.contentNode.innerHTML = msg;
-	} else {
-		if (dojo.html.isNode(msg)) {
-			this.contentNode.innerHTML = dojo.html.getContentAsString(msg);
-		} else {
-			dojo.raise("Toaster.setContent(): msg is of unknown type:" + msg);
-		}
-	}
-	switch (messageType) {
-	  case this.messageTypes.WARNING:
-		dojo.html.addClass(this.containerNode, this.warningCssClass);
-		break;
-	  case this.messageTypes.ERROR:
-		dojo.html.addClass(this.containerNode, this.errorCssClass);
-		break;
-	  case this.messageTypes.FATAL:
-		dojo.html.addClass(this.containerNode, this.fatalCssClass);
-		break;
-	  case this.messageTypes.MESSAGE:
-	  default:
-		dojo.html.addClass(this.containerNode, this.messageCssClass);
-		break;
-	}
-	this.show();
-	var nodeSize = dojo.html.getMarginBox(this.containerNode);
-	if (this.positionDirection.indexOf("-up") >= 0) {
-		this.containerNode.style.left = 0 + "px";
-		this.containerNode.style.top = nodeSize.height + 10 + "px";
-	} else {
-		if (this.positionDirection.indexOf("-left") >= 0) {
-			this.containerNode.style.left = nodeSize.width + 10 + "px";
-			this.containerNode.style.top = 0 + "px";
-		} else {
-			if (this.positionDirection.indexOf("-right") >= 0) {
-				this.containerNode.style.left = 0 - nodeSize.width - 10 + "px";
-				this.containerNode.style.top = 0 + "px";
-			} else {
-				if (this.positionDirection.indexOf("-down") >= 0) {
-					this.containerNode.style.left = 0 + "px";
-					this.containerNode.style.top = 0 - nodeSize.height - 10 + "px";
-				} else {
-					dojo.raise(this.widgetId + ".positionDirection is an invalid value: " + this.positionDirection);
-				}
-			}
-		}
-	}
-	this.slideAnim = dojo.lfx.html.slideTo(this.containerNode, {top:0, left:0}, 450, null, dojo.lang.hitch(this, function (nodes, anim) {
-		dojo.lang.setTimeout(dojo.lang.hitch(this, function (evt) {
-			if (this.bgIframe) {
-				this.bgIframe.hide();
-			}
-			this.fadeAnim = dojo.lfx.html.fadeOut(this.containerNode, 1000, null, dojo.lang.hitch(this, function (evt) {
-				this.hide();
-			})).play();
-		}), delay);
-	})).play();
-}, _placeClip:function () {
-	var scroll = dojo.html.getScroll();
-	var view = dojo.html.getViewport();
-	var nodeSize = dojo.html.getMarginBox(this.containerNode);
-	this.clipNode.style.height = nodeSize.height + "px";
-	this.clipNode.style.width = nodeSize.width + "px";
-	if (this.positionDirection.match(/^t/)) {
-		this.clipNode.style.top = scroll.top + "px";
-	} else {
-		if (this.positionDirection.match(/^b/)) {
-			this.clipNode.style.top = (view.height - nodeSize.height - 2 + scroll.top) + "px";
-		}
-	}
-	if (this.positionDirection.match(/^[tb]r-/)) {
-		this.clipNode.style.left = (view.width - nodeSize.width - 1 - scroll.left) + "px";
-	} else {
-		if (this.positionDirection.match(/^[tb]l-/)) {
-			this.clipNode.style.left = 0 + "px";
-		}
-	}
-	this.clipNode.style.clip = "rect(0px, " + nodeSize.width + "px, " + nodeSize.height + "px, 0px)";
-	if (dojo.render.html.ie) {
-		if (!this.bgIframe) {
-			this.bgIframe = new dojo.html.BackgroundIframe(this.containerNode);
-			this.bgIframe.setZIndex(this.containerNode);
-		}
-		this.bgIframe.onResized();
-		this.bgIframe.show();
-	}
-}, onSelect:function (e) {
-}, show:function () {
-	dojo.widget.Toaster.superclass.show.call(this);
-	this._placeClip();
-	if (!this._scrollConnected) {
-		this._scrollConnected = true;
-		dojo.event.connect(window, "onscroll", this, "_placeClip");
-	}
-}, hide:function () {
-	dojo.widget.Toaster.superclass.hide.call(this);
-	if (this._scrollConnected) {
-		this._scrollConnected = false;
-		dojo.event.disconnect(window, "onscroll", this, "_placeClip");
-	}
-	dojo.html.setOpacity(this.containerNode, 1);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/Toggler.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Toggler.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Toggler.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,19 +8,33 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.Toggler");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.event.*");
-dojo.widget.defineWidget("dojo.widget.Toggler", dojo.widget.HtmlWidget, {targetId:"", fillInTemplate:function () {
-	dojo.event.connect(this.domNode, "onclick", this, "onClick");
-}, onClick:function () {
-	var pane = dojo.widget.byId(this.targetId);
-	if (!pane) {
-		return;
-	}
-	pane.explodeSrc = this.domNode;
-	pane.toggleShowing();
-}});
-
+dojo.provide("dojo.widget.Toggler");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.event.*");
+
+// clicking on this node shows/hides another widget
+
+dojo.widget.Toggler = function(){
+	dojo.widget.DomWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.Toggler, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.Toggler, {
+	widgetType: "Toggler",
+	
+	// Associated widget 
+	targetId: '',
+	
+	fillInTemplate: function() {
+		dojo.event.connect(this.domNode, "onclick", this, "onClick");
+	},
+	
+	onClick: function() {
+		var pane = dojo.widget.byId(this.targetId);
+		if(!pane){ return; }
+		pane.explodeSrc = this.domNode;
+		pane.toggleShowing();
+	}
+});
+dojo.widget.tags.addParseTreeHandler("dojo:toggler");

Modified: tags/parley-0.53/root/static/magic/src/widget/Toolbar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Toolbar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Toolbar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,717 +8,928 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.ToolbarContainer");
+dojo.provide("dojo.widget.html.ToolbarContainer");
+dojo.provide("dojo.widget.Toolbar");
+dojo.provide("dojo.widget.html.Toolbar");
+dojo.provide("dojo.widget.ToolbarItem");
+dojo.provide("dojo.widget.html.ToolbarButtonGroup");
+dojo.provide("dojo.widget.html.ToolbarButton");
+dojo.provide("dojo.widget.html.ToolbarDialog");
+dojo.provide("dojo.widget.html.ToolbarMenu");
+dojo.provide("dojo.widget.html.ToolbarSeparator");
+dojo.provide("dojo.widget.html.ToolbarSpace");
+dojo.provide("dojo.widget.Icon");
 
+dojo.require("dojo.widget.*");
+dojo.require("dojo.html");
 
-dojo.provide("dojo.widget.Toolbar");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.html.style");
-dojo.widget.defineWidget("dojo.widget.ToolbarContainer", dojo.widget.HtmlWidget, {isContainer:true, templateString:"<div class=\"toolbarContainer\" dojoAttachPoint=\"containerNode\"></div>", templateCssString:".toolbarContainer {\n\tborder-bottom : 0;\n\tbackground-color : #def;\n\tcolor : ButtonText;\n\tfont : Menu;\n\tbackground-image: url(images/toolbar-bg.gif);\n}\n\n.toolbar {\n\tpadding : 2px 4px;\n\tmin-height : 26px;\n\t_height : 26px;\n}\n\n.toolbarItem {\n\tfloat : left;\n\tpadding : 1px 2px;\n\tmargin : 0 2px 1px 0;\n\tcursor : pointer;\n}\n\n.toolbarItem.selected, .toolbarItem.down {\n\tmargin : 1px 1px 0 1px;\n\tpadding : 0px 1px;\n\tborder : 1px solid #bbf;\n\tbackground-color : #fafaff;\n}\n\n.toolbarButton img {\n\tvertical-align : bottom;\n}\n\n.toolbarButton span {\n\tline-height : 16px;\n\tvertical-align : middle;\n}\n\n.toolbarButton.hover {\n\tpadding : 0px 1px;\n\tborder : 1px solid #99c;\n}\n\n.toolbarItem.disabled {\n\topacity : 0.3;\n\tfilter : alph!
 a(opacity=30);\n\tcursor : default;\n}\n\n.toolbarSeparator {\n\tcursor : default;\n}\n\n.toolbarFlexibleSpace {\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Toolbar.css"), getItem:function (name) {
-	if (name instanceof dojo.widget.ToolbarItem) {
-		return name;
-	}
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			var item = child.getItem(name);
-			if (item) {
-				return item;
+/* ToolbarContainer
+ *******************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarContainer");
+dojo.widget.html.ToolbarContainer = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarContainer, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.html.ToolbarContainer, {
+	widgetType: "ToolbarContainer",
+	isContainer: true,
+
+	templateString: '<div class="toolbarContainer" dojoAttachPoint="containerNode"></div>',
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlToolbar.css"),
+
+	getItem: function(name) {
+		if(name instanceof dojo.widget.ToolbarItem) { return name; }
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				var item = child.getItem(name);
+				if(item) { return item; }
 			}
 		}
-	}
-	return null;
-}, getItems:function () {
-	var items = [];
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			items = items.concat(child.getItems());
+		return null;
+	},
+
+	getItems: function() {
+		var items = [];
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				items = items.concat(child.getItems());
+			}
 		}
-	}
-	return items;
-}, enable:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			child.enable.apply(child, arguments);
+		return items;
+	},
+
+	enable: function() {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.enable.apply(child, arguments);
+			}
 		}
-	}
-}, disable:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			child.disable.apply(child, arguments);
+	},
+
+	disable: function() {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.disable.apply(child, arguments);
+			}
 		}
-	}
-}, select:function (name) {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			child.select(arguments);
+	},
+
+	select: function(name) {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.select(arguments);
+			}
 		}
-	}
-}, deselect:function (name) {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			child.deselect(arguments);
+	},
+
+	deselect: function(name) {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.deselect(arguments);
+			}
 		}
-	}
-}, getItemsState:function () {
-	var values = {};
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			dojo.lang.mixin(values, child.getItemsState());
+	},
+
+	getItemsState: function() {
+		var values = {};
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				dojo.lang.mixin(values, child.getItemsState());
+			}
 		}
-	}
-	return values;
-}, getItemsActiveState:function () {
-	var values = {};
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			dojo.lang.mixin(values, child.getItemsActiveState());
+		return values;
+	},
+
+	getItemsActiveState: function() {
+		var values = {};
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				dojo.lang.mixin(values, child.getItemsActiveState());
+			}
 		}
-	}
-	return values;
-}, getItemsSelectedState:function () {
-	var values = {};
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.Toolbar) {
-			dojo.lang.mixin(values, child.getItemsSelectedState());
+		return values;
+	},
+
+	getItemsSelectedState: function() {
+		var values = {};
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				dojo.lang.mixin(values, child.getItemsSelectedState());
+			}
 		}
+		return values;
 	}
-	return values;
-}});
-dojo.widget.defineWidget("dojo.widget.Toolbar", dojo.widget.HtmlWidget, {isContainer:true, templateString:"<div class=\"toolbar\" dojoAttachPoint=\"containerNode\" unselectable=\"on\" dojoOnMouseover=\"_onmouseover\" dojoOnMouseout=\"_onmouseout\" dojoOnClick=\"_onclick\" dojoOnMousedown=\"_onmousedown\" dojoOnMouseup=\"_onmouseup\"></div>", _getItem:function (node) {
-	var start = new Date();
-	var widget = null;
-	while (node && node != this.domNode) {
-		if (dojo.html.hasClass(node, "toolbarItem")) {
-			var widgets = dojo.widget.manager.getWidgetsByFilter(function (w) {
-				return w.domNode == node;
-			});
-			if (widgets.length == 1) {
-				widget = widgets[0];
-				break;
-			} else {
-				if (widgets.length > 1) {
+});
+
+/* Toolbar
+ **********/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbar");
+dojo.widget.html.Toolbar = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.Toolbar, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.html.Toolbar, {
+	widgetType: "Toolbar",
+	isContainer: true,
+
+	templateString: '<div class="toolbar" dojoAttachPoint="containerNode" unselectable="on" dojoOnMouseover="_onmouseover" dojoOnMouseout="_onmouseout" dojoOnClick="_onclick" dojoOnMousedown="_onmousedown" dojoOnMouseup="_onmouseup"></div>',
+	//templateString: '<div class="toolbar" dojoAttachPoint="containerNode" unselectable="on"></div>',
+
+	// given a node, tries to find it's toolbar item
+	_getItem: function(node) {
+		var start = new Date();
+		var widget = null;
+		while(node && node != this.domNode) {
+			if(dojo.html.hasClass(node, "toolbarItem")) {
+				var widgets = dojo.widget.manager.getWidgetsByFilter(function(w) { return w.domNode == node; });
+				if(widgets.length == 1) {
+					widget = widgets[0];
+					break;
+				} else if(widgets.length > 1) {
 					dojo.raise("Toolbar._getItem: More than one widget matches the node");
 				}
 			}
+			node = node.parentNode;
 		}
-		node = node.parentNode;
-	}
-	return widget;
-}, _onmouseover:function (e) {
-	var widget = this._getItem(e.target);
-	if (widget && widget._onmouseover) {
-		widget._onmouseover(e);
-	}
-}, _onmouseout:function (e) {
-	var widget = this._getItem(e.target);
-	if (widget && widget._onmouseout) {
-		widget._onmouseout(e);
-	}
-}, _onclick:function (e) {
-	var widget = this._getItem(e.target);
-	if (widget && widget._onclick) {
-		widget._onclick(e);
-	}
-}, _onmousedown:function (e) {
-	var widget = this._getItem(e.target);
-	if (widget && widget._onmousedown) {
-		widget._onmousedown(e);
-	}
-}, _onmouseup:function (e) {
-	var widget = this._getItem(e.target);
-	if (widget && widget._onmouseup) {
-		widget._onmouseup(e);
-	}
-}, addChild:function (item, pos, props) {
-	var widget = dojo.widget.ToolbarItem.make(item, null, props);
-	var ret = dojo.widget.Toolbar.superclass.addChild.call(this, widget, null, pos, null);
-	return ret;
-}, push:function () {
-	for (var i = 0; i < arguments.length; i++) {
-		this.addChild(arguments[i]);
-	}
-}, getItem:function (name) {
-	if (name instanceof dojo.widget.ToolbarItem) {
-		return name;
-	}
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem && child._name == name) {
-			return child;
+		return widget;
+	},
+
+	_onmouseover: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget && widget._onmouseover) { widget._onmouseover(e); }
+	},
+
+	_onmouseout: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget && widget._onmouseout) { widget._onmouseout(e); }
+	},
+
+	_onclick: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget && widget._onclick){ 
+			widget._onclick(e);
 		}
-	}
-	return null;
-}, getItems:function () {
-	var items = [];
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem) {
-			items.push(child);
+	},
+
+	_onmousedown: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget && widget._onmousedown) { widget._onmousedown(e); }
+	},
+
+	_onmouseup: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget && widget._onmouseup) { widget._onmouseup(e); }
+	},
+
+	addChild: function(item, pos, props) {
+		var widget = dojo.widget.ToolbarItem.make(item, null, props);
+		var ret = dojo.widget.html.Toolbar.superclass.addChild.call(this, widget, null, pos, null);
+		return ret;
+	},
+
+	push: function() {
+		for(var i = 0; i < arguments.length; i++) {
+			this.addChild(arguments[i]);
 		}
-	}
-	return items;
-}, getItemsState:function () {
-	var values = {};
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem) {
-			values[child._name] = {selected:child._selected, enabled:!child.disabled};
+	},
+
+	getItem: function(name) {
+		if(name instanceof dojo.widget.ToolbarItem) { return name; }
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem
+				&& child._name == name) { return child; }
 		}
-	}
-	return values;
-}, getItemsActiveState:function () {
-	var values = this.getItemsState();
-	for (var item in values) {
-		values[item] = values[item].enabled;
-	}
-	return values;
-}, getItemsSelectedState:function () {
-	var values = this.getItemsState();
-	for (var item in values) {
-		values[item] = values[item].selected;
-	}
-	return values;
-}, enable:function () {
-	var items = arguments.length ? arguments : this.children;
-	for (var i = 0; i < items.length; i++) {
-		var child = this.getItem(items[i]);
-		if (child instanceof dojo.widget.ToolbarItem) {
-			child.enable(false, true);
+		return null;
+	},
+
+	getItems: function() {
+		var items = [];
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				items.push(child);
+			}
 		}
-	}
-}, disable:function () {
-	var items = arguments.length ? arguments : this.children;
-	for (var i = 0; i < items.length; i++) {
-		var child = this.getItem(items[i]);
-		if (child instanceof dojo.widget.ToolbarItem) {
-			child.disable();
+		return items;
+	},
+
+	getItemsState: function() {
+		var values = {};
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				values[child._name] = {
+					selected: child._selected,
+					enabled: child._enabled
+				};
+			}
 		}
-	}
-}, select:function () {
-	for (var i = 0; i < arguments.length; i++) {
-		var name = arguments[i];
-		var item = this.getItem(name);
-		if (item) {
-			item.select();
+		return values;
+	},
+
+	getItemsActiveState: function() {
+		var values = this.getItemsState();
+		for(var item in values) {
+			values[item] = values[item].enabled;
 		}
-	}
-}, deselect:function () {
-	for (var i = 0; i < arguments.length; i++) {
-		var name = arguments[i];
-		var item = this.getItem(name);
-		if (item) {
-			item.disable();
+		return values;
+	},
+
+	getItemsSelectedState: function() {
+		var values = this.getItemsState();
+		for(var item in values) {
+			values[item] = values[item].selected;
 		}
-	}
-}, setValue:function () {
-	for (var i = 0; i < arguments.length; i += 2) {
-		var name = arguments[i], value = arguments[i + 1];
-		var item = this.getItem(name);
-		if (item) {
-			if (item instanceof dojo.widget.ToolbarItem) {
-				item.setValue(value);
+		return values;
+	},
+
+	enable: function() {
+		var items = arguments.length ? arguments : this.children;
+		for(var i = 0; i < items.length; i++) {
+			var child = this.getItem(items[i]);
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.enable(false, true);
 			}
 		}
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.ToolbarItem", dojo.widget.HtmlWidget, {templateString:"<span unselectable=\"on\" class=\"toolbarItem\"></span>", _name:null, getName:function () {
-	return this._name;
-}, setName:function (value) {
-	return (this._name = value);
-}, getValue:function () {
-	return this.getName();
-}, setValue:function (value) {
-	return this.setName(value);
-}, _selected:false, isSelected:function () {
-	return this._selected;
-}, setSelected:function (is, force, preventEvent) {
-	if (!this._toggleItem && !force) {
-		return;
-	}
-	is = Boolean(is);
-	if (force || !this.disabled && this._selected != is) {
-		this._selected = is;
-		this.update();
-		if (!preventEvent) {
-			this._fireEvent(is ? "onSelect" : "onDeselect");
-			this._fireEvent("onChangeSelect");
+	},
+
+	disable: function() {
+		var items = arguments.length ? arguments : this.children;
+		for(var i = 0; i < items.length; i++) {
+			var child = this.getItem(items[i]);
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.disable();
+			}
 		}
+	},
+
+	select: function() {
+		for(var i = 0; i < arguments.length; i++) {
+			var name = arguments[i];
+			var item = this.getItem(name);
+			if(item) { item.select(); }
+		}
+	},
+
+	deselect: function() {
+		for(var i = 0; i < arguments.length; i++) {
+			var name = arguments[i];
+			var item = this.getItem(name);
+			if(item) { item.disable(); }
+		}
+	},
+
+	setValue: function() {
+		for(var i = 0; i < arguments.length; i += 2) {
+			var name = arguments[i], value = arguments[i+1];
+			var item = this.getItem(name);
+			if(item) {
+				if(item instanceof dojo.widget.ToolbarItem) {
+					item.setValue(value);
+				}
+			}
+		}
 	}
-}, select:function (force, preventEvent) {
-	return this.setSelected(true, force, preventEvent);
-}, deselect:function (force, preventEvent) {
-	return this.setSelected(false, force, preventEvent);
-}, _toggleItem:false, isToggleItem:function () {
-	return this._toggleItem;
-}, setToggleItem:function (value) {
-	this._toggleItem = Boolean(value);
-}, toggleSelected:function (force) {
-	return this.setSelected(!this._selected, force);
-}, isEnabled:function () {
-	return !this.disabled;
-}, setEnabled:function (is, force, preventEvent) {
-	is = Boolean(is);
-	if (force || this.disabled == is) {
-		this.disabled = !is;
-		this.update();
-		if (!preventEvent) {
-			this._fireEvent(this.disabled ? "onDisable" : "onEnable");
-			this._fireEvent("onChangeEnabled");
+});
+
+/* ToolbarItem hierarchy:
+	- ToolbarItem
+		- ToolbarButton
+		- ToolbarDialog
+			- ToolbarMenu
+		- ToolbarSeparator
+			- ToolbarSpace
+				- ToolbarFlexibleSpace
+*/
+
+
+/* ToolbarItem
+ **************/
+dojo.widget.ToolbarItem = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.ToolbarItem, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.ToolbarItem, {
+	templateString: '<span unselectable="on" class="toolbarItem"></span>',
+
+	_name: null,
+	getName: function() { return this._name; },
+	setName: function(value) { return this._name = value; },
+	getValue: function() { return this.getName(); },
+	setValue: function(value) { return this.setName(value); },
+
+	_selected: false,
+	isSelected: function() { return this._selected; },
+	setSelected: function(is, force, preventEvent) {
+		if(!this._toggleItem && !force) { return; }
+		is = Boolean(is);
+		if(force || this._enabled && this._selected != is) {
+			this._selected = is;
+			this.update();
+			if(!preventEvent) {
+				this._fireEvent(is ? "onSelect" : "onDeselect");
+				this._fireEvent("onChangeSelect");
+			}
 		}
-	}
-	return !this.disabled;
-}, enable:function (force, preventEvent) {
-	return this.setEnabled(true, force, preventEvent);
-}, disable:function (force, preventEvent) {
-	return this.setEnabled(false, force, preventEvent);
-}, toggleEnabled:function (force, preventEvent) {
-	return this.setEnabled(this.disabled, force, preventEvent);
-}, _icon:null, getIcon:function () {
-	return this._icon;
-}, setIcon:function (value) {
-	var icon = dojo.widget.Icon.make(value);
-	if (this._icon) {
-		this._icon.setIcon(icon);
-	} else {
-		this._icon = icon;
-	}
-	var iconNode = this._icon.getNode();
-	if (iconNode.parentNode != this.domNode) {
-		if (this.domNode.hasChildNodes()) {
-			this.domNode.insertBefore(iconNode, this.domNode.firstChild);
+	},
+	select: function(force, preventEvent) {
+		return this.setSelected(true, force, preventEvent);
+	},
+	deselect: function(force, preventEvent) {
+		return this.setSelected(false, force, preventEvent);
+	},
+
+	_toggleItem: false,
+	isToggleItem: function() { return this._toggleItem; },
+	setToggleItem: function(value) { this._toggleItem = Boolean(value); },
+
+	toggleSelected: function(force) {
+		return this.setSelected(!this._selected, force);
+	},
+
+	_enabled: true,
+	isEnabled: function() { return this._enabled; },
+	setEnabled: function(is, force, preventEvent) {
+		is = Boolean(is);
+		if(force || this._enabled != is) {
+			this._enabled = is;
+			this.update();
+			if(!preventEvent) {
+				this._fireEvent(this._enabled ? "onEnable" : "onDisable");
+				this._fireEvent("onChangeEnabled");
+			}
+		}
+		return this._enabled;
+	},
+	enable: function(force, preventEvent) {
+		return this.setEnabled(true, force, preventEvent);
+	},
+	disable: function(force, preventEvent) {
+		return this.setEnabled(false, force, preventEvent);
+	},
+	toggleEnabled: function(force, preventEvent) {
+		return this.setEnabled(!this._enabled, force, preventEvent);
+	},
+
+	_icon: null,
+	getIcon: function() { return this._icon; },
+	setIcon: function(value) {
+		var icon = dojo.widget.Icon.make(value);
+		if(this._icon) {
+			this._icon.setIcon(icon);
 		} else {
-			this.domNode.appendChild(iconNode);
+			this._icon = icon;
 		}
-	}
-	return this._icon;
-}, _label:"", getLabel:function () {
-	return this._label;
-}, setLabel:function (value) {
-	var ret = (this._label = value);
-	if (!this.labelNode) {
-		this.labelNode = document.createElement("span");
-		this.domNode.appendChild(this.labelNode);
-	}
-	this.labelNode.innerHTML = "";
-	this.labelNode.appendChild(document.createTextNode(this._label));
-	this.update();
-	return ret;
-}, update:function () {
-	if (this.disabled) {
-		this._selected = false;
-		dojo.html.addClass(this.domNode, "disabled");
-		dojo.html.removeClass(this.domNode, "down");
-		dojo.html.removeClass(this.domNode, "hover");
-	} else {
-		dojo.html.removeClass(this.domNode, "disabled");
-		if (this._selected) {
-			dojo.html.addClass(this.domNode, "selected");
+		var iconNode = this._icon.getNode();
+		if(iconNode.parentNode != this.domNode) {
+			if(this.domNode.hasChildNodes()) {
+				this.domNode.insertBefore(iconNode, this.domNode.firstChild);
+			} else {
+				this.domNode.appendChild(iconNode);
+			}
+		}
+		return this._icon;
+	},
+
+	// TODO: update the label node (this.labelNode?)
+	_label: "",
+	getLabel: function() { return this._label; },
+	setLabel: function(value) {
+		var ret = this._label = value;
+		if(!this.labelNode) {
+			this.labelNode = document.createElement("span");
+			this.domNode.appendChild(this.labelNode);
+		}
+		this.labelNode.innerHTML = "";
+		this.labelNode.appendChild(document.createTextNode(this._label));
+		this.update();
+		return ret;
+	},
+
+	// fired from: setSelected, setEnabled, setLabel
+	update: function() {
+		if(this._enabled) {
+			dojo.html.removeClass(this.domNode, "disabled");
+			if(this._selected) {
+				dojo.html.addClass(this.domNode, "selected");
+			} else {
+				dojo.html.removeClass(this.domNode, "selected");
+			}
 		} else {
-			dojo.html.removeClass(this.domNode, "selected");
+			this._selected = false;
+			dojo.html.addClass(this.domNode, "disabled");
+			dojo.html.removeClass(this.domNode, "down");
+			dojo.html.removeClass(this.domNode, "hover");
 		}
-	}
-	this._updateIcon();
-}, _updateIcon:function () {
-	if (this._icon) {
-		if (this.disabled) {
-			this._icon.disable();
-		} else {
-			if (this._cssHover) {
-				this._icon.hover();
-			} else {
-				if (this._selected) {
+		this._updateIcon();
+	},
+
+	_updateIcon: function() {
+		if(this._icon) {
+			if(this._enabled) {
+				if(this._cssHover) {
+					this._icon.hover();
+				} else if(this._selected) {
 					this._icon.select();
 				} else {
 					this._icon.enable();
 				}
+			} else {
+				this._icon.disable();
 			}
 		}
-	}
-}, _fireEvent:function (evt) {
-	if (typeof this[evt] == "function") {
-		var args = [this];
-		for (var i = 1; i < arguments.length; i++) {
-			args.push(arguments[i]);
+	},
+
+	_fireEvent: function(evt) {
+		if(typeof this[evt] == "function") {
+			var args = [this];
+			for(var i = 1; i < arguments.length; i++) {
+				args.push(arguments[i]);
+			}
+			this[evt].apply(this, args);
 		}
-		this[evt].apply(this, args);
-	}
-}, _onmouseover:function (e) {
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.addClass(this.domNode, "hover");
-	this._fireEvent("onMouseOver");
-}, _onmouseout:function (e) {
-	dojo.html.removeClass(this.domNode, "hover");
-	dojo.html.removeClass(this.domNode, "down");
-	if (!this._selected) {
-		dojo.html.removeClass(this.domNode, "selected");
-	}
-	this._fireEvent("onMouseOut");
-}, _onclick:function (e) {
-	if (!this.disabled && !this._toggleItem) {
-		this._fireEvent("onClick");
-	}
-}, _onmousedown:function (e) {
-	if (e.preventDefault) {
-		e.preventDefault();
-	}
-	if (this.disabled) {
-		return;
-	}
-	dojo.html.addClass(this.domNode, "down");
-	if (this._toggleItem) {
-		if (this.parent.preventDeselect && this._selected) {
-			return;
+	},
+
+	_onmouseover: function(e) {
+		if(!this._enabled) { return };
+		dojo.html.addClass(this.domNode, "hover");
+	},
+
+	_onmouseout: function(e) {
+		dojo.html.removeClass(this.domNode, "hover");
+		dojo.html.removeClass(this.domNode, "down");
+		if(!this._selected) {
+			dojo.html.removeClass(this.domNode, "selected");
 		}
-		this.toggleSelected();
+	},
+
+	_onclick: function(e) {
+		// FIXME: buttons never seem to have this._enabled set to true on Opera 9
+		// dojo.debug("widget:", this.widgetType, ":", this.getName(), ", enabled:", this._enabled);
+		if(this._enabled && !this._toggleItem) {
+			this._fireEvent("onClick");
+		}
+	},
+
+	_onmousedown: function(e) {
+		if(e.preventDefault) { e.preventDefault(); }
+		if(!this._enabled) { return };
+		dojo.html.addClass(this.domNode, "down");
+		if(this._toggleItem) {
+			if(this.parent.preventDeselect && this._selected) {
+				return;
+			}
+			this.toggleSelected();
+		}
+	},
+
+	_onmouseup: function(e) {
+		dojo.html.removeClass(this.domNode, "down");
+	},
+
+	fillInTemplate: function(args, frag) {
+		if(args.name) { this._name = args.name; }
+		if(args.selected) { this.select(); }
+		if(args.disabled) { this.disable(); }
+		if(args.label) { this.setLabel(args.label); }
+		if(args.icon) { this.setIcon(args.icon); }
+		if(args.toggleitem||args.toggleItem) { this.setToggleItem(true); }
 	}
-	this._fireEvent("onMouseDown");
-}, _onmouseup:function (e) {
-	dojo.html.removeClass(this.domNode, "down");
-	this._fireEvent("onMouseUp");
-}, onClick:function () {
-}, onMouseOver:function () {
-}, onMouseOut:function () {
-}, onMouseDown:function () {
-}, onMouseUp:function () {
-}, fillInTemplate:function (args, frag) {
-	if (args.name) {
-		this._name = args.name;
-	}
-	if (args.selected) {
-		this.select();
-	}
-	if (args.disabled) {
-		this.disable();
-	}
-	if (args.label) {
-		this.setLabel(args.label);
-	}
-	if (args.icon) {
-		this.setIcon(args.icon);
-	}
-	if (args.toggleitem || args.toggleItem) {
-		this.setToggleItem(true);
-	}
-}});
-dojo.widget.ToolbarItem.make = function (wh, whIsType, props) {
+});
+
+dojo.widget.ToolbarItem.make = function(wh, whIsType, props) {
 	var item = null;
-	if (wh instanceof Array) {
+
+	if(wh instanceof Array) {
 		item = dojo.widget.createWidget("ToolbarButtonGroup", props);
 		item.setName(wh[0]);
-		for (var i = 1; i < wh.length; i++) {
+		for(var i = 1; i < wh.length; i++) {
 			item.addChild(wh[i]);
 		}
-	} else {
-		if (wh instanceof dojo.widget.ToolbarItem) {
-			item = wh;
-		} else {
-			if (wh instanceof dojo.uri.Uri) {
-				item = dojo.widget.createWidget("ToolbarButton", dojo.lang.mixin(props || {}, {icon:new dojo.widget.Icon(wh.toString())}));
-			} else {
-				if (whIsType) {
-					item = dojo.widget.createWidget(wh, props);
+	} else if(wh instanceof dojo.widget.ToolbarItem) {
+		item = wh;
+	} else if(wh instanceof dojo.uri.Uri) {
+		item = dojo.widget.createWidget("ToolbarButton",
+			dojo.lang.mixin(props||{}, {icon: new dojo.widget.Icon(wh.toString())}));
+	} else if(whIsType) {
+		item = dojo.widget.createWidget(wh, props)
+	} else if(typeof wh == "string" || wh instanceof String) {
+		switch(wh.charAt(0)) {
+			case "|":
+			case "-":
+			case "/":
+				item = dojo.widget.createWidget("ToolbarSeparator", props);
+				break;
+			case " ":
+				if(wh.length == 1) {
+					item = dojo.widget.createWidget("ToolbarSpace", props);
 				} else {
-					if (typeof wh == "string" || wh instanceof String) {
-						switch (wh.charAt(0)) {
-						  case "|":
-						  case "-":
-						  case "/":
-							item = dojo.widget.createWidget("ToolbarSeparator", props);
-							break;
-						  case " ":
-							if (wh.length == 1) {
-								item = dojo.widget.createWidget("ToolbarSpace", props);
-							} else {
-								item = dojo.widget.createWidget("ToolbarFlexibleSpace", props);
-							}
-							break;
-						  default:
-							if (/\.(gif|jpg|jpeg|png)$/i.test(wh)) {
-								item = dojo.widget.createWidget("ToolbarButton", dojo.lang.mixin(props || {}, {icon:new dojo.widget.Icon(wh.toString())}));
-							} else {
-								item = dojo.widget.createWidget("ToolbarButton", dojo.lang.mixin(props || {}, {label:wh.toString()}));
-							}
-						}
-					} else {
-						if (wh && wh.tagName && /^img$/i.test(wh.tagName)) {
-							item = dojo.widget.createWidget("ToolbarButton", dojo.lang.mixin(props || {}, {icon:wh}));
-						} else {
-							item = dojo.widget.createWidget("ToolbarButton", dojo.lang.mixin(props || {}, {label:wh.toString()}));
-						}
-					}
+					item = dojo.widget.createWidget("ToolbarFlexibleSpace", props);
 				}
-			}
+				break;
+			default:
+				if(/\.(gif|jpg|jpeg|png)$/i.test(wh)) {
+					item = dojo.widget.createWidget("ToolbarButton",
+						dojo.lang.mixin(props||{}, {icon: new dojo.widget.Icon(wh.toString())}));
+				} else {
+					item = dojo.widget.createWidget("ToolbarButton",
+						dojo.lang.mixin(props||{}, {label: wh.toString()}));
+				}
 		}
+	} else if(wh && wh.tagName && /^img$/i.test(wh.tagName)) {
+		item = dojo.widget.createWidget("ToolbarButton",
+			dojo.lang.mixin(props||{}, {icon: wh}));
+	} else {
+		item = dojo.widget.createWidget("ToolbarButton",
+			dojo.lang.mixin(props||{}, {label: wh.toString()}));
 	}
 	return item;
-};
-dojo.widget.defineWidget("dojo.widget.ToolbarButtonGroup", dojo.widget.ToolbarItem, {isContainer:true, templateString:"<span unselectable=\"on\" class=\"toolbarButtonGroup\" dojoAttachPoint=\"containerNode\"></span>", defaultButton:"", postCreate:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		this._injectChild(this.children[i]);
-	}
-}, addChild:function (item, pos, props) {
-	var widget = dojo.widget.ToolbarItem.make(item, null, dojo.lang.mixin(props || {}, {toggleItem:true}));
-	var ret = dojo.widget.ToolbarButtonGroup.superclass.addChild.call(this, widget, null, pos, null);
-	this._injectChild(widget);
-	return ret;
-}, _injectChild:function (widget) {
-	dojo.event.connect(widget, "onSelect", this, "onChildSelected");
-	dojo.event.connect(widget, "onDeselect", this, "onChildDeSelected");
-	if (widget._name == this.defaultButton || (typeof this.defaultButton == "number" && this.children.length - 1 == this.defaultButton)) {
-		widget.select(false, true);
-	}
-}, getItem:function (name) {
-	if (name instanceof dojo.widget.ToolbarItem) {
-		return name;
-	}
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem && child._name == name) {
-			return child;
+}
+
+/* ToolbarButtonGroup
+ *********************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarButtonGroup");
+dojo.widget.html.ToolbarButtonGroup = function() {
+	dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarButtonGroup, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarButtonGroup, {
+	widgetType: "ToolbarButtonGroup",
+	isContainer: true,
+
+	templateString: '<span unselectable="on" class="toolbarButtonGroup" dojoAttachPoint="containerNode"></span>',
+
+	// if a button has the same name, it will be selected
+	// if this is set to a number, the button at that index will be selected
+	defaultButton: "",
+
+    postCreate: function() {
+        for (var i = 0; i < this.children.length; i++) {
+            this._injectChild(this.children[i]);
+        }
+    },
+
+	addChild: function(item, pos, props) {
+		var widget = dojo.widget.ToolbarItem.make(item, null, dojo.lang.mixin(props||{}, {toggleItem:true}));
+		var ret = dojo.widget.html.ToolbarButtonGroup.superclass.addChild.call(this, widget, null, pos, null);
+        this._injectChild(widget);
+        return ret;
+    },
+
+    _injectChild: function(widget) {
+        dojo.event.connect(widget, "onSelect", this, "onChildSelected");
+        dojo.event.connect(widget, "onDeselect", this, "onChildDeSelected");
+        if(widget._name == this.defaultButton
+			|| (typeof this.defaultButton == "number"
+			&& this.children.length-1 == this.defaultButton)) {
+			widget.select(false, true);
 		}
-	}
-	return null;
-}, getItems:function () {
-	var items = [];
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem) {
-			items.push(child);
+	},
+
+	getItem: function(name) {
+		if(name instanceof dojo.widget.ToolbarItem) { return name; }
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem
+				&& child._name == name) { return child; }
 		}
-	}
-	return items;
-}, onChildSelected:function (e) {
-	this.select(e._name);
-}, onChildDeSelected:function (e) {
-	this._fireEvent("onChangeSelect", this._value);
-}, enable:function (force, preventEvent) {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem) {
-			child.enable(force, preventEvent);
-			if (child._name == this._value) {
-				child.select(force, preventEvent);
+		return null;
+	},
+
+	getItems: function() {
+		var items = [];
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				items.push(child);
 			}
 		}
-	}
-}, disable:function (force, preventEvent) {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem) {
-			child.disable(force, preventEvent);
+		return items;
+	},
+
+	onChildSelected: function(e) {
+		this.select(e._name);
+	},
+
+	onChildDeSelected: function(e) {
+		this._fireEvent("onChangeSelect", this._value);
+	},
+
+	enable: function(force, preventEvent) {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.enable(force, preventEvent);
+				if(child._name == this._value) {
+					child.select(force, preventEvent);
+				}
+			}
 		}
-	}
-}, _value:"", getValue:function () {
-	return this._value;
-}, select:function (name, force, preventEvent) {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child instanceof dojo.widget.ToolbarItem) {
-			if (child._name == name) {
-				child.select(force, preventEvent);
-				this._value = name;
-			} else {
-				child.deselect(true, true);
+	},
+
+	disable: function(force, preventEvent) {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.disable(force, preventEvent);
 			}
 		}
-	}
-	if (!preventEvent) {
-		this._fireEvent("onSelect", this._value);
-		this._fireEvent("onChangeSelect", this._value);
-	}
-}, setValue:this.select, preventDeselect:false});
-dojo.widget.defineWidget("dojo.widget.ToolbarButton", dojo.widget.ToolbarItem, {fillInTemplate:function (args, frag) {
-	dojo.widget.ToolbarButton.superclass.fillInTemplate.call(this, args, frag);
-	dojo.html.addClass(this.domNode, "toolbarButton");
-	if (this._icon) {
-		this.setIcon(this._icon);
-	}
-	if (this._label) {
-		this.setLabel(this._label);
-	}
-	if (!this._name) {
-		if (this._label) {
-			this.setName(this._label);
-		} else {
-			if (this._icon) {
+	},
+
+	_value: "",
+	getValue: function() { return this._value; },
+
+	select: function(name, force, preventEvent) {
+		for(var i = 0; i < this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				if(child._name == name) {
+					child.select(force, preventEvent);
+					this._value = name;
+				} else {
+					child.deselect(true, true);
+				}
+			}
+		}
+		if(!preventEvent) {
+			this._fireEvent("onSelect", this._value);
+			this._fireEvent("onChangeSelect", this._value);
+		}
+	},
+	setValue: this.select,
+
+	preventDeselect: false // if true, once you select one, you can't have none selected
+});
+
+/* ToolbarButton
+ ***********************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarButton");
+dojo.widget.html.ToolbarButton = function() {
+	dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarButton, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarButton, {
+	widgetType: "ToolbarButton",
+
+	fillInTemplate: function(args, frag) {
+		dojo.widget.html.ToolbarButton.superclass.fillInTemplate.call(this, args, frag);
+		dojo.html.addClass(this.domNode, "toolbarButton");
+		if(this._icon) {
+			this.setIcon(this._icon);
+		}
+		if(this._label) {
+			this.setLabel(this._label);
+		}
+
+		if(!this._name) {
+			if(this._label) {
+				this.setName(this._label);
+			} else if(this._icon) {
 				var src = this._icon.getSrc("enabled").match(/[\/^]([^\.\/]+)\.(gif|jpg|jpeg|png)$/i);
-				if (src) {
-					this.setName(src[1]);
-				}
+				if(src) { this.setName(src[1]); }
 			} else {
 				this._name = this._widgetId;
 			}
 		}
 	}
-}});
-dojo.widget.defineWidget("dojo.widget.ToolbarDialog", dojo.widget.ToolbarButton, {fillInTemplate:function (args, frag) {
-	dojo.widget.ToolbarDialog.superclass.fillInTemplate.call(this, args, frag);
-	dojo.event.connect(this, "onSelect", this, "showDialog");
-	dojo.event.connect(this, "onDeselect", this, "hideDialog");
-}, showDialog:function (e) {
-	dojo.lang.setTimeout(dojo.event.connect, 1, document, "onmousedown", this, "deselect");
-}, hideDialog:function (e) {
-	dojo.event.disconnect(document, "onmousedown", this, "deselect");
-}});
-dojo.widget.defineWidget("dojo.widget.ToolbarMenu", dojo.widget.ToolbarDialog, {});
-dojo.widget.ToolbarMenuItem = function () {
-};
-dojo.widget.defineWidget("dojo.widget.ToolbarSeparator", dojo.widget.ToolbarItem, {templateString:"<span unselectable=\"on\" class=\"toolbarItem toolbarSeparator\"></span>", defaultIconPath:new dojo.uri.moduleUri("dojo.widget", "templates/buttons/sep.gif"), fillInTemplate:function (args, frag, skip) {
-	dojo.widget.ToolbarSeparator.superclass.fillInTemplate.call(this, args, frag);
-	this._name = this.widgetId;
-	if (!skip) {
-		if (!this._icon) {
-			this.setIcon(this.defaultIconPath);
+});
+
+/* ToolbarDialog
+ **********************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarDialog");
+dojo.widget.html.ToolbarDialog = function() {
+	dojo.widget.html.ToolbarButton.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarDialog, dojo.widget.html.ToolbarButton);
+dojo.lang.extend(dojo.widget.html.ToolbarDialog, {
+	widgetType: "ToolbarDialog",
+	
+	fillInTemplate: function (args, frag) {
+		dojo.widget.html.ToolbarDialog.superclass.fillInTemplate.call(this, args, frag);
+		dojo.event.connect(this, "onSelect", this, "showDialog");
+		dojo.event.connect(this, "onDeselect", this, "hideDialog");
+	},
+	
+	showDialog: function (e) {
+		dojo.lang.setTimeout(dojo.event.connect, 1, document, "onmousedown", this, "deselect");
+	},
+	
+	hideDialog: function (e) {
+		dojo.event.disconnect(document, "onmousedown", this, "deselect");
+	}
+
+});
+
+/* ToolbarMenu
+ **********************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarMenu");
+dojo.widget.html.ToolbarMenu = function() {
+	dojo.widget.html.ToolbarDialog.call(this);
+
+	this.widgetType = "ToolbarMenu";
+}
+dojo.inherits(dojo.widget.html.ToolbarMenu, dojo.widget.html.ToolbarDialog);
+
+/* ToolbarMenuItem
+ ******************/
+dojo.widget.ToolbarMenuItem = function() {
+}
+
+/* ToolbarSeparator
+ **********************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarSeparator");
+dojo.widget.html.ToolbarSeparator = function() {
+    dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarSeparator, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarSeparator, {
+	widgetType: "ToolbarSeparator",
+	templateString: '<span unselectable="on" class="toolbarItem toolbarSeparator"></span>',
+
+	defaultIconPath: new dojo.uri.dojoUri("src/widget/templates/buttons/-.gif"),
+
+	fillInTemplate: function(args, frag, skip) {
+		dojo.widget.html.ToolbarSeparator.superclass.fillInTemplate.call(this, args, frag);
+		this._name = this.widgetId;
+		if(!skip) {
+			if(!this._icon) {
+				this.setIcon(this.defaultIconPath);
+			}
+			this.domNode.appendChild(this._icon.getNode());
 		}
-		this.domNode.appendChild(this._icon.getNode());
+	},
+
+	// don't want events!
+	_onmouseover: null, 
+    _onmouseout: null, 
+    _onclick: null, 
+    _onmousedown: null, 
+    _onmouseup: null 
+});
+
+/* ToolbarSpace
+ **********************/
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarSpace");
+dojo.widget.html.ToolbarSpace = function() {
+	dojo.widget.html.ToolbarSeparator.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarSpace, dojo.widget.html.ToolbarSeparator);
+dojo.lang.extend(dojo.widget.html.ToolbarSpace, {
+    widgetType: "ToolbarSpace",
+
+	fillInTemplate: function(args, frag, skip) {
+		dojo.widget.html.ToolbarSpace.superclass.fillInTemplate.call(this, args, frag, true);
+		if(!skip) {
+			dojo.html.addClass(this.domNode, "toolbarSpace");
+		}
 	}
-}, _onmouseover:null, _onmouseout:null, _onclick:null, _onmousedown:null, _onmouseup:null});
-dojo.widget.defineWidget("dojo.widget.ToolbarSpace", dojo.widget.ToolbarSeparator, {fillInTemplate:function (args, frag, skip) {
-	dojo.widget.ToolbarSpace.superclass.fillInTemplate.call(this, args, frag, true);
-	if (!skip) {
-		dojo.html.addClass(this.domNode, "toolbarSpace");
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.ToolbarSelect", dojo.widget.ToolbarItem, {templateString:"<span class=\"toolbarItem toolbarSelect\" unselectable=\"on\"><select dojoAttachPoint=\"selectBox\" dojoOnChange=\"changed\"></select></span>", fillInTemplate:function (args, frag) {
-	dojo.widget.ToolbarSelect.superclass.fillInTemplate.call(this, args, frag, true);
-	var keys = args.values;
-	var i = 0;
-	for (var val in keys) {
-		var opt = document.createElement("option");
-		opt.setAttribute("value", keys[val]);
-		opt.innerHTML = val;
-		this.selectBox.appendChild(opt);
-	}
-}, changed:function (e) {
-	this._fireEvent("onSetValue", this.selectBox.value);
-}, setEnabled:function (is, force, preventEvent) {
-	var ret = dojo.widget.ToolbarSelect.superclass.setEnabled.call(this, is, force, preventEvent);
-	this.selectBox.disabled = this.disabled;
-	return ret;
-}, _onmouseover:null, _onmouseout:null, _onclick:null, _onmousedown:null, _onmouseup:null});
-dojo.widget.Icon = function (enabled, disabled, hovered, selected) {
-	if (!arguments.length) {
+});
+
+/* ToolbarSelect
+ ******************/ 
+
+dojo.widget.tags.addParseTreeHandler("dojo:toolbarSelect");
+dojo.widget.html.ToolbarSelect = function() {
+	dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarSelect, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarSelect, {
+    widgetType: "ToolbarSelect",
+	templateString: '<span class="toolbarItem toolbarSelect" unselectable="on"><select dojoAttachPoint="selectBox" dojoOnChange="changed"></select></span>',
+
+	fillInTemplate: function(args, frag) {
+		dojo.widget.html.ToolbarSelect.superclass.fillInTemplate.call(this, args, frag, true);
+		var keys = args.values;
+		var i = 0;
+		for(var val in keys) {
+			var opt = document.createElement("option");
+			opt.setAttribute("value", keys[val]);
+			opt.innerHTML = val;
+			this.selectBox.appendChild(opt);
+		}
+	},
+
+	changed: function(e) {
+		this._fireEvent("onSetValue", this.selectBox.value);
+	},
+
+	setEnabled: function(is, force, preventEvent) {
+		var ret = dojo.widget.html.ToolbarSelect.superclass.setEnabled.call(this, is, force, preventEvent);
+		this.selectBox.disabled = !this._enabled;
+		return ret;
+	},
+
+	// don't want events!
+	_onmouseover: null,
+    _onmouseout: null,
+    _onclick: null,
+    _onmousedown: null,
+    _onmouseup: null
+});
+
+/* Icon
+ *********/
+// arguments can be IMG nodes, Image() instances or URLs -- enabled is the only one required
+dojo.widget.Icon = function(enabled, disabled, hover, selected){
+	if(!arguments.length){
+		// FIXME: should this be dojo.raise?
 		throw new Error("Icon must have at least an enabled state");
 	}
-	var states = ["enabled", "disabled", "hovered", "selected"];
+	var states = ["enabled", "disabled", "hover", "selected"];
 	var currentState = "enabled";
 	var domNode = document.createElement("img");
-	this.getState = function () {
-		return currentState;
-	};
-	this.setState = function (value) {
-		if (dojo.lang.inArray(states, value)) {
-			if (this[value]) {
+
+	this.getState = function(){ return currentState; }
+	this.setState = function(value){
+		if(dojo.lang.inArray(value, states)){
+			if(this[value]){
 				currentState = value;
-				var img = this[currentState];
-				if ((dojo.render.html.ie55 || dojo.render.html.ie60) && img.src && img.src.match(/[.]png$/i)) {
-					domNode.width = img.width || img.offsetWidth;
-					domNode.height = img.height || img.offsetHeight;
-					domNode.setAttribute("src", dojo.uri.moduleUri("dojo.widget", "templates/images/blank.gif").uri);
-					domNode.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src='" + img.src + "',sizingMethod='image')";
-				} else {
-					domNode.setAttribute("src", img.src);
-				}
+				domNode.setAttribute("src", this[currentState].src);
 			}
-		} else {
+		}else{
 			throw new Error("Invalid state set on Icon (state: " + value + ")");
 		}
-	};
-	this.setSrc = function (state, value) {
-		if (/^img$/i.test(value.tagName)) {
+	}
+
+	this.setSrc = function(state, value){
+		if(/^img$/i.test(value.tagName)){
 			this[state] = value;
-		} else {
-			if (typeof value == "string" || value instanceof String || value instanceof dojo.uri.Uri) {
-				this[state] = new Image();
-				this[state].src = value.toString();
-			}
+		}else if(typeof value == "string" || value instanceof String
+			|| value instanceof dojo.uri.Uri){
+			this[state] = new Image();
+			this[state].src = value.toString();
 		}
 		return this[state];
-	};
-	this.setIcon = function (icon) {
-		for (var i = 0; i < states.length; i++) {
-			if (icon[states[i]]) {
+	}
+
+	this.setIcon = function(icon){
+		for(var i = 0; i < states.length; i++){
+			if(icon[states[i]]){
 				this.setSrc(states[i], icon[states[i]]);
 			}
 		}
 		this.update();
-	};
-	this.enable = function () {
-		this.setState("enabled");
-	};
-	this.disable = function () {
-		this.setState("disabled");
-	};
-	this.hover = function () {
-		this.setState("hovered");
-	};
-	this.select = function () {
-		this.setState("selected");
-	};
-	this.getSize = function () {
-		return {width:domNode.width || domNode.offsetWidth, height:domNode.height || domNode.offsetHeight};
-	};
-	this.setSize = function (w, h) {
+	}
+
+	this.enable = function(){ this.setState("enabled"); }
+	this.disable = function(){ this.setState("disabled"); }
+	this.hover = function(){ this.setState("hover"); }
+	this.select = function(){ this.setState("selected"); }
+
+	this.getSize = function(){
+		return {
+			width: domNode.width||domNode.offsetWidth,
+			height: domNode.height||domNode.offsetHeight
+		};
+	}
+
+	this.setSize = function(w, h){
 		domNode.width = w;
 		domNode.height = h;
-		return {width:w, height:h};
-	};
-	this.getNode = function () {
+		return { width: w, height: h };
+	}
+
+	this.getNode = function(){
 		return domNode;
-	};
-	this.getSrc = function (state) {
-		if (state) {
-			return this[state].src;
-		}
-		return domNode.src || "";
-	};
-	this.update = function () {
+	}
+
+	this.getSrc = function(state){
+		if(state){ return this[state].src; }
+		return domNode.src||"";
+	}
+
+	this.update = function(){
 		this.setState(currentState);
-	};
-	for (var i = 0; i < states.length; i++) {
+	}
+
+	for(var i = 0; i < states.length; i++){
 		var arg = arguments[i];
 		var state = states[i];
 		this[state] = null;
-		if (!arg) {
-			continue;
-		}
+		if(!arg){ continue; }
 		this.setSrc(state, arg);
 	}
+
 	this.enable();
-};
-dojo.widget.Icon.make = function (a, b, c, d) {
-	for (var i = 0; i < arguments.length; i++) {
-		if (arguments[i] instanceof dojo.widget.Icon) {
+}
+
+dojo.widget.Icon.make = function(a,b,c,d){
+	for(var i = 0; i < arguments.length; i++){
+		if(arguments[i] instanceof dojo.widget.Icon){
 			return arguments[i];
 		}
 	}
-	return new dojo.widget.Icon(a, b, c, d);
-};
-dojo.widget.defineWidget("dojo.widget.ToolbarColorDialog", dojo.widget.ToolbarDialog, {palette:"7x10", fillInTemplate:function (args, frag) {
-	dojo.widget.ToolbarColorDialog.superclass.fillInTemplate.call(this, args, frag);
-	this.dialog = dojo.widget.createWidget("ColorPalette", {palette:this.palette});
-	this.dialog.domNode.style.position = "absolute";
-	dojo.event.connect(this.dialog, "onColorSelect", this, "_setValue");
-}, _setValue:function (color) {
-	this._value = color;
-	this._fireEvent("onSetValue", color);
-}, showDialog:function (e) {
-	dojo.widget.ToolbarColorDialog.superclass.showDialog.call(this, e);
-	var abs = dojo.html.getAbsolutePosition(this.domNode, true);
-	var y = abs.y + dojo.html.getBorderBox(this.domNode).height;
-	this.dialog.showAt(abs.x, y);
-}, hideDialog:function (e) {
-	dojo.widget.ToolbarColorDialog.superclass.hideDialog.call(this, e);
-	this.dialog.hide();
-}});
 
+	return new dojo.widget.Icon(a,b,c,d);
+}

Modified: tags/parley-0.53/root/static/magic/src/widget/Tooltip.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Tooltip.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Tooltip.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,100 +8,7 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.Tooltip");
-dojo.require("dojo.widget.ContentPane");
-dojo.require("dojo.widget.PopupContainer");
-dojo.require("dojo.uri.Uri");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.event.*");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.util");
-dojo.widget.defineWidget("dojo.widget.Tooltip", [dojo.widget.ContentPane, dojo.widget.PopupContainerBase], {caption:"", showDelay:500, hideDelay:100, connectId:"", templateCssString:".dojoTooltip {\n\tborder: solid black 1px;\n\tbackground: beige;\n\tcolor: black;\n\tposition: absolute;\n\tfont-size: small;\n\tpadding: 2px 2px 2px 2px;\n\tz-index: 10;\n\tdisplay: block;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TooltipTemplate.css"), fillInTemplate:function (args, frag) {
-	if (this.caption != "") {
-		this.domNode.appendChild(document.createTextNode(this.caption));
-	}
-	this._connectNode = dojo.byId(this.connectId);
-	dojo.widget.Tooltip.superclass.fillInTemplate.call(this, args, frag);
-	this.addOnLoad(this, "_loadedContent");
-	dojo.html.addClass(this.domNode, "dojoTooltip");
-	var source = this.getFragNodeRef(frag);
-	dojo.html.copyStyle(this.domNode, source);
-	this.applyPopupBasicStyle();
-}, postCreate:function (args, frag) {
-	dojo.event.connect(this._connectNode, "onmouseover", this, "_onMouseOver");
-	dojo.widget.Tooltip.superclass.postCreate.call(this, args, frag);
-}, _onMouseOver:function (e) {
-	this._mouse = {x:e.pageX, y:e.pageY};
-	if (!this._tracking) {
-		dojo.event.connect(document.documentElement, "onmousemove", this, "_onMouseMove");
-		this._tracking = true;
-	}
-	this._onHover(e);
-}, _onMouseMove:function (e) {
-	this._mouse = {x:e.pageX, y:e.pageY};
-	if (dojo.html.overElement(this._connectNode, e) || dojo.html.overElement(this.domNode, e)) {
-		this._onHover(e);
-	} else {
-		this._onUnHover(e);
-	}
-}, _onHover:function (e) {
-	if (this._hover) {
-		return;
-	}
-	this._hover = true;
-	if (this._hideTimer) {
-		clearTimeout(this._hideTimer);
-		delete this._hideTimer;
-	}
-	if (!this.isShowingNow && !this._showTimer) {
-		this._showTimer = setTimeout(dojo.lang.hitch(this, "open"), this.showDelay);
-	}
-}, _onUnHover:function (e) {
-	if (!this._hover) {
-		return;
-	}
-	this._hover = false;
-	if (this._showTimer) {
-		clearTimeout(this._showTimer);
-		delete this._showTimer;
-	}
-	if (this.isShowingNow && !this._hideTimer) {
-		this._hideTimer = setTimeout(dojo.lang.hitch(this, "close"), this.hideDelay);
-	}
-	if (!this.isShowingNow) {
-		dojo.event.disconnect(document.documentElement, "onmousemove", this, "_onMouseMove");
-		this._tracking = false;
-	}
-}, open:function () {
-	if (this.isShowingNow) {
-		return;
-	}
-	dojo.widget.PopupContainerBase.prototype.open.call(this, this._mouse.x, this._mouse.y, null, [this._mouse.x, this._mouse.y], "TL,TR,BL,BR", [10, 15]);
-}, close:function () {
-	if (this.isShowingNow) {
-		if (this._showTimer) {
-			clearTimeout(this._showTimer);
-			delete this._showTimer;
-		}
-		if (this._hideTimer) {
-			clearTimeout(this._hideTimer);
-			delete this._hideTimer;
-		}
-		dojo.event.disconnect(document.documentElement, "onmousemove", this, "_onMouseMove");
-		this._tracking = false;
-		dojo.widget.PopupContainerBase.prototype.close.call(this);
-	}
-}, _position:function () {
-	this.move(this._mouse.x, this._mouse.y, [10, 15], "TL,TR,BL,BR");
-}, _loadedContent:function () {
-	if (this.isShowingNow) {
-		this._position();
-	}
-}, checkSize:function () {
-}, uninitialize:function () {
-	this.close();
-	dojo.event.disconnect(this._connectNode, "onmouseover", this, "_onMouseOver");
-}});
-
+dojo.provide("dojo.widget.Tooltip");
+dojo.require("dojo.widget.Widget");
+
+dojo.requireAfterIf("html", "dojo.widget.html.Tooltip");

Modified: tags/parley-0.53/root/static/magic/src/widget/Tree.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Tree.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Tree.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,229 +8,562 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/**
+ * Tree model does all the drawing, visual node management etc.
+ * Throws events about clicks on it, so someone may catch them and process
+ * Tree knows nothing about DnD stuff, covered in TreeDragAndDrop and (if enabled) attached by controller
+*/
 
+/**
+ * TODO: use domNode.cloneNode instead of createElement for grid
+ * Should be faster (lyxsus)
+ */
+dojo.provide("dojo.widget.Tree");
 
-dojo.provide("dojo.widget.Tree");
-dojo.require("dojo.widget.*");
 dojo.require("dojo.event.*");
 dojo.require("dojo.io.*");
 dojo.require("dojo.widget.HtmlWidget");
 dojo.require("dojo.widget.TreeNode");
-dojo.require("dojo.html.common");
-dojo.require("dojo.html.selection");
-dojo.widget.defineWidget("dojo.widget.Tree", dojo.widget.HtmlWidget, function () {
+
+
+
+// make it a tag
+dojo.widget.tags.addParseTreeHandler("dojo:Tree");
+
+
+dojo.widget.Tree = function() {
+	dojo.widget.HtmlWidget.call(this);
+
 	this.eventNames = {};
+
 	this.tree = this;
 	this.DNDAcceptTypes = [];
 	this.actionsDisabled = [];
-}, {widgetType:"Tree", eventNamesDefault:{createDOMNode:"createDOMNode", treeCreate:"treeCreate", treeDestroy:"treeDestroy", treeClick:"treeClick", iconClick:"iconClick", titleClick:"titleClick", moveFrom:"moveFrom", moveTo:"moveTo", addChild:"addChild", removeNode:"removeNode", expand:"expand", collapse:"collapse"}, isContainer:true, DNDMode:"off", lockLevel:0, strictFolders:true, DNDModes:{BETWEEN:1, ONTO:2}, DNDAcceptTypes:"", templateCssString:"\n.dojoTree {\n\tfont: caption;\n\tfont-size: 11px;\n\tfont-weight: normal;\n\toverflow: auto;\n}\n\n\n.dojoTreeNodeLabelTitle {\n\tpadding-left: 2px;\n\tcolor: WindowText;\n}\n\n.dojoTreeNodeLabel {\n\tcursor:hand;\n\tcursor:pointer;\n}\n\n.dojoTreeNodeLabelTitle:hover {\n\ttext-decoration: underline;\n}\n\n.dojoTreeNodeLabelSelected {\n\tbackground-color: Highlight;\n\tcolor: HighlightText;\n}\n\n.dojoTree div {\n\twhite-space: nowrap;\n}\n\n.dojoTree img, .dojoTreeNodeLabel img {\n\tvertical-align: middle;\n}\n\n", templateCss!
 Path:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/Tree.css"), templateString:"<div class=\"dojoTree\"></div>", isExpanded:true, isTree:true, objectId:"", controller:"", selector:"", menu:"", expandLevel:"", blankIconSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_blank.gif"), gridIconSrcT:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_t.gif"), gridIconSrcL:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_l.gif"), gridIconSrcV:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_v.gif"), gridIconSrcP:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_p.gif"), gridIconSrcC:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_c.gif"), gridIconSrcX:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_x.gif"), gridIconSrcY:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_grid_y.gif"), gridIconSrcZ:dojo.uri.modu!
 leUri("dojo.widget", "templates/images/Tree/treenode_grid_z.gi!
 f"), exp
andIconSrcPlus:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_expand_plus.gif"), expandIconSrcMinus:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_expand_minus.gif"), expandIconSrcLoading:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/treenode_loading.gif"), iconWidth:18, iconHeight:18, showGrid:true, showRootGrid:true, actionIsDisabled:function (action) {
-	var _this = this;
-	return dojo.lang.inArray(_this.actionsDisabled, action);
-}, actions:{ADDCHILD:"ADDCHILD"}, getInfo:function () {
-	var info = {widgetId:this.widgetId, objectId:this.objectId};
-	return info;
-}, initializeController:function () {
-	if (this.controller != "off") {
-		if (this.controller) {
-			this.controller = dojo.widget.byId(this.controller);
+
+}
+dojo.inherits(dojo.widget.Tree, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.Tree, {
+	widgetType: "Tree",
+
+	eventNamesDefault: {
+		// new child does not get domNode filled in (only template draft)
+		// until addChild->createDOMNode is called(program way) OR createDOMNode (html-way)
+		// hook events to operate on new DOMNode, create dropTargets etc
+		createDOMNode: "createDOMNode",
+		// tree created.. Perform tree-wide actions if needed
+		treeCreate: "treeCreate",
+		treeDestroy: "treeDestroy",
+		// expand icon clicked
+		treeClick: "treeClick",
+		// node icon clicked
+		iconClick: "iconClick",
+		// node title clicked
+		titleClick: "titleClick",
+
+		moveFrom: "moveFrom",
+		moveTo: "moveTo",
+		addChild: "addChild",
+		removeNode: "removeNode",
+		expand: "expand",
+		collapse: "collapse"
+	},
+
+	isContainer: true,
+
+	DNDMode: "off",
+
+	lockLevel: 0, // lock ++ unlock --, so nested locking works fine
+
+	strictFolders: true,
+
+	DNDModes: {
+		BETWEEN: 1,
+		ONTO: 2
+	},
+
+	DNDAcceptTypes: "",
+
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/images/Tree/Tree.css"),
+
+	templateString: '<div class="dojoTree"></div>',
+
+	isExpanded: true, // consider this "root node" to be always expanded
+
+	isTree: true,
+
+	objectId: "",
+
+	// autoCreate if not "off"
+	// used to get the autocreated controller ONLY.
+	// generally, tree DOES NOT KNOW about its CONTROLLER, it just doesn't care
+	// controller gets messages via dojo.event
+	controller: "",
+
+	// autoCreate if not "off"
+	// used to get the autocreated selector ONLY.
+	// generally, tree DOES NOT KNOW its SELECTOR
+	// binding is made with dojo.event
+	selector: "",
+
+	// used ONLY at initialization time
+	menu: "", // autobind menu if menu's widgetId is set here
+
+	expandLevel: "", // expand to level automatically
+
+	//
+	// these icons control the grid and expando buttons for the whole tree
+	//
+
+	blankIconSrc: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_blank.gif"),
+
+	gridIconSrcT: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_t.gif"), // for non-last child grid
+	gridIconSrcL: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_l.gif"), // for last child grid
+	gridIconSrcV: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_v.gif"), // vertical line
+	gridIconSrcP: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_p.gif"), // for under parent item child icons
+	gridIconSrcC: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_c.gif"), // for under child item child icons
+	gridIconSrcX: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_x.gif"), // grid for sole root item
+	gridIconSrcY: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_y.gif"), // grid for last rrot item
+	gridIconSrcZ: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_grid_z.gif"), // for under root parent item child icon
+
+	expandIconSrcPlus: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_expand_plus.gif"),
+	expandIconSrcMinus: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_expand_minus.gif"),
+	expandIconSrcLoading: dojo.uri.dojoUri("src/widget/templates/images/Tree/treenode_loading.gif"),
+
+
+	iconWidth: 18,
+	iconHeight: 18,
+
+
+	//
+	// tree options
+	//
+
+	showGrid: true,
+	showRootGrid: true,
+
+	actionIsDisabled: function(action) {
+		var _this = this;
+		return dojo.lang.inArray(_this.actionsDisabled, action)
+	},
+
+
+	actions: {
+    	ADDCHILD: "ADDCHILD"
+	},
+
+
+	getInfo: function() {
+		var info = {
+			widgetId: this.widgetId,
+			objectId: this.objectId
+		}
+
+		return info;
+	},
+
+	initializeController: function() {
+		if (this.controller != "off") {
+			if (this.controller) {
+				this.controller = dojo.widget.byId(this.controller);
+			}
+			else {
+				// create default controller here
+				dojo.require("dojo.widget.TreeBasicController");
+				this.controller = dojo.widget.createWidget("TreeBasicController",
+					{ DNDController: (this.DNDMode ? "create" : ""), dieWithTree: true }
+				 );
+
+			}
+			this.controller.listenTree(this); // controller listens to my events
+
 		} else {
-			dojo.require("dojo.widget.TreeBasicController");
-			this.controller = dojo.widget.createWidget("TreeBasicController", {DNDController:(this.DNDMode ? "create" : ""), dieWithTree:true});
+			this.controller = null;
 		}
-		this.controller.listenTree(this);
-	} else {
-		this.controller = null;
-	}
-}, initializeSelector:function () {
-	if (this.selector != "off") {
-		if (this.selector) {
-			this.selector = dojo.widget.byId(this.selector);
+	},
+
+	initializeSelector: function() {
+
+		if (this.selector != "off") {
+			if (this.selector) {
+				this.selector = dojo.widget.byId(this.selector);
+			}
+			else {
+				// create default controller here
+				dojo.require("dojo.widget.TreeSelector");
+				this.selector = dojo.widget.createWidget("TreeSelector", {dieWithTree: true});
+			}
+
+			this.selector.listenTree(this);
+
 		} else {
-			dojo.require("dojo.widget.TreeSelector");
-			this.selector = dojo.widget.createWidget("TreeSelector", {dieWithTree:true});
+			this.selector = null;
 		}
-		this.selector.listenTree(this);
-	} else {
-		this.selector = null;
-	}
-}, initialize:function (args, frag) {
-	var _this = this;
-	for (name in this.eventNamesDefault) {
-		if (dojo.lang.isUndefined(this.eventNames[name])) {
-			this.eventNames[name] = this.widgetId + "/" + this.eventNamesDefault[name];
+	},
+
+	initialize: function(args, frag){
+
+		var _this = this;
+
+		for(name in this.eventNamesDefault) {
+			if (dojo.lang.isUndefined(this.eventNames[name])) {
+				this.eventNames[name] = this.widgetId+"/"+this.eventNamesDefault[name];
+			}
 		}
-	}
-	for (var i = 0; i < this.actionsDisabled.length; i++) {
-		this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
-	}
-	if (this.DNDMode == "off") {
-		this.DNDMode = 0;
-	} else {
-		if (this.DNDMode == "between") {
+
+		for(var i=0; i<this.actionsDisabled.length; i++) {
+			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
+		}
+
+		if (this.DNDMode == "off") {
+			this.DNDMode = 0;
+		} else if (this.DNDMode == "between") {
 			this.DNDMode = this.DNDModes.ONTO | this.DNDModes.BETWEEN;
+		} else if (this.DNDMode == "onto") {
+			this.DNDMode = this.DNDModes.ONTO;
+		}
+
+		this.expandLevel = parseInt(this.expandLevel);
+
+		this.initializeSelector();
+		this.initializeController();
+
+		if (this.menu) {
+			this.menu = dojo.widget.byId(this.menu);
+			this.menu.listenTree(this);
+		}
+
+
+		this.containerNode = this.domNode;
+
+	},
+
+
+	postCreate: function() {
+		this.createDOMNode();
+	},
+
+
+	createDOMNode: function() {
+
+		dojo.html.disableSelection(this.domNode);
+
+		for(var i=0; i<this.children.length; i++){
+			this.children[i].parent = this; // root nodes have tree as parent
+
+			var node = this.children[i].createDOMNode(this, 0);
+
+
+			this.domNode.appendChild(node);
+		}
+
+
+		if (!this.showRootGrid){
+			for(var i=0; i<this.children.length; i++){
+				this.children[i].expand();
+			}
+		}
+
+		dojo.event.topic.publish(this.eventNames.treeCreate, { source: this } );
+
+	},
+
+
+	destroy: function() {
+		dojo.event.topic.publish(this.tree.eventNames.treeDestroy, { source: this } );
+
+		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
+	},
+
+
+	addChild: function(child, index) {
+
+//		dojo.debug("doAddChild "+index+" called for "+child);
+
+		var message = {
+			child: child,
+			index: index,
+			parent: this,
+			// remember if dom was already initialized
+			// initialized => no createDOMNode => no createDOMNode event
+			domNodeInitialized: child.domNodeInitialized
+		}
+
+		this.doAddChild.apply(this, arguments);
+
+		dojo.event.topic.publish(this.tree.eventNames.addChild, message);
+	},
+
+
+	// not called for initial tree building. See createDOMNode instead.
+	// builds child html node if needed
+	// index is "last node" by default
+	/**
+	 * FIXME: Is it possible that removeNode from the tree will cause leaks cause of attached events ?
+	 * if yes, then only attach events in addChild and detach in remove.. Seems all ok yet.
+	*/
+	doAddChild: function(child, index){
+
+		if (dojo.lang.isUndefined(index)) {
+			index = this.children.length;
+		}
+
+		if (!child.isTreeNode){
+			dojo.raise("You can only add TreeNode widgets to a "+this.widgetType+" widget!");
+			return;
+		}
+
+		// usually it is impossible to change "isFolder" state, but if anyone wants to add a child to leaf,
+		// it is possible program-way.
+		if (this.isTreeNode){
+			if (!this.isFolder) { // just became a folder.
+				//dojo.debug("becoming folder "+this);
+				this.setFolder();
+			}
+		}
+
+		// adjust tree
+		var _this = this;
+		dojo.lang.forEach(child.getDescendants(), function(elem) { elem.tree = _this.tree; });
+
+		// fix parent
+		child.parent = this;
+
+
+		// no dynamic loading for those who become parents
+		if (this.isTreeNode) {
+			this.state = this.loadStates.LOADED;
+		}
+
+		// add new child into DOM after it was added into children
+		if (index < this.children.length) { // children[] already has child
+			//dojo.debug("Inserting before "+this.children[index].title);
+			dojo.dom.insertBefore(child.domNode, this.children[index].domNode);
 		} else {
-			if (this.DNDMode == "onto") {
-				this.DNDMode = this.DNDModes.ONTO;
+			this.containerNode.appendChild(child.domNode);
+			if (this.isExpanded && this.isTreeNode) {
+				/* When I add children to hidden containerNode => show container w/ them */
+				this.showChildren();
 			}
 		}
-	}
-	this.expandLevel = parseInt(this.expandLevel);
-	this.initializeSelector();
-	this.initializeController();
-	if (this.menu) {
-		this.menu = dojo.widget.byId(this.menu);
-		this.menu.listenTree(this);
-	}
-	this.containerNode = this.domNode;
-}, postCreate:function () {
-	this.createDOMNode();
-}, createDOMNode:function () {
-	dojo.html.disableSelection(this.domNode);
-	for (var i = 0; i < this.children.length; i++) {
-		this.children[i].parent = this;
-		var node = this.children[i].createDOMNode(this, 0);
-		this.domNode.appendChild(node);
-	}
-	if (!this.showRootGrid) {
-		for (var i = 0; i < this.children.length; i++) {
-			this.children[i].expand();
+
+
+		this.children.splice(index, 0, child);
+
+		//dojo.debugShallow(this.children);
+
+
+		// if node exists - adjust its depth, otherwise build it
+		if (child.domNodeInitialized) {
+			var d = this.isTreeNode ? this.depth : -1;
+			child.adjustDepth( d - child.depth + 1 );
+
+
+			// update icons to link generated dom with Tree => updateParentGrid
+			// if I moved child from LastNode inside the tree => need to link it up'n'down =>
+			// updateExpandGridColumn
+			// if I change depth => need to update all grid..
+			child.updateIconTree();
+		} else {
+			//dojo.debug("Create domnode ");
+			child.depth = this.isTreeNode ? this.depth+1 : 0;
+			child.createDOMNode(child.tree, child.depth);
 		}
-	}
-	dojo.event.topic.publish(this.eventNames.treeCreate, {source:this});
-}, destroy:function () {
-	dojo.event.topic.publish(this.tree.eventNames.treeDestroy, {source:this});
-	return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
-}, addChild:function (child, index) {
-	var message = {child:child, index:index, parent:this, domNodeInitialized:child.domNodeInitialized};
-	this.doAddChild.apply(this, arguments);
-	dojo.event.topic.publish(this.tree.eventNames.addChild, message);
-}, doAddChild:function (child, index) {
-	if (dojo.lang.isUndefined(index)) {
-		index = this.children.length;
-	}
-	if (!child.isTreeNode) {
-		dojo.raise("You can only add TreeNode widgets to a " + this.widgetType + " widget!");
-		return;
-	}
-	if (this.isTreeNode) {
-		if (!this.isFolder) {
-			this.setFolder();
+
+
+
+		// Use-case:
+		// When previous sibling was created => it was last, no children after it
+		// so it did not create link down => let's add it for all descendants
+		// Use-case:
+		// a child was moved down under the last node so last node should be updated
+		var prevSibling = child.getPreviousSibling();
+		if (child.isLastNode() && prevSibling) {
+			prevSibling.updateExpandGridColumn();
 		}
-	}
-	var _this = this;
-	dojo.lang.forEach(child.getDescendants(), function (elem) {
-		elem.tree = _this.tree;
-	});
-	child.parent = this;
-	if (this.isTreeNode) {
-		this.state = this.loadStates.LOADED;
-	}
-	if (index < this.children.length) {
-		dojo.html.insertBefore(child.domNode, this.children[index].domNode);
-	} else {
-		this.containerNode.appendChild(child.domNode);
-		if (this.isExpanded && this.isTreeNode) {
-			this.showChildren();
+
+
+		//dojo.debug("Added child "+child);
+
+
+
+	},
+
+
+
+
+	makeBlankImg: function() {
+		var img = document.createElement('img');
+
+		img.style.width = this.iconWidth + 'px';
+		img.style.height = this.iconHeight + 'px';
+		img.src = this.blankIconSrc;
+		img.style.verticalAlign = 'middle';
+
+		return img;
+	},
+
+
+	updateIconTree: function(){
+
+		//dojo.debug("Update icons for "+this)
+		if (!this.isTree) {
+			this.updateIcons();
 		}
-	}
-	this.children.splice(index, 0, child);
-	if (child.domNodeInitialized) {
-		var d = this.isTreeNode ? this.depth : -1;
-		child.adjustDepth(d - child.depth + 1);
-		child.updateIconTree();
-	} else {
-		child.depth = this.isTreeNode ? this.depth + 1 : 0;
-		child.createDOMNode(child.tree, child.depth);
-	}
-	var prevSibling = child.getPreviousSibling();
-	if (child.isLastChild() && prevSibling) {
-		prevSibling.updateExpandGridColumn();
-	}
-}, makeBlankImg:function () {
-	var img = document.createElement("img");
-	img.style.width = this.iconWidth + "px";
-	img.style.height = this.iconHeight + "px";
-	img.src = this.blankIconSrc;
-	img.style.verticalAlign = "middle";
-	return img;
-}, updateIconTree:function () {
-	if (!this.isTree) {
-		this.updateIcons();
-	}
-	for (var i = 0; i < this.children.length; i++) {
-		this.children[i].updateIconTree();
-	}
-}, toString:function () {
-	return "[" + this.widgetType + " ID:" + this.widgetId + "]";
-}, move:function (child, newParent, index) {
-	var oldParent = child.parent;
-	var oldTree = child.tree;
-	this.doMove.apply(this, arguments);
-	var newParent = child.parent;
-	var newTree = child.tree;
-	var message = {oldParent:oldParent, oldTree:oldTree, newParent:newParent, newTree:newTree, child:child};
-	dojo.event.topic.publish(oldTree.eventNames.moveFrom, message);
-	dojo.event.topic.publish(newTree.eventNames.moveTo, message);
-}, doMove:function (child, newParent, index) {
-	child.parent.doRemoveNode(child);
-	newParent.doAddChild(child, index);
-}, removeNode:function (child) {
-	if (!child.parent) {
-		return;
-	}
-	var oldTree = child.tree;
-	var oldParent = child.parent;
-	var removedChild = this.doRemoveNode.apply(this, arguments);
-	dojo.event.topic.publish(this.tree.eventNames.removeNode, {child:removedChild, tree:oldTree, parent:oldParent});
-	return removedChild;
-}, doRemoveNode:function (child) {
-	if (!child.parent) {
-		return;
-	}
-	var parent = child.parent;
-	var children = parent.children;
-	var index = child.getParentIndex();
-	if (index < 0) {
-		dojo.raise("Couldn't find node " + child + " for removal");
-	}
-	children.splice(index, 1);
-	dojo.html.removeNode(child.domNode);
-	if (parent.children.length == 0 && !parent.isTree) {
-		parent.containerNode.style.display = "none";
-	}
-	if (index == children.length && index > 0) {
-		children[index - 1].updateExpandGridColumn();
-	}
-	if (parent instanceof dojo.widget.Tree && index == 0 && children.length > 0) {
-		children[0].updateExpandGrid();
-	}
-	child.parent = child.tree = null;
-	return child;
-}, markLoading:function () {
-}, unMarkLoading:function () {
-}, lock:function () {
-	!this.lockLevel && this.markLoading();
-	this.lockLevel++;
-}, unlock:function () {
-	if (!this.lockLevel) {
-		dojo.raise("unlock: not locked");
-	}
-	this.lockLevel--;
-	!this.lockLevel && this.unMarkLoading();
-}, isLocked:function () {
-	var node = this;
-	while (true) {
-		if (node.lockLevel) {
-			return true;
+
+		for(var i=0; i<this.children.length; i++){
+			this.children[i].updateIconTree();
 		}
-		if (node instanceof dojo.widget.Tree) {
-			break;
+
+	},
+
+	toString: function() {
+		return "["+this.widgetType+" ID:"+this.widgetId+"]"
+	},
+
+
+
+
+	/**
+	 * Move child to newParent as last child
+	 * redraw tree and update icons.
+	 *
+	 * Called by target, saves source in event.
+	 * events are published for BOTH trees AFTER update.
+	*/
+	move: function(child, newParent, index) {
+
+		//dojo.debug(child+" "+newParent+" at "+index);
+
+		var oldParent = child.parent;
+		var oldTree = child.tree;
+
+		this.doMove.apply(this, arguments);
+
+		var newParent = child.parent;
+		var newTree = child.tree;
+
+		var message = {
+				oldParent: oldParent, oldTree: oldTree,
+				newParent: newParent, newTree: newTree,
+				child: child
+		};
+
+		/* publish events here about structural changes for both source and target trees */
+		dojo.event.topic.publish(oldTree.eventNames.moveFrom, message);
+		dojo.event.topic.publish(newTree.eventNames.moveTo, message);
+
+	},
+
+
+	/* do actual parent change here. Write remove child first */
+	doMove: function(child, newParent, index) {
+		//var parent = child.parent;
+		child.parent.doRemoveNode(child);
+
+		newParent.doAddChild(child, index);
+	},
+
+
+
+// ================================ removeNode ===================================
+
+	removeNode: function(child) {
+		if (!child.parent) return;
+
+		var oldTree = child.tree;
+		var oldParent = child.parent;
+
+		var removedChild = this.doRemoveNode.apply(this, arguments);
+
+
+		dojo.event.topic.publish(this.tree.eventNames.removeNode,
+			{ child: removedChild, tree: oldTree, parent: oldParent }
+		);
+
+		return removedChild;
+	},
+
+
+	doRemoveNode: function(child) {
+		if (!child.parent) return;
+
+		var parent = child.parent;
+
+		var children = parent.children;
+
+
+		var index = child.getParentIndex();
+		if (index < 0) {
+			dojo.raise("Couldn't find node "+child+" for removal");
 		}
-		node = node.parent;
+
+
+		children.splice(index,1);
+		dojo.dom.removeNode(child.domNode);
+
+		if (parent.children.length == 0) {
+			parent.containerNode.style.display = "none";
+		}
+
+		// if WAS last node (children.length decreased already) and has prevSibling
+		if (index == children.length && index>0) {
+			children[index-1].updateExpandGridColumn();
+		}
+		// if it WAS first node in WHOLE TREE -
+		// update link up of its former lower neighbour(if exists still)
+		if (parent instanceof dojo.widget.Tree && index == 0 && children.length>0) {
+			children[0].updateExpandGrid();
+		}
+
+		//parent.updateIconTree();
+
+
+		child.parent = child.tree = null;
+
+		return child;
+	},
+
+	markLoading: function() {
+		// no way to mark tree loading
+	},
+
+	unMarkLoading: function() {
+		// no way to show that tree finished loading
+	},
+
+
+	lock: function() {
+		!this.lockLevel && this.markLoading();
+		this.lockLevel++;
+	},
+	unlock: function() {
+		if (!this.lockLevel) {
+			dojo.raise("unlock: not locked");
+		}
+		this.lockLevel--;
+		!this.lockLevel && this.unMarkLoading();
+	},
+
+	isLocked: function() {
+		var node = this;
+		while (true) {
+			if (node.lockLevel) {
+				return true;
+			}
+			if (node instanceof dojo.widget.Tree) {
+				break;
+			}
+			node = node.parent;
+		}
+
+		return false;
+	},
+
+	flushLock: function() {
+		this.lockLevel = 0;
+		this.unMarkLoading();
 	}
-	return false;
-}, flushLock:function () {
-	this.lockLevel = 0;
-	this.unMarkLoading();
-}});
+});
 
+

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeBasicController.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeBasicController.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeBasicController.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -9,146 +9,286 @@
 */
 
 
+dojo.provide("dojo.widget.TreeBasicController");
 
-dojo.provide("dojo.widget.TreeBasicController");
 dojo.require("dojo.event.*");
-dojo.require("dojo.json");
+dojo.require("dojo.json")
 dojo.require("dojo.io.*");
-dojo.widget.defineWidget("dojo.widget.TreeBasicController", dojo.widget.HtmlWidget, {widgetType:"TreeBasicController", DNDController:"", dieWithTree:false, initialize:function (args, frag) {
-	if (this.DNDController == "create") {
-		dojo.require("dojo.dnd.TreeDragAndDrop");
-		this.DNDController = new dojo.dnd.TreeDNDController(this);
-	}
-}, listenTree:function (tree) {
-	dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
-	dojo.event.topic.subscribe(tree.eventNames.treeClick, this, "onTreeClick");
-	dojo.event.topic.subscribe(tree.eventNames.treeCreate, this, "onTreeCreate");
-	dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-	if (this.DNDController) {
-		this.DNDController.listenTree(tree);
-	}
-}, unlistenTree:function (tree) {
-	dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
-	dojo.event.topic.unsubscribe(tree.eventNames.treeClick, this, "onTreeClick");
-	dojo.event.topic.unsubscribe(tree.eventNames.treeCreate, this, "onTreeCreate");
-	dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-}, onTreeDestroy:function (message) {
-	var tree = message.source;
-	this.unlistenTree(tree);
-	if (this.dieWithTree) {
-		this.destroy();
-	}
-}, onCreateDOMNode:function (message) {
-	var node = message.source;
-	if (node.expandLevel > 0) {
-		this.expandToLevel(node, node.expandLevel);
-	}
-}, onTreeCreate:function (message) {
-	var tree = message.source;
-	var _this = this;
-	if (tree.expandLevel) {
-		dojo.lang.forEach(tree.children, function (child) {
-			_this.expandToLevel(child, tree.expandLevel - 1);
-		});
-	}
-}, expandToLevel:function (node, level) {
-	if (level == 0) {
-		return;
-	}
-	var children = node.children;
-	var _this = this;
-	var handler = function (node, expandLevel) {
-		this.node = node;
-		this.expandLevel = expandLevel;
-		this.process = function () {
-			for (var i = 0; i < this.node.children.length; i++) {
-				var child = node.children[i];
-				_this.expandToLevel(child, this.expandLevel);
+
+
+dojo.widget.tags.addParseTreeHandler("dojo:TreeBasicController");
+
+
+dojo.widget.TreeBasicController = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.TreeBasicController, dojo.widget.HtmlWidget);
+
+
+dojo.lang.extend(dojo.widget.TreeBasicController, {
+	widgetType: "TreeBasicController",
+
+	DNDController: "",
+
+	dieWithTree: false,
+
+	initialize: function(args, frag){
+
+		/* no DND by default for compatibility */
+		if (this.DNDController == "create") {
+			dojo.require("dojo.dnd.TreeDragAndDrop");
+			this.DNDController = new dojo.dnd.TreeDNDController(this);
+		}
+
+
+
+	},
+
+
+	/**
+	 * Binds controller to all tree events
+	*/
+	listenTree: function(tree) {
+		//dojo.debug("Event "+tree.eventNames.treeClick);
+		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
+		dojo.event.topic.subscribe(tree.eventNames.treeClick, this, "onTreeClick");
+		dojo.event.topic.subscribe(tree.eventNames.treeCreate, this, "onTreeCreate");
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+
+		if (this.DNDController) {
+			this.DNDController.listenTree(tree);
+		}
+	},
+
+	unlistenTree: function(tree) {
+		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
+		dojo.event.topic.unsubscribe(tree.eventNames.treeClick, this, "onTreeClick");
+		dojo.event.topic.unsubscribe(tree.eventNames.treeCreate, this, "onTreeCreate");
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+	},
+
+	onTreeDestroy: function(message) {
+		var tree = message.source;
+
+		this.unlistenTree(tree);
+
+		if (this.dieWithTree) {
+			//alert("Killing myself "+this.widgetId);
+			this.destroy();
+			//dojo.debug("done");
+		}
+	},
+
+	onCreateDOMNode: function(message) {
+
+		var node = message.source;
+
+
+		if (node.expandLevel > 0) {
+			this.expandToLevel(node, node.expandLevel);
+		}
+	},
+
+	// perform actions-initializers for tree
+	onTreeCreate: function(message) {
+		var tree = message.source;
+		var _this = this;
+		if (tree.expandLevel) {
+			dojo.lang.forEach(tree.children,
+				function(child) {
+					_this.expandToLevel(child, tree.expandLevel-1)
+				}
+			);
+		}
+	},
+
+	expandToLevel: function(node, level) {
+		if (level == 0) return;
+
+		var children = node.children;
+		var _this = this;
+
+		var handler = function(node, expandLevel) {
+			this.node = node;
+			this.expandLevel = expandLevel;
+			// recursively expand opened node
+			this.process = function() {
+				//dojo.debug("Process "+node+" level "+level);
+				for(var i=0; i<this.node.children.length; i++) {
+					var child = node.children[i];
+
+					_this.expandToLevel(child, this.expandLevel);
+				}
+			};
+		}
+
+		var h = new handler(node, level-1);
+
+
+		this.expand(node, false, h, h.process);
+
+	},
+
+
+
+
+	onTreeClick: function(message){
+		var node = message.source;
+
+		if(node.isLocked()) {
+			return false;
+		}
+
+		if (node.isExpanded){
+			this.collapse(node);
+		} else {
+			this.expand(node);
+		}
+	},
+
+	expand: function(node, sync, callObj, callFunc) {
+		node.expand();
+		if (callFunc) callFunc.apply(callObj, [node]);
+	},
+
+	collapse: function(node) {
+
+		node.collapse();
+	},
+
+// =============================== move ============================
+
+	/**
+	 * Checks whether it is ok to change parent of child to newParent
+	 * May incur type checks etc
+	 *
+	 * It should check only hierarchical possibility w/o index, etc
+	 * because in onDragOver event for Between DND mode we can't calculate index at once on onDragOVer.
+	 * index changes as client moves mouse up-down over the node
+	 */
+	canMove: function(child, newParent){
+
+		if (child.actionIsDisabled(child.actions.MOVE)) {
+			return false;
+		}
+
+		// if we move under same parent then no matter if ADDCHILD disabled for him
+		// but if we move to NEW parent then check if action is disabled for him
+		// also covers case for newParent being a non-folder in strict mode etc
+		if (child.parent !== newParent && newParent.actionIsDisabled(newParent.actions.ADDCHILD)) {
+			return false;
+		}
+
+		// Can't move parent under child. check whether new parent is child of "child".
+		var node = newParent;
+		while(node.isTreeNode) {
+			//dojo.debugShallow(node.title)
+			if (node === child) {
+				// parent of newParent is child
+				return false;
 			}
-		};
-	};
-	var h = new handler(node, level - 1);
-	this.expand(node, false, h, h.process);
-}, onTreeClick:function (message) {
-	var node = message.source;
-	if (node.isLocked()) {
-		return false;
-	}
-	if (node.isExpanded) {
-		this.collapse(node);
-	} else {
-		this.expand(node);
-	}
-}, expand:function (node, sync, callObj, callFunc) {
-	node.expand();
-	if (callFunc) {
-		callFunc.apply(callObj, [node]);
-	}
-}, collapse:function (node) {
-	node.collapse();
-}, canMove:function (child, newParent) {
-	if (child.actionIsDisabled(child.actions.MOVE)) {
-		return false;
-	}
-	if (child.parent !== newParent && newParent.actionIsDisabled(newParent.actions.ADDCHILD)) {
-		return false;
-	}
-	var node = newParent;
-	while (node.isTreeNode) {
-		if (node === child) {
+			node = node.parent;
+		}
+
+		return true;
+	},
+
+
+	move: function(child, newParent, index) {
+
+		/* move sourceTreeNode to new parent */
+		if (!this.canMove(child, newParent)) {
 			return false;
 		}
-		node = node.parent;
-	}
-	return true;
-}, move:function (child, newParent, index) {
-	if (!this.canMove(child, newParent)) {
-		return false;
-	}
-	var result = this.doMove(child, newParent, index);
-	if (!result) {
+
+		var result = this.doMove(child, newParent, index);
+
+		if (!result) return result;
+
+		if (newParent.isTreeNode) {
+			this.expand(newParent);
+		}
+
 		return result;
+	},
+
+	doMove: function(child, newParent, index) {
+		child.tree.move(child, newParent, index);
+
+		return true;
+	},
+
+// =============================== removeNode ============================
+
+
+	canRemoveNode: function(child) {
+		if (child.actionIsDisabled(child.actions.REMOVE)) {
+			return false;
+		}
+
+		return true;
+	},
+
+
+	removeNode: function(node, callObj, callFunc) {
+		if (!this.canRemoveNode(node)) {
+			return false;
+		}
+
+		return this.doRemoveNode(node, callObj, callFunc);
+	},
+
+
+	doRemoveNode: function(node, callObj, callFunc) {
+		node.tree.removeNode(node);
+
+		if (callFunc) {
+			callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node]);
+		}
+	},
+
+
+	// -----------------------------------------------------------------------------
+	//                             Create node stuff
+	// -----------------------------------------------------------------------------
+
+
+	canCreateChild: function(parent, index, data) {
+		if (parent.actionIsDisabled(parent.actions.ADDCHILD)) return false;
+
+		return true;
+	},
+
+
+	/* send data to server and add child from server */
+	/* data may contain an almost ready child, or anything else, suggested to server */
+	/*in RPC controllers server responds with child data to be inserted */
+	createChild: function(parent, index, data, callObj, callFunc) {
+		if (!this.canCreateChild(parent, index, data)) {
+			return false;
+		}
+
+		return this.doCreateChild.apply(this, arguments);
+	},
+
+	doCreateChild: function(parent, index, data, callObj, callFunc) {
+
+		var widgetType = data.widgetType ? data.widgetType : "TreeNode";
+
+		var newChild = dojo.widget.createWidget(widgetType, data);
+
+		parent.addChild(newChild, index);
+
+		this.expand(parent);
+
+		if (callFunc) {
+			callFunc.apply(callObj, [newChild]);
+		}
+
+		return newChild;
 	}
-	if (newParent.isTreeNode) {
-		this.expand(newParent);
-	}
-	return result;
-}, doMove:function (child, newParent, index) {
-	child.tree.move(child, newParent, index);
-	return true;
-}, canRemoveNode:function (child) {
-	if (child.actionIsDisabled(child.actions.REMOVE)) {
-		return false;
-	}
-	return true;
-}, removeNode:function (node, callObj, callFunc) {
-	if (!this.canRemoveNode(node)) {
-		return false;
-	}
-	return this.doRemoveNode(node, callObj, callFunc);
-}, doRemoveNode:function (node, callObj, callFunc) {
-	node.tree.removeNode(node);
-	if (callFunc) {
-		callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node]);
-	}
-}, canCreateChild:function (parent, index, data) {
-	if (parent.actionIsDisabled(parent.actions.ADDCHILD)) {
-		return false;
-	}
-	return true;
-}, createChild:function (parent, index, data, callObj, callFunc) {
-	if (!this.canCreateChild(parent, index, data)) {
-		return false;
-	}
-	return this.doCreateChild.apply(this, arguments);
-}, doCreateChild:function (parent, index, data, callObj, callFunc) {
-	var widgetType = data.widgetType ? data.widgetType : "TreeNode";
-	var newChild = dojo.widget.createWidget(widgetType, data);
-	parent.addChild(newChild, index);
-	this.expand(parent);
-	if (callFunc) {
-		callFunc.apply(callObj, [newChild]);
-	}
-	return newChild;
-}});
 
+
+
+});

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeBasicControllerV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeBasicControllerV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeBasicControllerV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,461 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeBasicControllerV3");
-dojo.require("dojo.event.*");
-dojo.require("dojo.json");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.TreeCommon");
-dojo.require("dojo.widget.TreeNodeV3");
-dojo.require("dojo.widget.TreeV3");
-dojo.widget.defineWidget("dojo.widget.TreeBasicControllerV3", [dojo.widget.HtmlWidget, dojo.widget.TreeCommon], function () {
-	this.listenedTrees = {};
-}, {listenTreeEvents:["afterSetFolder", "afterTreeCreate", "beforeTreeDestroy"], listenNodeFilter:function (elem) {
-	return elem instanceof dojo.widget.Widget;
-}, editor:null, initialize:function (args) {
-	if (args.editor) {
-		this.editor = dojo.widget.byId(args.editor);
-		this.editor.controller = this;
-	}
-}, getInfo:function (elem) {
-	return elem.getInfo();
-}, onBeforeTreeDestroy:function (message) {
-	this.unlistenTree(message.source);
-}, onAfterSetFolder:function (message) {
-	if (message.source.expandLevel > 0) {
-		this.expandToLevel(message.source, message.source.expandLevel);
-	}
-	if (message.source.loadLevel > 0) {
-		this.loadToLevel(message.source, message.source.loadLevel);
-	}
-}, _focusNextVisible:function (nodeWidget) {
-	if (nodeWidget.isFolder && nodeWidget.isExpanded && nodeWidget.children.length > 0) {
-		returnWidget = nodeWidget.children[0];
-	} else {
-		while (nodeWidget.isTreeNode && nodeWidget.isLastChild()) {
-			nodeWidget = nodeWidget.parent;
-		}
-		if (nodeWidget.isTreeNode) {
-			var returnWidget = nodeWidget.parent.children[nodeWidget.getParentIndex() + 1];
-		}
-	}
-	if (returnWidget && returnWidget.isTreeNode) {
-		this._focusLabel(returnWidget);
-		return returnWidget;
-	}
-}, _focusPreviousVisible:function (nodeWidget) {
-	var returnWidget = nodeWidget;
-	if (!nodeWidget.isFirstChild()) {
-		var previousSibling = nodeWidget.parent.children[nodeWidget.getParentIndex() - 1];
-		nodeWidget = previousSibling;
-		while (nodeWidget.isFolder && nodeWidget.isExpanded && nodeWidget.children.length > 0) {
-			returnWidget = nodeWidget;
-			nodeWidget = nodeWidget.children[nodeWidget.children.length - 1];
-		}
-	} else {
-		nodeWidget = nodeWidget.parent;
-	}
-	if (nodeWidget && nodeWidget.isTreeNode) {
-		returnWidget = nodeWidget;
-	}
-	if (returnWidget && returnWidget.isTreeNode) {
-		this._focusLabel(returnWidget);
-		return returnWidget;
-	}
-}, _focusZoomIn:function (nodeWidget) {
-	var returnWidget = nodeWidget;
-	if (nodeWidget.isFolder && !nodeWidget.isExpanded) {
-		this.expand(nodeWidget);
-	} else {
-		if (nodeWidget.children.length > 0) {
-			nodeWidget = nodeWidget.children[0];
-		}
-	}
-	if (nodeWidget && nodeWidget.isTreeNode) {
-		returnWidget = nodeWidget;
-	}
-	if (returnWidget && returnWidget.isTreeNode) {
-		this._focusLabel(returnWidget);
-		return returnWidget;
-	}
-}, _focusZoomOut:function (node) {
-	var returnWidget = node;
-	if (node.isFolder && node.isExpanded) {
-		this.collapse(node);
-	} else {
-		node = node.parent;
-	}
-	if (node && node.isTreeNode) {
-		returnWidget = node;
-	}
-	if (returnWidget && returnWidget.isTreeNode) {
-		this._focusLabel(returnWidget);
-		return returnWidget;
-	}
-}, onFocusNode:function (e) {
-	var node = this.domElement2TreeNode(e.target);
-	if (node) {
-		node.viewFocus();
-		dojo.event.browser.stopEvent(e);
-	}
-}, onBlurNode:function (e) {
-	var node = this.domElement2TreeNode(e.target);
-	if (!node) {
-		return;
-	}
-	var labelNode = node.labelNode;
-	labelNode.setAttribute("tabIndex", "-1");
-	node.viewUnfocus();
-	dojo.event.browser.stopEvent(e);
-	node.tree.domNode.setAttribute("tabIndex", "0");
-}, _focusLabel:function (node) {
-	var lastFocused = node.tree.lastFocused;
-	var labelNode;
-	if (lastFocused && lastFocused.labelNode) {
-		labelNode = lastFocused.labelNode;
-		dojo.event.disconnect(labelNode, "onblur", this, "onBlurNode");
-		labelNode.setAttribute("tabIndex", "-1");
-		dojo.html.removeClass(labelNode, "TreeLabelFocused");
-	}
-	labelNode = node.labelNode;
-	labelNode.setAttribute("tabIndex", "0");
-	node.tree.lastFocused = node;
-	dojo.html.addClass(labelNode, "TreeLabelFocused");
-	dojo.event.connectOnce(labelNode, "onblur", this, "onBlurNode");
-	dojo.event.connectOnce(labelNode, "onfocus", this, "onFocusNode");
-	labelNode.focus();
-}, onKey:function (e) {
-	if (!e.key || e.ctrkKey || e.altKey) {
-		return;
-	}
-	var nodeWidget = this.domElement2TreeNode(e.target);
-	if (!nodeWidget) {
-		return;
-	}
-	var treeWidget = nodeWidget.tree;
-	if (treeWidget.lastFocused && treeWidget.lastFocused.labelNode) {
-		nodeWidget = treeWidget.lastFocused;
-	}
-	switch (e.key) {
-	  case e.KEY_TAB:
-		if (e.shiftKey) {
-			treeWidget.domNode.setAttribute("tabIndex", "-1");
-		}
-		break;
-	  case e.KEY_RIGHT_ARROW:
-		this._focusZoomIn(nodeWidget);
-		dojo.event.browser.stopEvent(e);
-		break;
-	  case e.KEY_LEFT_ARROW:
-		this._focusZoomOut(nodeWidget);
-		dojo.event.browser.stopEvent(e);
-		break;
-	  case e.KEY_UP_ARROW:
-		this._focusPreviousVisible(nodeWidget);
-		dojo.event.browser.stopEvent(e);
-		break;
-	  case e.KEY_DOWN_ARROW:
-		this._focusNextVisible(nodeWidget);
-		dojo.event.browser.stopEvent(e);
-		break;
-	}
-}, onFocusTree:function (e) {
-	if (!e.currentTarget) {
-		return;
-	}
-	try {
-		var treeWidget = this.getWidgetByNode(e.currentTarget);
-		if (!treeWidget || !treeWidget.isTree) {
-			return;
-		}
-		var nodeWidget = this.getWidgetByNode(treeWidget.domNode.firstChild);
-		if (nodeWidget && nodeWidget.isTreeNode) {
-			if (treeWidget.lastFocused && treeWidget.lastFocused.isTreeNode) {
-				nodeWidget = treeWidget.lastFocused;
-			}
-			this._focusLabel(nodeWidget);
-		}
-	}
-	catch (e) {
-	}
-}, onAfterTreeCreate:function (message) {
-	var tree = message.source;
-	dojo.event.browser.addListener(tree.domNode, "onKey", dojo.lang.hitch(this, this.onKey));
-	dojo.event.browser.addListener(tree.domNode, "onmousedown", dojo.lang.hitch(this, this.onTreeMouseDown));
-	dojo.event.browser.addListener(tree.domNode, "onclick", dojo.lang.hitch(this, this.onTreeClick));
-	dojo.event.browser.addListener(tree.domNode, "onfocus", dojo.lang.hitch(this, this.onFocusTree));
-	tree.domNode.setAttribute("tabIndex", "0");
-	if (tree.expandLevel) {
-		this.expandToLevel(tree, tree.expandLevel);
-	}
-	if (tree.loadLevel) {
-		this.loadToLevel(tree, tree.loadLevel);
-	}
-}, onTreeMouseDown:function (e) {
-}, onTreeClick:function (e) {
-	var domElement = e.target;
-	var node = this.domElement2TreeNode(domElement);
-	if (!node || !node.isTreeNode) {
-		return;
-	}
-	var checkExpandClick = function (el) {
-		return el === node.expandNode;
-	};
-	if (this.checkPathCondition(domElement, checkExpandClick)) {
-		this.processExpandClick(node);
-	}
-	this._focusLabel(node);
-}, processExpandClick:function (node) {
-	if (node.isExpanded) {
-		this.collapse(node);
-	} else {
-		this.expand(node);
-	}
-}, batchExpandTimeout:20, expandAll:function (nodeOrTree) {
-	return this.expandToLevel(nodeOrTree, Number.POSITIVE_INFINITY);
-}, collapseAll:function (nodeOrTree) {
-	var _this = this;
-	var filter = function (elem) {
-		return (elem instanceof dojo.widget.Widget) && elem.isFolder && elem.isExpanded;
-	};
-	if (nodeOrTree.isTreeNode) {
-		this.processDescendants(nodeOrTree, filter, this.collapse);
-	} else {
-		if (nodeOrTree.isTree) {
-			dojo.lang.forEach(nodeOrTree.children, function (c) {
-				_this.processDescendants(c, filter, _this.collapse);
-			});
-		}
-	}
-}, expandToNode:function (node, withSelected) {
-	n = withSelected ? node : node.parent;
-	s = [];
-	while (!n.isExpanded) {
-		s.push(n);
-		n = n.parent;
-	}
-	dojo.lang.forEach(s, function (n) {
-		n.expand();
-	});
-}, expandToLevel:function (nodeOrTree, level) {
-	dojo.require("dojo.widget.TreeTimeoutIterator");
-	var _this = this;
-	var filterFunc = function (elem) {
-		var res = elem.isFolder || elem.children && elem.children.length;
-		return res;
-	};
-	var callFunc = function (node, iterator) {
-		_this.expand(node, true);
-		iterator.forward();
-	};
-	var iterator = new dojo.widget.TreeTimeoutIterator(nodeOrTree, callFunc, this);
-	iterator.setFilter(filterFunc);
-	iterator.timeout = this.batchExpandTimeout;
-	iterator.setMaxLevel(nodeOrTree.isTreeNode ? level - 1 : level);
-	return iterator.start(nodeOrTree.isTreeNode);
-}, getWidgetByNode:function (node) {
-	var widgetId;
-	var newNode = node;
-	while (!(widgetId = newNode.widgetId)) {
-		newNode = newNode.parentNode;
-		if (newNode == null) {
-			break;
-		}
-	}
-	if (widgetId) {
-		return dojo.widget.byId(widgetId);
-	} else {
-		if (node == null) {
-			return null;
-		} else {
-			return dojo.widget.manager.byNode(node);
-		}
-	}
-}, expand:function (node) {
-	if (node.isFolder) {
-		node.expand();
-	}
-}, collapse:function (node) {
-	if (node.isFolder) {
-		node.collapse();
-	}
-}, canEditLabel:function (node) {
-	if (node.actionIsDisabledNow(node.actions.EDIT)) {
-		return false;
-	}
-	return true;
-}, editLabelStart:function (node) {
-	if (!this.canEditLabel(node)) {
-		return false;
-	}
-	if (!this.editor.isClosed()) {
-		this.editLabelFinish(this.editor.saveOnBlur);
-	}
-	this.doEditLabelStart(node);
-}, editLabelFinish:function (save) {
-	this.doEditLabelFinish(save);
-}, doEditLabelStart:function (node) {
-	if (!this.editor) {
-		dojo.raise(this.widgetType + ": no editor specified");
-	}
-	this.editor.open(node);
-}, doEditLabelFinish:function (save, server_data) {
-	if (!this.editor) {
-		dojo.raise(this.widgetType + ": no editor specified");
-	}
-	var node = this.editor.node;
-	var editorTitle = this.editor.getContents();
-	this.editor.close(save);
-	if (save) {
-		var data = {title:editorTitle};
-		if (server_data) {
-			dojo.lang.mixin(data, server_data);
-		}
-		if (node.isPhantom) {
-			var parent = node.parent;
-			var index = node.getParentIndex();
-			node.destroy();
-			dojo.widget.TreeBasicControllerV3.prototype.doCreateChild.call(this, parent, index, data);
-		} else {
-			var title = server_data && server_data.title ? server_data.title : editorTitle;
-			node.setTitle(title);
-		}
-	} else {
-		if (node.isPhantom) {
-			node.destroy();
-		}
-	}
-}, makeDefaultNode:function (parent, index) {
-	var data = {title:parent.tree.defaultChildTitle};
-	return dojo.widget.TreeBasicControllerV3.prototype.doCreateChild.call(this, parent, index, data);
-}, runStages:function (check, prepare, make, finalize, expose, args) {
-	if (check && !check.apply(this, args)) {
-		return false;
-	}
-	if (prepare && !prepare.apply(this, args)) {
-		return false;
-	}
-	var result = make.apply(this, args);
-	if (finalize) {
-		finalize.apply(this, args);
-	}
-	if (!result) {
-		return result;
-	}
-	if (expose) {
-		expose.apply(this, args);
-	}
-	return result;
-}});
-dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {createAndEdit:function (parent, index) {
-	var data = {title:parent.tree.defaultChildTitle};
-	if (!this.canCreateChild(parent, index, data)) {
-		return false;
-	}
-	var child = this.doCreateChild(parent, index, data);
-	if (!child) {
-		return false;
-	}
-	this.exposeCreateChild(parent, index, data);
-	child.isPhantom = true;
-	if (!this.editor.isClosed()) {
-		this.editLabelFinish(this.editor.saveOnBlur);
-	}
-	this.doEditLabelStart(child);
-}});
-dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {canClone:function (child, newParent, index, deep) {
-	return true;
-}, clone:function (child, newParent, index, deep) {
-	return this.runStages(this.canClone, this.prepareClone, this.doClone, this.finalizeClone, this.exposeClone, arguments);
-}, exposeClone:function (child, newParent) {
-	if (newParent.isTreeNode) {
-		this.expand(newParent);
-	}
-}, doClone:function (child, newParent, index, deep) {
-	var cloned = child.clone(deep);
-	newParent.addChild(cloned, index);
-	return cloned;
-}});
-dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {canDetach:function (child) {
-	if (child.actionIsDisabledNow(child.actions.DETACH)) {
-		return false;
-	}
-	return true;
-}, detach:function (node) {
-	return this.runStages(this.canDetach, this.prepareDetach, this.doDetach, this.finalizeDetach, this.exposeDetach, arguments);
-}, doDetach:function (node, callObj, callFunc) {
-	node.detach();
-}});
-dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {canDestroyChild:function (child) {
-	if (child.parent && !this.canDetach(child)) {
-		return false;
-	}
-	return true;
-}, destroyChild:function (node) {
-	return this.runStages(this.canDestroyChild, this.prepareDestroyChild, this.doDestroyChild, this.finalizeDestroyChild, this.exposeDestroyChild, arguments);
-}, doDestroyChild:function (node) {
-	node.destroy();
-}});
-dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {canMoveNotANode:function (child, parent) {
-	if (child.treeCanMove) {
-		return child.treeCanMove(parent);
-	}
-	return true;
-}, canMove:function (child, newParent) {
-	if (!child.isTreeNode) {
-		return this.canMoveNotANode(child, newParent);
-	}
-	if (child.actionIsDisabledNow(child.actions.MOVE)) {
-		return false;
-	}
-	if (child.parent !== newParent && newParent.actionIsDisabledNow(newParent.actions.ADDCHILD)) {
-		return false;
-	}
-	var node = newParent;
-	while (node.isTreeNode) {
-		if (node === child) {
-			return false;
-		}
-		node = node.parent;
-	}
-	return true;
-}, move:function (child, newParent, index) {
-	return this.runStages(this.canMove, this.prepareMove, this.doMove, this.finalizeMove, this.exposeMove, arguments);
-}, doMove:function (child, newParent, index) {
-	child.tree.move(child, newParent, index);
-	return true;
-}, exposeMove:function (child, newParent) {
-	if (newParent.isTreeNode) {
-		this.expand(newParent);
-	}
-}});
-dojo.lang.extend(dojo.widget.TreeBasicControllerV3, {canCreateChild:function (parent, index, data) {
-	if (parent.actionIsDisabledNow(parent.actions.ADDCHILD)) {
-		return false;
-	}
-	return true;
-}, createChild:function (parent, index, data) {
-	if (!data) {
-		data = {title:parent.tree.defaultChildTitle};
-	}
-	return this.runStages(this.canCreateChild, this.prepareCreateChild, this.doCreateChild, this.finalizeCreateChild, this.exposeCreateChild, [parent, index, data]);
-}, prepareCreateChild:function () {
-	return true;
-}, finalizeCreateChild:function () {
-}, doCreateChild:function (parent, index, data) {
-	var newChild = parent.tree.createNode(data);
-	parent.addChild(newChild, index);
-	return newChild;
-}, exposeCreateChild:function (parent) {
-	return this.expand(parent);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeCommon.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeCommon.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeCommon.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,82 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeCommon");
-dojo.require("dojo.widget.*");
-dojo.declare("dojo.widget.TreeCommon", null, {listenTreeEvents:[], listenedTrees:{}, listenNodeFilter:null, listenTree:function (tree) {
-	var _this = this;
-	if (this.listenedTrees[tree.widgetId]) {
-		return;
-	}
-	dojo.lang.forEach(this.listenTreeEvents, function (event) {
-		var eventHandler = "on" + event.charAt(0).toUpperCase() + event.substr(1);
-		dojo.event.topic.subscribe(tree.eventNames[event], _this, eventHandler);
-	});
-	var filter;
-	if (this.listenNodeFilter) {
-		this.processDescendants(tree, this.listenNodeFilter, this.listenNode, true);
-	}
-	this.listenedTrees[tree.widgetId] = true;
-}, listenNode:function () {
-}, unlistenNode:function () {
-}, unlistenTree:function (tree, nodeFilter) {
-	var _this = this;
-	if (!this.listenedTrees[tree.widgetId]) {
-		return;
-	}
-	dojo.lang.forEach(this.listenTreeEvents, function (event) {
-		var eventHandler = "on" + event.charAt(0).toUpperCase() + event.substr(1);
-		dojo.event.topic.unsubscribe(tree.eventNames[event], _this, eventHandler);
-	});
-	if (this.listenNodeFilter) {
-		this.processDescendants(tree, this.listenNodeFilter, this.unlistenNode, true);
-	}
-	delete this.listenedTrees[tree.widgetId];
-}, checkPathCondition:function (domElement, condition) {
-	while (domElement && !domElement.widgetId) {
-		if (condition.call(null, domElement)) {
-			return true;
-		}
-		domElement = domElement.parentNode;
-	}
-	return false;
-}, domElement2TreeNode:function (domElement) {
-	while (domElement && !domElement.widgetId) {
-		domElement = domElement.parentNode;
-	}
-	if (!domElement) {
-		return null;
-	}
-	var widget = dojo.widget.byId(domElement.widgetId);
-	if (!widget.isTreeNode) {
-		return null;
-	}
-	return widget;
-}, processDescendants:function (elem, filter, func, skipFirst) {
-	var _this = this;
-	if (!skipFirst) {
-		if (!filter.call(_this, elem)) {
-			return;
-		}
-		func.call(_this, elem);
-	}
-	var stack = [elem];
-	while (elem = stack.pop()) {
-		dojo.lang.forEach(elem.children, function (elem) {
-			if (filter.call(_this, elem)) {
-				func.call(_this, elem);
-				stack.push(elem);
-			}
-		});
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeContextMenu.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeContextMenu.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeContextMenu.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -11,100 +11,204 @@
 
 
 dojo.provide("dojo.widget.TreeContextMenu");
+dojo.provide("dojo.widget.TreeMenuItem");
+
 dojo.require("dojo.event.*");
 dojo.require("dojo.io.*");
 dojo.require("dojo.widget.Menu2");
-dojo.widget.defineWidget("dojo.widget.TreeContextMenu", dojo.widget.PopupMenu2, function () {
+
+
+dojo.widget.tags.addParseTreeHandler("dojo:TreeContextMenu");
+dojo.widget.tags.addParseTreeHandler("dojo:TreeMenuItem");
+
+
+
+dojo.widget.TreeContextMenu = function() {
+	dojo.widget.PopupMenu2.call(this);
+
 	this.listenedTrees = [];
-}, {open:function (x, y, parentMenu, explodeSrc) {
-	var result = dojo.widget.PopupMenu2.prototype.open.apply(this, arguments);
-	dojo.event.topic.publish(this.eventNames.open, {menu:this});
-	return result;
-}, listenTree:function (tree) {
-	var nodes = tree.getDescendants();
-	for (var i = 0; i < nodes.length; i++) {
-		if (!nodes[i].isTreeNode) {
-			continue;
+
+}
+
+
+dojo.inherits(dojo.widget.TreeContextMenu, dojo.widget.PopupMenu2);
+
+dojo.lang.extend(dojo.widget.TreeContextMenu, {
+
+	widgetType: "TreeContextMenu",
+
+	open: function(x, y, parentMenu, explodeSrc){
+
+		var result = dojo.widget.PopupMenu2.prototype.open.apply(this, arguments);
+
+		/* publish many events here about structural changes */
+		dojo.event.topic.publish(this.eventNames.open, { menu:this });
+
+		return result;
+	},
+
+	listenTree: function(tree) {
+		/* add context menu to all nodes that exist already */
+		var nodes = tree.getDescendants();
+
+		for(var i=0; i<nodes.length; i++) {
+			if (!nodes[i].isTreeNode) continue;
+			this.bindDomNode(nodes[i].labelNode);
 		}
-		this.bindDomNode(nodes[i].labelNode);
-	}
-	var _this = this;
-	dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
-	dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
-	dojo.event.topic.subscribe(tree.eventNames.moveTo, this, "onMoveTo");
-	dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
-	dojo.event.topic.subscribe(tree.eventNames.addChild, this, "onAddChild");
-	dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-	this.listenedTrees.push(tree);
-}, unlistenTree:function (tree) {
-	dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
-	dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
-	dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, "onMoveTo");
-	dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
-	dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, "onAddChild");
-	dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-	for (var i = 0; i < this.listenedTrees.length; i++) {
-		if (this.listenedTrees[i] === tree) {
-			this.listenedTrees.splice(i, 1);
-			break;
+
+
+		/* bind context menu to all nodes that will be created in the future (e.g loaded from server)*/
+		var _this = this;
+		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
+		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
+		dojo.event.topic.subscribe(tree.eventNames.moveTo, this, "onMoveTo");
+		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
+		dojo.event.topic.subscribe(tree.eventNames.addChild, this, "onAddChild");
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+
+		this.listenedTrees.push(tree);
+
+	},
+
+	unlistenTree: function(tree) {
+		/* clear event listeners */
+
+		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, "onCreateDOMNode");
+		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
+		dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, "onMoveTo");
+		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
+		dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, "onAddChild");
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+
+		for(var i=0; i<this.listenedTrees.length; i++){
+           if(this.listenedTrees[i] === tree){
+                   this.listenedTrees.splice(i, 1);
+                   break;
+           }
 		}
-	}
-}, onTreeDestroy:function (message) {
-	this.unlistenTree(message.source);
-}, bindTreeNode:function (node) {
-	var _this = this;
-	dojo.lang.forEach(node.getDescendants(), function (e) {
-		_this.bindDomNode(e.labelNode);
-	});
-}, unBindTreeNode:function (node) {
-	var _this = this;
-	dojo.lang.forEach(node.getDescendants(), function (e) {
-		_this.unBindDomNode(e.labelNode);
-	});
-}, onCreateDOMNode:function (message) {
-	this.bindTreeNode(message.source);
-}, onMoveFrom:function (message) {
-	if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+	},
+
+	onTreeDestroy: function(message) {
+		this.unlistenTree(message.source);
+	},
+
+	bindTreeNode: function(node) {
+		var _this = this;
+		//dojo.debug("bind to "+node);
+		dojo.lang.forEach(node.getDescendants(),
+			function(e) {_this.bindDomNode(e.labelNode); }
+		);
+	},
+
+
+	unBindTreeNode: function(node) {
+		var _this = this;
+		//dojo.debug("Unbind from "+node);
+		dojo.lang.forEach(node.getDescendants(),
+			function(e) {_this.unBindDomNode(e.labelNode); }
+		);
+	},
+
+	onCreateDOMNode: function(message) {
+		this.bindTreeNode(message.source);
+	},
+
+
+	onMoveFrom: function(message) {
+		if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+			this.unBindTreeNode(message.child);
+		}
+	},
+
+	onMoveTo: function(message) {
+		if (dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+			this.bindTreeNode(message.child);
+		}
+	},
+
+	onRemoveNode: function(message) {
 		this.unBindTreeNode(message.child);
+	},
+
+	onAddChild: function(message) {
+		if (message.domNodeInitialized) {
+			// dom node was there already => I did not process onNodeDomCreate
+			this.bindTreeNode(message.child);
+		}
 	}
-}, onMoveTo:function (message) {
-	if (dojo.lang.inArray(this.listenedTrees, message.newTree)) {
-		this.bindTreeNode(message.child);
+
+
+});
+
+
+
+
+
+
+dojo.widget.TreeMenuItem = function() {
+	dojo.widget.MenuItem2.call(this);
+
+}
+
+
+dojo.inherits(dojo.widget.TreeMenuItem, dojo.widget.MenuItem2);
+
+
+dojo.lang.extend(dojo.widget.TreeMenuItem, {
+
+	widgetType: "TreeMenuItem",
+
+	// treeActions menu item performs following actions (to be checked for permissions)
+	treeActions: "",
+
+	initialize: function(args, frag) {
+
+		this.treeActions = this.treeActions.split(",");
+		for(var i=0; i<this.treeActions.length; i++) {
+			this.treeActions[i] = this.treeActions[i].toUpperCase();
+		}
+
+	},
+
+	getTreeNode: function() {
+		var menu = this;
+
+		while (! (menu instanceof dojo.widget.TreeContextMenu) ) {
+			menu = menu.parent;
+		}
+
+		var source = menu.getTopOpenEvent().target;
+
+		while (!source.getAttribute('treeNode') && source.tagName != 'body') {
+			source = source.parentNode;
+		}
+		if (source.tagName == 'body') {
+			dojo.raise("treeNode not detected");
+		}
+		var treeNode = dojo.widget.manager.getWidgetById(source.getAttribute('treeNode'));
+
+		return treeNode;
+	},
+
+
+	menuOpen: function(message) {
+		var treeNode = this.getTreeNode();
+
+		this.setDisabled(false); // enable by default
+
+		var _this = this;
+		dojo.lang.forEach(_this.treeActions,
+			function(action) {
+				_this.setDisabled( treeNode.actionIsDisabled(action) );
+			}
+		);
+
+	},
+
+	toString: function() {
+		return "["+this.widgetType+" node "+this.getTreeNode()+"]";
 	}
-}, onRemoveNode:function (message) {
-	this.unBindTreeNode(message.child);
-}, onAddChild:function (message) {
-	if (message.domNodeInitialized) {
-		this.bindTreeNode(message.child);
-	}
-}});
-dojo.widget.defineWidget("dojo.widget.TreeMenuItem", dojo.widget.MenuItem2, {treeActions:"", initialize:function (args, frag) {
-	this.treeActions = this.treeActions.split(",");
-	for (var i = 0; i < this.treeActions.length; i++) {
-		this.treeActions[i] = this.treeActions[i].toUpperCase();
-	}
-}, getTreeNode:function () {
-	var menu = this;
-	while (!(menu instanceof dojo.widget.TreeContextMenu)) {
-		menu = menu.parent;
-	}
-	var source = menu.getTopOpenEvent().target;
-	while (!source.getAttribute("treeNode") && source.tagName != "body") {
-		source = source.parentNode;
-	}
-	if (source.tagName == "body") {
-		dojo.raise("treeNode not detected");
-	}
-	var treeNode = dojo.widget.manager.getWidgetById(source.getAttribute("treeNode"));
-	return treeNode;
-}, menuOpen:function (message) {
-	var treeNode = this.getTreeNode();
-	this.setDisabled(false);
-	var _this = this;
-	dojo.lang.forEach(_this.treeActions, function (action) {
-		_this.setDisabled(treeNode.actionIsDisabled(action));
-	});
-}, toString:function () {
-	return "[" + this.widgetType + " node " + this.getTreeNode() + "]";
-}});
 
+});
+
+

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeContextMenuV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeContextMenuV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeContextMenuV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,74 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeContextMenuV3");
-dojo.require("dojo.event.*");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.Menu2");
-dojo.require("dojo.widget.TreeCommon");
-dojo.widget.defineWidget("dojo.widget.TreeContextMenuV3", [dojo.widget.PopupMenu2, dojo.widget.TreeCommon], function () {
-	this.listenedTrees = {};
-}, {listenTreeEvents:["afterTreeCreate", "beforeTreeDestroy"], listenNodeFilter:function (elem) {
-	return elem instanceof dojo.widget.Widget;
-}, onAfterTreeCreate:function (message) {
-	var tree = message.source;
-	this.bindDomNode(tree.domNode);
-}, onBeforeTreeDestroy:function (message) {
-	this.unBindDomNode(message.source.domNode);
-}, getTreeNode:function () {
-	var source = this.getTopOpenEvent().target;
-	var treeNode = this.domElement2TreeNode(source);
-	return treeNode;
-}, open:function () {
-	var result = dojo.widget.PopupMenu2.prototype.open.apply(this, arguments);
-	for (var i = 0; i < this.children.length; i++) {
-		if (this.children[i].menuOpen) {
-			this.children[i].menuOpen(this.getTreeNode());
-		}
-	}
-	return result;
-}, close:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		if (this.children[i].menuClose) {
-			this.children[i].menuClose(this.getTreeNode());
-		}
-	}
-	var result = dojo.widget.PopupMenu2.prototype.close.apply(this, arguments);
-	return result;
-}});
-dojo.widget.defineWidget("dojo.widget.TreeMenuItemV3", [dojo.widget.MenuItem2, dojo.widget.TreeCommon], function () {
-	this.treeActions = [];
-}, {treeActions:"", initialize:function (args, frag) {
-	for (var i = 0; i < this.treeActions.length; i++) {
-		this.treeActions[i] = this.treeActions[i].toUpperCase();
-	}
-}, getTreeNode:function () {
-	var menu = this;
-	while (!(menu instanceof dojo.widget.TreeContextMenuV3)) {
-		menu = menu.parent;
-	}
-	var treeNode = menu.getTreeNode();
-	return treeNode;
-}, menuOpen:function (treeNode) {
-	treeNode.viewEmphasize();
-	this.setDisabled(false);
-	var _this = this;
-	dojo.lang.forEach(_this.treeActions, function (action) {
-		_this.setDisabled(treeNode.actionIsDisabledNow(action));
-	});
-}, menuClose:function (treeNode) {
-	treeNode.viewUnemphasize();
-}, toString:function () {
-	return "[" + this.widgetType + " node " + this.getTreeNode() + "]";
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeControllerExtension.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeControllerExtension.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeControllerExtension.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,53 +8,88 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+/**
+ * Additional tree utils
+ *
+ */
+dojo.provide("dojo.widget.TreeControllerExtension");
 
 
-dojo.provide("dojo.widget.TreeControllerExtension");
-dojo.declare("dojo.widget.TreeControllerExtension", null, {saveExpandedIndices:function (node, field) {
-	var obj = {};
-	for (var i = 0; i < node.children.length; i++) {
-		if (node.children[i].isExpanded) {
-			var key = dojo.lang.isUndefined(field) ? i : node.children[i][field];
-			obj[key] = this.saveExpandedIndices(node.children[i], field);
+dojo.widget.TreeControllerExtension = function() { }
+
+dojo.lang.extend(dojo.widget.TreeControllerExtension, {
+
+	saveExpandedIndices: function(node, field) {
+		var obj = {};
+
+		for(var i=0; i<node.children.length; i++) {
+			if (node.children[i].isExpanded) {
+				var key = dojo.lang.isUndefined(field) ? i : node.children[i][field];
+				obj[key] = this.saveExpandedIndices(node.children[i], field);
+			}
 		}
-	}
-	return obj;
-}, restoreExpandedIndices:function (node, savedIndices, field) {
-	var _this = this;
-	var handler = function (node, savedIndices) {
-		this.node = node;
-		this.savedIndices = savedIndices;
-		this.process = function () {
-			_this.restoreExpandedIndices(this.node, this.savedIndices, field);
-		};
-	};
-	for (var i = 0; i < node.children.length; i++) {
-		var child = node.children[i];
-		var found = false;
-		var key = -1;
-		if (dojo.lang.isUndefined(field) && savedIndices[i]) {
-			found = true;
-			key = i;
+
+		return obj;
+	},
+
+
+	restoreExpandedIndices: function(node, savedIndices, field) {
+		var _this = this;
+
+		var handler = function(node, savedIndices) {
+			this.node = node; //.children[i];
+			this.savedIndices = savedIndices; //[i];
+			// recursively read next savedIndices level and apply to opened node
+			this.process = function() {
+				//dojo.debug("Callback applied for "+this.node);
+				_this.restoreExpandedIndices(this.node, this.savedIndices, field);
+			};
 		}
-		if (field) {
-			for (var key in savedIndices) {
-				if (key == child[field]) {
-					found = true;
-					break;
+
+
+		for(var i=0; i<node.children.length; i++) {
+			var child = node.children[i];
+
+			var found = false;
+			var key = -1;
+
+			//dojo.debug("Check "+child)
+			// process field set case
+			if (dojo.lang.isUndefined(field) && savedIndices[i]) {
+				found = true;
+				key = i;
+			}
+
+			// process case when field is not set
+			if (field) {
+				for(var key in savedIndices) {
+					//dojo.debug("Compare "+key+" "+child[field])
+					if (key == child[field]) {
+						found = true;
+						break;
+					}
 				}
 			}
-		}
-		if (found) {
-			var h = new handler(child, savedIndices[key]);
-			_this.expand(child, false, h, h.process);
-		} else {
-			if (child.isExpanded) {
-				dojo.lang.forEach(child.getDescendants(), function (elem) {
-					_this.collapse(elem);
-				});
+
+			// if we found anything - expand it
+			if (found) {
+				//dojo.debug("Found at "+key)
+				var h = new handler(child, savedIndices[key]);
+				_this.expand(child, false, h, h.process);
+			} else if (child.isExpanded) { // not found, so collapse
+				//dojo.debug("Collapsing all descendants "+node.children[i])
+				dojo.lang.forEach(child.getDescendants(), function(elem) { _this.collapse(elem); });
+				//this.collapse(node.children[i]);
 			}
+
 		}
+
+
 	}
-}});
 
+});
+
+
+
+
+

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeDemo.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeDemo.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeDemo.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,85 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeDemo");
-dojo.require("dojo.Deferred");
-dojo.widget.TreeDemo = {reportIfDefered:function (res) {
-	if (res instanceof dojo.Deferred) {
-		res.addCallbacks(function (res) {
-			return res;
-		}, function (err) {
-			dojo.debug("Error");
-			dojo.debugShallow(err);
-		});
-	}
-}, resetRandomChildren:function (maxCount) {
-	this.randomChildrenMaxCount = maxCount;
-	this.randomChildrenCount = 0;
-	this.randomChildrenDepth = 0;
-}, makeRandomChildren:function (title) {
-	this.randomChildrenDepth++;
-	var children = [];
-	for (var i = 1; i <= 5; i++) {
-		var t = title + (this.randomChildrenDepth == 1 ? "" : ".") + i;
-		var node = {title:t};
-		children.push(node);
-		this.randomChildrenCount++;
-		if (this.randomChildrenCount >= this.randomChildrenMaxCount) {
-			break;
-		}
-	}
-	var i = 1;
-	var _this = this;
-	dojo.lang.forEach(children, function (child) {
-		var t = title + (_this.randomChildrenDepth == 1 ? "" : ".") + i;
-		i++;
-		if (_this.randomChildrenCount < _this.randomChildrenMaxCount && (_this.randomChildrenDepth == 1 && child === children[0] || _this.randomChildrenDepth < 5 && Math.random() > 0.3)) {
-			child.children = _this.makeRandomChildren(t);
-		}
-	});
-	this.randomChildrenDepth--;
-	return children;
-}, bindDemoMenu:function (controller) {
-	var _t = this;
-	dojo.event.topic.subscribe("treeContextMenuDestroy/engage", function (menuItem) {
-		var node = menuItem.getTreeNode();
-		_t.reportIfDefered(controller.destroyChild(node));
-	});
-	dojo.event.topic.subscribe("treeContextMenuRefresh/engage", function (menuItem) {
-		var node = menuItem.getTreeNode();
-		_t.reportIfDefered(controller.refreshChildren(node));
-	});
-	dojo.event.topic.subscribe("treeContextMenuCreate/engage", function (menuItem) {
-		var node = menuItem.getTreeNode();
-		var d = controller.createAndEdit(node, 0);
-		_t.reportIfDefered(d);
-	});
-	dojo.event.topic.subscribe("treeContextMenuUp/engage", function (menuItem) {
-		var node = menuItem.getTreeNode();
-		if (node.isFirstChild()) {
-			return;
-		}
-		_t.reportIfDefered(controller.move(node, node.parent, node.getParentIndex() - 1));
-	});
-	dojo.event.topic.subscribe("treeContextMenuDown/engage", function (menuItem) {
-		var node = menuItem.getTreeNode();
-		if (node.isLastChild()) {
-			return;
-		}
-		_t.reportIfDefered(controller.move(node, node.parent, node.getParentIndex() + 1));
-	});
-	dojo.event.topic.subscribe("treeContextMenuEdit/engage", function (menuItem) {
-		var node = menuItem.getTreeNode();
-		_t.reportIfDefered(controller.editLabelStart(node));
-	});
-}};
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeDeselectOnDblselect.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeDeselectOnDblselect.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeDeselectOnDblselect.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,23 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeDeselectOnDblselect");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeSelectorV3");
-dojo.deprecated("Does anyone still need this extension? (TreeDeselectOnDblselect)");
-dojo.widget.defineWidget("dojo.widget.TreeDeselectOnDblselect", [dojo.widget.HtmlWidget], {selector:"", initialize:function () {
-	this.selector = dojo.widget.byId(this.selector);
-	dojo.event.topic.subscribe(this.selector.eventNames.dblselect, this, "onDblselect");
-}, onDblselect:function (message) {
-	this.selector.deselect(message.node);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeDisableWrapExtension.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeDisableWrapExtension.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeDisableWrapExtension.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,37 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeDisableWrapExtension");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeExtension");
-dojo.widget.defineWidget("dojo.widget.TreeDisableWrapExtension", dojo.widget.TreeExtension, {templateCssString:"\n/* CSS for TreeDisableWrapExtension */\n\n.TreeDisableWrap {\n\twhite-space: nowrap;\n}\n.TreeIEDisableWrap {\n\twidth: expression( 5 + firstChild.offsetWidth );\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TreeDisableWrap.css"), listenTree:function (tree) {
-	var wrappingDiv = document.createElement("div");
-	var clazz = tree.classPrefix + "DisableWrap";
-	if (dojo.render.html.ie) {
-		clazz = clazz + " " + tree.classPrefix + "IEDisableWrap";
-	}
-	dojo.html.setClass(wrappingDiv, clazz);
-	var table = document.createElement("table");
-	wrappingDiv.appendChild(table);
-	var tbody = document.createElement("tbody");
-	table.appendChild(tbody);
-	var tr = document.createElement("tr");
-	tbody.appendChild(tr);
-	var td = document.createElement("td");
-	tr.appendChild(td);
-	if (tree.domNode.parentNode) {
-		tree.domNode.parentNode.replaceChild(wrappingDiv, tree.domNode);
-	}
-	td.appendChild(tree.domNode);
-	tree.domNode = wrappingDiv;
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeDndControllerV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeDndControllerV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeDndControllerV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,71 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeDndControllerV3");
-dojo.require("dojo.dnd.TreeDragAndDropV3");
-dojo.require("dojo.experimental");
-dojo.experimental("Tree drag'n'drop' has lots of problems/bugs, it requires dojo drag'n'drop overhaul to work, probably in 0.5");
-dojo.widget.defineWidget("dojo.widget.TreeDndControllerV3", [dojo.widget.HtmlWidget, dojo.widget.TreeCommon], function () {
-	this.dragSources = {};
-	this.dropTargets = {};
-	this.listenedTrees = {};
-}, {listenTreeEvents:["afterChangeTree", "beforeTreeDestroy", "afterAddChild"], listenNodeFilter:function (elem) {
-	return elem instanceof dojo.widget.Widget;
-}, initialize:function (args) {
-	this.treeController = dojo.lang.isString(args.controller) ? dojo.widget.byId(args.controller) : args.controller;
-	if (!this.treeController) {
-		dojo.raise("treeController must be declared");
-	}
-}, onBeforeTreeDestroy:function (message) {
-	this.unlistenTree(message.source);
-}, onAfterAddChild:function (message) {
-	this.listenNode(message.child);
-}, onAfterChangeTree:function (message) {
-	if (!message.oldTree) {
-		return;
-	}
-	if (!message.newTree || !this.listenedTrees[message.newTree.widgetId]) {
-		this.processDescendants(message.node, this.listenNodeFilter, this.unlistenNode);
-	}
-	if (!this.listenedTrees[message.oldTree.widgetId]) {
-		this.processDescendants(message.node, this.listenNodeFilter, this.listenNode);
-	}
-}, listenNode:function (node) {
-	if (!node.tree.DndMode) {
-		return;
-	}
-	if (this.dragSources[node.widgetId] || this.dropTargets[node.widgetId]) {
-		return;
-	}
-	var source = null;
-	var target = null;
-	if (!node.actionIsDisabled(node.actions.MOVE)) {
-		var source = this.makeDragSource(node);
-		this.dragSources[node.widgetId] = source;
-	}
-	var target = this.makeDropTarget(node);
-	this.dropTargets[node.widgetId] = target;
-}, makeDragSource:function (node) {
-	return new dojo.dnd.TreeDragSourceV3(node.contentNode, this, node.tree.widgetId, node);
-}, makeDropTarget:function (node) {
-	return new dojo.dnd.TreeDropTargetV3(node.contentNode, this.treeController, node.tree.DndAcceptTypes, node);
-}, unlistenNode:function (node) {
-	if (this.dragSources[node.widgetId]) {
-		dojo.dnd.dragManager.unregisterDragSource(this.dragSources[node.widgetId]);
-		delete this.dragSources[node.widgetId];
-	}
-	if (this.dropTargets[node.widgetId]) {
-		dojo.dnd.dragManager.unregisterDropTarget(this.dropTargets[node.widgetId]);
-		delete this.dropTargets[node.widgetId];
-	}
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeDocIconExtension.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeDocIconExtension.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeDocIconExtension.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,54 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeDocIconExtension");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeExtension");
-dojo.widget.defineWidget("dojo.widget.TreeDocIconExtension", [dojo.widget.TreeExtension], {templateCssString:"\n/* CSS for TreeDocIconExtension */\n\n\n/* long vertical line under docIcon, connecting w/ children */\n.TreeStateChildrenYes-ExpandOpen .TreeIconContent {\n	background-image : url('../templates/images/TreeV3/i_long.gif');\n	background-repeat : no-repeat;\n	background-position: 18px 9px;\n}\n\n/* close has higher priority */\n.TreeStateChildrenYes-ExpandClosed .TreeIconContent {\n	background-image : url();\n}\n\n/* higher priotity: same length and appear after background-definition */\n.TreeStateChildrenNo-ExpandLeaf .TreeIconContent {\n	background-image : url();\n}\n\n.TreeStateChildrenNo-ExpandClosed .TreeIconContent {\n	background-image : url();\n}\n\n.TreeStateChildrenNo-ExpandOpen .TreeIconContent {\n	background-image : url();\n}\n\n\n/* highest priority */\n.TreeIconDocument {\n	background-image: url('../templates/images/TreeV3/document.gif');\n}\n\n.TreeExp!
 andOpen .TreeIconFolder {\n	background-image: url('../templates/images/TreeV3/open.gif');\n}\n\n.TreeExpandClosed .TreeIconFolder {\n	background-image: url('../templates/images/TreeV3/closed.gif');\n}\n\n/* generic class for docIcon */\n.TreeIcon {\n	width: 18px;\n	height: 18px;\n	float: left;\n	display: inline;\n	background-repeat : no-repeat;\n}\n\ndiv.TreeContent {\n	margin-left: 36px;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TreeDocIcon.css"), listenTreeEvents:["afterChangeTree", "afterSetFolder", "afterUnsetFolder"], listenNodeFilter:function (elem) {
-	return elem instanceof dojo.widget.Widget;
-}, getnodeDocType:function (node) {
-	var nodeDocType = node.getnodeDocType();
-	if (!nodeDocType) {
-		nodeDocType = node.isFolder ? "Folder" : "Document";
-	}
-	return nodeDocType;
-}, setnodeDocTypeClass:function (node) {
-	var reg = new RegExp("(^|\\s)" + node.tree.classPrefix + "Icon\\w+", "g");
-	var clazz = dojo.html.getClass(node.iconNode).replace(reg, "") + " " + node.tree.classPrefix + "Icon" + this.getnodeDocType(node);
-	dojo.html.setClass(node.iconNode, clazz);
-}, onAfterSetFolder:function (message) {
-	if (message.source.iconNode) {
-		this.setnodeDocTypeClass(message.source);
-	}
-}, onAfterUnsetFolder:function (message) {
-	this.setnodeDocTypeClass(message.source);
-}, listenNode:function (node) {
-	node.contentIconNode = document.createElement("div");
-	var clazz = node.tree.classPrefix + "IconContent";
-	if (dojo.render.html.ie) {
-		clazz = clazz + " " + node.tree.classPrefix + "IEIconContent";
-	}
-	dojo.html.setClass(node.contentIconNode, clazz);
-	node.contentNode.parentNode.replaceChild(node.contentIconNode, node.expandNode);
-	node.iconNode = document.createElement("div");
-	dojo.html.setClass(node.iconNode, node.tree.classPrefix + "Icon" + " " + node.tree.classPrefix + "Icon" + this.getnodeDocType(node));
-	node.contentIconNode.appendChild(node.expandNode);
-	node.contentIconNode.appendChild(node.iconNode);
-	dojo.dom.removeNode(node.contentNode);
-	node.contentIconNode.appendChild(node.contentNode);
-}, onAfterChangeTree:function (message) {
-	var _this = this;
-	if (!message.oldTree || !this.listenedTrees[message.oldTree.widgetId]) {
-		this.processDescendants(message.node, this.listenNodeFilter, this.listenNode);
-	}
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeEditor.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeEditor.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeEditor.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,67 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.RichText");
-dojo.provide("dojo.widget.TreeEditor");
-dojo.widget.defineWidget("dojo.widget.TreeEditor", dojo.widget.HtmlWidget, {singleLineMode:false, saveOnBlur:true, sync:false, selectOnOpen:true, controller:null, node:null, richTextParams:{styleSheets:"src/widget/templates/TreeEditor.css"}, getContents:function () {
-	return this.richText.getEditorContent();
-}, open:function (node) {
-	if (!this.richText) {
-		this.richText = dojo.widget.createWidget("RichText", this.richTextParams, node.labelNode);
-		dojo.event.connect("around", this.richText, "onKeyDown", this, "richText_onKeyDown");
-		dojo.event.connect(this.richText, "onBlur", this, "richText_onBlur");
-		var self = this;
-		dojo.event.connect(this.richText, "onLoad", function () {
-			if (self.selectOnOpen) {
-				self.richText.execCommand("selectall");
-			}
-		});
-	} else {
-		this.richText.open(node.labelNode);
-	}
-	this.node = node;
-}, close:function (save) {
-	this.richText.close(save);
-	this.node = null;
-}, isClosed:function () {
-	return !this.richText || this.richText.isClosed;
-}, execCommand:function () {
-	this.richText.execCommand.apply(this.richText, arguments);
-}, richText_onKeyDown:function (invocation) {
-	var e = invocation.args[0];
-	if ((!e) && (this.object)) {
-		e = dojo.event.browser.fixEvent(this.editor.window.event);
-	}
-	switch (e.keyCode) {
-	  case e.KEY_ESCAPE:
-		this.finish(false);
-		dojo.event.browser.stopEvent(e);
-		break;
-	  case e.KEY_ENTER:
-		if (e.ctrlKey && !this.singleLineMode) {
-			this.execCommand("inserthtml", "<br/>");
-		} else {
-			this.finish(true);
-		}
-		dojo.event.browser.stopEvent(e);
-		break;
-	  default:
-		return invocation.proceed();
-	}
-}, richText_onBlur:function () {
-	this.finish(this.saveOnBlur);
-}, finish:function (save) {
-	return this.controller.editLabelFinish(save, this.sync);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeEmphasizeOnSelect.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeEmphasizeOnSelect.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeEmphasizeOnSelect.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,26 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeEmphasizeOnSelect");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeSelectorV3");
-dojo.require("dojo.html.selection");
-dojo.widget.defineWidget("dojo.widget.TreeEmphasizeOnSelect", dojo.widget.HtmlWidget, {selector:"", initialize:function () {
-	this.selector = dojo.widget.byId(this.selector);
-	dojo.event.topic.subscribe(this.selector.eventNames.select, this, "onSelect");
-	dojo.event.topic.subscribe(this.selector.eventNames.deselect, this, "onDeselect");
-}, onSelect:function (message) {
-	message.node.viewEmphasize();
-}, onDeselect:function (message) {
-	message.node.viewUnemphasize();
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeExpandToNodeOnSelect.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeExpandToNodeOnSelect.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeExpandToNodeOnSelect.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,22 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeExpandToNodeOnSelect");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.TreeExpandToNodeOnSelect", dojo.widget.HtmlWidget, {selector:"", controller:"", withSelected:false, initialize:function () {
-	this.selector = dojo.widget.byId(this.selector);
-	this.controller = dojo.widget.byId(this.controller);
-	dojo.event.topic.subscribe(this.selector.eventNames.select, this, "onSelect");
-}, onSelectEvent:function (message) {
-	this.controller.expandToNode(message.node, this.withSelected);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeExtension.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeExtension.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeExtension.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,19 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeExtension");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeCommon");
-dojo.widget.defineWidget("dojo.widget.TreeExtension", [dojo.widget.HtmlWidget, dojo.widget.TreeCommon], function () {
-	this.listenedTrees = {};
-}, {});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeLinkExtension.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeLinkExtension.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeLinkExtension.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,46 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeLinkExtension");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeExtension");
-dojo.widget.defineWidget("dojo.widget.TreeLinkExtension", dojo.widget.TreeExtension, function () {
-	this.params = {};
-}, {listenTreeEvents:["afterChangeTree"], listenTree:function (tree) {
-	dojo.widget.TreeCommon.prototype.listenTree.call(this, tree);
-	var labelNode = tree.labelNodeTemplate;
-	var newLabel = this.makeALabel();
-	dojo.html.setClass(newLabel, dojo.html.getClass(labelNode));
-	labelNode.parentNode.replaceChild(newLabel, labelNode);
-}, makeALabel:function () {
-	var newLabel = document.createElement("a");
-	for (var key in this.params) {
-		if (key in {}) {
-			continue;
-		}
-		newLabel.setAttribute(key, this.params[key]);
-	}
-	return newLabel;
-}, onAfterChangeTree:function (message) {
-	var _this = this;
-	if (!message.oldTree) {
-		this.listenNode(message.node);
-	}
-}, listenNode:function (node) {
-	for (var key in node.object) {
-		if (key in {}) {
-			continue;
-		}
-		node.labelNode.setAttribute(key, node.object[key]);
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeLoadingController.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeLoadingController.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeLoadingController.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -9,86 +9,209 @@
 */
 
 
+dojo.provide("dojo.widget.TreeLoadingController");
 
-dojo.provide("dojo.widget.TreeLoadingController");
 dojo.require("dojo.widget.TreeBasicController");
 dojo.require("dojo.event.*");
-dojo.require("dojo.json");
+dojo.require("dojo.json")
 dojo.require("dojo.io.*");
-dojo.widget.defineWidget("dojo.widget.TreeLoadingController", dojo.widget.TreeBasicController, {RPCUrl:"", RPCActionParam:"action", RPCErrorHandler:function (type, obj, evt) {
-	alert("RPC Error: " + (obj.message || "no message"));
-}, preventCache:true, getRPCUrl:function (action) {
-	if (this.RPCUrl == "local") {
-		var dir = document.location.href.substr(0, document.location.href.lastIndexOf("/"));
-		var localUrl = dir + "/" + action;
-		return localUrl;
-	}
-	if (!this.RPCUrl) {
-		dojo.raise("Empty RPCUrl: can't load");
-	}
-	return this.RPCUrl + (this.RPCUrl.indexOf("?") > -1 ? "&" : "?") + this.RPCActionParam + "=" + action;
-}, loadProcessResponse:function (node, result, callObj, callFunc) {
-	if (!dojo.lang.isUndefined(result.error)) {
-		this.RPCErrorHandler("server", result.error);
-		return false;
-	}
-	var newChildren = result;
-	if (!dojo.lang.isArray(newChildren)) {
-		dojo.raise("loadProcessResponse: Not array loaded: " + newChildren);
-	}
-	for (var i = 0; i < newChildren.length; i++) {
-		newChildren[i] = dojo.widget.createWidget(node.widgetType, newChildren[i]);
-		node.addChild(newChildren[i]);
-	}
-	node.state = node.loadStates.LOADED;
-	if (dojo.lang.isFunction(callFunc)) {
-		callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node, newChildren]);
-	}
-}, getInfo:function (obj) {
-	return obj.getInfo();
-}, runRPC:function (kw) {
-	var _this = this;
-	var handle = function (type, data, evt) {
+
+
+dojo.widget.tags.addParseTreeHandler("dojo:TreeLoadingController");
+
+
+dojo.widget.TreeLoadingController = function() {
+	dojo.widget.TreeBasicController.call(this);
+}
+
+dojo.inherits(dojo.widget.TreeLoadingController, dojo.widget.TreeBasicController);
+
+
+dojo.lang.extend(dojo.widget.TreeLoadingController, {
+	widgetType: "TreeLoadingController",
+
+	RPCUrl: "",
+
+	RPCActionParam: "action", // used for GET for RPCUrl
+
+
+	/**
+	 * Common RPC error handler (dies)
+	*/
+	RPCErrorHandler: function(type, obj, evt) {
+		alert( "RPC Error: " + (obj.message||"no message"));
+	},
+
+
+
+	getRPCUrl: function(action) {
+
+		// RPCUrl=local meant SOLELY for DEMO and LOCAL TESTS.
+		// May lead to widgetId collisions
+		if (this.RPCUrl == "local") {
+			var dir = document.location.href.substr(0, document.location.href.lastIndexOf('/'));
+			var localUrl = dir+"/"+action;
+			//dojo.debug(localUrl);
+			return localUrl;
+		}
+
+		if (!this.RPCUrl) {
+			dojo.raise("Empty RPCUrl: can't load");
+		}
+
+		return this.RPCUrl + ( this.RPCUrl.indexOf("?") > -1 ? "&" : "?") + this.RPCActionParam+"="+action;
+	},
+
+
+	/**
+	 * Add all loaded nodes from array obj as node children and expand it
+	*/
+	loadProcessResponse: function(node, result, callObj, callFunc) {
+
+		if (!dojo.lang.isUndefined(result.error)) {
+			this.RPCErrorHandler("server", result.error);
+			return false;
+		}
+
+		//dojo.debugShallow(result);
+
+		var newChildren = result;
+
+		if (!dojo.lang.isArray(newChildren)) {
+			dojo.raise('loadProcessResponse: Not array loaded: '+newChildren);
+		}
+
+		for(var i=0; i<newChildren.length; i++) {
+			// looks like dojo.widget.manager needs no special "add" command
+			newChildren[i] = dojo.widget.createWidget(node.widgetType, newChildren[i]);
+			node.addChild(newChildren[i]);
+		}
+
+
+		//node.addAllChildren(newChildren);
+
+		node.state = node.loadStates.LOADED;
+
+		//dojo.debug(callFunc);
+
+		if (dojo.lang.isFunction(callFunc)) {
+			callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node, newChildren]);
+		}
+		//this.expand(node);
+	},
+
+	getInfo: function(obj) {
+		return obj.getInfo();
+	},
+
+	runRPC: function(kw) {
+		var _this = this;
+
+		var handle = function(type, data, evt) {
+			// unlock BEFORE any processing is done
+			// so errorHandler may apply locking
+			if (kw.lock) {
+				dojo.lang.forEach(kw.lock,
+					function(t) { t.unlock() }
+				);
+			}
+
+			if(type == "load"){
+				kw.load.call(this, data);
+			}else{
+				this.RPCErrorHandler(type, data, evt);
+			}
+
+		}
+
 		if (kw.lock) {
-			dojo.lang.forEach(kw.lock, function (t) {
-				t.unlock();
-			});
+			dojo.lang.forEach(kw.lock,
+				function(t) { t.lock() }
+			);
 		}
-		if (type == "load") {
-			kw.load.call(this, data);
-		} else {
-			this.RPCErrorHandler(type, data, evt);
-		}
-	};
-	if (kw.lock) {
-		dojo.lang.forEach(kw.lock, function (t) {
-			t.lock();
+
+
+		dojo.io.bind({
+			url: kw.url,
+			/* I hitch to get this.loadOkHandler */
+			handle: dojo.lang.hitch(this, handle),
+			mimetype: "text/json",
+			preventCache: true,
+			sync: kw.sync,
+			content: { data: dojo.json.serialize(kw.params) }
 		});
-	}
-	dojo.io.bind({url:kw.url, handle:dojo.lang.hitch(this, handle), mimetype:"text/json", preventCache:_this.preventCache, sync:kw.sync, content:{data:dojo.json.serialize(kw.params)}});
-}, loadRemote:function (node, sync, callObj, callFunc) {
-	var _this = this;
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree)};
-	this.runRPC({url:this.getRPCUrl("getChildren"), load:function (result) {
-		_this.loadProcessResponse(node, result, callObj, callFunc);
-	}, sync:sync, lock:[node], params:params});
-}, expand:function (node, sync, callObj, callFunc) {
-	if (node.state == node.loadStates.UNCHECKED && node.isFolder) {
-		this.loadRemote(node, sync, this, function (node, newChildren) {
-			this.expand(node, sync, callObj, callFunc);
+	},
+
+
+
+	/**
+	 * Load children of the node from server
+	 * Synchroneous loading doesn't break control flow
+	 * I need sync mode for DnD
+	*/
+	loadRemote: function(node, sync, callObj, callFunc){
+		var _this = this;
+
+		var params = {
+			node: this.getInfo(node),
+			tree: this.getInfo(node.tree)
+		};
+
+		//dojo.debug(callFunc)
+
+		this.runRPC({
+			url: this.getRPCUrl('getChildren'),
+			load: function(result) {
+				_this.loadProcessResponse(node, result, callObj, callFunc) ;
+			},
+			sync: sync,
+			lock: [node],
+			params: params
 		});
-		return;
+
+	},
+
+
+	expand: function(node, sync, callObj, callFunc) {
+
+		if (node.state == node.loadStates.UNCHECKED && node.isFolder) {
+
+			this.loadRemote(node, sync,
+				this,
+				function(node, newChildren) {
+					this.expand(node, sync, callObj, callFunc);
+				}
+			);
+
+			return;
+		}
+
+		dojo.widget.TreeBasicController.prototype.expand.apply(this, arguments);
+
+	},
+
+
+
+	doMove: function(child, newParent, index) {
+		/* load nodes into newParent in sync mode, if needed, first */
+		if (newParent.isTreeNode && newParent.state == newParent.loadStates.UNCHECKED) {
+			this.loadRemote(newParent, true);
+		}
+
+		return dojo.widget.TreeBasicController.prototype.doMove.apply(this, arguments);
+	},
+
+
+	doCreateChild: function(parent, index, data, callObj, callFunc) {
+
+		/* load nodes into newParent in sync mode, if needed, first */
+		if (parent.state == parent.loadStates.UNCHECKED) {
+			this.loadRemote(parent, true);
+		}
+
+		return dojo.widget.TreeBasicController.prototype.doCreateChild.apply(this, arguments);
 	}
-	dojo.widget.TreeBasicController.prototype.expand.apply(this, arguments);
-}, doMove:function (child, newParent, index) {
-	if (newParent.isTreeNode && newParent.state == newParent.loadStates.UNCHECKED) {
-		this.loadRemote(newParent, true);
-	}
-	return dojo.widget.TreeBasicController.prototype.doMove.apply(this, arguments);
-}, doCreateChild:function (parent, index, data, callObj, callFunc) {
-	if (parent.state == parent.loadStates.UNCHECKED) {
-		this.loadRemote(parent, true);
-	}
-	return dojo.widget.TreeBasicController.prototype.doCreateChild.apply(this, arguments);
-}});
 
+
+
+});

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeLoadingControllerV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeLoadingControllerV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeLoadingControllerV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,250 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeLoadingControllerV3");
-dojo.require("dojo.widget.TreeBasicControllerV3");
-dojo.require("dojo.event.*");
-dojo.require("dojo.json");
-dojo.require("dojo.io.*");
-dojo.require("dojo.Deferred");
-dojo.require("dojo.DeferredList");
-dojo.declare("dojo.Error", Error, function (message, extra) {
-	this.message = message;
-	this.extra = extra;
-	this.stack = (new Error()).stack;
-});
-dojo.declare("dojo.CommunicationError", dojo.Error, function () {
-	this.name = "CommunicationError";
-});
-dojo.declare("dojo.LockedError", dojo.Error, function () {
-	this.name = "LockedError";
-});
-dojo.declare("dojo.FormatError", dojo.Error, function () {
-	this.name = "FormatError";
-});
-dojo.declare("dojo.RpcError", dojo.Error, function () {
-	this.name = "RpcError";
-});
-dojo.widget.defineWidget("dojo.widget.TreeLoadingControllerV3", dojo.widget.TreeBasicControllerV3, {RpcUrl:"", RpcActionParam:"action", preventCache:true, checkValidRpcResponse:function (type, obj) {
-	if (type != "load") {
-		var extra = {};
-		for (var i = 1; i < arguments.length; i++) {
-			dojo.lang.mixin(extra, arguments[i]);
-		}
-		return new dojo.CommunicationError(obj, extra);
-	}
-	if (typeof obj != "object") {
-		return new dojo.FormatError("Wrong server answer format " + (obj && obj.toSource ? obj.toSource() : obj) + " type " + (typeof obj), obj);
-	}
-	if (!dojo.lang.isUndefined(obj.error)) {
-		return new dojo.RpcError(obj.error, obj);
-	}
-	return false;
-}, getDeferredBindHandler:function (deferred) {
-	return dojo.lang.hitch(this, function (type, obj) {
-		var error = this.checkValidRpcResponse.apply(this, arguments);
-		if (error) {
-			deferred.errback(error);
-			return;
-		}
-		deferred.callback(obj);
-	});
-}, getRpcUrl:function (action) {
-	if (this.RpcUrl == "local") {
-		var dir = document.location.href.substr(0, document.location.href.lastIndexOf("/"));
-		var localUrl = dir + "/local/" + action;
-		return localUrl;
-	}
-	if (!this.RpcUrl) {
-		dojo.raise("Empty RpcUrl: can't load");
-	}
-	var url = this.RpcUrl;
-	if (url.indexOf("/") != 0) {
-		var protocol = document.location.href.replace(/:\/\/.*/, "");
-		var prefix = document.location.href.substring(protocol.length + 3);
-		if (prefix.lastIndexOf("/") != prefix.length - 1) {
-			prefix = prefix.replace(/\/[^\/]+$/, "/");
-		}
-		if (prefix.lastIndexOf("/") != prefix.length - 1) {
-			prefix = prefix + "/";
-		}
-		url = protocol + "://" + prefix + url;
-	}
-	return url + (url.indexOf("?") > -1 ? "&" : "?") + this.RpcActionParam + "=" + action;
-}, loadProcessResponse:function (node, result) {
-	if (!dojo.lang.isArray(result)) {
-		throw new dojo.FormatError("loadProcessResponse: Not array loaded: " + result);
-	}
-	node.setChildren(result);
-}, runRpc:function (kw) {
-	var _this = this;
-	var deferred = new dojo.Deferred();
-	dojo.io.bind({url:kw.url, handle:this.getDeferredBindHandler(deferred), mimetype:"text/javascript", preventCache:this.preventCache, sync:kw.sync, content:{data:dojo.json.serialize(kw.params)}});
-	return deferred;
-}, loadRemote:function (node, sync) {
-	var _this = this;
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree)};
-	var deferred = this.runRpc({url:this.getRpcUrl("getChildren"), sync:sync, params:params});
-	deferred.addCallback(function (res) {
-		return _this.loadProcessResponse(node, res);
-	});
-	return deferred;
-}, batchExpandTimeout:0, recurseToLevel:function (widget, level, callFunc, callObj, skipFirst, sync) {
-	if (level == 0) {
-		return;
-	}
-	if (!skipFirst) {
-		var deferred = callFunc.call(callObj, widget, sync);
-	} else {
-		var deferred = dojo.Deferred.prototype.makeCalled();
-	}
-	var _this = this;
-	var recurseOnExpand = function () {
-		var children = widget.children;
-		var deferreds = [];
-		for (var i = 0; i < children.length; i++) {
-			deferreds.push(_this.recurseToLevel(children[i], level - 1, callFunc, callObj, sync));
-		}
-		return new dojo.DeferredList(deferreds);
-	};
-	deferred.addCallback(recurseOnExpand);
-	return deferred;
-}, expandToLevel:function (nodeOrTree, level, sync) {
-	return this.recurseToLevel(nodeOrTree, nodeOrTree.isTree ? level + 1 : level, this.expand, this, nodeOrTree.isTree, sync);
-}, loadToLevel:function (nodeOrTree, level, sync) {
-	return this.recurseToLevel(nodeOrTree, nodeOrTree.isTree ? level + 1 : level, this.loadIfNeeded, this, nodeOrTree.isTree, sync);
-}, loadAll:function (nodeOrTree, sync) {
-	return this.loadToLevel(nodeOrTree, Number.POSITIVE_INFINITY, sync);
-}, expand:function (node, sync) {
-	var _this = this;
-	var deferred = this.startProcessing(node);
-	deferred.addCallback(function () {
-		return _this.loadIfNeeded(node, sync);
-	});
-	deferred.addCallback(function (res) {
-		dojo.widget.TreeBasicControllerV3.prototype.expand(node);
-		return res;
-	});
-	deferred.addBoth(function (res) {
-		_this.finishProcessing(node);
-		return res;
-	});
-	return deferred;
-}, loadIfNeeded:function (node, sync) {
-	var deferred;
-	if (node.state == node.loadStates.UNCHECKED && node.isFolder && !node.children.length) {
-		deferred = this.loadRemote(node, sync);
-	} else {
-		deferred = new dojo.Deferred();
-		deferred.callback();
-	}
-	return deferred;
-}, runStages:function (check, prepare, make, finalize, expose, args) {
-	var _this = this;
-	if (check && !check.apply(this, args)) {
-		return false;
-	}
-	var deferred = dojo.Deferred.prototype.makeCalled();
-	if (prepare) {
-		deferred.addCallback(function () {
-			return prepare.apply(_this, args);
-		});
-	}
-	if (make) {
-		deferred.addCallback(function () {
-			var res = make.apply(_this, args);
-			return res;
-		});
-	}
-	if (finalize) {
-		deferred.addBoth(function (res) {
-			finalize.apply(_this, args);
-			return res;
-		});
-	}
-	if (expose) {
-		deferred.addCallback(function (res) {
-			expose.apply(_this, args);
-			return res;
-		});
-	}
-	return deferred;
-}, startProcessing:function (nodesArray) {
-	var deferred = new dojo.Deferred();
-	var nodes = dojo.lang.isArray(nodesArray) ? nodesArray : arguments;
-	for (var i = 0; i < nodes.length; i++) {
-		if (nodes[i].isLocked()) {
-			deferred.errback(new dojo.LockedError("item locked " + nodes[i], nodes[i]));
-			return deferred;
-		}
-		if (nodes[i].isTreeNode) {
-			nodes[i].markProcessing();
-		}
-		nodes[i].lock();
-	}
-	deferred.callback();
-	return deferred;
-}, finishProcessing:function (nodesArray) {
-	var nodes = dojo.lang.isArray(nodesArray) ? nodesArray : arguments;
-	for (var i = 0; i < nodes.length; i++) {
-		if (!nodes[i].hasLock()) {
-			continue;
-		}
-		nodes[i].unlock();
-		if (nodes[i].isTreeNode) {
-			nodes[i].unmarkProcessing();
-		}
-	}
-}, refreshChildren:function (nodeOrTree, sync) {
-	return this.runStages(null, this.prepareRefreshChildren, this.doRefreshChildren, this.finalizeRefreshChildren, this.exposeRefreshChildren, arguments);
-}, prepareRefreshChildren:function (nodeOrTree, sync) {
-	var deferred = this.startProcessing(nodeOrTree);
-	nodeOrTree.destroyChildren();
-	nodeOrTree.state = nodeOrTree.loadStates.UNCHECKED;
-	return deferred;
-}, doRefreshChildren:function (nodeOrTree, sync) {
-	return this.loadRemote(nodeOrTree, sync);
-}, finalizeRefreshChildren:function (nodeOrTree, sync) {
-	this.finishProcessing(nodeOrTree);
-}, exposeRefreshChildren:function (nodeOrTree, sync) {
-	nodeOrTree.expand();
-}, move:function (child, newParent, index) {
-	return this.runStages(this.canMove, this.prepareMove, this.doMove, this.finalizeMove, this.exposeMove, arguments);
-}, doMove:function (child, newParent, index) {
-	child.tree.move(child, newParent, index);
-	return true;
-}, prepareMove:function (child, newParent, index, sync) {
-	var deferred = this.startProcessing(newParent);
-	deferred.addCallback(dojo.lang.hitch(this, function () {
-		return this.loadIfNeeded(newParent, sync);
-	}));
-	return deferred;
-}, finalizeMove:function (child, newParent) {
-	this.finishProcessing(newParent);
-}, prepareCreateChild:function (parent, index, data, sync) {
-	var deferred = this.startProcessing(parent);
-	deferred.addCallback(dojo.lang.hitch(this, function () {
-		return this.loadIfNeeded(parent, sync);
-	}));
-	return deferred;
-}, finalizeCreateChild:function (parent) {
-	this.finishProcessing(parent);
-}, prepareClone:function (child, newParent, index, deep, sync) {
-	var deferred = this.startProcessing(child, newParent);
-	deferred.addCallback(dojo.lang.hitch(this, function () {
-		return this.loadIfNeeded(newParent, sync);
-	}));
-	return deferred;
-}, finalizeClone:function (child, newParent) {
-	this.finishProcessing(child, newParent);
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeNode.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeNode.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeNode.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,239 +8,527 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.TreeNode");
-dojo.require("dojo.html.*");
-dojo.require("dojo.event.*");
-dojo.require("dojo.io.*");
-dojo.widget.defineWidget("dojo.widget.TreeNode", dojo.widget.HtmlWidget, function () {
-	this.actionsDisabled = [];
-}, {widgetType:"TreeNode", loadStates:{UNCHECKED:"UNCHECKED", LOADING:"LOADING", LOADED:"LOADED"}, actions:{MOVE:"MOVE", REMOVE:"REMOVE", EDIT:"EDIT", ADDCHILD:"ADDCHILD"}, isContainer:true, lockLevel:0, templateString:("<div class=\"dojoTreeNode\"> " + "<span treeNode=\"${this.widgetId}\" class=\"dojoTreeNodeLabel\" dojoAttachPoint=\"labelNode\"> " + "\t\t<span dojoAttachPoint=\"titleNode\" dojoAttachEvent=\"onClick: onTitleClick\" class=\"dojoTreeNodeLabelTitle\">${this.title}</span> " + "</span> " + "<span class=\"dojoTreeNodeAfterLabel\" dojoAttachPoint=\"afterLabelNode\">${this.afterLabel}</span> " + "<div dojoAttachPoint=\"containerNode\" style=\"display:none\"></div> " + "</div>").replace(/(>|<)\s+/g, "$1"), childIconSrc:"", childIconFolderSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/closed.gif"), childIconDocumentSrc:dojo.uri.moduleUri("dojo.widget", "templates/images/Tree/document.gif"), childIcon:null, isTreeNode:true, objectId:"", afterLabel:"", a!
 fterLabelNode:null, expandIcon:null, title:"", object:"", isFolder:false, labelNode:null, titleNode:null, imgs:null, expandLevel:"", tree:null, depth:0, isExpanded:false, state:null, domNodeInitialized:false, isFirstChild:function () {
-	return this.getParentIndex() == 0 ? true : false;
-}, isLastChild:function () {
-	return this.getParentIndex() == this.parent.children.length - 1 ? true : false;
-}, lock:function () {
-	return this.tree.lock.apply(this, arguments);
-}, unlock:function () {
-	return this.tree.unlock.apply(this, arguments);
-}, isLocked:function () {
-	return this.tree.isLocked.apply(this, arguments);
-}, cleanLock:function () {
-	return this.tree.cleanLock.apply(this, arguments);
-}, actionIsDisabled:function (action) {
-	var _this = this;
-	var disabled = false;
-	if (this.tree.strictFolders && action == this.actions.ADDCHILD && !this.isFolder) {
-		disabled = true;
-	}
-	if (dojo.lang.inArray(_this.actionsDisabled, action)) {
-		disabled = true;
-	}
-	if (this.isLocked()) {
-		disabled = true;
-	}
-	return disabled;
-}, getInfo:function () {
-	var info = {widgetId:this.widgetId, objectId:this.objectId, index:this.getParentIndex(), isFolder:this.isFolder};
-	return info;
-}, initialize:function (args, frag) {
-	this.state = this.loadStates.UNCHECKED;
-	for (var i = 0; i < this.actionsDisabled.length; i++) {
-		this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
-	}
-	this.expandLevel = parseInt(this.expandLevel);
-}, adjustDepth:function (depthDiff) {
-	for (var i = 0; i < this.children.length; i++) {
-		this.children[i].adjustDepth(depthDiff);
-	}
-	this.depth += depthDiff;
-	if (depthDiff > 0) {
-		for (var i = 0; i < depthDiff; i++) {
-			var img = this.tree.makeBlankImg();
-			this.imgs.unshift(img);
-			dojo.html.insertBefore(this.imgs[0], this.domNode.firstChild);
-		}
-	}
-	if (depthDiff < 0) {
-		for (var i = 0; i < -depthDiff; i++) {
-			this.imgs.shift();
-			dojo.html.removeNode(this.domNode.firstChild);
-		}
-	}
-}, markLoading:function () {
-	this._markLoadingSavedIcon = this.expandIcon.src;
-	this.expandIcon.src = this.tree.expandIconSrcLoading;
-}, unMarkLoading:function () {
-	if (!this._markLoadingSavedIcon) {
-		return;
-	}
-	var im = new Image();
-	im.src = this.tree.expandIconSrcLoading;
-	if (this.expandIcon.src == im.src) {
-		this.expandIcon.src = this._markLoadingSavedIcon;
-	}
-	this._markLoadingSavedIcon = null;
-}, setFolder:function () {
-	dojo.event.connect(this.expandIcon, "onclick", this, "onTreeClick");
-	this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
-	this.isFolder = true;
-}, createDOMNode:function (tree, depth) {
-	this.tree = tree;
-	this.depth = depth;
-	this.imgs = [];
-	for (var i = 0; i < this.depth + 1; i++) {
-		var img = this.tree.makeBlankImg();
-		this.domNode.insertBefore(img, this.labelNode);
-		this.imgs.push(img);
-	}
-	this.expandIcon = this.imgs[this.imgs.length - 1];
-	this.childIcon = this.tree.makeBlankImg();
-	this.imgs.push(this.childIcon);
-	dojo.html.insertBefore(this.childIcon, this.titleNode);
-	if (this.children.length || this.isFolder) {
-		this.setFolder();
-	} else {
-		this.state = this.loadStates.LOADED;
-	}
-	dojo.event.connect(this.childIcon, "onclick", this, "onIconClick");
-	for (var i = 0; i < this.children.length; i++) {
-		this.children[i].parent = this;
-		var node = this.children[i].createDOMNode(this.tree, this.depth + 1);
-		this.containerNode.appendChild(node);
-	}
-	if (this.children.length) {
-		this.state = this.loadStates.LOADED;
-	}
-	this.updateIcons();
-	this.domNodeInitialized = true;
-	dojo.event.topic.publish(this.tree.eventNames.createDOMNode, {source:this});
-	return this.domNode;
-}, onTreeClick:function (e) {
-	dojo.event.topic.publish(this.tree.eventNames.treeClick, {source:this, event:e});
-}, onIconClick:function (e) {
-	dojo.event.topic.publish(this.tree.eventNames.iconClick, {source:this, event:e});
-}, onTitleClick:function (e) {
-	dojo.event.topic.publish(this.tree.eventNames.titleClick, {source:this, event:e});
-}, markSelected:function () {
-	dojo.html.addClass(this.titleNode, "dojoTreeNodeLabelSelected");
-}, unMarkSelected:function () {
-	dojo.html.removeClass(this.titleNode, "dojoTreeNodeLabelSelected");
-}, updateExpandIcon:function () {
-	if (this.isFolder) {
-		this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
-	} else {
-		this.expandIcon.src = this.tree.blankIconSrc;
-	}
-}, updateExpandGrid:function () {
-	if (this.tree.showGrid) {
-		if (this.depth) {
-			this.setGridImage(-2, this.isLastChild() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
-		} else {
-			if (this.isFirstChild()) {
-				this.setGridImage(-2, this.isLastChild() ? this.tree.gridIconSrcX : this.tree.gridIconSrcY);
-			} else {
-				this.setGridImage(-2, this.isLastChild() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
-			}
-		}
-	} else {
-		this.setGridImage(-2, this.tree.blankIconSrc);
-	}
-}, updateChildGrid:function () {
-	if ((this.depth || this.tree.showRootGrid) && this.tree.showGrid) {
-		this.setGridImage(-1, (this.children.length && this.isExpanded) ? this.tree.gridIconSrcP : this.tree.gridIconSrcC);
-	} else {
-		if (this.tree.showGrid && !this.tree.showRootGrid) {
-			this.setGridImage(-1, (this.children.length && this.isExpanded) ? this.tree.gridIconSrcZ : this.tree.blankIconSrc);
-		} else {
-			this.setGridImage(-1, this.tree.blankIconSrc);
-		}
-	}
-}, updateParentGrid:function () {
-	var parent = this.parent;
-	for (var i = 0; i < this.depth; i++) {
-		var idx = this.imgs.length - (3 + i);
-		var img = (this.tree.showGrid && !parent.isLastChild()) ? this.tree.gridIconSrcV : this.tree.blankIconSrc;
-		this.setGridImage(idx, img);
-		parent = parent.parent;
-	}
-}, updateExpandGridColumn:function () {
-	if (!this.tree.showGrid) {
-		return;
-	}
-	var _this = this;
-	var icon = this.isLastChild() ? this.tree.blankIconSrc : this.tree.gridIconSrcV;
-	dojo.lang.forEach(_this.getDescendants(), function (node) {
-		node.setGridImage(_this.depth, icon);
-	});
-	this.updateExpandGrid();
-}, updateIcons:function () {
-	this.imgs[0].style.display = this.tree.showRootGrid ? "inline" : "none";
-	this.buildChildIcon();
-	this.updateExpandGrid();
-	this.updateChildGrid();
-	this.updateParentGrid();
-	dojo.profile.stop("updateIcons");
-}, buildChildIcon:function () {
-	if (this.childIconSrc) {
-		this.childIcon.src = this.childIconSrc;
-	}
-	this.childIcon.style.display = this.childIconSrc ? "inline" : "none";
-}, setGridImage:function (idx, src) {
-	if (idx < 0) {
-		idx = this.imgs.length + idx;
-	}
-	this.imgs[idx].style.backgroundImage = "url(" + src + ")";
-}, updateIconTree:function () {
-	this.tree.updateIconTree.call(this);
-}, expand:function () {
-	if (this.isExpanded) {
-		return;
-	}
-	if (this.children.length) {
-		this.showChildren();
-	}
-	this.isExpanded = true;
-	this.updateExpandIcon();
-	dojo.event.topic.publish(this.tree.eventNames.expand, {source:this});
-}, collapse:function () {
-	if (!this.isExpanded) {
-		return;
-	}
-	this.hideChildren();
-	this.isExpanded = false;
-	this.updateExpandIcon();
-	dojo.event.topic.publish(this.tree.eventNames.collapse, {source:this});
-}, hideChildren:function () {
-	this.tree.toggleObj.hide(this.containerNode, this.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onHide"));
-	if (dojo.exists(dojo, "dnd.dragManager.dragObjects") && dojo.dnd.dragManager.dragObjects.length) {
-		dojo.dnd.dragManager.cacheTargetLocations();
-	}
-}, showChildren:function () {
-	this.tree.toggleObj.show(this.containerNode, this.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onShow"));
-	if (dojo.exists(dojo, "dnd.dragManager.dragObjects") && dojo.dnd.dragManager.dragObjects.length) {
-		dojo.dnd.dragManager.cacheTargetLocations();
-	}
-}, addChild:function () {
-	return this.tree.addChild.apply(this, arguments);
-}, doAddChild:function () {
-	return this.tree.doAddChild.apply(this, arguments);
-}, edit:function (props) {
-	dojo.lang.mixin(this, props);
-	if (props.title) {
-		this.titleNode.innerHTML = this.title;
-	}
-	if (props.afterLabel) {
-		this.afterLabelNode.innerHTML = this.afterLabel;
-	}
-	if (props.childIconSrc) {
-		this.buildChildIcon();
-	}
-}, removeNode:function () {
-	return this.tree.removeNode.apply(this, arguments);
-}, doRemoveNode:function () {
-	return this.tree.doRemoveNode.apply(this, arguments);
-}, toString:function () {
-	return "[" + this.widgetType + " Tree:" + this.tree + " ID:" + this.widgetId + " Title:" + this.title + "]";
-}});
-
+
+dojo.provide("dojo.widget.TreeNode");
+
+dojo.require("dojo.event.*");
+dojo.require("dojo.io.*");
+
+// make it a tag
+dojo.widget.tags.addParseTreeHandler("dojo:TreeNode");
+
+
+// # //////////
+
+dojo.widget.TreeNode = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+	this.actionsDisabled = [];
+}
+
+dojo.inherits(dojo.widget.TreeNode, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.TreeNode, {
+	widgetType: "TreeNode",
+
+	loadStates: {
+		UNCHECKED: "UNCHECKED",
+    	LOADING: "LOADING",
+    	LOADED: "LOADED"
+	},
+
+
+	actions: {
+		MOVE: "MOVE",
+    	REMOVE: "REMOVE",
+    	EDIT: "EDIT",
+    	ADDCHILD: "ADDCHILD"
+	},
+
+	isContainer: true,
+
+	lockLevel: 0, // lock ++ unlock --, so nested locking works fine
+
+
+	templateString: ('<div class="dojoTreeNode"> '
+		+ '<span treeNode="${this.widgetId}" class="dojoTreeNodeLabel" dojoAttachPoint="labelNode"> '
+		+ '		<span dojoAttachPoint="titleNode" dojoAttachEvent="onClick: onTitleClick" class="dojoTreeNodeLabelTitle">${this.title}</span> '
+		+ '</span> '
+		+ '<span class="dojoTreeNodeAfterLabel" dojoAttachPoint="afterLabelNode">${this.afterLabel}</span> '
+		+ '<div dojoAttachPoint="containerNode" style="display:none"></div> '
+		+ '</div>').replace(/(>|<)\s+/g, '$1'), // strip whitespaces between nodes
+
+
+	childIconSrc: "",
+	childIconFolderSrc: dojo.uri.dojoUri("src/widget/templates/images/Tree/closed.gif"), // for under root parent item child icon,
+	childIconDocumentSrc: dojo.uri.dojoUri("src/widget/templates/images/Tree/document.gif"), // for under root parent item child icon,
+
+	childIcon: null,
+	isTreeNode: true,
+
+	objectId: "", // the widget represents an object
+
+	afterLabel: "",
+	afterLabelNode: null, // node to the left of labelNode
+
+	// an icon left from childIcon: imgs[-2].
+	// if +/- for folders, blank for leaves
+	expandIcon: null,
+
+	title: "",
+	object: "", // node may have object attached, settable from HTML
+	isFolder: false,
+
+	labelNode: null, // the item label
+	titleNode: null, // the item title
+	imgs: null, // an array of icons imgs
+
+	expandLevel: "", // expand to level
+
+	tree: null,
+
+	depth: 0,
+
+	isExpanded: false,
+
+	state: null,  // after creation will change to loadStates: "loaded/loading/unchecked"
+	domNodeInitialized: false,  // domnode is initialized with icons etc
+
+
+	isFirstNode: function() {
+		return this.getParentIndex() == 0 ? true: false;
+	},
+
+	isLastNode: function() {
+		return this.getParentIndex() == this.parent.children.length-1 ? true : false;
+	},
+
+	lock: function(){ return this.tree.lock.apply(this, arguments) },
+	unlock: function(){ return this.tree.unlock.apply(this, arguments) },
+	isLocked: function(){ return this.tree.isLocked.apply(this, arguments) },
+	cleanLock: function(){ return this.tree.cleanLock.apply(this, arguments) },
+
+	actionIsDisabled: function(action) {
+		var _this = this;
+
+		var disabled = false;
+
+		if (this.tree.strictFolders && action == this.actions.ADDCHILD && !this.isFolder) {
+			disabled = true;
+		}
+
+		if (dojo.lang.inArray(_this.actionsDisabled, action)) {
+			disabled = true;
+		}
+
+		if (this.isLocked()) {
+			disabled = true;
+		}
+
+		return disabled;
+	},
+
+	getInfo: function() {
+		// No title here (title may be widget)
+		var info = {
+			widgetId: this.widgetId,
+			objectId: this.objectId,
+			index: this.getParentIndex(),
+			isFolder: this.isFolder
+		}
+
+		return info;
+	},
+
+	initialize: function(args, frag){
+
+		//dojo.debug(this.title)
+
+		this.state = this.loadStates.UNCHECKED;
+
+		for(var i=0; i<this.actionsDisabled.length; i++) {
+			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
+		}
+
+		this.expandLevel = parseInt(this.expandLevel);
+
+	},
+
+
+	/**
+	 * Change visible node depth by appending/prepending with blankImgs
+	 * @param depthDiff Integer positive => move right, negative => move left
+	*/
+	adjustDepth: function(depthDiff) {
+
+		for(var i=0; i<this.children.length; i++) {
+			this.children[i].adjustDepth(depthDiff);
+		}
+
+		this.depth += depthDiff;
+
+		if (depthDiff>0) {
+			for(var i=0; i<depthDiff; i++) {
+				var img = this.tree.makeBlankImg();
+				this.imgs.unshift(img);
+				//dojo.debugShallow(this.domNode);
+				dojo.dom.insertBefore(this.imgs[0], this.domNode.firstChild);
+
+			}
+		}
+		if (depthDiff<0) {
+			for(var i=0; i<-depthDiff;i++) {
+				this.imgs.shift();
+				dojo.dom.removeNode(this.domNode.firstChild);
+			}
+		}
+
+	},
+
+
+	markLoading: function() {
+		this._markLoadingSavedIcon = this.expandIcon.src;
+		this.expandIcon.src = this.tree.expandIconSrcLoading;
+	},
+
+	// if icon is "Loading" then
+	unMarkLoading: function() {
+		if (!this._markLoadingSavedIcon) return;
+
+		var im = new Image();
+		im.src = this.tree.expandIconSrcLoading;
+
+		//dojo.debug("Unmark "+this.expandIcon.src+" : "+im.src);
+		if (this.expandIcon.src == im.src) {
+			this.expandIcon.src = this._markLoadingSavedIcon;
+		}
+		this._markLoadingSavedIcon = null;
+	},
+
+
+	setFolder: function() {
+		dojo.event.connect(this.expandIcon, 'onclick', this, 'onTreeClick');
+		this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
+		this.isFolder = true;
+	},
+
+
+	createDOMNode: function(tree, depth){
+
+		this.tree = tree;
+		this.depth = depth;
+
+
+		//
+		// add the tree icons
+		//
+
+		this.imgs = [];
+
+		for(var i=0; i<this.depth+1; i++){
+
+			var img = this.tree.makeBlankImg();
+
+			this.domNode.insertBefore(img, this.labelNode);
+
+			this.imgs.push(img);
+		}
+
+
+		this.expandIcon = this.imgs[this.imgs.length-1];
+
+
+		this.childIcon = this.tree.makeBlankImg();
+
+		// add to images before the title
+		this.imgs.push(this.childIcon);
+
+		dojo.dom.insertBefore(this.childIcon, this.titleNode);
+
+		// node with children(from source html) becomes folder on build stage.
+		if (this.children.length || this.isFolder) {
+			this.setFolder();
+		}
+		else {
+			// leaves are always loaded
+			//dojo.debug("Set "+this+" state to loaded");
+			this.state = this.loadStates.LOADED;
+		}
+
+		dojo.event.connect(this.childIcon, 'onclick', this, 'onIconClick');
+
+
+		//
+		// create the child rows
+		//
+
+
+		for(var i=0; i<this.children.length; i++){
+			this.children[i].parent = this;
+
+			var node = this.children[i].createDOMNode(this.tree, this.depth+1);
+
+			this.containerNode.appendChild(node);
+		}
+
+
+		if (this.children.length) {
+			this.state = this.loadStates.LOADED;
+		}
+
+		this.updateIcons();
+
+		this.domNodeInitialized = true;
+
+		dojo.event.topic.publish(this.tree.eventNames.createDOMNode, { source: this } );
+
+		return this.domNode;
+	},
+
+	onTreeClick: function(e){
+		dojo.event.topic.publish(this.tree.eventNames.treeClick, { source: this, event: e });
+	},
+
+	onIconClick: function(e){
+		dojo.event.topic.publish(this.tree.eventNames.iconClick, { source: this, event: e });
+	},
+
+	onTitleClick: function(e){
+		dojo.event.topic.publish(this.tree.eventNames.titleClick, { source: this, event: e });
+	},
+
+	markSelected: function() {
+		dojo.html.addClass(this.titleNode, 'dojoTreeNodeLabelSelected');
+	},
+
+
+	unMarkSelected: function() {
+		//dojo.debug('unmark')
+		dojo.html.removeClass(this.titleNode, 'dojoTreeNodeLabelSelected');
+	},
+
+	updateExpandIcon: function() {
+		if (this.isFolder){
+			this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
+		} else {
+			this.expandIcon.src = this.tree.blankIconSrc;
+		}
+	},
+
+	/* set the grid under the expand icon */
+	updateExpandGrid: function() {
+
+		if (this.tree.showGrid){
+			if (this.depth){
+				this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
+			}else{
+				if (this.isFirstNode()){
+					this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcX : this.tree.gridIconSrcY);
+				}else{
+					this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
+				}
+			}
+		}else{
+			this.setGridImage(-2, this.tree.blankIconSrc);
+		}
+
+	},
+
+	/* set the grid under the child icon */
+	updateChildGrid: function() {
+
+		if ((this.depth || this.tree.showRootGrid) && this.tree.showGrid){
+			this.setGridImage(-1, (this.children.length && this.isExpanded) ? this.tree.gridIconSrcP : this.tree.gridIconSrcC);
+		}else{
+			if (this.tree.showGrid && !this.tree.showRootGrid){
+				this.setGridImage(-1, (this.children.length && this.isExpanded) ? this.tree.gridIconSrcZ : this.tree.blankIconSrc);
+			}else{
+				this.setGridImage(-1, this.tree.blankIconSrc);
+			}
+		}
+
+
+	},
+
+	updateParentGrid: function() {
+		var parent = this.parent;
+
+		//dojo.debug("updateParentGrid "+this);
+
+		for(var i=0; i<this.depth; i++){
+
+			//dojo.debug("Parent "+parent);
+
+			var idx = this.imgs.length-(3+i);
+			var img = (this.tree.showGrid && !parent.isLastNode()) ? this.tree.gridIconSrcV : this.tree.blankIconSrc;
+
+			//dojo.debug("Image "+img+" for "+idx);
+
+			this.setGridImage(idx, img);
+
+			parent = parent.parent;
+		}
+	},
+
+	updateExpandGridColumn: function() {
+		if (!this.tree.showGrid) return;
+
+		var _this = this;
+
+		var icon = this.isLastNode() ? this.tree.blankIconSrc : this.tree.gridIconSrcV;
+
+		dojo.lang.forEach(_this.getDescendants(),
+			function(node) { node.setGridImage(_this.depth, icon); }
+		);
+
+		this.updateExpandGrid();
+	},
+
+	updateIcons: function(){
+
+
+		//dojo.profile.start("updateIcons")
+
+		//dojo.debug("Update icons for "+this)
+		//dojo.debug(this.isFolder)
+
+		this.imgs[0].style.display = this.tree.showRootGrid ? 'inline' : 'none';
+
+
+		//
+		// set the expand icon
+		//
+
+
+		//
+		// set the child icon
+		//
+		this.buildChildIcon();
+
+		this.updateExpandGrid();
+		this.updateChildGrid();
+		this.updateParentGrid();
+
+
+
+		dojo.profile.stop("updateIcons")
+
+	},
+
+	buildChildIcon: function() {
+		// IE (others?) tries to download whatever is on src attribute so setting "url()" like before isnt a good idea
+		// Only results in a 404
+		if(this.childIconSrc){
+			this.childIcon.src = this.childIconSrc;
+		}
+		this.childIcon.style.display = this.childIconSrc ? 'inline' : 'none';
+	},
+
+	setGridImage: function(idx, src){
+
+		if (idx < 0){
+			idx = this.imgs.length + idx;
+		}
+
+		//if (idx >= this.imgs.length-2) return;
+		this.imgs[idx].style.backgroundImage = 'url(' + src + ')';
+	},
+
+
+	updateIconTree: function(){
+		this.tree.updateIconTree.call(this);
+	},
+
+
+
+
+	expand: function(){
+		if (this.isExpanded) return;
+
+		if (this.children.length) {
+			this.showChildren();
+		}
+
+		this.isExpanded = true;
+
+		this.updateExpandIcon();
+
+		dojo.event.topic.publish(this.tree.eventNames.expand, {source: this} );
+	},
+
+	collapse: function(){
+		if (!this.isExpanded) return;
+
+		this.hideChildren();
+		this.isExpanded = false;
+
+		this.updateExpandIcon();
+
+		dojo.event.topic.publish(this.tree.eventNames.collapse, {source: this} );
+	},
+
+	hideChildren: function(){
+		this.tree.toggleObj.hide(
+			this.containerNode, this.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onHide")
+		);
+
+		/* if dnd is in action, recalculate changed coordinates */
+		if(dojo.exists(dojo, 'dnd.dragManager.dragObjects') && dojo.dnd.dragManager.dragObjects.length) {
+			dojo.dnd.dragManager.cacheTargetLocations();
+		}
+	},
+
+	showChildren: function(){
+		this.tree.toggleObj.show(
+			this.containerNode, this.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onShow")
+		);
+
+		/* if dnd is in action, recalculate changed coordinates */
+		if(dojo.exists(dojo, 'dnd.dragManager.dragObjects') && dojo.dnd.dragManager.dragObjects.length) {
+			dojo.dnd.dragManager.cacheTargetLocations();
+		}
+	},
+
+	addChild: function(){
+		return this.tree.addChild.apply(this, arguments);
+	},
+
+	doAddChild: function(){
+		return this.tree.doAddChild.apply(this, arguments);
+	},
+
+
+
+	/* Edit current node : change properties and update contents */
+	edit: function(props) {
+		dojo.lang.mixin(this, props);
+		if (props.title) {
+			this.titleNode.innerHTML = this.title;
+		}
+
+		if (props.afterLabel) {
+			this.afterLabelNode.innerHTML = this.afterLabel;
+		}
+
+		if (props.childIconSrc) {
+			this.buildChildIcon();
+		}
+
+
+	},
+
+
+	removeNode: function(){ return this.tree.removeNode.apply(this, arguments) },
+	doRemoveNode: function(){ return this.tree.doRemoveNode.apply(this, arguments) },
+
+
+	toString: function() {
+		return "["+this.widgetType+" Tree:"+this.tree+" ID:"+this.widgetId+" Title:"+this.title+"]";
+
+	}
+
+});
+
+
+
+

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeNodeV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeNodeV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeNodeV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,310 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeNodeV3");
-dojo.require("dojo.html.*");
-dojo.require("dojo.event.*");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.TreeWithNode");
-dojo.widget.defineWidget("dojo.widget.TreeNodeV3", [dojo.widget.HtmlWidget, dojo.widget.TreeWithNode], function () {
-	this.actionsDisabled = [];
-	this.object = {};
-}, {tryLazyInit:true, actions:{MOVE:"MOVE", DETACH:"DETACH", EDIT:"EDIT", ADDCHILD:"ADDCHILD", SELECT:"SELECT"}, labelClass:"", contentClass:"", expandNode:null, labelNode:null, nodeDocType:"", selected:false, getnodeDocType:function () {
-	return this.nodeDocType;
-}, cloneProperties:["actionsDisabled", "tryLazyInit", "nodeDocType", "objectId", "object", "title", "isFolder", "isExpanded", "state"], clone:function (deep) {
-	var ret = new this.constructor();
-	for (var i = 0; i < this.cloneProperties.length; i++) {
-		var prop = this.cloneProperties[i];
-		ret[prop] = dojo.lang.shallowCopy(this[prop], true);
-	}
-	if (this.tree.unsetFolderOnEmpty && !deep && this.isFolder) {
-		ret.isFolder = false;
-	}
-	ret.toggleObj = this.toggleObj;
-	dojo.widget.manager.add(ret);
-	ret.tree = this.tree;
-	ret.buildRendering({}, {});
-	ret.initialize({}, {});
-	if (deep && this.children.length) {
-		for (var i = 0; i < this.children.length; i++) {
-			var child = this.children[i];
-			if (child.clone) {
-				ret.children.push(child.clone(deep));
-			} else {
-				ret.children.push(dojo.lang.shallowCopy(child, deep));
-			}
-		}
-		ret.setChildren();
-	}
-	return ret;
-}, markProcessing:function () {
-	this.markProcessingSavedClass = dojo.html.getClass(this.expandNode);
-	dojo.html.setClass(this.expandNode, this.tree.classPrefix + "ExpandLoading");
-}, unmarkProcessing:function () {
-	dojo.html.setClass(this.expandNode, this.markProcessingSavedClass);
-}, buildRendering:function (args, fragment, parent) {
-	if (args.tree) {
-		this.tree = dojo.lang.isString(args.tree) ? dojo.widget.manager.getWidgetById(args.tree) : args.tree;
-	} else {
-		if (parent && parent.tree) {
-			this.tree = parent.tree;
-		}
-	}
-	if (!this.tree) {
-		dojo.raise("Can't evaluate tree from arguments or parent");
-	}
-	this.domNode = this.tree.nodeTemplate.cloneNode(true);
-	this.expandNode = this.domNode.firstChild;
-	this.contentNode = this.domNode.childNodes[1];
-	this.labelNode = this.contentNode.firstChild;
-	if (this.labelClass) {
-		dojo.html.addClass(this.labelNode, this.labelClass);
-	}
-	if (this.contentClass) {
-		dojo.html.addClass(this.contentNode, this.contentClass);
-	}
-	this.domNode.widgetId = this.widgetId;
-	this.labelNode.innerHTML = this.title;
-}, isTreeNode:true, object:{}, title:"", isFolder:null, contentNode:null, expandClass:"", isExpanded:false, containerNode:null, getInfo:function () {
-	var info = {widgetId:this.widgetId, objectId:this.objectId, index:this.getParentIndex()};
-	return info;
-}, setFolder:function () {
-	this.isFolder = true;
-	this.viewSetExpand();
-	if (!this.containerNode) {
-		this.viewAddContainer();
-	}
-	dojo.event.topic.publish(this.tree.eventNames.afterSetFolder, {source:this});
-}, initialize:function (args, frag, parent) {
-	if (args.isFolder) {
-		this.isFolder = true;
-	}
-	if (this.children.length || this.isFolder) {
-		this.setFolder();
-	} else {
-		this.viewSetExpand();
-	}
-	for (var i = 0; i < this.actionsDisabled.length; i++) {
-		this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
-	}
-	dojo.event.topic.publish(this.tree.eventNames.afterChangeTree, {oldTree:null, newTree:this.tree, node:this});
-}, unsetFolder:function () {
-	this.isFolder = false;
-	this.viewSetExpand();
-	dojo.event.topic.publish(this.tree.eventNames.afterUnsetFolder, {source:this});
-}, insertNode:function (parent, index) {
-	if (!index) {
-		index = 0;
-	}
-	if (index == 0) {
-		dojo.html.prependChild(this.domNode, parent.containerNode);
-	} else {
-		dojo.html.insertAfter(this.domNode, parent.children[index - 1].domNode);
-	}
-}, updateTree:function (newTree) {
-	if (this.tree === newTree) {
-		return;
-	}
-	var oldTree = this.tree;
-	dojo.lang.forEach(this.getDescendants(), function (elem) {
-		elem.tree = newTree;
-	});
-	if (oldTree.classPrefix != newTree.classPrefix) {
-		var stack = [this.domNode];
-		var elem;
-		var reg = new RegExp("(^|\\s)" + oldTree.classPrefix, "g");
-		while (elem = stack.pop()) {
-			for (var i = 0; i < elem.childNodes.length; i++) {
-				var childNode = elem.childNodes[i];
-				if (childNode.nodeDocType != 1) {
-					continue;
-				}
-				dojo.html.setClass(childNode, dojo.html.getClass(childNode).replace(reg, "$1" + newTree.classPrefix));
-				stack.push(childNode);
-			}
-		}
-	}
-	var message = {oldTree:oldTree, newTree:newTree, node:this};
-	dojo.event.topic.publish(this.tree.eventNames.afterChangeTree, message);
-	dojo.event.topic.publish(newTree.eventNames.afterChangeTree, message);
-}, addedTo:function (parent, index, dontPublishEvent) {
-	if (this.tree !== parent.tree) {
-		this.updateTree(parent.tree);
-	}
-	if (parent.isTreeNode) {
-		if (!parent.isFolder) {
-			parent.setFolder();
-			parent.state = parent.loadStates.LOADED;
-		}
-	}
-	var siblingsCount = parent.children.length;
-	this.insertNode(parent, index);
-	this.viewAddLayout();
-	if (siblingsCount > 1) {
-		if (index == 0 && parent.children[1] instanceof dojo.widget.Widget) {
-			parent.children[1].viewUpdateLayout();
-		}
-		if (index == siblingsCount - 1 && parent.children[siblingsCount - 2] instanceof dojo.widget.Widget) {
-			parent.children[siblingsCount - 2].viewUpdateLayout();
-		}
-	} else {
-		if (parent.isTreeNode) {
-			parent.viewSetHasChildren();
-		}
-	}
-	if (!dontPublishEvent) {
-		var message = {child:this, index:index, parent:parent};
-		dojo.event.topic.publish(this.tree.eventNames.afterAddChild, message);
-	}
-}, createSimple:function (args, parent) {
-	if (args.tree) {
-		var tree = args.tree;
-	} else {
-		if (parent) {
-			var tree = parent.tree;
-		} else {
-			dojo.raise("createSimple: can't evaluate tree");
-		}
-	}
-	tree = dojo.widget.byId(tree);
-	var treeNode = new tree.defaultChildWidget();
-	for (var x in args) {
-		treeNode[x] = args[x];
-	}
-	treeNode.toggleObj = dojo.lfx.toggle[treeNode.toggle.toLowerCase()] || dojo.lfx.toggle.plain;
-	dojo.widget.manager.add(treeNode);
-	treeNode.buildRendering(args, {}, parent);
-	treeNode.initialize(args, {}, parent);
-	if (treeNode.parent) {
-		delete dojo.widget.manager.topWidgets[treeNode.widgetId];
-	}
-	return treeNode;
-}, viewUpdateLayout:function () {
-	this.viewRemoveLayout();
-	this.viewAddLayout();
-}, viewAddContainer:function () {
-	this.containerNode = this.tree.containerNodeTemplate.cloneNode(true);
-	this.domNode.appendChild(this.containerNode);
-}, viewAddLayout:function () {
-	if (this.parent["isTree"]) {
-		dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode) + " " + this.tree.classPrefix + "IsRoot");
-	}
-	if (this.isLastChild()) {
-		dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode) + " " + this.tree.classPrefix + "IsLast");
-	}
-}, viewRemoveLayout:function () {
-	dojo.html.removeClass(this.domNode, this.tree.classPrefix + "IsRoot");
-	dojo.html.removeClass(this.domNode, this.tree.classPrefix + "IsLast");
-}, viewGetExpandClass:function () {
-	if (this.isFolder) {
-		return this.isExpanded ? "ExpandOpen" : "ExpandClosed";
-	} else {
-		return "ExpandLeaf";
-	}
-}, viewSetExpand:function () {
-	var expand = this.tree.classPrefix + this.viewGetExpandClass();
-	var reg = new RegExp("(^|\\s)" + this.tree.classPrefix + "Expand\\w+", "g");
-	dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode).replace(reg, "") + " " + expand);
-	this.viewSetHasChildrenAndExpand();
-}, viewGetChildrenClass:function () {
-	return "Children" + (this.children.length ? "Yes" : "No");
-}, viewSetHasChildren:function () {
-	var clazz = this.tree.classPrefix + this.viewGetChildrenClass();
-	var reg = new RegExp("(^|\\s)" + this.tree.classPrefix + "Children\\w+", "g");
-	dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode).replace(reg, "") + " " + clazz);
-	this.viewSetHasChildrenAndExpand();
-}, viewSetHasChildrenAndExpand:function () {
-	var clazz = this.tree.classPrefix + "State" + this.viewGetChildrenClass() + "-" + this.viewGetExpandClass();
-	var reg = new RegExp("(^|\\s)" + this.tree.classPrefix + "State[\\w-]+", "g");
-	dojo.html.setClass(this.domNode, dojo.html.getClass(this.domNode).replace(reg, "") + " " + clazz);
-}, viewUnfocus:function () {
-	dojo.html.removeClass(this.labelNode, this.tree.classPrefix + "LabelFocused");
-}, viewFocus:function () {
-	dojo.html.addClass(this.labelNode, this.tree.classPrefix + "LabelFocused");
-}, viewEmphasize:function () {
-	dojo.html.clearSelection(this.labelNode);
-	dojo.html.addClass(this.labelNode, this.tree.classPrefix + "NodeEmphasized");
-}, viewUnemphasize:function () {
-	dojo.html.removeClass(this.labelNode, this.tree.classPrefix + "NodeEmphasized");
-}, detach:function () {
-	if (!this.parent) {
-		return;
-	}
-	var parent = this.parent;
-	var index = this.getParentIndex();
-	this.doDetach.apply(this, arguments);
-	dojo.event.topic.publish(this.tree.eventNames.afterDetach, {child:this, parent:parent, index:index});
-}, doDetach:function () {
-	var parent = this.parent;
-	if (!parent) {
-		return;
-	}
-	var index = this.getParentIndex();
-	this.viewRemoveLayout();
-	dojo.widget.DomWidget.prototype.removeChild.call(parent, this);
-	var siblingsCount = parent.children.length;
-	if (siblingsCount > 0) {
-		if (index == 0) {
-			parent.children[0].viewUpdateLayout();
-		}
-		if (index == siblingsCount) {
-			parent.children[siblingsCount - 1].viewUpdateLayout();
-		}
-	} else {
-		if (parent.isTreeNode) {
-			parent.viewSetHasChildren();
-		}
-	}
-	if (this.tree.unsetFolderOnEmpty && !parent.children.length && parent.isTreeNode) {
-		parent.unsetFolder();
-	}
-	this.parent = null;
-}, destroy:function () {
-	dojo.event.topic.publish(this.tree.eventNames.beforeNodeDestroy, {source:this});
-	this.detach();
-	return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
-}, expand:function () {
-	if (this.isExpanded) {
-		return;
-	}
-	if (this.tryLazyInit) {
-		this.setChildren();
-		this.tryLazyInit = false;
-	}
-	this.isExpanded = true;
-	this.viewSetExpand();
-	this.showChildren();
-}, collapse:function () {
-	if (!this.isExpanded) {
-		return;
-	}
-	this.isExpanded = false;
-	this.hideChildren();
-}, hideChildren:function () {
-	this.tree.toggleObj.hide(this.containerNode, this.tree.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onHideChildren"));
-}, showChildren:function () {
-	this.tree.toggleObj.show(this.containerNode, this.tree.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, "onShowChildren"));
-}, onShowChildren:function () {
-	this.onShow();
-	dojo.event.topic.publish(this.tree.eventNames.afterExpand, {source:this});
-}, onHideChildren:function () {
-	this.viewSetExpand();
-	this.onHide();
-	dojo.event.topic.publish(this.tree.eventNames.afterCollapse, {source:this});
-}, setTitle:function (title) {
-	var oldTitle = this.title;
-	this.labelNode.innerHTML = this.title = title;
-	dojo.event.topic.publish(this.tree.eventNames.afterSetTitle, {source:this, oldTitle:oldTitle});
-}, toString:function () {
-	return "[" + this.widgetType + ", " + this.title + "]";
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeRPCController.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeRPCController.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeRPCController.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -9,64 +9,163 @@
 */
 
 
+dojo.provide("dojo.widget.TreeRPCController");
 
-dojo.provide("dojo.widget.TreeRPCController");
 dojo.require("dojo.event.*");
-dojo.require("dojo.json");
+dojo.require("dojo.json")
 dojo.require("dojo.io.*");
 dojo.require("dojo.widget.TreeLoadingController");
-dojo.widget.defineWidget("dojo.widget.TreeRPCController", dojo.widget.TreeLoadingController, {doMove:function (child, newParent, index) {
-	var params = {child:this.getInfo(child), childTree:this.getInfo(child.tree), newParent:this.getInfo(newParent), newParentTree:this.getInfo(newParent.tree), newIndex:index};
-	var success;
-	this.runRPC({url:this.getRPCUrl("move"), load:function (response) {
-		success = this.doMoveProcessResponse(response, child, newParent, index);
-	}, sync:true, lock:[child, newParent], params:params});
-	return success;
-}, doMoveProcessResponse:function (response, child, newParent, index) {
-	if (!dojo.lang.isUndefined(response.error)) {
-		this.RPCErrorHandler("server", response.error);
-		return false;
-	}
-	var args = [child, newParent, index];
-	return dojo.widget.TreeLoadingController.prototype.doMove.apply(this, args);
-}, doRemoveNode:function (node, callObj, callFunc) {
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree)};
-	this.runRPC({url:this.getRPCUrl("removeNode"), load:function (response) {
-		this.doRemoveNodeProcessResponse(response, node, callObj, callFunc);
-	}, params:params, lock:[node]});
-}, doRemoveNodeProcessResponse:function (response, node, callObj, callFunc) {
-	if (!dojo.lang.isUndefined(response.error)) {
-		this.RPCErrorHandler("server", response.error);
-		return false;
-	}
-	if (!response) {
-		return false;
-	}
-	if (response == true) {
-		var args = [node, callObj, callFunc];
-		dojo.widget.TreeLoadingController.prototype.doRemoveNode.apply(this, args);
-		return;
-	} else {
-		if (dojo.lang.isObject(response)) {
+
+dojo.widget.tags.addParseTreeHandler("dojo:TreeRPCController");
+
+dojo.widget.TreeRPCController = function(){
+	dojo.widget.TreeLoadingController.call(this);
+}
+
+dojo.inherits(dojo.widget.TreeRPCController, dojo.widget.TreeLoadingController);
+
+dojo.lang.extend(dojo.widget.TreeRPCController, {
+	widgetType: "TreeRPCController",
+
+	/**
+	 * Make request to server about moving children.
+	 *
+	 * Request returns "true" if move succeeded,
+	 * object with error field if failed
+	 *
+	 * I can't leave DragObject floating until async request returns, need to return false/true
+	 * so making it sync way...
+	 *
+	 * Also, "loading" icon is not shown until function finishes execution, so no indication for remote request.
+	*/
+	doMove: function(child, newParent, index){
+
+		//if (newParent.isTreeNode) newParent.markLoading();
+
+		var params = {
+			// where from
+			child: this.getInfo(child),
+			childTree: this.getInfo(child.tree),
+			// where to
+			newParent: this.getInfo(newParent),
+			newParentTree: this.getInfo(newParent.tree),
+			newIndex: index
+		};
+
+		var success;
+
+		this.runRPC({		
+			url: this.getRPCUrl('move'),
+			/* I hitch to get this.loadOkHandler */
+			load: function(response){
+				success = this.doMoveProcessResponse(response, child, newParent, index) ;
+			},
+			sync: true,
+			lock: [child, newParent],
+			params: params
+		});
+
+
+		return success;
+	},
+
+	doMoveProcessResponse: function(response, child, newParent, index){
+
+		if(!dojo.lang.isUndefined(response.error)){
+			this.RPCErrorHandler("server", response.error);
+			return false;
+		}
+
+		var args = [child, newParent, index];
+		return dojo.widget.TreeLoadingController.prototype.doMove.apply(this, args);
+
+	},
+
+
+	doRemoveNode: function(node, callObj, callFunc){
+
+		var params = {
+			node: this.getInfo(node),
+			tree: this.getInfo(node.tree)
+		}
+
+		this.runRPC({
+				url: this.getRPCUrl('removeNode'),
+				/* I hitch to get this.loadOkHandler */
+				load: function(response){
+					this.doRemoveNodeProcessResponse(response, node, callObj, callFunc) 
+				},
+				params: params,
+				lock: [node]
+		});
+
+	},
+
+
+	doRemoveNodeProcessResponse: function(response, node, callObj, callFunc){
+		if(!dojo.lang.isUndefined(response.error)){
+			this.RPCErrorHandler("server", response.error);
+			return false;
+		}
+
+		if(!response){ return false; }
+
+		if(response == true){
+			/* change parent succeeded */
+			var args = [ node, callObj, callFunc ];
+			dojo.widget.TreeLoadingController.prototype.doRemoveNode.apply(this, args);
+
+			return;
+		}else if(dojo.lang.isObject(response)){
 			dojo.raise(response.error);
-		} else {
-			dojo.raise("Invalid response " + response);
+		}else{
+			dojo.raise("Invalid response "+response)
 		}
+
+
+	},
+
+
+
+	// -----------------------------------------------------------------------------
+	//                             Create node stuff
+	// -----------------------------------------------------------------------------
+
+
+	doCreateChild: function(parent, index, output, callObj, callFunc){
+
+			var params = {
+				tree: this.getInfo(parent.tree),
+				parent: this.getInfo(parent),
+				index: index,
+				data: output
+			}
+
+			this.runRPC({
+				url: this.getRPCUrl('createChild'),
+				load: function(response) {
+					// suggested data is dead, fresh data from server is used
+					this.doCreateChildProcessResponse( response, parent, index, callObj, callFunc) 
+				},
+				params: params,
+				lock: [parent]
+			});
+
+	},
+
+	doCreateChildProcessResponse: function(response, parent, index, callObj, callFunc){
+
+		if(!dojo.lang.isUndefined(response.error)){
+			this.RPCErrorHandler("server",response.error);
+			return false;
+		}
+
+		if(!dojo.lang.isObject(response)){
+			dojo.raise("Invalid result "+response)
+		}
+
+		var args = [parent, index, response, callObj, callFunc];
+		
+		dojo.widget.TreeLoadingController.prototype.doCreateChild.apply(this, args);
 	}
-}, doCreateChild:function (parent, index, output, callObj, callFunc) {
-	var params = {tree:this.getInfo(parent.tree), parent:this.getInfo(parent), index:index, data:output};
-	this.runRPC({url:this.getRPCUrl("createChild"), load:function (response) {
-		this.doCreateChildProcessResponse(response, parent, index, callObj, callFunc);
-	}, params:params, lock:[parent]});
-}, doCreateChildProcessResponse:function (response, parent, index, callObj, callFunc) {
-	if (!dojo.lang.isUndefined(response.error)) {
-		this.RPCErrorHandler("server", response.error);
-		return false;
-	}
-	if (!dojo.lang.isObject(response)) {
-		dojo.raise("Invalid result " + response);
-	}
-	var args = [parent, index, response, callObj, callFunc];
-	dojo.widget.TreeLoadingController.prototype.doCreateChild.apply(this, args);
-}});
-
+});

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeRpcControllerV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeRpcControllerV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeRpcControllerV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,182 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeRpcControllerV3");
-dojo.require("dojo.event.*");
-dojo.require("dojo.json");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.TreeLoadingControllerV3");
-dojo.widget.defineWidget("dojo.widget.TreeRpcControllerV3", dojo.widget.TreeLoadingControllerV3, {extraRpcOnEdit:false, doMove:function (child, newParent, index, sync) {
-	var params = {child:this.getInfo(child), childTree:this.getInfo(child.tree), oldParent:this.getInfo(child.parent), oldParentTree:this.getInfo(child.parent.tree), newParent:this.getInfo(newParent), newParentTree:this.getInfo(newParent.tree), newIndex:index};
-	var deferred = this.runRpc({url:this.getRpcUrl("move"), sync:sync, params:params});
-	var _this = this;
-	var args = arguments;
-	deferred.addCallback(function () {
-		dojo.widget.TreeBasicControllerV3.prototype.doMove.apply(_this, args);
-	});
-	return deferred;
-}, prepareDetach:function (node, sync) {
-	var deferred = this.startProcessing(node);
-	return deferred;
-}, finalizeDetach:function (node) {
-	this.finishProcessing(node);
-}, doDetach:function (node, sync) {
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree)};
-	var deferred = this.runRpc({url:this.getRpcUrl("detach"), sync:sync, params:params});
-	var _this = this;
-	var args = arguments;
-	deferred.addCallback(function () {
-		dojo.widget.TreeBasicControllerV3.prototype.doDetach.apply(_this, args);
-	});
-	return deferred;
-}, requestEditConfirmation:function (node, action, sync) {
-	if (!this.extraRpcOnEdit) {
-		return dojo.Deferred.prototype.makeCalled();
-	}
-	var _this = this;
-	var deferred = this.startProcessing(node);
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree)};
-	deferred.addCallback(function () {
-		return _this.runRpc({url:_this.getRpcUrl(action), sync:sync, params:params});
-	});
-	deferred.addBoth(function (r) {
-		_this.finishProcessing(node);
-		return r;
-	});
-	return deferred;
-}, editLabelSave:function (node, newContent, sync) {
-	var deferred = this.startProcessing(node);
-	var _this = this;
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree), newContent:newContent};
-	deferred.addCallback(function () {
-		return _this.runRpc({url:_this.getRpcUrl("editLabelSave"), sync:sync, params:params});
-	});
-	deferred.addBoth(function (r) {
-		_this.finishProcessing(node);
-		return r;
-	});
-	return deferred;
-}, editLabelStart:function (node, sync) {
-	if (!this.canEditLabel(node)) {
-		return false;
-	}
-	var _this = this;
-	if (!this.editor.isClosed()) {
-		var deferred = this.editLabelFinish(this.editor.saveOnBlur, sync);
-		deferred.addCallback(function () {
-			return _this.editLabelStart(node, sync);
-		});
-		return deferred;
-	}
-	var deferred = this.requestEditConfirmation(node, "editLabelStart", sync);
-	deferred.addCallback(function () {
-		_this.doEditLabelStart(node);
-	});
-	return deferred;
-}, editLabelFinish:function (save, sync) {
-	var _this = this;
-	var node = this.editor.node;
-	var deferred = dojo.Deferred.prototype.makeCalled();
-	if (!save && !node.isPhantom) {
-		deferred = this.requestEditConfirmation(this.editor.node, "editLabelFinishCancel", sync);
-	}
-	if (save) {
-		if (node.isPhantom) {
-			deferred = this.sendCreateChildRequest(node.parent, node.getParentIndex(), {title:this.editor.getContents()}, sync);
-		} else {
-			deferred = this.editLabelSave(node, this.editor.getContents(), sync);
-		}
-	}
-	deferred.addCallback(function (server_data) {
-		_this.doEditLabelFinish(save, server_data);
-	});
-	deferred.addErrback(function (r) {
-		_this.doEditLabelFinish(false);
-		return false;
-	});
-	return deferred;
-}, createAndEdit:function (parent, index, sync) {
-	var data = {title:parent.tree.defaultChildTitle};
-	if (!this.canCreateChild(parent, index, data)) {
-		return false;
-	}
-	if (!this.editor.isClosed()) {
-		var deferred = this.editLabelFinish(this.editor.saveOnBlur, sync);
-		deferred.addCallback(function () {
-			return _this.createAndEdit(parent, index, sync);
-		});
-		return deferred;
-	}
-	var _this = this;
-	var deferred = this.prepareCreateChild(parent, index, data, sync);
-	deferred.addCallback(function () {
-		var child = _this.makeDefaultNode(parent, index);
-		child.isPhantom = true;
-		return child;
-	});
-	deferred.addBoth(function (r) {
-		_this.finalizeCreateChild(parent, index, data, sync);
-		return r;
-	});
-	deferred.addCallback(function (child) {
-		var d = _this.exposeCreateChild(parent, index, data, sync);
-		d.addCallback(function () {
-			return child;
-		});
-		return d;
-	});
-	deferred.addCallback(function (child) {
-		_this.doEditLabelStart(child);
-		return child;
-	});
-	return deferred;
-}, prepareDestroyChild:function (node, sync) {
-	var deferred = this.startProcessing(node);
-	return deferred;
-}, finalizeDestroyChild:function (node) {
-	this.finishProcessing(node);
-}, doDestroyChild:function (node, sync) {
-	var params = {node:this.getInfo(node), tree:this.getInfo(node.tree)};
-	var deferred = this.runRpc({url:this.getRpcUrl("destroyChild"), sync:sync, params:params});
-	var _this = this;
-	var args = arguments;
-	deferred.addCallback(function () {
-		dojo.widget.TreeBasicControllerV3.prototype.doDestroyChild.apply(_this, args);
-	});
-	return deferred;
-}, sendCreateChildRequest:function (parent, index, data, sync) {
-	var params = {tree:this.getInfo(parent.tree), parent:this.getInfo(parent), index:index, data:data};
-	var deferred = this.runRpc({url:this.getRpcUrl("createChild"), sync:sync, params:params});
-	return deferred;
-}, doCreateChild:function (parent, index, data, sync) {
-	if (dojo.lang.isUndefined(data.title)) {
-		data.title = parent.tree.defaultChildTitle;
-	}
-	var deferred = this.sendCreateChildRequest(parent, index, data, sync);
-	var _this = this;
-	var args = arguments;
-	deferred.addCallback(function (server_data) {
-		dojo.lang.mixin(data, server_data);
-		return dojo.widget.TreeBasicControllerV3.prototype.doCreateChild.call(_this, parent, index, data);
-	});
-	return deferred;
-}, doClone:function (child, newParent, index, deep, sync) {
-	var params = {child:this.getInfo(child), oldParent:this.getInfo(child.parent), oldParentTree:this.getInfo(child.parent.tree), newParent:this.getInfo(newParent), newParentTree:this.getInfo(newParent.tree), index:index, deep:deep ? true : false, tree:this.getInfo(child.tree)};
-	var deferred = this.runRpc({url:this.getRpcUrl("clone"), sync:sync, params:params});
-	var _this = this;
-	var args = arguments;
-	deferred.addCallback(function () {
-		dojo.widget.TreeBasicControllerV3.prototype.doClone.apply(_this, args);
-	});
-	return deferred;
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/TreeSelector.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeSelector.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeSelector.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -9,94 +9,175 @@
 */
 
 
+dojo.provide("dojo.widget.TreeSelector");
 
-dojo.provide("dojo.widget.TreeSelector");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.TreeSelector", dojo.widget.HtmlWidget, function () {
+
+
+dojo.widget.tags.addParseTreeHandler("dojo:TreeSelector");
+
+
+dojo.widget.TreeSelector = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+
 	this.eventNames = {};
+
 	this.listenedTrees = [];
-}, {widgetType:"TreeSelector", selectedNode:null, dieWithTree:false, eventNamesDefault:{select:"select", destroy:"destroy", deselect:"deselect", dblselect:"dblselect"}, initialize:function () {
-	for (var name in this.eventNamesDefault) {
-		if (dojo.lang.isUndefined(this.eventNames[name])) {
-			this.eventNames[name] = this.widgetId + "/" + this.eventNamesDefault[name];
+
+}
+
+dojo.inherits(dojo.widget.TreeSelector, dojo.widget.HtmlWidget);
+
+
+dojo.lang.extend(dojo.widget.TreeSelector, {
+	widgetType: "TreeSelector",
+	selectedNode: null,
+
+	dieWithTree: false,
+
+	eventNamesDefault: {
+		select : "select",
+		destroy : "destroy",
+		deselect : "deselect",
+		dblselect: "dblselect" // select already selected node.. Edit or whatever
+	},
+
+	initialize: function() {
+
+		for(name in this.eventNamesDefault) {
+			if (dojo.lang.isUndefined(this.eventNames[name])) {
+				this.eventNames[name] = this.widgetId+"/"+this.eventNamesDefault[name];
+			}
 		}
-	}
-}, destroy:function () {
-	dojo.event.topic.publish(this.eventNames.destroy, {source:this});
-	return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
-}, listenTree:function (tree) {
-	dojo.event.topic.subscribe(tree.eventNames.titleClick, this, "select");
-	dojo.event.topic.subscribe(tree.eventNames.iconClick, this, "select");
-	dojo.event.topic.subscribe(tree.eventNames.collapse, this, "onCollapse");
-	dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
-	dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
-	dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-	this.listenedTrees.push(tree);
-}, unlistenTree:function (tree) {
-	dojo.event.topic.unsubscribe(tree.eventNames.titleClick, this, "select");
-	dojo.event.topic.unsubscribe(tree.eventNames.iconClick, this, "select");
-	dojo.event.topic.unsubscribe(tree.eventNames.collapse, this, "onCollapse");
-	dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
-	dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
-	dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
-	for (var i = 0; i < this.listenedTrees.length; i++) {
-		if (this.listenedTrees[i] === tree) {
-			this.listenedTrees.splice(i, 1);
-			break;
+
+	},
+
+
+	destroy: function() {
+		dojo.event.topic.publish(this.eventNames.destroy, { source: this } );
+
+		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
+	},
+
+
+	listenTree: function(tree) {
+		dojo.event.topic.subscribe(tree.eventNames.titleClick, this, "select");
+		dojo.event.topic.subscribe(tree.eventNames.iconClick, this, "select");
+		dojo.event.topic.subscribe(tree.eventNames.collapse, this, "onCollapse");
+		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
+		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, "onRemoveNode");
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+
+		/* remember all my trees to deselect when element is movedFrom them */
+		this.listenedTrees.push(tree);
+	},
+
+
+	unlistenTree: function(tree) {
+
+		dojo.event.topic.unsubscribe(tree.eventNames.titleClick, this, "select");
+		dojo.event.topic.unsubscribe(tree.eventNames.iconClick, this, "select");
+		dojo.event.topic.unsubscribe(tree.eventNames.collapse, this, "onCollapse");
+		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, "onMoveFrom");
+		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, "onRemoveNode");
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, "onTreeDestroy");
+
+
+		for(var i=0; i<this.listenedTrees.length; i++){
+           if(this.listenedTrees[i] === tree){
+                   this.listenedTrees.splice(i, 1);
+                   break;
+           }
 		}
-	}
-}, onTreeDestroy:function (message) {
-	this.unlistenTree(message.source);
-	if (this.dieWithTree) {
-		this.destroy();
-	}
-}, onCollapse:function (message) {
-	if (!this.selectedNode) {
-		return;
-	}
-	var node = message.source;
-	var parent = this.selectedNode.parent;
-	while (parent !== node && parent.isTreeNode) {
-		parent = parent.parent;
-	}
-	if (parent.isTreeNode) {
-		this.deselect();
-	}
-}, select:function (message) {
-	var node = message.source;
-	var e = message.event;
-	if (this.selectedNode === node) {
-		if (e.ctrlKey || e.shiftKey || e.metaKey) {
+	},
+
+
+	onTreeDestroy: function(message) {
+
+		this.unlistenTree(message.source);
+
+		if (this.dieWithTree) {
+			//dojo.debug("Killing myself "+this.widgetId);
+			this.destroy();
+			//dojo.debug("done");
+		}
+	},
+
+
+	// deselect node if parent is collapsed
+	onCollapse: function(message) {
+		if (!this.selectedNode) return;
+
+		var node = message.source;
+		var parent = this.selectedNode.parent;
+		while (parent !== node && parent.isTreeNode) {
+			parent = parent.parent;
+		}
+		if (parent.isTreeNode) {
 			this.deselect();
+		}
+	},
+
+
+
+	select: function(message) {
+		var node = message.source;
+		var e = message.event;
+
+		if (this.selectedNode === node) {
+			dojo.event.topic.publish(this.eventNames.dblselect, { node: node });
 			return;
 		}
-		dojo.event.topic.publish(this.eventNames.dblselect, {node:node});
-		return;
-	}
-	if (this.selectedNode) {
+
+		if (this.selectedNode) {
+			this.deselect();
+		}
+
+		this.doSelect(node);
+
+		dojo.event.topic.publish(this.eventNames.select, {node: node} );
+	},
+
+	/**
+	 * Deselect node if target tree is out of our concern
+	 */
+	onMoveFrom: function(message) {
+		if (message.child !== this.selectedNode) {
+			return;
+		}
+
+		if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+			this.deselect();
+		}
+	},
+
+	onRemoveNode: function(message) {
+		if (message.child !== this.selectedNode) {
+			return;
+		}
+
 		this.deselect();
+	},
+
+	doSelect: function(node){
+
+		node.markSelected();
+
+		this.selectedNode = node;
+	},
+
+	deselect: function(){
+
+		var node = this.selectedNode;
+
+		this.selectedNode = null;
+		node.unMarkSelected();
+		dojo.event.topic.publish(this.eventNames.deselect, {node: node} );
+
 	}
-	this.doSelect(node);
-	dojo.event.topic.publish(this.eventNames.select, {node:node});
-}, onMoveFrom:function (message) {
-	if (message.child !== this.selectedNode) {
-		return;
-	}
-	if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
-		this.deselect();
-	}
-}, onRemoveNode:function (message) {
-	if (message.child !== this.selectedNode) {
-		return;
-	}
-	this.deselect();
-}, doSelect:function (node) {
-	node.markSelected();
-	this.selectedNode = node;
-}, deselect:function () {
-	var node = this.selectedNode;
-	this.selectedNode = null;
-	node.unMarkSelected();
-	dojo.event.topic.publish(this.eventNames.deselect, {node:node});
-}});
 
+});
+
+
+

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeSelectorV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeSelectorV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeSelectorV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,160 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeSelectorV3");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeCommon");
-dojo.widget.defineWidget("dojo.widget.TreeSelectorV3", [dojo.widget.HtmlWidget, dojo.widget.TreeCommon], function () {
-	this.eventNames = {};
-	this.listenedTrees = {};
-	this.selectedNodes = [];
-	this.lastClicked = {};
-}, {listenTreeEvents:["afterTreeCreate", "afterCollapse", "afterChangeTree", "afterDetach", "beforeTreeDestroy"], listenNodeFilter:function (elem) {
-	return elem instanceof dojo.widget.Widget;
-}, allowedMulti:true, dblselectTimeout:300, eventNamesDefault:{select:"select", deselect:"deselect", dblselect:"dblselect"}, onAfterTreeCreate:function (message) {
-	var tree = message.source;
-	dojo.event.browser.addListener(tree.domNode, "onclick", dojo.lang.hitch(this, this.onTreeClick));
-	if (dojo.render.html.ie) {
-		dojo.event.browser.addListener(tree.domNode, "ondblclick", dojo.lang.hitch(this, this.onTreeDblClick));
-	}
-	dojo.event.browser.addListener(tree.domNode, "onKey", dojo.lang.hitch(this, this.onKey));
-}, onKey:function (e) {
-	if (!e.key || e.ctrkKey || e.altKey) {
-		return;
-	}
-	switch (e.key) {
-	  case e.KEY_ENTER:
-		var node = this.domElement2TreeNode(e.target);
-		if (node) {
-			this.processNode(node, e);
-		}
-	}
-}, onAfterChangeTree:function (message) {
-	if (!message.oldTree && message.node.selected) {
-		this.select(message.node);
-	}
-	if (!message.newTree || !this.listenedTrees[message.newTree.widgetId]) {
-		if (this.selectedNode && message.node.children) {
-			this.deselectIfAncestorMatch(message.node);
-		}
-	}
-}, initialize:function (args) {
-	for (var name in this.eventNamesDefault) {
-		if (dojo.lang.isUndefined(this.eventNames[name])) {
-			this.eventNames[name] = this.widgetId + "/" + this.eventNamesDefault[name];
-		}
-	}
-}, onBeforeTreeDestroy:function (message) {
-	this.unlistenTree(message.source);
-}, onAfterCollapse:function (message) {
-	this.deselectIfAncestorMatch(message.source);
-}, onTreeDblClick:function (event) {
-	this.onTreeClick(event);
-}, checkSpecialEvent:function (event) {
-	return event.shiftKey || event.ctrlKey;
-}, onTreeClick:function (event) {
-	var node = this.domElement2TreeNode(event.target);
-	if (!node) {
-		return;
-	}
-	var checkLabelClick = function (domElement) {
-		return domElement === node.labelNode;
-	};
-	if (this.checkPathCondition(event.target, checkLabelClick)) {
-		this.processNode(node, event);
-	}
-}, processNode:function (node, event) {
-	if (node.actionIsDisabled(node.actions.SELECT)) {
-		return;
-	}
-	if (dojo.lang.inArray(this.selectedNodes, node)) {
-		if (this.checkSpecialEvent(event)) {
-			this.deselect(node);
-			return;
-		}
-		var _this = this;
-		var i = 0;
-		var selectedNode;
-		while (this.selectedNodes.length > i) {
-			selectedNode = this.selectedNodes[i];
-			if (selectedNode !== node) {
-				this.deselect(selectedNode);
-				continue;
-			}
-			i++;
-		}
-		var wasJustClicked = this.checkRecentClick(node);
-		eventName = wasJustClicked ? this.eventNames.dblselect : this.eventNames.select;
-		if (wasJustClicked) {
-			eventName = this.eventNames.dblselect;
-			this.forgetLastClicked();
-		} else {
-			eventName = this.eventNames.select;
-			this.setLastClicked(node);
-		}
-		dojo.event.topic.publish(eventName, {node:node});
-		return;
-	}
-	this.deselectIfNoMulti(event);
-	this.setLastClicked(node);
-	this.select(node);
-}, forgetLastClicked:function () {
-	this.lastClicked = {};
-}, setLastClicked:function (node) {
-	this.lastClicked.date = new Date();
-	this.lastClicked.node = node;
-}, checkRecentClick:function (node) {
-	var diff = new Date() - this.lastClicked.date;
-	if (this.lastClicked.node && diff < this.dblselectTimeout) {
-		return true;
-	} else {
-		return false;
-	}
-}, deselectIfNoMulti:function (event) {
-	if (!this.checkSpecialEvent(event) || !this.allowedMulti) {
-		this.deselectAll();
-	}
-}, deselectIfAncestorMatch:function (ancestor) {
-	var _this = this;
-	dojo.lang.forEach(this.selectedNodes, function (node) {
-		var selectedNode = node;
-		node = node.parent;
-		while (node && node.isTreeNode) {
-			if (node === ancestor) {
-				_this.deselect(selectedNode);
-				return;
-			}
-			node = node.parent;
-		}
-	});
-}, onAfterDetach:function (message) {
-	this.deselectIfAncestorMatch(message.child);
-}, select:function (node) {
-	var index = dojo.lang.find(this.selectedNodes, node, true);
-	if (index >= 0) {
-		return;
-	}
-	this.selectedNodes.push(node);
-	dojo.event.topic.publish(this.eventNames.select, {node:node});
-}, deselect:function (node) {
-	var index = dojo.lang.find(this.selectedNodes, node, true);
-	if (index < 0) {
-		return;
-	}
-	this.selectedNodes.splice(index, 1);
-	dojo.event.topic.publish(this.eventNames.deselect, {node:node});
-}, deselectAll:function () {
-	while (this.selectedNodes.length) {
-		this.deselect(this.selectedNodes[0]);
-	}
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeTimeoutIterator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeTimeoutIterator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeTimeoutIterator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,88 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeTimeoutIterator");
-dojo.require("dojo.event.*");
-dojo.require("dojo.json");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.TreeCommon");
-dojo.declare("dojo.widget.TreeTimeoutIterator", null, function (elem, callFunc, callObj) {
-	var _this = this;
-	this.currentParent = elem;
-	this.callFunc = callFunc;
-	this.callObj = callObj ? callObj : this;
-	this.stack = [];
-}, {maxStackDepth:Number.POSITIVE_INFINITY, stack:null, currentParent:null, currentIndex:0, filterFunc:function () {
-	return true;
-}, finishFunc:function () {
-	return true;
-}, setFilter:function (func, obj) {
-	this.filterFunc = func;
-	this.filterObj = obj;
-}, setMaxLevel:function (level) {
-	this.maxStackDepth = level - 2;
-}, forward:function (timeout) {
-	var _this = this;
-	if (this.timeout) {
-		var tid = setTimeout(function () {
-			_this.processNext();
-			clearTimeout(tid);
-		}, _this.timeout);
-	} else {
-		return this.processNext();
-	}
-}, start:function (processFirst) {
-	if (processFirst) {
-		return this.callFunc.call(this.callObj, this.currentParent, this);
-	}
-	return this.processNext();
-}, processNext:function () {
-	var handler;
-	var _this = this;
-	var found;
-	var next;
-	if (this.maxStackDepth == -2) {
-		return;
-	}
-	while (true) {
-		var children = this.currentParent.children;
-		if (children && children.length) {
-			do {
-				next = children[this.currentIndex];
-			} while (this.currentIndex++ < children.length && !(found = this.filterFunc.call(this.filterObj, next)));
-			if (found) {
-				if (next.isFolder && this.stack.length <= this.maxStackDepth) {
-					this.moveParent(next, 0);
-				}
-				return this.callFunc.call(this.callObj, next, this);
-			}
-		}
-		if (this.stack.length) {
-			this.popParent();
-			continue;
-		}
-		break;
-	}
-	return this.finishFunc.call(this.finishObj);
-}, setFinish:function (func, obj) {
-	this.finishFunc = func;
-	this.finishObj = obj;
-}, popParent:function () {
-	var p = this.stack.pop();
-	this.currentParent = p[0];
-	this.currentIndex = p[1];
-}, moveParent:function (nextParent, nextIndex) {
-	this.stack.push([this.currentParent, this.currentIndex]);
-	this.currentParent = nextParent;
-	this.currentIndex = nextIndex;
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeToggleOnSelect.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeToggleOnSelect.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeToggleOnSelect.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,23 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeToggleOnSelect");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("dojo.widget.TreeToggleOnSelect", dojo.widget.HtmlWidget, {selector:"", controller:"", selectEvent:"select", initialize:function () {
-	this.selector = dojo.widget.byId(this.selector);
-	this.controller = dojo.widget.byId(this.controller);
-	dojo.event.topic.subscribe(this.selector.eventNames[this.selectEvent], this, "onSelectEvent");
-}, onSelectEvent:function (message) {
-	var node = message.node;
-	node.isExpanded ? this.controller.collapse(node) : this.controller.expand(node);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeV3.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeV3.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeV3.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,135 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.TreeV3");
-dojo.require("dojo.widget.TreeWithNode");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.event.*");
-dojo.require("dojo.io.*");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.TreeNodeV3");
-dojo.widget.defineWidget("dojo.widget.TreeV3", [dojo.widget.HtmlWidget, dojo.widget.TreeWithNode], function () {
-	this.eventNames = {};
-	this.DndAcceptTypes = [];
-	this.actionsDisabled = [];
-	this.listeners = [];
-	this.tree = this;
-}, {DndMode:"", defaultChildWidget:null, defaultChildTitle:"New Node", eagerWidgetInstantiation:false, eventNamesDefault:{afterTreeCreate:"afterTreeCreate", beforeTreeDestroy:"beforeTreeDestroy", beforeNodeDestroy:"beforeNodeDestroy", afterChangeTree:"afterChangeTree", afterSetFolder:"afterSetFolder", afterUnsetFolder:"afterUnsetFolder", beforeMoveFrom:"beforeMoveFrom", beforeMoveTo:"beforeMoveTo", afterMoveFrom:"afterMoveFrom", afterMoveTo:"afterMoveTo", afterAddChild:"afterAddChild", afterDetach:"afterDetach", afterExpand:"afterExpand", beforeExpand:"beforeExpand", afterSetTitle:"afterSetTitle", afterCollapse:"afterCollapse", beforeCollapse:"beforeCollapse"}, classPrefix:"Tree", style:"", allowAddChildToLeaf:true, unsetFolderOnEmpty:true, DndModes:{BETWEEN:1, ONTO:2}, DndAcceptTypes:"", templateCssString:"/* indent for all tree children excepts root */\n.TreeNode {\n	background-image : url('../templates/images/TreeV3/i.gif');\n	background-position : top left;\n	background!
 -repeat : repeat-y;\n	margin-left: 19px;\n	zoom: 1;\n}\n.TreeIsRoot {\n	margin-left: 0;\n}\n \n/* left vertical line (grid) for all nodes */\n.TreeIsLast {\n	background-image: url('../templates/images/TreeV3/i_half.gif');\n	background-repeat : no-repeat;\n}\n \n.TreeExpandOpen .TreeExpand {\n	background-image: url('../templates/images/TreeV3/expand_minus.gif');\n}\n \n/* closed is higher priority than open */\n.TreeExpandClosed .TreeExpand {\n	background-image: url('../templates/images/TreeV3/expand_plus.gif');\n}\n \n/* highest priority */\n.TreeExpandLeaf .TreeExpand {\n	background-image: url('../templates/images/TreeV3/expand_leaf.gif');\n}\n\n/* \nshould always override any expand setting, but do not touch children.\nif I add .TreeExpand .TreeExpandLoading same time and put it to top/bottom, then it will take precedence over +- for all descendants or always fail\nso I have to remove TreeExpand and process this one specifically\n*/\n\n.TreeExpandLoading   {\n	width: 18px!
 ;\n	height: 18px;\n	float: left;\n	display: inline;\n	backgrou!
 nd-repea
t : no-repeat;\n	background-image: url('../templates/images/TreeV3/expand_loading.gif');\n}\n \n.TreeContent {\n	min-height: 18px;\n	min-width: 18px;\n	margin-left:18px;\n	cursor: default;\n	/* can't make inline - multiline bugs */\n}\n\n.TreeIEContent {\n\theight: 18px;\n}\n \n.TreeExpand {\n	width: 18px;\n	height: 18px;\n	float: left;\n	display: inline;\n	background-repeat : no-repeat;\n}\n \n/* same style as IE selection */\n.TreeNodeEmphasized {\n	background-color: Highlight;\n	color: HighlightText;\n}\n \n.TreeContent .RichTextEditable, .TreeContent .RichTextEditable iframe {\n	  background-color: #ffc;\n	  color: black;\n}\n\n/* don't use :focus due to opera's lack of support on div's */\n.TreeLabelFocused {\n	  outline: 1px invert dotted;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/TreeV3.css"), templateString:"<div style=\"${this.style}\">\n</div>", isExpanded:true, isTree:true, createNode:function (data) {
-	data.tree = this.widgetId;
-	if (data.widgetName) {
-		return dojo.widget.createWidget(data.widgetName, data);
-	} else {
-		if (this.defaultChildWidget.prototype.createSimple) {
-			return this.defaultChildWidget.prototype.createSimple(data);
-		} else {
-			var ns = this.defaultChildWidget.prototype.ns;
-			var wt = this.defaultChildWidget.prototype.widgetType;
-			return dojo.widget.createWidget(ns + ":" + wt, data);
-		}
-	}
-}, makeNodeTemplate:function () {
-	var domNode = document.createElement("div");
-	dojo.html.setClass(domNode, this.classPrefix + "Node " + this.classPrefix + "ExpandLeaf " + this.classPrefix + "ChildrenNo");
-	this.nodeTemplate = domNode;
-	var expandNode = document.createElement("div");
-	var clazz = this.classPrefix + "Expand";
-	if (dojo.render.html.ie) {
-		clazz = clazz + " " + this.classPrefix + "IEExpand";
-	}
-	dojo.html.setClass(expandNode, clazz);
-	this.expandNodeTemplate = expandNode;
-	var labelNode = document.createElement("span");
-	dojo.html.setClass(labelNode, this.classPrefix + "Label");
-	this.labelNodeTemplate = labelNode;
-	var contentNode = document.createElement("div");
-	var clazz = this.classPrefix + "Content";
-	if (dojo.render.html.ie && !dojo.render.html.ie70) {
-		clazz = clazz + " " + this.classPrefix + "IEContent";
-	}
-	dojo.html.setClass(contentNode, clazz);
-	this.contentNodeTemplate = contentNode;
-	domNode.appendChild(expandNode);
-	domNode.appendChild(contentNode);
-	contentNode.appendChild(labelNode);
-}, makeContainerNodeTemplate:function () {
-	var div = document.createElement("div");
-	div.style.display = "none";
-	dojo.html.setClass(div, this.classPrefix + "Container");
-	this.containerNodeTemplate = div;
-}, actions:{ADDCHILD:"ADDCHILD"}, getInfo:function () {
-	var info = {widgetId:this.widgetId, objectId:this.objectId};
-	return info;
-}, adjustEventNames:function () {
-	for (var name in this.eventNamesDefault) {
-		if (dojo.lang.isUndefined(this.eventNames[name])) {
-			this.eventNames[name] = this.widgetId + "/" + this.eventNamesDefault[name];
-		}
-	}
-}, adjustDndMode:function () {
-	var _this = this;
-	var DndMode = 0;
-	dojo.lang.forEach(this.DndMode.split(";"), function (elem) {
-		var mode = _this.DndModes[dojo.string.trim(elem).toUpperCase()];
-		if (mode) {
-			DndMode = DndMode | mode;
-		}
-	});
-	this.DndMode = DndMode;
-}, destroy:function () {
-	dojo.event.topic.publish(this.tree.eventNames.beforeTreeDestroy, {source:this});
-	return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
-}, initialize:function (args) {
-	this.domNode.widgetId = this.widgetId;
-	for (var i = 0; i < this.actionsDisabled.length; i++) {
-		this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
-	}
-	if (!args.defaultChildWidget) {
-		this.defaultChildWidget = dojo.widget.TreeNodeV3;
-	} else {
-		this.defaultChildWidget = dojo.lang.getObjPathValue(args.defaultChildWidget);
-	}
-	this.adjustEventNames();
-	this.adjustDndMode();
-	this.makeNodeTemplate();
-	this.makeContainerNodeTemplate();
-	this.containerNode = this.domNode;
-	dojo.html.setClass(this.domNode, this.classPrefix + "Container");
-	var _this = this;
-	dojo.lang.forEach(this.listeners, function (elem) {
-		var t = dojo.lang.isString(elem) ? dojo.widget.byId(elem) : elem;
-		t.listenTree(_this);
-	});
-}, postCreate:function () {
-	dojo.event.topic.publish(this.eventNames.afterTreeCreate, {source:this});
-}, move:function (child, newParent, index) {
-	if (!child.parent) {
-		dojo.raise(this.widgetType + ": child can be moved only while it's attached");
-	}
-	var oldParent = child.parent;
-	var oldTree = child.tree;
-	var oldIndex = child.getParentIndex();
-	var newTree = newParent.tree;
-	var newParent = newParent;
-	var newIndex = index;
-	var message = {oldParent:oldParent, oldTree:oldTree, oldIndex:oldIndex, newParent:newParent, newTree:newTree, newIndex:newIndex, child:child};
-	dojo.event.topic.publish(oldTree.eventNames.beforeMoveFrom, message);
-	dojo.event.topic.publish(newTree.eventNames.beforeMoveTo, message);
-	this.doMove.apply(this, arguments);
-	dojo.event.topic.publish(oldTree.eventNames.afterMoveFrom, message);
-	dojo.event.topic.publish(newTree.eventNames.afterMoveTo, message);
-}, doMove:function (child, newParent, index) {
-	child.doDetach();
-	newParent.doAddChild(child, index);
-}, toString:function () {
-	return "[" + this.widgetType + " ID:" + this.widgetId + "]";
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/TreeWithNode.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/TreeWithNode.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/TreeWithNode.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,115 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.require("dojo.lang.declare");
-dojo.provide("dojo.widget.TreeWithNode");
-dojo.declare("dojo.widget.TreeWithNode", null, function () {
-}, {loadStates:{UNCHECKED:"UNCHECKED", LOADING:"LOADING", LOADED:"LOADED"}, state:"UNCHECKED", objectId:"", isContainer:true, lockLevel:0, lock:function () {
-	this.lockLevel++;
-}, unlock:function () {
-	if (!this.lockLevel) {
-		dojo.raise(this.widgetType + " unlock: not locked");
-	}
-	this.lockLevel--;
-}, expandLevel:0, loadLevel:0, hasLock:function () {
-	return this.lockLevel > 0;
-}, isLocked:function () {
-	var node = this;
-	while (true) {
-		if (node.lockLevel) {
-			return true;
-		}
-		if (!node.parent || node.isTree) {
-			break;
-		}
-		node = node.parent;
-	}
-	return false;
-}, flushLock:function () {
-	this.lockLevel = 0;
-}, actionIsDisabled:function (action) {
-	var disabled = false;
-	if (dojo.lang.inArray(this.actionsDisabled, action)) {
-		disabled = true;
-	}
-	if (this.isTreeNode) {
-		if (!this.tree.allowAddChildToLeaf && action == this.actions.ADDCHILD && !this.isFolder) {
-			disabled = true;
-		}
-	}
-	return disabled;
-}, actionIsDisabledNow:function (action) {
-	return this.actionIsDisabled(action) || this.isLocked();
-}, setChildren:function (childrenArray) {
-	if (this.isTreeNode && !this.isFolder) {
-		this.setFolder();
-	} else {
-		if (this.isTreeNode) {
-			this.state = this.loadStates.LOADED;
-		}
-	}
-	var hadChildren = this.children.length > 0;
-	if (hadChildren && childrenArray) {
-		this.destroyChildren();
-	}
-	if (childrenArray) {
-		this.children = childrenArray;
-	}
-	var hasChildren = this.children.length > 0;
-	if (this.isTreeNode && hasChildren != hadChildren) {
-		this.viewSetHasChildren();
-	}
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (!(child instanceof dojo.widget.Widget)) {
-			child = this.children[i] = this.tree.createNode(child);
-			var childWidgetCreated = true;
-		} else {
-			var childWidgetCreated = false;
-		}
-		if (!child.parent) {
-			child.parent = this;
-			if (this.tree !== child.tree) {
-				child.updateTree(this.tree);
-			}
-			child.viewAddLayout();
-			this.containerNode.appendChild(child.domNode);
-			var message = {child:child, index:i, parent:this, childWidgetCreated:childWidgetCreated};
-			delete dojo.widget.manager.topWidgets[child.widgetId];
-			dojo.event.topic.publish(this.tree.eventNames.afterAddChild, message);
-		}
-		if (this.tree.eagerWidgetInstantiation) {
-			dojo.lang.forEach(this.children, function (child) {
-				child.setChildren();
-			});
-		}
-	}
-}, doAddChild:function (child, index) {
-	return this.addChild(child, index, true);
-}, addChild:function (child, index, dontPublishEvent) {
-	if (dojo.lang.isUndefined(index)) {
-		index = this.children.length;
-	}
-	if (!child.isTreeNode) {
-		dojo.raise("You can only add TreeNode widgets to a " + this.widgetType + " widget!");
-		return;
-	}
-	this.children.splice(index, 0, child);
-	child.parent = this;
-	child.addedTo(this, index, dontPublishEvent);
-	delete dojo.widget.manager.topWidgets[child.widgetId];
-}, onShow:function () {
-	this.animationInProgress = false;
-}, onHide:function () {
-	this.animationInProgress = false;
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/UsTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/UsTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/UsTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,36 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.UsTextbox");
-dojo.require("dojo.widget.ValidationTextbox");
-dojo.require("dojo.validate.us");
-dojo.widget.defineWidget("dojo.widget.UsStateTextbox", dojo.widget.ValidationTextbox, {mixInProperties:function (localProperties) {
-	dojo.widget.UsStateTextbox.superclass.mixInProperties.apply(this, arguments);
-	if (localProperties.allowterritories) {
-		this.flags.allowTerritories = (localProperties.allowterritories == "true");
-	}
-	if (localProperties.allowmilitary) {
-		this.flags.allowMilitary = (localProperties.allowmilitary == "true");
-	}
-}, isValid:function () {
-	return dojo.validate.us.isState(this.textbox.value, this.flags);
-}});
-dojo.widget.defineWidget("dojo.widget.UsZipTextbox", dojo.widget.ValidationTextbox, {isValid:function () {
-	return dojo.validate.us.isZipCode(this.textbox.value);
-}});
-dojo.widget.defineWidget("dojo.widget.UsSocialSecurityNumberTextbox", dojo.widget.ValidationTextbox, {isValid:function () {
-	return dojo.validate.us.isSocialSecurityNumber(this.textbox.value);
-}});
-dojo.widget.defineWidget("dojo.widget.UsPhoneNumberTextbox", dojo.widget.ValidationTextbox, {isValid:function () {
-	return dojo.validate.us.isPhoneNumber(this.textbox.value);
-}});
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/ValidationTextbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/ValidationTextbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/ValidationTextbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,124 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.ValidationTextbox");
-dojo.require("dojo.widget.Textbox");
-dojo.require("dojo.i18n.common");
-dojo.widget.defineWidget("dojo.widget.ValidationTextbox", dojo.widget.Textbox, function () {
-	this.flags = {};
-}, {required:false, rangeClass:"range", invalidClass:"invalid", missingClass:"missing", classPrefix:"dojoValidate", size:"", maxlength:"", promptMessage:"", invalidMessage:"", missingMessage:"", rangeMessage:"", listenOnKeyPress:true, htmlfloat:"none", lastCheckedValue:null, templateString:"<span style='float:${this.htmlfloat};'>\n\t<input dojoAttachPoint='textbox' type='${this.type}' dojoAttachEvent='onblur;onfocus;onkeyup'\n\t\tid='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'\n\t\tclass='${this.className}' style=''>\n\t<span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'>${this.messages.invalidMessage}</span>\n\t<span dojoAttachPoint='missingSpan' class='${this.missingClass}'>${this.messages.missingMessage}</span>\n\t<span dojoAttachPoint='rangeSpan' class='${this.rangeClass}'>${this.messages.rangeMessage}</span>\n</span>\n", templateCssString:".dojoValidateEmpty{\n\tbackground-color: #00FFFF;\n}\n.dojoValidateValid{\!
 n\tbackground-color: #cfc;\n}\n.dojoValidateInvalid{\n\tbackground-color: #fcc;\n}\n.dojoValidateRange{\n\tbackground-color: #ccf;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Validate.css"), invalidSpan:null, missingSpan:null, rangeSpan:null, getValue:function () {
-	return this.textbox.value;
-}, setValue:function (value) {
-	this.textbox.value = value;
-	this.update();
-}, isValid:function () {
-	return true;
-}, isInRange:function () {
-	return true;
-}, isEmpty:function () {
-	return (/^\s*$/.test(this.textbox.value));
-}, isMissing:function () {
-	return (this.required && this.isEmpty());
-}, update:function () {
-	this.lastCheckedValue = this.textbox.value;
-	this.missingSpan.style.display = "none";
-	this.invalidSpan.style.display = "none";
-	this.rangeSpan.style.display = "none";
-	var empty = this.isEmpty();
-	var valid = true;
-	if (this.promptMessage != this.textbox.value) {
-		valid = this.isValid();
-	}
-	var missing = this.isMissing();
-	if (missing) {
-		this.missingSpan.style.display = "";
-	} else {
-		if (!empty && !valid) {
-			this.invalidSpan.style.display = "";
-		} else {
-			if (!empty && !this.isInRange()) {
-				this.rangeSpan.style.display = "";
-			}
-		}
-	}
-	this.highlight();
-}, updateClass:function (className) {
-	var pre = this.classPrefix;
-	dojo.html.removeClass(this.textbox, pre + "Empty");
-	dojo.html.removeClass(this.textbox, pre + "Valid");
-	dojo.html.removeClass(this.textbox, pre + "Invalid");
-	dojo.html.addClass(this.textbox, pre + className);
-}, highlight:function () {
-	if (this.isEmpty()) {
-		this.updateClass("Empty");
-	} else {
-		if (this.isValid() && this.isInRange()) {
-			this.updateClass("Valid");
-		} else {
-			if (this.textbox.value != this.promptMessage) {
-				this.updateClass("Invalid");
-			} else {
-				this.updateClass("Empty");
-			}
-		}
-	}
-}, onfocus:function (evt) {
-	if (!this.listenOnKeyPress) {
-		this.updateClass("Empty");
-	}
-}, onblur:function (evt) {
-	this.filter();
-	this.update();
-}, onkeyup:function (evt) {
-	if (this.listenOnKeyPress) {
-		this.update();
-	} else {
-		if (this.textbox.value != this.lastCheckedValue) {
-			this.updateClass("Empty");
-		}
-	}
-}, postMixInProperties:function (localProperties, frag) {
-	dojo.widget.ValidationTextbox.superclass.postMixInProperties.apply(this, arguments);
-	this.messages = dojo.i18n.getLocalization("dojo.widget", "validate", this.lang);
-	dojo.lang.forEach(["invalidMessage", "missingMessage", "rangeMessage"], function (prop) {
-		if (this[prop]) {
-			this.messages[prop] = this[prop];
-		}
-	}, this);
-}, fillInTemplate:function () {
-	dojo.widget.ValidationTextbox.superclass.fillInTemplate.apply(this, arguments);
-	this.textbox.isValid = function () {
-		this.isValid.call(this);
-	};
-	this.textbox.isMissing = function () {
-		this.isMissing.call(this);
-	};
-	this.textbox.isInRange = function () {
-		this.isInRange.call(this);
-	};
-	dojo.html.setClass(this.invalidSpan, this.invalidClass);
-	this.update();
-	this.filter();
-	if (dojo.render.html.ie) {
-		dojo.html.addClass(this.domNode, "ie");
-	}
-	if (dojo.render.html.moz) {
-		dojo.html.addClass(this.domNode, "moz");
-	}
-	if (dojo.render.html.opera) {
-		dojo.html.addClass(this.domNode, "opera");
-	}
-	if (dojo.render.html.safari) {
-		dojo.html.addClass(this.domNode, "safari");
-	}
-}});
-

Modified: tags/parley-0.53/root/static/magic/src/widget/Widget.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Widget.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Widget.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,305 +8,569 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.Widget");
+dojo.provide("dojo.widget.tags");
 
-
-dojo.provide("dojo.widget.Widget");
 dojo.require("dojo.lang.func");
 dojo.require("dojo.lang.array");
 dojo.require("dojo.lang.extras");
 dojo.require("dojo.lang.declare");
-dojo.require("dojo.ns");
 dojo.require("dojo.widget.Manager");
 dojo.require("dojo.event.*");
-dojo.require("dojo.a11y");
-dojo.declare("dojo.widget.Widget", null, function () {
-	this.children = [];
-	this.extraArgs = {};
-}, {parent:null, isTopLevel:false, disabled:false, isContainer:false, widgetId:"", widgetType:"Widget", ns:"dojo", getNamespacedType:function () {
-	return (this.ns ? this.ns + ":" + this.widgetType : this.widgetType).toLowerCase();
-}, toString:function () {
-	return "[Widget " + this.getNamespacedType() + ", " + (this.widgetId || "NO ID") + "]";
-}, repr:function () {
-	return this.toString();
-}, enable:function () {
-	this.disabled = false;
-}, disable:function () {
-	this.disabled = true;
-}, onResized:function () {
-	this.notifyChildrenOfResize();
-}, notifyChildrenOfResize:function () {
-	for (var i = 0; i < this.children.length; i++) {
-		var child = this.children[i];
-		if (child.onResized) {
-			child.onResized();
+
+dojo.declare("dojo.widget.Widget", null, {
+	initializer: function() {								 
+		// these properties aren't primitives and need to be created on a per-item
+		// basis.
+		this.children = [];
+		// this.selection = new dojo.widget.Selection();
+		// FIXME: need to replace this with context menu stuff
+		this.extraArgs = {};
+	},
+	// FIXME: need to be able to disambiguate what our rendering context is
+	//        here!
+	//
+	// needs to be a string with the end classname. Every subclass MUST
+	// over-ride.
+	//
+	// base widget properties
+	parent: null,
+	// obviously, top-level and modal widgets should set these appropriately
+	isTopLevel:  false,
+	isModal: false,
+
+	isEnabled: true,
+	isHidden: false,
+	isContainer: false, // can we contain other widgets?
+	widgetId: "",
+	widgetType: "Widget", // used for building generic widgets
+
+	toString: function() {
+		return '[Widget ' + this.widgetType + ', ' + (this.widgetId || 'NO ID') + ']';
+	},
+
+	repr: function(){
+		return this.toString();
+	},
+
+	enable: function(){
+		// should be over-ridden
+		this.isEnabled = true;
+	},
+
+	disable: function(){
+		// should be over-ridden
+		this.isEnabled = false;
+	},
+
+	hide: function(){
+		// should be over-ridden
+		this.isHidden = true;
+	},
+
+	show: function(){
+		// should be over-ridden
+		this.isHidden = false;
+	},
+
+	onResized: function(){
+		// Clients should override this function to do special processing,
+		// then call this.notifyChildrenOfResize() to notify children of resize
+		this.notifyChildrenOfResize();
+	},
+	
+	notifyChildrenOfResize: function(){
+		for(var i=0; i<this.children.length; i++){
+			var child = this.children[i];
+			//dojo.debug(this.widgetId + " resizing child " + child.widgetId);
+			if( child.onResized ){
+				child.onResized();
+			}
 		}
-	}
-}, create:function (args, fragment, parent, ns) {
-	if (ns) {
-		this.ns = ns;
-	}
-	this.satisfyPropertySets(args, fragment, parent);
-	this.mixInProperties(args, fragment, parent);
-	this.postMixInProperties(args, fragment, parent);
-	dojo.widget.manager.add(this);
-	this.buildRendering(args, fragment, parent);
-	this.initialize(args, fragment, parent);
-	this.postInitialize(args, fragment, parent);
-	this.postCreate(args, fragment, parent);
-	return this;
-}, destroy:function (finalize) {
-	if (this.parent) {
-		this.parent.removeChild(this);
-	}
-	this.destroyChildren();
-	this.uninitialize();
-	this.destroyRendering(finalize);
-	dojo.widget.manager.removeById(this.widgetId);
-}, destroyChildren:function () {
-	var widget;
-	var i = 0;
-	while (this.children.length > i) {
-		widget = this.children[i];
-		if (widget instanceof dojo.widget.Widget) {
-			this.removeChild(widget);
-			widget.destroy();
-			continue;
+	},
+
+	create: function(args, fragment, parentComp){
+		// dojo.debug(this.widgetType, "create");
+		this.satisfyPropertySets(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "-> mixInProperties");
+		this.mixInProperties(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "-> postMixInProperties");
+		this.postMixInProperties(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "-> dojo.widget.manager.add");
+		dojo.widget.manager.add(this);
+		// dojo.debug(this.widgetType, "-> buildRendering");
+		this.buildRendering(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "-> initialize");
+		this.initialize(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "-> postInitialize");
+		this.postInitialize(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "-> postCreate");
+		this.postCreate(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, "done!");
+		return this;
+	},
+
+	// Destroy this widget and it's descendants
+	destroy: function(finalize){
+		// FIXME: this is woefully incomplete
+		this.destroyChildren();
+		this.uninitialize();
+		this.destroyRendering(finalize);
+		dojo.widget.manager.removeById(this.widgetId);
+	},
+
+	// Destroy the children of this widget, and their descendents
+	destroyChildren: function(){
+		while(this.children.length > 0){
+			var tc = this.children[0];
+			this.removeChild(tc);
+			tc.destroy();
 		}
-		i++;
-	}
-}, getChildrenOfType:function (type, recurse) {
-	var ret = [];
-	var isFunc = dojo.lang.isFunction(type);
-	if (!isFunc) {
-		type = type.toLowerCase();
-	}
-	for (var x = 0; x < this.children.length; x++) {
-		if (isFunc) {
-			if (this.children[x] instanceof type) {
-				ret.push(this.children[x]);
+	},
+
+	getChildrenOfType: function(type, recurse){
+		var ret = [];
+		var isFunc = dojo.lang.isFunction(type);
+		if(!isFunc){
+			type = type.toLowerCase();
+		}
+		for(var x=0; x<this.children.length; x++){
+			if(isFunc){
+				if(this.children[x] instanceof type){
+					ret.push(this.children[x]);
+				}
+			}else{
+				if(this.children[x].widgetType.toLowerCase() == type){
+					ret.push(this.children[x]);
+				}
 			}
-		} else {
-			if (this.children[x].widgetType.toLowerCase() == type) {
-				ret.push(this.children[x]);
+			if(recurse){
+				ret = ret.concat(this.children[x].getChildrenOfType(type, recurse));
 			}
 		}
-		if (recurse) {
-			ret = ret.concat(this.children[x].getChildrenOfType(type, recurse));
+		return ret;
+	},
+
+	getDescendants: function(){
+		var result = [];
+		var stack = [this];
+		var elem;
+		while (elem = stack.pop()){
+			result.push(elem);
+			dojo.lang.forEach(elem.children, function(elem) { stack.push(elem); });
 		}
-	}
-	return ret;
-}, getDescendants:function () {
-	var result = [];
-	var stack = [this];
-	var elem;
-	while ((elem = stack.pop())) {
-		result.push(elem);
-		if (elem.children) {
-			dojo.lang.forEach(elem.children, function (elem) {
-				stack.push(elem);
-			});
+		return result;
+	},
+
+	satisfyPropertySets: function(args){
+		// dojo.profile.start("satisfyPropertySets");
+		// get the default propsets for our component type
+		/*
+		var typePropSets = []; // FIXME: need to pull these from somewhere!
+		var localPropSets = []; // pull out propsets from the parser's return structure
+
+		// for(var x=0; x<args.length; x++){
+		// }
+
+		for(var x=0; x<typePropSets.length; x++){
 		}
-	}
-	return result;
-}, isFirstChild:function () {
-	return this === this.parent.children[0];
-}, isLastChild:function () {
-	return this === this.parent.children[this.parent.children.length - 1];
-}, satisfyPropertySets:function (args) {
-	return args;
-}, mixInProperties:function (args, frag) {
-	if ((args["fastMixIn"]) || (frag["fastMixIn"])) {
-		for (var x in args) {
-			this[x] = args[x];
+
+		for(var x=0; x<localPropSets.length; x++){
 		}
-		return;
-	}
-	var undef;
-	var lcArgs = dojo.widget.lcArgsCache[this.widgetType];
-	if (lcArgs == null) {
-		lcArgs = {};
-		for (var y in this) {
-			lcArgs[((new String(y)).toLowerCase())] = y;
+		*/
+		// dojo.profile.end("satisfyPropertySets");
+		
+		return args;
+	},
+
+	mixInProperties: function(args, frag){
+		if((args["fastMixIn"])||(frag["fastMixIn"])){
+			// dojo.profile.start("mixInProperties_fastMixIn");
+			// fast mix in assumes case sensitivity, no type casting, etc...
+			// dojo.lang.mixin(this, args);
+			for(var x in args){
+				this[x] = args[x];
+			}
+			// dojo.profile.end("mixInProperties_fastMixIn");
+			return;
 		}
-		dojo.widget.lcArgsCache[this.widgetType] = lcArgs;
-	}
-	var visited = {};
-	for (var x in args) {
-		if (!this[x]) {
-			var y = lcArgs[(new String(x)).toLowerCase()];
-			if (y) {
-				args[y] = args[x];
-				x = y;
+		// dojo.profile.start("mixInProperties");
+		/*
+		 * the actual mix-in code attempts to do some type-assignment based on
+		 * PRE-EXISTING properties of the "this" object. When a named property
+		 * of a propset is located, it is first tested to make sure that the
+		 * current object already "has one". Properties which are undefined in
+		 * the base widget are NOT settable here. The next step is to try to
+		 * determine type of the pre-existing property. If it's a string, the
+		 * property value is simply assigned. If a function, the property is
+		 * replaced with a "new Function()" declaration. If an Array, the
+		 * system attempts to split the string value on ";" chars, and no
+		 * further processing is attempted (conversion of array elements to a
+		 * integers, for instance). If the property value is an Object
+		 * (testObj.constructor === Object), the property is split first on ";"
+		 * chars, secondly on ":" chars, and the resulting key/value pairs are
+		 * assigned to an object in a map style. The onus is on the property
+		 * user to ensure that all property values are converted to the
+		 * expected type before usage.
+		 */
+
+		var undef;
+
+		// NOTE: we cannot assume that the passed properties are case-correct
+		// (esp due to some browser bugs). Therefore, we attempt to locate
+		// properties for assignment regardless of case. This may cause
+		// problematic assignments and bugs in the future and will need to be
+		// documented with big bright neon lights.
+
+		// FIXME: fails miserably if a mixin property has a default value of null in 
+		// a widget
+
+		// NOTE: caching lower-cased args in the prototype is only 
+		// acceptable if the properties are invariant.
+		// if we have a name-cache, get it
+		var lcArgs = dojo.widget.lcArgsCache[this.widgetType];
+		if ( lcArgs == null ){
+			// build a lower-case property name cache if we don't have one
+			lcArgs = {};
+			for(var y in this){
+				lcArgs[((new String(y)).toLowerCase())] = y;
 			}
+			dojo.widget.lcArgsCache[this.widgetType] = lcArgs;
 		}
-		if (visited[x]) {
-			continue;
-		}
-		visited[x] = true;
-		if ((typeof this[x]) != (typeof undef)) {
-			if (typeof args[x] != "string") {
-				this[x] = args[x];
-			} else {
-				if (dojo.lang.isString(this[x])) {
+		var visited = {};
+		for(var x in args){
+			if(!this[x]){ // check the cache for properties
+				var y = lcArgs[(new String(x)).toLowerCase()];
+				if(y){
+					args[y] = args[x];
+					x = y; 
+				}
+			}
+			if(visited[x]){ continue; }
+			visited[x] = true;
+			if((typeof this[x]) != (typeof undef)){
+				if(typeof args[x] != "string"){
 					this[x] = args[x];
-				} else {
-					if (dojo.lang.isNumber(this[x])) {
-						this[x] = new Number(args[x]);
-					} else {
-						if (dojo.lang.isBoolean(this[x])) {
-							this[x] = (args[x].toLowerCase() == "false") ? false : true;
-						} else {
-							if (dojo.lang.isFunction(this[x])) {
-								if (args[x].search(/[^\w\.]+/i) == -1) {
-									this[x] = dojo.evalObjPath(args[x], false);
-								} else {
-									var tn = dojo.lang.nameAnonFunc(new Function(args[x]), this);
-									dojo.event.kwConnect({srcObj:this, srcFunc:x, adviceObj:this, adviceFunc:tn});
+				}else{
+					if(dojo.lang.isString(this[x])){
+						this[x] = args[x];
+					}else if(dojo.lang.isNumber(this[x])){
+						this[x] = new Number(args[x]); // FIXME: what if NaN is the result?
+					}else if(dojo.lang.isBoolean(this[x])){
+						this[x] = (args[x].toLowerCase()=="false") ? false : true;
+					}else if(dojo.lang.isFunction(this[x])){
+
+						// FIXME: need to determine if always over-writing instead
+						// of attaching here is appropriate. I suspect that we
+						// might want to only allow attaching w/ action items.
+						
+						// RAR, 1/19/05: I'm going to attach instead of
+						// over-write here. Perhaps function objects could have
+						// some sort of flag set on them? Or mixed-into objects
+						// could have some list of non-mutable properties
+						// (although I'm not sure how that would alleviate this
+						// particular problem)? 
+
+						// this[x] = new Function(args[x]);
+
+						// after an IRC discussion last week, it was decided
+						// that these event handlers should execute in the
+						// context of the widget, so that the "this" pointer
+						// takes correctly.
+						
+						// argument that contains no punctuation other than . is 
+						// considered a function spec, not code
+						if(args[x].search(/[^\w\.]+/i) == -1){
+							this[x] = dojo.evalObjPath(args[x], false);
+						}else{
+							var tn = dojo.lang.nameAnonFunc(new Function(args[x]), this);
+							dojo.event.connect(this, x, this, tn);
+						}
+					}else if(dojo.lang.isArray(this[x])){ // typeof [] == "object"
+						this[x] = args[x].split(";");
+					} else if (this[x] instanceof Date) {
+						this[x] = new Date(Number(args[x])); // assume timestamp
+					}else if(typeof this[x] == "object"){ 
+						// FIXME: should we be allowing extension here to handle
+						// other object types intelligently?
+
+						// if we defined a URI, we probablt want to allow plain strings
+						// to override it
+						if (this[x] instanceof dojo.uri.Uri){
+
+							this[x] = args[x];
+						}else{
+
+							// FIXME: unlike all other types, we do not replace the
+							// object with a new one here. Should we change that?
+							var pairs = args[x].split(";");
+							for(var y=0; y<pairs.length; y++){
+								var si = pairs[y].indexOf(":");
+								if((si != -1)&&(pairs[y].length>si)){
+									this[x][pairs[y].substr(0, si).replace(/^\s+|\s+$/g, "")] = pairs[y].substr(si+1);
 								}
-							} else {
-								if (dojo.lang.isArray(this[x])) {
-									this[x] = args[x].split(";");
-								} else {
-									if (this[x] instanceof Date) {
-										this[x] = new Date(Number(args[x]));
-									} else {
-										if (typeof this[x] == "object") {
-											if (this[x] instanceof dojo.uri.Uri) {
-												this[x] = dojo.uri.dojoUri(args[x]);
-											} else {
-												var pairs = args[x].split(";");
-												for (var y = 0; y < pairs.length; y++) {
-													var si = pairs[y].indexOf(":");
-													if ((si != -1) && (pairs[y].length > si)) {
-														this[x][pairs[y].substr(0, si).replace(/^\s+|\s+$/g, "")] = pairs[y].substr(si + 1);
-													}
-												}
-											}
-										} else {
-											this[x] = args[x];
-										}
-									}
-								}
 							}
 						}
+					}else{
+						// the default is straight-up string assignment. When would
+						// we ever hit this?
+						this[x] = args[x];
 					}
 				}
+			}else{
+				// collect any extra 'non mixed in' args
+				this.extraArgs[x.toLowerCase()] = args[x];
 			}
-		} else {
-			this.extraArgs[x.toLowerCase()] = args[x];
 		}
-	}
-}, postMixInProperties:function (args, frag, parent) {
-}, initialize:function (args, frag, parent) {
-	return false;
-}, postInitialize:function (args, frag, parent) {
-	return false;
-}, postCreate:function (args, frag, parent) {
-	return false;
-}, uninitialize:function () {
-	return false;
-}, buildRendering:function (args, frag, parent) {
-	dojo.unimplemented("dojo.widget.Widget.buildRendering, on " + this.toString() + ", ");
-	return false;
-}, destroyRendering:function () {
-	dojo.unimplemented("dojo.widget.Widget.destroyRendering");
-	return false;
-}, addedTo:function (parent) {
-}, addChild:function (child) {
-	dojo.unimplemented("dojo.widget.Widget.addChild");
-	return false;
-}, removeChild:function (widget) {
-	for (var x = 0; x < this.children.length; x++) {
-		if (this.children[x] === widget) {
-			this.children.splice(x, 1);
-			widget.parent = null;
-			break;
+		// dojo.profile.end("mixInProperties");
+	},
+	
+	postMixInProperties: function(){
+	},
+
+	initialize: function(args, frag){
+		// dojo.unimplemented("dojo.widget.Widget.initialize");
+		return false;
+	},
+
+	postInitialize: function(args, frag){
+		return false;
+	},
+
+	postCreate: function(args, frag){
+		return false;
+	},
+
+	uninitialize: function(){
+		// dojo.unimplemented("dojo.widget.Widget.uninitialize");
+		return false;
+	},
+
+	buildRendering: function(){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented("dojo.widget.Widget.buildRendering, on "+this.toString()+", ");
+		return false;
+	},
+
+	destroyRendering: function(){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented("dojo.widget.Widget.destroyRendering");
+		return false;
+	},
+
+	cleanUp: function(){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented("dojo.widget.Widget.cleanUp");
+		return false;
+	},
+
+	addedTo: function(parent){
+		// this is just a signal that can be caught
+	},
+
+	addChild: function(child){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented("dojo.widget.Widget.addChild");
+		return false;
+	},
+
+	// Detach the given child widget from me, but don't destroy it
+	removeChild: function(widget){
+		for(var x=0; x<this.children.length; x++){
+			if(this.children[x] === widget){
+				this.children.splice(x, 1);
+				break;
+			}
 		}
+		return widget;
+	},
+
+	resize: function(width, height){
+		// both width and height may be set as percentages. The setWidth and
+		// setHeight  functions attempt to determine if the passed param is
+		// specified in percentage or native units. Integers without a
+		// measurement are assumed to be in the native unit of measure.
+		this.setWidth(width);
+		this.setHeight(height);
+	},
+
+	setWidth: function(width){
+		if((typeof width == "string")&&(width.substr(-1) == "%")){
+			this.setPercentageWidth(width);
+		}else{
+			this.setNativeWidth(width);
+		}
+	},
+
+	setHeight: function(height){
+		if((typeof height == "string")&&(height.substr(-1) == "%")){
+			this.setPercentageHeight(height);
+		}else{
+			this.setNativeHeight(height);
+		}
+	},
+
+	setPercentageHeight: function(height){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	setNativeHeight: function(height){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	setPercentageWidth: function(width){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	setNativeWidth: function(width){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	getPreviousSibling: function() {
+		var idx = this.getParentIndex();
+ 
+		 // first node is idx=0 not found is idx<0
+		if (idx<=0) return null;
+ 
+		return this.getSiblings()[idx-1];
+	},
+ 
+	getSiblings: function() {
+		return this.parent.children;
+	},
+ 
+	getParentIndex: function() {
+		return dojo.lang.indexOf( this.getSiblings(), this, true);
+	},
+ 
+	getNextSibling: function() {
+ 
+		var idx = this.getParentIndex();
+ 
+		if (idx == this.getSiblings().length-1) return null; // last node
+		if (idx < 0) return null; // not found
+ 
+		return this.getSiblings()[idx+1];
+ 
 	}
-	return widget;
-}, getPreviousSibling:function () {
-	var idx = this.getParentIndex();
-	if (idx <= 0) {
-		return null;
-	}
-	return this.parent.children[idx - 1];
-}, getSiblings:function () {
-	return this.parent.children;
-}, getParentIndex:function () {
-	return dojo.lang.indexOf(this.parent.children, this, true);
-}, getNextSibling:function () {
-	var idx = this.getParentIndex();
-	if (idx == this.parent.children.length - 1) {
-		return null;
-	}
-	if (idx < 0) {
-		return null;
-	}
-	return this.parent.children[idx + 1];
-}});
+});
+
+// Lower case name cache: listing of the lower case elements in each widget.
+// We can't store the lcArgs in the widget itself because if B subclasses A,
+// then B.prototype.lcArgs might return A.prototype.lcArgs, which is not what we
+// want
 dojo.widget.lcArgsCache = {};
+
+// TODO: should have a more general way to add tags or tag libraries?
+// TODO: need a default tags class to inherit from for things like getting propertySets
+// TODO: parse properties/propertySets into component attributes
+// TODO: parse subcomponents
+// TODO: copy/clone raw markup fragments/nodes as appropriate
 dojo.widget.tags = {};
-dojo.widget.tags.addParseTreeHandler = function (type) {
-	dojo.deprecated("addParseTreeHandler", ". ParseTreeHandlers are now reserved for components. Any unfiltered DojoML tag without a ParseTreeHandler is assumed to be a widget", "0.5");
-};
-dojo.widget.tags["dojo:propertyset"] = function (fragment, widgetParser, parentComp) {
+dojo.widget.tags.addParseTreeHandler = function(type){
+	var ltype = type.toLowerCase();
+	this[ltype] = function(fragment, widgetParser, parentComp, insertionIndex, localProps){ 
+		return dojo.widget.buildWidgetFromParseTree(ltype, fragment, widgetParser, parentComp, insertionIndex, localProps);
+	}
+}
+dojo.widget.tags.addParseTreeHandler("dojo:widget");
+
+dojo.widget.tags["dojo:propertyset"] = function(fragment, widgetParser, parentComp){
+	// FIXME: Is this needed?
+	// FIXME: Not sure that this parses into the structure that I want it to parse into...
+	// FIXME: add support for nested propertySets
 	var properties = widgetParser.parseProperties(fragment["dojo:propertyset"]);
-};
-dojo.widget.tags["dojo:connect"] = function (fragment, widgetParser, parentComp) {
+}
+
+// FIXME: need to add the <dojo:connect />
+dojo.widget.tags["dojo:connect"] = function(fragment, widgetParser, parentComp){
 	var properties = widgetParser.parseProperties(fragment["dojo:connect"]);
-};
-dojo.widget.buildWidgetFromParseTree = function (type, frag, parser, parentComp, insertionIndex, localProps) {
-	dojo.a11y.setAccessibleMode();
+}
+
+// FIXME: if we know the insertion point (to a reasonable location), why then do we:
+//	- create a template node
+//	- clone the template node
+//	- render the clone and set properties
+//	- remove the clone from the render tree
+//	- place the clone
+// this is quite dumb
+dojo.widget.buildWidgetFromParseTree = function(type, frag, 
+												parser, parentComp, 
+												insertionIndex, localProps){
 	var stype = type.split(":");
 	stype = (stype.length == 2) ? stype[1] : type;
-	var localProperties = localProps || parser.parseProperties(frag[frag["ns"] + ":" + stype]);
-	var twidget = dojo.widget.manager.getImplementation(stype, null, null, frag["ns"]);
-	if (!twidget) {
-		throw new Error("cannot find \"" + type + "\" widget");
-	} else {
-		if (!twidget.create) {
-			throw new Error("\"" + type + "\" widget object has no \"create\" method and does not appear to implement *Widget");
-		}
+	// FIXME: we don't seem to be doing anything with this!
+	// var propertySets = parser.getPropertySets(frag);
+	var localProperties = localProps || parser.parseProperties(frag["dojo:"+stype]);
+	// var tic = new Date();
+	var twidget = dojo.widget.manager.getImplementation(stype);
+	if(!twidget){
+		throw new Error("cannot find \"" + stype + "\" widget");
+	}else if (!twidget.create){
+		throw new Error("\"" + stype + "\" widget object does not appear to implement *Widget");
 	}
 	localProperties["dojoinsertionindex"] = insertionIndex;
-	var ret = twidget.create(localProperties, frag, parentComp, frag["ns"]);
+	// FIXME: we loose no less than 5ms in construction!
+	var ret = twidget.create(localProperties, frag, parentComp);
+	// dojo.debug(new Date() - tic);
 	return ret;
-};
-dojo.widget.defineWidget = function (widgetClass, renderer, superclasses, init, props) {
-	if (dojo.lang.isString(arguments[3])) {
+}
+
+/*
+ * Create a widget constructor function (aka widgetClass)
+ */
+dojo.widget.defineWidget = function(widgetClass /*string*/, renderer /*string*/, superclasses /*function||array*/, init /*function*/, props /*object*/){
+	// This meta-function does parameter juggling for backward compat and overloading
+	// if 4th argument is a string, we are using the old syntax
+	// old sig: widgetClass, superclasses, props (object), renderer (string), init (function)
+	if(dojo.lang.isString(arguments[3])){
 		dojo.widget._defineWidget(arguments[0], arguments[3], arguments[1], arguments[4], arguments[2]);
-	} else {
-		var args = [arguments[0]], p = 3;
-		if (dojo.lang.isString(arguments[1])) {
+	}else{
+		// widgetClass
+		var args = [ arguments[0] ], p = 3;
+		if(dojo.lang.isString(arguments[1])){
+			// renderer, superclass
 			args.push(arguments[1], arguments[2]);
-		} else {
-			args.push("", arguments[1]);
+		}else{
+			// superclass
+			args.push('', arguments[1]);
 			p = 2;
 		}
-		if (dojo.lang.isFunction(arguments[p])) {
-			args.push(arguments[p], arguments[p + 1]);
-		} else {
+		if(dojo.lang.isFunction(arguments[p])){
+			// init (function), props (object) 
+			args.push(arguments[p], arguments[p+1]);
+		}else{
+			// props (object) 
 			args.push(null, arguments[p]);
 		}
 		dojo.widget._defineWidget.apply(this, args);
 	}
-};
+}
+
 dojo.widget.defineWidget.renderers = "html|svg|vml";
-dojo.widget._defineWidget = function (widgetClass, renderer, superclasses, init, props) {
-	var module = widgetClass.split(".");
-	var type = module.pop();
-	var regx = "\\.(" + (renderer ? renderer + "|" : "") + dojo.widget.defineWidget.renderers + ")\\.";
+
+dojo.widget._defineWidget = function(widgetClass /*string*/, renderer /*string*/, superclasses /*function||array*/, init /*function*/, props /*object*/){
+	// FIXME: uncomment next line to test parameter juggling ... remove when confidence improves
+	//dojo.debug('(c:)' + widgetClass + '\n\n(r:)' + renderer + '\n\n(i:)' + init + '\n\n(p:)' + props);
+	// widgetClass takes the form foo.bar.baz<.renderer>.WidgetName (e.g. foo.bar.baz.WidgetName or foo.bar.baz.html.WidgetName)
+	var namespace = widgetClass.split(".");
+	var type = namespace.pop(); // type <= WidgetName, namespace <= foo.bar.baz<.renderer>
+	var regx = "\\.(" + (renderer ? renderer + '|' : '') + dojo.widget.defineWidget.renderers + ")\\.";
 	var r = widgetClass.search(new RegExp(regx));
-	module = (r < 0 ? module.join(".") : widgetClass.substr(0, r));
-	dojo.widget.manager.registerWidgetPackage(module);
-	var pos = module.indexOf(".");
-	var nsName = (pos > -1) ? module.substring(0, pos) : module;
-	props = (props) || {};
+	namespace = (r < 0 ? namespace.join(".") : widgetClass.substr(0, r));
+
+	dojo.widget.manager.registerWidgetPackage(namespace);
+	dojo.widget.tags.addParseTreeHandler("dojo:"+type.toLowerCase());
+
+	props=(props)||{};
 	props.widgetType = type;
-	if ((!init) && (props["classConstructor"])) {
+	if((!init)&&(props["classConstructor"])){
 		init = props.classConstructor;
 		delete props.classConstructor;
 	}
 	dojo.declare(widgetClass, superclasses, init, props);
-};
-
+}
\ No newline at end of file

Modified: tags/parley-0.53/root/static/magic/src/widget/Wizard.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/Wizard.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/Wizard.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,120 +8,203 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.Wizard");
 
-
-dojo.provide("dojo.widget.Wizard");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.LayoutContainer");
 dojo.require("dojo.widget.ContentPane");
 dojo.require("dojo.event.*");
-dojo.require("dojo.html.style");
-dojo.widget.defineWidget("dojo.widget.WizardContainer", dojo.widget.LayoutContainer, {templateString:"<div class=\"WizardContainer\" dojoAttachPoint=\"wizardNode\">\n	<div class=\"WizardText\" dojoAttachPoint=\"wizardPanelContainerNode\">\n	</div>\n	<div class=\"WizardButtonHolder\" dojoAttachPoint=\"wizardControlContainerNode\">\n		<input class=\"WizardButton\" type=\"button\" dojoAttachPoint=\"previousButton\"/>\n		<input class=\"WizardButton\" type=\"button\" dojoAttachPoint=\"nextButton\"/>\n		<input class=\"WizardButton\" type=\"button\" dojoAttachPoint=\"doneButton\" style=\"display:none\"/>\n		<input class=\"WizardButton\" type=\"button\" dojoAttachPoint=\"cancelButton\"/>\n	</div>\n</div>\n", templateCssString:".WizardContainer {\n\tbackground: #EEEEEE;\n\tborder: #798EC5 1px solid;\n\tpadding: 2px;\n}\n\n.WizardTitle {\n\tcolor: #003366;\n\tpadding: 8px 5px 15px 2px;\n\tfont-weight: bold;\n\tfont-size: x-small;\n\tfont-style: normal;\n\tfont-family: Verdana, Arial,!
  Helvetica;\n\ttext-align: left;\n}\n\n.WizardText {\n\tcolor: #000033;\n\tfont-weight: normal;\n\tfont-size: xx-small;\n\tfont-family: Verdana, Arial, Helvetica;\n\tpadding: 2 50; text-align: justify;\n}\n\n.WizardLightText {\n\tcolor: #666666;\n\tfont-weight: normal;\n\tfont-size: xx-small;\n\tfont-family: verdana, arial, helvetica;\n\tpadding: 2px 50px;\n\ttext-align: justify;\n}\n\n.WizardButtonHolder {\n\ttext-align: right;\n\tpadding: 10px 5px;\n}\n\n.WizardButton {\n\tcolor: #ffffff;\n\tbackground: #798EC5;\n\tfont-size: xx-small;\n\tfont-family: verdana, arial, helvetica, sans-serif;\n\tborder-right: #000000 1px solid;\n\tborder-bottom: #000000 1px solid;\n\tborder-left: #666666 1px solid;\n\tborder-top: #666666 1px solid;\n\tpadding-right: 4px;\n\tpadding-left: 4px;\n\ttext-decoration: none; height: 18px;\n}\n\n.WizardButton:hover {\n\tcursor: pointer;\n}\n\n.WizardButtonDisabled {\n\tcolor: #eeeeee;\n\tbackground-color: #999999;\n\tfont-size: xx-small;\n\tFONT-FAM!
 ILY: verdana, arial, helvetica, sans-serif;\n\tborder-right: #!
 000000 1
px solid;\n\tborder-bottom: #000000 1px solid;\n\tborder-left: #798EC5 1px solid;\n\tborder-top: #798EC5 1px solid;\n\tpadding-right: 4px;\n\tpadding-left: 4px;\n\ttext-decoration: none;\n\theight: 18px;\n}\n\n\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "templates/Wizard.css"), selected:null, nextButtonLabel:"next", previousButtonLabel:"previous", cancelButtonLabel:"cancel", doneButtonLabel:"done", cancelFunction:"", hideDisabledButtons:false, fillInTemplate:function (args, frag) {
-	dojo.event.connect(this.nextButton, "onclick", this, "_onNextButtonClick");
-	dojo.event.connect(this.previousButton, "onclick", this, "_onPreviousButtonClick");
-	if (this.cancelFunction) {
-		dojo.event.connect(this.cancelButton, "onclick", this.cancelFunction);
-	} else {
-		this.cancelButton.style.display = "none";
-	}
-	dojo.event.connect(this.doneButton, "onclick", this, "done");
-	this.nextButton.value = this.nextButtonLabel;
-	this.previousButton.value = this.previousButtonLabel;
-	this.cancelButton.value = this.cancelButtonLabel;
-	this.doneButton.value = this.doneButtonLabel;
-}, _checkButtons:function () {
-	var lastStep = !this.hasNextPanel();
-	this.nextButton.disabled = lastStep;
-	this._setButtonClass(this.nextButton);
-	if (this.selected.doneFunction) {
-		this.doneButton.style.display = "";
-		if (lastStep) {
-			this.nextButton.style.display = "none";
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+
+//////////////////////////////////////////
+// WizardContainer -- a set of panels
+//////////////////////////////////////////
+dojo.widget.WizardContainer = function() {
+	dojo.widget.html.LayoutContainer.call(this);
+}
+dojo.inherits(dojo.widget.WizardContainer, dojo.widget.html.LayoutContainer);
+
+dojo.lang.extend(dojo.widget.WizardContainer, {
+
+	widgetType: "WizardContainer",
+
+	labelPosition: "top",
+
+	templatePath: dojo.uri.dojoUri("src/widget/templates/Wizard.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/Wizard.css"),
+
+	selected: null,		// currently selected panel
+	wizardNode: null, // the outer wizard node
+	wizardPanelContainerNode: null, // the container for the panels
+	wizardControlContainerNode: null, // the container for the wizard controls
+	previousButton: null, // the previous button
+	nextButton: null, // the next button
+	cancelButton: null, // the cancel button
+	doneButton: null, // the done button
+	nextButtonLabel: "next",
+	previousButtonLabel: "previous",
+	cancelButtonLabel: "cancel",
+	doneButtonLabel: "done",
+	cancelFunction : "",
+
+	hideDisabledButtons: false,
+
+	fillInTemplate: function(args, frag){
+		dojo.event.connect(this.nextButton, "onclick", this, "nextPanel");
+		dojo.event.connect(this.previousButton, "onclick", this, "previousPanel");
+		if (this.cancelFunction){
+			dojo.event.connect(this.cancelButton, "onclick", this.cancelFunction);
+		}else{
+			this.cancelButton.style.display = "none";
 		}
-	} else {
-		this.doneButton.style.display = "none";
-	}
-	this.previousButton.disabled = ((!this.hasPreviousPanel()) || (!this.selected.canGoBack));
-	this._setButtonClass(this.previousButton);
-}, _setButtonClass:function (button) {
-	if (!this.hideDisabledButtons) {
-		button.style.display = "";
-		dojo.html.setClass(button, button.disabled ? "WizardButtonDisabled" : "WizardButton");
-	} else {
-		button.style.display = button.disabled ? "none" : "";
-	}
-}, registerChild:function (panel, insertionIndex) {
-	dojo.widget.WizardContainer.superclass.registerChild.call(this, panel, insertionIndex);
-	this.wizardPanelContainerNode.appendChild(panel.domNode);
-	panel.hide();
-	if (!this.selected) {
-		this.onSelected(panel);
-	}
-	this._checkButtons();
-}, onSelected:function (panel) {
-	if (this.selected) {
-		if (this.selected._checkPass()) {
-			this.selected.hide();
-		} else {
-			return;
+		dojo.event.connect(this.doneButton, "onclick", this, "done");
+		this.nextButton.value = this.nextButtonLabel;
+		this.previousButton.value = this.previousButtonLabel;
+		this.cancelButton.value = this.cancelButtonLabel;
+		this.doneButton.value = this.doneButtonLabel;
+	},
+
+	checkButtons: function(){
+		var lastStep = !this.hasNextPanel();
+		this.nextButton.disabled = lastStep;
+		this.setButtonClass(this.nextButton);
+		if(this.selected.doneFunction){
+			this.doneButton.style.display = "";
+			// hide the next button if this is the last one and we have a done function
+			if(lastStep){
+				this.nextButton.style.display = "none";
+			}
+		}else{
+			this.doneButton.style.display = "none";
 		}
-	}
-	panel.show();
-	this.selected = panel;
-}, getPanels:function () {
-	return this.getChildrenOfType("WizardPane", false);
-}, selectedIndex:function () {
-	if (this.selected) {
-		return dojo.lang.indexOf(this.getPanels(), this.selected);
-	}
-	return -1;
-}, _onNextButtonClick:function () {
-	var selectedIndex = this.selectedIndex();
-	if (selectedIndex > -1) {
-		var childPanels = this.getPanels();
-		if (childPanels[selectedIndex + 1]) {
-			this.onSelected(childPanels[selectedIndex + 1]);
+		this.previousButton.disabled = ((!this.hasPreviousPanel()) || (!this.selected.canGoBack));
+		this.setButtonClass(this.previousButton);
+	},
+
+	setButtonClass: function(button){
+		if(!this.hideDisabledButtons){
+			button.style.display = "";
+			dojo.html.setClass(button, button.disabled ? "WizardButtonDisabled" : "WizardButton");
+		}else{
+			button.style.display = button.disabled ? "none" : "";
 		}
-	}
-	this._checkButtons();
-}, _onPreviousButtonClick:function () {
-	var selectedIndex = this.selectedIndex();
-	if (selectedIndex > -1) {
-		var childPanels = this.getPanels();
-		if (childPanels[selectedIndex - 1]) {
-			this.onSelected(childPanels[selectedIndex - 1]);
+	},
+
+	registerChild: function(panel, insertionIndex){
+		dojo.widget.WizardContainer.superclass.registerChild.call(this, panel, insertionIndex);
+		this.wizardPanelContainerNode.appendChild(panel.domNode);
+		panel.hide();
+
+		if(!this.selected){
+			this.onSelected(panel);
 		}
+		this.checkButtons();
+	},
+
+	onSelected: function(panel){
+		// Deselect old panel and select new one
+		if(this.selected ){
+			if (this.selected.checkPass()) {
+				this.selected.hide();
+			} else {
+				return;
+			}
+		}
+		panel.show();
+		this.selected = panel;
+	},
+
+	getPanels: function() {
+		return this.getChildrenOfType("WizardPane", false);
+	},
+
+	selectedIndex: function() {
+		if (this.selected) {
+			return dojo.lang.indexOf(this.getPanels(), this.selected);
+		}
+		return -1;
+	},
+
+	nextPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		if ( selectedIndex > -1 ) {
+			var childPanels = this.getPanels();
+			if (childPanels[selectedIndex + 1]) {
+				this.onSelected(childPanels[selectedIndex + 1]);
+			}
+		}
+		this.checkButtons();
+	},
+
+	previousPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		if ( selectedIndex > -1 ) {
+			var childPanels = this.getPanels();
+			if (childPanels[selectedIndex - 1]) {
+				this.onSelected(childPanels[selectedIndex - 1]);
+			}
+		}
+		this.checkButtons();
+	},
+
+	hasNextPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		return (selectedIndex < (this.getPanels().length - 1));
+	},
+
+	hasPreviousPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		return (selectedIndex > 0);
+	},
+
+	done: function() {
+		this.selected.done();
 	}
-	this._checkButtons();
-}, hasNextPanel:function () {
-	var selectedIndex = this.selectedIndex();
-	return (selectedIndex < (this.getPanels().length - 1));
-}, hasPreviousPanel:function () {
-	var selectedIndex = this.selectedIndex();
-	return (selectedIndex > 0);
-}, done:function () {
-	this.selected.done();
-}});
-dojo.widget.defineWidget("dojo.widget.WizardPane", dojo.widget.ContentPane, {canGoBack:true, passFunction:"", doneFunction:"", postMixInProperties:function (args, frag) {
-	if (this.passFunction) {
-		this.passFunction = dj_global[this.passFunction];
-	}
-	if (this.doneFunction) {
-		this.doneFunction = dj_global[this.doneFunction];
-	}
-	dojo.widget.WizardPane.superclass.postMixInProperties.apply(this, arguments);
-}, _checkPass:function () {
-	if (this.passFunction && dojo.lang.isFunction(this.passFunction)) {
-		var failMessage = this.passFunction();
-		if (failMessage) {
-			alert(failMessage);
-			return false;
+});
+dojo.widget.tags.addParseTreeHandler("dojo:WizardContainer");
+
+//////////////////////////////////////////
+// WizardPane -- a panel in a wizard
+//////////////////////////////////////////
+dojo.widget.WizardPane = function() {
+	dojo.widget.html.ContentPane.call(this);
+}
+dojo.inherits(dojo.widget.WizardPane, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.WizardPane, {
+	widgetType: "WizardPane",
+
+	canGoBack: true,
+
+	passFunction: "",
+	doneFunction: "",
+
+	fillInTemplate: function(args, frag) {
+		if (this.passFunction) {
+			this.passFunction = dj_global[this.passFunction];
 		}
+		if (this.doneFunction) {
+			this.doneFunction = dj_global[this.doneFunction];
+		}
+	},
+
+	checkPass: function() {
+		if (this.passFunction && dojo.lang.isFunction(this.passFunction)) {
+			var failMessage = this.passFunction();
+			if (failMessage) {
+				alert(failMessage);
+				return false;
+			}
+		}
+		return true;
+	},
+
+	done: function() {
+		if (this.doneFunction && dojo.lang.isFunction(this.doneFunction)) {
+			this.doneFunction();
+		}
 	}
-	return true;
-}, done:function () {
-	if (this.doneFunction && dojo.lang.isFunction(this.doneFunction)) {
-		this.doneFunction();
-	}
-}});
+});
 
+dojo.widget.tags.addParseTreeHandler("dojo:WizardPane");

Modified: tags/parley-0.53/root/static/magic/src/widget/YahooMap.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/YahooMap.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/YahooMap.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,138 +8,20 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.YahooMap");
-dojo.require("dojo.event.*");
-dojo.require("dojo.math");
-dojo.require("dojo.widget.*");
-dojo.require("dojo.widget.HtmlWidget");
-(function () {
-	var yappid = djConfig["yAppId"] || djConfig["yahooAppId"] || "dojotoolkit";
-	if (!dojo.hostenv.post_load_) {
-		if (yappid == "dojotoolkit") {
-			dojo.debug("please provide a unique Yahoo App ID in djConfig.yahooAppId when using the map widget");
-		}
-		var tag = "<scr" + "ipt src='http://api.maps.yahoo.com/ajaxymap?v=3.0&appid=" + yappid + "'></scri" + "pt>";
-		if (!dj_global["YMap"]) {
-			document.write(tag);
-		}
-	} else {
-		dojo.debug("cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Yahoo in your page or require() the YahooMap widget before onload has fired");
-	}
-})();
-dojo.widget.defineWidget("dojo.widget.YahooMap", dojo.widget.HtmlWidget, function () {
-	this.map = null;
-	this.datasrc = "";
-	this.data = [];
-	this.width = 0;
-	this.height = 0;
-	this.controls = ["zoomlong", "maptype", "pan"];
-}, {isContainer:false, templatePath:null, templateCssPath:null, findCenter:function (aPts) {
-	var start = new YGeoPoint(37, -90);
-	if (aPts.length == 0) {
-		return start;
-	}
-	var minLat, maxLat, minLon, maxLon, cLat, cLon;
-	minLat = maxLat = aPts[0].Lat;
-	minLon = maxLon = aPts[0].Lon;
-	for (var i = 0; i < aPts.length; i++) {
-		minLat = Math.min(minLat, aPts[i].Lat);
-		maxLat = Math.max(maxLat, aPts[i].Lat);
-		minLon = Math.min(minLon, aPts[i].Lon);
-		maxLon = Math.max(maxLon, aPts[i].Lon);
-	}
-	cLat = dojo.math.round((minLat + maxLat) / 2, 6);
-	cLon = dojo.math.round((minLon + maxLon) / 2, 6);
-	return new YGeoPoint(cLat, cLon);
-}, setControls:function () {
-	var methodmap = {maptype:"addTypeControl", pan:"addPanControl", zoomlong:"addZoomLong", zoomshort:"addZoomShort"};
-	var c = this.controls;
-	for (var i = 0; i < c.length; i++) {
-		var controlMethod = methodmap[c[i].toLowerCase()];
-		if (this.map[controlMethod]) {
-			this.map[controlMethod]();
-		}
-	}
-}, parse:function (table) {
-	this.data = [];
-	var h = table.getElementsByTagName("thead")[0];
-	if (!h) {
-		return;
-	}
-	var a = [];
-	var cols = h.getElementsByTagName("td");
-	if (cols.length == 0) {
-		cols = h.getElementsByTagName("th");
-	}
-	for (var i = 0; i < cols.length; i++) {
-		var c = cols[i].innerHTML.toLowerCase();
-		if (c == "long") {
-			c = "lng";
-		}
-		a.push(c);
-	}
-	var b = table.getElementsByTagName("tbody")[0];
-	if (!b) {
-		return;
-	}
-	for (var i = 0; i < b.childNodes.length; i++) {
-		if (!(b.childNodes[i].nodeName && b.childNodes[i].nodeName.toLowerCase() == "tr")) {
-			continue;
-		}
-		var cells = b.childNodes[i].getElementsByTagName("td");
-		var o = {};
-		for (var j = 0; j < a.length; j++) {
-			var col = a[j];
-			if (col == "lat" || col == "lng") {
-				o[col] = parseFloat(cells[j].innerHTML);
-			} else {
-				o[col] = cells[j].innerHTML;
-			}
-		}
-		this.data.push(o);
-	}
-}, render:function () {
-	var pts = [];
-	var d = this.data;
-	for (var i = 0; i < d.length; i++) {
-		var pt = new YGeoPoint(d[i].lat, d[i].lng);
-		pts.push(pt);
-		var icon = d[i].icon || null;
-		if (icon) {
-			icon = new YImage(icon);
-		}
-		var m = new YMarker(pt, icon);
-		if (d[i].description) {
-			m.addAutoExpand("<div>" + d[i].description + "</div>");
-		}
-		this.map.addOverlay(m);
-	}
-	var c = this.findCenter(pts);
-	var z = this.map.getZoomLevel(pts);
-	this.map.drawZoomAndCenter(c, z);
-}, initialize:function (args, frag) {
-	if (!YMap || !YGeoPoint) {
-		dojo.raise("dojo.widget.YahooMap: The Yahoo Map script must be included in order to use this widget.");
-	}
-	if (this.datasrc) {
-		this.parse(dojo.byId(this.datasrc));
-	} else {
-		if (this.domNode.getElementsByTagName("table")[0]) {
-			this.parse(this.domNode.getElementsByTagName("table")[0]);
-		}
-	}
-}, postCreate:function () {
-	while (this.domNode.childNodes.length > 0) {
-		this.domNode.removeChild(this.domNode.childNodes[0]);
-	}
-	if (this.width > 0 && this.height > 0) {
-		this.map = new YMap(this.domNode, YAHOO_MAP_REG, new YSize(this.width, this.height));
-	} else {
-		this.map = new YMap(this.domNode);
-	}
-	this.setControls();
-	this.render();
-}});
-
+dojo.provide("dojo.widget.YahooMap");
+dojo.provide("dojo.widget.YahooMap.Controls");
+dojo.require("dojo.widget.*");
+
+dojo.widget.defineWidget(
+	"dojo.widget.YahooMap",
+	dojo.widget.Widget,
+	{ isContainer: false }
+);
+
+dojo.widget.YahooMap.Controls={
+	MapType:"maptype",
+	Pan:"pan",
+	ZoomLong:"zoomlong",
+	ZoomShort:"zoomshort"
+};
+dojo.requireAfterIf("html", "dojo.widget.html.YahooMap");

Modified: tags/parley-0.53/root/static/magic/src/widget/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,16 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({common:["dojo.xml.Parse", "dojo.widget.Widget", "dojo.widget.Parse", "dojo.widget.Manager"], browser:["dojo.widget.DomWidget", "dojo.widget.HtmlWidget"], dashboard:["dojo.widget.DomWidget", "dojo.widget.HtmlWidget"], svg:["dojo.widget.SvgWidget"], rhino:["dojo.widget.SwtWidget"]});
+dojo.kwCompoundRequire({
+	common: ["dojo.xml.Parse", 
+			 "dojo.widget.Widget", 
+			 "dojo.widget.Parse", 
+			 "dojo.widget.Manager"],
+	browser: ["dojo.widget.DomWidget",
+			  "dojo.widget.HtmlWidget"],
+	dashboard: ["dojo.widget.DomWidget",
+			  "dojo.widget.HtmlWidget"],
+	svg: 	 ["dojo.widget.SvgWidget"],
+	rhino: 	 ["dojo.widget.SwtWidget"]
+});
 dojo.provide("dojo.widget.*");
-

Modified: tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoContainer.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoContainer.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoContainer.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,68 +8,100 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.demoEngine.DemoContainer");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
 dojo.require("dojo.widget.demoEngine.DemoPane");
 dojo.require("dojo.widget.demoEngine.SourcePane");
 dojo.require("dojo.widget.TabContainer");
-dojo.widget.defineWidget("my.widget.demoEngine.DemoContainer", dojo.widget.HtmlWidget, {templateString:"<div dojoAttachPoint=\"domNode\">\n\t<table width=\"100%\" cellspacing=\"0\" cellpadding=\"5\">\n\t\t<tbody>\n\t\t\t<tr dojoAttachPoint=\"headerNode\">\n\t\t\t\t<td dojoAttachPoint=\"returnNode\" valign=\"middle\" width=\"1%\">\n\t\t\t\t\t<img dojoAttachPoint=\"returnImageNode\" dojoAttachEvent=\"onclick: returnToDemos\"/>\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t<h1 dojoAttachPoint=\"demoNameNode\"></h1>\n\t\t\t\t\t<p dojoAttachPoint=\"summaryNode\"></p>\n\t\t\t\t</td>\n\t\t\t\t<td dojoAttachPoint=\"tabControlNode\" valign=\"middle\" align=\"right\" nowrap>\n\t\t\t\t\t<span dojoAttachPoint=\"sourceButtonNode\" dojoAttachEvent=\"onclick: showSource\">source</span>\n\t\t\t\t\t<span dojoAttachPoint=\"demoButtonNode\" dojoAttachEvent=\"onclick: showDemo\">demo</span>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"3\">\n\t\t\t\t\t<div dojoAttachPoint=\"tabNode\!
 ">\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n</div>\n", templateCssString:".demoContainer{\n\twidth: 100%;\n\theight: 100%;\n\tpadding: 0px;\n\tmargin: 0px;\n}\n\n.demoContainer .return {\n\tcursor: pointer;\n}\n\n.demoContainer span {\n\tmargin-right: 10px;\n\tcursor: pointer;\n}\n\n.demoContainer .selected {\n\tborder-bottom: 5px solid #95bfff;\n}\n\n.demoContainer table {\n\tbackground: #f5f5f5;\n\twidth: 100%;\n\theight: 100%;\n}\n\n.demoContainerTabs {\n\twidth: 100%;\n\theight: 400px;\n}\n\n.demoContainerTabs .dojoTabLabels-top {\n\tdisplay: none;\n}\n\n.demoContainerTabs .dojoTabPaneWrapper {\n\tborder: 0px;\n}\n\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "demoEngine/templates/DemoContainer.css"), postCreate:function () {
-	dojo.html.addClass(this.domNode, this.domNodeClass);
-	dojo.html.addClass(this.tabNode, this.tabClass);
-	dojo.html.addClass(this.returnImageNode, this.returnClass);
-	this.returnImageNode.src = this.returnImage;
-	this.tabContainer = dojo.widget.createWidget("TabContainer", {}, this.tabNode);
-	this.demoTab = dojo.widget.createWidget("DemoPane", {});
-	this.tabContainer.addChild(this.demoTab);
-	this.sourceTab = dojo.widget.createWidget("SourcePane", {});
-	this.tabContainer.addChild(this.sourceTab);
-	dojo.html.setOpacity(this.domNode, 0);
-	dojo.html.hide(this.domNode);
-}, loadDemo:function (url) {
-	this.demoTab.setHref(url);
-	this.sourceTab.setHref(url);
-	this.showDemo();
-}, setName:function (name) {
-	dojo.html.removeChildren(this.demoNameNode);
-	this.demoNameNode.appendChild(document.createTextNode(name));
-}, setSummary:function (summary) {
-	dojo.html.removeChildren(this.summaryNode);
-	this.summaryNode.appendChild(document.createTextNode(summary));
-}, showSource:function () {
-	dojo.html.removeClass(this.demoButtonNode, this.selectedButtonClass);
-	dojo.html.addClass(this.sourceButtonNode, this.selectedButtonClass);
-	this.tabContainer.selectTab(this.sourceTab);
-}, showDemo:function () {
-	dojo.html.removeClass(this.sourceButtonNode, this.selectedButtonClass);
-	dojo.html.addClass(this.demoButtonNode, this.selectedButtonClass);
-	this.tabContainer.selectTab(this.demoTab);
-}, returnToDemos:function () {
-	dojo.debug("Return To Demos");
-}, show:function () {
-	dojo.html.setOpacity(this.domNode, 1);
-	dojo.html.show(this.domNode);
-	this.tabContainer.checkSize();
-}}, "", function () {
-	dojo.debug("DemoPane Init");
-	this.domNodeClass = "demoContainer";
-	this.tabContainer = "";
-	this.sourceTab = "";
-	this.demoTab = "";
-	this.headerNode = "";
-	this.returnNode = "";
-	this.returnImageNode = "";
-	this.returnImage = "images/dojoDemos.gif";
-	this.returnClass = "return";
-	this.summaryNode = "";
-	this.demoNameNode = "";
-	this.tabControlNode = "";
-	this.tabNode = "";
-	this.tabClass = "demoContainerTabs";
-	this.sourceButtonNode = "";
-	this.demoButtonNode = "";
-	this.selectedButtonClass = "selected";
-});
 
+dojo.widget.defineWidget("my.widget.demoEngine.DemoContainer", 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoContainer.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoContainer.css"),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.html.addClass(this.tabNode, this.tabClass);
+			dojo.html.addClass(this.returnImageNode, this.returnClass);
+			this.returnImageNode.src=this.returnImage;
+
+			this.tabContainer = dojo.widget.createWidget("TabContainer",{},this.tabNode);
+
+			this.demoTab = dojo.widget.createWidget("DemoPane",{});
+			this.tabContainer.addChild(this.demoTab);
+
+			this.sourceTab= dojo.widget.createWidget("SourcePane",{});
+			this.tabContainer.addChild(this.sourceTab);
+
+			dojo.html.setOpacity(this.domNode,0);
+			dojo.html.hide(this.domNode);
+		},
+
+		loadDemo: function(url) {
+			this.demoTab.setHref(url);
+			this.sourceTab.setHref(url);
+			this.showDemo();
+		},
+
+		setName: function(name) {
+			dojo.html.removeChildren(this.demoNameNode);
+			this.demoNameNode.appendChild(document.createTextNode(name));
+		},
+
+		setSummary: function(summary) {
+			dojo.html.removeChildren(this.summaryNode);
+			this.summaryNode.appendChild(document.createTextNode(summary));
+		},
+
+		showSource: function() {
+			dojo.html.removeClass(this.demoButtonNode,this.selectedButtonClass);
+			dojo.html.addClass(this.sourceButtonNode,this.selectedButtonClass);
+			this.tabContainer.selectTab(this.sourceTab);	
+		},
+
+		showDemo: function() {
+			dojo.html.removeClass(this.sourceButtonNode,this.selectedButtonClass);
+			dojo.html.addClass(this.demoButtonNode,this.selectedButtonClass);
+			this.tabContainer.selectTab(this.demoTab);
+		},
+
+		returnToDemos: function() {
+			dojo.debug("Return To Demos");
+		},
+
+		show: function() {
+			dojo.html.setOpacity(this.domNode,1);
+			dojo.html.show(this.domNode);
+			this.tabContainer.checkSize();
+		}
+	},
+	"",
+	function() {
+		dojo.debug("DemoPane Init");
+		this.domNodeClass="demoContainer";
+
+		this.tabContainer="";
+		this.sourceTab="";
+		this.demoTab="";
+
+		this.headerNode="";
+		this.returnNode="";
+	
+		this.returnImageNode="";
+		this.returnImage="images/dojoDemos.gif";
+		this.returnClass="return";
+		
+		this.summaryNode="";
+		this.demoNameNode="";
+		this.tabControlNode="";
+
+		this.tabNode="";
+		this.tabClass = "demoContainerTabs";
+
+		this.sourceButtonNode="";
+		this.demoButtonNode="";
+
+		this.selectedButtonClass="selected";
+	}
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoItem.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoItem.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoItem.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,45 +8,64 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.demoEngine.DemoItem");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("my.widget.demoEngine.DemoItem", dojo.widget.HtmlWidget, {templateString:"<div dojoAttachPoint=\"domNode\">\n\t<div dojoAttachPoint=\"summaryBoxNode\">\n\t\t<table width=\"100%\" cellspacing=\"0\" cellpadding=\"0\">\n\t\t\t<tbody>\n\t\t\t\t<tr>\n\t\t\t\t\t<td dojoAttachPoint=\"screenshotTdNode\" valign=\"top\" width=\"1%\">\n\t\t\t\t\t\t<img dojoAttachPoint=\"thumbnailImageNode\" dojoAttachEvent=\"onclick: onSelectDemo\" />\n\t\t\t\t\t</td>\n\t\t\t\t\t<td dojoAttachPoint=\"summaryContainerNode\" valign=\"top\">\n\t\t\t\t\t\t<h1 dojoAttachPoint=\"nameNode\">\n\t\t\t\t\t\t</h1>\n\t\t\t\t\t\t<div dojoAttachPoint=\"summaryNode\">\n\t\t\t\t\t\t\t<p dojoAttachPoint=\"descriptionNode\"></p>\n\t\t\t\t\t\t\t<div dojoAttachPoint=\"viewDemoLinkNode\"><img dojoAttachPoint=\"viewDemoImageNode\"/ dojoAttachEvent=\"onclick: onSelectDemo\"></div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</td>\n\t\t\t\t</tr>\n\t\t\t</tbody>\n\t\t</table>\n\t</div>\n</div>\n", templateCssStrin!
 g:".demoItemSummaryBox {\n\tbackground: #efefef;\n\tborder:1px solid #dae3ee;\n}\n\n.demoItemScreenshot {\n\tpadding:0.65em;\n\twidth:175px;\n\tborder-right:1px solid #fafafa;\n\ttext-align:center;\n\tcursor: pointer;\n}\n\n.demoItemWrapper{\n\tmargin-bottom:1em;\n}\n\n.demoItemWrapper a:link, .demoItemWrapper a:visited {\n\tcolor:#a6238f;\n\ttext-decoration:none;\n}\n\n.demoItemSummaryContainer {\n\tborder-left:1px solid #ddd;\n}\n\n.demoItemSummaryContainer h1 {\n\tbackground-color:#e8e8e8;\n\tborder-bottom: 1px solid #e6e6e6;\n\tcolor:#738fb9;\n\tmargin:1px;\n\tpadding:0.5em;\n\tfont-family:\"Lucida Grande\", \"Tahoma\", serif;\n\tfont-size:1.25em;\n\tfont-weight:normal;\n}\n\n.demoItemSummaryContainer h1 .packageSummary {\n\tdisplay:block;\n\tcolor:#000;\n\tfont-size:10px;\n\tmargin-top:2px;\n}\n\n.demoItemSummaryContainer .demoItemSummary{\n\tpadding:1em;\n}\n\n.demoItemSummaryContainer .demoItemSummary p {\n\tfont-size:0.85em;\n\tpadding:0;\n\tmargin:0;\n}\n\n.demoIte!
 mView {\n\ttext-align:right;\n\tcursor: pointer;\n}\n", templa!
 teCssPat
h:dojo.uri.moduleUri("dojo.widget", "demoEngine/templates/DemoItem.css"), postCreate:function () {
-	dojo.html.addClass(this.domNode, this.domNodeClass);
-	dojo.html.addClass(this.summaryBoxNode, this.summaryBoxClass);
-	dojo.html.addClass(this.screenshotTdNode, this.screenshotTdClass);
-	dojo.html.addClass(this.summaryContainerNode, this.summaryContainerClass);
-	dojo.html.addClass(this.summaryNode, this.summaryClass);
-	dojo.html.addClass(this.viewDemoLinkNode, this.viewDemoLinkClass);
-	this.nameNode.appendChild(document.createTextNode(this.name));
-	this.descriptionNode.appendChild(document.createTextNode(this.description));
-	this.thumbnailImageNode.src = this.thumbnail;
-	this.thumbnailImageNode.name = this.name;
-	this.viewDemoImageNode.src = this.viewDemoImage;
-	this.viewDemoImageNode.name = this.name;
-}, onSelectDemo:function () {
-}}, "", function () {
-	this.demo = "";
-	this.domNodeClass = "demoItemWrapper";
-	this.summaryBoxNode = "";
-	this.summaryBoxClass = "demoItemSummaryBox";
-	this.nameNode = "";
-	this.thumbnailImageNode = "";
-	this.viewDemoImageNode = "";
-	this.screenshotTdNode = "";
-	this.screenshotTdClass = "demoItemScreenshot";
-	this.summaryContainerNode = "";
-	this.summaryContainerClass = "demoItemSummaryContainer";
-	this.summaryNode = "";
-	this.summaryClass = "demoItemSummary";
-	this.viewDemoLinkNode = "";
-	this.viewDemoLinkClass = "demoItemView";
-	this.descriptionNode = "";
-	this.name = "Some Demo";
-	this.description = "This is the description of this demo.";
-	this.thumbnail = "images/test_thumb.gif";
-	this.viewDemoImage = "images/viewDemo.png";
-});
 
+dojo.widget.defineWidget("my.widget.demoEngine.DemoItem", 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoItem.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoItem.css"),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.html.addClass(this.summaryBoxNode, this.summaryBoxClass);
+			dojo.html.addClass(this.screenshotTdNode, this.screenshotTdClass);
+			dojo.html.addClass(this.summaryContainerNode, this.summaryContainerClass);
+			dojo.html.addClass(this.summaryNode, this.summaryClass);
+			dojo.html.addClass(this.viewDemoLinkNode, this.viewDemoLinkClass);
+
+			this.nameNode.appendChild(document.createTextNode(this.name));
+			this.descriptionNode.appendChild(document.createTextNode(this.description));
+			this.thumbnailImageNode.src = this.thumbnail;
+			this.thumbnailImageNode.name=this.name;
+			this.viewDemoImageNode.src = this.viewDemoImage;
+			this.viewDemoImageNode.name=this.name;
+		},
+		onSelectDemo: function() {
+			//Attach to this to do something when a demo is selected
+		}
+	},
+	"",
+	function() {
+		this.demo = "";
+
+		this.domNodeClass="demoItemWrapper";
+
+		this.summaryBoxNode="";
+		this.summaryBoxClass="demoItemSummaryBox";
+
+		this.nameNode="";
+		this.thumbnailImageNode="";
+		this.viewDemoImageNode="";
+
+		this.screenshotTdNode="";
+		this.screenshotTdClass="demoItemScreenshot";
+
+		this.summaryContainerNode="";
+		this.summaryContainerClass="demoItemSummaryContainer";
+
+		this.summaryNode="";
+		this.summaryClass="demoItemSummary";
+
+		this.viewDemoLinkNode="";
+		this.viewDemoLinkClass="demoItemView";
+
+		this.descriptionNode="";
+
+		this.name="Some Demo";
+		this.description="This is the description of this demo.";
+		this.thumbnail="images/test_thumb.gif";
+		this.viewDemoImage="images/viewDemo.png";
+	}
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoNavigator.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoNavigator.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoNavigator.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,6 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.demoEngine.DemoNavigator");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
@@ -17,118 +15,174 @@
 dojo.require("dojo.widget.demoEngine.DemoItem");
 dojo.require("dojo.io.*");
 dojo.require("dojo.lfx.*");
-dojo.require("dojo.lang.common");
-dojo.widget.defineWidget("my.widget.demoEngine.DemoNavigator", dojo.widget.HtmlWidget, {templateString:"<div dojoAttachPoint=\"domNode\">\n\t<table width=\"100%\" cellspacing=\"0\" cellpadding=\"5\">\n\t\t<tbody>\n\t\t\t<tr dojoAttachPoint=\"navigationContainer\">\n\t\t\t\t<td dojoAttachPoint=\"categoriesNode\" valign=\"top\" width=\"1%\">\n\t\t\t\t\t<h1>Categories</h1>\n\t\t\t\t\t<div dojoAttachPoint=\"categoriesButtonsNode\"></div>\n\t\t\t\t</td>\n\n\t\t\t\t<td dojoAttachPoint=\"demoListNode\" valign=\"top\">\n\t\t\t\t\t<div dojoAttachPoint=\"demoListWrapperNode\">\n\t\t\t\t\t\t<div dojoAttachPoint=\"demoListContainerNode\">\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td colspan=\"2\">\n\t\t\t\t\t<div dojoAttachPoint=\"demoNode\"></div>\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</tbody>\n\t</table>\n</div>\n", templateCssString:".demoNavigatorListWrapper {\n\tborder:1px solid #dcdbdb;\n\tbackground-color:#f8f8f8;\n\tpadding:2px;\n}\n\n.d!
 emoNavigatorListContainer {\n\tborder:1px solid #f0f0f0;\n\tbackground-color:#fff;\n\tpadding:1em;\n}\n\n.demoNavigator h1 {\n\tmargin-top: 0px;\n\tmargin-bottom: 10px;\n\tfont-size: 1.2em;\n\tborder-bottom:1px dotted #a9ccf5;\n}\n\n.demoNavigator .dojoButton {\n\tmargin-bottom: 5px;\n}\n\n.demoNavigator .dojoButton .dojoButtonContents {\n\tfont-size: 1.1em;\n\twidth: 100px;\n\tcolor: black;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "demoEngine/templates/DemoNavigator.css"), postCreate:function () {
-	dojo.html.addClass(this.domNode, this.domNodeClass);
-	dojo.html.addClass(this.demoListWrapperNode, this.demoListWrapperClass);
-	dojo.html.addClass(this.demoListContainerNode, this.demoListContainerClass);
-	if (dojo.render.html.ie) {
-		dojo.debug("render ie");
-		dojo.html.hide(this.demoListWrapperNode);
-	} else {
-		dojo.debug("render non-ie");
-		dojo.lfx.html.fadeHide(this.demoListWrapperNode, 0).play();
+dojo.require("dojo.lang.Common");
+
+dojo.widget.defineWidget("my.widget.demoEngine.DemoNavigator", 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoNavigator.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoNavigator.css"),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.html.addClass(this.demoListWrapperNode,this.demoListWrapperClass);
+			dojo.html.addClass(this.demoListContainerNode,this.demoListContainerClass);
+
+			if (dojo.render.html.ie) {
+				dojo.debug("render ie");
+				dojo.html.hide(this.demoListWrapperNode); 
+			} else {
+				dojo.debug("render non-ie");
+				dojo.lfx.html.fadeHide(this.demoListWrapperNode, 0).play();	
+			}
+
+			this.getRegistry(this.demoRegistryUrl);
+
+			this.demoContainer = dojo.widget.createWidget("DemoContainer",{returnImage: this.returnImage},this.demoNode);
+			dojo.event.connect(this.demoContainer,"returnToDemos", this, "returnToDemos");
+			this.demoContainer.hide();
+		},
+
+		returnToDemos: function() {
+			this.demoContainer.hide();
+			if (dojo.render.html.ie) {
+				dojo.debug("render ie");
+				dojo.html.show(this.navigationContainer) ;
+			} else {	
+				dojo.debug("render non-ie");
+				dojo.lfx.html.fadeShow(this.navigationContainer,250).play();
+			}
+
+			//if (dojo.render.html.ie) {
+			//	dojo.html.setOpacity(this.navigationContainer);
+			//}
+
+			dojo.lang.forEach(this.categoriesChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+
+			dojo.lang.forEach(this.demoListChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+		},
+
+		show: function() {
+			//dojo.widget.demoEngine.DemoNavigator.superclass.show.call(this);
+			dojo.html.show(this.domNode);
+			dojo.html.setOpacity(this.domNode,1);
+			//dojo.html.setOpacity(this.navigationContainer);	
+			//dojo.html.show(this.navigationContainer);
+			dojo.html.setOpacity(this.navigationContainer,1);
+
+			dojo.lang.forEach(this.categoriesChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+
+			dojo.lang.forEach(this.demoListChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+		},
+		getRegistry: function(url) {
+			dojo.io.bind({
+				url: url,
+				load: dojo.lang.hitch(this,this.processRegistry),
+				mimetype: "text/json"
+			});
+		},
+
+		processRegistry: function(type,registry,e) {
+			dojo.debug("Processing Registry");
+			this.registry = registry;
+			dojo.lang.forEach(this.registry.navigation, dojo.lang.hitch(this,this.addCategory)); 
+		},
+
+		addCategory: function(category) {
+				var newCat = dojo.widget.createWidget("Button",{caption: category.name});
+
+				if(!dojo.lang.isObject(this.registry.categories)) {
+					this.registry.categories=function(){};
+				}
+
+				this.registry.categories[category.name] = category;
+				this.categoriesChildren.push(newCat);
+				this.categoriesButtonsNode.appendChild(newCat.domNode);	
+				newCat.domNode.categoryName = category.name;
+				dojo.event.connect(newCat,"onClick", this, "onSelectCategory");
+		},
+
+		addDemo: function(demoName) {
+			var demo = this.registry.definitions[demoName];
+
+			if (dojo.render.html.ie) {
+				dojo.html.show(this.demoListWrapperNode) 
+			} else {
+				dojo.lfx.html.fadeShow(this.demoListWrapperNode, 250).play();
+			}
+
+			var newDemo = dojo.widget.createWidget("DemoItem",{viewDemoImage: this.viewDemoImage, name: demoName, description: demo.description, thumbnail: demo.thumbnail});
+			this.demoListChildren.push(newDemo);
+			this.demoListContainerNode.appendChild(newDemo.domNode);	
+			dojo.event.connect(newDemo,"onSelectDemo",this,"onSelectDemo");
+		},
+
+		onSelectCategory: function(e) {
+			catName = e.currentTarget.categoryName;	
+			dojo.debug("Selected Category: " + catName);
+			//Remove current list of demos
+			dojo.lang.forEach(this.demoListChildren, function(child) {
+					child.destroy();
+			});
+			this.demoListChildren=[];
+
+			//add demos from this cat
+			dojo.lang.forEach(this.registry.categories[catName].demos, dojo.lang.hitch(this,function(demoName){
+				this.addDemo(demoName);
+			}));
+		},
+
+		onSelectDemo: function(e) {
+			//Attach to this to do something when a demo is selected
+			dojo.debug("Demo Selected: " + e.target.name);
+
+			if (dojo.render.html.ie) {
+				dojo.debug("render ie");
+				dojo.html.hide(this.navigationContainer) ;
+				this.demoContainer.show();
+				this.demoContainer.showDemo();
+			} else {
+				dojo.debug("render non-ie");
+				dojo.lfx.html.fadeHide(this.navigationContainer,250,null,dojo.lang.hitch(this, function() {
+					this.demoContainer.show();	
+					this.demoContainer.showDemo();
+				})).play();
+			}
+
+			this.demoContainer.loadDemo(this.registry.definitions[e.target.name].url);
+			this.demoContainer.setName(e.target.name);
+			this.demoContainer.setSummary(this.registry.definitions[e.target.name].description);
+		}
+		
+	},
+	"",
+	function() {
+		this.demoRegistryUrl="demoRegistry.json";
+		this.registry=function(){};
+
+		this.categoriesNode="";
+		this.categoriesButtonsNode="";
+		this.navigationContainer="";
+
+		this.domNodeClass="demoNavigator";
+
+		this.demoNode="";
+		this.demoContainer="";
+
+		this.demoListWrapperNode="";
+		this.demoListWrapperClass="demoNavigatorListWrapper";
+		this.demoListContainerClass="demoNavigatorListContainer";
+
+		this.returnImage="images/dojoDemos.gif";
+		this.viewDemoImage="images/viewDemo.png";
+		this.demoListChildren = [];
+		this.categoriesChildren = [];
 	}
-	this.getRegistry(this.demoRegistryUrl);
-	this.demoContainer = dojo.widget.createWidget("DemoContainer", {returnImage:this.returnImage}, this.demoNode);
-	dojo.event.connect(this.demoContainer, "returnToDemos", this, "returnToDemos");
-	this.demoContainer.hide();
-}, returnToDemos:function () {
-	this.demoContainer.hide();
-	if (dojo.render.html.ie) {
-		dojo.debug("render ie");
-		dojo.html.show(this.navigationContainer);
-	} else {
-		dojo.debug("render non-ie");
-		dojo.lfx.html.fadeShow(this.navigationContainer, 250).play();
-	}
-	dojo.lang.forEach(this.categoriesChildren, dojo.lang.hitch(this, function (child) {
-		child.checkSize();
-	}));
-	dojo.lang.forEach(this.demoListChildren, dojo.lang.hitch(this, function (child) {
-		child.checkSize();
-	}));
-}, show:function () {
-	dojo.html.show(this.domNode);
-	dojo.html.setOpacity(this.domNode, 1);
-	dojo.html.setOpacity(this.navigationContainer, 1);
-	dojo.lang.forEach(this.categoriesChildren, dojo.lang.hitch(this, function (child) {
-		child.checkSize();
-	}));
-	dojo.lang.forEach(this.demoListChildren, dojo.lang.hitch(this, function (child) {
-		child.checkSize();
-	}));
-}, getRegistry:function (url) {
-	dojo.io.bind({url:url, load:dojo.lang.hitch(this, this.processRegistry), mimetype:"text/json"});
-}, processRegistry:function (type, registry, e) {
-	dojo.debug("Processing Registry");
-	this.registry = registry;
-	dojo.lang.forEach(this.registry.navigation, dojo.lang.hitch(this, this.addCategory));
-}, addCategory:function (category) {
-	var newCat = dojo.widget.createWidget("Button", {caption:category.name});
-	if (!dojo.lang.isObject(this.registry.categories)) {
-		this.registry.categories = function () {
-		};
-	}
-	this.registry.categories[category.name] = category;
-	this.categoriesChildren.push(newCat);
-	this.categoriesButtonsNode.appendChild(newCat.domNode);
-	newCat.domNode.categoryName = category.name;
-	dojo.event.connect(newCat, "onClick", this, "onSelectCategory");
-}, addDemo:function (demoName) {
-	var demo = this.registry.definitions[demoName];
-	if (dojo.render.html.ie) {
-		dojo.html.show(this.demoListWrapperNode);
-	} else {
-		dojo.lfx.html.fadeShow(this.demoListWrapperNode, 250).play();
-	}
-	var newDemo = dojo.widget.createWidget("DemoItem", {viewDemoImage:this.viewDemoImage, name:demoName, description:demo.description, thumbnail:demo.thumbnail});
-	this.demoListChildren.push(newDemo);
-	this.demoListContainerNode.appendChild(newDemo.domNode);
-	dojo.event.connect(newDemo, "onSelectDemo", this, "onSelectDemo");
-}, onSelectCategory:function (e) {
-	catName = e.currentTarget.categoryName;
-	dojo.debug("Selected Category: " + catName);
-	dojo.lang.forEach(this.demoListChildren, function (child) {
-		child.destroy();
-	});
-	this.demoListChildren = [];
-	dojo.lang.forEach(this.registry.categories[catName].demos, dojo.lang.hitch(this, function (demoName) {
-		this.addDemo(demoName);
-	}));
-}, onSelectDemo:function (e) {
-	dojo.debug("Demo Selected: " + e.target.name);
-	if (dojo.render.html.ie) {
-		dojo.debug("render ie");
-		dojo.html.hide(this.navigationContainer);
-		this.demoContainer.show();
-		this.demoContainer.showDemo();
-	} else {
-		dojo.debug("render non-ie");
-		dojo.lfx.html.fadeHide(this.navigationContainer, 250, null, dojo.lang.hitch(this, function () {
-			this.demoContainer.show();
-			this.demoContainer.showDemo();
-		})).play();
-	}
-	this.demoContainer.loadDemo(this.registry.definitions[e.target.name].url);
-	this.demoContainer.setName(e.target.name);
-	this.demoContainer.setSummary(this.registry.definitions[e.target.name].description);
-}}, "", function () {
-	this.demoRegistryUrl = "demoRegistry.json";
-	this.registry = function () {
-	};
-	this.categoriesNode = "";
-	this.categoriesButtonsNode = "";
-	this.navigationContainer = "";
-	this.domNodeClass = "demoNavigator";
-	this.demoNode = "";
-	this.demoContainer = "";
-	this.demoListWrapperNode = "";
-	this.demoListWrapperClass = "demoNavigatorListWrapper";
-	this.demoListContainerClass = "demoNavigatorListContainer";
-	this.returnImage = "images/dojoDemos.gif";
-	this.viewDemoImage = "images/viewDemo.png";
-	this.demoListChildren = [];
-	this.categoriesChildren = [];
-});
-
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/demoEngine/DemoPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,26 +8,37 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.demoEngine.DemoPane");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
-dojo.widget.defineWidget("my.widget.demoEngine.DemoPane", dojo.widget.HtmlWidget, {templateString:"<div dojoAttachPoint=\"domNode\">\n\t<iframe dojoAttachPoint=\"demoNode\"></iframe>\n</div>\n", templateCssString:".demoPane {\n\twidth: 100%;\n\theight: 100%;\n\tpadding: 0px;\n\tmargin: 0px;\n\toverflow: hidden;\n}\n\n.demoPane iframe {\n\twidth: 100%;\n\theight: 100%;\n\tborder: 0px;\n\tborder: none;\n\toverflow: auto;\n\tpadding: 0px;\n\tmargin:0px;\n\tbackground: #ffffff;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "demoEngine/templates/DemoPane.css"), postCreate:function () {
-	dojo.html.addClass(this.domNode, this.domNodeClass);
-	dojo.debug("PostCreate");
-	this._launchDemo();
-}, _launchDemo:function () {
-	dojo.debug("Launching Demo");
-	dojo.debug(this.demoNode);
-	this.demoNode.src = this.href;
-}, setHref:function (url) {
-	this.href = url;
-	this._launchDemo();
-}}, "", function () {
-	dojo.debug("DemoPane Init");
-	this.domNodeClass = "demoPane";
-	this.demoNode = "";
-	this.href = "";
-});
 
+dojo.widget.defineWidget("my.widget.demoEngine.DemoPane", 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoPane.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/demoEngine/templates/DemoPane.css"),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.debug("PostCreate");
+			this._launchDemo();
+		},
+		
+		_launchDemo: function() {
+			dojo.debug("Launching Demo");
+			dojo.debug(this.demoNode);
+			this.demoNode.src=this.href;
+		},
+
+		setHref: function(url) {
+			this.href = url;
+			this._launchDemo();
+		}
+	},
+	"",
+	function() {
+		dojo.debug("DemoPane Init");
+		this.domNodeClass="demoPane";
+		this.demoNode = "";
+		this.href = "";
+	}
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/demoEngine/SourcePane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/demoEngine/SourcePane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/demoEngine/SourcePane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,28 +8,45 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.provide("dojo.widget.demoEngine.SourcePane");
 dojo.require("dojo.widget.*");
 dojo.require("dojo.widget.HtmlWidget");
 dojo.require("dojo.io.*");
-dojo.widget.defineWidget("my.widget.demoEngine.SourcePane", dojo.widget.HtmlWidget, {templateString:"<div dojoAttachPoint=\"domNode\">\n\t<textarea dojoAttachPoint=\"sourceNode\" rows=\"100%\"></textarea>\n</div>\n", templateCssString:".sourcePane {\n\twidth: 100%;\n\theight: 100%;\n\tpadding: 0px;\n\tmargin: 0px;\n\toverflow: hidden;\n}\n\n.sourcePane textarea{\n\twidth: 100%;\n\theight: 100%;\n\tborder: 0px;\n\toverflow: auto;\n\tpadding: 0px;\n\tmargin:0px;\n}\n\n* html .sourcePane {\n\toverflow: auto;\n}\n", templateCssPath:dojo.uri.moduleUri("dojo.widget", "demoEngine/templates/SourcePane.css"), postCreate:function () {
-	dojo.html.addClass(this.domNode, this.domNodeClass);
-	dojo.debug("PostCreate");
-}, getSource:function () {
-	if (this.href) {
-		dojo.io.bind({url:this.href, load:dojo.lang.hitch(this, "fillInSource"), mimetype:"text/plain"});
+
+dojo.widget.defineWidget("my.widget.demoEngine.SourcePane", 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri("src/widget/demoEngine/templates/SourcePane.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/demoEngine/templates/SourcePane.css"),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.debug("PostCreate");
+		},
+	
+		getSource: function() {
+			if (this.href) {
+				dojo.io.bind({
+					url: this.href,
+					load: dojo.lang.hitch(this, "fillInSource"),
+					mimetype: "text/plain"
+				});
+			}
+		},	
+
+		fillInSource: function(type, source, e) {
+			this.sourceNode.value=source;
+		},
+
+		setHref: function(url) {
+			this.href = url;
+			this.getSource();
+		}
+	},
+	"",
+	function() {
+		dojo.debug("SourcePane Init");
+		this.domNodeClass="sourcePane";
+		this.sourceNode = "";
+		this.href = "";
 	}
-}, fillInSource:function (type, source, e) {
-	this.sourceNode.value = source;
-}, setHref:function (url) {
-	this.href = url;
-	this.getSource();
-}}, "", function () {
-	dojo.debug("SourcePane Init");
-	this.domNodeClass = "sourcePane";
-	this.sourceNode = "";
-	this.href = "";
-});
-
+);

Modified: tags/parley-0.53/root/static/magic/src/widget/demoEngine/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/demoEngine/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/demoEngine/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,13 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.kwCompoundRequire({browser:["dojo.widget.demoEngine.DemoItem", "dojo.widget.demoEngine.DemoNavigator", "dojo.widget.demoEngine.DemoPane", "dojo.widget.demoEngine.SourcePane", "dojo.widget.demoEngine.DemoContainer"]});
+dojo.kwCompoundRequire({
+	browser: [
+		"dojo.widget.demoEngine.DemoItem",
+		"dojo.widget.demoEngine.DemoNavigator",
+		"dojo.widget.demoEngine.DemoPane",
+		"dojo.widget.demoEngine.SourcePane",
+		"dojo.widget.demoEngine.DemoContainer"
+	]
+});
 dojo.provide("dojo.widget.demoEngine.*");
-

Added: tags/parley-0.53/root/static/magic/src/widget/html/AccordionPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/AccordionPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/AccordionPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,98 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.AccordionPane");
+dojo.require("dojo.widget.TitlePane");
+
+dojo.widget.html.AccordionPane = function(){
+
+	dojo.widget.html.TitlePane.call(this);
+	this.widgetType = "AccordionPane";
+
+	this.open=false;
+	this.allowCollapse=true;
+	this.label="";
+	this.open=false;
+
+	this.labelNodeClass="";
+	this.containerNodeClass="";
+}
+
+dojo.inherits(dojo.widget.html.AccordionPane, dojo.widget.html.TitlePane);
+
+dojo.lang.extend(dojo.widget.html.AccordionPane, {
+        postCreate: function() {
+                dojo.widget.html.AccordionPane.superclass.postCreate.call(this);
+		this.domNode.widgetType=this.widgetType;
+		this.setSizes();
+		dojo.html.addClass(this.labelNode, this.labelNodeClass);
+		dojo.html.disableSelection(this.labelNode);
+		dojo.html.addClass(this.containerNode, this.containerNodeClass);
+        },
+
+	collapse: function() {
+		//dojo.fx.html.wipeOut(this.containerNode,250);
+		//var anim = dojo.fx.html.wipe(this.containerNode, 1000, this.containerNode.offsetHeight, 0, null, true);
+		this.containerNode.style.display="none";
+		this.open=false;
+	},
+
+	expand: function() {
+		//dojo.fx.html.wipeIn(this.containerNode,250);
+		this.containerNode.style.display="block";
+		//var anim = dojo.fx.html.wipe(this.containerNode, 1000, 0, this.containerNode.scrollHeight, null, true);
+		this.open=true;
+	},
+
+	getCollapsedHeight: function() {
+		return dojo.style.getOuterHeight(this.labelNode)+1;
+	},
+
+	setSizes: function() {
+		var siblings = this.domNode.parentNode.childNodes;
+		var height=dojo.style.getInnerHeight(this.domNode.parentNode)-this.getCollapsedHeight();
+
+		this.siblingWidgets = [];
+	
+		for (var x=0; x<siblings.length; x++) {
+			if (siblings[x].widgetType==this.widgetType) {
+				if (this.domNode != siblings[x]) {
+					var ap = dojo.widget.byNode(siblings[x]);
+					this.siblingWidgets.push(ap);
+					height -= ap.getCollapsedHeight();
+				}
+			}
+		}
+	
+		for (var x=0; x<this.siblingWidgets.length; x++) {
+			dojo.style.setOuterHeight(this.siblingWidgets[x].containerNode,height);
+		}
+
+		dojo.style.setOuterHeight(this.containerNode,height);
+	},
+
+	onLabelClick: function() {
+		this.setSizes();
+		if (!this.open) { 
+			for (var x=0; x<this.siblingWidgets.length;x++) {
+				if (this.siblingWidgets[x].open) {
+					this.siblingWidgets[x].collapse();
+				}
+			}
+			this.expand();
+		} else {
+			if (this.allowCollapse) {
+				this.collapse();
+			}
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:AccordionPane");

Added: tags/parley-0.53/root/static/magic/src/widget/html/Button2.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Button2.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Button2.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,25 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+// this is a stub that will be removed in 0.4, see ../Button2.html for details
+
+dojo.provide("dojo.widget.html.Button2");
+
+dojo.widget.html.Button2 = function(){}
+dojo.inherits(dojo.widget.html.Button2, dojo.widget.html.Button);
+dojo.lang.extend(dojo.widget.html.Button2, { widgetType: "Button2" });
+
+dojo.widget.html.DropDownButton2 = function(){}
+dojo.inherits(dojo.widget.html.DropDownButton2, dojo.widget.html.DropDownButton);
+dojo.lang.extend(dojo.widget.html.DropDownButton2, { widgetType: "DropDownButton2" });
+
+dojo.widget.html.ComboButton2 = function(){}
+dojo.inherits(dojo.widget.html.ComboButton2, dojo.widget.html.ComboButton);
+dojo.lang.extend(dojo.widget.html.ComboButton2, { widgetType: "ComboButton2" });
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/html/Checkbox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Checkbox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Checkbox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,82 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.Checkbox");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.event");
+dojo.require("dojo.html");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Checkbox",
+	dojo.widget.HtmlWidget,
+	{
+		widgetType: "Checkbox",
+	
+		templatePath: dojo.uri.dojoUri('src/widget/templates/HtmlCheckBox.html'),
+
+		srcOn: dojo.uri.dojoUri('src/widget/templates/check_on.gif'),
+		srcOff: dojo.uri.dojoUri('src/widget/templates/check_off.gif'),
+		srcDisabledOn: dojo.uri.dojoUri('src/widget/templates/check_disabled_on.gif'),
+		srcDisabledOff: dojo.uri.dojoUri('src/widget/templates/check_disabled_off.gif'),
+		srcHoverOn: dojo.uri.dojoUri('src/widget/templates/check_hover_on.gif'),
+		srcHoverOff: dojo.uri.dojoUri('src/widget/templates/check_hover_off.gif'),
+
+		imgSrc: null,
+
+		// parameters
+		disabled: "enabled",
+		name: "",
+		checked: false,
+		tabIndex: -1,
+
+		imgNode: null,
+		inputNode: null,
+
+		postMixInProperties: function(){
+			// set correct source for image before instantiating template
+			this._updateImgSrc();
+		},
+
+		onMouseUp: function(){
+			if(this.disabled == "enabled"){
+				this.checked = !this.checked;
+				this.inputNode.checked = this.checked;
+				this._updateImgSrc();
+			}
+		},
+
+		onMouseOver: function(){
+			this.hover=true;
+			this._updateImgSrc();
+		},
+
+		onMouseOut: function(){
+			this.hover=false;
+			this._updateImgSrc();
+		},
+
+		_updateImgSrc: function(){
+			if(this.disabled == "enabled"){
+				if(this.hover){
+					this.imgSrc = this.checked ? this.srcHoverOn : this.srcHoverOff;
+				}else{
+					this.imgSrc = this.checked ? this.srcOn : this.srcOff;
+				}
+			}else{
+				this.imgSrc = this.checked ? this.srcDisabledOn : this.srcDisabledOff;
+			}
+			if(this.imgNode){
+				this.imgNode.src = this.imgSrc;
+			}
+		}
+	}
+);
+

Added: tags/parley-0.53/root/static/magic/src/widget/html/ComboBox.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/ComboBox.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/ComboBox.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,611 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.ComboBox");
+dojo.require("dojo.widget.ComboBox");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.io.*");
+dojo.require("dojo.lfx.*");
+dojo.require("dojo.dom");
+dojo.require("dojo.html");
+dojo.require("dojo.string");
+dojo.require("dojo.widget.html.stabile");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.ComboBox",
+	[dojo.widget.HtmlWidget, dojo.widget.ComboBox],
+	{
+		autoComplete: true,
+		formInputName: "",
+		name: "", // clone in the name from the DOM node
+		textInputNode: null,
+		comboBoxValue: null,
+		comboBoxSelectionValue: null,
+		optionsListWrapper: null,
+		optionsListNode: null,
+		downArrowNode: null,
+		cbTableNode: null,
+		searchTimer: null,
+		searchDelay: 100,
+		dataUrl: "",
+		fadeTime: 200,
+		// maxListLength limits list to X visible rows, scroll on rest 
+		maxListLength: 8, 
+		// mode can also be "remote" for JSON-returning live search or "html" for
+		// dumber live search
+		mode: "local", 
+		selectedResult: null,
+		_highlighted_option: null,
+		_prev_key_backspace: false,
+		_prev_key_esc: false,
+		_result_list_open: false,
+		_gotFocus: false,
+		_mouseover_list: false,
+		dataProviderClass: "dojo.widget.ComboBoxDataProvider",
+
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlComboBox.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlComboBox.css"),
+	
+		setValue: function(value) {
+			this.comboBoxValue.value = value;
+			if (this.textInputNode.value != value) { // prevent mucking up of selection
+				this.textInputNode.value = value;
+			}
+			dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
+		},
+	
+		getValue: function() {
+			return this.comboBoxValue.value;
+		},
+	
+		getState: function() {
+			return {value: this.getValue()};
+		},
+	
+		setState: function(state) {
+			this.setValue(state.value);
+		},
+	
+		getCaretPos: function(element){
+			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
+			if(dojo.lang.isNumber(element.selectionStart)){
+				// FIXME: this is totally borked on Moz < 1.3. Any recourse?
+				return element.selectionStart;
+			}else if(dojo.render.html.ie){
+				// in the case of a mouse click in a popup being handled,
+				// then the document.selection is not the textarea, but the popup
+				// var r = document.selection.createRange();
+				// hack to get IE 6 to play nice. What a POS browser.
+				var tr = document.selection.createRange().duplicate();
+				var ntr = element.createTextRange();
+				tr.move("character",0);
+				ntr.move("character",0);
+				try {
+					// If control doesnt have focus, you get an exception.
+					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
+					// There appears to be no workaround for this - googled for quite a while.
+					ntr.setEndPoint("EndToEnd", tr);
+					return String(ntr.text).replace(/\r/g,"").length;
+				} catch (e) {
+					return 0; // If focus has shifted, 0 is fine for caret pos.
+				}
+				
+			}
+		},
+	
+		setCaretPos: function(element, location){
+			location = parseInt(location);
+			this.setSelectedRange(element, location, location);
+		},
+	
+		setSelectedRange: function(element, start, end){
+			if(!end){ end = element.value.length; }  // NOTE: Strange - should be able to put caret at start of text?
+			// Mozilla
+			// parts borrowed from http://www.faqts.com/knowledge_base/view.phtml/aid/13562/fid/130
+			if(element.setSelectionRange){
+				element.focus();
+				element.setSelectionRange(start, end);
+			}else if(element.createTextRange){ // IE
+				var range = element.createTextRange();
+				with(range){
+					collapse(true);
+					moveEnd('character', end);
+					moveStart('character', start);
+					select();
+				}
+			}else{ //otherwise try the event-creation hack (our own invention)
+				// do we need these?
+				element.value = element.value;
+				element.blur();
+				element.focus();
+				// figure out how far back to go
+				var dist = parseInt(element.value.length)-end;
+				var tchar = String.fromCharCode(37);
+				var tcc = tchar.charCodeAt(0);
+				for(var x = 0; x < dist; x++){
+					var te = document.createEvent("KeyEvents");
+					te.initKeyEvent("keypress", true, true, null, false, false, false, false, tcc, tcc);
+					element.dispatchEvent(te);
+				}
+			}
+		},
+	
+		// does the keyboard related stuff
+		_handleKeyEvents: function(evt){
+			if(evt.ctrlKey || evt.altKey){ return; }
+	
+			// reset these
+			this._prev_key_backspace = false;
+			this._prev_key_esc = false;
+	
+			var k = dojo.event.browser.keys;
+			var doSearch = true;
+	
+			// mozilla quirk 
+			// space has no keyCode in mozilla
+			var keyCode = evt.keyCode;
+			if(keyCode==0 && evt.charCode==k.KEY_SPACE){
+				keyCode = k.KEY_SPACE;
+			}
+			switch(keyCode){
+	 			case k.KEY_DOWN_ARROW:
+					if(!this._result_list_open){
+						this.startSearchFromInput();
+					}
+					this.highlightNextOption();
+					dojo.event.browser.stopEvent(evt);
+					return;
+				case k.KEY_UP_ARROW:
+					this.highlightPrevOption();
+					dojo.event.browser.stopEvent(evt);
+					return;
+				case k.KEY_ENTER:
+					// prevent submitting form if we press enter with list open
+					if(this._result_list_open){
+						dojo.event.browser.stopEvent(evt);
+					}
+					// fallthrough
+				case k.KEY_TAB:
+					// using linux alike tab for autocomplete
+					if(!this.autoComplete && this._result_list_open && this._highlighted_option){
+						dojo.event.browser.stopEvent(evt);
+						this.selectOption({ 'target': this._highlighted_option, 'noHide': true });
+	
+						// put caret last
+						this.setSelectedRange(this.textInputNode, this.textInputNode.value.length, null);
+					}else{
+						this.selectOption();
+						return;
+					}
+					break;
+				case k.KEY_SPACE:
+					if(this._result_list_open && this._highlighted_option){
+						dojo.event.browser.stopEvent(evt);
+						this.selectOption();
+						this.hideResultList();
+						return;
+					}
+					break;
+				case k.KEY_ESCAPE:
+					this.hideResultList();
+					this._prev_key_esc = true;
+					return;
+				case k.KEY_BACKSPACE:
+					this._prev_key_backspace = true;
+					if(!this.textInputNode.value.length){
+						this.setAllValues("", "");
+						this.hideResultList();
+						doSearch = false;
+					}
+					break;
+				case k.KEY_RIGHT_ARROW: // fall through
+				case k.KEY_LEFT_ARROW: // fall through
+				case k.KEY_SHIFT:
+					doSearch = false;
+					break;
+				default:// non char keys (F1-F12 etc..)  shouldn't open list
+					if(evt.charCode==0){
+						doSearch = false;
+					}
+			}
+	
+			if(this.searchTimer){
+				clearTimeout(this.searchTimer);
+			}
+			if(doSearch){
+				// if we have gotten this far we dont want to keep our highlight
+				this.blurOptionNode();
+	
+				// need to wait a tad before start search so that the event bubbles through DOM and we have value visible
+				this.searchTimer = setTimeout(dojo.lang.hitch(this, this.startSearchFromInput), this.searchDelay);
+			}
+		},
+	
+		onKeyDown: function(evt){
+			// IE needs to stop keyDown others need to stop keyPress
+			if(!document.createEvent){ // only IE
+				this._handleKeyEvents(evt);
+			}
+			// FIXME: What about ESC ??
+		},
+	
+		onKeyPress: function(evt){
+			if(document.createEvent){ // never IE
+				this._handleKeyEvents(evt);
+			}
+		},
+	
+		onKeyUp: function(evt){
+			this.setValue(this.textInputNode.value);
+		},
+	
+		setSelectedValue: function(value){
+			// FIXME, not sure what to do here!
+			this.comboBoxSelectionValue.value = value;
+		},
+
+		setAllValues: function(value1, value2){
+			this.setValue(value1);
+			this.setSelectedValue(value2);
+		},
+	
+		// opera, khtml, safari doesnt support node.scrollIntoView(), workaround
+		scrollIntoView: function(){
+			var node = this._highlighted_option;
+			var parent = this.optionsListNode;
+			// don't rely on that node.scrollIntoView works just because the function is there
+			// it doesnt work in Konqueror or Opera even though the function is there and probably
+			// not safari either
+			// dont like browser sniffs implementations but sometimes you have to use it
+			if(dojo.render.html.ie || dojo.render.html.mozilla){
+				// IE, mozilla
+				node.scrollIntoView(false);	
+			}else{
+				var parentBottom = parent.scrollTop + dojo.style.getInnerHeight(parent);
+				var nodeBottom = node.offsetTop + dojo.style.getOuterHeight(node);
+				if(parentBottom < nodeBottom){
+					parent.scrollTop += (nodeBottom - parentBottom);
+				}else if(parent.scrollTop > node.offsetTop){
+					parent.scrollTop -= (parent.scrollTop - node.offsetTop);
+				}
+			}
+		},
+	
+		// does the actual highlight
+		focusOptionNode: function(node){
+			if(this._highlighted_option != node){
+				this.blurOptionNode();
+				this._highlighted_option = node;
+				dojo.html.addClass(this._highlighted_option, "dojoComboBoxItemHighlight");
+			}
+		},
+	
+		// removes highlight on highlighted
+		blurOptionNode: function(){
+			if(this._highlighted_option){
+				dojo.html.removeClass(this._highlighted_option, "dojoComboBoxItemHighlight");
+				this._highlighted_option = null;
+			}
+		},
+	
+		highlightNextOption: function(){
+			if((!this._highlighted_option) || !this._highlighted_option.parentNode){
+				this.focusOptionNode(this.optionsListNode.firstChild);
+			}else if(this._highlighted_option.nextSibling){
+				this.focusOptionNode(this._highlighted_option.nextSibling);
+			}
+			this.scrollIntoView();
+		},
+	
+		highlightPrevOption: function(){
+			if(this._highlighted_option && this._highlighted_option.previousSibling){
+				this.focusOptionNode(this._highlighted_option.previousSibling);
+			}else{
+				this._highlighted_option = null;
+				this.hideResultList();
+				return;
+			}
+			this.scrollIntoView();
+		},
+	
+		itemMouseOver: function(evt){
+			this.focusOptionNode(evt.target);
+			dojo.html.addClass(this._highlighted_option, "dojoComboBoxItemHighlight");
+		},
+	
+		itemMouseOut: function(evt){
+			this.blurOptionNode();
+		},
+	
+		fillInTemplate: function(args, frag){
+			// FIXME: need to get/assign DOM node names for form participation here.
+			this.comboBoxValue.name = this.name;
+			this.comboBoxSelectionValue.name = this.name+"_selected";
+	
+			var source = this.getFragNodeRef(frag);
+			dojo.html.copyStyle(this.domNode, source);
+	
+			var dpClass;
+			if(this.mode == "remote"){
+				dpClass = dojo.widget.incrementalComboBoxDataProvider;
+			}else if(typeof this.dataProviderClass == "string"){
+				dpClass = dojo.evalObjPath(this.dataProviderClass)
+			}else{
+				dpClass = this.dataProviderClass;
+			}
+			this.dataProvider = new dpClass();
+			this.dataProvider.init(this, this.getFragNodeRef(frag));
+	
+			// Prevent IE bleed-through problem
+			this.optionsIframe = new dojo.html.BackgroundIframe(this.optionsListWrapper);
+			this.optionsIframe.size([0,0,0,0]);
+		},
+	
+	
+		focus: function(){
+			// summary
+			//	set focus to input node from code
+			this.tryFocus();
+		},
+	
+		openResultList: function(results){
+			this.clearResultList();
+			if(!results.length){
+				this.hideResultList();
+			}
+	
+			if(	(this.autoComplete)&&
+				(results.length)&&
+				(!this._prev_key_backspace)&&
+				(this.textInputNode.value.length > 0)){
+				var cpos = this.getCaretPos(this.textInputNode);
+				// only try to extend if we added the last character at the end of the input
+				if((cpos+1) > this.textInputNode.value.length){
+					// only add to input node as we would overwrite Capitalisation of chars
+					this.textInputNode.value += results[0][0].substr(cpos);
+					// build a new range that has the distance from the earlier
+					// caret position to the end of the first string selected
+					this.setSelectedRange(this.textInputNode, cpos, this.textInputNode.value.length);
+				}
+			}
+	
+			var even = true;
+			while(results.length){
+				var tr = results.shift();
+				if(tr){
+					var td = document.createElement("div");
+					td.appendChild(document.createTextNode(tr[0]));
+					td.setAttribute("resultName", tr[0]);
+					td.setAttribute("resultValue", tr[1]);
+					td.className = "dojoComboBoxItem "+((even) ? "dojoComboBoxItemEven" : "dojoComboBoxItemOdd");
+					even = (!even);
+					this.optionsListNode.appendChild(td);
+					dojo.event.connect(td, "onmouseover", this, "itemMouseOver");
+					dojo.event.connect(td, "onmouseout", this, "itemMouseOut");
+				}
+			}
+	
+			// show our list (only if we have content, else nothing)
+			this.showResultList();
+		},
+	
+		onFocusInput: function(){
+			this._hasFocus = true;
+		},
+	
+		onBlurInput: function(){
+			this._hasFocus = false;
+			this._handleBlurTimer(true, 500);
+		},
+	
+		// collect all blur timers issues here
+		_handleBlurTimer: function(/*Boolean*/clear, /*Number*/ millisec){
+			if(this.blurTimer && (clear || millisec)){
+				clearTimeout(this.blurTimer);
+			}
+			if(millisec){ // we ignore that zero is false and never sets as that never happens in this widget
+				this.blurTimer = dojo.lang.setTimeout(this, "checkBlurred", millisec);
+			}
+		},
+	
+		// these 2 are needed in IE and Safari as inputTextNode loses focus when scrolling optionslist
+		_onMouseOver: function(evt){
+			if(!this._mouseover_list){
+				this._handleBlurTimer(true, 0);
+				this._mouseover_list = true;
+			}
+		},
+	
+		_onMouseOut:function(evt){
+			var relTarget = evt.relatedTarget;
+			if(!relTarget || relTarget.parentNode!=this.optionsListNode){
+				this._mouseover_list = false;
+				this._handleBlurTimer(true, 100);
+				this.tryFocus();
+			}
+		},
+	
+		_isInputEqualToResult: function(result){
+			input = this.textInputNode.value;
+			if(!this.dataProvider.caseSensitive){
+				input = input.toLowerCase();
+				result = result.toLowerCase();
+			}
+			return (input == result);
+		},
+
+		_isValidOption: function(){
+			tgt = dojo.dom.firstElement(this.optionsListNode);
+			isValidOption = false;
+			while(!isValidOption && tgt){
+				if(this._isInputEqualToResult(tgt.getAttribute("resultName"))){
+					isValidOption = true;
+				}else{
+					tgt = dojo.dom.nextElement(tgt);
+				}
+			}
+			return isValidOption;
+		},
+
+		checkBlurred: function(){
+			if(!this._hasFocus && !this._mouseover_list){
+				this.hideResultList();
+				// clear the list if the user empties field and moves away.
+				if(!this.textInputNode.value.length){
+					this.setAllValues("", "");
+					return;
+				}
+				
+				isValidOption = this._isValidOption();
+				// enforce selection from option list
+				if(this.forceValidOption && !isValidOption){
+					this.setAllValues("", "");
+					return;
+				}
+				if(!isValidOption){// clear
+					this.setSelectedValue("");
+				}
+			}
+		},
+	
+		sizeBackgroundIframe: function(){
+			var w = dojo.style.getOuterWidth(this.optionsListNode);
+			var h = dojo.style.getOuterHeight(this.optionsListNode);
+			if( w==0 || h==0 ){
+				// need more time to calculate size
+				dojo.lang.setTimeout(this, "sizeBackgroundIframe", 100);
+				return;
+			}
+			if(this._result_list_open){
+				this.optionsIframe.size([0,0,w,h]);
+			}
+		},
+	
+		selectOption: function(evt){
+			var tgt = null;
+			if(!evt){
+				evt = { target: this._highlighted_option };
+			}
+	
+			if(!dojo.dom.isDescendantOf(evt.target, this.optionsListNode)){
+				// handle autocompletion where the the user has hit ENTER or TAB
+	
+				// if the input is empty do nothing
+				if(!this.textInputNode.value.length){
+					return;
+				}
+				tgt = dojo.dom.firstElement(this.optionsListNode);
+	
+				// user has input value not in option list
+				if(!tgt || !this._isInputEqualToResult(tgt.getAttribute("resultName"))){
+					return;
+				}
+				// otherwise the user has accepted the autocompleted value
+			}else{
+				tgt = evt.target; 
+			}
+	
+			while((tgt.nodeType!=1)||(!tgt.getAttribute("resultName"))){
+				tgt = tgt.parentNode;
+				if(tgt === document.body){
+					return false;
+				}
+			}
+	
+			this.textInputNode.value = tgt.getAttribute("resultName");
+			this.selectedResult = [tgt.getAttribute("resultName"), tgt.getAttribute("resultValue")];
+			this.setAllValues(tgt.getAttribute("resultName"), tgt.getAttribute("resultValue"));
+			if(!evt.noHide){
+				this.hideResultList();
+				this.setSelectedRange(this.textInputNode, 0, null);
+			}
+			this.tryFocus();
+		},
+	
+		clearResultList: function(){
+			var oln = this.optionsListNode;
+			while(oln.firstChild){
+				dojo.event.disconnect(oln.firstChild, "onmouseover", this, "itemMouseOver");
+				dojo.event.disconnect(oln.firstChild, "onmouseout", this, "itemMouseOut");
+				oln.removeChild(oln.firstChild);
+			}
+		},
+	
+		hideResultList: function(){
+			if(this._result_list_open){
+				this._result_list_open = false;
+				this.optionsIframe.size([0,0,0,0]);
+				dojo.lfx.fadeHide(this.optionsListNode, this.fadeTime).play();
+			}
+		},
+	
+		showResultList: function(){
+			// Our dear friend IE doesnt take max-height so we need to calculate that on our own every time
+			var childs = this.optionsListNode.childNodes;
+			if(childs.length){
+				var visibleCount = this.maxListLength;
+				if(childs.length < visibleCount){
+					visibleCount = childs.length;
+				}
+	
+				with(this.optionsListNode.style){
+					display = "";
+					height = ((visibleCount) ? (dojo.style.getOuterHeight(childs[0]) * visibleCount) : 0)+"px";
+					width = dojo.html.getOuterWidth(this.cbTableNode)-2+"px";
+				}
+				// only fadein once (flicker)
+				if(!this._result_list_open){
+					dojo.html.setOpacity(this.optionsListNode, 0);
+					dojo.lfx.fadeIn(this.optionsListNode, this.fadeTime).play();
+				}
+				
+				// prevent IE bleed through
+				this._iframeTimer = dojo.lang.setTimeout(this, "sizeBackgroundIframe", 200);
+				this._result_list_open = true;
+			}else{
+				this.hideResultList();
+			}
+		},
+	
+		handleArrowClick: function(){
+			this._handleBlurTimer(true, 0);
+			this.tryFocus();
+			if(this._result_list_open){
+				this.hideResultList();
+			}else{
+				this.startSearchFromInput();
+			}
+		},
+	
+		tryFocus: function(){
+			try {
+				this.textInputNode.focus();
+			} catch (e) {
+				// element isn't focusable if disabled, or not visible etc - not easy to test for.
+	 		};
+		},
+		
+		startSearchFromInput: function(){
+			this.startSearch(this.textInputNode.value);
+		},
+	
+		postCreate: function(){
+			dojo.event.connect(this, "startSearch", this.dataProvider, "startSearch");
+			dojo.event.connect(this.dataProvider, "provideSearchResults", this, "openResultList");
+			dojo.event.connect(this.textInputNode, "onblur", this, "onBlurInput");
+			dojo.event.connect(this.textInputNode, "onfocus", this, "onFocusInput");
+	
+			var s = dojo.widget.html.stabile.getState(this.widgetId);
+			if (s) {
+				this.setState(s);
+			}
+		}
+	}
+);

Added: tags/parley-0.53/root/static/magic/src/widget/html/ContentPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/ContentPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/ContentPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,566 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.ContentPane");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.io.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.ContentPane");
+dojo.require("dojo.string");
+dojo.require("dojo.string.extras");
+dojo.require("dojo.style");
+
+dojo.widget.html.ContentPane = function(){
+	this._onLoadStack = [];
+	this._onUnLoadStack = [];
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.ContentPane, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.ContentPane, {
+	widgetType: "ContentPane",
+	isContainer: true,
+
+	// remote loading options
+	adjustPaths: true,
+	href: "",
+	extractContent: true,
+	parseContent: true,
+	cacheContent: true,
+	preload: false,			// force load of data even if pane is hidden
+	refreshOnShow: false,
+	handler: "",			// generate pane content from a java function
+	executeScripts: false,	// if true scripts in content will be evaled after content is set and parsed
+	scriptScope: null,		// scopeContainer for downloaded scripts
+
+		// If the user want a global in the remote script he/she just omitts the var
+		// examples:
+		//--------------------------
+		// these gets collected by scriptScope and is reached by dojo.widget.byId('..').scriptScope.myCustomproperty
+		//	this.myString = "dojo is a great javascript toolkit!";
+		//
+		//	this.alertMyString = function(){
+		//		alert(myString);
+		//	}
+		// -------------------------
+		// these go into the global namespace (window) notice lack of var, equiv to window.myString
+		//	myString = "dojo is a javascript toolkit!";
+		//
+		//	alertMyString = function(){
+		//		alert(myString);
+		// }
+
+
+	// private
+	_remoteStyles: null,	// array of stylenodes inserted to document head
+							// by remote content, used when we clean up for new content
+
+	_callOnUnLoad: false,		// used by setContent and _handleDefults, makes sure onUnLoad is only called once
+
+	postCreate: function(args, frag, parentComp){
+		if ( this.handler != "" ){
+			this.setHandler(this.handler);
+		}
+		if(this.isShowing()||this.preload){ this.loadContents(); }
+	},
+
+	show: function(){
+		// if refreshOnShow is true, reload the contents every time; otherwise, load only the first time
+		if(this.refreshOnShow){
+			this.refresh();
+		}else{
+			this.loadContents();
+		}
+		dojo.widget.html.ContentPane.superclass.show.call(this);
+	},
+
+	refresh: function(){
+		this.isLoaded=false;
+		this.loadContents();
+	},
+
+	loadContents: function() {
+		if ( this.isLoaded ){
+			return;
+		}
+		this.isLoaded=true;
+		if ( dojo.lang.isFunction(this.handler)) {
+			this._runHandler();
+		} else if ( this.href != "" ) {
+			this._downloadExternalContent(this.href, this.cacheContent);
+		}
+	},
+
+	
+	setUrl: function(/*String*/ url) {
+		// summary:
+		// 	Reset the (external defined) content of this pane and replace with new url
+		this.href = url;
+		this.isLoaded = false;
+		if ( this.preload || this.isShowing() ){
+			this.loadContents();
+		}
+	},
+
+	_downloadExternalContent: function(url, useCache) {
+		this._handleDefaults("Loading...", "onDownloadStart");
+		var self = this;
+		dojo.io.bind({
+			url: url,
+			useCache: useCache,
+			preventCache: !useCache,
+			mimetype: "text/html",
+			handler: function(type, data, e) {
+				if(type == "load") {
+					self.onDownloadEnd.call(self, url, data);
+				} else {
+					// works best when from a live server instead of from file system 
+					self._handleDefaults.call(self, "Error loading '" + url + "' (" + e.status + " "+  e.statusText + ")", "onDownloadError");
+					self.onLoad();
+				}
+			}
+		});
+	},
+
+	// called when setContent is finished
+	onLoad: function(e){
+		this._runStack("_onLoadStack");
+	},
+
+	// called before old content is cleared
+	onUnLoad: function(e){
+		this._runStack("_onUnLoadStack");
+		this.scriptScope = null;
+	},
+
+	_runStack: function(stName){
+		var st = this[stName]; var err = "";
+		for(var i = 0;i < st.length; i++){
+			try{
+				st[i].call(this.scriptScope);
+			}catch(e){ 
+				err += "\n"+st[i]+" failed: "+e.description;
+			}
+		}
+		this[stName] = [];
+
+		if(err.length){
+			var name = (stName== "_onLoadStack") ? "addOnLoad" : "addOnUnLoad";
+			this._handleDefaults(name+" failure\n "+err, "onExecError", true);
+		}
+	},
+
+	addOnLoad: function(obj, func){
+		// summary
+		// 	same as to dojo.addOnLoad but does not take "function_name" as a string
+		this._pushOnStack(this._onLoadStack, obj, func);
+	},
+
+	addOnUnLoad: function(obj, func){
+		// summary
+		// 	same as to dojo.addUnOnLoad but does not take "function_name" as a string
+		this._pushOnStack(this._onUnLoadStack, obj, func);
+	},
+
+	_pushOnStack: function(stack, obj, func){
+		if(typeof func == 'undefined') {
+			stack.push(obj);
+		}else{
+			stack.push(function(){ obj[func](); });
+		}
+	},
+
+	destroy: function(){
+		// make sure we call onUnLoad
+		this.onUnLoad();
+		dojo.widget.html.ContentPane.superclass.destroy.call(this);
+	},
+
+	// called when content script eval error or Java error occurs, preventDefault-able
+	onExecError: function(e){ /*stub*/ },
+
+	// called on DOM faults, require fault etc in content, preventDefault-able
+	onContentError: function(e){ /*stub*/ },
+
+	// called when download error occurs, preventDefault-able
+	onDownloadError: function(e){ /*stub*/ },
+
+	// called before download starts, preventDefault-able
+	onDownloadStart: function(e){ /*stub*/ },
+
+	// called when download is finished
+	onDownloadEnd: function(url, data){
+		data = this.splitAndFixPaths(data, url);
+		this.setContent(data);
+	},
+
+	// usefull if user wants to prevent default behaviour ie: _setContent("Error...")
+	_handleDefaults: function(e, handler, useAlert){
+		if(!handler){ handler = "onContentError"; }
+		if(dojo.lang.isString(e)){
+			e = {
+				"text": e,
+				"toString": function(){ return this.text; }
+			}
+		}
+		if(typeof e.returnValue != "boolean"){
+			e.returnValue = true; 
+		}
+		if(typeof e.preventDefault != "function"){
+			e.preventDefault = function(){
+				this.returnValue = false;
+			}
+		}
+		// call our handler
+		this[handler](e);
+		if(e.returnValue){
+			if(useAlert){
+				alert(e.toString());
+			}else{
+				if(this._callOnUnLoad){
+					this.onUnLoad(); // makes sure scripts can clean up after themselves, before we setContent
+				}
+				this._callOnUnLoad = false; // makes sure we dont try to call onUnLoad again on this event,
+											// ie onUnLoad before 'Loading...' but not before clearing 'Loading...'
+				this._setContent(e.toString());
+			}
+		}
+	},
+
+	
+	splitAndFixPaths: function(/*String*/s, /*dojo.uri.Uri?*/url){
+		// summary:
+		// 	fixes all remote paths in (hopefully) all cases for example images, remote scripts, links etc.
+		// 	splits up content in different pieces, scripts, title, style, link and whats left becomes .xml
+
+		if(!url) { url = "./"; } // point to this page if not set
+		if(!s) { return ""; }
+
+		// fix up paths in data
+		var titles = []; var scripts = []; var linkStyles = [];
+		var styles = []; var remoteScripts = []; var requires = [];
+
+		// khtml is much more picky about dom faults, you can't for example attach a style node under body of document
+		// must go into head, as does a title node, so we need to cut out those tags
+		// cut out title tags
+		var match = [];
+		while(match){
+			match = s.match(/<title[^>]*>([\s\S]*?)<\/title>/i); // can't match with dot as that 
+			if(!match){ break;}					//doesnt match newline in js
+			titles.push(match[1]);
+			s = s.replace(/<title[^>]*>[\s\S]*?<\/title>/i, "");
+		}
+
+		// cut out <style> url(...) </style>, as that bails out in khtml
+		var match = [];
+		while(match){
+			match = s.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
+			if(!match){ break; }
+			styles.push(dojo.style.fixPathsInCssText(match[1], url));
+			s = s.replace(/<style[^>]*?>[\s\S]*?<\/style>/i, "");
+		}
+
+		// attributepaths one tag can have multiple paths example:
+		// <input src="..." style="url(..)"/> or <a style="url(..)" href="..">
+		// strip out the tag and run fix on that.
+		// this guarantees that we won't run replace another tag's attribute + it was easier do
+		var pos = 0; var pos2 = 0; var stop = 0 ;var str = ""; var fixedPath = "";
+		var attr = []; var fix = ""; var tagFix = ""; var tag = ""; var regex = ""; 
+		while(pos>-1){
+			pos = s.search(/<[a-z][a-z0-9]*[^>]*\s(?:(?:src|href|style)=[^>])+[^>]*>/i);
+			if(pos==-1){ break; }
+			str += s.substring(0, pos);
+			s = s.substring(pos, s.length);
+			tag = s.match(/^<[a-z][a-z0-9]*[^>]*>/i)[0];
+			s = s.substring(tag.length, s.length);
+
+			// loop through attributes
+			pos2 = 0; tagFix = ""; fix = ""; regex = ""; var regexlen = 0;
+			while(pos2!=-1){
+				// slices up before next attribute check, values from previous loop
+				tagFix += tag.substring(0, pos2) + fix;
+				tag = tag.substring(pos2+regexlen, tag.length);
+
+				// fix next attribute or bail out when done
+				// hopefully this charclass covers most urls
+				attr = tag.match(/ (src|href|style)=(['"]?)([\w()\[\]\/.,\\'"-:;#=&?\s@]+?)\2/i);
+				if(!attr){ break; }
+
+				switch(attr[1].toLowerCase()){
+					case "src":// falltrough
+					case "href":
+						// this hopefully covers most common protocols
+						if(attr[3].search(/^(?:[#]|(?:(?:https?|ftps?|file|javascript|mailto|news):))/)==-1){
+							fixedPath = (new dojo.uri.Uri(url, attr[3]).toString());
+						} else {
+							pos2 = pos2 + attr[3].length;
+							continue;
+						}
+						break;
+					case "style":// style
+						fixedPath = dojo.style.fixPathsInCssText(attr[3], url);
+						break;
+					default:
+						pos2 = pos2 + attr[3].length;
+						continue;
+				}
+
+				regex = " " + attr[1] + "=" + attr[2] + attr[3] + attr[2];
+				regexlen = regex.length;
+				fix = " " + attr[1] + "=" + attr[2] + fixedPath + attr[2];
+				pos2 = tag.search(new RegExp(dojo.string.escapeRegExp(regex)));
+			}
+			str += tagFix + tag;
+			pos = 0; // reset for next mainloop
+		}
+		s = str+s;
+
+		// cut out all script tags, push them into scripts array
+		match = []; var tmp = [];
+		while(match){
+			match = s.match(/<script([^>]*)>([\s\S]*?)<\/script>/i);
+			if(!match){ break; }
+			if(match[1]){
+				attr = match[1].match(/src=(['"]?)([^"']*)\1/i);
+				if(attr){
+					// remove a dojo.js or dojo.js.uncompressed.js from remoteScripts
+					// we declare all files with dojo.js as bad, regardless of folder
+					var tmp = attr[2].search(/.*(\bdojo\b(?:\.uncompressed)?\.js)$/);
+					if(tmp > -1){
+						dojo.debug("Security note! inhibit:"+attr[2]+" from  beeing loaded again.");
+					}else{
+						remoteScripts.push(attr[2]);
+					}
+				}
+			}
+			if(match[2]){
+				// strip out all djConfig variables from script tags nodeValue
+				// this is ABSOLUTLY needed as reinitialize djConfig after dojo is initialised
+				// makes a dissaster greater than Titanic, update remove writeIncludes() to
+				var sc = match[2].replace(/(?:var )?\bdjConfig\b(?:[\s]*=[\s]*\{[^}]+\}|\.[\w]*[\s]*=[\s]*[^;\n]*)?;?|dojo\.hostenv\.writeIncludes\(\s*\);?/g, "");
+				if(!sc){ continue; }
+
+				// cut out all dojo.require (...) calls, if we have execute 
+				// scripts false widgets dont get there require calls
+				// does suck out possible widgetpackage registration as well
+				tmp = [];
+				while(tmp && requires.length<100){
+					tmp = sc.match(/dojo\.(?:(?:require(?:After)?(?:If)?)|(?:widget\.(?:manager\.)?registerWidgetPackage)|(?:(?:hostenv\.)?setModulePrefix))\((['"]).*?\1\)\s*;?/);
+					if(!tmp){ break;}
+					requires.push(tmp[0]);
+					sc = sc.replace(tmp[0], "");
+				}
+				scripts.push(sc);
+			}
+			s = s.replace(/<script[^>]*>[\s\S]*?<\/script>/i, "");
+		}
+
+		// scan for scriptScope in html eventHandlers and replace with link to this pane
+		if(this.executeScripts){
+			var regex = /(<[a-zA-Z][a-zA-Z0-9]*\s[^>]*\S=(['"])[^>]*[^\.\]])scriptScope([^>]*>)/;
+			var pos = 0;var str = "";match = [];var cit = "";
+			while(pos > -1){
+				pos = s.search(regex);
+				if(pos > -1){
+					cit = ((RegExp.$2=="'") ? '"': "'");
+					str += s.substring(0, pos);
+					s = s.substr(pos).replace(regex, "$1dojo.widget.byId("+ cit + this.widgetId + cit + ").scriptScope$3");
+				}
+			}
+			s = str + s;
+		}
+
+		// cut out all <link rel="stylesheet" href="..">
+		match = [];
+		while(match){
+			match = s.match(/<link ([^>]*rel=['"]?stylesheet['"]?[^>]*)>/i);
+			if(!match){ break; }
+			attr = match[1].match(/href=(['"]?)([^'">]*)\1/i);
+			if(attr){
+				linkStyles.push(attr[2]);
+			}
+			s = s.replace(new RegExp(match[0]), "");
+		}
+
+		return {"xml": s, // Object
+			"styles": styles,
+			"linkStyles": linkStyles,
+			"titles": titles,
+			"requires": 	requires,
+			"scripts": scripts,
+			"remoteScripts": remoteScripts,
+			"url": url};
+	},
+
+	
+	_setContent: function(/*String*/ xml){
+		// summary: 
+		//		private internal function without path regExpCheck and no onLoad calls aftervards
+
+		// remove old children from current content
+		this.destroyChildren();
+
+		// remove old stylenodes from HEAD
+		if(this._remoteStyles){
+			for(var i = 0; i < this._remoteStyles.length; i++){
+				if(this._remoteStyles[i] && this._remoteStyles.parentNode){
+					this._remoteStyles[i].parentNode.removeChild(this._remoteStyles[i]);
+				}
+			}
+			this._remoteStyles = null;
+		}
+
+		var node = this.containerNode || this.domNode;
+		try{
+			if(typeof xml != "string"){
+				node.innerHTML = "";
+				node.appendChild(xml);
+			}else{
+				node.innerHTML = xml;
+			}
+		} catch(e){
+			e = "Could'nt load content:"+e;
+			this._handleDefaults(e, "onContentError");
+		}
+	},
+
+	setContent: function(/*String*/ data){
+		// summary:
+		// 	Destroys old content and setting new content, and possibly initialize any widgets within 'data'
+
+		if(this._callOnUnLoad){ // this tells a remote script clean up after itself
+			this.onUnLoad();
+		}
+		this._callOnUnLoad = true;
+
+		if(!data || dojo.dom.isNode(data)){
+			// if we do a clean using setContent(""); or setContent(#node) bypass all parseing, extractContent etc
+			this._setContent(data);
+			this.onResized();
+			this.onLoad();
+		}else{
+			// need to run splitAndFixPaths? ie. manually setting content
+			 if((!data.xml)&&(this.adjustPaths)){
+				data = this.splitAndFixPaths(data);
+			}
+			if(this.extractContent) {
+				var matches = data.xml.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
+				if(matches) { data.xml = matches[1]; }
+			}
+			// insert styleNodes, from <style>....
+			for(var i = 0; i < data.styles.length; i++){
+				if(i==0){ 
+					this._remoteStyles = []; 
+				}
+				this._remoteStyles.push(dojo.style.insertCssText(data.styles[i]));
+			}
+			// insert styleNodes, from <link href="...">
+			for(var i = 0; i < data.linkStyles.length; i++){
+				if(i==0){ 
+					this._remoteStyles = []; 
+				}
+				this._remoteStyles.push(dojo.style.insertCssFile(data.linkStyles[i]));
+			}
+			this._setContent(data.xml);
+
+			if(this.parseContent){
+				for(var i = 0; i < data.requires.length; i++){
+					try{ 
+						eval(data.requires[i]);
+					} catch(e){
+						this._handleDefaults(e, "onContentError", true);
+					}
+				}
+			}
+			// need to allow async load, Xdomain uses it
+			// is inline function because we cant send args to addOnLoad function
+			var _self = this;
+			function asyncParse(){
+				if(_self.executeScripts){
+					_self._executeScripts(data);
+				}
+
+				if(_self.parseContent){
+					var node = _self.containerNode || _self.domNode;
+					var parser = new dojo.xml.Parse();
+					var frag = parser.parseElement(node, null, true);
+					// createSubComponents not createComponents because frag has already been created
+					dojo.widget.getParser().createSubComponents(frag, _self);
+				}
+
+				_self.onResized();
+				_self.onLoad();
+			}
+			// try as long as possible to make setContent sync call
+			if(dojo.hostenv.isXDomain && data.requires.length){
+				dojo.addOnLoad(asyncParse);
+			}else{
+				asyncParse();
+			}
+		}
+	},
+
+	// Generate pane content from given java function
+	setHandler: function(handler) {
+		var fcn = dojo.lang.isFunction(handler) ? handler : window[handler];
+		if(!dojo.lang.isFunction(fcn)) {
+			// FIXME: needs testing! somebody with java knowledge needs to try this
+			this._handleDefaults("Unable to set handler, '" + handler + "' not a function.", "onExecError", true);
+			return;
+		}
+		this.handler = function() {
+			return fcn.apply(this, arguments);
+		}
+	},
+
+	_runHandler: function() {
+		if(dojo.lang.isFunction(this.handler)) {
+			this.handler(this, this.domNode);
+			return false;
+		}
+		return true;
+	},
+
+	_executeScripts: function(data) {
+		// do remoteScripts first
+		var self = this;
+		for(var i = 0; i < data.remoteScripts.length; i++){
+			dojo.io.bind({
+				"url": data.remoteScripts[i],
+				"useCash":	this.cacheContent,
+				"load":     function(type, scriptStr){
+						dojo.lang.hitch(self, data.scripts.push(scriptStr));
+				},
+				"error":    function(type, error){
+						self._handleDefaults.call(self, type + " downloading remote script", "onExecError", true);
+				},
+				"mimetype": "text/plain",
+				"sync":     true
+			});
+		}
+
+		var scripts = "";
+		for(var i = 0; i < data.scripts.length; i++){
+			scripts += data.scripts[i];
+		}
+
+		try{
+			// initialize a new anonymous container for our script, dont make it part of this widgets scope chain
+			// instead send in a variable that points to this widget, usefull to connect events to onLoad, onUnLoad etc..
+			this.scriptScope = null;
+			this.scriptScope = new (new Function('_container_', scripts+'; return this;'))(self);
+		}catch(e){
+			this._handleDefaults("Error running scripts from content:\n"+e, "onExecError", true);
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:ContentPane");

Added: tags/parley-0.53/root/static/magic/src/widget/html/ContextMenu.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/ContextMenu.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/ContextMenu.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,166 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.ContextMenu");
+dojo.require("dojo.html");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.ContextMenu");
+dojo.require("dojo.lang");
+
+dojo.widget.html.ContextMenu = function(){
+	dojo.widget.ContextMenu.call(this);
+	dojo.widget.HtmlWidget.call(this);
+
+	this.isShowing = 0;
+	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlContextMenuTemplate.html");
+	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/Menu.css");
+
+	this.targetNodeIds = []; // fill this with nodeIds upon widget creation and it only responds to those nodes
+
+	// default event detection method 
+	var eventType = "oncontextmenu"; 
+
+	var doc = document.documentElement  || document.body; 
+
+	var _blockHide = false; 
+
+	this.fillInTemplate = function(args, frag){
+
+		var func = "onOpen";
+		var attached = false;
+
+		// connect with rightclick if oncontextmenu is not around
+		// NOTE: It would be very nice to have a dojo.event.browser.supportsEvent here
+		// NOTE: Opera does not have rightclick events, it is listed here only because
+		//     it bails out when connecting with oncontextmenu event
+
+		if((dojo.render.html.khtml && !dojo.render.html.safari) || (dojo.render.html.opera)){
+			eventType = "onmousedown";
+			func = "_checkRightClick";
+		}
+
+		// attach event listeners to our selected nodes
+		for(var i=0; i<this.targetNodeIds.length; i++){
+			var node = document.getElementById(this.targetNodeIds[i]);
+			if(node){
+				dojo.event.connect(node, eventType, this, func);
+				attached = true;
+			}else{
+				// remove this nodeId
+				dojo.debug("Couldent find "+this.targetNodeIds[i]+", cant do ContextMenu on this node");
+				this.targetNodeIds.splice(i,1);
+			}
+		}
+
+		// if we got attached to a node, hide on all non node contextevents
+		if(attached){ func = "_canHide"; }
+
+		dojo.event.connect(doc, eventType, this, func);
+	}
+
+	this.onOpen = function(evt){
+		// if (this.isShowing){ this.onHide(evt); } // propably not needed
+		this.isShowing = 1;
+
+		// if I do this, I cant preventDefault in khtml
+		//evt = dojo.event.browser.fixEvent(evt);
+ 
+		// stop default contextmenu, needed in khtml
+		if (evt.preventDefault){ evt.preventDefault(); }
+
+		// need to light up this one before we check width and height
+		this.domNode.style.left = "-9999px";
+		this.domNode.style.top  = "-9999px";
+		this.domNode.style.display = "block";
+
+		// calculate if menu is going to apear within window
+		// or if its partially out of visable area
+		with(dojo.html){
+
+			var menuW = getInnerWidth(this.domNode);
+			var menuH = getInnerHeight(this.domNode);
+
+			var viewport = getViewportSize();
+			var scrolloffset = getScrollOffset();
+		}
+
+		var minX = viewport[0];
+		var minY = viewport[1];
+
+		var maxX = (viewport[0] + scrolloffset[0]) - menuW;
+		var maxY = (viewport[1] + scrolloffset[1]) - menuH;
+
+		var posX = evt.clientX + scrolloffset[0];
+		var posY = evt.clientY + scrolloffset[1];
+
+		if (posX > maxX){ posX = posX - menuW; }
+		if (posY > maxY){ posY = posY - menuH; }
+
+		this.domNode.style.left = posX + "px";
+		this.domNode.style.top = posY + "px";
+
+
+		// block the onclick that follows this particular right click
+		// not if the eventtrigger is documentElement and always when
+		// we use onmousedown hack
+		_blockHide = (evt.currentTarget!=doc || eventType=='onmousedown');
+
+		//return false; // we propably doesnt need to return false as we dont stop the event as we did before
+	}
+
+	/*
+	* _canHide is meant to block the onHide call that follows the event that triggered
+	* onOpen. This is (hopefully) faster that event.connect and event.disconnect every
+	* time the code executes and it makes connecting with onmousedown event possible
+	* and we dont have to stop the event from bubbling further.
+	*
+	* this code is moved into a separete function because it makes it possible for the
+	* user to connect to a onHide event, if anyone would like that.
+	*/
+
+	this._canHide = function(evt){
+		// block the onclick that follows the same event that turn on contextmenu
+		if(_blockHide){
+			// the onclick check is needed to prevent displaying multiple
+			// menus when we have 2 or more contextmenus loaded and are using
+			// the onmousedown hack
+			if(evt.type=='click' || eventType=='oncontextmenu'){
+				_blockHide = false;
+				return;
+			}else{
+				return;
+			}
+		}
+
+		this.onHide(evt);
+	}
+	
+	this.onHide = function(evt){
+		// FIXME: use whatever we use to do more general style setting?
+		this.domNode.style.display = "none";
+		//dojo.event.disconnect(doc, "onclick", this, "onHide");
+		this.isShowing = 0;
+	}
+
+	// callback for rightclicks, needed for browsers that doesnt implement oncontextmenu, konqueror and more? 
+	this._checkRightClick = function(evt){ 
+
+		// for some reason konq comes here even when we are not clicking on the attached nodes 
+		// added check for targetnode 
+		if (evt.button==2 && (this.targetNodeIds.length==0 || (evt.currentTarget.id!="" && dojo.lang.inArray(this.targetNodeIds, evt.currentTarget.id)))){
+
+			return this.onOpen(evt);
+		}
+	}
+
+	dojo.event.connect(doc, "onclick", this, "_canHide");
+}
+
+dojo.inherits(dojo.widget.html.ContextMenu, dojo.widget.HtmlWidget);

Added: tags/parley-0.53/root/static/magic/src/widget/html/DatePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/DatePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/DatePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,346 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.DatePicker");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.DatePicker");
+dojo.require("dojo.event.*");
+dojo.require("dojo.html");
+dojo.require("dojo.date");
+
+/*
+	Some assumptions:
+	- I'm planning on always showing 42 days at a time, and we can scroll by week,
+	not just by month or year
+	- To get a sense of what month to highlight, I basically initialize on the 
+	first Saturday of each month, since that will be either the first of two or 
+	the second of three months being partially displayed, and then I work forwards 
+	and backwards from that point.
+	Currently, I assume that dates are stored in the RFC 3339 format,
+	because I find it to be most human readable and easy to parse
+	http://www.faqs.org/rfcs/rfc3339.html: 		2005-06-30T08:05:00-07:00
+*/
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.DatePicker",
+	dojo.widget.HtmlWidget,
+	{
+		classConstructor: function() {
+			// mixin dojo.widget.DatePicker non-demoninational code
+			dojo.widget.DatePicker.call(this);
+			// today's date, JS Date object
+			this.today = "";
+			// selected date, JS Date object
+			this.date = "";
+			// rfc 3339 date
+			this.storedDate = "";
+			// date currently selected in the UI, stored in year, month, date in the format that will be actually displayed
+			this.currentDate = {};
+			// stored in year, month, date in the format that will be actually displayed
+			this.firstSaturday = {};
+		},
+		classNames: {
+			previous: "previousMonth",
+			current: "currentMonth",
+			next: "nextMonth",
+			currentDate: "currentDate",
+			selectedDate: "selectedItem"
+		},
+		templatePath:  dojo.uri.dojoUri("src/widget/templates/HtmlDatePicker.html"),
+		templateCssPath:  dojo.uri.dojoUri("src/widget/templates/HtmlDatePicker.css"),
+
+		fillInTemplate: function(){
+			dojo.widget.DatePicker.call(this);
+			this.initData();
+			this.initUI();
+		},
+		initData: function() {
+			this.today = new Date();
+			if(this.storedDate && (this.storedDate.split("-").length > 2)) {
+				this.date = dojo.widget.DatePicker.util.fromRfcDate(this.storedDate);
+			} else {
+				this.date = this.today;
+			}
+			// calendar math is simplified if time is set to 0
+			this.today.setHours(0);
+			this.date.setHours(0);
+			var month = this.date.getMonth();
+			var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(this.date.getMonth().toString(), this.date.getFullYear());
+			this.firstSaturday.year = tempSaturday.year;
+			this.firstSaturday.month = tempSaturday.month;
+			this.firstSaturday.date = tempSaturday.date;
+		},
+		
+		setDate: function(rfcDate) {
+			this.storedDate = rfcDate;
+		},
+		
+		initUI: function() {
+			this.selectedIsUsed = false;
+			this.currentIsUsed = false;
+			var currentClassName = "";
+			var previousDate = new Date();
+			var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName("td");
+			var currentCalendarNode;
+			// set hours of date such that there is no chance of rounding error due to 
+			// time change in local time zones
+			previousDate.setHours(8);
+			var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
+			
+			if(this.firstSaturday.date < 7) {
+				// this means there are days to show from the previous month
+				var dayInWeek = 6;
+				for (var i=this.firstSaturday.date; i>0; i--) {
+					currentCalendarNode = calendarNodes.item(dayInWeek);
+					currentCalendarNode.innerHTML = nextDate.getDate();
+					dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
+					dayInWeek--;
+					previousDate = nextDate;
+					nextDate = this.incrementDate(nextDate, false);
+				}
+				for(var i=dayInWeek; i>-1; i--) {
+					currentCalendarNode = calendarNodes.item(i);
+					currentCalendarNode.innerHTML = nextDate.getDate();
+					dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "previous"));
+					previousDate = nextDate;
+					nextDate = this.incrementDate(nextDate, false);				
+				}
+			} else {
+				nextDate.setDate(this.firstSaturday.date-6);
+				for(var i=0; i<7; i++) {
+					currentCalendarNode = calendarNodes.item(i);
+					currentCalendarNode.innerHTML = nextDate.getDate();
+					dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
+					previousDate = nextDate;
+					nextDate = this.incrementDate(nextDate, true);				
+				}
+			}
+			previousDate.setDate(this.firstSaturday.date);
+			previousDate.setMonth(this.firstSaturday.month);
+			previousDate.setFullYear(this.firstSaturday.year);
+			nextDate = this.incrementDate(previousDate, true);
+			var count = 7;
+			currentCalendarNode = calendarNodes.item(count);
+			while((nextDate.getMonth() == previousDate.getMonth()) && (count<42)) {
+				currentCalendarNode.innerHTML = nextDate.getDate();
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
+				currentCalendarNode = calendarNodes.item(++count);
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, true);
+			}
+			
+			while(count < 42) {
+				currentCalendarNode.innerHTML = nextDate.getDate();
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "next"));
+				currentCalendarNode = calendarNodes.item(++count);
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, true);
+			}
+			this.setMonthLabel(this.firstSaturday.month);
+			this.setYearLabels(this.firstSaturday.year);
+		},
+		
+		incrementDate: function(date, bool) {
+			// bool: true to increase, false to decrease
+			var time = date.getTime();
+			var increment = 1000 * 60 * 60 * 24;
+			time = (bool) ? (time + increment) : (time - increment);
+			var returnDate = new Date();
+			returnDate.setTime(time);
+			return returnDate;
+		},
+		
+		incrementWeek: function(evt) {
+			var date = this.firstSaturday.date;
+			var month = this.firstSaturday.month;
+			var year = this.firstSaturday.year;
+			switch(evt.target) {
+				case this.increaseWeekNode.getElementsByTagName("img").item(0): 
+				case this.increaseWeekNode:
+					date = date + 7;
+					if (date>this._daysIn(month,year)) {
+						date = date - this._daysIn(month,year);
+						if (month < 11) {
+							month++;	
+						} else {
+							month=0;
+							year++;
+						}
+					}
+					break;
+				case this.decreaseWeekNode.getElementsByTagName("img").item(0):
+				case this.decreaseWeekNode:
+					if (date > 7) {
+						date = date - 7;
+					} else {
+						var diff = 7 - date;
+						if (month > 0) {
+							month--;
+							date = this._daysIn(month,year) - diff;
+						}else {
+							year--;
+							month=11;
+							date = 31 - diff;
+						}
+					}
+					break;
+	
+			}
+	
+			this.firstSaturday.date=date;
+			this.firstSaturday.month=month;
+			this.firstSaturday.year=year;
+			this.initUI();
+		},
+	
+		incrementMonth: function(evt) {
+			var month = this.firstSaturday.month;
+			var year = this.firstSaturday.year;
+			switch(evt.currentTarget) {
+				case this.increaseMonthNode:
+					if(month < 11) {
+						month++;
+					} else {
+						month = 0;
+						year++;
+						
+						this.setYearLabels(year);
+					}
+					break;
+				case this.decreaseMonthNode:
+					if(month > 0) {
+						month--;
+					} else {
+						month = 11;
+						year--;
+						this.setYearLabels(year);
+					}
+					break;
+				case this.increaseMonthNode.getElementsByTagName("img").item(0):
+					if(month < 11) {
+						month++;
+					} else {
+						month = 0;
+						year++;
+						this.setYearLabels(year);
+					}
+					break;
+				case this.decreaseMonthNode.getElementsByTagName("img").item(0):
+					if(month > 0) {
+						month--;
+					} else {
+						month = 11;
+						year--;
+						this.setYearLabels(year);
+					}
+					break;
+			}
+			var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(month.toString(), year);
+			this.firstSaturday.year = tempSaturday.year;
+			this.firstSaturday.month = tempSaturday.month;
+			this.firstSaturday.date = tempSaturday.date;
+			this.initUI();
+		},
+	
+		incrementYear: function(evt) {
+			var year = this.firstSaturday.year;
+			switch(evt.target) {
+				case this.nextYearLabelNode:
+					year++;
+					break;
+				case this.previousYearLabelNode:
+					year--;
+					break;
+			}
+			var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(this.firstSaturday.month.toString(), year);
+			this.firstSaturday.year = tempSaturday.year;
+			this.firstSaturday.month = tempSaturday.month;
+			this.firstSaturday.date = tempSaturday.date;
+			this.initUI();
+		},
+	
+		_daysIn: function(month,year) {
+			var daysIn = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; 
+			
+			if (month==1) {
+				return (year%400 == 0) ? 29: (year%100 == 0) ? 28: (year%4 == 0) ? 29: 28;
+			} else {
+				return daysIn[month];
+			}
+		},
+	
+		onIncrementDate: function(evt) {
+			dojo.unimplemented('dojo.widget.html.DatePicker.onIncrementDate');
+		},
+	
+		onIncrementWeek: function(evt) {
+			evt.stopPropagation();
+			this.incrementWeek(evt);
+		},
+	
+		onIncrementMonth: function(evt) {
+			evt.stopPropagation();
+			this.incrementMonth(evt);
+		},
+		
+		onIncrementYear: function(evt) {
+			evt.stopPropagation();
+			this.incrementYear(evt);
+		},
+	
+		setMonthLabel: function(monthIndex) {
+			this.monthLabelNode.innerHTML = dojo.date.months[monthIndex];
+		},
+		
+		setYearLabels: function(year) {
+			this.previousYearLabelNode.innerHTML = year - 1;
+			this.currentYearLabelNode.innerHTML = year;
+			this.nextYearLabelNode.innerHTML = year + 1;
+		},
+		
+		getDateClassName: function(date, monthState) {
+			var currentClassName = this.classNames[monthState];
+			if ((!this.selectedIsUsed) && (date.getDate() == this.date.getDate()) && (date.getMonth() == this.date.getMonth()) && (date.getFullYear() == this.date.getFullYear())) {
+				currentClassName = this.classNames.selectedDate + " " + currentClassName;
+				this.selectedIsUsed = 1;
+			}
+			if((!this.currentIsUsed) && (date.getDate() == this.today.getDate()) && (date.getMonth() == this.today.getMonth()) && (date.getFullYear() == this.today.getFullYear())) {
+				currentClassName = currentClassName + " "  + this.classNames.currentDate;
+				this.currentIsUsed = 1;
+			}
+			return currentClassName;
+		},
+	
+		onClick: function(evt) {
+			dojo.event.browser.stopEvent(evt)
+		},
+		
+		onSetDate: function(evt) {
+			dojo.event.browser.stopEvent(evt);
+			this.selectedIsUsed = 0;
+			this.todayIsUsed = 0;
+			var month = this.firstSaturday.month;
+			var year = this.firstSaturday.year;
+			if (dojo.html.hasClass(evt.target, this.classNames["next"])) {
+				month = ++month % 12;
+				// if month is now == 0, add a year
+				year = (month==0) ? ++year : year;
+			} else if (dojo.html.hasClass(evt.target, this.classNames["previous"])) {
+				month = --month % 12;
+				// if month is now == 0, add a year
+				year = (month==11) ? --year : year;
+			}
+			this.date = new Date(year, month, evt.target.innerHTML);
+			this.setDate(dojo.widget.DatePicker.util.toRfcDate(this.date));
+			this.initUI();
+		}
+	}
+);

Added: tags/parley-0.53/root/static/magic/src/widget/html/DebugConsole.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/DebugConsole.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/DebugConsole.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,31 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.DebugConsole");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.FloatingPane");
+
+dojo.widget.html.DebugConsole= function(){
+
+	dojo.widget.html.FloatingPane.call(this);
+	dojo.widget.DebugConsole.call(this);
+}
+
+dojo.inherits(dojo.widget.html.DebugConsole, dojo.widget.html.FloatingPane);
+
+dojo.lang.extend(dojo.widget.html.DebugConsole, {
+	fillInTemplate: function() {
+		dojo.widget.html.DebugConsole.superclass.fillInTemplate.apply(this, arguments);
+		this.containerNode.id = "debugConsoleClientPane";
+		djConfig.isDebug = true;
+		djConfig.debugContainerId = this.containerNode.id;
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/DocPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/DocPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/DocPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,210 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.DocPane");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.io.*");
+dojo.require("dojo.event.*");
+dojo.require("dojo.widget.HtmlWidget");
+
+dojo.widget.html.DocPane = function(){
+	dojo.widget.HtmlWidget.call(this);
+
+	this.templatePath = dojo.uri.dojoUri("src/widget/templates/HtmlDocPane.html");
+	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlDocPane.css");
+	this.widgetType = "DocPane";
+	this.isContainer = true;
+
+	this.select;
+	this.result;
+	this.fn;
+	this.fnLink;
+	this.count;
+	this.row;
+	this.summary;
+	this.description;
+	this.variables;
+	this.vRow;
+	this.vLink;
+	this.vDesc;
+	this.parameters;
+	this.pRow;
+	this.pLink;
+	this.pDesc;
+	this.pOpt;
+	this.pType;
+	this.source;
+	this.sType;
+	this.sName;
+	this.sParams;
+	this.sPType;
+	this.sPTypeSave;
+	this.sPName;
+	this.sPNameSave;
+
+	dojo.event.topic.subscribe("/doc/results", this, "onDocResults");
+	dojo.event.topic.subscribe("/doc/functionDetail", this, "onDocSelectFunction");
+}
+
+dojo.inherits(dojo.widget.html.DocPane, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.DocPane, {
+	fillInTemplate: function(){
+		this.homeSave = this.containerNode.cloneNode(true);
+		this.selectSave = dojo.dom.removeNode(this.select);
+		this.resultSave = dojo.dom.removeNode(this.result);
+		this.rowParent = this.row.parentNode;
+		this.rowSave = dojo.dom.removeNode(this.row);
+		this.vParent = this.vRow.parentNode;
+		this.vSave = dojo.dom.removeNode(this.vRow);
+		this.pParent = this.pRow.parentNode;
+		this.pSave = dojo.dom.removeNode(this.pRow);
+		this.sPTypeSave = dojo.dom.removeNode(this.sPType);
+		this.sPNameSave = dojo.dom.removeNode(this.sPName);
+	},
+
+	onDocSelectFunction: function(message){
+		var meta = message.meta;
+		if(meta){
+			var variables = meta.variables;
+			var this_variables = meta.this_variables;
+			var child_variables = meta.child_variables;
+			var parameters = meta.parameters;
+		}
+		var doc = message.doc;
+
+		var appends = [];
+		dojo.dom.removeChildren(this.domNode);
+		this.fn.innerHTML = message.name;
+		this.description.innerHTML = doc.description;
+
+		this.variables.style.display = "block";
+		var all = [];
+		if(variables){
+			all = variables;
+		}
+		if(this_variables){
+			all = all.concat(this_variables);
+		}
+		if(child_variables){
+			all = all.concat(child_variables);
+		}
+		if(!all.length){
+			this.variables.style.display = "none";
+		}else{
+			for(var i = 0, one; one = all[i]; i++){
+				this.vLink.innerHTML = one;
+				this.vDesc.parentNode.style.display = "none";
+				appends.push(this.vParent.appendChild(this.vSave.cloneNode(true)));
+			}
+		}
+		
+		this.sParams.innerHTML = "";
+		for(var param in parameters){
+			var paramType = parameters[param][0];
+			var paramName = parameters[param][1];
+			this.parameters.style.display = "block";		
+			this.pLink.innerHTML = paramName;
+			this.pOpt.style.display = "none";
+			if(parameters[param].opt){
+				this.pOpt.style.display = "inline";				
+			}
+			this.pType.parentNode.style.display = "none";
+			if(parameters[param][0]){
+				this.pType.parentNode.style.display = "inline";
+				this.pType.innerHTML = paramType;
+			}
+			this.pDesc.parentNode.style.display = "none";
+			if(doc.parameters[paramName] && doc.parameters[paramName].description){
+				this.pDesc.parentNode.style.display = "inline";
+				this.pDesc.innerHTML = doc.parameters[paramName].description;
+			}
+			appends.push(this.pParent.appendChild(this.pSave.cloneNode(true)));
+			
+			if(param > 0) {
+				this.sParams.appendChild(document.createTextNode(", "));
+			}
+			if(paramType){
+				dojo.debug(this.sPTypeSave);
+				this.sPTypeSave.innerHTML = paramType;
+				this.sParams.appendChild(this.sPTypeSave.cloneNode(true));
+				this.sParams.appendChild(document.createTextNode(" "));
+			}
+			dojo.debug(this.sPNameSave);
+			this.sPNameSave.innerHTML = paramName;
+			this.sParams.appendChild(this.sPNameSave.cloneNode(true))
+		}
+
+		if(message.returns){
+			this.sType.innerHTML = message.returns;
+		}else{
+			this.sType.innerHTML = "void";
+		}
+		
+		this.sName.innerHTML = message.name;
+		
+		dojo.dom.removeChildren(this.source);
+                this.source.appendChild(document.createTextNode("\n\r"));
+		this.source.appendChild(document.createTextNode(message.src.replace(/\n/g, "\r\n\t")));
+                this.source.appendChild(document.createTextNode("\n\r"));
+		
+		this.domNode.appendChild(this.selectSave.cloneNode(true));
+
+		for(var i = 0, append; append = appends[i]; i++){
+			dojo.dom.removeNode(append);
+		}
+	},
+
+	onDocResults: function(message){
+		var results = message.docResults;
+		
+		if(results.length == 1){
+			dojo.event.topic.publish("/doc/selectFunction", results[0]);
+			return;
+		}
+
+		dojo.dom.removeChildren(this.domNode);
+
+		this.count.innerHTML = results.length;
+		var appends = [];
+		for(var i = 0, row; row = results[i]; i++){
+			this.fnLink.innerHTML = row.name;
+			this.fnLink.href = "#" + row.name;
+			if(row.id){
+				this.fnLink.href = this.fnLink.href + "," + row.id;	
+			}
+			this.summary.parentNode.style.display = "none";
+			if(row.summary){
+				this.summary.parentNode.style.display = "inline";				
+				this.summary.innerHTML = row.summary;
+			}
+			appends.push(this.rowParent.appendChild(this.rowSave.cloneNode(true)));
+		}
+		
+		function makeSelect(x){
+			return function(e) {
+				dojo.event.topic.publish("/doc/selectFunction", x);
+			}
+		}
+
+		this.domNode.appendChild(this.resultSave.cloneNode(true));
+		var as = this.domNode.getElementsByTagName("a");
+		for(var i = 0, a; a = as[i]; i++){
+			dojo.event.connect(a, "onclick", makeSelect(results[i]));
+		}
+		
+		for(var i = 0, append; append = appends[i]; i++){
+			this.rowParent.removeChild(append);
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:DocPane");

Added: tags/parley-0.53/root/static/magic/src/widget/html/DropdownButton.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/DropdownButton.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/DropdownButton.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,188 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+/* TODO:
+ * - make the dropdown "smart" so it can't get cutoff on bottom of page, sides of page, etc.
+ */
+
+dojo.provide("dojo.widget.html.DropdownButton");
+
+dojo.require("dojo.event.*");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.uri.Uri");
+dojo.require("dojo.dom");
+dojo.require("dojo.style");
+dojo.require("dojo.html");
+
+dojo.widget.html.DropdownButton = function() {
+	// mix in the button properties
+	dojo.widget.DropdownButton.call(this);
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.DropdownButton, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.DropdownButton, {
+	
+	// In IE, event handlers on objects inside buttons don't work correctly, so
+	// we just set onClick on the button itself.
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlDropDownButtonTemplate.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlButtonTemplate.css"),
+
+	// attach points
+	button: null,
+	table: null,
+	labelCell: null,
+	borderCell: null,
+	arrowCell: null,
+	arrow: null,
+
+	fillInTemplate: function(args, frag) {
+		// input data (containing the anchor for the button itself, plus the
+		// thing to display when you push the down arrow)
+		var input = frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"];
+
+		// Recursively expand widgets inside of the <dojo:dropdownButton>
+		var parser = new dojo.xml.Parse();
+		var frag = parser.parseElement(input, null, true);
+		var ary = dojo.widget.getParser().createComponents(frag);
+
+		this.a = dojo.dom.getFirstChildElement(input);	// the button contents
+		this.menu = dojo.dom.getNextSiblingElement(this.a);	// the menu under the button
+		
+		this.disabled = dojo.html.hasClass(this.a, "disabled");
+		if( this.disabled ) {
+			dojo.html.addClass(this.button, "dojoDisabled");
+			this.domNode.setAttribute("disabled", "true");
+		}
+
+		dojo.html.disableSelection(this.a);
+		this.a.style["text-decoration"]="none";
+		this.labelCell.appendChild(this.a);
+
+		this.arrow.src =
+			dojo.uri.dojoUri("src/widget/templates/images/dropdownButtonsArrow" +
+			(this.disabled ? "-disabled" : "") + ".gif");
+
+		// Attach menu to body so that it appears above other buttons
+		this.menu.style.position="absolute";
+		this.menu.style.display="none";
+		this.menu.style["z-index"] = 99;
+		document.body.appendChild(this.menu);
+	},
+
+	postCreate: function() {
+		if ( dojo.render.html.ie ) {
+			// Compensate for IE's weird padding of button content, which seems to be relative
+			// to the length of the content
+			var contentWidth = dojo.style.getOuterWidth(this.table);
+			this.labelCell.style["left"] = "-" + (contentWidth / 10) + "px";
+			this.arrowCell.style["left"] = (contentWidth / 10) + "px";
+		}
+
+		// Make menu at least as wide as the button
+		var buttonWidth = dojo.style.getOuterWidth(this.button);
+		var menuWidth = dojo.style.getOuterWidth(this.menu);
+		if ( buttonWidth > menuWidth ) {
+			dojo.style.setOuterWidth(this.menu, buttonWidth);
+		}
+	},
+
+	// If someone clicks anywhere else on the screen (including another menu),
+	// then close this menu.
+	onCanvasMouseDown: function(e) {
+		if( !dojo.dom.isDescendantOf(e.target, this.button) &&
+			!dojo.dom.isDescendantOf(e.target, this.menu) ) {
+			this.hideMenu();
+		}
+	},
+
+	eventWasOverArrow: function(e) {
+		// want to use dojo.html.overElement() but also need to detect clicks
+		// on the area between the arrow and the edge of the button
+		var eventX = e.clientX;
+		var borderX = dojo.style.totalOffsetLeft(this.borderCell);
+		return (eventX > borderX );
+	},
+
+	onMouseOver: function(e) {
+		dojo.html.addClass(this.button, "dojoButtonHover");
+		dojo.html.removeClass(this.button, "dojoButtonNoHover");
+	},
+	
+	onMouseOut: function(e) {
+		dojo.html.removeClass(this.button, "dojoButtonHover");
+		dojo.html.addClass(this.button, "dojoButtonNoHover");
+	},
+
+	onClick: function(e) {
+		if ( this.eventWasOverArrow(e) ) {
+			this._onClickArrow();
+		} else {
+			this._onClickButton();
+		}
+	},
+
+	// Action when the user presses the button
+	_onClickButton: function(e) {
+		if ( this.a ) {
+			if ( this.a.click ) {
+				this.a.click();
+			} else if ( this.a.href ) {
+				location.href = this.a.href;
+			}
+		}
+	},
+
+	// Action when user presses the arrow
+	_onClickArrow: function() {
+		if ( this.menu.style.display == "none" ) {
+			this.showMenu();
+		} else {
+			this.hideMenu();
+		}
+	},
+	
+	showMenu: function() {
+		if ( this.disabled )
+			return;
+
+		// Position it accordingly, relative to screen root (since
+		// it's attached to document.body)
+		this.menu.style.left = dojo.style.totalOffsetLeft(this.button) + "px";
+		this.menu.style.top = dojo.style.totalOffsetTop(this.button) + dojo.style.getOuterHeight(this.button) + "px";
+
+		// Display the menu; do this funky code below to stop the menu from extending
+		// all the way to the right edge of the screen.
+		// TODO: retest simple display="" to confirm that it doesn't work.
+		try {
+			this.menu.style.display="table";	// mozilla
+		} catch(e) {
+			this.menu.style.display="block";	// IE
+		}
+
+		// If someone clicks somewhere else on the screen then close the menu
+		dojo.event.connect(document.documentElement, "onmousedown", this, "onCanvasMouseDown");
+		
+		// When someone clicks the menu, after the menu handles the event,
+		// close the menu (be careful not to close the menu too early or else
+		// the menu will never receive the event.)
+		dojo.event.connect(this.menu, "onclick", this, "hideMenu");
+	},
+
+	hideMenu: function() {
+		this.menu.style.display = "none";
+		dojo.event.disconnect(document.documentElement, "onmousedown", this, "onCanvasMouseDown");
+		dojo.event.disconnect(this.menu, "onclick", this, "hideMenu");
+	}
+});
+
+

Added: tags/parley-0.53/root/static/magic/src/widget/html/GoogleMap.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/GoogleMap.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/GoogleMap.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,198 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.GoogleMap");
+dojo.require("dojo.event.*");
+dojo.require("dojo.html");
+dojo.require("dojo.math");
+dojo.require("dojo.uri.Uri");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.GoogleMap");
+
+(function(){
+	var gkey = djConfig["gMapKey"]||djConfig["googleMapKey"];
+
+	//	the Google API key mechanism sucks.  We're hardcoding here for love and affection but I don't like it.
+	var uri=new dojo.uri.Uri(window.location.href);
+	if(uri.host=="www.dojotoolkit.org"){
+		gkey="ABQIAAAACUNdgv_7FGOmUslbm9l6_hRqjp7ri2mNiOEYqetD3xnFHpt5rBSjszDd1sdufPyQKUTyCf_YxoIxvw";
+	}
+	else if(uri.host=="blog.dojotoolkit.org"){
+		gkey="ABQIAAAACUNdgv_7FGOmUslbm9l6_hSkep6Av1xaMhVn3yCLkorJeXeLARQ6fammI_P3qSGleTJhoI5_1JmP_Q";
+	}
+	else if(uri.host=="archive.dojotoolkit.org"){
+		gkey="ABQIAAAACUNdgv_7FGOmUslbm9l6_hTaQpDt0dyGLIHbXMPTzg1kWeAfwRTwZNyrUfbfxYE9yIvRivEjcXoDTg";
+	}
+	else if(uri.host=="dojotoolkit.org"){
+		gkey="ABQIAAAACUNdgv_7FGOmUslbm9l6_hSaOaO_TgJ5c3mtQFnk5JO2zD5dZBRZk-ieqVs7BORREYNzAERmcJoEjQ";
+	}
+
+	if(!dojo.hostenv.post_load_){
+		var tag = "<scr"+"ipt src='http://maps.google.com/maps?file=api&amp;v=2&amp;key="+gkey+"'></scri"+"pt>";
+		if(!dj_global["GMap2"]){ // prevent multi-inclusion
+			document.write(tag);
+		}
+	}else{
+		dojo.debug("cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Google in your page or require() the GoogleMap widget before onload has fired");
+	}
+})();
+
+dojo.widget.html.GoogleMap=function(){
+	dojo.widget.HtmlWidget.call(this);
+	dojo.widget.GoogleMap.call(this);
+
+	var gm=dojo.widget.GoogleMap;
+
+	this.map=null;
+	this.data=[];
+	this.datasrc="";
+	// FIXME: this is pehraps the stupidest way to specify this enum I can think of
+	this.controls=[gm.Controls.LargeMap,gm.Controls.Scale,gm.Controls.MapType];
+};
+dojo.inherits(dojo.widget.html.GoogleMap, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.GoogleMap, {
+	templatePath:null,
+	templateCssPath:null,
+
+	setControls:function(){
+		var c=dojo.widget.GoogleMap.Controls;
+		for(var i=0; i<this.controls.length; i++){
+			var type=this.controls[i];
+			switch(type){
+				case c.LargeMap:{
+					this.map.addControl(new GLargeMapControl());
+					break;
+				}
+				case c.SmallMap:{
+					this.map.addControl(new GSmallMapControl());
+					break;
+				}
+				case c.SmallZoom:{
+					this.map.addControl(new GSmallZoomControl());
+					break;
+				}
+				case c.Scale:{
+					this.map.addControl(new GScaleControl());
+					break;
+				}
+				case c.MapType:{
+					this.map.addControl(new GMapTypeControl());
+					break;
+				}
+				case c.Overview:{
+					this.map.addControl(new GOverviewMapControl());
+					break;
+				}
+				default:{
+					break;
+				}
+			}
+		}
+	},
+	
+	findCenter:function(bounds){
+		var clat=(bounds.getNorthEast().lat()+bounds.getSouthWest().lat())/2;
+		var clng=(bounds.getNorthEast().lng()+bounds.getSouthWest().lng())/2;
+		return (new GLatLng(clat,clng));
+	},
+
+	createPinpoint:function(pt,overlay){
+		var m=new GMarker(pt);
+		if(overlay){
+			GEvent.addListener(m,"click",function(){
+				m.openInfoWindowHtml("<div>"+overlay+"</div>");
+			});
+		}
+		return m;
+	},
+
+	parse:function(table){
+		this.data=[];
+
+		//	get the column indices
+		var h=table.getElementsByTagName("thead")[0];
+		if(!h){
+			return;
+		}
+
+		var a=[];
+		var cols=h.getElementsByTagName("td");
+		if(cols.length==0){
+			cols=h.getElementsByTagName("th");
+		}
+		for(var i=0; i<cols.length; i++){
+			var c=cols[i].innerHTML.toLowerCase();
+			if(c=="long") c="lng";
+			a.push(c);
+		}
+		
+		//	parse the data
+		var b=table.getElementsByTagName("tbody")[0];
+		if(!b){
+			return;
+		}
+		for(var i=0; i<b.childNodes.length; i++){
+			if(!(b.childNodes[i].nodeName&&b.childNodes[i].nodeName.toLowerCase()=="tr")){
+				continue;
+			}
+			var cells=b.childNodes[i].getElementsByTagName("td");
+			var o={};
+			for(var j=0; j<a.length; j++){
+				var col=a[j];
+				if(col=="lat"||col=="lng"){
+					o[col]=parseFloat(cells[j].innerHTML);					
+				}else{
+					o[col]=cells[j].innerHTML;
+				}
+			}
+			this.data.push(o);
+		}
+	},
+	render:function(){
+		var bounds=new GLatLngBounds();
+		var d=this.data;
+		var pts=[];
+		for(var i=0; i<d.length; i++){
+			bounds.extend(new GLatLng(d[i].lat,d[i].lng));
+		}
+
+		this.map.setCenter(this.findCenter(bounds), this.map.getBoundsZoomLevel(bounds));
+
+		for(var i=0; i<this.data.length; i++){
+			var p=new GLatLng(this.data[i].lat,this.data[i].lng);
+			var d=this.data[i].description||null;
+			var m=this.createPinpoint(p,d);
+			this.map.addOverlay(m);
+		}
+	},
+	
+
+	initialize:function(args, frag){
+		if(!GMap2){
+			dojo.raise("dojo.widget.GoogleMap: The Google Map script must be included (with a proper API key) in order to use this widget.");
+		}
+		if(this.datasrc){
+			this.parse(dojo.byId(this.datasrc));
+		}
+		else if(this.domNode.getElementsByTagName("table")[0]){
+			this.parse(this.domNode.getElementsByTagName("table")[0]);
+		}
+	},
+	postCreate:function(){
+		//	clean the domNode before creating the map.
+		while(this.domNode.childNodes.length>0){
+			this.domNode.removeChild(this.domNode.childNodes[0]);
+		}
+		this.map=new GMap2(this.domNode);
+		this.render();
+		this.setControls();
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/LinkPane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/LinkPane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/LinkPane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,54 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.LinkPane");
+dojo.provide("dojo.widget.html.LinkPane");
+
+//
+// a div that loads from a URL.  (Similar to an iframe, but
+// it's in the same environment as the main window)
+//
+
+dojo.require("dojo.widget.LinkPane");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.event.*");
+dojo.require("dojo.io.*");
+dojo.require("dojo.widget.ContentPane");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.dom");
+dojo.require("dojo.string");
+
+
+dojo.widget.html.LinkPane = function(){
+	dojo.widget.html.ContentPane.call(this);
+}
+
+dojo.inherits(dojo.widget.html.LinkPane, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.html.LinkPane, {
+	widgetType: "LinkPane",
+
+	// I'm using a template because the user may specify the input as
+	// <a href="foo.html">label</a>, in which case we need to get rid of the
+	// <a> because we don't want a link.
+	templateString: '<div class="dojoLinkPane"></div>',
+
+	fillInTemplate: function(args, frag){
+		var source = this.getFragNodeRef(frag);
+
+		// If user has specified node contents, they become the label
+		// (the link must be plain text)
+		this.label += source.innerHTML;
+
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/Menu.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Menu.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Menu.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,51 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.require("dojo.widget.Menu");
+dojo.provide("dojo.widget.html.Menu");
+
+/* HtmlMenu
+ ***********/
+ 
+dojo.widget.html.Menu = function(){
+	dojo.widget.html.Menu.superclass.constructor.call(this);
+	this.items = [];
+}
+dojo.inherits(dojo.widget.html.Menu, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.Menu, {
+	widgetType: "Menu",
+	isContainer: true,
+
+	// copy children widgets output directly to parent (this node), to avoid
+	// errors trying to insert an <li> under a <div>
+	snarfChildDomOutput: true,
+
+	templateString: '<ul></ul>',
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/Menu.css"),
+	
+	fillInTemplate: function (args, frag){
+		//dojo.widget.HtmlMenu.superclass.fillInTemplate.apply(this, arguments);
+		this.domNode.className = "dojoMenu";
+	},
+	
+ 
+	_register: function (item ) {
+		dojo.event.connect(item, "onSelect", this, "onSelect");
+		this.items.push(item);
+	},
+
+	push: function (item) {
+		this.domNode.appendChild(item.domNode);
+		this._register(item);
+	}
+
+});
+

Added: tags/parley-0.53/root/static/magic/src/widget/html/MenuItem.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/MenuItem.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/MenuItem.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,60 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.MenuItem");
+
+/* HtmlMenuItem
+ ***************/
+
+dojo.widget.html.MenuItem = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.MenuItem, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.MenuItem, {
+	widgetType: "MenuItem",
+	templateString: '<li class="dojoMenuItem" dojoAttachEvent="onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick;"></li>',
+	title: "",
+
+	fillInTemplate: function(args, frag){
+		dojo.html.disableSelection(this.domNode);
+
+		if(!dojo.string.isBlank(this.title)){
+			this.domNode.appendChild(document.createTextNode(this.title));
+		}else{
+			this.domNode.appendChild(frag["dojo:"+this.widgetType.toLowerCase()]["nodeRef"]);
+		}
+	},
+	
+	onMouseOver: function(e){
+		dojo.html.addClass(this.domNode, "dojoMenuItemHover");
+	},
+	
+	onMouseOut: function(e){
+		dojo.html.removeClass(this.domNode, "dojoMenuItemHover");
+	},
+	
+	onClick: function(e){ this.onSelect(this, e); },
+	onMouseDown: function(e){},
+	onMouseUp: function(e){},
+	
+	// By default, when I am clicked, click the item inside of me
+	onSelect: function (item, e) {
+		var child = dojo.dom.getFirstChildElement(this.domNode);
+		if(child){
+			if(child.click){
+				child.click();
+			}else if(child.href){
+				location.href = child.href;
+			}
+		}
+	}
+});
+

Added: tags/parley-0.53/root/static/magic/src/widget/html/MonthlyCalendar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/MonthlyCalendar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/MonthlyCalendar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,134 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.MonthlyCalendar");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.html.DatePicker");
+dojo.require("dojo.widget.MonthlyCalendar");
+//dojo.require("dojo.widget.MonthlyCalendar.util");
+dojo.require("dojo.event.*");
+dojo.require("dojo.html");
+
+dojo.widget.html.MonthlyCalendar= function(){
+	dojo.widget.MonthlyCalendar.call(this);
+	//dojo.widget.html.DatePicker.call(this);
+	this.widgetType = "MonthlyCalendar";
+	this.templatePath =  dojo.uri.dojoUri("src/widget/templates/HtmlMonthlyCalendar.html");
+	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlMonthlyCalendar.css");
+
+	this.iCalendars = [];
+}
+
+dojo.inherits(dojo.widget.html.MonthlyCalendar, dojo.widget.html.DatePicker);
+
+dojo.lang.extend(dojo.widget.html.MonthlyCalendar, {
+	cache: function() {
+	},
+
+	addCalendar: function(/* dojo.iCalendar */ cal) {
+		dojo.debug("Adding Calendar");
+		this.iCalendars.push(cal);
+		dojo.debug("Starting init");
+		this.initUI()
+		dojo.debug("done init");
+	},
+
+	createDayContents: function(node,mydate) {
+		dojo.dom.removeChildren(node);
+		node.appendChild(document.createTextNode(mydate.getDate()));	
+			for(var x=0; x<this.iCalendars.length; x++) {
+				var evts = this.iCalendars[x].getEvents(mydate);
+				if ((dojo.lang.isArray(evts)) && (evts.length>0)) {
+				for(var y=0;y<evts.length;y++) {
+					var el = document.createElement("div");
+					dojo.html.addClass(el, "dojoMonthlyCalendarEvent");          
+					el.appendChild(document.createTextNode(evts[y].summary.value));
+					el.width = dojo.style.getContentWidth(node);
+					node.appendChild(el);
+				}
+			}
+		}
+	},
+
+	initUI: function() {
+		this.selectedIsUsed = false;
+		this.currentIsUsed = false;
+		var currentClassName = "";
+		var previousDate = new Date();
+		var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName("td");
+		var currentCalendarNode;
+		// set hours of date such that there is no chance of rounding error due to 
+		// time change in local time zones
+		previousDate.setHours(8);
+		var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
+		var lastDay = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date + 42, 8);
+		
+		if (this.iCalendars.length > 0) {
+			for (var x=0; x<this.iCalendars.length;x++) {
+				this.iCalendars[x].preComputeRecurringEvents(lastDay);
+			}
+		}
+
+		if(this.firstSaturday.date < 7) {
+			// this means there are days to show from the previous month
+			var dayInWeek = 6;
+			for (var i=this.firstSaturday.date; i>0; i--) {
+				currentCalendarNode = calendarNodes.item(dayInWeek);
+				this.createDayContents(currentCalendarNode, nextDate);
+				
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
+				dayInWeek--;
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, false);
+			}
+			for(var i=dayInWeek; i>-1; i--) {
+				currentCalendarNode = calendarNodes.item(i);
+
+				this.createDayContents(currentCalendarNode, nextDate);
+
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "previous"));
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, false);				
+			}
+		} else {
+			nextDate.setDate(1);
+			for(var i=0; i<7; i++) {
+				currentCalendarNode = calendarNodes.item(i);
+				this.createDayContents(currentCalendarNode, nextDate);
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, true);				
+			}
+		}
+		previousDate.setDate(this.firstSaturday.date);
+		previousDate.setMonth(this.firstSaturday.month);
+		previousDate.setFullYear(this.firstSaturday.year);
+		nextDate = this.incrementDate(previousDate, true);
+		var count = 7;
+		currentCalendarNode = calendarNodes.item(count);
+		while((nextDate.getMonth() == previousDate.getMonth()) && (count<42)) {
+			this.createDayContents(currentCalendarNode, nextDate);
+			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "current"));
+			currentCalendarNode = calendarNodes.item(++count);
+			previousDate = nextDate;
+			nextDate = this.incrementDate(nextDate, true);
+		}
+		
+		while(count < 42) {
+			this.createDayContents(currentCalendarNode, nextDate);
+			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, "next"));
+			currentCalendarNode = calendarNodes.item(++count);
+			previousDate = nextDate;
+			nextDate = this.incrementDate(nextDate, true);
+		}
+		this.setMonthLabel(this.firstSaturday.month);
+		this.setYearLabels(this.firstSaturday.year);
+	}	
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/Show.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Show.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Show.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,177 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.Show");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.Show");
+dojo.require("dojo.uri.Uri");
+dojo.require("dojo.event");
+dojo.require("dojo.animation.Animation");
+dojo.require("dojo.math.curves");
+dojo.require("dojo.html");
+dojo.require("dojo.lang.common");
+dojo.require("dojo.lang.func");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Show",
+	dojo.widget.HtmlWidget,
+	null,
+	"html",
+	function(){
+		dojo.widget.Show.call(this);
+	}
+);
+dojo.lang.extend(dojo.widget.html.Show, dojo.widget.Show.prototype);
+dojo.lang.extend(dojo.widget.html.Show, {
+	body: null,
+	nav: null,
+	hider: null,
+	select: null,
+	option: null,
+	inNav: false,
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlShow.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlShow.css"),
+	fillInTemplate: function(args, frag){
+		var source = this.getFragNodeRef(frag);
+		this.sourceNode = document.body.appendChild(source.cloneNode(true));
+		for(var i = 0, child; child = this.sourceNode.childNodes[i]; i++){
+			if(child.tagName && child.getAttribute("dojotype").toLowerCase() == "showslide"){
+				child.className = "dojoShowPrintSlide";
+				child.innerHTML = "<h1>" + child.title + "</h1>" + child.innerHTML;
+			}
+		}
+		this.sourceNode.className = "dojoShowPrint";
+		this.sourceNode.style.display = "none";
+		
+		dojo.event.connect(document, "onclick", this, "gotoSlideByEvent");
+		dojo.event.connect(document, "onkeypress", this, "gotoSlideByEvent");
+		dojo.event.connect(window, "onresize", this, "resizeWindow");
+		dojo.event.connect(this.nav, "onmousemove", this, "popUpNav");
+	},
+	postCreate: function(){		
+		this._slides = [];
+		for(var i = 0, child; child = this.children[i]; i++){
+			if(child.widgetType == "ShowSlide"){
+				this._slides.push(child);
+				this.option.text = child.title;
+				this.option.parentNode.insertBefore(this.option.cloneNode(true), this.option);
+			}
+		}
+		this.option.parentNode.removeChild(this.option);
+
+		document.body.style.display = "block";
+		this.resizeWindow();
+		this.gotoSlide(0);
+	},
+	gotoSlide: function(/*int*/ slide){
+		if(slide == this._slide){
+			return;
+		}
+
+		if(!this._slides[slide]){
+			// slide: string
+			for(var i = 0, child; child = this._slides[i]; i++){
+				if(child.title == slide){
+					slide = i;
+					break;
+				}
+			}
+		}
+		
+		if(!this._slides[slide]){
+			return;
+		}
+		
+		if(this._slide != -1){
+			while(this._slides[this._slide].previousAction()){}
+		}
+		
+		this._slide = slide;
+		this.select.selectedIndex = slide;
+		while(this.contentNode.hasChildNodes()){ this.contentNode.removeChild(this.contentNode.firstChild); }
+		this.contentNode.appendChild(this._slides[slide].domNode);
+	},
+	gotoSlideByEvent: function(/*Event*/ event){
+		var node = event.target;
+		var type = event.type;
+		if(type == "click"){
+			if(node.tagName == "OPTION"){
+				this.gotoSlide(node.index);
+			}else if(node.tagName == "SELECT"){
+				this.gotoSlide(node.selectedIndex);
+			}else if(node.tagName != "A"){
+				this.nextSlide(event);
+			}
+		}else if(type == "keypress"){
+			var key = event.keyCode;
+			var ch = event.charCode;
+			if(key == 63234 || key == 37){
+				this.previousSlide(event);
+			}else if(key == 63235 || key == 39 || ch == 32){
+				this.nextSlide(event);
+			}
+		}
+	},
+	nextSlide: function(/*Event?*/ event){
+		this.stopEvent(event);
+		return dojo.widget.Show.prototype.nextSlide.call(this, event);
+	},
+	previousSlide: function(/*Event?*/ event){
+		this.stopEvent(event);
+		return dojo.widget.Show.prototype.previousSlide.call(this, event);
+	},
+	stopEvent: function(/*Event*/ ev){
+		if(window.event){
+			ev.returnValue = false;
+			ev.cancelBubble = true;
+		}else{
+			ev.preventDefault();
+			ev.stopPropagation();
+		}
+	},
+	popUpNav: function(){
+		if(!this.inNav){
+			dojo.widget.Show.node = this.nav;
+			var anim = new dojo.animation.Animation(new dojo.math.curves.Line([5], [30]), 250, -1);
+			dojo.event.connect(anim, "onAnimate", function(e) {
+				dojo.widget.Show.node.style.height = e.x + "px";
+			});
+			dojo.event.connect(anim, "onEnd", function(e) {
+				dojo.widget.Show.node.style.height = e.x + "px";
+			});
+			anim.play(true);
+		}
+		clearTimeout(this.inNav);
+		this.inNav = setTimeout(dojo.lang.hitch(this, "hideNav"), 2000);
+	},
+	hideNav: function(){
+		clearTimeout(this.inNav);
+		this.inNav = false;
+
+		dojo.widget.Show.node = this.nav;
+		var anim = new dojo.animation.Animation(new dojo.math.curves.Line([30], [5]), 250, 1);
+		dojo.event.connect(anim, "onAnimate", function(e) {
+			dojo.widget.Show.node.style.height = e.x + "px";
+		});
+		dojo.event.connect(anim, "onEnd", function(e) {
+			dojo.widget.Show.node.style.height = e.x + "px";
+		});
+		anim.play(true);
+	},
+	resizeWindow: function(/*Event*/ ev){
+		document.body.style.height = "auto";
+		var h = Math.max(
+			document.documentElement.scrollHeight || document.body.scrollHeight,
+			dojo.html.getViewportHeight());
+		document.body.style.height = h + "px";
+	}
+});
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/html/ShowAction.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/ShowAction.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/ShowAction.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,28 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.ShowAction");
+
+dojo.require("dojo.widget.ShowAction");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.lang.common");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.ShowAction",
+	dojo.widget.HtmlWidget,
+	null,
+	"html",
+	function(){
+		dojo.widget.ShowAction.call(this);
+	}
+);
+dojo.lang.extend(dojo.widget.html.ShowAction, dojo.widget.ShowAction.prototype);
+dojo.lang.extend(dojo.widget.html.ShowAction, {
+});
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/html/ShowSlide.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/ShowSlide.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/ShowSlide.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,189 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.ShowSlide");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.lang.common");
+dojo.require("dojo.widget.ShowSlide");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.lfx.html");
+dojo.require("dojo.animation.Animation");
+dojo.require("dojo.graphics.color");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.ShowSlide",
+	dojo.widget.HtmlWidget,
+	null,
+	"html",
+	function(){
+		dojo.widget.ShowSlide.call(this);
+	}
+);
+dojo.lang.extend(dojo.widget.html.ShowSlide, dojo.widget.ShowSlide.prototype);
+dojo.lang.extend(dojo.widget.html.ShowSlide, {
+	htmlTitle: null,
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlShowSlide.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlShowSlide.css"),
+	fillInTemplate: function(){
+		this.htmlTitle.innerHTML = this.title;
+
+		this._components = {};
+		var nodes = this.containerNode.all ? this.containerNode.all : this.containerNode.getElementsByTagName('*');
+		for(var i = 0, node; node = nodes[i]; i++){
+			var as = node.getAttribute("as");
+			if(as){
+				if(!this._components[as]){
+					this._components[as] = [];
+				}
+				this._components[as].push(node);
+			}
+		}
+	},
+	postCreate: function(){
+		this._actions = [];
+		for(var i = 0, child; child = this.children[i]; i++){
+			if(child.widgetType == "ShowAction"){
+				this._actions.push(child);
+				var components = this._components[child.on];
+				for(var j = 0, component; component = components[j]; j++){
+					if(child.action && child.action != "remove"){
+						this.hideComponent(component);
+					}
+				}
+			}
+		}
+	},
+	previousAction: function(/*Event?*/ event){
+		this.stopEvent(event);
+
+		var action = this._actions[this._action];
+		if(!action){
+			return false;
+		}
+
+		var on = action.on;
+		while(action.on == on){
+			var components = this._components[on];
+			for(var i = 0, component; component = components[i]; i++){
+				if(action.action == "remove"){
+					if(component.style.display == "none"){
+						component.style.display = "";
+						component.style.visibility = "visible";
+						var exits = true;
+					}
+				}else if(action.action){
+					this.hideComponent(component);
+				}
+			}
+
+			--this._action;
+
+			if(exits){
+				return true;
+			}	
+
+			if(action.auto == "true"){
+				on = this._actions[this._action].on;
+			}
+
+			action = this._actions[this._action];
+			if(!action){
+				return false;
+			}
+		}
+		return true;
+	},
+	hideComponent: function(/*Node*/ component){
+		component.style.visibility = "hidden";
+		component.style.backgroundColor = "transparent";
+		var parent = component.parentNode;
+		if((parent)&&(parent.tagName == "LI")){
+			parent.oldType = parent.style.listStyleType;
+			parent.style.listStyleType = "none";
+		}
+	},
+	nextAction: function(/*Event?*/ event){
+		this.stopEvent(event);
+
+		if(!dojo.widget.ShowSlide.prototype.nextAction.call(this, event)){
+			return false;
+		}
+
+		var action = this._actions[this._action];
+		if(!action){
+			return false;
+		}
+		
+		var components = this._components[action.on];
+		for(var i = 0, component; component = components[i]; i++){
+			if(action.action){
+				var duration = action.duration || 1000;
+				if(action.action == "fade"){
+					dojo.style.setOpacity(component, 0);
+					dojo.lfx.html.fadeIn(component, duration).play(true);
+				}else if(action.action == "fly"){
+					var width = dojo.style.getMarginBoxWidth(component);
+					var position = dojo.style.getAbsolutePosition(component);
+					// alert(position);
+					component.style.position = "relative";
+					component.style.left = -(width + position.x) + "px";
+					dojo.lfx.html.slideBy(component, [0, (width + position.x)], duration, -1, this.callWith).play(true);
+				}else if(action.action == "wipe"){
+					dojo.lfx.html.wipeIn(component, duration).play();
+				}else if(action.action == "color"){
+					var from = new dojo.graphics.color.Color(action.from).toRgb();
+					var to = new dojo.graphics.color.Color(action.to).toRgb();
+					var anim = new dojo.animation.Animation(new dojo.math.curves.Line(from, to), duration, 0);
+					node = component;
+					dojo.event.connect(anim, "onAnimate", function(e) {
+						node.style.color = "rgb(" + e.coordsAsInts().join(",") + ")";
+					});
+					anim.play(true);
+				}else if(action.action == "bgcolor"){
+					dojo.lfx.html.unhighlight(component, action.to, duration).play();
+				}else if(action.action == "remove"){
+					component.style.display = "none";
+				}
+				component.style.visibility = "visible";
+			}
+		}
+		
+		action = this._actions[this._action + 1];
+		if(action && action.auto == "true"){
+			this.nextAction();
+		}
+
+		return true;
+	},
+	callWith: function(/*Node*/ node){
+		if(!node){ return; }
+		if(dojo.lang.isArray(node)){
+			dojo.lang.forEach(node, arguments.callee);
+			return;
+		}
+		var parent = node.parentNode;
+		if((parent)&&(parent.tagName.toLowerCase() == "li")){
+			parent.style.listStyleType = parent.oldType;
+		}
+	},
+	stopEvent: function(/*Event*/ ev){
+		if(!ev){
+			return;
+		}
+		if(window.event){
+			ev.returnValue = false;
+			ev.cancelBubble = true;
+		}else{
+			ev.preventDefault();
+			ev.stopPropagation();
+		}
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/Slider.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Slider.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Slider.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,500 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+/**
+ * Slider Widget.
+ * 
+ * The slider widget comes in three forms:
+ *  1. Base Slider widget which supports movement in x and y dimensions
+ *  2. Vertical Slider (SliderVertical) widget which supports movement
+ *     only in the y dimension.
+ *  3. Horizontal Slider (SliderHorizontal) widget which supports movement
+ *     only in the x dimension.
+ *
+ * The key objects in the widget are:
+ *  - a container div which displays a bar in the background (Slider object)
+ *  - a handle inside the container div, which represents the value
+ *    (sliderHandle DOM node)
+ *  - the object which moves the handle (handleMove is of type 
+ *    SliderDragMoveSource)
+ *
+ * The values for the slider are calculated by grouping pixels together, 
+ * based on the number of values to be represented by the slider.
+ * The number of pixels in a group is called the valueSize
+ *  e.g. if slider is 150 pixels long, and is representing the values
+ *       0,1,...10 then pixels are grouped into lots of 15 (valueSize), where:
+ *         value 0 maps to pixels  0 -  7
+ *               1                 8 - 22
+ *               2                23 - 37 etc.
+ * The accuracy of the slider is limited to the number of pixels
+ * (i.e tiles > pixels will result in the slider not being able to
+ *  represent some values).
+ *
+ * Technical Notes:
+ *  - 3 widgets exist because the framework caches the template in
+ *    dojo.widget.fillFromTemplateCache (which ignores the changed URI)
+ *
+ * Todo:
+ *  - Setting of initial value currently doesn't work, because the one or
+ *    more of the offsets, constraints or containing block are not set and
+ *    are required to set the valueSize is not set before fillInTemplate
+ *    is called.
+ *  - Issues with dragging handle when page has been scrolled
+ *  - 
+ *
+ * References (aka sources of inspiration):
+ *  - http://dojotoolkit.org/docs/fast_widget_authoring.html
+ *  - http://dojotoolkit.org/docs/dojo_event_system.html
+ * 
+ * @author Marcel Linnenfelser (m.linnen at synflag.de)
+ * @author Mathew Pole (mathew.pole at ebor.com)
+ *
+ * $Id: $
+ */
+
+// tell the package system what functionality is provided in this module (file)
+// (note that the package system works on modules, not the classes)
+dojo.provide("dojo.widget.html.Slider");
+
+// load dependencies
+dojo.require("dojo.event.*");
+dojo.require("dojo.dnd.*");
+// dojo.dnd.* doesn't include this package, because it's not in __package__.js
+dojo.require("dojo.dnd.HtmlDragMove");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.style");
+
+
+/**
+ * Define the two dimensional slider widget class.
+ */
+dojo.widget.defineWidget (
+	"dojo.widget.html.Slider",
+	dojo.widget.HtmlWidget,
+	{
+		// over-ride some defaults
+		isContainer: false,
+		widgetType: "Slider",
+
+		// useful properties (specified as attributes in the html tag)
+		// number of values to be represented by slider in the horizontal direction
+		valuesX: 10,
+		// number of values to be represented by slider in the vertical direction
+		valuesY: 10,
+		// can values be changed on the x (horizontal) axis?
+		isEnableX: true,
+		// can values be changed on the y (vertical) axis?
+		isEnableY: true,
+		// value size (pixels) in the x dimension
+		valueSizeX: 0.0,
+		// value size (pixels) in the y dimension
+		valueSizeY: 0.0,
+		// initial value in the x dimension
+		initialValueX: 0,
+		// initial value in the y dimension
+		initialValueY: 0,
+
+		// do we allow the user to click on the slider to set the position?
+		// (note: dojo's infrastructor will convert attribute to a boolean)
+		clickSelect: true,
+		// should the handle snap to the grid or remain where it was dragged to?
+		// (note: dojo's infrastructor will convert attribute to a boolean)
+		snapToGrid: false,
+		// should the value change while you are dragging, or just after drag finishes?
+		activeDrag: false,
+
+		templateCssPath: dojo.uri.dojoUri ("src/widget/templates/HtmlSlider.css"),
+		templatePath: dojo.uri.dojoUri ("src/widget/templates/HtmlSlider.html"),
+
+		// our DOM nodes
+		sliderHandle: null,
+
+		// private attributes
+		// This is set to true when a drag is started, so that it is not confused
+		// with a click
+		isDragInProgress: false,
+
+
+		// This function is called when the template is loaded
+		fillInTemplate: function () 
+		{
+			// dojo.debug ("fillInTemplate - className = " + this.domNode.className);
+
+			// setup drag-n-drop for the sliderHandle
+			this.handleMove = new dojo.widget.html.SliderDragMoveSource (this.sliderHandle);
+			this.handleMove.setParent (this);
+			dojo.event.connect(this.handleMove, "onDragMove", this, "onDragMove");
+			dojo.event.connect(this.handleMove, "onDragEnd", this, "onDragEnd");
+			dojo.event.connect(this.handleMove, "onClick", this, "onClick");
+
+			// keep the slider handle inside it's parent container
+			this.handleMove.constrainToContainer = true;
+		
+			if (this.clickSelect) {
+				dojo.event.connect (this.domNode, "onclick", this, "setPosition");
+			} 
+
+			if (this.isEnableX && this.initialValueX > 0) {
+				alert("setting x to " + this.initialValueX);
+				this.setValueX (this.initialValueX);
+			}
+			if (this.isEnableY && this.initialValueY > 0) {
+				this.setValueY (this.initialValueY);
+			}
+		},
+
+
+		// Move the handle (in the x dimension) to the specified value
+		setValueX: function (value) {
+			if (0.0 == this.valueSizeX) {
+				this.valueSizeX = this.handleMove.calcValueSizeX ();
+			}
+			if (value > this.valuesX) {
+				value = this.valuesX;
+			}
+			else if (value < 0) {
+				value = 0;
+			}
+			//dojo.debug ("value = " + value, ", valueSizeX = " + this.valueSizeX);
+			this.handleMove.domNode.style.left = (value * this.valueSizeX) + "px";
+		},
+
+
+		// Get the number of the value that matches the position of the handle
+		getValueX: function () {
+			if (0.0 == this.valueSizeX) {
+				this.valueSizeX = this.handleMove.calcValueSizeX ();
+			}
+			return Math.round (dojo.style.getPixelValue (this.handleMove.domNode, "left") / this.valueSizeX);
+		},
+
+
+		// set the slider to a particular value
+		setValueY: function (value) {
+			if (0.0 == this.valueSizeY) {
+				this.valueSizeY = this.handleMove.calcValueSizeY ();
+			}
+			if (value > this.valuesY) {
+				value = this.valuesY;
+			}
+			else if (value < 0) {
+				value = 0;
+			}
+
+			this.handleMove.domNode.style.top = (value * this.valueSizeY) + "px";
+		},
+
+
+		// Get the number of the value that the matches the position of the handle
+		getValueY: function () {
+			if (0.0 == this.valueSizeY) {
+				this.valueSizeY = this.handleMove.calcValueSizeY ();
+			}
+			return Math.round (dojo.style.getPixelValue (this.handleMove.domNode, "top") / this.valueSizeY);
+		},
+
+
+		// set the position of the handle
+		setPosition: function (e) {
+			//dojo.debug ("Slider#setPosition - e.clientX = " + e.clientX
+			//            + ", e.clientY = " + e.clientY);
+			if (this.isDragInProgress) {
+				this.isDragInProgress = false;
+			}
+
+			var offset = dojo.html.getScrollOffset();
+			var parent = dojo.style.getAbsolutePosition(this.domNode, true);
+			
+			if (this.isEnableX) {
+				var x = offset.x + e.clientX - parent.x;
+				if (x > this.domNode.offsetWidth) {
+					x = this.domNode.offsetWidth;
+				}
+				if (this.snapToGrid && x > 0) {
+					if (0.0 == this.valueSizeX) {
+						this.valueSizeX = this.handleMove.calcValueSizeX ();
+					}
+					x = this.valueSizeX * (Math.round (x / this.valueSizeX));
+				}
+				this.handleMove.domNode.style.left = x + "px";
+			}
+			if (this.isEnableY) {
+				var y = offset.y + e.clientY - parent.y;
+				if (y > this.domNode.offsetHeight) {
+					y = this.domNode.offsetHeight;
+				}
+				if (this.snapToGrid && y > 0) {
+					if (0.0 == this.valueSizeY) {
+						this.valueSizeY = this.handleMove.calcValueSizeY ();
+					}
+					y = this.valueSizeY * (Math.round (y / this.valueSizeY));
+				}
+				this.handleMove.domNode.style.top = y + "px";
+			}
+		},
+
+		onDragMove: function(){
+			this.onValueChanged(this.getValueX(), this.getValueY());
+		},
+	
+		onClick: function(){
+			this.onValueChanged(this.getValueX(), this.getValueY());
+		},
+		
+		onValueChanged: function(x, y){
+		}
+	}
+);
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * Define the horizontal slider widget class.
+ */
+dojo.widget.defineWidget (
+	"dojo.widget.html.SliderHorizontal",
+	dojo.widget.html.Slider,
+	{
+		widgetType: "SliderHorizontal",
+
+		value: 0,
+
+		isEnableY: false,
+		templatePath: dojo.uri.dojoUri ("src/widget/templates/HtmlSliderHorizontal.html"),
+
+		postMixInProperties: function(){
+			this.initialValue = this.value;
+		},
+
+		// wrapper for getValueX
+		getValue: function () {
+			return this.getValueX ();
+		},
+
+		// wrapper for setValueX
+		setValue: function (value) {
+			this.setValueX (value);
+			this.onValueChanged(value);
+		},
+
+		onDragMove: function(){
+			if(this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onDragEnd: function(){
+			if(!this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onClick: function(){
+			this.onValueChanged(this.getValue());
+		},
+		
+		onValueChanged: function(value){
+			this.value=value;
+		}
+	}
+);
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * Define the vertical slider widget class.
+ */
+dojo.widget.defineWidget (
+	"dojo.widget.html.SliderVertical",
+	dojo.widget.html.Slider,
+	{
+		widgetType: "SliderVertical",
+
+		value: 0,
+
+		isEnableX: false,
+		templatePath: dojo.uri.dojoUri ("src/widget/templates/HtmlSliderVertical.html"),
+
+		postMixInProperties: function(){
+			this.initialValueY = this.value;
+		},
+
+		// wrapper for getValueY
+		getValue: function () {
+			return this.getValueY ();
+		},
+
+		// wrapper for setValueY
+		setValue: function (value) {
+			this.setValueY (value);
+		},
+
+		onDragMove: function(){
+			if(this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onDragEnd: function(){
+			if(!this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onClick: function(){
+			this.onValueChanged(this.getValue());
+		},
+		
+		onValueChanged: function(value){
+			this.value=value;
+		}
+	}
+);
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * This class extends the HtmlDragMoveSource class to provide
+ * features for the slider handle.
+ */
+dojo.declare (
+	"dojo.widget.html.SliderDragMoveSource",
+	dojo.dnd.HtmlDragMoveSource,
+{
+	isDragInProgress: false,
+	slider: null,
+
+
+	/** Setup the handle for drag
+	 *  Extends dojo.dnd.HtmlDragMoveSource by creating a SliderDragMoveSource */
+	onDragStart: function (e) {
+		this.isDragInProgress = true;
+		this.constrainToContainer = true;
+
+		var dragObj = this.createDragMoveObject ();
+		var constraints = null;
+
+
+		dojo.event.connect (dragObj, "onDragMove", this, "onDragMove");
+
+		return dragObj;
+	},
+
+
+	onDragMove: function (e) {
+		// placeholder to enable event connection
+	},
+
+
+	createDragMoveObject: function () {
+		//dojo.debug ("SliderDragMoveSource#createDragMoveObject - " + this.slider);
+		var dragObj = new dojo.widget.html.SliderDragMoveObject (this.dragObject, this.type);
+		dragObj.slider = this.slider;
+
+		// this code copied from dojo.dnd.HtmlDragSource#onDragStart
+		if (this.dragClass) { 
+			dragObj.dragClass = this.dragClass; 
+		}
+		if (this.constrainToContainer) {
+			dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
+		}
+		return dragObj;
+	},
+
+
+	setParent: function (slider) {
+		this.slider = slider;
+	},
+
+	
+	calcValueSizeX: function () {
+		var dragObj = this.createDragMoveObject ();
+		dragObj.containingBlockPosition = dragObj.domNode.offsetParent ? 
+		dojo.style.getAbsolutePosition(dragObj.domNode.offsetParent) : {x:0, y:0};
+		
+		var constraints = dragObj.getConstraints ();
+		return (constraints.maxX - constraints.minX) / this.slider.valuesX;
+	},
+
+	
+	calcValueSizeY: function () {
+		var dragObj = this.createDragMoveObject ();
+		dragObj.containingBlockPosition = dragObj.domNode.offsetParent ? 
+		dojo.style.getAbsolutePosition(dragObj.domNode.offsetParent) : {x:0, y:0};
+		var constraints = dragObj.getConstraints ();
+		return (constraints.maxY - constraints.minY) / this.slider.valuesY;
+	}
+});
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * This class extends the HtmlDragMoveObject class to provide
+ * features for the slider handle.
+ */
+dojo.declare (
+	"dojo.widget.html.SliderDragMoveObject",
+	dojo.dnd.HtmlDragMoveObject,
+{
+	// reference to dojo.widget.html.Slider
+	slider: null,
+
+	/** Moves the node to follow the mouse.
+	 *  Extends functon HtmlDragObject by adding functionality to snap handle
+	 *  to a discrete value */
+	onDragMove: function (e) {
+		if (this.slider.isEnableX && 0.0 == this.slider.valueSizeX) {
+			this.slider.valueSizeX = (this.constraints.maxX - this.constraints.minX) / this.slider.valuesX;
+		}
+		if (this.slider.isEnableY && 0.0 == this.slider.valueSizeY) {
+			this.slider.valueSizeY = (this.constraints.maxY - this.constraints.minY) / this.slider.valuesY;
+		}
+
+		this.updateDragOffset ();
+
+		var x = this.dragOffset.x + e.pageX;
+		var y = this.dragOffset.y + e.pageY;
+
+		if (this.constrainToContainer) {
+			if (x < this.constraints.minX) { x = this.constraints.minX; }
+			if (y < this.constraints.minY) { y = this.constraints.minY; }
+			if (x > this.constraints.maxX) { x = this.constraints.maxX; }
+			if (y > this.constraints.maxY) { y = this.constraints.maxY; }
+		}
+
+		if (this.slider.isEnableX) {
+			var selectedValue = 0;
+			if (x > 0) {
+				selectedValue = Math.round (x / this.slider.valueSizeX);
+			}
+			// dojo.debug ("x = " + x + ", valueSize = " + valueSize 
+			//             + ", selectedValue = " + selectedValue);
+			x = (selectedValue * this.slider.valueSizeX);
+		}
+
+		if (this.slider.isEnableY) {
+			var selectedValue = 0;
+			if (y > 0) {
+				selectedValue = Math.round (y / this.slider.valueSizeY);
+			}
+			y = (selectedValue * this.slider.valueSizeY);
+		}
+
+		this.setAbsolutePosition (x, y);
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/SortableTable.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/SortableTable.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/SortableTable.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,582 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.SortableTable");
+dojo.require("dojo.lang");
+dojo.require("dojo.date");
+dojo.require("dojo.html");
+dojo.require("dojo.event.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.SortableTable");
+
+dojo.widget.html.SortableTable=function(){
+	//	summary
+	//	Constructor for the SortableTable widget
+	dojo.widget.SortableTable.call(this);
+	dojo.widget.HtmlWidget.call(this);
+
+	this.headClass="";
+	this.tbodyClass="";
+	this.headerClass="";
+	this.headerSortUpClass="selected";
+	this.headerSortDownClass="selected";
+	this.rowClass="";
+	this.rowAlternateClass="alt";
+	this.rowSelectedClass="selected";
+	this.columnSelected="sorted-column";
+};
+dojo.inherits(dojo.widget.html.SortableTable, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.SortableTable, {
+	templatePath:null,
+	templateCssPath:null,
+
+	getTypeFromString:function(/* string */ s){
+		//	summary
+		//	Find the constructor that matches param s by searching through the entire object tree.
+		var parts=s.split("."),i=0,obj=dj_global; 
+		do{obj=obj[parts[i++]];}while(i<parts.length&&obj); 
+		return(obj!=dj_global)?obj:null;	//	function
+	},
+	compare:function(/* object */ o1, /* object */ o2){
+		//	summary
+		//	Compare two objects using a shallow property compare
+		for(var p in o1){
+			if(!(p in o2)) return false;	//	boolean
+			if(o1[p].valueOf()!=o2[p].valueOf()) return false;	//	boolean
+		}
+		return true;	// boolean
+	},
+	isSelected:function(/* object */ o){
+		//	summary
+		//	checked to see if the passed object is in the current selection.
+		for(var i=0;i<this.selected.length;i++){
+			if(this.compare(this.selected[i],o)){
+				return true; // boolean
+			}
+		}
+		return false;	// boolean
+	},
+	removeFromSelected:function(/* object */ o){
+		//	summary
+		//	remove the passed object from the current selection.
+		var idx=-1;
+		for(var i=0;i<this.selected.length;i++){
+			if(this.compare(this.selected[i],o)){
+				idx=i;
+				break;
+			}
+		}
+		if(idx>=0){
+			this.selected.splice(idx,1);
+		}
+	},
+	getSelection:function(){
+		//	summary
+		//	return the array of currently selected objects (JSON format)
+		return this.selected;	//	array
+	},
+	getValue:function(){
+		//	summary
+		//	return a comma-delimited list of selected valueFields.
+		var a=[];
+		for(var i=0;i<this.selected.length;i++){
+			if (this.selected[i][this.valueField]){
+				a.push(this.selected[i][this.valueField]);
+			}
+		}
+		return a.join();	//	string
+	},
+	reset:function(){
+		//	summary
+		//	completely resets the internal representations.
+		this.columns=[];
+		this.data=[];
+		this.resetSelections(this.domNode.getElementsByTagName("tbody")[0]);
+	},
+	resetSelections:function(/* HTMLTableBodyElement */ body){
+		this.selected=[];
+		var idx=0;
+		var rows=body.getElementsByTagName("tr");
+		for(var i=0; i<rows.length; i++){
+			if(rows[i].parentNode==body){
+				rows[i].removeAttribute("selected");
+				if(this.enableAlternateRows&&idx%2==1){
+					rows[i].className=this.rowAlternateClass;
+				}else{
+					rows[i].className="";
+				}
+				idx++;
+			}
+		}
+	},
+
+	getObjectFromRow:function(/* HTMLTableRowElement */ row){
+		//	summary
+		//	creates a JSON object based on the passed row
+		var cells=row.getElementsByTagName("td");
+		var o={};
+		for(var i=0; i<this.columns.length;i++){
+			if(this.columns[i].sortType=="__markup__"){
+				//	FIXME: should we parse this instead?  Because if the user may not get back the markup they put in...
+				o[this.columns[i].getField()]=cells[i].innerHTML;
+			}else{
+				var text=dojo.html.renderedTextContent(cells[i]);
+				var val=new (this.columns[i].getType())(text);
+				o[this.columns[i].getField()]=val;
+			}
+		}
+		if(dojo.html.hasAttribute(row,"value")){
+			o[this.valueField]=dojo.html.getAttribute(row,"value");
+		}
+		return o;	//	object
+	},
+	setSelectionByRow:function(/* HTMLTableElementRow */ row){
+		//	summary
+		//	create the selection object based on the passed row, makes sure it's unique.
+		//	note that you need to call render manually (because of multi-select operations)
+		var o=this.getObjectFromRow(row);
+		var b=false;
+		for(var i=0;i<this.selected.length;i++){
+			if(this.compare(this.selected[i], o)){
+				b=true;
+				break;
+			}
+		}
+		if(!b){
+			this.selected.push(o);
+		}
+	},
+
+	parseColumns:function(/* HTMLTableHeadElement */ node){
+		//	summary
+		//	parses the passed element to create column objects
+		this.reset();
+		var row=node.getElementsByTagName("tr")[0];
+		var cells=row.getElementsByTagName("td");
+		if (cells.length==0) cells=row.getElementsByTagName("th");
+		for(var i=0; i<cells.length; i++){
+			var o={
+				field:null,
+				format:null,
+				noSort:false,
+				sortType:"String",
+				dataType:String,
+				sortFunction:null,
+				label:null,
+				align:"left",
+				valign:"middle",
+				getField:function(){ return this.field||this.label; },
+				getType:function(){ return this.dataType; }
+			};
+			//	presentation attributes
+			if(dojo.html.hasAttribute(cells[i], "align")){
+				o.align=dojo.html.getAttribute(cells[i],"align");
+			}
+			if(dojo.html.hasAttribute(cells[i], "valign")){
+				o.valign=dojo.html.getAttribute(cells[i],"valign");
+			}
+
+			//	sorting features.
+			if(dojo.html.hasAttribute(cells[i], "nosort")){
+				o.noSort=dojo.html.getAttribute(cells[i],"nosort")=="true";
+			}
+			if(dojo.html.hasAttribute(cells[i], "sortusing")){
+				var trans=dojo.html.getAttribute(cells[i],"sortusing");
+				var f=this.getTypeFromString(trans);
+				if (f!=null && f!=window && typeof(f)=="function") 
+					o.sortFunction=f;
+			}
+
+			if(dojo.html.hasAttribute(cells[i], "field")){
+				o.field=dojo.html.getAttribute(cells[i],"field");
+			}
+			if(dojo.html.hasAttribute(cells[i], "format")){
+				o.format=dojo.html.getAttribute(cells[i],"format");
+			}
+			if(dojo.html.hasAttribute(cells[i], "dataType")){
+				var sortType=dojo.html.getAttribute(cells[i],"dataType");
+				if(sortType.toLowerCase()=="html"||sortType.toLowerCase()=="markup"){
+					o.sortType="__markup__";	//	always convert to "__markup__"
+					o.noSort=true;
+				}else{
+					var type=this.getTypeFromString(sortType);
+					if(type){
+						o.sortType=sortType;
+						o.dataType=type;
+					}
+				}
+			}
+			o.label=dojo.html.renderedTextContent(cells[i]);
+			this.columns.push(o);
+
+			//	check to see if there's a default sort, and set the properties necessary
+			if(dojo.html.hasAttribute(cells[i], "sort")){
+				this.sortIndex=i;
+				var dir=dojo.html.getAttribute(cells[i], "sort");
+				if(!isNaN(parseInt(dir))){
+					dir=parseInt(dir);
+					this.sortDirection=(dir!=0)?1:0;
+				}else{
+					this.sortDirection=(dir.toLowerCase()=="desc")?1:0;
+				}
+			}
+		}
+	},
+
+	parseData:function(/* array */ data){
+		//	summary
+		//	Parse the passed JSON data structure, and cast based on columns.
+		this.data=[];
+		this.selected=[];
+		for(var i=0; i<data.length; i++){
+			var o={};	//	new data object.
+			for(var j=0; j<this.columns.length; j++){
+				var field=this.columns[j].getField();
+				if(this.columns[j].sortType=="__markup__"){
+					o[field]=String(data[i][field]);
+				}else{
+					var type=this.columns[j].getType();
+					var val=data[i][field];
+					var t=this.columns[j].sortType.toLowerCase();
+					if(val){
+						o[field]=new type(val);
+					}else{
+						o[field]=new type();	//	let it use the default.
+					}
+				}
+			}
+			//	check for the valueField if not already parsed.
+			if(data[i][this.valueField]&&!o[this.valueField]){
+				o[this.valueField]=data[i][this.valueField];
+			}
+			this.data.push(o);
+		}
+	}, 
+
+	parseDataFromTable:function(/* HTMLTableBodyElement */ tbody){
+		//	summary
+		//	parses the data in the tbody of a table to create a set of objects.
+		//	Will add objects to this.selected if an attribute 'selected="true"' is present on the row.
+		this.data=[];
+		this.selected=[];
+		var rows=tbody.getElementsByTagName("tr");
+		for(var i=0; i<rows.length; i++){
+			if(dojo.html.getAttribute(rows[i],"ignoreIfParsed")=="true"){
+				continue;
+			}
+			var o={};	//	new data object.
+			var cells=rows[i].getElementsByTagName("td");
+			for(var j=0; j<this.columns.length; j++){
+				var field=this.columns[j].getField();
+				if(this.columns[j].sortType=="__markup__"){
+					//	FIXME: parse this?
+					o[field]=cells[j].innerHTML;
+				}else{
+					var type=this.columns[j].getType();
+					var val=dojo.html.renderedTextContent(cells[j]); //	should be the same index as the column.
+					if (val) o[field]=new type(val);
+					else o[field]=new type();	//	let it use the default.
+				}
+			}
+			if(dojo.html.hasAttribute(rows[i],"value")&&!o[this.valueField]){
+				o[this.valueField]=dojo.html.getAttribute(rows[i],"value");
+			}
+			//	FIXME: add code to preserve row attributes in __metadata__ field?
+			this.data.push(o);
+			
+			//	add it to the selections if selected="true" is present.
+			if(dojo.html.getAttribute(rows[i],"selected")=="true"){
+				this.selected.push(o);
+			}
+		}
+	},
+	
+	showSelections:function(){
+		var body=this.domNode.getElementsByTagName("tbody")[0];
+		var rows=body.getElementsByTagName("tr");
+		var idx=0;
+		for(var i=0; i<rows.length; i++){
+			if(rows[i].parentNode==body){
+				if(dojo.html.getAttribute(rows[i],"selected")=="true"){
+					rows[i].className=this.rowSelectedClass;
+				} else {
+					if(this.enableAlternateRows&&idx%2==1){
+						rows[i].className=this.rowAlternateClass;
+					}else{
+						rows[i].className="";
+					}
+				}
+				idx++;
+			}
+		}
+	},
+	render:function(bDontPreserve){
+		//	summary
+		//	renders the table to the browser
+		var data=[];
+		var body=this.domNode.getElementsByTagName("tbody")[0];
+
+		if(!bDontPreserve){
+			//	rebuild data and selection
+			this.parseDataFromTable(body);
+		}
+
+		//	clone this.data for sorting purposes.
+		for(var i=0; i<this.data.length; i++){
+			data.push(this.data[i]);
+		}
+		
+		var col=this.columns[this.sortIndex];
+		if(!col.noSort){
+			var field=col.getField();
+			if(col.sortFunction){
+				var sort=col.sortFunction;
+			}else{
+				var sort=function(a,b){
+					if (a[field]>b[field]) return 1;
+					if (a[field]<b[field]) return -1;
+					return 0;
+				}
+			}
+			data.sort(sort);
+			if(this.sortDirection!=0) data.reverse();
+		}
+
+		//	build the table and pop it in.
+		while(body.childNodes.length>0) body.removeChild(body.childNodes[0]);
+		for(var i=0; i<data.length;i++){
+			var row=document.createElement("tr");
+			dojo.html.disableSelection(row);
+			if (data[i][this.valueField]){
+				row.setAttribute("value",data[i][this.valueField]);
+			}
+			if(this.isSelected(data[i])){
+				row.className=this.rowSelectedClass;
+				row.setAttribute("selected","true");
+			} else {
+				if(this.enableAlternateRows&&i%2==1){
+					row.className=this.rowAlternateClass;
+				}
+			}
+			for(var j=0;j<this.columns.length;j++){
+				var cell=document.createElement("td");
+				cell.setAttribute("align", this.columns[j].align);
+				cell.setAttribute("valign", this.columns[j].valign);
+				dojo.html.disableSelection(cell);
+				if(this.sortIndex==j){
+					cell.className=this.columnSelected;
+				}
+				if(this.columns[j].sortType=="__markup__"){
+					cell.innerHTML=data[i][this.columns[j].getField()];
+					for(var k=0; k<cell.childNodes.length; k++){
+						var node=cell.childNodes[k];
+						if(node&&node.nodeType==dojo.html.ELEMENT_NODE){
+							dojo.html.disableSelection(node);
+						}
+					}
+				}else{
+					if(this.columns[j].getType()==Date){
+						var format=this.defaultDateFormat;
+						if(this.columns[j].format) format=this.columns[j].format;
+						cell.appendChild(document.createTextNode(dojo.date.format(data[i][this.columns[j].getField()], format)));
+					}else{
+						cell.appendChild(document.createTextNode(data[i][this.columns[j].getField()]));
+					}
+				}
+				row.appendChild(cell);
+			}
+			body.appendChild(row);
+			dojo.event.connect(row, "onclick", this, "onUISelect");
+		}
+		
+		//	if minRows exist.
+		var minRows=parseInt(this.minRows);
+		if (!isNaN(minRows) && minRows>0 && data.length<minRows){
+			var mod=0;
+			if(data.length%2==0) mod=1;
+			var nRows=minRows-data.length;
+			for(var i=0; i<nRows; i++){
+				var row=document.createElement("tr");
+				row.setAttribute("ignoreIfParsed","true");
+				if(this.enableAlternateRows&&i%2==mod){
+					row.className=this.rowAlternateClass;
+				}
+				for(var j=0;j<this.columns.length;j++){
+					var cell=document.createElement("td");
+					cell.appendChild(document.createTextNode("\u00A0"));
+					row.appendChild(cell);
+				}
+				body.appendChild(row);
+			}
+		}
+	},
+
+	//	the following the user can override.
+	onSelect:function(/* DomEvent */ e){ 
+		//	summary
+		//	empty function for the user to attach code to, fired by onUISelect
+	},
+	onUISelect:function(/* DomEvent */ e){
+		//	summary
+		//	fired when a user selects a row
+		var row=dojo.html.getParentByType(e.target,"tr");
+		var body=dojo.html.getParentByType(row,"tbody");
+		if(this.enableMultipleSelect){
+			if(e.metaKey||e.ctrlKey){
+				if(this.isSelected(this.getObjectFromRow(row))){
+					this.removeFromSelected(this.getObjectFromRow(row));
+					row.removeAttribute("selected");
+				}else{
+					//	push onto the selection stack.
+					this.setSelectionByRow(row);
+					row.setAttribute("selected","true");
+				}
+			}else if(e.shiftKey){
+				//	the tricky one.  We need to figure out the *last* selected row above, 
+				//	and select all the rows in between.
+				var startRow;
+				var rows=body.getElementsByTagName("tr");
+				//	if there's a selection above, we go with that first. 
+				for(var i=0;i<rows.length;i++){
+					if(rows[i].parentNode==body){
+						if(rows[i]==row) break;
+						if(dojo.html.getAttribute(rows[i],"selected")=="true"){
+							startRow=rows[i];
+						}
+					}
+				}
+				//	if there isn't a selection above, we continue with a selection below.
+				if(!startRow){
+					startRow=row;
+					for(;i<rows.length;i++){
+						if(dojo.html.getAttribute(rows[i],"selected")=="true"){
+							row=rows[i];
+							break;
+						}
+					}
+				}
+				this.resetSelections(body);
+				if(startRow==row){
+					//	this is the only selection
+					row.setAttribute("selected","true");
+					this.setSelectionByRow(row);
+				}else{
+					var doSelect=false;
+					for(var i=0; i<rows.length; i++){
+						if(rows[i].parentNode==body){
+							rows[i].removeAttribute("selected");
+							if(rows[i]==startRow){
+								doSelect=true;
+							}
+							if(doSelect){
+								this.setSelectionByRow(rows[i]);
+								rows[i].setAttribute("selected","true");
+							}
+							if(rows[i]==row){
+								doSelect=false;
+							}
+						}
+					}
+				}
+			}else{
+				//	reset the selection
+				this.resetSelections(body);
+				row.setAttribute("selected","true");
+				this.setSelectionByRow(row);
+			}
+		}else{
+			//	reset the data selection and go.
+			this.resetSelections(body);
+			row.setAttribute("selected","true");
+			this.setSelectionByRow(row);
+		}
+		this.showSelections();
+		this.onSelect(e);
+		e.stopPropagation();
+		e.preventDefault();
+	},
+	onHeaderClick:function(/* DomEvent */ e){
+		//	summary
+		//	Main handler function for each header column click.
+		var oldIndex=this.sortIndex;
+		var oldDirection=this.sortDirection;
+		var source=e.target;
+		var row=dojo.html.getParentByType(source,"tr");
+		var cellTag="td";
+		if(row.getElementsByTagName(cellTag).length==0) cellTag="th";
+
+		var headers=row.getElementsByTagName(cellTag);
+		var header=dojo.html.getParentByType(source,cellTag);
+		
+		for(var i=0; i<headers.length; i++){
+			if(headers[i]==header){
+				if(i!=oldIndex){
+					//	new col.
+					this.sortIndex=i;
+					this.sortDirection=0;
+					headers[i].className=this.headerSortDownClass
+				}else{
+					this.sortDirection=(oldDirection==0)?1:0;
+					if(this.sortDirection==0){
+						headers[i].className=this.headerSortDownClass;
+					}else{
+						headers[i].className=this.headerSortUpClass;
+					}
+				}
+			}else{
+				//	reset the header class.
+				headers[i].className=this.headerClass;
+			}
+		}
+		this.render();
+	},
+
+	postCreate:function(){ 
+		// 	summary
+		//	overridden from HtmlWidget, initializes and renders the widget.
+		var thead=this.domNode.getElementsByTagName("thead")[0];
+		if(this.headClass.length>0){
+			thead.className=this.headClass;
+		}
+
+		//	disable selections
+		dojo.html.disableSelection(this.domNode);
+
+		//	parse the columns.
+		this.parseColumns(thead);
+
+		//	attach header handlers.
+		var header="td";
+		if(thead.getElementsByTagName(header).length==0) header="th";
+		var headers=thead.getElementsByTagName(header);
+		for(var i=0; i<headers.length; i++){
+			if(!this.columns[i].noSort){
+				dojo.event.connect(headers[i], "onclick", this, "onHeaderClick");
+			}
+			if(this.sortIndex==i){
+				if(this.sortDirection==0){
+					headers[i].className=this.headerSortDownClass;
+				}else{
+					headers[i].className=this.headerSortUpClass;
+				}
+			}
+		}
+
+		//	parse the tbody element and re-render it.
+		var tbody=this.domNode.getElementsByTagName("tbody")[0];
+		if (this.tbodyClass.length>0) {
+			tbody.className=this.tbodyClass;
+		}
+
+		this.parseDataFromTable(tbody);
+		this.render(true);
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/Spinner.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Spinner.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Spinner.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,383 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.Spinner");
+dojo.require("dojo.widget.Spinner");
+dojo.require("dojo.widget.Manager.*");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.io.*");
+dojo.require("dojo.lfx.*");
+dojo.require("dojo.dom");
+dojo.require("dojo.html");
+dojo.require("dojo.string");
+dojo.require("dojo.widget.html.stabile");
+
+dojo.widget.html.Spinner = function(){
+	dojo.widget.Spinner.call(this);
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.Spinner, dojo.widget.HtmlWidget);
+
+// copied from superclass since we can't really over-ride via prototype
+dojo.lang.extend(dojo.widget.html.Spinner, dojo.widget.Spinner.defaults);
+
+dojo.lang.extend(dojo.widget.html.Spinner, {
+
+	name: "", // clone in the name from the DOM node
+	inputNode: null,
+	upArrowNode: null,
+	downArrowNode: null,
+	absNode: null,
+	relNode: null,
+	innerRelNode: null,
+	spacerNode: null,
+	inputWidgetId: "",
+	inputWidget: null,
+	typamaticTimer: null,
+	typamaticFunction: null,
+	defaultTimeout: 500,
+	currentTimeout: this.defaultTimeout,
+	eventCount: 0,
+
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlSpinner.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlSpinner.css"),
+
+	setValue: function(value){
+		this.inputWidget.setValue(value);
+		this.inputWidget.adjustValue(0);
+		dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
+	},
+
+	getValue: function(){
+		return this.inputWidget.getValue();
+	},
+
+	getState: function(){
+		return {value: this.getValue()};
+	},
+
+	setState: function(state){
+		this.setValue(state.value);
+	},
+
+	// does the keyboard related stuff
+	_handleKeyEvents: function(evt){
+		var k = dojo.event.browser.keys;
+		var keyCode = evt.keyCode;
+
+		switch(keyCode){
+ 			case k.KEY_DOWN_ARROW:
+				dojo.event.browser.stopEvent(evt);
+				this.downArrowPressed(evt);
+				return;
+			case k.KEY_UP_ARROW:
+				dojo.event.browser.stopEvent(evt);
+				this.upArrowPressed(evt);
+				return;
+		}
+		this.eventCount++;
+
+	},
+
+	onKeyDown: function(evt){
+		// IE needs to stop keyDown others need to stop keyPress
+		if(!document.createEvent){ // only IE
+			this._handleKeyEvents(evt);
+		}
+	},
+
+	onKeyPress: function(evt){
+		if(document.createEvent){ // never IE
+			this._handleKeyEvents(evt);
+		}
+	},
+
+	fillInTemplate: function(args, frag){
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+	},
+
+
+	resizeUpArrow: function(){
+		var newh = dojo.style.getContentBoxHeight(this.inputNode) >> 1;
+		if(newh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, "resizeUpArrow", 100);
+			return;
+		}
+		var oldh = this.upArrowNode.height;
+		if(oldh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, "resizeUpArrow", 100);
+			return;
+		}
+		var ratio = newh / oldh;
+		this.upArrowNode.width=Math.floor(this.upArrowNode.width * ratio);
+		this.upArrowNode.height=newh;
+	},
+
+	resizeDownArrow: function(){
+		var newh = dojo.style.getContentBoxHeight(this.inputNode) >> 1;
+		if(newh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, "resizeDownArrow", 100);
+			return;
+		}
+		var oldh = this.downArrowNode.height;
+		if(oldh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, "resizeDownArrow", 100);
+			return;
+		}
+		var ratio = newh / oldh;
+		this.downArrowNode.width=Math.floor(this.downArrowNode.width * ratio);
+		this.downArrowNode.height=newh;
+	},
+
+	resizeSpacer: function(){
+		var newh = dojo.style.getContentBoxHeight(this.inputNode) >> 1;
+		if( newh==0 ){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, "resizeSpacer", 100);
+			return;
+		}
+		var oldh = this.downArrowNode.height;
+		if( oldh==0 ){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, "resizeSpacer", 100);
+			return;
+		}
+		var ratio = newh / oldh;
+		this.spacerNode.width=Math.floor(this.spacerNode.width * ratio);
+		this.spacerNode.height=newh;
+	},
+
+	_pressButton: function(node){
+		with(node.style){
+			borderRight = "0px";
+			borderBottom = "0px";
+			borderLeft = "1px solid black";
+			borderTop = "1px solid black";
+		}
+	},
+
+	_releaseButton: function(node){
+		with(node.style){
+			borderLeft = "0px";
+			borderTop = "0px";
+			borderRight = "1px solid gray";
+			borderBottom = "1px solid gray";
+		}
+	},
+
+	downArrowPressed: function(evt){
+		if(typeof evt != "number"){
+		    if(this.typamaticTimer != null){
+				if(this.typamaticFunction == this.downArrowPressed){
+					return;
+				}
+		        clearTimeout(this.typamaticTimer);
+		    }
+		    this._releaseButton(this.upArrowNode);
+		    this.eventCount++;
+		    this.typamaticTimer = null;
+		    this.currentTimeout = this.defaultTimeout;
+
+		}else if (evt != this.eventCount){
+		    this._releaseButton(this.downArrowNode);
+		    return;
+		}
+		this._pressButton(this.downArrowNode);
+		this.setCursorX(this.inputWidget.adjustValue(-1,this.getCursorX()));
+		this.typamaticFunction = this.downArrowPressed;
+		this.typamaticTimer = setTimeout( dojo.lang.hitch(this,function(){this.downArrowPressed(this.eventCount);}), this.currentTimeout);
+		this.currentTimeout = Math.round(this.currentTimeout * 90 / 100);
+	},
+
+	upArrowPressed: function(evt){
+		if(typeof evt != "number"){
+		    if(this.typamaticTimer != null){
+				if(this.typamaticFunction == this.upArrowPressed){
+					return;
+				}
+		        clearTimeout(this.typamaticTimer);
+		    }
+		    this._releaseButton(this.downArrowNode);
+		    this.eventCount++;
+		    this.typamaticTimer = null;
+		    this.currentTimeout = this.defaultTimeout;
+		}else if(evt != this.eventCount) {
+		    this._releaseButton(this.upArrowNode);
+		    return;
+		}
+		this._pressButton(this.upArrowNode);
+		this.setCursorX(this.inputWidget.adjustValue(+1,this.getCursorX()));
+		this.typamaticFunction = this.upArrowPressed;
+		this.typamaticTimer = setTimeout( dojo.lang.hitch(this,function(){this.upArrowPressed(this.eventCount);}), this.currentTimeout);
+		this.currentTimeout = Math.round(this.currentTimeout * 90 / 100);
+	},
+
+	arrowReleased: function(evt){
+		this.inputNode.focus();
+		if(evt.keyCode && evt.keyCode != null){
+			var keyCode = evt.keyCode;
+			var k = dojo.event.browser.keys;
+
+			switch(keyCode){
+				case k.KEY_DOWN_ARROW:
+				case k.KEY_UP_ARROW:
+					dojo.event.browser.stopEvent(evt);
+					break;
+			}
+		}
+		this._releaseButton(this.upArrowNode);
+		this._releaseButton(this.downArrowNode);
+		this.eventCount++;
+		if(this.typamaticTimer != null){
+		    clearTimeout(this.typamaticTimer);
+		}
+		this.typamaticTimer = null;
+		this.currentTimeout = this.defaultTimeout;
+	},
+
+	mouseWheeled: function(evt) {
+		var scrollAmount = 0;
+		if(typeof evt.wheelDelta == 'number'){ // IE
+		    scrollAmount = evt.wheelDelta;
+		}else if (typeof evt.detail == 'number'){ // Mozilla+Firefox
+		    scrollAmount = -evt.detail;
+		}
+		if(scrollAmount > 0){
+		    this.upArrowPressed(evt);
+		    this.arrowReleased(evt);
+		}else if (scrollAmount < 0){
+		    this.downArrowPressed(evt);
+		    this.arrowReleased(evt);
+		}
+	},
+
+	getCursorX: function(){
+		var x = -1;
+		try{
+		    this.inputNode.focus();
+		    if (typeof this.inputNode.selectionEnd == "number"){
+				x = this.inputNode.selectionEnd;
+		    }else if (document.selection && document.selection.createRange) {
+				var range = document.selection.createRange().duplicate();
+				if(range.parentElement() == this.inputNode){
+					range.moveStart('textedit', -1);
+					x = range.text.length;
+				}
+		    }
+		}catch(e){ /* squelch! */ }
+		return x;
+	},
+
+	setCursorX: function(x){
+		try{
+			this.inputNode.focus();
+		    if(!x){ x = 0 }
+		    if(typeof this.inputNode.selectionEnd == "number"){
+		        this.inputNode.selectionEnd = x;
+		    }else if(this.inputNode.createTextRange){
+		        var range = this.inputNode.createTextRange();
+		        range.collapse(true);
+		        range.moveEnd('character', x);
+		        range.moveStart('character', x);
+		        range.select();
+		    }
+		}catch(e){ /* squelch! */ }
+	},
+
+	postCreate: function(){
+		this.domNode.style.display="none";
+
+		if((typeof this.inputWidgetId != 'string')||(this.inputWidgetId.length == 0)){
+		    var w=dojo.widget.manager.getAllWidgets();
+		    for(var i=w.length-1; i>=0; i--){
+		        if(w[i].adjustValue){
+					this.inputWidget = w[i];
+					break;
+		        }
+		    }
+		}else{
+		    this.inputWidget = dojo.widget.getWidgetById(this.inputWidgetId);
+		}
+
+		if(typeof this.inputWidget != 'object'){
+			dojo.lang.setTimeout(this, "postCreate", 100); 
+			return;
+		}
+		var widgetNode = this.inputWidget.domNode;
+		var inputNodes = widgetNode.getElementsByTagName('INPUT');
+		this.inputNode = inputNodes[0];
+
+		/*
+		// unlink existing dom nodes from domNode
+		this.downArrowNode = dojo.dom.removeNode(this.downArrowNode);
+		this.upArrowNode = dojo.dom.removeNode(this.upArrowNode);
+		this.spacerNode = dojo.dom.removeNode(this.spacerNode);
+		this.innerRelNode = dojo.dom.removeNode(this.innerRelNode);
+		this.absNode = dojo.dom.removeNode(this.absNode);
+		this.relNode = dojo.dom.removeNode(this.relNode);
+		*/
+
+		// create a disconnected node
+		this.innerRelNode.appendChild(this.upArrowNode);
+		this.innerRelNode.appendChild(this.downArrowNode);
+		this.absNode.appendChild(this.innerRelNode);
+		this.relNode.appendChild(this.absNode);
+		this.relNode.appendChild(this.spacerNode);
+
+		dojo.event.connect(this.inputNode, "onkeypress", this, "onKeyPress");
+		dojo.event.connect(this.inputNode, "onkeydown", this, "onKeyDown");
+		dojo.event.connect(this.inputNode, "onkeyup", this, "arrowReleased");
+		dojo.event.connect(this.downArrowNode, "onmousedown", this, "downArrowPressed");
+		dojo.event.connect(this.downArrowNode, "onmouseup", this, "arrowReleased");
+		dojo.event.connect(this.upArrowNode, "onmousedown", this, "upArrowPressed");
+		dojo.event.connect(this.upArrowNode, "onmouseup", this, "arrowReleased");
+		if(this.inputNode.addEventListener){
+			// FIXME: why not use dojo.event.connect() to DOMMouseScroll here?
+		    this.inputNode.addEventListener('DOMMouseScroll', dojo.lang.hitch(this, "mouseWheeled"), false); // Mozilla + Firefox + Netscape
+		}else{
+		    dojo.event.connect(this.inputNode, "onmousewheel", this, "mouseWheeled"); // IE + Safari
+		}
+
+		this.resizeDownArrow();
+		this.resizeUpArrow();
+		this.resizeSpacer();
+
+		// make sure the disconnected node will fit right next to the INPUT tag w/o any interference
+		dojo.html.copyStyle(this.relNode, this.inputNode);
+		with(this.relNode.style){
+			display = "inline";
+			position = "relative";
+			backgroundColor = "";
+			marginLeft = "-1px";
+			paddingLeft = "0";
+		}
+		this.inputNode.style.marginRight = "0px";
+		this.inputNode.style.paddingRight = "0px";
+
+		// add the disconnected node right after the INPUT tag
+		dojo.dom.insertAfter(this.relNode, this.inputNode, false);
+		this.domNode = dojo.dom.removeNode(this.domNode);
+		// realign the spinner vertically in case there's a slight difference
+		var absOffset = dojo.html.getAbsoluteY(this.relNode,true)-dojo.html.getAbsoluteY(this.absNode,true);
+		this.absNode.style.top = absOffset-dojo.style.getBorderExtent(this.inputNode, "top")+"px";
+
+		var s = dojo.widget.html.stabile.getState(this.widgetId);
+		this.setValue(this.getValue());
+		if(s){
+			this.setState(s);
+		}
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/TaskBar.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/TaskBar.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/TaskBar.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,85 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.TaskBar");
+dojo.provide("dojo.widget.html.TaskBarItem");
+
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.FloatingPane");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.event");
+
+// Icon associated w/a floating pane
+dojo.widget.html.TaskBarItem = function(){
+	dojo.widget.TaskBarItem.call(this);
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.TaskBarItem, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.TaskBarItem, {
+	// constructor arguments
+	iconSrc: '',
+	caption: 'Untitled',
+	window: null,
+	templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlTaskBarItemTemplate.html"),
+	templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlTaskBar.css"),
+
+	fillInTemplate: function() {
+		if ( this.iconSrc != '' ) {
+			var img = document.createElement("img");
+			img.src = this.iconSrc;
+			this.domNode.appendChild(img);
+		}
+		this.domNode.appendChild(document.createTextNode(this.caption));
+		dojo.html.disableSelection(this.domNode);
+	},
+
+	postCreate: function() {
+		this.window=dojo.widget.getWidgetById(this.windowId);
+		this.window.explodeSrc = this.domNode;
+		dojo.event.connect(this.window, "destroy", this, "destroy")
+	},
+
+	onClick: function() {
+		this.window.show();
+	}
+});
+
+// Collection of widgets in a bar, like Windows task bar
+dojo.widget.html.TaskBar = function(){
+
+	dojo.widget.html.FloatingPane.call(this);
+	dojo.widget.TaskBar.call(this);
+	this._addChildStack = [];
+}
+
+dojo.inherits(dojo.widget.html.TaskBar, dojo.widget.html.FloatingPane);
+
+dojo.lang.extend(dojo.widget.html.TaskBar, {
+
+	resizable: false,
+	titleBarDisplay: "none",
+
+	addChild: function(child) {
+		if(!this.containerNode){ 
+			this._addChildStack.push(child);
+		}else if(this._addChildStack.length > 0){
+			var oarr = this._addChildStack;
+			this._addChildStack = [];
+			dojo.lang.forEach(oarr, this.addChild, this);
+		}
+		var tbi = dojo.widget.createWidget("TaskBarItem",
+			{	windowId: child.widgetId, 
+				caption: child.title, 
+				iconSrc: child.iconSrc
+			});
+		dojo.widget.html.TaskBar.superclass.addChild.call(this,tbi);
+	}
+});

Added: tags/parley-0.53/root/static/magic/src/widget/html/TimePicker.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/TimePicker.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/TimePicker.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,249 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.TimePicker");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.TimePicker");
+dojo.require("dojo.event.*");
+dojo.require("dojo.date");
+dojo.require("dojo.html");
+
+dojo.widget.html.TimePicker = function(){
+	dojo.widget.TimePicker.call(this);
+	dojo.widget.HtmlWidget.call(this);
+
+
+	var _this = this;
+	// selected time, JS Date object
+	this.time = "";
+	// set following flag to true if a default time should be set
+	this.useDefaultTime = false;
+	// set the following to true to set default minutes to current time, false to // use zero
+	this.useDefaultMinutes = false;
+	// rfc 3339 date
+	this.storedTime = "";
+	// time currently selected in the UI, stored in hours, minutes, seconds in the format that will be actually displayed
+	this.currentTime = {};
+	this.classNames = {
+		selectedTime: "selectedItem"
+	}
+	this.any = "any"
+	// dom node indecies for selected hour, minute, amPm, and "any time option"
+	this.selectedTime = {
+		hour: "",
+		minute: "",
+		amPm: "",
+		anyTime: false
+	}
+
+	// minutes are ordered as follows: ["12", "6", "1", "7", "2", "8", "3", "9", "4", "10", "5", "11"]
+	this.hourIndexMap = ["", 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11, 0];
+	// minutes are ordered as follows: ["00", "30", "05", "35", "10", "40", "15", "45", "20", "50", "25", "55"]
+	this.minuteIndexMap = [0, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11];
+
+	this.templatePath =  dojo.uri.dojoUri("src/widget/templates/HtmlTimePicker.html");
+	this.templateCssPath = dojo.uri.dojoUri("src/widget/templates/HtmlTimePicker.css");
+
+	this.fillInTemplate = function(){
+		this.initData();
+		this.initUI();
+	}
+
+	this.initData = function() {
+		// FIXME: doesn't currently validate the time before trying to set it
+		// Determine the date/time from stored info, or by default don't 
+		//  have a set time
+		// FIXME: should normalize against whitespace on storedTime... for now 
+		// just a lame hack
+		if(this.storedTime.indexOf("T")!=-1 && this.storedTime.split("T")[1] && this.storedTime!=" " && this.storedTime.split("T")[1]!="any") {
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime(this.storedTime, this.useDefaultMinutes, this.selectedTime.anyTime);
+		} else if (this.useDefaultTime) {
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", this.useDefaultMinutes, this.selectedTime.anyTime);
+		} else {
+			this.selectedTime.anyTime = true;
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", 0, 1);
+		}
+	}
+
+	this.initUI = function() {
+		// set UI to match the currently selected time
+		if(!this.selectedTime.anyTime && this.time) {
+			var amPmHour = dojo.widget.TimePicker.util.toAmPmHour(this.time.getHours());
+			var hour = amPmHour[0];
+			var isAm = amPmHour[1];
+			var minute = this.time.getMinutes();
+			var minuteIndex = parseInt(minute/5);
+			this.onSetSelectedHour(this.hourIndexMap[hour]);
+			this.onSetSelectedMinute(this.minuteIndexMap[minuteIndex]);
+			this.onSetSelectedAmPm(isAm);
+		} else {
+			this.onSetSelectedAnyTime();
+		}
+	}
+
+	this.setDateTime = function(rfcDate) {
+		this.storedTime = rfcDate;
+	}
+	
+	this.onClearSelectedHour = function(evt) {
+		this.clearSelectedHour();
+	}
+
+	this.onClearSelectedMinute = function(evt) {
+		this.clearSelectedMinute();
+	}
+
+	this.onClearSelectedAmPm = function(evt) {
+		this.clearSelectedAmPm();
+	}
+
+	this.onClearSelectedAnyTime = function(evt) {
+		this.clearSelectedAnyTime();
+		if(this.selectedTime.anyTime) {
+			this.selectedTime.anyTime = false;
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime("", this.useDefaultMinutes);
+			this.initUI();
+		}
+	}
+
+	this.clearSelectedHour = function() {
+		var hourNodes = this.hourContainerNode.getElementsByTagName("td");
+		for (var i=0; i<hourNodes.length; i++) {
+			dojo.html.setClass(hourNodes.item(i), "");
+		}
+	}
+
+	this.clearSelectedMinute = function() {
+		var minuteNodes = this.minuteContainerNode.getElementsByTagName("td");
+		for (var i=0; i<minuteNodes.length; i++) {
+			dojo.html.setClass(minuteNodes.item(i), "");
+		}
+	}
+
+	this.clearSelectedAmPm = function() {
+		var amPmNodes = this.amPmContainerNode.getElementsByTagName("td");
+		for (var i=0; i<amPmNodes.length; i++) {
+			dojo.html.setClass(amPmNodes.item(i), "");
+		}
+	}
+
+	this.clearSelectedAnyTime = function() {
+		dojo.html.setClass(this.anyTimeContainerNode, "anyTimeContainer");
+	}
+
+	this.onSetSelectedHour = function(evt) {
+		this.onClearSelectedAnyTime();
+		this.onClearSelectedHour();
+		this.setSelectedHour(evt);
+		this.onSetTime();
+	}
+
+	this.setSelectedHour = function(evt) {
+		if(evt && evt.target) {
+			dojo.html.setClass(evt.target, this.classNames.selectedTime);
+			this.selectedTime["hour"] = evt.target.innerHTML;
+		} else if (!isNaN(evt)) {
+			var hourNodes = this.hourContainerNode.getElementsByTagName("td");
+			if(hourNodes.item(evt)) {
+				dojo.html.setClass(hourNodes.item(evt), this.classNames.selectedTime);
+				this.selectedTime["hour"] = hourNodes.item(evt).innerHTML;
+			}
+		}
+		this.selectedTime.anyTime = false;
+	}
+
+	this.onSetSelectedMinute = function(evt) {
+		this.onClearSelectedAnyTime();
+		this.onClearSelectedMinute();
+		this.setSelectedMinute(evt);
+		this.selectedTime.anyTime = false;
+		this.onSetTime();
+	}
+
+	this.setSelectedMinute = function(evt) {
+		if(evt && evt.target) {
+			dojo.html.setClass(evt.target, this.classNames.selectedTime);
+			this.selectedTime["minute"] = evt.target.innerHTML;
+		} else if (!isNaN(evt)) {
+			var minuteNodes = this.minuteContainerNode.getElementsByTagName("td");
+			if(minuteNodes.item(evt)) {
+				dojo.html.setClass(minuteNodes.item(evt), this.classNames.selectedTime);
+				this.selectedTime["minute"] = minuteNodes.item(evt).innerHTML;
+			}
+		}
+	}
+
+	this.onSetSelectedAmPm = function(evt) {
+		this.onClearSelectedAnyTime();
+		this.onClearSelectedAmPm();
+		this.setSelectedAmPm(evt);
+		this.selectedTime.anyTime = false;
+		this.onSetTime();
+	}
+
+	this.setSelectedAmPm = function(evt) {
+		if(evt && evt.target) {
+			dojo.html.setClass(evt.target, this.classNames.selectedTime);
+			this.selectedTime["amPm"] = evt.target.innerHTML;
+		} else {
+			evt = evt ? 0 : 1;
+			var amPmNodes = this.amPmContainerNode.getElementsByTagName("td");
+			if(amPmNodes.item(evt)) {
+				dojo.html.setClass(amPmNodes.item(evt), this.classNames.selectedTime);
+				this.selectedTime["amPm"] = amPmNodes.item(evt).innerHTML;
+			}
+		}
+	}
+
+	this.onSetSelectedAnyTime = function(evt) {
+		this.onClearSelectedHour();
+		this.onClearSelectedMinute();
+		this.onClearSelectedAmPm();
+		this.setSelectedAnyTime();
+		this.onSetTime();
+	}
+
+	this.setSelectedAnyTime = function(evt) {
+		this.selectedTime.anyTime = true;
+		dojo.html.setClass(this.anyTimeContainerNode, this.classNames.selectedTime + " " + "anyTimeContainer");
+	}
+
+	this.onClick = function(evt) {
+		dojo.event.browser.stopEvent(evt)
+	}
+
+	this.onSetTime = function() {
+		if(this.selectedTime.anyTime) {
+			this.time = new Date();
+			var tempDateTime = dojo.widget.TimePicker.util.toRfcDateTime(this.time);
+			this.setDateTime(tempDateTime.split("T")[0]);
+		} else {
+			var hour = 12;
+			var minute = 0;
+			var isAm = false;
+			if(this.selectedTime["hour"]) {
+				hour = parseInt(this.selectedTime["hour"], 10);
+			}
+			if(this.selectedTime["minute"]) {
+				minute = parseInt(this.selectedTime["minute"], 10);
+			}
+			if(this.selectedTime["amPm"]) {
+				isAm = (this.selectedTime["amPm"].toLowerCase() == "am");
+			}
+			this.time = new Date();
+			this.time.setHours(dojo.widget.TimePicker.util.fromAmPmHour(hour, isAm));
+			this.time.setMinutes(minute);
+			this.setDateTime(dojo.widget.TimePicker.util.toRfcDateTime(this.time));
+		}
+	}
+
+}
+dojo.inherits(dojo.widget.html.TimePicker, dojo.widget.HtmlWidget);

Added: tags/parley-0.53/root/static/magic/src/widget/html/TitlePane.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/TitlePane.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/TitlePane.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,70 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.TitlePane");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.lfx.*");
+
+dojo.widget.html.TitlePane = function(){
+	dojo.widget.HtmlWidget.call(this);
+	this.widgetType = "TitlePane";
+
+	this.labelNode="";
+	this.labelNodeClass="";
+	this.containerNodeClass="";
+	this.label="";
+
+	this.open=true;
+	this.templatePath = dojo.uri.dojoUri("src/widget/templates/TitlePane.html");
+}
+
+dojo.inherits(dojo.widget.html.TitlePane, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.TitlePane, {
+	isContainer: true,
+	postCreate: function() {
+		if (this.label) {
+			this.labelNode.appendChild(document.createTextNode(this.label));
+		}
+
+		if (this.labelNodeClass) {
+			dojo.html.addClass(this.labelNode, this.labelNodeClass);
+		}	
+
+		if (this.containerNodeClass) {
+			dojo.html.addClass(this.containerNode, this.containerNodeClass);
+		}	
+
+		if (!this.open) {
+			dojo.lfx.wipeOut(this.containerNode,0).play();
+		}
+	},
+
+	onLabelClick: function() {
+		if (this.open) {
+			dojo.lfx.wipeOut(this.containerNode,250).play();
+			this.open=false;
+		}else {
+			dojo.lfx.wipeIn(this.containerNode,250).play();
+			this.open=true;
+		}
+	},
+
+	setContent: function(content) {
+		this.containerNode.innerHTML=content;
+	},
+
+	setLabel: function(label) {
+		this.labelNode.innerHTML=label;
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:TitlePane");

Added: tags/parley-0.53/root/static/magic/src/widget/html/Tooltip.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/Tooltip.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/Tooltip.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,183 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.Tooltip");
+dojo.require("dojo.widget.html.ContentPane");
+dojo.require("dojo.widget.Tooltip");
+dojo.require("dojo.uri");
+dojo.require("dojo.widget.*");
+dojo.require("dojo.event");
+dojo.require("dojo.style");
+dojo.require("dojo.html");
+
+dojo.widget.defineWidget(
+	"dojo.widget.html.Tooltip",
+	dojo.widget.html.ContentPane,
+	{
+		widgetType: "Tooltip",
+		isContainer: true,
+	
+		// Constructor arguments
+		caption: "",
+		showDelay: 500,
+		hideDelay: 100,
+		connectId: "",
+	
+		templatePath: dojo.uri.dojoUri("src/widget/templates/HtmlTooltipTemplate.html"),
+		templateCssPath: dojo.uri.dojoUri("src/widget/templates/HtmlTooltipTemplate.css"),
+	
+		connectNode: null,
+	
+		// Tooltip has the following possible states:
+		//   erased - nothing on screen
+		//   displaying - currently being faded in (partially displayed)
+		//   displayed - fully displayed
+		//   erasing - currently being faded out (partially erased)
+		state: "erased",
+	
+		fillInTemplate: function(args, frag){
+			if(this.caption != ""){
+				this.domNode.appendChild(document.createTextNode(this.caption));
+			}
+			this.connectNode = dojo.byId(this.connectId);		
+			dojo.widget.html.Tooltip.superclass.fillInTemplate.call(this, args, frag);
+		},
+		
+		postCreate: function(args, frag){
+			// The domnode was appended to my parent widget's domnode, but the positioning
+			// only works if the domnode is a child of document.body
+			document.body.appendChild(this.domNode);
+	
+			dojo.event.connect(this.connectNode, "onmouseover", this, "onMouseOver");
+			dojo.widget.html.Tooltip.superclass.postCreate.call(this, args, frag);
+		},
+		
+		onMouseOver: function(e) {
+			this.mouse = {x: e.pageX, y: e.pageY};
+	
+			if(!this.showTimer){
+				this.showTimer = setTimeout(dojo.lang.hitch(this, "show"), this.showDelay);
+				dojo.event.connect(document.documentElement, "onmousemove", this, "onMouseMove");
+			}
+		},
+	
+		onMouseMove: function(e) {
+			this.mouse = {x: e.pageX, y: e.pageY};
+	
+			if(dojo.html.overElement(this.connectNode, e) || dojo.html.overElement(this.domNode, e)) {
+				// If the tooltip has been scheduled to be erased, cancel that timer
+				// since we are hovering over element/tooltip again
+				if(this.hideTimer) {
+					clearTimeout(this.hideTimer);
+					delete this.hideTimer;
+				}
+			} else {
+				// mouse has been moved off the element/tooltip
+				// note: can't use onMouseOut to detect this because the "explode" effect causes
+				// spurious onMouseOut/onMouseOver events (due to interference from outline)
+				if(this.showTimer){
+					clearTimeout(this.showTimer);
+					delete this.showTimer;
+				}
+				if((this.state=="displaying"||this.state=="displayed") && !this.hideTimer){
+					this.hideTimer = setTimeout(dojo.lang.hitch(this, "hide"), this.hideDelay);
+				}
+			}
+		},
+	
+		show: function() {
+			if(this.state=="erasing"){
+				// we are in the process of erasing; when that is finished, display it.
+				this.displayScheduled=true;
+				return;
+			}
+			if ( this.state=="displaying" || this.state=="displayed" ) { return; }
+	
+			// prevent IE bleed through (iframe creation is deferred until first show()
+			// call because apparently it takes a long time)
+			if(!this.bgIframe){
+				this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);
+			}
+	
+			this.position();
+	
+			// if rendering using explosion effect, need to set explosion source
+			this.explodeSrc = [this.mouse.x, this.mouse.y];
+	
+			this.state="displaying";
+	
+			dojo.widget.html.Tooltip.superclass.show.call(this);
+		},
+	
+		onShow: function() {
+			dojo.widget.html.Tooltip.superclass.onShow.call(this);
+			
+			this.state="displayed";
+			
+			// in the corner case where the user has moved his mouse away
+			// while the tip was fading in
+			if(this.eraseScheduled){
+				this.hide();
+				this.eraseScheduled=false;
+			}
+		},
+	
+		hide: function() {
+			if(this.state=="displaying"){
+				// in the process of fading in.  wait until that is finished and then fade out
+				this.eraseScheduled=true;
+				return;
+			}
+			if ( this.state=="displayed" ) {
+				this.state="erasing";
+				if ( this.showTimer ) {
+					clearTimeout(this.showTimer);
+					delete this.showTimer;
+				}
+				if ( this.hideTimer ) {
+					clearTimeout(this.hideTimer);
+					delete this.hideTimer;
+				}
+				dojo.event.disconnect(document.documentElement, "onmousemove", this, "onMouseMove");
+				dojo.widget.html.Tooltip.superclass.hide.call(this);
+			}
+		},
+	
+		onHide: function(){
+			this.state="erased";
+	
+			// in the corner case where the user has moved his mouse back
+			// while the tip was fading out
+			if(this.displayScheduled){
+				this.display();
+				this.displayScheduled=false;
+			}
+		},
+	
+		position: function(){
+			dojo.html.placeOnScreenPoint(this.domNode, this.mouse.x, this.mouse.y, [10,15], true);
+			this.bgIframe.onResized();
+		},
+	
+		onLoad: function(){
+			if(this.isShowing()){
+				// the tooltip has changed size due to downloaded contents, so reposition it
+				dojo.lang.setTimeout(this, this.position, 50);
+				dojo.widget.html.Tooltip.superclass.onLoad.apply(this, arguments);
+			}
+		},
+	
+		checkSize: function() {
+			// checkSize() is called when the user has resized the browser window,
+			// but that doesn't affect this widget (or this widget's children)
+			// so it can be safely ignored
+		}
+	}
+);

Added: tags/parley-0.53/root/static/magic/src/widget/html/YahooMap.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/YahooMap.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/YahooMap.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,180 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.widget.html.YahooMap");
+dojo.require("dojo.event.*");
+dojo.require("dojo.html");
+dojo.require("dojo.math");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.YahooMap");
+
+(function(){
+	var yappid = djConfig["yAppId"]||djConfig["yahooAppId"]||"dojotoolkit";
+	if(!dojo.hostenv.post_load_){
+		if(yappid == "dojotoolkit"){
+			dojo.debug("please provide a unique Yahoo App ID in djConfig.yahooAppId when using the map widget");
+		}
+		var tag = "<scr"+"ipt src='http://api.maps.yahoo.com/ajaxymap?v=3.0&appid="+yappid+"'></scri"+"pt>";
+		if(!dj_global["YMap"]){
+			document.write(tag);
+		}
+	}else{
+		dojo.debug("cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Yahoo in your page or require() the YahooMap widget before onload has fired");
+	}
+})();
+
+dojo.widget.html.YahooMap=function(){
+	dojo.widget.HtmlWidget.call(this);
+	dojo.widget.YahooMap.call(this);
+
+	this.map=null;
+	this.datasrc="";
+	this.data=[];
+	this.width=0;
+	this.height=0;
+	this.controls=["zoomlong","maptype","pan"];
+};
+dojo.inherits(dojo.widget.html.YahooMap, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.YahooMap, {
+	widgetType: "YahooMap",
+	templatePath:null,
+	templateCssPath:null,
+
+	findCenter:function(aPts){
+		var start=new YGeoPoint(37,-90);
+		if(aPts.length==0) return start;
+		var minLat,maxLat, minLon, maxLon, cLat, cLon;
+		minLat=maxLat=aPts[0].Lat;
+		minLon=maxLon=aPts[0].Lon;
+		for(var i=0; i<aPts.length; i++){
+			minLat=Math.min(minLat,aPts[i].Lat);
+			maxLat=Math.max(maxLat,aPts[i].Lat);
+			minLon=Math.min(minLon,aPts[i].Lon);
+			maxLon=Math.max(maxLon,aPts[i].Lon);
+		}
+		cLat=dojo.math.round((minLat+maxLat)/2,6);
+		cLon=dojo.math.round((minLon+maxLon)/2,6);
+		return new YGeoPoint(cLat,cLon);
+	},
+	setControls:function(){
+		var c=this.controls;
+		var t=dojo.widget.YahooMap.Controls;
+		for(var i=0; i<c.length; i++){
+			switch(c[i]){
+				case t.MapType:{
+					this.map.addTypeControl();
+					break;
+				}
+				case t.Pan:{
+					this.map.addPanControl();
+					break;
+				}
+				case t.ZoomLong:{
+					this.map.addZoomLong();
+					break;
+				}
+				case t.ZoomShort:{
+					this.map.addZoomShort();
+					break;
+				}
+			}
+		}
+	},
+	
+	parse:function(table){
+		this.data=[];
+
+		//	get the column indices
+		var h=table.getElementsByTagName("thead")[0];
+		if(!h){
+			return;
+		}
+
+		var a=[];
+		var cols=h.getElementsByTagName("td");
+		if(cols.length==0){
+			cols=h.getElementsByTagName("th");
+		}
+		for(var i=0; i<cols.length; i++){
+			var c=cols[i].innerHTML.toLowerCase();
+			if(c=="long") c="lng";
+			a.push(c);
+		}
+		
+		//	parse the data
+		var b=table.getElementsByTagName("tbody")[0];
+		if(!b){
+			return;
+		}
+		for(var i=0; i<b.childNodes.length; i++){
+			if(!(b.childNodes[i].nodeName&&b.childNodes[i].nodeName.toLowerCase()=="tr")){
+				continue;
+			}
+			var cells=b.childNodes[i].getElementsByTagName("td");
+			var o={};
+			for(var j=0; j<a.length; j++){
+				var col=a[j];
+				if(col=="lat"||col=="lng"){
+					o[col]=parseFloat(cells[j].innerHTML);					
+				}else{
+					o[col]=cells[j].innerHTML;
+				}
+			}
+			this.data.push(o);
+		}
+	},
+	render:function(){
+		var pts=[];
+		var d=this.data;
+		for(var i=0; i<d.length; i++){
+			var pt=new YGeoPoint(d[i].lat, d[i].lng);
+			pts.push(pt);
+			var icon=d[i].icon||null;
+			if(icon){
+				icon=new YImage(icon);
+			}
+			var m=new YMarker(pt,icon);
+			if(d[i].description){
+				m.addAutoExpand("<div>"+d[i].description+"</div>");
+			}
+			this.map.addOverlay(m);
+		}
+		var c=this.findCenter(pts);
+		var z=this.map.getZoomLevel(pts);
+		this.map.drawZoomAndCenter(c,z);
+	},
+	
+	initialize:function(args, frag){
+		if(!YMap || !YGeoPoint){
+			dojo.raise("dojo.widget.YahooMap: The Yahoo Map script must be included in order to use this widget.");
+		}
+		if(this.datasrc){
+			this.parse(dojo.byId(this.datasrc));
+		}
+		else if(this.domNode.getElementsByTagName("table")[0]){
+			this.parse(this.domNode.getElementsByTagName("table")[0]);
+		}
+	},
+	postCreate:function(){
+		//	clean the domNode before creating the map.
+		while(this.domNode.childNodes.length>0){
+			this.domNode.removeChild(this.domNode.childNodes[0]);
+		}
+
+		if(this.width>0&&this.height>0){
+			this.map=new YMap(this.domNode, YAHOO_MAP_REG, new YSize(this.width, this.height));
+		}else{
+			this.map=new YMap(this.domNode);
+		}
+		this.setControls();
+		this.render();
+	}
+});

Deleted: tags/parley-0.53/root/static/magic/src/widget/html/layout.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/layout.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/layout.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,94 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.html.layout");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.string.extras");
-dojo.require("dojo.html.style");
-dojo.require("dojo.html.layout");
-dojo.widget.html.layout = function (container, children, layoutPriority) {
-	dojo.html.addClass(container, "dojoLayoutContainer");
-	children = dojo.lang.filter(children, function (child, idx) {
-		child.idx = idx;
-		return dojo.lang.inArray(["top", "bottom", "left", "right", "client", "flood"], child.layoutAlign);
-	});
-	if (layoutPriority && layoutPriority != "none") {
-		var rank = function (child) {
-			switch (child.layoutAlign) {
-			  case "flood":
-				return 1;
-			  case "left":
-			  case "right":
-				return (layoutPriority == "left-right") ? 2 : 3;
-			  case "top":
-			  case "bottom":
-				return (layoutPriority == "left-right") ? 3 : 2;
-			  default:
-				return 4;
-			}
-		};
-		children.sort(function (a, b) {
-			return (rank(a) - rank(b)) || (a.idx - b.idx);
-		});
-	}
-	var f = {top:dojo.html.getPixelValue(container, "padding-top", true), left:dojo.html.getPixelValue(container, "padding-left", true)};
-	dojo.lang.mixin(f, dojo.html.getContentBox(container));
-	dojo.lang.forEach(children, function (child) {
-		var elm = child.domNode;
-		var pos = child.layoutAlign;
-		with (elm.style) {
-			left = f.left + "px";
-			top = f.top + "px";
-			bottom = "auto";
-			right = "auto";
-		}
-		dojo.html.addClass(elm, "dojoAlign" + dojo.string.capitalize(pos));
-		if ((pos == "top") || (pos == "bottom")) {
-			dojo.html.setMarginBox(elm, {width:f.width});
-			var h = dojo.html.getMarginBox(elm).height;
-			f.height -= h;
-			if (pos == "top") {
-				f.top += h;
-			} else {
-				elm.style.top = f.top + f.height + "px";
-			}
-			if (child.onResized) {
-				child.onResized();
-			}
-		} else {
-			if (pos == "left" || pos == "right") {
-				var w = dojo.html.getMarginBox(elm).width;
-				if (child.resizeTo) {
-					child.resizeTo(w, f.height);
-				} else {
-					dojo.html.setMarginBox(elm, {width:w, height:f.height});
-				}
-				f.width -= w;
-				if (pos == "left") {
-					f.left += w;
-				} else {
-					elm.style.left = f.left + f.width + "px";
-				}
-			} else {
-				if (pos == "flood" || pos == "client") {
-					if (child.resizeTo) {
-						child.resizeTo(f.width, f.height);
-					} else {
-						dojo.html.setMarginBox(elm, {width:f.width, height:f.height});
-					}
-				}
-			}
-		}
-	});
-};
-dojo.html.insertCssText(".dojoLayoutContainer{ position: relative; display: block; overflow: hidden; }\n" + "body .dojoAlignTop, body .dojoAlignBottom, body .dojoAlignLeft, body .dojoAlignRight { position: absolute; overflow: hidden; }\n" + "body .dojoAlignClient { position: absolute }\n" + ".dojoAlignClient { overflow: auto; }\n");
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/html/loader.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/loader.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/loader.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,622 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.widget.html.loader");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.io.*");
-dojo.require("dojo.lang.common");
-dojo.require("dojo.lang.extras");
-dojo.require("dojo.experimental");
-dojo.experimental("dojo.widget.html.loader");
-dojo.widget.html.loader = new (function () {
-	this.toString = function () {
-		return "dojo.widget.html.loader";
-	};
-	var _loader = this;
-	dojo.addOnLoad(function () {
-		dojo.experimental(_loader.toString());
-		var undo = dojo.evalObjPath("dojo.undo.browser");
-		if (djConfig["preventBackButtonFix"] && undo && !undo.initialState) {
-			undo.setInitialState(new trackerObj);
-		}
-	});
-	var logger = {};
-	var trackerObj = function (id, data) {
-		this.id = id;
-		this.data = data;
-	};
-	trackerObj.prototype.handle = function (type) {
-		if (typeof dojo == "undefined") {
-			return;
-		}
-		var wg = dojo.widget.byId(this.id);
-		if (wg) {
-			wg.setContent(this.data, true);
-		}
-	};
-	this._log = function (widget, data) {
-		if (widget.trackHistory) {
-			if (!logger[widget.widgetId]) {
-				logger[widget.widgetId] = {childrenIds:[], stack:[data]};
-			}
-			var children = logger[widget.widgetId].childrenIds;
-			while (children && children.length) {
-				delete logger[children.pop()];
-			}
-			for (var child in widget.children) {
-				logger[widget.widgetId].childrenIds = child.widgetId;
-			}
-			dojo.undo.browser.addToHistory(new trackerObj(widget.widgetId, dojo.lang.shallowCopy(data, true)));
-		}
-	};
-	var undef = dojo.lang.isUndefined;
-	var isFunc = dojo.lang.isFunction;
-	function handleDefaults(e, handler, useAlert) {
-		if (!handler) {
-			handler = "onContentError";
-		}
-		if (dojo.lang.isString(e)) {
-			e = {_text:e};
-		}
-		if (!e._text) {
-			e._text = e.toString();
-		}
-		e.toString = function () {
-			return this._text;
-		};
-		if (typeof e.returnValue != "boolean") {
-			e.returnValue = true;
-		}
-		if (typeof e.preventDefault != "function") {
-			e.preventDefault = function () {
-				this.returnValue = false;
-			};
-		}
-		this[handler](e);
-		if (e.returnValue) {
-			if (useAlert) {
-				alert(e.toString());
-			} else {
-				this.loader.callOnUnLoad.call(this, false);
-				this.onSetContent(e.toString());
-			}
-		}
-	}
-	function downloader(bindArgs) {
-		for (var x in this.bindArgs) {
-			bindArgs[x] = (undef(bindArgs[x]) ? this.bindArgs[x] : undefined);
-		}
-		var cache = this.cacheContent;
-		if (undef(bindArgs.useCache)) {
-			bindArgs.useCache = cache;
-		}
-		if (undef(bindArgs.preventCache)) {
-			bindArgs.preventCache = !cache;
-		}
-		if (undef(bindArgs.mimetype)) {
-			bindArgs.mimetype = "text/html";
-		}
-		this.loader.bindObj = dojo.io.bind(bindArgs);
-	}
-	function stackRunner(st) {
-		var err = "", func = null;
-		var scope = this.scriptScope || dojo.global();
-		while (st.length) {
-			func = st.shift();
-			try {
-				func.call(scope);
-			}
-			catch (e) {
-				err += "\n" + func + " failed: " + e;
-			}
-		}
-		if (err.length) {
-			var name = (st == this.loader.addOnLoads) ? "addOnLoad" : "addOnUnLoad";
-			handleDefaults.call(this, name + " failure\n " + err, "onExecError", true);
-		}
-	}
-	function stackPusher(st, obj, func) {
-		if (typeof func == "undefined") {
-			st.push(obj);
-		} else {
-			st.push(function () {
-				obj[func]();
-			});
-		}
-	}
-	function refreshed() {
-		this.onResized();
-		this.onLoad();
-		this.isLoaded = true;
-	}
-	function asyncParse(data) {
-		if (this.executeScripts) {
-			this.onExecScript.call(this, data.scripts);
-		}
-		if (this.parseContent) {
-			this.onContentParse.call(this);
-		}
-		refreshed.call(this);
-	}
-	function runHandler() {
-		if (dojo.lang.isFunction(this.handler)) {
-			this.handler(this, this.containerNode || this.domNode);
-			refreshed.call(this);
-			return false;
-		}
-		return true;
-	}
-	this.htmlContentBasicFix = function (s, url) {
-		var titles = [], styles = [];
-		var regex = /<title[^>]*>([\s\S]*?)<\/title>/i;
-		var match, attr;
-		while (match = regex.exec(s)) {
-			titles.push(match[1]);
-			s = s.substring(0, match.index) + s.substr(match.index + match[0].length);
-		}
-		regex = /(?:<(style)[^>]*>([\s\S]*?)<\/style>|<link ([^>]*rel=['"]?stylesheet['"]?[^>]*)>)/i;
-		while (match = regex.exec(s)) {
-			if (match[1] && match[1].toLowerCase() == "style") {
-				styles.push(dojo.html.fixPathsInCssText(match[2], url));
-			} else {
-				if (attr = match[3].match(/href=(['"]?)([^'">]*)\1/i)) {
-					styles.push({path:attr[2]});
-				}
-			}
-			s = s.substring(0, match.index) + s.substr(match.index + match[0].length);
-		}
-		return {"s":s, "titles":titles, "styles":styles};
-	};
-	this.htmlContentAdjustPaths = function (s, url) {
-		var tag = "", str = "", tagFix = "", path = "";
-		var attr = [], origPath = "", fix = "";
-		var regexFindTag = /<[a-z][a-z0-9]*[^>]*\s(?:(?:src|href|style)=[^>])+[^>]*>/i;
-		var regexFindAttr = /\s(src|href|style)=(['"]?)([\w()\[\]\/.,\\'"-:;#=&?\s@]+?)\2/i;
-		var regexProtocols = /^(?:[#]|(?:(?:https?|ftps?|file|javascript|mailto|news):))/;
-		while (tag = regexFindTag.exec(s)) {
-			str += s.substring(0, tag.index);
-			s = s.substring((tag.index + tag[0].length), s.length);
-			tag = tag[0];
-			tagFix = "";
-			while (attr = regexFindAttr.exec(tag)) {
-				path = "";
-				origPath = attr[3];
-				switch (attr[1].toLowerCase()) {
-				  case "src":
-				  case "href":
-					if (regexProtocols.exec(origPath)) {
-						path = origPath;
-					} else {
-						path = (new dojo.uri.Uri(url, origPath).toString());
-					}
-					break;
-				  case "style":
-					path = dojo.html.fixPathsInCssText(origPath, url);
-					break;
-				  default:
-					path = origPath;
-				}
-				fix = " " + attr[1] + "=" + attr[2] + path + attr[2];
-				tagFix += tag.substring(0, attr.index) + fix;
-				tag = tag.substring((attr.index + attr[0].length), tag.length);
-			}
-			str += tagFix + tag;
-		}
-		return str + s;
-	};
-	this.htmlContentScripts = function (s, collectScripts) {
-		var scripts = [], requires = [], match = [];
-		var attr = "", tmp = null, tag = "", sc = "", str = "";
-		var regex = /<script([^>]*)>([\s\S]*?)<\/script>/i;
-		var regexSrc = /src=(['"]?)([^"']*)\1/i;
-		var regexDojoJs = /.*(\bdojo\b\.js(?:\.uncompressed\.js)?)$/;
-		var regexInvalid = /(?:var )?\bdjConfig\b(?:[\s]*=[\s]*\{[^}]+\}|\.[\w]*[\s]*=[\s]*[^;\n]*)?;?|dojo\.hostenv\.writeIncludes\(\s*\);?/g;
-		var regexRequires = /dojo\.(?:(?:require(?:After)?(?:If)?)|(?:widget\.(?:manager\.)?registerWidgetPackage)|(?:(?:hostenv\.)?setModulePrefix)|defineNamespace)\((['"]).*?\1\)\s*;?/;
-		while (match = regex.exec(s)) {
-			if (this.executeScripts && match[1]) {
-				if (attr = regexSrc.exec(match[1])) {
-					if (regexDojoJs.exec(attr[2])) {
-						dojo.debug("Security note! inhibit:" + attr[2] + " from  beeing loaded again.");
-					} else {
-						scripts.push({path:attr[2]});
-					}
-				}
-			}
-			if (match[2]) {
-				sc = match[2].replace(regexInvalid, "");
-				if (!sc) {
-					continue;
-				}
-				while (tmp = regexRequires.exec(sc)) {
-					requires.push(tmp[0]);
-					sc = sc.substring(0, tmp.index) + sc.substr(tmp.index + tmp[0].length);
-				}
-				if (collectScripts) {
-					scripts.push(sc);
-				}
-			}
-			s = s.substr(0, match.index) + s.substr(match.index + match[0].length);
-		}
-		if (collectScripts) {
-			var regex = /(<[a-zA-Z][a-zA-Z0-9]*\s[^>]*\S=(['"])[^>]*[^\.\]])scriptScope([^>]*>)/;
-			str = "";
-			while (tag = regex.exec(s)) {
-				tmp = ((tag[2] == "'") ? "\"" : "'");
-				str += s.substring(0, tag.index);
-				s = s.substr(tag.index).replace(regex, "$1dojo.widget.byId(" + tmp + this.widgetId + tmp + ").scriptScope$3");
-			}
-			s = str + s;
-		}
-		return {"s":s, "requires":requires, "scripts":scripts};
-	};
-	this.splitAndFixPaths = function (args) {
-		if (!args.url) {
-			args.url = "./";
-		}
-		url = new dojo.uri.Uri(location, args.url).toString();
-		var ret = {"xml":"", "styles":[], "titles":[], "requires":[], "scripts":[], "url":url};
-		if (args.content) {
-			var tmp = null, content = args.content;
-			if (args.adjustPaths) {
-				content = _loader.htmlContentAdjustPaths.call(this, content, url);
-			}
-			tmp = _loader.htmlContentBasicFix.call(this, content, url);
-			content = tmp.s;
-			ret.styles = tmp.styles;
-			ret.titles = tmp.titles;
-			if (args.collectRequires || args.collectScripts) {
-				tmp = _loader.htmlContentScripts.call(this, content, args.collectScripts);
-				content = tmp.s;
-				ret.requires = tmp.requires;
-				ret.scripts = tmp.scripts;
-			}
-			var match = [];
-			if (args.bodyExtract) {
-				match = content.match(/<body[^>]*>\s*([\s\S]+)\s*<\/body>/im);
-				if (match) {
-					content = match[1];
-				}
-			}
-			ret.xml = content;
-		}
-		return ret;
-	};
-	this.hookUp = function (args) {
-		var widget = args.widget;
-		if (dojo.lang.isString(widget)) {
-			if (args.mixin) {
-				dojo.raise(this.toString() + ", cant use mixin when widget is a string");
-			}
-			widget = dojo.evalObjPath(widget);
-		}
-		if (!widget || !(widget instanceof dojo.widget.HtmlWidget)) {
-			dojo.raise(this.toString() + " Widget isn't defined or isn't a HtmlWidget instance");
-		}
-		if (widget.loader && widget.setUrl) {
-			return;
-		}
-		var widgetProto = (args.mixin) ? widget : widget.constructor.prototype;
-		widget.loader = {isLoaded:false, styleNodes:[], addOnLoads:[], addOnUnLoads:[], callOnUnLoad:(function (canCall) {
-			return function (after) {
-				this.abort();
-				if (canCall) {
-					this.onUnLoad();
-				}
-				canCall = after;
-			};
-		})(false), bindObj:null, unHook:(function (w, wg) {
-			var oldProps = {isContainer:w.isContainer, adjustPats:w.adjustPaths, href:w.href, extractContent:w.extractContent, parseContent:w.parseContent, cacheContent:w.cacheContent, bindArgs:w.bindArgs, preload:w.preload, refreshOnShow:w.refreshOnShow, handler:w.handler, trackHistory:w.trackHistory, executeScripts:w.executeScripts, scriptScope:w.scriptScope, postCreate:w.postCreate, show:w.show, refresh:w.refresh, loadContents:w.loadContents, abort:w.abort, destroy:w.destroy, onLoad:w.onLoad, onUnLoad:w.onUnLoad, addOnLoad:w.addOnLoad, addOnUnLoad:w.addOnUnLoad, onDownloadStart:w.onDownloadStart, onDownloadEnd:w.onDownloadEnd, onDownloadError:w.onDownloadError, onContentError:w.onContentError, onExecError:w.onExecError, onSetContent:w.onSetContent, setUrl:w.setUrl, setContent:w.setContent, onContentParse:w.onContentParse, onExecScript:w.onExecScript, setHandler:w.setHandler};
-			return function () {
-				if (wg.abort) {
-					wg.abort();
-				}
-				if ((w != wg) && (dojo.widget.byType(wg.widgetType).length > 1)) {
-					return;
-				}
-				for (var x in oldProps) {
-					if (oldProps[x] === undefined) {
-						delete w[x];
-						continue;
-					}
-					w[x] = oldProps[x];
-				}
-				delete wg._loader_defined;
-				delete wg.loader;
-			};
-		})(widgetProto, widget)};
-		if (widgetProto._loader_defined || widget._loader_defined) {
-			return;
-		}
-		dojo.mixin(widgetProto, {isContainer:true, adjustPaths:undef(widgetProto.adjustPaths) ? true : widgetProto.adjustPaths, href:undef(widgetProto.href) ? "" : widgetProto.href, extractContent:undef(widgetProto.extractContent) ? true : widgetProto.extractContent, parseContent:undef(widgetProto.parseContent) ? true : widgetProto.parseContent, cacheContent:undef(widgetProto.cacheContent) ? true : widgetProto.cacheContent, bindArgs:undef(widgetProto.bindArgs) ? {} : widgetProto.bindArgs, preload:undef(widgetProto.preload) ? false : widgetProto.preload, refreshOnShow:undef(widgetProto.refreshOnShow) ? false : widgetProto.refreshOnShow, handler:undef(widgetProto.handler) ? "" : widgetProto.handler, executeScripts:undef(widgetProto.executeScripts) ? false : widgetProto.executeScripts, trackHistory:undef(widgetProto.tracHistory) ? false : widgetProto.trackHistory, scriptScope:null});
-		widgetProto.postCreate = (function (postCreate) {
-			return function () {
-				if (widgetProto.constructor.superclass.postCreate != postCreate) {
-					postCreate.apply(this, arguments);
-				} else {
-					widgetProto.constructor.superclass.postCreate.apply(this, arguments);
-				}
-				if (this.handler !== "") {
-					this.setHandler(this.handler);
-				}
-				if (this.isShowing() || this.preload) {
-					this.loadContents();
-					if (!this.href) {
-						_loader._log(this, (this.domNode || this.containerNode).innerHTML);
-					}
-				}
-			};
-		})(widgetProto.postCreate);
-		widgetProto.show = (function (show) {
-			return function () {
-				if (this.refreshOnShow) {
-					this.refresh();
-				} else {
-					this.loadContents();
-				}
-				if ((widgetProto.constructor.superclass.show == show) || !isFunc(show)) {
-					widgetProto.constructor.superclass.show.apply(this, arguments);
-				} else {
-					show.apply(this, arguments);
-				}
-			};
-		})(widgetProto.show);
-		widgetProto.destroy = (function (destroy) {
-			return function (destroy) {
-				this.onUnLoad();
-				this.abort();
-				this.loader.unHook();
-				if ((widgetProto.constructor.superclass.destroy != destroy) && isFunc(destroy)) {
-					destroy.apply(this, arguments);
-				} else {
-					widgetProto.constructor.superclass.destroy.apply(this, arguments);
-				}
-			};
-		})(widgetProto.destroy);
-		if (!widgetProto.refresh) {
-			widgetProto.refresh = function () {
-				this.loader.isLoaded = false;
-				this.loadContents();
-			};
-		}
-		if (!widgetProto.loadContents) {
-			widgetProto.loadContents = function () {
-				if (this.loader.isLoaded) {
-					return;
-				}
-				if (isFunc(this.handler)) {
-					runHandler.call(this);
-				} else {
-					if (this.href !== "") {
-						handleDefaults.call(this, "Loading...", "onDownloadStart");
-						var self = this, url = this.href;
-						downloader.call(this, {url:url, load:function (type, data, xhr) {
-							self.onDownloadEnd.call(self, url, data);
-						}, error:function (type, err, xhr) {
-							var e = {responseText:xhr.responseText, status:xhr.status, statusText:xhr.statusText, responseHeaders:(xhr.getAllResponseHeaders) ? xhr.getAllResponseHeaders() : [], _text:"Error loading '" + url + "' (" + xhr.status + " " + xhr.statusText + ")"};
-							handleDefaults.call(self, e, "onDownloadError");
-							self.onLoad();
-						}});
-					}
-				}
-			};
-		}
-		if (!widgetProto.abort) {
-			widgetProto.abort = function () {
-				if (!this.loader || !this.loader.bindObj || !this.loader.bindObj.abort) {
-					return;
-				}
-				this.loader.bindObj.abort();
-				this.loader.bindObj = null;
-			};
-		}
-		if (!widgetProto.onLoad) {
-			widgetProto.onLoad = function () {
-				stackRunner.call(this, this.loader.addOnLoads);
-				this.loader.isLoaded = true;
-			};
-		}
-		if (!widgetProto.onUnLoad) {
-			widgetProto.onUnLoad = function () {
-				stackRunner.call(this, this.loader.addOnUnLoads);
-				delete this.scriptScope;
-			};
-		}
-		if (!widgetProto.addOnLoad) {
-			widgetProto.addOnLoad = function (obj, func) {
-				stackPusher.call(this, this.loader.addOnLoads, obj, func);
-			};
-		}
-		if (!widgetProto.addOnUnLoad) {
-			widgetProto.addOnUnLoad = function (obj, func) {
-				stackPusher.call(this, this.loader.addOnUnLoads, obj, func);
-			};
-		}
-		if (!widgetProto.onExecError) {
-			widgetProto.onExecError = function () {
-			};
-		}
-		if (!widgetProto.onContentError) {
-			widgetProto.onContentError = function () {
-			};
-		}
-		if (!widgetProto.onDownloadError) {
-			widgetProto.onDownloadError = function () {
-			};
-		}
-		if (!widgetProto.onDownloadStart) {
-			widgetProto.onDownloadStart = function (onDownloadStart) {
-			};
-		}
-		if (!widgetProto.onDownloadEnd) {
-			widgetProto.onDownloadEnd = function (url, data) {
-				var args = {content:data, url:url, adjustPaths:this.adjustPaths, collectScripts:this.executeScripts, collectRequires:this.parseContent, bodyExtract:this.extractContent};
-				data = _loader.splitAndFixPaths.call(this, args);
-				this.setContent(data);
-			};
-		}
-		if (!widgetProto.onSetContent) {
-			widgetProto.onSetContent = function (cont) {
-				this.destroyChildren();
-				var styleNodes = this.loader.styleNodes;
-				while (styleNodes.length) {
-					var st = styleNodes.pop();
-					if (st && st.parentNode) {
-						st.parentNode.removeChild(st);
-					}
-				}
-				var node = this.containerNode || this.domNode;
-				while (node.firstChild) {
-					try {
-						dojo.event.browser.clean(node.firstChild);
-					}
-					catch (e) {
-					}
-					node.removeChild(node.firstChild);
-				}
-				try {
-					if (typeof cont != "string") {
-						node.appendChild(cont);
-					} else {
-						try {
-							node.innerHTML = cont;
-						}
-						catch (e) {
-							var tmp;
-							(tmp = dojo.doc().createElement("div")).innerHTML = cont;
-							while (tmp.firstChild) {
-								node.appendChild(tmp.removeChild(tmp.firstChild));
-							}
-						}
-					}
-				}
-				catch (e) {
-					e._text = "Could'nt load content: " + e;
-					var useAlert = (this.loader._onSetContent_err == e._text);
-					this.loader._onSetContent_err = e._text;
-					handleDefaults.call(this, e, "onContentError", useAlert);
-				}
-			};
-		}
-		if (!widgetProto.setUrl) {
-			widgetProto.setUrl = function (url) {
-				this.href = url;
-				this.loader.isLoaded = false;
-				if (this.preload || this.isShowing()) {
-					this.loadContents();
-				}
-			};
-		}
-		if (!widgetProto.setContent) {
-			widgetProto.setContent = function (data, dontLog) {
-				this.loader.callOnUnLoad.call(this, true);
-				if (!data || dojo.html.isNode(data)) {
-					this.onSetContent(data);
-					refreshed.call(this);
-				} else {
-					if (typeof data.xml != "string") {
-						this.href = "";
-						var args = {content:data, url:this.href, adjustPaths:this.adjustPaths, collectScripts:this.executeScripts, collectRequires:this.parseContent, bodyExtract:this.extractContent};
-						data = _loader.splitAndFixPaths.call(this, args);
-					} else {
-						if (data.url != "./") {
-							this.url = data.url;
-						}
-					}
-					this.onSetContent(data.xml);
-					for (var i = 0, styles = data.styles; i < styles.length; i++) {
-						if (styles[i].path) {
-							this.loader.styleNodes.push(dojo.html.insertCssFile(styles[i].path));
-						} else {
-							this.loader.styleNodes.push(dojo.html.insertCssText(styles[i]));
-						}
-					}
-					if (this.parseContent) {
-						for (var i = 0, requires = data.requires; i < requires.length; i++) {
-							try {
-								eval(requires[i]);
-							}
-							catch (e) {
-								e._text = "dojo.widget.html.loader.hookUp: error in package loading calls, " + (e.description || e);
-								handleDefaults.call(this, e, "onContentError", true);
-							}
-						}
-					}
-					if (dojo.hostenv.isXDomain && data.requires.length) {
-						dojo.addOnLoad(function () {
-							asyncParse.call(this, data);
-							if (!dontLog) {
-								_loader._log(this, data);
-							}
-						});
-						dontLog = true;
-					} else {
-						asyncParse.call(this, data);
-					}
-				}
-				if (!dontLog) {
-				}
-			};
-		}
-		if (!widgetProto.onContentParse) {
-			widgetProto.onContentParse = function () {
-				var node = this.containerNode || this.domNode;
-				var parser = new dojo.xml.Parse();
-				var frag = parser.parseElement(node, null, true);
-				dojo.widget.getParser().createSubComponents(frag, this);
-			};
-		}
-		if (!widgetProto.onExecScript) {
-			widgetProto.onExecScript = function (scripts) {
-				var self = this, tmp = "", code = "";
-				for (var i = 0; i < scripts.length; i++) {
-					if (scripts[i].path) {
-						var url = scripts[i].path;
-						downloader.call(this, {"url":url, "load":function (type, scriptStr) {
-							(function () {
-								tmp = scriptStr;
-								scripts[i] = scriptStr;
-							}).call(self);
-						}, "error":function (type, error) {
-							error._text = type + " downloading remote script";
-							handleDefaults.call(self, error, "onExecError", true);
-						}, "mimetype":"text/plain", "sync":true});
-						code += tmp;
-					} else {
-						code += scripts[i];
-					}
-				}
-				try {
-					delete this.scriptScope;
-					this.scriptScope = new (new Function("_container_", code + "; return this;"))(self);
-				}
-				catch (e) {
-					e._text = "Error running scripts from content:\n" + (e.description || e.toString());
-					handleDefaults.call(this, e, "onExecError", true);
-				}
-			};
-		}
-		if (!widgetProto.setHandler) {
-			widgetProto.setHandler = function (handler) {
-				var fcn = dojo.lang.isFunction(handler) ? handler : window[handler];
-				if (!isFunc(fcn)) {
-					handleDefaults.call(this, "Unable to set handler, '" + handler + "' not a function.", "onExecError", true);
-					return;
-				}
-				this.handler = function () {
-					return fcn.apply(this, arguments);
-				};
-			};
-		}
-		widgetProto._loader_defined = true;
-	};
-})();
-

Modified: tags/parley-0.53/root/static/magic/src/widget/html/stabile.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/html/stabile.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/html/stabile.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,121 +8,206 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.html.stabile");
-dojo.widget.html.stabile = {_sqQuotables:new RegExp("([\\\\'])", "g"), _depth:0, _recur:false, depthLimit:2};
-dojo.widget.html.stabile.getState = function (id) {
-	dojo.widget.html.stabile.setup();
-	return dojo.widget.html.stabile.widgetState[id];
-};
-dojo.widget.html.stabile.setState = function (id, state, isCommit) {
-	dojo.widget.html.stabile.setup();
-	dojo.widget.html.stabile.widgetState[id] = state;
-	if (isCommit) {
-		dojo.widget.html.stabile.commit(dojo.widget.html.stabile.widgetState);
-	}
-};
-dojo.widget.html.stabile.setup = function () {
-	if (!dojo.widget.html.stabile.widgetState) {
-		var text = dojo.widget.html.stabile._getStorage().value;
-		dojo.widget.html.stabile.widgetState = text ? dj_eval("(" + text + ")") : {};
-	}
-};
-dojo.widget.html.stabile.commit = function (state) {
-	dojo.widget.html.stabile._getStorage().value = dojo.widget.html.stabile.description(state);
-};
-dojo.widget.html.stabile.description = function (v, showAll) {
-	var depth = dojo.widget.html.stabile._depth;
-	var describeThis = function () {
-		return this.description(this, true);
-	};
-	try {
-		if (v === void (0)) {
-			return "undefined";
-		}
-		if (v === null) {
-			return "null";
-		}
-		if (typeof (v) == "boolean" || typeof (v) == "number" || v instanceof Boolean || v instanceof Number) {
-			return v.toString();
-		}
-		if (typeof (v) == "string" || v instanceof String) {
-			var v1 = v.replace(dojo.widget.html.stabile._sqQuotables, "\\$1");
-			v1 = v1.replace(/\n/g, "\\n");
-			v1 = v1.replace(/\r/g, "\\r");
-			return "'" + v1 + "'";
-		}
-		if (v instanceof Date) {
-			return "new Date(" + d.getFullYear + "," + d.getMonth() + "," + d.getDate() + ")";
-		}
-		var d;
-		if (v instanceof Array || v.push) {
-			if (depth >= dojo.widget.html.stabile.depthLimit) {
-				return "[ ... ]";
-			}
-			d = "[";
-			var first = true;
-			dojo.widget.html.stabile._depth++;
-			for (var i = 0; i < v.length; i++) {
-				if (first) {
-					first = false;
-				} else {
-					d += ",";
-				}
-				d += arguments.callee(v[i], showAll);
-			}
-			return d + "]";
-		}
-		if (v.constructor == Object || v.toString == describeThis) {
-			if (depth >= dojo.widget.html.stabile.depthLimit) {
-				return "{ ... }";
-			}
-			if (typeof (v.hasOwnProperty) != "function" && v.prototype) {
-				throw new Error("description: " + v + " not supported by script engine");
-			}
-			var first = true;
-			d = "{";
-			dojo.widget.html.stabile._depth++;
-			for (var key in v) {
-				if (v[key] == void (0) || typeof (v[key]) == "function") {
-					continue;
-				}
-				if (first) {
-					first = false;
-				} else {
-					d += ", ";
-				}
-				var kd = key;
-				if (!kd.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)) {
-					kd = arguments.callee(key, showAll);
-				}
-				d += kd + ": " + arguments.callee(v[key], showAll);
-			}
-			return d + "}";
-		}
-		if (showAll) {
-			if (dojo.widget.html.stabile._recur) {
-				var objectToString = Object.prototype.toString;
-				return objectToString.apply(v, []);
-			} else {
-				dojo.widget.html.stabile._recur = true;
-				return v.toString();
-			}
-		} else {
-			throw new Error("Unknown type: " + v);
-			return "'unknown'";
-		}
-	}
-	finally {
-		dojo.widget.html.stabile._depth = depth;
-	}
-};
-dojo.widget.html.stabile._getStorage = function () {
-	if (dojo.widget.html.stabile.dataField) {
-		return dojo.widget.html.stabile.dataField;
-	}
-	var form = document.forms._dojo_form;
-	return dojo.widget.html.stabile.dataField = form ? form.stabile : {value:""};
-};
-
+// Maintain state of widgets when user hits back/forward button
+
+dojo.provide("dojo.widget.html.stabile");
+
+dojo.widget.html.stabile = {
+	// Characters to quote in single-quoted regexprs
+	_sqQuotables: new RegExp("([\\\\'])", "g"),
+
+	// Current depth.
+	_depth: 0,
+
+	// Set to true when calling v.toString, to sniff for infinite
+	// recursion.
+	_recur: false,
+
+	// Levels of nesting of Array and object displays.
+	// If when >= depth, no display or array or object internals.
+	depthLimit: 2
+};
+
+
+
+
+
+//// PUBLIC METHODS
+
+// Get the state stored for the widget with the given ID, or undefined
+// if none.
+// 
+dojo.widget.html.stabile.getState = function(id){
+	dojo.widget.html.stabile.setup();
+	return dojo.widget.html.stabile.widgetState[id];
+}
+
+
+// Set the state stored for the widget with the given ID.  If isCommit
+// is true, commits all widget state to more stable storage.
+// 
+dojo.widget.html.stabile.setState = function(id, state, isCommit){
+	dojo.widget.html.stabile.setup();
+	dojo.widget.html.stabile.widgetState[id] = state;
+	if(isCommit){
+		dojo.widget.html.stabile.commit(dojo.widget.html.stabile.widgetState);
+	}
+}
+
+
+// Sets up widgetState: a hash keyed by widgetId, maps to an object
+// or array writable with "describe".  If there is data in the widget
+// storage area, use it, otherwise initialize an empty object.
+// 
+dojo.widget.html.stabile.setup = function(){
+	if(!dojo.widget.html.stabile.widgetState){
+		var text = dojo.widget.html.stabile.getStorage().value;
+		dojo.widget.html.stabile.widgetState = text ? dj_eval("("+text+")") : {};
+	}
+}
+
+
+// Commits all widget state to more stable storage, so if the user
+// navigates away and returns, it can be restored.
+// 
+dojo.widget.html.stabile.commit = function(state){
+	dojo.widget.html.stabile.getStorage().value = dojo.widget.html.stabile.description(state);
+}
+
+// Return a JSON "description string" for the given value.
+// Supports only core JavaScript types with literals, plus Date,
+// and cyclic structures are unsupported.
+// showAll defaults to false -- if true, this becomes a simple symbolic
+// object dumper, but you cannot "eval" the output.
+//
+dojo.widget.html.stabile.description = function(v, showAll){
+	// Save and later restore dojo.widget.html.stabile._depth;
+	var depth = dojo.widget.html.stabile._depth;
+
+	var describeThis = function() {
+		 return this.description(this, true);
+	} 
+	
+	try {
+
+		if(v===void(0)){
+			return "undefined";
+		}
+		if(v===null){
+			return "null";
+		}
+		if(typeof(v)=="boolean" || typeof(v)=="number"
+		    || v instanceof Boolean || v instanceof Number){
+			return v.toString();
+		}
+
+		if(typeof(v)=="string" || v instanceof String){
+			// Quote strings and their contents as required.
+			// Replacing by $& fails in IE 5.0
+			var v1 = v.replace(dojo.widget.html.stabile._sqQuotables, "\\$1"); 
+			v1 = v1.replace(/\n/g, "\\n");
+			v1 = v1.replace(/\r/g, "\\r");
+			// Any other important special cases?
+			return "'"+v1+"'";
+		}
+
+		if(v instanceof Date){
+			// Create a data constructor.
+			return "new Date("+d.getFullYear+","+d.getMonth()+","+d.getDate()+")";
+		}
+
+		var d;
+		if(v instanceof Array || v.push){
+			// "push" test needed for KHTML/Safari, don't know why -cp
+
+			if(depth>=dojo.widget.html.stabile.depthLimit)
+			  return "[ ... ]";
+
+			d = "[";
+			var first = true;
+			dojo.widget.html.stabile._depth++;
+			for(var i=0; i<v.length; i++){
+				// Skip functions and undefined values
+				// if(v[i]==undef || typeof(v[i])=="function")
+				//   continue;
+				if(first){
+					first = false;
+				}else{
+					d += ",";
+				}
+				d+=arguments.callee(v[i], showAll);
+			}
+			return d+"]";
+		}
+
+		if(v.constructor==Object
+		    || v.toString==describeThis){
+			if(depth>=dojo.widget.html.stabile.depthLimit)
+			  return "{ ... }";
+
+			// Instanceof Hash is good, or if we just use Objects,
+			// we can say v.constructor==Object.
+			// IE (5?) lacks hasOwnProperty, but perhaps objects do not always
+			// have prototypes??
+			if(typeof(v.hasOwnProperty)!="function" && v.prototype){
+				throw new Error("description: "+v+" not supported by script engine");
+			}
+			var first = true;
+			d = "{";
+			dojo.widget.html.stabile._depth++;
+			for(var key in v){
+				// Skip values that are functions or undefined.
+				if(v[key]==void(0) || typeof(v[key])=="function")
+					continue;
+				if(first){
+					first = false;
+				}else{
+					d += ", ";
+				}
+				var kd = key;
+				// If the key is not a legal identifier, use its description.
+				// For strings this will quote the stirng.
+				if(!kd.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)){
+					kd = arguments.callee(key, showAll);
+				}
+				d += kd+": "+arguments.callee(v[key], showAll);
+			}
+			return d+"}";
+		}
+
+		if(showAll){
+			if(dojo.widget.html.stabile._recur){
+				// Save the original definitions of toString;
+				var objectToString = Object.prototype.toString;
+				return objectToString.apply(v, []);
+			}else{
+				dojo.widget.html.stabile._recur = true;
+				return v.toString();
+			}
+		}else{
+			// log("Description? "+v.toString()+", "+typeof(v));
+			throw new Error("Unknown type: "+v);
+			return "'unknown'";
+		}
+
+	} finally {
+		// Always restore the global current depth.
+		dojo.widget.html.stabile._depth = depth;
+	}
+
+}
+
+
+
+//// PRIVATE TO MODULE
+
+// Gets an object (form field) with a read/write "value" property.
+// 
+dojo.widget.html.stabile.getStorage = function(){
+	if (dojo.widget.html.stabile.dataField) {
+		return dojo.widget.html.stabile.dataField;
+	}
+	var form = document.forms._dojo_form;
+	return dojo.widget.html.stabile.dataField = form ? form.stabile : {value: ""};
+}
+

Modified: tags/parley-0.53/root/static/magic/src/widget/svg/Chart.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/svg/Chart.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/svg/Chart.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,347 +8,433 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.svg.Chart");
 
-
-dojo.provide("dojo.widget.svg.Chart");
 dojo.require("dojo.widget.HtmlWidget");
 dojo.require("dojo.widget.Chart");
-dojo.require("dojo.html.layout");
 dojo.require("dojo.math");
+dojo.require("dojo.html");
 dojo.require("dojo.svg");
-dojo.require("dojo.gfx.color");
-dojo.require("dojo.json");
-dojo.widget.defineWidget("dojo.widget.svg.Chart", [dojo.widget.HtmlWidget, dojo.widget.Chart], function () {
-	this.templatePath = null;
-	this.templateCssPath = null;
-	this._isInitialize = false;
-	this.hasData = false;
-	this.vectorNode = null;
-	this.plotArea = null;
-	this.dataGroup = null;
-	this.axisGroup = null;
-	this.properties = {height:0, width:0, defaultWidth:600, defaultHeight:400, plotType:null, padding:{top:10, bottom:2, left:60, right:30}, axes:{x:{plotAt:0, label:"", unitLabel:"", unitType:Number, nUnitsToShow:10, range:{min:0, max:200}}, y:{plotAt:0, label:"", unitLabel:"", unitType:Number, nUnitsToShow:10, range:{min:0, max:200}}}};
-}, {parseProperties:function (node) {
-	var bRangeX = false;
-	var bRangeY = false;
-	if (node.getAttribute("width")) {
-		this.properties.width = node.getAttribute("width");
-	}
-	if (node.getAttribute("height")) {
-		this.properties.height = node.getAttribute("height");
-	}
-	if (node.getAttribute("plotType")) {
-		this.properties.plotType = node.getAttribute("plotType");
-	}
-	if (node.getAttribute("padding")) {
-		if (node.getAttribute("padding").indexOf(",") > -1) {
-			var p = node.getAttribute("padding").split(",");
-		} else {
-			var p = node.getAttribute("padding").split(" ");
-		}
-		if (p.length == 1) {
-			var pad = parseFloat(p[0]);
-			this.properties.padding.top = pad;
-			this.properties.padding.right = pad;
-			this.properties.padding.bottom = pad;
-			this.properties.padding.left = pad;
-		} else {
-			if (p.length == 2) {
-				var padV = parseFloat(p[0]);
-				var padH = parseFloat(p[1]);
-				this.properties.padding.top = padV;
-				this.properties.padding.right = padH;
-				this.properties.padding.bottom = padV;
-				this.properties.padding.left = padH;
-			} else {
-				if (p.length == 4) {
-					this.properties.padding.top = parseFloat(p[0]);
-					this.properties.padding.right = parseFloat(p[1]);
-					this.properties.padding.bottom = parseFloat(p[2]);
-					this.properties.padding.left = parseFloat(p[3]);
+dojo.require("dojo.graphics.color");
+
+dojo.widget.svg.Chart=function(){
+	dojo.widget.Chart.call(this);
+	dojo.widget.HtmlWidget.call(this);
+};
+dojo.inherits(dojo.widget.svg.Chart, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.svg.Chart, {
+	//	widget props
+	templatePath:null,
+	templateCssPath:null,
+
+	//	state
+	_isInitialized:false,
+	hasData:false,
+
+	//	chart props
+	vectorNode:null,
+	plotArea:null,
+	dataGroup:null,
+	axisGroup:null,
+
+	properties:{
+		height:400,	//	defaults, will resize to the domNode.
+		width:600,
+		plotType:null,
+		padding:{
+			top:10,
+			bottom:2,
+			left:60,
+			right:30
+		},
+		axes:{
+			x:{
+				plotAt:0,
+				label:"",
+				unitLabel:"",
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
 				}
+			},
+			y:{
+				plotAt:0,
+				label:"",
+				unitLabel:"",
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
 			}
 		}
-	}
-	if (node.getAttribute("rangeX")) {
-		var p = node.getAttribute("rangeX");
-		if (p.indexOf(",") > -1) {
-			p = p.split(",");
-		} else {
-			p = p.split(" ");
+	},
+	
+	fillInTemplate:function(args,frag){
+		this.initialize();
+		this.render();
+	},
+	parseData:function(){
+	},
+	initialize:function(){
+		this.parseData();
+	
+		//	begin by grabbing the table, and reading it in.
+		var table=this.domNode.getElementsByTagName("table")[0];
+		if (!table) return;
+		
+		var bRangeX=false;
+		var bRangeY=false;
+		
+		//	properties off the table
+		if (table.getAttribute("width")) this.properties.width=table.getAttribute("width");
+		if (table.getAttribute("height")) this.properties.height=table.getAttribute("height");
+		if (table.getAttribute("plotType")) this.properties.plotType=table.getAttribute("plotType");
+		if (table.getAttribute("padding")){
+			if (table.getAttribute("padding").indexOf(",") > -1)
+				var p=table.getAttribute("padding").split(","); 
+			else var p=table.getAttribute("padding").split(" ");
+			if (p.length==1){
+				var pad=parseFloat(p[0]);
+				this.properties.padding.top=pad;
+				this.properties.padding.right=pad;
+				this.properties.padding.bottom=pad;
+				this.properties.padding.left=pad;
+			} else if(p.length==2){
+				var padV=parseFloat(p[0]);
+				var padH=parseFloat(p[1]);
+				this.properties.padding.top=padV;
+				this.properties.padding.right=padH;
+				this.properties.padding.bottom=padV;
+				this.properties.padding.left=padH;
+			} else if(p.length==4){
+				this.properties.padding.top=parseFloat(p[0]);
+				this.properties.padding.right=parseFloat(p[1]);
+				this.properties.padding.bottom=parseFloat(p[2]);
+				this.properties.padding.left=parseFloat(p[3]);
+			}
 		}
-		this.properties.axes.x.range.min = parseFloat(p[0]);
-		this.properties.axes.x.range.max = parseFloat(p[1]);
-		bRangeX = true;
-	}
-	if (node.getAttribute("rangeY")) {
-		var p = node.getAttribute("rangeY");
-		if (p.indexOf(",") > -1) {
-			p = p.split(",");
-		} else {
-			p = p.split(" ");
+		if (table.getAttribute("rangeX")){
+			var p=table.getAttribute("rangeX");
+			if (p.indexOf(",")>-1) p=p.split(",");
+			else p=p.split(" ");
+			this.properties.axes.x.range.min=parseFloat(p[0]);
+			this.properties.axes.x.range.max=parseFloat(p[1]);
+			bRangeX=true;
 		}
-		this.properties.axes.y.range.min = parseFloat(p[0]);
-		this.properties.axes.y.range.max = parseFloat(p[1]);
-		bRangeY = true;
-	}
-	return {rangeX:bRangeX, rangeY:bRangeY};
-}, setAxesPlot:function (table) {
-	if (table.getAttribute("axisAt")) {
-		var p = table.getAttribute("axisAt");
-		if (p.indexOf(",") > -1) {
-			p = p.split(",");
-		} else {
-			p = p.split(" ");
+		if (table.getAttribute("rangeY")){
+			var p=table.getAttribute("rangeY");
+			if (p.indexOf(",")>-1) p=p.split(",");
+			else p=p.split(" ");
+			this.properties.axes.y.range.min=parseFloat(p[0]);
+			this.properties.axes.y.range.max=parseFloat(p[1]);
+			bRangeY=true;
 		}
-		if (!isNaN(parseFloat(p[0]))) {
-			this.properties.axes.x.plotAt = parseFloat(p[0]);
-		} else {
-			if (p[0].toLowerCase() == "ymin") {
-				this.properties.axes.x.plotAt = this.properties.axes.y.range.min;
-			} else {
-				if (p[0].toLowerCase() == "ymax") {
-					this.properties.axes.x.plotAt = this.properties.axes.y.range.max;
-				}
-			}
+
+		var thead=table.getElementsByTagName("thead")[0];
+		var tbody=table.getElementsByTagName("tbody")[0];
+		if(!(thead&&tbody)) dojo.raise("dojo.widget.Chart: supplied table must define a head and a body.");
+
+		//	set up the series.
+		var columns=thead.getElementsByTagName("tr")[0].getElementsByTagName("th");	//	should be <tr><..>
+		
+		//	assume column 0 == X
+		for (var i=1; i<columns.length; i++){
+			var key="column"+i;
+			var label=columns[i].innerHTML;
+			var plotType=columns[i].getAttribute("plotType")||"line";
+			var color=columns[i].getAttribute("color");
+			var ds=new dojo.widget.Chart.DataSeries(key,label,plotType,color);
+			this.series.push(ds);
 		}
-		if (!isNaN(parseFloat(p[1]))) {
-			this.properties.axes.y.plotAt = parseFloat(p[1]);
-		} else {
-			if (p[1].toLowerCase() == "xmin") {
-				this.properties.axes.y.plotAt = this.properties.axes.x.range.min;
-			} else {
-				if (p[1].toLowerCase() == "xmax") {
-					this.properties.axes.y.plotAt = this.properties.axes.x.range.max;
+
+		//	ok, get the values.
+		var rows=tbody.getElementsByTagName("tr");
+		var xMin=Number.MAX_VALUE,xMax=Number.MIN_VALUE;
+		var yMin=Number.MAX_VALUE,yMax=Number.MIN_VALUE;
+		var ignore = [
+			"accesskey","align","bgcolor","class",
+			"colspan","height","id","nowrap",
+			"rowspan","style","tabindex","title",
+			"valign","width"
+		];
+
+		for(var i=0; i<rows.length; i++){
+			var row=rows[i];
+			var cells=row.getElementsByTagName("td");
+			var x=Number.MIN_VALUE;
+			for (var j=0; j<cells.length; j++){
+				if (j==0){
+					x=parseFloat(cells[j].innerHTML);
+					xMin=Math.min(xMin, x);
+					xMax=Math.max(xMax, x);
+				} else {
+					var ds=this.series[j-1];
+					var y=parseFloat(cells[j].innerHTML);
+					yMin=Math.min(yMin,y);
+					yMax=Math.max(yMax,y);
+					var o={x:x, value:y};
+					var attrs=cells[j].attributes;
+					for(var k=0; k<attrs.length; k++){
+						var attr=attrs.item(k);
+						var bIgnore=false;
+						for (var l=0; l<ignore.length; l++){
+							if (attr.nodeName.toLowerCase()==ignore[l]){
+								bIgnore=true;
+								break;
+							}
+						}
+						if(!bIgnore) o[attr.nodeName]=attr.nodeValue;
+					}
+					ds.add(o);
 				}
 			}
 		}
-	} else {
-		this.properties.axes.x.plotAt = this.properties.axes.y.range.min;
-		this.properties.axes.y.plotAt = this.properties.axes.x.range.min;
-	}
-}, drawVectorNode:function () {
-	dojo.svg.g.suspend();
-	if (this.vectorNode) {
-		this.destroy();
-	}
-	this.vectorNode = document.createElementNS(dojo.svg.xmlns.svg, "svg");
-	this.vectorNode.setAttribute("width", this.properties.width);
-	this.vectorNode.setAttribute("height", this.properties.height);
-	dojo.svg.g.resume();
-}, drawPlotArea:function () {
-	dojo.svg.g.suspend();
-	if (this.plotArea) {
-		this.plotArea.parentNode.removeChild(this.plotArea);
-		this.plotArea = null;
-	}
-	var defs = document.createElementNS(dojo.svg.xmlns.svg, "defs");
-	var clip = document.createElementNS(dojo.svg.xmlns.svg, "clipPath");
-	clip.setAttribute("id", "plotClip" + this.widgetId);
-	var rect = document.createElementNS(dojo.svg.xmlns.svg, "rect");
-	rect.setAttribute("x", this.properties.padding.left);
-	rect.setAttribute("y", this.properties.padding.top);
-	rect.setAttribute("width", this.properties.width - this.properties.padding.left - this.properties.padding.right);
-	rect.setAttribute("height", this.properties.height - this.properties.padding.top - this.properties.padding.bottom);
-	clip.appendChild(rect);
-	defs.appendChild(clip);
-	this.vectorNode.appendChild(defs);
-	this.plotArea = document.createElementNS(dojo.svg.xmlns.svg, "g");
-	this.vectorNode.appendChild(this.plotArea);
-	var rect = document.createElementNS(dojo.svg.xmlns.svg, "rect");
-	rect.setAttribute("x", this.properties.padding.left);
-	rect.setAttribute("y", this.properties.padding.top);
-	rect.setAttribute("width", this.properties.width - this.properties.padding.left - this.properties.padding.right);
-	rect.setAttribute("height", this.properties.height - this.properties.padding.top - this.properties.padding.bottom);
-	rect.setAttribute("fill", "#fff");
-	this.plotArea.appendChild(rect);
-	dojo.svg.g.resume();
-}, drawDataGroup:function () {
-	dojo.svg.g.suspend();
-	if (this.dataGroup) {
-		this.dataGroup.parentNode.removeChild(this.dataGroup);
-		this.dataGroup = null;
-	}
-	this.dataGroup = document.createElementNS(dojo.svg.xmlns.svg, "g");
-	this.dataGroup.setAttribute("style", "clip-path:url(#plotClip" + this.widgetId + ");");
-	this.plotArea.appendChild(this.dataGroup);
-	dojo.svg.g.resume();
-}, drawAxes:function () {
-	dojo.svg.g.suspend();
-	if (this.axisGroup) {
-		this.axisGroup.parentNode.removeChild(this.axisGroup);
-		this.axisGroup = null;
-	}
-	this.axisGroup = document.createElementNS(dojo.svg.xmlns.svg, "g");
-	this.plotArea.appendChild(this.axisGroup);
-	var stroke = 1;
-	var line = document.createElementNS(dojo.svg.xmlns.svg, "line");
-	var y = dojo.widget.svg.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
-	line.setAttribute("y1", y);
-	line.setAttribute("y2", y);
-	line.setAttribute("x1", this.properties.padding.left - stroke);
-	line.setAttribute("x2", this.properties.width - this.properties.padding.right);
-	line.setAttribute("style", "stroke:#000;stroke-width:" + stroke + ";");
-	this.axisGroup.appendChild(line);
-	var textSize = 10;
-	var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
-	text.setAttribute("x", this.properties.padding.left);
-	text.setAttribute("y", this.properties.height - this.properties.padding.bottom + textSize + 2);
-	text.setAttribute("style", "text-anchor:middle;font-size:" + textSize + "px;fill:#000;");
-	text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.min), 2)));
-	this.axisGroup.appendChild(text);
-	var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
-	text.setAttribute("x", this.properties.width - this.properties.padding.right - (textSize / 2));
-	text.setAttribute("y", this.properties.height - this.properties.padding.bottom + textSize + 2);
-	text.setAttribute("style", "text-anchor:middle;font-size:" + textSize + "px;fill:#000;");
-	text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.max), 2)));
-	this.axisGroup.appendChild(text);
-	var line = document.createElementNS(dojo.svg.xmlns.svg, "line");
-	var x = dojo.widget.svg.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
-	line.setAttribute("x1", x);
-	line.setAttribute("x2", x);
-	line.setAttribute("y1", this.properties.padding.top);
-	line.setAttribute("y2", this.properties.height - this.properties.padding.bottom);
-	line.setAttribute("style", "stroke:#000;stroke-width:" + stroke + ";");
-	this.axisGroup.appendChild(line);
-	var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
-	text.setAttribute("x", this.properties.padding.left - 4);
-	text.setAttribute("y", this.properties.height - this.properties.padding.bottom);
-	text.setAttribute("style", "text-anchor:end;font-size:" + textSize + "px;fill:#000;");
-	text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.min), 2)));
-	this.axisGroup.appendChild(text);
-	var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
-	text.setAttribute("x", this.properties.padding.left - 4);
-	text.setAttribute("y", this.properties.padding.top + (textSize / 2));
-	text.setAttribute("style", "text-anchor:end;font-size:" + textSize + "px;fill:#000;");
-	text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.max), 2)));
-	this.axisGroup.appendChild(text);
-	dojo.svg.g.resume();
-}, init:function () {
-	if (!this.properties.width || !this.properties.height) {
-		var box = dojo.html.getContentBox(this.domNode);
-		if (!this.properties.width) {
-			this.properties.width = (box.width < 32) ? this.properties.defaultWidth : box.width;
+
+		//	fix the axes
+		if(!bRangeX){
+			this.properties.axes.x.range={min:xMin, max:xMax};
 		}
-		if (!this.properties.height) {
-			this.properties.height = (box.height < 32) ? this.properties.defaultHeight : box.height;
+		if(!bRangeY){
+			this.properties.axes.y.range={min:yMin, max:yMax};
 		}
-	}
-	this.drawVectorNode();
-	this.drawPlotArea();
-	this.drawDataGroup();
-	this.drawAxes();
-	this.domNode.appendChild(this.vectorNode);
-	this.assignColors();
-	this._isInitialized = true;
-}, destroy:function () {
-	while (this.domNode.childNodes.length > 0) {
-		this.domNode.removeChild(this.domNode.childNodes.item(0));
-	}
-	this.vectorNode = this.plotArea = this.dataGroup = this.axisGroup = null;
-}, render:function () {
-	dojo.svg.g.suspend();
-	if (this.dataGroup) {
-		while (this.dataGroup.childNodes.length > 0) {
-			this.dataGroup.removeChild(this.dataGroup.childNodes.item(0));
+
+		//	where to plot the axes
+		if (table.getAttribute("axisAt")){
+			var p=table.getAttribute("axisAt");
+			if (p.indexOf(",")>-1) p=p.split(",");
+			else p=p.split(" ");
+			
+			//	x axis
+			if (!isNaN(parseFloat(p[0]))){
+				this.properties.axes.x.plotAt=parseFloat(p[0]);
+			} else if (p[0].toLowerCase()=="ymin"){
+				this.properties.axes.x.plotAt=this.properties.axes.y.range.min;
+			} else if (p[0].toLowerCase()=="ymax"){
+				this.properties.axes.x.plotAt=this.properties.axes.y.range.max;
+			}
+
+			// y axis
+			if (!isNaN(parseFloat(p[1]))){
+				this.properties.axes.y.plotAt=parseFloat(p[1]);
+			} else if (p[1].toLowerCase()=="xmin"){
+				this.properties.axes.y.plotAt=this.properties.axes.x.range.min;
+			} else if (p[1].toLowerCase()=="xmax"){
+				this.properties.axes.y.plotAt=this.properties.axes.x.range.max;
+			}
+		} else {
+			this.properties.axes.x.plotAt=this.properties.axes.y.range.min;
+			this.properties.axes.y.plotAt=this.properties.axes.x.range.min;
 		}
-	} else {
-		this.init();
-	}
-	for (var i = 0; i < this.series.length; i++) {
-		dojo.widget.svg.Chart.Plotter.plot(this.series[i], this);
-	}
-	dojo.svg.g.resume();
-}, postCreate:function () {
-	var table = this.domNode.getElementsByTagName("table")[0];
-	if (table) {
-		var ranges = this.parseProperties(table);
-		var bRangeX = false;
-		var bRangeY = false;
-		var axisValues = this.parseData(table);
-		if (!bRangeX) {
-			this.properties.axes.x.range = {min:axisValues.x.min, max:axisValues.x.max};
+
+		//	table values should be populated, now pop it off.
+		this.domNode.removeChild(table);
+
+		//	get the width and the height.
+//		this.properties.width=dojo.html.getInnerWidth(this.domNode);
+//		this.properties.height=dojo.html.getInnerHeight(this.domNode);
+
+		// ok, lets create the chart itself.
+		dojo.svg.g.suspend();		
+		if(this.vectorNode) this.destroy();
+		this.vectorNode=document.createElementNS(dojo.svg.xmlns.svg, "svg");
+		this.vectorNode.setAttribute("width", this.properties.width);
+		this.vectorNode.setAttribute("height", this.properties.height);
+
+		//	set up the clip path for the plot area.
+		var defs = document.createElementNS(dojo.svg.xmlns.svg, "defs");
+		var clip = document.createElementNS(dojo.svg.xmlns.svg, "clipPath");
+		clip.setAttribute("id","plotClip"+this.widgetId);
+		var rect = document.createElementNS(dojo.svg.xmlns.svg, "rect");		
+		rect.setAttribute("x", this.properties.padding.left);
+		rect.setAttribute("y", this.properties.padding.top);
+		rect.setAttribute("width", this.properties.width-this.properties.padding.left-this.properties.padding.right);
+		rect.setAttribute("height", this.properties.height-this.properties.padding.bottom-this.properties.padding.bottom);
+		clip.appendChild(rect);
+		defs.appendChild(clip);
+		this.vectorNode.appendChild(defs);
+
+		//	the plot background.
+		this.plotArea = document.createElementNS(dojo.svg.xmlns.svg, "g");
+		this.vectorNode.appendChild(this.plotArea);
+		var rect = document.createElementNS(dojo.svg.xmlns.svg, "rect");		
+		rect.setAttribute("x", this.properties.padding.left);
+		rect.setAttribute("y", this.properties.padding.top);
+		rect.setAttribute("width", this.properties.width-this.properties.padding.left-this.properties.padding.right);
+		rect.setAttribute("height", this.properties.height-this.properties.padding.bottom-this.properties.padding.bottom);
+		rect.setAttribute("fill", "#fff");
+		this.plotArea.appendChild(rect);
+
+		//	data group
+		this.dataGroup = document.createElementNS(dojo.svg.xmlns.svg, "g");
+		this.dataGroup.setAttribute("style","clip-path:url(#plotClip"+this.widgetId+");");
+		this.plotArea.appendChild(this.dataGroup);
+
+		//	axis group
+		this.axisGroup = document.createElementNS(dojo.svg.xmlns.svg, "g");
+		this.plotArea.appendChild(this.axisGroup);
+
+		//	x axis
+		var stroke=1;
+		var line = document.createElementNS(dojo.svg.xmlns.svg, "line");
+		var y=dojo.widget.svg.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
+		line.setAttribute("y1", y);
+		line.setAttribute("y2", y);
+		line.setAttribute("x1",this.properties.padding.left-stroke);
+		line.setAttribute("x2",this.properties.width-this.properties.padding.right);
+		line.setAttribute("style","stroke:#000;stroke-width:"+stroke+";");
+		this.axisGroup.appendChild(line);
+		
+		//	x axis units.
+		//	(min and max)
+		var textSize=10;
+		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
+		text.setAttribute("x", this.properties.padding.left);
+		text.setAttribute("y", this.properties.height-this.properties.padding.bottom+textSize+2);
+		text.setAttribute("style", "text-anchor:middle;font-size:"+textSize+"px;fill:#000;");
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.min),2)));
+		this.axisGroup.appendChild(text);
+		
+		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
+		text.setAttribute("x", this.properties.width-this.properties.padding.right-(textSize/2));
+		text.setAttribute("y", this.properties.height-this.properties.padding.bottom+textSize+2);
+		text.setAttribute("style", "text-anchor:middle;font-size:"+textSize+"px;fill:#000;");
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.max),2)));
+		this.axisGroup.appendChild(text);	
+		
+		//	y axis
+		var line=document.createElementNS(dojo.svg.xmlns.svg, "line");
+		var x=dojo.widget.svg.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
+		line.setAttribute("x1", x);
+		line.setAttribute("x2", x);
+		line.setAttribute("y1", this.properties.padding.top);
+		line.setAttribute("y2", this.properties.height-this.properties.padding.bottom);
+		line.setAttribute("style", "stroke:#000;stroke-width:"+stroke+";");
+		this.axisGroup.appendChild(line);
+
+		//	y axis units
+		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
+		text.setAttribute("x", this.properties.padding.left-4);
+		text.setAttribute("y", this.properties.height-this.properties.padding.bottom);
+		text.setAttribute("style", "text-anchor:end;font-size:"+textSize+"px;fill:#000;");
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.min),2)));
+		this.axisGroup.appendChild(text);
+		
+		var text = document.createElementNS(dojo.svg.xmlns.svg, "text");
+		text.setAttribute("x", this.properties.padding.left-4);
+		text.setAttribute("y", this.properties.padding.top+(textSize/2));
+		text.setAttribute("style", "text-anchor:end;font-size:"+textSize+"px;fill:#000;");
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.max),2)));
+		this.axisGroup.appendChild(text);	
+
+		this.domNode.appendChild(this.vectorNode);
+		dojo.svg.g.resume();
+
+		//	this is last.
+		this.assignColors();
+		this._isInitialized=true;
+	},
+	destroy:function(){
+		while(this.domNode.childNodes.length>0){
+			this.domNode.removeChild(this.domNode.childNodes.item(0));
 		}
-		if (!bRangeY) {
-			this.properties.axes.y.range = {min:axisValues.y.min, max:axisValues.y.max};
+		this.vectorNode=this.plotArea=this.dataGroup=this.axisGroup=null;
+	},
+	render:function(){
+		dojo.svg.g.suspend();
+		
+		if (this.dataGroup){
+			while(this.dataGroup.childNodes.length>0){
+				this.dataGroup.removeChild(this.dataGroup.childNodes.item(0));
+			}
+		} else {
+			this.initialize();
 		}
-		this.setAxesPlot(table);
-		this.domNode.removeChild(table);
+
+		//	the remove/append is an attempt to streamline the rendering, it's totally optional
+//		var p=this.dataGroup.parentNode;
+//		p.removeChild(this.dataGroup);
+		for(var i=0; i<this.series.length; i++){
+			dojo.widget.svg.Chart.Plotter.plot(this.series[i], this);
+		}
+//		p.appendChild(this.dataGroup);
+		
+		dojo.svg.g.resume();
 	}
-	if (this.series.length > 0) {
-		this.render();
-	}
-}});
-dojo.widget.svg.Chart.Plotter = new function () {
-	var self = this;
+});
+
+dojo.widget.svg.Chart.Plotter=new function(){
+	var _this=this;
 	var plotters = {};
-	var types = dojo.widget.Chart.PlotTypes;
-	this.getX = function (value, chart) {
-		var v = parseFloat(value);
-		var min = chart.properties.axes.x.range.min;
-		var max = chart.properties.axes.x.range.max;
-		var ofst = 0 - min;
-		min += ofst;
-		max += ofst;
-		v += ofst;
-		var xmin = chart.properties.padding.left;
-		var xmax = chart.properties.width - chart.properties.padding.right;
-		var x = (v * ((xmax - xmin) / max)) + xmin;
+	var types=dojo.widget.Chart.PlotTypes;
+	
+	this.getX=function(value, chart){
+		var v=parseFloat(value);
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+		min+=ofst; max+=ofst; v+=ofst;
+
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var x=(v*((xmax-xmin)/max))+xmin;
 		return x;
 	};
-	this.getY = function (value, chart) {
-		var v = parseFloat(value);
-		var max = chart.properties.axes.y.range.max;
-		var min = chart.properties.axes.y.range.min;
-		var ofst = 0;
-		if (min < 0) {
-			ofst += Math.abs(min);
-		}
-		min += ofst;
-		max += ofst;
-		v += ofst;
-		var ymin = chart.properties.height - chart.properties.padding.bottom;
-		var ymax = chart.properties.padding.top;
-		var y = (((ymin - ymax) / (max - min)) * (max - v)) + ymax;
+	this.getY=function(value, chart){
+		var v=parseFloat(value);
+		var max=chart.properties.axes.y.range.max;
+		var min=chart.properties.axes.y.range.min;
+		var ofst=0;
+		if(min<0)ofst+=Math.abs(min);
+		min+=ofst; max+=ofst; v+=ofst;
+		
+		var ymin=chart.properties.height-chart.properties.padding.bottom;
+		var ymax=chart.properties.padding.top;
+		var y=(((ymin-ymax)/(max-min))*(max-v))+ymax;
 		return y;
 	};
-	this.addPlotter = function (name, func) {
-		plotters[name] = func;
+
+	this.addPlotter=function(name, func){
+		plotters[name]=func;
 	};
-	this.plot = function (series, chart) {
-		if (series.values.length == 0) {
-			return;
-		}
-		if (series.plotType && plotters[series.plotType]) {
+	this.plot=function(series, chart){
+		if (series.values.length==0) return;
+		if (series.plotType && plotters[series.plotType]){
 			return plotters[series.plotType](series, chart);
-		} else {
-			if (chart.plotType && plotters[chart.plotType]) {
-				return plotters[chart.plotType](series, chart);
-			}
 		}
+		else if (chart.plotType && plotters[chart.plotType]){
+			return plotters[chart.plotType](series, chart);
+		}
 	};
-	plotters["bar"] = function (series, chart) {
-		var space = 1;
+
+	//	plotting
+	plotters[types.Bar]=function(series, chart){
+		var space=1;
 		var lastW = 0;
-		for (var i = 0; i < series.values.length; i++) {
-			var x = self.getX(series.values[i].x, chart);
+		for (var i=0; i<series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
 			var w;
-			if (i == series.values.length - 1) {
-				w = lastW;
-			} else {
-				w = self.getX(series.values[i + 1].x, chart) - x - space;
-				lastW = w;
+			if (i==series.values.length-1){
+				w=lastW;
+			} else{
+				w=_this.getX(series.values[i+1].x, chart)-x-space;
+				lastW=w;
 			}
-			x -= (w / 2);
-			var yA = self.getY(chart.properties.axes.x.plotAt, chart);
-			var y = self.getY(series.values[i].value, chart);
-			var h = Math.abs(yA - y);
-			if (parseFloat(series.values[i].value) < chart.properties.axes.x.plotAt) {
-				var oy = yA;
-				yA = y;
-				y = oy;
+			x-=(w/2);
+
+			var yA=_this.getY(chart.properties.axes.x.plotAt, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var h=Math.abs(yA-y);
+			if (parseFloat(series.values[i].value)<chart.properties.axes.x.plotAt){
+				var oy=yA;
+				yA=y;
+				y=oy;
 			}
-			var bar = document.createElementNS(dojo.svg.xmlns.svg, "rect");
+
+			var bar=document.createElementNS(dojo.svg.xmlns.svg, "rect");
 			bar.setAttribute("fill", series.color);
 			bar.setAttribute("title", series.label + ": " + series.values[i].value);
 			bar.setAttribute("stroke-width", "0");
@@ -360,8 +446,8 @@
 			chart.dataGroup.appendChild(bar);
 		}
 	};
-	plotters["line"] = function (series, chart) {
-		var tension = 1.5;
+	plotters[types.Line]=function(series, chart){
+		var tension=3;
 		var line = document.createElementNS(dojo.svg.xmlns.svg, "path");
 		line.setAttribute("fill", "none");
 		line.setAttribute("stroke", series.color);
@@ -369,104 +455,77 @@
 		line.setAttribute("stroke-opacity", "0.85");
 		line.setAttribute("title", series.label);
 		chart.dataGroup.appendChild(line);
+
 		var path = [];
-		for (var i = 0; i < series.values.length; i++) {
-			var x = self.getX(series.values[i].x, chart);
-			var y = self.getY(series.values[i].value, chart);
-			var dx = chart.properties.padding.left + 1;
-			var dy = chart.properties.height - chart.properties.padding.bottom;
-			if (i > 0) {
-				dx = x - self.getX(series.values[i - 1].x, chart);
-				dy = self.getY(series.values[i - 1].value, chart);
+		for (var i=0; i<series.values.length; i++){
+			var x = _this.getX(series.values[i].x, chart)
+			var y = _this.getY(series.values[i].value, chart);
+
+			var dx = chart.properties.padding.left+1;
+			var dy = chart.properties.height-chart.properties.padding.bottom;
+			if (i>0){
+				dx=x-_this.getX(series.values[i-1].x, chart);
+				dy=_this.getY(series.values[i-1].value, chart);
 			}
-			if (i == 0) {
-				path.push("M");
-			} else {
+			
+			if (i==0) path.push("M");
+			else {
 				path.push("C");
-				var cx = x - (tension - 1) * (dx / tension);
-				path.push(cx + "," + dy);
-				cx = x - (dx / tension);
-				path.push(cx + "," + y);
+				var cx=x-(tension-1)*(dx/tension);
+				path.push(cx+","+dy);
+				cx=x-(dx/tension);
+				path.push(cx+","+y);
 			}
-			path.push(x + "," + y);
+			path.push(x+","+y);
 		}
 		line.setAttribute("d", path.join(" "));
 	};
-	plotters["area"] = function (series, chart) {
-		var tension = 1.5;
-		var line = document.createElementNS(dojo.svg.xmlns.svg, "path");
-		line.setAttribute("fill", series.color);
-		line.setAttribute("fill-opacity", "0.4");
-		line.setAttribute("stroke", series.color);
-		line.setAttribute("stroke-width", "1");
-		line.setAttribute("stroke-opacity", "0.8");
-		line.setAttribute("title", series.label);
-		chart.dataGroup.appendChild(line);
-		var path = [];
-		for (var i = 0; i < series.values.length; i++) {
-			var x = self.getX(series.values[i].x, chart);
-			var y = self.getY(series.values[i].value, chart);
-			var dx = chart.properties.padding.left + 1;
-			var dy = chart.properties.height - chart.properties.padding.bottom;
-			if (i > 0) {
-				dx = x - self.getX(series.values[i - 1].x, chart);
-				dy = self.getY(series.values[i - 1].value, chart);
-			}
-			if (i == 0) {
-				path.push("M");
-			} else {
-				path.push("C");
-				var cx = x - (tension - 1) * (dx / tension);
-				path.push(cx + "," + dy);
-				cx = x - (dx / tension);
-				path.push(cx + "," + y);
-			}
-			path.push(x + "," + y);
-		}
-		path.push("L");
-		path.push(x + "," + self.getY(0, chart));
-		path.push("L");
-		path.push(self.getX(0, chart) + "," + self.getY(0, chart));
-		path.push("Z");
-		line.setAttribute("d", path.join(" "));
-	}, plotters["scatter"] = function (series, chart) {
-		var r = 7;
-		for (var i = 0; i < series.values.length; i++) {
-			var x = self.getX(series.values[i].x, chart);
-			var y = self.getY(series.values[i].value, chart);
+	plotters[types.Scatter]=function(series, chart){
+		var r=7;
+		for (var i=0; i<series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var y=_this.getY(series.values[i].value, chart);
 			var point = document.createElementNS(dojo.svg.xmlns.svg, "path");
 			point.setAttribute("fill", series.color);
 			point.setAttribute("stroke-width", "0");
 			point.setAttribute("title", series.label + ": " + series.values[i].value);
-			point.setAttribute("d", "M " + x + "," + (y - r) + " " + "Q " + x + "," + y + " " + (x + r) + "," + y + " " + "Q " + x + "," + y + " " + x + "," + (y + r) + " " + "Q " + x + "," + y + " " + (x - r) + "," + y + " " + "Q " + x + "," + y + " " + x + "," + (y - r) + " " + "Z");
+			point.setAttribute("d",
+				"M " + x + "," + (y-r) + " " +
+				"Q " + x + "," + y + " " + (x+r) + "," + y + " " +
+				"Q " + x + "," + y + " " + x + "," + (y+r) + " " +
+				"Q " + x + "," + y + " " + (x-r) + "," + y + " " +
+				"Q " + x + "," + y + " " + x + "," + (y-r) + " " +
+				"Z"
+			);
 			chart.dataGroup.appendChild(point);
 		}
 	};
-	plotters["bubble"] = function (series, chart) {
-		var minR = 1;
-		var min = chart.properties.axes.x.range.min;
-		var max = chart.properties.axes.x.range.max;
-		var ofst = 0 - min;
-		min += ofst;
-		max += ofst;
-		var xmin = chart.properties.padding.left;
-		var xmax = chart.properties.width - chart.properties.padding.right;
-		var factor = (max - min) / (xmax - xmin) * 25;
-		for (var i = 0; i < series.values.length; i++) {
+	plotters[types.Bubble]=function(series, chart){
+		//	added param for series[n].value: size
+		var minR=1;
+		
+		//	do this off the x axis?
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+		min+=ofst; max+=ofst;
+
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var factor=(max-min)/(xmax-xmin)*25;
+		
+		for (var i=0; i<series.values.length; i++){
 			var size = series.values[i].size;
-			if (isNaN(parseFloat(size))) {
-				size = minR;
-			}
-			var point = document.createElementNS(dojo.svg.xmlns.svg, "circle");
+			if (isNaN(parseFloat(size))) size=minR;
+			var point=document.createElementNS(dojo.svg.xmlns.svg, "circle");
 			point.setAttribute("stroke-width", 0);
 			point.setAttribute("fill", series.color);
 			point.setAttribute("fill-opacity", "0.8");
-			point.setAttribute("r", (parseFloat(size) * factor) / 2);
-			point.setAttribute("cx", self.getX(series.values[i].x, chart));
-			point.setAttribute("cy", self.getY(series.values[i].value, chart));
+			point.setAttribute("r", (parseFloat(size)*factor)/2);
+			point.setAttribute("cx", _this.getX(series.values[i].x, chart));
+			point.setAttribute("cy", _this.getY(series.values[i].value, chart));
 			point.setAttribute("title", series.label + ": " + series.values[i].value + " (" + size + ")");
 			chart.dataGroup.appendChild(point);
 		}
 	};
 }();
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,22 +0,0 @@
-.dojoAccordionPane .label {
-	color: #000;
-	font-weight: bold;
-	background: url("images/soriaAccordionOff.gif") repeat-x top left #85aeec;
-	border:1px solid #d9d9d9;
-	font-size:0.9em;
-}
-
-.dojoAccordionPane-selected .label {
-	background: url("images/soriaAccordionSelected.gif") repeat-x top left #85aeec;
-	border:1px solid #84a3d1;
-}
-
-.dojoAccordionPane .label:hover {
-	cursor: pointer;
-}
-
-.dojoAccordionPane .accBody {
-	background: #fff;
-	overflow: auto;
-	border:1px solid #84a3d1;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/AccordionPane.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +0,0 @@
-<div dojoAttachPoint="domNode">
-<div dojoAttachPoint="labelNode" dojoAttachEvent="onclick: onLabelClick" class="${this.labelNodeClass}">${this.label}</div>
-<div dojoAttachPoint="containerNode" style="overflow: hidden;" class="${this.containerNodeClass}"></div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,59 +0,0 @@
-/* ---- button --- */
-.dojoButton {
-	padding: 0 0 0 0;
-	font-size: 8pt;
-	white-space: nowrap;
-	cursor: pointer;
-	font-family: Myriad, Tahoma, Verdana, sans-serif;
-}
-
-.dojoButton .dojoButtonContents {
-	padding: 2px 2px 2px 2px;
-	text-align: center;		/* if icon and label are split across two lines, center icon */
-	color: white;
-}
-
-.dojoButtonLeftPart .dojoButtonContents {
-	padding-right: 8px;
-}
-
-.dojoButtonDisabled {
-	cursor: url("images/no.gif"), default;
-}
-
-
-.dojoButtonContents img {
-	vertical-align: middle;	/* if icon and label are on same line, center them */
-}
-
-/* -------- colors ------------ */
-
-.dojoButtonHover .dojoButtonContents {
-}
-
-.dojoButtonDepressed .dojoButtonContents {
-	color: #293a4b;
-}
-
-.dojoButtonDisabled .dojoButtonContents {
-	color: #aaa;
-}
-
-
-/* ---------- drop down button specific ---------- */
-
-/* border between label and arrow (for drop down buttons */
-.dojoButton .border {
-	width: 1px;
-	background: gray;
-}
-
-/* button arrow */
-.dojoButton .downArrow {
-	padding-left: 10px;
-	text-align: center;
-}
-
-.dojoButton.disabled .downArrow {
-	cursor : default;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ButtonTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,6 +0,0 @@
-<div dojoAttachPoint="buttonNode" class="dojoButton" style="position:relative;" dojoAttachEvent="onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick; onKey:onKey; onFocus;">
-  <div class="dojoButtonContents" align=center dojoAttachPoint="containerNode" style="position:absolute;z-index:2;"></div>
-  <img dojoAttachPoint="leftImage" style="position:absolute;left:0px;">
-  <img dojoAttachPoint="centerImage" style="position:absolute;z-index:1;">
-  <img dojoAttachPoint="rightImage" style="position:absolute;top:0px;right:0px;">
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,26 +0,0 @@
-.dojoHtmlCheckbox {
-	border: 0px;
-	width: 16px;
-	height: 16px;
-	margin: 2px;
-	vertical-align: middle;
-}
-
-.dojoHtmlCheckboxOn {
-	background: url(check.gif) 0px 0px;
-}
-.dojoHtmlCheckboxOff {
-	background: url(check.gif) -16px 0px;
-}
-.dojoHtmlCheckboxDisabledOn {
-	background: url(check.gif) -32px 0px;
-}
-.dojoHtmlCheckboxDisabledOff {
-	background: url(check.gif) -48px 0px;
-}
-.dojoHtmlCheckboxOnHover {
-	background: url(check.gif) -64px 0px;
-}
-.dojoHtmlCheckboxOffHover {
-	background: url(check.gif) -80px 0px;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Checkbox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,5 +0,0 @@
-<span style="display: inline-block;" tabIndex="${this.tabIndex}" waiRole="checkbox" id="${this.id}">
-	<img dojoAttachPoint="imageNode" class="dojoHtmlCheckbox" src="${dojoWidgetModuleUri}templates/images/blank.gif" alt="" />
-	<input type="checkbox" name="${this.name}" style="display: none" value="${this.value}"
-		dojoAttachPoint="inputNode">
-</span>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/CheckboxA11y.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/CheckboxA11y.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/CheckboxA11y.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +0,0 @@
-<span class='dojoHtmlCheckbox'>
-	<input type="checkbox" name="${this.name}" tabIndex="${this.tabIndex}" id="${this.id}" value="${this.value}"
-		 dojoAttachEvent="onClick: _onClick;" dojoAttachPoint="inputNode"> 
-</span>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/CiviCrmDatePicker.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/CiviCrmDatePicker.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/CiviCrmDatePicker.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,12 +0,0 @@
-<table cellpadding="0" cellspacing="0" border="0" width="400">
-	<tr>
-		<td id="dateHolderTd" width="200">
-		</td>
-		<td id="timeHolderTd" width="200">
-		</td>
-	</tr>
-	<tr style="display: none;" id="formItemsTr">
-		<td id="formItemsTd">&nbsp;</td>
-		<td>&nbsp;</td>
-	</tr>
-</table>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,68 +0,0 @@
-.dojoComboBoxOuter {
-	border: 0px !important;
-	margin: 0px !important;
-	padding: 0px !important;
-	background: transparent !important;
-	white-space: nowrap !important;
-}
-
-.dojoComboBox {
-	border: 1px inset #afafaf;
-	margin: 0px;
-	padding: 0px;
-	vertical-align: middle !important;
-	float: none !important;
-	position: static !important;
-	display: inline !important;
-}
-
-/* the input box */
-input.dojoComboBox {
-	border-right-width: 0px !important; 
-	margin-right: 0px !important;
-	padding-right: 0px !important;
-}
-
-/* the down arrow */
-img.dojoComboBox {
-	border-left-width: 0px !important;
-	padding-left: 0px !important;
-	margin-left: 0px !important;
-}
-
-/* IE vertical-alignment calculations can be off by +-1 but these margins are collapsed away */
-.dj_ie img.dojoComboBox {
-	margin-top: 1px; 
-	margin-bottom: 1px; 
-}
-
-/* the drop down */
-.dojoComboBoxOptions {
-	font-family: Verdana, Helvetica, Garamond, sans-serif;
-	/* font-size: 0.7em; */
-	background-color: white;
-	border: 1px solid #afafaf;
-	position: absolute;
-	z-index: 1000; 
-	overflow: auto;
-	cursor: default;
-}
-
-.dojoComboBoxItem {
-	padding-left: 2px;
-	padding-top: 2px;
-	margin: 0px;
-}
-
-.dojoComboBoxItemEven {
-	background-color: #f4f4f4;
-}
-
-.dojoComboBoxItemOdd {
-	background-color: white;
-}
-
-.dojoComboBoxItemHighlight {
-	background-color: #63709A;
-	color: white;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ComboBox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,16 +0,0 @@
-<span _="whitespace and CR's between tags adds &nbsp; in FF"
-	class="dojoComboBoxOuter"
-	><input style="display:none"  tabindex="-1" name="" value="" 
-		dojoAttachPoint="comboBoxValue"
-	><input style="display:none"  tabindex="-1" name="" value="" 
-		dojoAttachPoint="comboBoxSelectionValue"
-	><input type="text" autocomplete="off" class="dojoComboBox"
-		dojoAttachEvent="key:_handleKeyEvents; keyUp: onKeyUp; compositionEnd; onResize;"
-		dojoAttachPoint="textInputNode"
-	><img hspace="0"
-		vspace="0"
-		class="dojoComboBox"
-		dojoAttachPoint="downArrowNode"
-		dojoAttachEvent="onMouseUp: handleArrowClick; onResize;"
-		src="${this.buttonSrc}"
-></span>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ComboButtonTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ComboButtonTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ComboButtonTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,18 +0,0 @@
-<div class="dojoButton" style="position:relative;top:0px;left:0px; text-align:none;" dojoAttachEvent="onKey;onFocus">
-
-	<div dojoAttachPoint="buttonNode" class="dojoButtonLeftPart" style="position:absolute;left:0px;top:0px;"
-		dojoAttachEvent="onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick;">
-		<div class="dojoButtonContents" dojoAttachPoint="containerNode" style="position:absolute;top:0px;right:0px;z-index:2;"></div>
-		<img dojoAttachPoint="leftImage" style="position:absolute;left:0px;top:0px;">
-		<img dojoAttachPoint="centerImage" style="position:absolute;right:0px;top:0px;z-index:1;">
-	</div>
-
-	<div dojoAttachPoint="rightPart" class="dojoButtonRightPart" style="position:absolute;top:0px;right:0px;"
-		dojoAttachEvent="onMouseOver:rightOver; onMouseOut:rightOut; onMouseDown:rightDown; onMouseUp:rightUp; onClick:rightClick;">
-		<img dojoAttachPoint="arrowBackgroundImage" style="position:absolute;top:0px;left:0px;z-index:1;">
-		<img src="${dojoWidgetModuleUri}templates/images/whiteDownArrow.gif"
-		  		style="z-index:2;position:absolute;left:3px;top:50%;">
-		<img dojoAttachPoint="rightImage" style="position:absolute;top:0px;right:0px;">
-	</div>
-
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,167 +0,0 @@
-.datePickerContainer {
-	width:164px; /* needed for proper user styling */
-}
-
-.calendarContainer {
-/*	border:1px solid #566f8f;*/
-}
-
-.calendarBodyContainer {
-	width:100%; /* needed for the explode effect (explain?) */
-	background: #7591bc url("images/dpBg.gif") top left repeat-x;
-}
-
-.calendarBodyContainer thead tr td {
-	color:#293a4b;
-	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
-	text-align:center;
-	padding:0.25em;
-	background: url("images/dpHorizLine.gif") bottom left repeat-x;
-}
-
-.calendarBodyContainer tbody tr td {
-	color:#fff;
-	font:bold 0.7em Helvetica, Arial, Verdana, sans-serif;
-	text-align:center;
-	padding:0.4em;
-	background: url("images/dpVertLine.gif") top right repeat-y;
-	cursor:pointer;
-	cursor:hand;
-}
-
-
-.monthWrapper {
-	padding-bottom:2px;
-	background: url("images/dpHorizLine.gif") bottom left repeat-x;
-}
-
-.monthContainer {
-	width:100%;
-}
-
-.monthLabelContainer {
-	text-align:center;
-	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
-	background: url("images/dpMonthBg.png") repeat-x top left !important;
-	color:#293a4b;
-	padding:0.25em;
-}
-
-.monthCurve {
-	width:12px;
-}
-
-.monthCurveTL {
-	background: url("images/dpCurveTL.png") no-repeat top left !important;
-}
-
-.monthCurveTR {
-		background: url("images/dpCurveTR.png") no-repeat top right !important;
-}
-
-
-.yearWrapper {
-	background: url("images/dpHorizLineFoot.gif") top left repeat-x;
-	padding-top:2px;
-}
-
-.yearContainer {
-	width:100%;
-}
-
-.yearContainer td {
-	background:url("images/dpYearBg.png") top left repeat-x;
-}
-
-.yearContainer .yearLabel {
-	margin:0;
-	padding:0.45em 0 0.45em 0;
-	color:#fff;
-	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
-	text-align:center;
-}
-
-.curveBL {
-	background: url("images/dpCurveBL.png") bottom left no-repeat !important;
-	width:9px !important;
-	padding:0;
-	margin:0;
-}
-
-.curveBR {
-	background: url("images/dpCurveBR.png") bottom right no-repeat !important;
-	width:9px !important;
-	padding:0;
-	margin:0;
-}
-
-
-.previousMonth {
-	background-color:#6782a8 !important;
-}
-
-.previousMonthDisabled {
-	background-color:#a4a5a6 !important;
-	cursor:default !important
-}
-.currentMonth {
-}
-
-.currentMonthDisabled {
-	background-color:#bbbbbc !important;
-	cursor:default !important
-}
-.nextMonth {
-	background-color:#6782a8 !important;
-}
-.nextMonthDisabled {
-	background-color:#a4a5a6 !important;
-	cursor:default !important;
-}
-
-.currentDate {
-	text-decoration:underline;
-	font-style:italic;
-}
-
-.selectedDate {
-	background-color:#fff !important;
-	color:#6782a8 !important;
-}
-
-.yearLabel .selectedYear {
-	padding:0.2em;
-	background-color:#9ec3fb !important;
-}
-
-.nextYear, .previousYear {
-	cursor:pointer;cursor:hand;
-	padding:0;
-}
-
-.nextYear {
-	margin:0 0 0 0.55em;
-}
-
-.previousYear {
-	margin:0 0.55em 0 0;
-}
-
-.incrementControl {
-	cursor:pointer;cursor:hand;
-	width:1em;
-}
-
-.increase {
-	float:right;
-}
-
-.decrease {
-	float:left;
-}
-
-.lastColumn {
-	background-image:none !important;
-}
-
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/DatePicker.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,95 +0,0 @@
-<div class="datePickerContainer" dojoAttachPoint="datePickerContainerNode">
-	<table cellspacing="0" cellpadding="0" class="calendarContainer">
-		<thead>
-			<tr>
-				<td class="monthWrapper" valign="top">
-					<table class="monthContainer" cellspacing="0" cellpadding="0" border="0">
-						<tr>
-							<td class="monthCurve monthCurveTL" valign="top"></td>
-							<td class="monthLabelContainer" valign="top">
-								<span dojoAttachPoint="increaseWeekNode" 
-									dojoAttachEvent="onClick: onIncrementWeek;" 
-									class="incrementControl increase">
-									<img src="${dojoWidgetModuleUri}templates/images/incrementMonth.png" 
-									alt="&darr;" style="width:7px;height:5px;" />
-								</span>
-								<span 
-									dojoAttachPoint="increaseMonthNode" 
-									dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl increase">
-									<img src="${dojoWidgetModuleUri}templates/images/incrementMonth.png" 
-										alt="&darr;"  dojoAttachPoint="incrementMonthImageNode">
-								</span>
-								<span 
-									dojoAttachPoint="decreaseWeekNode" 
-									dojoAttachEvent="onClick: onIncrementWeek;" 
-									class="incrementControl decrease">
-									<img src="${dojoWidgetModuleUri}templates/images/decrementMonth.png" alt="&uarr;" style="width:7px;height:5px;" />
-								</span>
-								<span 
-									dojoAttachPoint="decreaseMonthNode" 
-									dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl decrease">
-									<img src="${dojoWidgetModuleUri}templates/images/decrementMonth.png" 
-										alt="&uarr;" dojoAttachPoint="decrementMonthImageNode">
-								</span>
-								<span dojoAttachPoint="monthLabelNode" class="month"></span>
-							</td>
-							<td class="monthCurve monthCurveTR" valign="top"></td>
-						</tr>
-					</table>
-				</td>
-			</tr>
-		</thead>
-		<tbody>
-			<tr>
-				<td colspan="3">
-					<table class="calendarBodyContainer" cellspacing="0" cellpadding="0" border="0">
-						<thead>
-							<tr dojoAttachPoint="dayLabelsRow">
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-							</tr>
-						</thead>
-						<tbody dojoAttachPoint="calendarDatesContainerNode" 
-							dojoAttachEvent="onClick: _handleUiClick;">
-							<tr dojoAttachPoint="calendarWeekTemplate">
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-								<td></td>
-							</tr>
-						</tbody>
-					</table>
-				</td>
-			</tr>
-		</tbody>
-		<tfoot>
-			<tr>
-				<td colspan="3" class="yearWrapper">
-					<table cellspacing="0" cellpadding="0" border="0" class="yearContainer">
-						<tr>
-							<td class="curveBL" valign="top"></td>
-							<td valign="top">
-								<h3 class="yearLabel">
-									<span dojoAttachPoint="previousYearLabelNode"
-										dojoAttachEvent="onClick: onIncrementYear;" class="previousYear"></span>
-									<span class="selectedYear" dojoAttachPoint="currentYearLabelNode"></span>
-									<span dojoAttachPoint="nextYearLabelNode" 
-										dojoAttachEvent="onClick: onIncrementYear;" class="nextYear"></span>
-								</h3>
-							</td>
-							<td class="curveBR" valign="top"></td>
-						</tr>
-					</table>
-				</td>
-			</tr>
-		</tfoot>
-	</table>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Dialog.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Dialog.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Dialog.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,7 +0,0 @@
-<div id="${this.widgetId}" class="dojoDialog" dojoattachpoint="wrapper">
-	<span dojoattachpoint="tabStartOuter" dojoonfocus="trapTabs" dojoonblur="clearTrap"	tabindex="0"></span>
-	<span dojoattachpoint="tabStart" dojoonfocus="trapTabs" dojoonblur="clearTrap" tabindex="0"></span>
-	<div dojoattachpoint="containerNode" style="position: relative; z-index: 2;"></div>
-	<span dojoattachpoint="tabEnd" dojoonfocus="trapTabs" dojoonblur="clearTrap" tabindex="0"></span>
-	<span dojoattachpoint="tabEndOuter" dojoonfocus="trapTabs" dojoonblur="clearTrap" tabindex="0"></span>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,49 +0,0 @@
-.dojoDocPane { padding:1em; font: 1em Georgia,Times,"Times New Roman",serif; }
-
-.dojoDocPane .container{ }
-
-.dojoDocPane .dialog{ }
-.dojoDocPane .dialog .container{ padding: 0.5em; background: #fff; border: 2px solid #333; }
-.dojoDocPane .dialog .docDialog{ background: transparent; width: 20em; }
-.dojoDocPane .dialog .docDialog h2{ margin-top: 0; padding-top: 0; }
-.dojoDocPane .dialog .docDialog input { float: right; margin-right: 1em; }
-.dojoDocPane .dialog .docDialog p{ clear: both; }
-#dojoDocUserName, #dojoDocPassword { width: 10em; }
-
-.dojoDocPane .nav{ }
-.dojoDocPane .nav span{ }
-
-.dojoDocPane .detail{ }
-.dojoDocPane .detail h1{ }
-.dojoDocPane .detail h1 span.fn{ }
-.dojoDocPane .detail .description{ }
-.dojoDocPane .detail .params{ }
-.dojoDocPane .detail .params .row{ }
-.dojoDocPane .detail .params .row span{ }
-.dojoDocPane .detail .variables{ }
-.dojoDocPane .detail .variables .row{ }
-.dojoDocPane .detail .signature{ }
-.dojoDocPane .detail .signature .source{ white-space: pre; font: 0.8em Monaco, Courier, "Courier New", monospace; }
-.dojoDocPane .detail .signature .source .return{ color:#369; }
-.dojoDocPane .detail .signature .source .function{ color: #98543F; font-weight: bold; }
-.dojoDocPane .detail .signature .source .params{ }
-.dojoDocPane .detail .signature .source .params .type{ font-style: italic; color: #d17575; }
-.dojoDocPane .detail .signature .source .params .name{ color: #d14040; }
-
-.dojoDocPane .result{ }
-.dojoDocPane .result h1{ }
-.dojoDocPane .result .row{ }
-.dojoDocPane .result .row .summary{ }
-
-.dojoDocPane .package{ }
-.dojoDocPane .package h1{ }
-.dojoDocPane .package .row{ }
-.dojoDocPane .package .row .summary{ }
-.dojoDocPane .package .description{ }
-.dojoDocPane .package .methods{ }
-.dojoDocPane .package .methods h2{ }
-.dojoDocPane .package .methods .row{ }
-.dojoDocPane .package .methods .row .description{ }
-.dojoDocPane .package .requires{ }
-.dojoDocPane .package .requires h2{ }
-.dojoDocPane .package .requires .row{ }

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/DocPane.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,79 +0,0 @@
-<div class="dojoDocPane">
-	<div dojoAttachPoint="containerNode" class="container"></div>
-
-	<div dojoAttachPoint="dialog" class="dialog">
-		<div class="container" dojoAttachPoint="dialogBg">
-			<div class="docDialog" dojoAttachPoint="dialogFg">
-				<h2>Log In</h2>
-				<p><input id="dojoDocUserName" dojoAttachPoint="userName"><label for="dojoDocUserName">User Name:</label></p>
-				<p><input id="dojoDocPassword" dojoAttachPoint="password" type="password"><label for="dojoDocPassword">Password:</label></p>
-				<p><input type="button" dojoAttachPoint="cancel" value="cancel"> <input type="button" dojoAttachPoint="logIn" value="Log In"></p>
-				<p></p>
-			</div>
-		</div>
-	</div>
-
-	<div dojoAttachPoint="nav" class="nav"><span>Detail</span> | <span>Source</span> | <span>Examples</span> | <span>Walkthrough</span></div>
-
-	<div dojoAttachPoint="detail" class="detail">
-		<h1>Detail: <span class="fn" dojoAttachPoint="fn">dojo.select</span></h1>
-		<div class="description" dojoAttachPoint="description">Description</div>
-		<div class="params" dojoAttachPoint="parameters">
-			<h2>Parameters</h2>
-			<div class="row" dojoAttachPoint="pRow">
-				<span dojoAttachPoint="pOpt"><em>optional</em> </span>
-				<span><span dojoAttachPoint="pType">type</span> </span>
-				<a href="#" dojoAttachPoint="pLink">variable</a>
-				<span> - <span dojoAttachPoint="pDesc"></span></span>
-			</div>
-		</div>
-		<div class="variables" dojoAttachPoint="variables">
-			<h2>Variables</h2>
-			<div class"row" dojoAttachPoint="vRow">
-				<a href="#" dojoAttachPoint="vLink">variable</a><span> - <span dojoAttachPoint="vDesc"></span></span>
-			</div>
-		</div>
-		<div class="signature">
-			<h2>Signature</h2>
-			<div class="source">
-				<span class="return" dojoAttachPoint="sType">returnType</span> 
-				<span class="function" dojoAttachPoint="sName">foo</span>
-				(<span class="params" dojoAttachPoint="sParams">
-					<span class="type" dojoAttachPoint="sPType">type </span>
-					<span class="name" dojoAttachPoint="sPName">paramName</span>
-				</span>)
-			</div>
-		</div>
-	</div>
-	
-	<div dojoAttachPoint="result" class="result">
-		<h1>Search Results: <span dojoAttachPoint="count">0</span> matches</h1>
-		<div class="row" dojoAttachPoint="row">
-			<a href="#" dojoAttachPoint="fnLink">dojo.fnLink</a>
-			<span> - <span class="summary" dojoAttachPoint="summary">summary</span></span>
-		</div>
-	</div>
-
-	<div dojoAttachPoint="packag" class="package">
-		<h1>Package: 
-			<span class="pkg" dojoAttachPoint="pkg">dojo.package</span> 
-			<span class="edit" dojoAttachPoint="edit">[edit]</span> 
-			<span class="save" dojoAttachPoint="save">[save]</span>
-		</h1>
-		<div dojoAttachPoint="pkgDescription" class="description">Description</div>
-		<div class="methods" dojoAttachPoint="methods">
-			<h2>Methods</h2>
-			<div class="row" dojoAttachPoint="mRow">
-				<a href="#" dojoAttachPoint="mLink">method</a>
-				<span> - <span class="description" dojoAttachPoint="mDesc"></span></span>
-			</div>
-		</div>
-		<div class="requires" dojoAttachPoint="requires">
-			<h2>Requires</h2>
-			<div class="row" dojoAttachPoint="rRow">
-				<h3 dojoAttachPoint="rH3">Environment</h3>
-				<div dojoAttachPoint="rRow2"><a href="#" dojoAttachPoint="rLink" class="package">require</a></div>
-			</div>
-		</div>
-	</div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/DropDownButtonTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/DropDownButtonTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/DropDownButtonTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,9 +0,0 @@
-<button dojoAttachPoint="button" class="dojoButton dojoButtonNoHover" dojoAttachEvent="onMouseOver: ; onMouseOut: ; onClick: ;">
-  <table dojoAttachPoint="table" style="margin:0 0 0 0;"><tr>
-    <td class="label" dojoAttachPoint="labelCell"></td>
-    <td class="border" dojoAttachPoint="borderCell"></td>
-    <td class="downArrow" dojoAttachPoint="arrowCell">
-      <img dojoAttachPoint="arrow">
-    </td>
-  </tr></table>
-</button>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,152 +0,0 @@
-.StyleDropdownContainer {
-	position: absolute;
-	z-index: 1000;
-	overflow: auto;
-	cursor: default;
-	width: 250px;
-	height: 250px;
-	background-color: white;
-	border: 1px solid black;
-}
-
-.ColorDropdownContainer {
-	position: absolute;
-	z-index: 1000;
-	overflow: auto;
-	cursor: default;
-	width: 250px;
-	height: 150px;
-	background-color: white;
-	border: 1px solid black;
-}
-
-.EditorToolbarDomNode {
-	background-image: url(buttons/bg-fade.png);
-	background-repeat: repeat-x;
-	background-position: 0px -50px;
-}
-
-.EditorToolbarSmallBg {
-	background-image: url(images/toolbar-bg.gif);
-	background-repeat: repeat-x;
-	background-position: 0px 0px;
-}
-
-/*
-body {
-	background:url(images/blank.gif) fixed;
-}*/
-
-.IEFixedToolbar {
-	position:absolute;
-	/* top:0; */
-	top: expression(eval((document.documentElement||document.body).scrollTop));
-}
-
-div.bigIcon {
-	width: 40px;
-	height: 40px; 
-	/* background-color: white; */
-	/* border: 1px solid #a6a7a3; */
-	font-family: Verdana, Trebuchet, Tahoma, Arial;
-}
-
-.iconContainer {
-	font-family: Verdana, Trebuchet, Tahoma, Arial;
-	font-size: 13px;
-	float: left;
-	height: 18px;
-	display: block;
-	/* background-color: white; */
-	cursor: pointer;
-	padding: 1px 4px 1px 1px; /* almost the same as a transparent border */
-	border: 0px;
-}
-
-.dojoE2TBIcon {
-	display: block;
-	text-align: center;
-	min-width: 18px;
-	width: 18px;
-	height: 18px;
-	/* background-color: #a6a7a3; */
-	background-repeat: no-repeat;
-	background-image: url(buttons/aggregate.gif);
-}
-
-
-.dojoE2TBIcon[class~=dojoE2TBIcon] {
-}
-
-.ToolbarButtonLatched {
-    border: #316ac5 1px solid; !important;
-    padding: 0px 3px 0px 0px; !important; /* make room for border */
-    background-color: #c1d2ee;
-}
-
-.ToolbarButtonHighlighted {
-    border: #316ac5 1px solid; !important;
-    padding: 0px 3px 0px 0px; !important; /* make room for border */
-    background-color: #dff1ff;
-}
-
-.ToolbarButtonDisabled{
-    filter: gray() alpha(opacity=30); /* IE */
-    opacity: 0.30; /* Safari, Opera and Mozilla */
-}
-
-.headingContainer {
-	width: 150px;
-	height: 30px;
-	margin: 0px;
-	/* padding-left: 5px; */
-	overflow: hidden;
-	line-height: 25px;
-	border-bottom: 1px solid black;
-	border-top: 1px solid white;
-}
-
-.EditorToolbarDomNode select {
-	font-size: 14px;
-}
- 
-.dojoE2TBIcon_Sep { width: 5px; min-width: 5px; max-width: 5px; background-position: 0px 0px}
-.dojoE2TBIcon_Backcolor { background-position: -18px 0px}
-.dojoE2TBIcon_Bold { background-position: -36px 0px}
-.dojoE2TBIcon_Cancel { background-position: -54px 0px}
-.dojoE2TBIcon_Copy { background-position: -72px 0px}
-.dojoE2TBIcon_Link { background-position: -90px 0px}
-.dojoE2TBIcon_Cut { background-position: -108px 0px}
-.dojoE2TBIcon_Delete { background-position: -126px 0px}
-.dojoE2TBIcon_TextColor { background-position: -144px 0px}
-.dojoE2TBIcon_BackgroundColor { background-position: -162px 0px}
-.dojoE2TBIcon_Indent { background-position: -180px 0px}
-.dojoE2TBIcon_HorizontalLine { background-position: -198px 0px}
-.dojoE2TBIcon_Image { background-position: -216px 0px}
-.dojoE2TBIcon_NumberedList { background-position: -234px 0px}
-.dojoE2TBIcon_Table { background-position: -252px 0px}
-.dojoE2TBIcon_BulletedList { background-position: -270px 0px}
-.dojoE2TBIcon_Italic { background-position: -288px 0px}
-.dojoE2TBIcon_CenterJustify { background-position: -306px 0px}
-.dojoE2TBIcon_BlockJustify { background-position: -324px 0px}
-.dojoE2TBIcon_LeftJustify { background-position: -342px 0px}
-.dojoE2TBIcon_RightJustify { background-position: -360px 0px}
-.dojoE2TBIcon_left_to_right { background-position: -378px 0px}
-.dojoE2TBIcon_list_bullet_indent { background-position: -396px 0px}
-.dojoE2TBIcon_list_bullet_outdent { background-position: -414px 0px}
-.dojoE2TBIcon_list_num_indent { background-position: -432px 0px}
-.dojoE2TBIcon_list_num_outdent { background-position: -450px 0px}
-.dojoE2TBIcon_Outdent { background-position: -468px 0px}
-.dojoE2TBIcon_Paste { background-position: -486px 0px}
-.dojoE2TBIcon_Redo { background-position: -504px 0px}
-dojoE2TBIcon_RemoveFormat { background-position: -522px 0px}
-.dojoE2TBIcon_right_to_left { background-position: -540px 0px}
-.dojoE2TBIcon_Save { background-position: -558px 0px}
-.dojoE2TBIcon_Space { background-position: -576px 0px}
-.dojoE2TBIcon_StrikeThrough { background-position: -594px 0px}
-.dojoE2TBIcon_Subscript { background-position: -612px 0px}
-.dojoE2TBIcon_Superscript { background-position: -630px 0px}
-.dojoE2TBIcon_Underline { background-position: -648px 0px}
-.dojoE2TBIcon_Undo { background-position: -666px 0px}
-.dojoE2TBIcon_WikiWord { background-position: -684px 0px}
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbar.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,153 +0,0 @@
-<div dojoAttachPoint="domNode" class="EditorToolbarDomNode" unselectable="on">
-	<table cellpadding="3" cellspacing="0" border="0">
-		<!--
-			our toolbar should look something like:
-
-			+=======+=======+=======+=============================================+
-			| w   w | style | copy  | bo | it | un | le | ce | ri |
-			| w w w | style |=======|==============|==============|
-			|  w w  | style | paste |  undo | redo | change style |
-			+=======+=======+=======+=============================================+
-		-->
-		<tbody>
-			<tr valign="top">
-				<td rowspan="2">
-					<div class="bigIcon" dojoAttachPoint="wikiWordButton"
-						dojoOnClick="wikiWordClick; buttonClick;">
-						<span style="font-size: 30px; margin-left: 5px;">
-							W
-						</span>
-					</div>
-				</td>
-				<td rowspan="2">
-					<div class="bigIcon" dojoAttachPoint="styleDropdownButton"
-						dojoOnClick="styleDropdownClick; buttonClick;">
-						<span unselectable="on"
-							style="font-size: 30px; margin-left: 5px;">
-							S
-						</span>
-					</div>
-					<div class="StyleDropdownContainer" style="display: none;"
-						dojoAttachPoint="styleDropdownContainer">
-						<table cellpadding="0" cellspacing="0" border="0"
-							height="100%" width="100%">
-							<tr valign="top">
-								<td rowspan="2">
-									<div style="height: 245px; overflow: auto;">
-										<div class="headingContainer"
-											unselectable="on"
-											dojoOnClick="normalTextClick">normal</div>
-										<h1 class="headingContainer"
-											unselectable="on"
-											dojoOnClick="h1TextClick">Heading 1</h1>
-										<h2 class="headingContainer"
-											unselectable="on"
-											dojoOnClick="h2TextClick">Heading 2</h2>
-										<h3 class="headingContainer"
-											unselectable="on"
-											dojoOnClick="h3TextClick">Heading 3</h3>
-										<h4 class="headingContainer"
-											unselectable="on"
-											dojoOnClick="h4TextClick">Heading 4</h4>
-										<div class="headingContainer"
-											unselectable="on"
-											dojoOnClick="blahTextClick">blah</div>
-										<div class="headingContainer"
-											unselectable="on"
-											dojoOnClick="blahTextClick">blah</div>
-										<div class="headingContainer"
-											unselectable="on"
-											dojoOnClick="blahTextClick">blah</div>
-										<div class="headingContainer">blah</div>
-										<div class="headingContainer">blah</div>
-										<div class="headingContainer">blah</div>
-										<div class="headingContainer">blah</div>
-									</div>
-								</td>
-								<!--
-								<td>
-									<span class="iconContainer" dojoOnClick="buttonClick;">
-										<span class="icon justifyleft" 
-											style="float: left;">&nbsp;</span>
-									</span>
-									<span class="iconContainer" dojoOnClick="buttonClick;">
-										<span class="icon justifycenter" 
-											style="float: left;">&nbsp;</span>
-									</span>
-									<span class="iconContainer" dojoOnClick="buttonClick;">
-										<span class="icon justifyright" 
-											style="float: left;">&nbsp;</span>
-									</span>
-									<span class="iconContainer" dojoOnClick="buttonClick;">
-										<span class="icon justifyfull" 
-											style="float: left;">&nbsp;</span>
-									</span>
-								</td>
-								-->
-							</tr>
-							<tr valign="top">
-								<td>
-									thud
-								</td>
-							</tr>
-						</table>
-					</div>
-				</td>
-				<td>
-					<!-- copy -->
-					<span class="iconContainer" dojoAttachPoint="copyButton"
-						unselectable="on"
-						dojoOnClick="copyClick; buttonClick;">
-						<span class="icon copy" 
-							unselectable="on"
-							style="float: left;">&nbsp;</span> copy
-					</span>
-					<!-- "droppable" options -->
-					<span class="iconContainer" dojoAttachPoint="boldButton"
-						unselectable="on"
-						dojoOnClick="boldClick; buttonClick;">
-						<span class="icon bold" unselectable="on">&nbsp;</span>
-					</span>
-					<span class="iconContainer" dojoAttachPoint="italicButton"
-						dojoOnClick="italicClick; buttonClick;">
-						<span class="icon italic" unselectable="on">&nbsp;</span>
-					</span>
-					<span class="iconContainer" dojoAttachPoint="underlineButton"
-						dojoOnClick="underlineClick; buttonClick;">
-						<span class="icon underline" unselectable="on">&nbsp;</span>
-					</span>
-					<span class="iconContainer" dojoAttachPoint="leftButton"
-						dojoOnClick="leftClick; buttonClick;">
-						<span class="icon justifyleft" unselectable="on">&nbsp;</span>
-					</span>
-					<span class="iconContainer" dojoAttachPoint="fullButton"
-						dojoOnClick="fullClick; buttonClick;">
-						<span class="icon justifyfull" unselectable="on">&nbsp;</span>
-					</span>
-					<span class="iconContainer" dojoAttachPoint="rightButton"
-						dojoOnClick="rightClick; buttonClick;">
-						<span class="icon justifyright" unselectable="on">&nbsp;</span>
-					</span>
-				</td>
-			</tr>
-			<tr>
-				<td>
-					<!-- paste -->
-					<span class="iconContainer" dojoAttachPoint="pasteButton"
-						dojoOnClick="pasteClick; buttonClick;" unselectable="on">
-						<span class="icon paste" style="float: left;" unselectable="on">&nbsp;</span> paste
-					</span>
-					<!-- "droppable" options -->
-					<span class="iconContainer" dojoAttachPoint="undoButton"
-						dojoOnClick="undoClick; buttonClick;" unselectable="on">
-						<span class="icon undo" style="float: left;" unselectable="on">&nbsp;</span> undo
-					</span>
-					<span class="iconContainer" dojoAttachPoint="redoButton"
-						dojoOnClick="redoClick; buttonClick;" unselectable="on">
-						<span class="icon redo" style="float: left;" unselectable="on">&nbsp;</span> redo
-					</span>
-				</td>	
-			</tr>
-		</tbody>
-	</table>
-</div>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbarOneline.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbarOneline.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/EditorToolbarOneline.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,172 +0,0 @@
-<div class="EditorToolbarDomNode EditorToolbarSmallBg">
-	<table cellpadding="1" cellspacing="0" border="0">
-		<tbody>
-			<tr valign="top" align="left">
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="htmltoggle">
-						<span class="dojoE2TBIcon" 
-						style="background-image: none; width: 30px;" >&lt;h&gt;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="copy">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Copy">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="paste">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Paste">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="undo">
-						<!-- FIXME: should we have the text "undo" here? -->
-						<span class="dojoE2TBIcon dojoE2TBIcon_Undo">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="redo">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Redo">&nbsp;</span>
-					</span>
-				</td>
-				<td isSpacer="true">
-					<span class="iconContainer">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Sep"	style="width: 5px; min-width: 5px;"></span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="createlink">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Link">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="insertimage">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Image">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="inserthorizontalrule">
-						<span class="dojoE2TBIcon dojoE2TBIcon_HorizontalLine ">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="bold">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Bold">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="italic">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Italic">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="underline">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Underline">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="strikethrough">
-						<span 
-							class="dojoE2TBIcon dojoE2TBIcon_StrikeThrough">&nbsp;</span>
-					</span>
-				</td>
-				<td isSpacer="true">
-					<span class="iconContainer">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Sep" 
-							style="width: 5px; min-width: 5px;"></span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="insertunorderedlist">
-						<span 
-							class="dojoE2TBIcon dojoE2TBIcon_BulletedList">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="insertorderedlist">
-						<span 
-							class="dojoE2TBIcon dojoE2TBIcon_NumberedList">&nbsp;</span>
-					</span>
-				</td>
-				<td isSpacer="true">
-					<span class="iconContainer">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Sep" style="width: 5px; min-width: 5px;"></span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="indent">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Indent" 
-							unselectable="on">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="outdent">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Outdent" 
-							unselectable="on">&nbsp;</span>
-					</span>
-				</td>
-				<td isSpacer="true">
-					<span class="iconContainer">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Sep" style="width: 5px; min-width: 5px;"></span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="forecolor">
-						<span class="dojoE2TBIcon dojoE2TBIcon_TextColor" 
-							unselectable="on">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="hilitecolor">
-						<span class="dojoE2TBIcon dojoE2TBIcon_BackgroundColor" 
-							unselectable="on">&nbsp;</span>
-					</span>
-				</td>
-				<td isSpacer="true">
-					<span class="iconContainer">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Sep" style="width: 5px; min-width: 5px;"></span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="justifyleft">
-						<span class="dojoE2TBIcon dojoE2TBIcon_LeftJustify">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="justifycenter">
-						<span class="dojoE2TBIcon dojoE2TBIcon_CenterJustify">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="justifyright">
-						<span class="dojoE2TBIcon dojoE2TBIcon_RightJustify">&nbsp;</span>
-					</span>
-				</td>
-				<td>
-					<span class="iconContainer dojoEditorToolbarItem" dojoETItemName="justifyfull">
-						<span class="dojoE2TBIcon dojoE2TBIcon_BlockJustify">&nbsp;</span>
-					</span>
-				</td>	
-				<td>
-					<select class="dojoEditorToolbarItem" dojoETItemName="plainformatblock">
-						<!-- FIXME: using "p" here inserts a paragraph in most cases! -->
-						<option value="">-- format --</option>
-						<option value="p">Normal</option>
-						<option value="pre">Fixed Font</option>
-						<option value="h1">Main Heading</option>
-						<option value="h2">Section Heading</option>
-						<option value="h3">Sub-Heading</option>
-						<!-- <option value="blockquote">Block Quote</option> -->
-					</select>
-				</td>
-				<td><!-- uncomment to enable save button -->
-					<!-- save -->
-					<!--span class="iconContainer dojoEditorToolbarItem" dojoETItemName="save">
-						<span class="dojoE2TBIcon dojoE2TBIcon_Save">&nbsp;</span>
-					</span-->
-				</td>
-				<td width="*">&nbsp;</td>
-			</tr>
-		</tbody>
-	</table>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/FisheyeList.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/FisheyeList.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/FisheyeList.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,27 +0,0 @@
-.dojoHtmlFisheyeListItemLabel {
-	font-family: Arial, Helvetica, sans-serif;
-	background-color: #eee;
-	border: 2px solid #666;
-	padding: 2px;
-	text-align: center;
-	position: absolute;
-	display: none;
-}
-
-.dojoHtmlFisheyeListItemLabel.selected {
-	display: block;
-}
-
-.dojoHtmlFisheyeListItemImage {
-	border: 0px;
-	position: absolute;
-}
-
-.dojoHtmlFisheyeListItem {
-	position: absolute;
-	z-index: 2;
-}
-
-.dojoHtmlFisheyeListBar {
-	position: relative;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,118 +0,0 @@
-
-/********** Outer Window ***************/
-
-.dojoFloatingPane {
-	/* essential css */
-	position: absolute;
-	overflow: visible;		/* so drop shadow is displayed */
-	z-index: 10;
-
-	/* styling css */
-	border: 1px solid;
-	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
-	background-color: ThreeDFace;
-}
-
-
-/********** Title Bar ****************/
-
-.dojoFloatingPaneTitleBar {
-	vertical-align: top;
-	margin: 2px 2px 2px 2px;
-	z-index: 10;
-	background-color: #7596c6;
-	cursor: default;
-	overflow: hidden;
-	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
-	vertical-align: middle;
-}
-
-.dojoFloatingPaneTitleText {
-	float: left;
-	padding: 2px 4px 2px 2px;
-	white-space: nowrap;
-	color: CaptionText;
-	font: small-caption;
-}
-
-.dojoTitleBarIcon {
-	float: left;
-	height: 22px;
-	width: 22px;
-	vertical-align: middle;
-	margin-right: 5px;
-	margin-left: 5px;
-}
-
-.dojoFloatingPaneActions{
-	float: right;
-	position: absolute;
-	right: 2px;
-	top: 2px;
-	vertical-align: middle;
-}
-
-
-.dojoFloatingPaneActionItem {
-	vertical-align: middle;
-	margin-right: 1px;
-	height: 22px;
-	width: 22px;
-}
-
-
-.dojoFloatingPaneTitleBarIcon {
-	/* essential css */
-	float: left;
-
-	/* styling css */
-	margin-left: 2px;
-	margin-right: 4px;
-	height: 22px;
-}
-
-/* minimize/maximize icons are specified by CSS only */
-.dojoFloatingPaneMinimizeIcon,
-.dojoFloatingPaneMaximizeIcon,
-.dojoFloatingPaneRestoreIcon,
-.dojoFloatingPaneCloseIcon {
-	vertical-align: middle;
-	height: 22px;
-	width: 22px;
-	float: right;
-}
-.dojoFloatingPaneMinimizeIcon {
-	background-image: url(images/floatingPaneMinimize.gif);
-}
-.dojoFloatingPaneMaximizeIcon {
-	background-image: url(images/floatingPaneMaximize.gif);
-}
-.dojoFloatingPaneRestoreIcon {
-	background-image: url(images/floatingPaneRestore.gif);
-}
-.dojoFloatingPaneCloseIcon {
-	background-image: url(images/floatingPaneClose.gif);
-}
-
-/* bar at bottom of window that holds resize handle */
-.dojoFloatingPaneResizebar {
-	z-index: 10;
-	height: 13px;
-	background-color: ThreeDFace;
-}
-
-/************* Client Area ***************/
-
-.dojoFloatingPaneClient {
-	position: relative;
-	z-index: 10;
-	border: 1px solid;
-	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
-	margin: 2px;
-	background-color: ThreeDFace;
-	padding: 8px;
-	font-family: Verdana, Helvetica, Garamond, sans-serif;
-	font-size: 12px;
-	overflow: auto;
-}
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/FloatingPane.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,18 +0,0 @@
-<div id="${this.widgetId}" dojoAttachEvent="onMouseDown" class="dojoFloatingPane">
-	<div dojoAttachPoint="titleBar" class="dojoFloatingPaneTitleBar"  style="display:none">
-	  	<img dojoAttachPoint="titleBarIcon"  class="dojoFloatingPaneTitleBarIcon">
-		<div dojoAttachPoint="closeAction" dojoAttachEvent="onClick:closeWindow"
-   	  		class="dojoFloatingPaneCloseIcon"></div>
-		<div dojoAttachPoint="restoreAction" dojoAttachEvent="onClick:restoreWindow"
-   	  		class="dojoFloatingPaneRestoreIcon"></div>
-		<div dojoAttachPoint="maximizeAction" dojoAttachEvent="onClick:maximizeWindow"
-   	  		class="dojoFloatingPaneMaximizeIcon"></div>
-		<div dojoAttachPoint="minimizeAction" dojoAttachEvent="onClick:minimizeWindow"
-   	  		class="dojoFloatingPaneMinimizeIcon"></div>
-	  	<div dojoAttachPoint="titleBarText" class="dojoFloatingPaneTitleText">${this.title}</div>
-	</div>
-
-	<div id="${this.widgetId}_container" dojoAttachPoint="containerNode" class="dojoFloatingPaneClient"></div>
-
-	<div dojoAttachPoint="resizeBar" class="dojoFloatingPaneResizebar" style="display:none"></div>
-</div>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,59 @@
+/* ---- button --- */
+.dojoButton {
+	padding: 0 0 0 0;
+	font-size: 8pt;
+	white-space: nowrap;
+	cursor: pointer;
+	font-family: Myriad, Tahoma, Verdana, sans-serif;
+}
+
+.dojoButton .dojoButtonContents {
+	padding: 2px 2px 2px 2px;
+	text-align: center;		/* if icon and label are split across two lines, center icon */
+	color: white;
+}
+
+.dojoButtonLeftPart .dojoButtonContents {
+	padding-right: 8px;
+}
+
+.dojoButtonDisabled {
+	cursor: url("images/no.gif"), default;
+}
+
+
+.dojoButtonContents img {
+	vertical-align: middle;	/* if icon and label are on same line, center them */
+}
+
+/* -------- colors ------------ */
+
+.dojoButtonHover .dojoButtonContents {
+}
+
+.dojoButtonDepressed .dojoButtonContents {
+	color: #293a4b;
+}
+
+.dojoButtonDisabled .dojoButtonContents {
+	color: #eeeeee;
+}
+
+
+/* ---------- drop down button specific ---------- */
+
+/* border between label and arrow (for drop down buttons */
+.dojoButton .border {
+	width: 1px;
+	background: gray;
+}
+
+/* button arrow */
+.dojoButton .downArrow {
+	padding-left: 10px;
+	text-align: center;
+}
+
+.dojoButton.disabled .downArrow {
+	cursor : default;
+}
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlButtonTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,6 @@
+<div class="dojoButton" style="position:relative;" dojoAttachEvent="onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick;">
+  <div class="dojoButtonContents" align=center dojoAttachPoint="containerNode" style="position:absolute;z-index:2;"></div>
+  <img dojoAttachPoint="leftImage" style="position:absolute;left:0px;">
+  <img dojoAttachPoint="centerImage" style="position:absolute;z-index:1;">
+  <img dojoAttachPoint="rightImage" style="position:absolute;top:0px;right:0px;">
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCheckBox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCheckBox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCheckBox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,6 @@
+<span>
+	<input type="checkbox" name="${this.name}" checked="${this.checked}" tabIndex="${this.tabIndex}" style="display: none"
+		dojoAttachPoint="inputNode">
+	<img src='${this.imgSrc}' class='dojoHtmlCheckbox'
+		dojoAttachPoint="imgNode" dojoAttachEvent="onMouseUp;onMouseOver;onMouseOut">
+</span>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,12 @@
+<table cellpadding="0" cellspacing="0" border="0" width="400">
+	<tr>
+		<td id="dateHolderTd" width="200">
+		</td>
+		<td id="timeHolderTd" width="200">
+		</td>
+	</tr>
+	<tr style="display: none;" id="formItemsTr">
+		<td id="formItemsTd">&nbsp;</td>
+		<td>&nbsp;</td>
+	</tr>
+</table>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,40 @@
+input.dojoComboBoxInput {
+	/* font-size: 0.8em; */
+	border: 0px;
+	
+}
+
+.dojoComboBoxOptions {
+	font-family: Verdana, Helvetica, Garamond, sans-serif;
+	/* font-size: 0.7em; */
+	background-color: white;
+	border: 1px solid #afafaf;
+	position: absolute;
+	z-index: 1000; 
+	overflow: auto;
+	-moz-opacity: 0;
+	cursor: default;
+}
+
+table.dojoComboBox {
+	border: 1px solid #afafaf;
+}
+
+.dojoComboBoxItem {
+	padding-left: 2px;
+	padding-top: 2px;
+	margin: 0px;
+}
+
+.dojoComboBoxItemEven {
+	background-color: #f4f4f4;
+}
+
+.dojoComboBoxItemOdd {
+	background-color: white;
+}
+
+.dojoComboBoxItemHighlight {
+	background-color: #63709A;
+	color: white;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboBox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,34 @@
+<div style="position: relative; z-index: 100;">
+	<input type="hidden" name="" value="" 
+		dojoAttachPoint="comboBoxValue">
+	<input type="hidden" name="" value="" 
+		dojoAttachPoint="comboBoxSelectionValue">
+	<table class="dojoComboBox"
+		cellpadding="0"
+		cellmargin="0"
+		border="0"
+		dojoAttachPoint="cbTableNode">
+		<tr valign="top">
+			<td width=100%>
+				<input type="text" autocomplete="off" class="dojoComboBoxInput"
+					dojoAttachEvent="keyDown: onKeyDown; keyUp: onKeyUp; keyPress: onKeyPress;"
+					dojoAttachPoint="textInputNode"
+					style="width: 100%;">
+			</td>
+			<td>
+				<img border="0" 
+					hspace="0"
+					vspace="0"
+					dojoAttachPoint="downArrowNode"
+					dojoAttachEvent="onMouseUp: handleArrowClick;"
+					src="${dojoRoot}src/widget/templates/images/combo_box_arrow.png">
+			</td>
+		</tr>
+	</table>
+	<div dojoAttachPoint="optionsListWrapper" style="position:relative;" tabindex="-1">
+		<div class="dojoComboBoxOptions" dojoAttachPoint="optionsListNode"
+			dojoAttachEvent="onClick: selectOption;  onMouseOver: _onMouseOver; onMouseOut: _onMouseOut;"
+			style="display:none;" tabindex="-1">
+		</div>
+	</div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,18 @@
+<div class="dojoButton" style="position:relative;top:0px;left:0px; text-align:none;">
+
+	<div dojoAttachPoint="leftPart" class="dojoButtonLeftPart" style="position:absolute;left:0px;top:0px;"
+		dojoAttachEvent="onMouseOver:leftOver; onMouseOut:leftOut; onMouseUp:leftUp; onClick:leftClick;">
+		<div class="dojoButtonContents" dojoAttachPoint="containerNode" style="position:absolute;top:0px;right:0px;z-index:2;"></div>
+		<img dojoAttachPoint="leftImage" style="position:absolute;left:0px;top:0px;">
+		<img dojoAttachPoint="centerImage" style="position:absolute;right:0px;top:0px;z-index:1;">
+	</div>
+
+	<div dojoAttachPoint="rightPart" class="dojoButtonRightPart" style="position:absolute;top:0px;right:0px;"
+		dojoAttachEvent="onMouseOver:rightOver; onMouseOut:rightOut; onMouseUp:rightUp; onClick:rightClick;">
+		<img dojoAttachPoint="arrowBackgroundImage" style="position:absolute;top:0px;left:0px;z-index:1;">
+		<img src="${dojoRoot}src/widget/templates/images/whiteDownArrow.gif"
+		  		style="z-index:2;position:absolute;left:3px;top:50%;">
+		<img dojoAttachPoint="rightImage" style="position:absolute;top:0px;right:0px;">
+	</div>
+
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,3 @@
+<ul class="dojoContextMenu" 
+	dojoAttachPoint="containerNode">
+</ul>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,143 @@
+.calendarContainer {
+/*	border:1px solid #566f8f;*/
+}
+
+.calendarBodyContainer {
+	width:160px;
+	background: #7591bc url("images/dpBg.gif") top left repeat-x;
+}
+
+.calendarBodyContainer thead tr td {
+	color:#293a4b;
+	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
+	text-align:center;
+	padding:0.25em;
+	background: url("images/dpHorizLine.gif") bottom left repeat-x;
+}
+
+.calendarBodyContainer tbody tr td {
+	color:#fff;
+	font:bold 0.7em Helvetica, Arial, Verdana, sans-serif;
+	text-align:center;
+	padding:0.4em;
+	background: url("images/dpVertLine.gif") top right repeat-y;
+	cursor:pointer;
+	cursor:hand;
+}
+
+
+.monthWrapper {
+	padding-bottom:2px;
+	background: url("images/dpHorizLine.gif") bottom left repeat-x;
+}
+
+.monthContainer {
+	width:100%;
+}
+
+.monthLabelContainer {
+	text-align:center;
+	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
+	background: url("images/dpMonthBg.png") repeat-x top left !important;
+	color:#293a4b;
+	padding:0.25em;
+}
+
+.monthCurve {
+	width:12px;
+}
+
+.monthCurveTL {
+	background: url("images/dpCurveTL.png") no-repeat top left !important;
+}
+
+.monthCurveTR {
+		background: url("images/dpCurveTR.png") no-repeat top left !important;
+}
+
+
+.yearWrapper {
+	background: url("images/dpHorizLineFoot.gif") top left repeat-x;
+	padding-top:2px;
+}
+
+.yearContainer {
+	width:100%;
+}
+
+.yearContainer td {
+	background:url("images/dpYearBg.png") top left repeat-x;
+}
+
+.yearContainer .yearLabel {
+	margin:0;
+	padding:0.45em 0 0.45em 0;
+	color:#fff;
+	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
+	text-align:center;
+}
+
+.curveBL {
+	background: url("images/dpCurveBL.png") bottom left no-repeat !important;
+	width:9px !important;
+	padding:0;
+	margin:0;
+}
+
+.curveBR {
+	background: url("images/dpCurveBR.png") bottom left no-repeat !important;
+	width:9px !important;
+	padding:0;
+	margin:0;
+}
+
+
+.previousMonth {
+	background-color:#6782a8 !important;
+}
+
+.currentMonth {
+}
+
+.nextMonth {
+	background-color:#6782a8 !important;
+}
+
+.currentDate {
+	text-decoration:underline;
+	font-style:italic;
+}
+
+.selectedItem {
+	background-color:#fff !important;
+	color:#6782a8 !important;
+}
+
+.yearLabel .selectedYear {
+	padding:0.2em;
+	background-color:#9ec3fb !important;
+}
+
+.nextYear, .previousYear {
+	cursor:pointer;cursor:hand;
+	margin:0 0.55em;
+}
+
+.incrementControl {
+	cursor:pointer;cursor:hand;
+	width:1em;
+}
+
+.increase {
+	float:right;
+}
+
+.decrease {
+	float:left;
+}
+
+.lastColumn {
+	background-image:none !important;
+}
+
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDatePicker.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,141 @@
+<div class="datePickerContainer" dojoAttachPoint="datePickerContainerNode">
+	<table cellspacing="0" cellpadding="0" class="calendarContainer">
+		<thead>
+			<tr>
+				<td class="monthWrapper" valign="top">
+					<table class="monthContainer" cellspacing="0" cellpadding="0" border="0">
+						<tr>
+							<td class="monthCurve monthCurveTL" valign="top"></td>
+							<td class="monthLabelContainer" valign="top">
+								<span dojoAttachPoint="increaseWeekNode" 
+									dojoAttachEvent="onClick: onIncrementWeek;" 
+									class="incrementControl increase">
+									<img src="${dojoRoot}src/widget/templates/images/incrementMonth.png" 
+									alt="&darr;" style="width:7px;height:5px;" />
+								</span>
+								<span 
+									dojoAttachPoint="increaseMonthNode" 
+									dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl increase">
+									<img src="${dojoRoot}src/widget/templates/images/incrementMonth.png" 
+										alt="&darr;"  dojoAttachPoint="incrementMonthImageNode">
+								</span>
+								<span 
+									dojoAttachPoint="decreaseWeekNode" 
+									dojoAttachEvent="onClick: onIncrementWeek;" 
+									class="incrementControl decrease">
+									<img src="${dojoRoot}src/widget/templates/images/decrementMonth.png" alt="&uarr;" style="width:7px;height:5px;" />
+								</span>
+								<span 
+									dojoAttachPoint="decreaseMonthNode" 
+									dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl decrease">
+									<img src="${dojoRoot}src/widget/templates/images/decrementMonth.png" 
+										alt="&uarr;" dojoAttachPoint="decrementMonthImageNode">
+								</span>
+								<span dojoAttachPoint="monthLabelNode" class="month">July</span>
+							</td>
+							<td class="monthCurve monthCurveTR" valign="top"></td>
+						</tr>
+					</table>
+				</td>
+			</tr>
+		</thead>
+		<tbody>
+			<tr>
+				<td colspan="3">
+					<table class="calendarBodyContainer" cellspacing="0" cellpadding="0" border="0">
+						<thead>
+							<tr>
+								<td>S</td>
+								<td>M</td>
+								<td>T</td>
+								<td>W</td>
+								<td>T</td>
+								<td>F</td>
+								<td>S</td>
+							</tr>
+						</thead>
+						<tbody dojoAttachPoint="calendarDatesContainerNode" 
+							dojoAttachEvent="onClick: onSetDate;">
+							<tr dojoAttachPoint="calendarRow0">
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+							</tr>
+							<tr dojoAttachPoint="calendarRow1">
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+							</tr>
+							<tr dojoAttachPoint="calendarRow2">
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+							</tr>
+							<tr dojoAttachPoint="calendarRow3">
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+							</tr>
+							<tr dojoAttachPoint="calendarRow4">
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+							</tr>
+							<tr dojoAttachPoint="calendarRow5">
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+								<td></td>
+							</tr>
+						</tbody>
+					</table>
+				</td>
+			</tr>
+		</tbody>
+		<tfoot>
+			<tr>
+				<td colspan="3" class="yearWrapper">
+					<table cellspacing="0" cellpadding="0" border="0" class="yearContainer">
+						<tr>
+							<td class="curveBL" valign="top"></td>
+							<td valign="top">
+								<h3 class="yearLabel">
+									<span dojoAttachPoint="previousYearLabelNode"
+										dojoAttachEvent="onClick: onIncrementYear;" class="previousYear"></span>
+									<span class="selectedYear" dojoAttachPoint="currentYearLabelNode"></span>
+									<span dojoAttachPoint="nextYearLabelNode" 
+										dojoAttachEvent="onClick: onIncrementYear;" class="nextYear"></span>
+								</h3>
+							</td>
+							<td class="curveBR" valign="top"></td>
+						</tr>
+					</table>
+				</td>
+			</tr>
+		</tfoot>
+	</table>
+	
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDialog.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDialog.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDialog.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,13 @@
+<div id="${this.widgetId}" class="dojoDialog" dojoAttachPoint="wrapper">
+
+	<span dojoAttachPoint="tabStart" 
+		dojoOnFocus="trapTabs" 
+		dojoOnBlur="clearTrap" tabindex="0"></span>
+
+	<div dojoAttachPoint="containerNode" style=" position: relative; z-index: 2;"></div>
+
+	<span dojoAttachPoint="tabEnd" 
+		dojoOnFocus="trapTabs" 
+		dojoOnBlur="clearTrap" tabindex="0"></span>
+
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,19 @@
+.dojoDocSrc {
+	white-space: pre;
+	font-family: Courier, "Courier New", monospace;
+	font-size: 0.8em;
+}
+.dojoDocReturn {
+	color: #369;
+}
+.dojoDocFunction {
+	color: #98543F;
+	font-weight: bold;
+}
+.dojoDocParamType {
+	font-style: italic;
+	color: #D17575;
+}
+.dojoDocParamName {
+	color: #D14040;
+}
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDocPane.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,23 @@
+<div>
+	<div dojoAttachPoint="containerNode"></div>
+	<div dojoAttachPoint="select">
+		<h1>Detail: <span dojoAttachPoint="fn">dojo.select</span></h1>
+		<div dojoAttachPoint="description">Description</div>
+		<div class="dojoDocParams" dojoAttachPoint="parameters">
+			<h2>Parameters</h2>
+			<div dojoAttachPoint="pRow"><span dojoAttachPoint="pOpt"><em>optional</em> </span><span><span dojoAttachPoint="pType">type</span> </span><a href="#" dojoAttachPoint="pLink">variable</a><span> - <span dojoAttachPoint="pDesc"></span></span></div>
+		</div>
+		<div class="dojoDocVars" dojoAttachPoint="variables">
+			<h2>Variables</h2>
+			<div dojoAttachPoint="vRow"><a href="#" dojoAttachPoint="vLink">variable</a><span> - <span dojoAttachPoint="vDesc"></span></span></div>
+		</div>
+		<div>
+			<h2>Source Code</h2>
+			<div class="dojoDocSrc"><span class="dojoDocReturn" dojoAttachPoint="sType">returnType</span> <span class="dojoDocFunction" dojoAttachPoint="sName">foo</span>(<span dojoAttachPoint="sParams"><span class="dojoDocParamType" dojoAttachPoint="sPType">type </span><span class="dojoDocParamName" dojoAttachPoint="sPName">paramName</span></span>){<span dojoAttachPoint="source">...</span>}</div>
+		</div>
+	</div>
+	<div dojoAttachPoint="result">
+		<h1>Search Results: <span dojoAttachPoint="count">0</span> matches</h1>
+		<div dojoAttachPoint="row"><a href="#" dojoAttachPoint="fnLink">dojo.fnLink</a><span> - <span dojoAttachPoint="summary">summary</span></span></div>
+	</div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,9 @@
+<button dojoAttachPoint="button" class="dojoButton dojoButtonNoHover" dojoAttachEvent="onMouseOver: ; onMouseOut: ; onClick: ;">
+  <table dojoAttachPoint="table" style="margin:0 0 0 0;"><tr>
+    <td class="label" dojoAttachPoint="labelCell"></td>
+    <td class="border" dojoAttachPoint="borderCell"></td>
+    <td class="downArrow" dojoAttachPoint="arrowCell">
+      <img dojoAttachPoint="arrow">
+    </td>
+  </tr></table>
+</button>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,138 @@
+.StyleDropdownContainer {
+	position: absolute;
+	z-index: 1000;
+	overflow: auto;
+	cursor: default;
+	width: 250px;
+	height: 250px;
+	background-color: white;
+	border: 1px solid black;
+}
+
+.ColorDropdownContainer {
+	position: absolute;
+	z-index: 1000;
+	overflow: auto;
+	cursor: default;
+	width: 250px;
+	height: 150px;
+	background-color: white;
+	border: 1px solid black;
+}
+
+.EditorToolbarDomNode {
+	background-image: url(buttons/bg-fade.png);
+	background-repeat: repeat-x;
+	background-position: 0px -50px;
+}
+
+.EditorToolbarSmallBg {
+	background-image: url(images/toolbar-bg.gif);
+	background-repeat: repeat-x;
+	background-position: 0px 0px;
+}
+
+/*
+body {
+	background:url(images/blank.gif) fixed;
+}*/
+
+.IEFixedToolbar {
+	position:absolute;
+	/* top:0; */
+	top: expression(eval((document.documentElement||document.body).scrollTop));
+}
+
+div.bigIcon {
+	width: 40px;
+	height: 40px; 
+	/* background-color: white; */
+	/* border: 1px solid #a6a7a3; */
+	font-family: Verdana, Trebuchet, Tahoma, Arial;
+}
+
+.iconContainer {
+	font-family: Verdana, Trebuchet, Tahoma, Arial;
+	font-size: 13px;
+	float: left;
+	height: 18px;
+	display: block;
+	/* background-color: white; */
+	/* border: 1px solid white; */
+	/* border: 1px solid #a6a7a3; */
+	padding-right: 3px;
+	cursor: pointer;
+	border: 1px solid transparent;
+	_border: none;
+}
+
+span.icon {
+	display: block;
+	text-align: center;
+	min-width: 18px;
+	width: 18px;
+	height: 18px;
+	/* background-color: #a6a7a3; */
+	background-repeat: no-repeat;
+	background-image: url(buttons/aggregate.gif);
+}
+
+
+span.icon[class~=icon] {
+}
+
+.headingContainer {
+	width: 150px;
+	height: 30px;
+	margin: 0px;
+	/* padding-left: 5px; */
+	overflow: hidden;
+	line-height: 25px;
+	border-bottom: 1px solid black;
+	border-top: 1px solid white;
+}
+
+.EditorToolbarDomNode select {
+	font-size: 14px;
+}
+
+.sep { width: 5px; min-width: 5px; max-width: 5px; background-position: 0px 0px}
+.backcolor { background-position: -18px 0px}
+.bold { background-position: -36px 0px}
+.cancel { background-position: -54px 0px}
+.copy { background-position: -72px 0px}
+.createlink { background-position: -90px 0px}
+.cut { background-position: -108px 0px}
+.delete { background-position: -126px 0px}
+.forecolor { background-position: -144px 0px}
+.hilitecolor { background-position: -162px 0px}
+.indent { background-position: -180px 0px}
+.inserthorizontalrule { background-position: -198px 0px}
+.insertimage { background-position: -216px 0px}
+.insertorderedlist { background-position: -234px 0px}
+.inserttable { background-position: -252px 0px}
+.insertunorderedlist { background-position: -270px 0px}
+.italic { background-position: -288px 0px}
+.justifycenter { background-position: -306px 0px}
+.justifyfull { background-position: -324px 0px}
+.justifyleft { background-position: -342px 0px}
+.justifyright { background-position: -360px 0px}
+.left_to_right { background-position: -378px 0px}
+.list_bullet_indent { background-position: -396px 0px}
+.list_bullet_outdent { background-position: -414px 0px}
+.list_num_indent { background-position: -432px 0px}
+.list_num_outdent { background-position: -450px 0px}
+.outdent { background-position: -468px 0px}
+.paste { background-position: -486px 0px}
+.redo { background-position: -504px 0px}
+.removeformat { background-position: -522px 0px}
+.right_to_left { background-position: -540px 0px}
+.save { background-position: -558px 0px}
+.space { background-position: -576px 0px}
+.strikethrough { background-position: -594px 0px}
+.subscript { background-position: -612px 0px}
+.superscript { background-position: -630px 0px}
+.underline { background-position: -648px 0px}
+.undo { background-position: -666px 0px}
+.wikiword { background-position: -684px 0px}
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbar.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,152 @@
+<div dojoAttachPoint="domNode" class="EditorToolbarDomNode" unselectable="on">
+	<table cellpadding="3" cellspacing="0" border="0">
+		<!--
+			our toolbar should look something like:
+
+			+=======+=======+=======+=============================================+
+			| w   w | style | copy  | bo | it | un | le | ce | ri |
+			| w w w | style |=======|==============|==============|
+			|  w w  | style | paste |  undo | redo | change style |
+			+=======+=======+=======+=============================================+
+		-->
+		<tbody>
+			<tr valign="top">
+				<td rowspan="2">
+					<div class="bigIcon" dojoAttachPoint="wikiWordButton"
+						dojoOnClick="wikiWordClick; buttonClick;">
+						<span style="font-size: 30px; margin-left: 5px;">
+							W
+						</span>
+					</div>
+				</td>
+				<td rowspan="2">
+					<div class="bigIcon" dojoAttachPoint="styleDropdownButton"
+						dojoOnClick="styleDropdownClick; buttonClick;">
+						<span unselectable="on"
+							style="font-size: 30px; margin-left: 5px;">
+							S
+						</span>
+					</div>
+					<div class="StyleDropdownContainer" style="display: none;"
+						dojoAttachPoint="styleDropdownContainer">
+						<table cellpadding="0" cellspacing="0" border="0"
+							height="100%" width="100%">
+							<tr valign="top">
+								<td rowspan="2">
+									<div style="height: 245px; overflow: auto;">
+										<div class="headingContainer"
+											unselectable="on"
+											dojoOnClick="normalTextClick">normal</div>
+										<h1 class="headingContainer"
+											unselectable="on"
+											dojoOnClick="h1TextClick">Heading 1</h1>
+										<h2 class="headingContainer"
+											unselectable="on"
+											dojoOnClick="h2TextClick">Heading 2</h2>
+										<h3 class="headingContainer"
+											unselectable="on"
+											dojoOnClick="h3TextClick">Heading 3</h3>
+										<h4 class="headingContainer"
+											unselectable="on"
+											dojoOnClick="h4TextClick">Heading 4</h4>
+										<div class="headingContainer"
+											unselectable="on"
+											dojoOnClick="blahTextClick">blah</div>
+										<div class="headingContainer"
+											unselectable="on"
+											dojoOnClick="blahTextClick">blah</div>
+										<div class="headingContainer"
+											unselectable="on"
+											dojoOnClick="blahTextClick">blah</div>
+										<div class="headingContainer">blah</div>
+										<div class="headingContainer">blah</div>
+										<div class="headingContainer">blah</div>
+										<div class="headingContainer">blah</div>
+									</div>
+								</td>
+								<!--
+								<td>
+									<span class="iconContainer" dojoOnClick="buttonClick;">
+										<span class="icon justifyleft" 
+											style="float: left;">&nbsp;</span>
+									</span>
+									<span class="iconContainer" dojoOnClick="buttonClick;">
+										<span class="icon justifycenter" 
+											style="float: left;">&nbsp;</span>
+									</span>
+									<span class="iconContainer" dojoOnClick="buttonClick;">
+										<span class="icon justifyright" 
+											style="float: left;">&nbsp;</span>
+									</span>
+									<span class="iconContainer" dojoOnClick="buttonClick;">
+										<span class="icon justifyfull" 
+											style="float: left;">&nbsp;</span>
+									</span>
+								</td>
+								-->
+							</tr>
+							<tr valign="top">
+								<td>
+									thud
+								</td>
+							</tr>
+						</table>
+					</div>
+				</td>
+				<td>
+					<!-- copy -->
+					<span class="iconContainer" dojoAttachPoint="copyButton"
+						unselectable="on"
+						dojoOnClick="copyClick; buttonClick;">
+						<span class="icon copy" 
+							unselectable="on"
+							style="float: left;">&nbsp;</span> copy
+					</span>
+					<!-- "droppable" options -->
+					<span class="iconContainer" dojoAttachPoint="boldButton"
+						unselectable="on"
+						dojoOnClick="boldClick; buttonClick;">
+						<span class="icon bold" unselectable="on">&nbsp;</span>
+					</span>
+					<span class="iconContainer" dojoAttachPoint="italicButton"
+						dojoOnClick="italicClick; buttonClick;">
+						<span class="icon italic" unselectable="on">&nbsp;</span>
+					</span>
+					<span class="iconContainer" dojoAttachPoint="underlineButton"
+						dojoOnClick="underlineClick; buttonClick;">
+						<span class="icon underline" unselectable="on">&nbsp;</span>
+					</span>
+					<span class="iconContainer" dojoAttachPoint="leftButton"
+						dojoOnClick="leftClick; buttonClick;">
+						<span class="icon justifyleft" unselectable="on">&nbsp;</span>
+					</span>
+					<span class="iconContainer" dojoAttachPoint="fullButton"
+						dojoOnClick="fullClick; buttonClick;">
+						<span class="icon justifyfull" unselectable="on">&nbsp;</span>
+					</span>
+					<span class="iconContainer" dojoAttachPoint="rightButton"
+						dojoOnClick="rightClick; buttonClick;">
+						<span class="icon justifyright" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+			</tr>
+			<tr>
+				<td>
+					<!-- paste -->
+					<span class="iconContainer" dojoAttachPoint="pasteButton"
+						dojoOnClick="pasteClick; buttonClick;" unselectable="on">
+						<span class="icon paste" style="float: left;" unselectable="on">&nbsp;</span> paste
+					</span>
+					<!-- "droppable" options -->
+					<span class="iconContainer" dojoAttachPoint="undoButton"
+						dojoOnClick="undoClick; buttonClick;" unselectable="on">
+						<span class="icon undo" style="float: left;" unselectable="on">&nbsp;</span> undo
+					</span>
+					<span class="iconContainer" dojoAttachPoint="redoButton"
+						dojoOnClick="redoClick; buttonClick;" unselectable="on">
+						<span class="icon redo" style="float: left;" unselectable="on">&nbsp;</span> redo
+					</span>
+				</td>	
+			</tr>
+		</tbody>
+	</table>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,266 @@
+<div class="EditorToolbarDomNode EditorToolbarSmallBg" 
+	unselectable="on" dojoOnMouseDown="preventSelect">
+	<table cellpadding="1" cellspacing="0" border="0">
+		<!--
+			toobar options, in order:
+
+				* wikiword
+				* paste
+				* copy
+				* undo
+				* redo
+				* link
+				* insert image
+				* insert <hr>
+				* font-select
+				* bold
+				* italic
+				* underline
+				* strikethrough
+				* numlist
+				* dotlist
+				* indent
+				* outdent
+				* text color
+				* bg color
+
+		-->
+		<tbody>
+			<tr valign="top" align="left" dojoAttachPoint="oneLineTr">
+				<td>
+					<!-- htmltoggle -->
+					<span class="iconContainer" dojoAttachPoint="htmltoggleButton"
+						dojoOnClick="htmltoggleClick; buttonClick;" style="display: none;">
+						<span title="Toggle Rich Text and HTML Markup Editing Modes" class="icon" 
+						style="background-image: none; width: 30px;" 
+						unselectable="on">&lt;h&gt;</span>
+					</span>
+				</td>
+				<td>
+					<!-- wikiword -->
+					<span class="iconContainer" dojoAttachPoint="wikiwordButton"
+						dojoOnClick="wikiwordClick; buttonClick;" style="display: none;">
+						<span title="Toggle Wiki Word" class="icon wikiword" 
+						unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- paste -->
+					<span class="iconContainer" dojoAttachPoint="copyButton"
+						unselectable="on" dojoOnClick="copyClick; buttonClick;">
+						<span title="Copy (Ctrl-C)" class="icon copy" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- copy -->
+					<span class="iconContainer" dojoAttachPoint="pasteButton"
+						dojoOnClick="pasteClick; buttonClick;" unselectable="on">
+						<span title="Paste (Ctrl-V)" class="icon paste" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- undo -->
+					<span class="iconContainer" dojoAttachPoint="undoButton"
+						dojoOnClick="undoClick; buttonClick;" unselectable="on">
+						<!-- FIXME: should we have the text "undo" here? -->
+						<span title="Undo (Ctrl-Z)" class="icon undo" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- redo -->
+					<span class="iconContainer" dojoAttachPoint="redoButton"
+						dojoOnClick="redoClick; buttonClick;" unselectable="on">
+						<span title="Redo (Ctrl-R)" class="icon redo" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td isSpacer="true">
+					<!-- spacer -->
+					<span class="iconContainer">
+						<span class="icon sep" unselectable="on" 
+							style="width: 5px; min-width: 5px;"></span>
+					</span>
+				</td>
+				<td>
+					<!-- link -->
+					<span class="iconContainer" dojoAttachPoint="linkButton"
+						unselectable="on" dojoOnClick="linkClick; buttonClick;">
+						<span title="Create Link" class="icon createlink" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- insertimage -->
+					<span class="iconContainer" 
+						style="display: none;"
+						dojoAttachPoint="insertimageButton"
+						unselectable="on" dojoOnClick="insertimageClick; buttonClick;">
+						<span title="Insert Image" class="icon insertimage" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- inserthorizontalrule -->
+					<span class="iconContainer" dojoAttachPoint="inserthorizontalruleButton"
+						unselectable="on" dojoOnClick="inserthorizontalruleClick; buttonClick;">
+						<span title="Insert Horizontal Rule" class="icon inserthorizontalrule " unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- bold -->
+					<span class="iconContainer" dojoAttachPoint="boldButton"
+						unselectable="on" dojoOnClick="boldClick; buttonClick;">
+						<span title="Toggle Bold (Ctrl-B)" class="icon bold" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- italic -->
+					<span class="iconContainer" dojoAttachPoint="italicButton"
+						dojoOnClick="italicClick; buttonClick;">
+						<span title="Toggle Italic (Ctrl-I)" class="icon italic" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- underline -->
+					<span class="iconContainer" dojoAttachPoint="underlineButton"
+						dojoOnClick="underlineClick; buttonClick;">
+						<span title="Toggle Underline (Ctrl-U)" class="icon underline" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- strikethrough -->
+					<span class="iconContainer" dojoAttachPoint="strikethroughButton"
+						dojoOnClick="strikethroughClick; buttonClick;">
+						<span title="Toggle Strike-Through" 
+							class="icon strikethrough" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td isSpacer="true">
+					<!-- spacer -->
+					<span class="iconContainer">
+						<span class="icon sep" unselectable="on" 
+							style="width: 5px; min-width: 5px;"></span>
+					</span>
+				</td>
+				<td>
+					<!-- insertunorderedlist -->
+					<span class="iconContainer" dojoAttachPoint="insertunorderedlistButton"
+						unselectable="on" 
+						dojoOnClick="insertunorderedlistClick; buttonClick;">
+						<span title="Insert Bullet List" 
+							class="icon insertunorderedlist" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- insertorderedlist -->
+					<span class="iconContainer" dojoAttachPoint="insertorderedlistButton"
+						unselectable="on" dojoOnClick="insertorderedlistClick; buttonClick;">
+						<span title="Insert Numbered List" 
+							class="icon insertorderedlist" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td isSpacer="true">
+					<!-- spacer -->
+					<span class="iconContainer">
+						<span class="icon sep" unselectable="on" 
+							style="width: 5px; min-width: 5px;"></span>
+					</span>
+				</td>
+				<td>
+					<!-- indent -->
+					<span class="iconContainer" dojoAttachPoint="indentButton"
+						unselectable="on" dojoOnClick="indentClick; buttonClick;">
+						<span title="Indent Selection" class="icon indent" 
+							unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- outdent -->
+					<span class="iconContainer" dojoAttachPoint="outdentButton"
+						unselectable="on" dojoOnClick="outdentClick; buttonClick;">
+						<span title="Outdent Selection" class="icon outdent" 
+							unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td isSpacer="true">
+					<!-- spacer -->
+					<span class="iconContainer">
+						<span class="icon sep" unselectable="on" 
+							style="width: 5px; min-width: 5px;"></span>
+					</span>
+				</td>
+				<td>
+					<!-- forecolor -->
+					<span class="iconContainer" dojoAttachPoint="forecolorButton"
+						unselectable="on" dojoOnClick="forecolorClick; buttonClick;">
+						<span title="Change Text Color" class="icon forecolor" 
+							unselectable="on">&nbsp;</span>
+					</span>
+					<div class="ColorDropdownContainer" 
+						style="display: none; margin-top: 22px;"
+						dojoAttachPoint="forecolorDropDown">
+					</div>
+				</td>
+				<td>
+					<!-- hilitecolor -->
+					<span class="iconContainer" dojoAttachPoint="hilitecolorButton"
+						unselectable="on" dojoOnClick="hilitecolorClick; buttonClick;">
+						<span title="Change Background Color" class="icon hilitecolor" 
+							unselectable="on">&nbsp;</span>
+					</span>
+					<div class="ColorDropdownContainer" 
+						style="display: none; margin-top: 22px;"
+						dojoAttachPoint="hilitecolorDropDown">
+					</div>
+				</td>
+				<td isSpacer="true">
+					<!-- spacer -->
+					<span class="iconContainer">
+						<span class="icon sep" unselectable="on" 
+							style="width: 5px; min-width: 5px;"></span>
+					</span>
+				</td>
+				<td>
+					<!-- justify left -->
+					<span class="iconContainer" dojoAttachPoint="justifyleftButton"
+						dojoOnClick="justifyleftClick; buttonClick;">
+						<span title="Justify Left" class="icon justifyleft" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- justify center -->
+					<span class="iconContainer" dojoAttachPoint="justifycenterButton"
+						dojoOnClick="justifycenterClick; buttonClick;">
+						<span title="Center" class="icon justifycenter" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- justify right -->
+					<span class="iconContainer" dojoAttachPoint="justifyrightButton"
+						dojoOnClick="justifyrightClick; buttonClick;">
+						<span title="Justify Right" class="icon justifyright" unselectable="on">&nbsp;</span>
+					</span>
+				</td>
+				<td>
+					<!-- justify full -->
+					<span class="iconContainer" dojoAttachPoint="justifyfullButton"
+						dojoOnClick="justifyfullClick; buttonClick;">
+						<span title="Justify Both" class="icon justifyfull" unselectable="on">&nbsp;</span>
+					</span>
+				</td>	
+				<td>
+					<!-- font select -->
+					<select dojoOnChange="formatSelectClick; buttonClick;"
+						dojoAttachPoint="formatSelectBox" unselectable="on">
+						<!-- FIXME: using "p" here inserts a paragraph in most cases! -->
+						<option value="">-- format --</option>
+						<option value="p">Normal</option>
+						<option value="pre">Fixed Font</option>
+						<option value="h1">Main Heading</option>
+						<option value="h2">Section Heading</option>
+						<option value="h3">Sub-Heading</option>
+						<!-- <option value="blockquote">Block Quote</option> -->
+					</select>
+				</td>
+				<td width="*">&nbsp;</td>
+			</tr>
+		</tbody>
+	</table>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFisheyeList.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFisheyeList.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFisheyeList.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,27 @@
+.dojoHtmlFisheyeListItemLabel {
+	font-family: Arial, Helvetica, sans-serif;
+	background-color: #eee;
+	border: 2px solid #666;
+	padding: 2px;
+	text-align: center;
+	position: absolute;
+	display: none;
+}
+
+.dojoHtmlFisheyeListItemLabel.selected {
+	display: block;
+}
+
+.dojoHtmlFisheyeListItemImage {
+	border: 0px;
+	position: absolute;
+}
+
+.dojoHtmlFisheyeListItem {
+	position: absolute;
+	z-index: 2;
+}
+
+.dojoHtmlFisheyeListBar {
+	position: relative;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,118 @@
+
+/********** Outer Window ***************/
+
+.dojoFloatingPane {
+	/* essential css */
+	position: absolute;
+	overflow: visible;		/* so drop shadow is displayed */
+	z-index: 10;
+
+	/* styling css */
+	border: 1px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	background-color: ThreeDFace;
+}
+
+
+/********** Title Bar ****************/
+
+.dojoFloatingPaneTitleBar {
+	vertical-align: top;
+	margin: 2px 2px 2px 2px;
+	z-index: 10;
+	background-color: #7596c6;
+	cursor: default;
+	overflow: hidden;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	vertical-align: middle;
+}
+
+.dojoFloatingPaneTitleText {
+	float: left;
+	padding: 2px 4px 2px 2px;
+	white-space: nowrap;
+	color: CaptionText;
+	font: small-caption;
+}
+
+.dojoTitleBarIcon {
+	float: left;
+	height: 22px;
+	width: 22px;
+	vertical-align: middle;
+	margin-right: 5px;
+	margin-left: 5px;
+}
+
+.dojoFloatingPaneActions{
+	float: right;
+	position: absolute;
+	right: 2px;
+	top: 2px;
+	vertical-align: middle;
+}
+
+
+.dojoFloatingPaneActionItem {
+	vertical-align: middle;
+	margin-right: 1px;
+	height: 22px;
+	width: 22px;
+}
+
+
+.dojoFloatingPaneTitleBarIcon {
+	/* essential css */
+	float: left;
+
+	/* styling css */
+	margin-left: 2px;
+	margin-right: 4px;
+	height: 22px;
+}
+
+/* minimize/maximize icons are specified by CSS only */
+.dojoFloatingPaneMinimizeIcon,
+.dojoFloatingPaneMaximizeIcon,
+.dojoFloatingPaneRestoreIcon,
+.dojoFloatingPaneCloseIcon {
+	vertical-align: middle;
+	height: 22px;
+	width: 22px;
+	float: right;
+}
+.dojoFloatingPaneMinimizeIcon {
+	background-image: url(images/floatingPaneMinimize.gif);
+}
+.dojoFloatingPaneMaximizeIcon {
+	background-image: url(images/floatingPaneMaximize.gif);
+}
+.dojoFloatingPaneRestoreIcon {
+	background-image: url(images/floatingPaneRestore.gif);
+}
+.dojoFloatingPaneCloseIcon {
+	background-image: url(images/floatingPaneClose.gif);
+}
+
+/* bar at bottom of window that holds resize handle */
+.dojoFloatingPaneResizebar {
+	z-index: 10;
+	height: 13px;
+	background-color: ThreeDFace;
+}
+
+/************* Client Area ***************/
+
+.dojoFloatingPaneClient {
+	position: relative;
+	z-index: 10;
+	border: 1px solid;
+	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
+	margin: 2px;
+	background-color: ThreeDFace;
+	padding: 8px;
+	font-family: Verdana, Helvetica, Garamond, sans-serif;
+	font-size: 12px;
+	overflow: auto;
+}
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlFloatingPane.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,18 @@
+<div id="${this.widgetId}" class="dojoFloatingPane">
+	<div dojoAttachPoint="titleBar" class="dojoFloatingPaneTitleBar"  dojoAttachEvent="onMouseDown" style="display:none">
+	  	<img dojoAttachPoint="titleBarIcon"  class="dojoFloatingPaneTitleBarIcon">
+		<div dojoAttachPoint="closeAction" dojoAttachEvent="onClick:closeWindow"
+   	  		class="dojoFloatingPaneCloseIcon"></div>
+		<div dojoAttachPoint="restoreAction" dojoAttachEvent="onClick:restoreWindow"
+   	  		class="dojoFloatingPaneRestoreIcon"></div>
+		<div dojoAttachPoint="maximizeAction" dojoAttachEvent="onClick:maximizeWindow"
+   	  		class="dojoFloatingPaneMaximizeIcon"></div>
+		<div dojoAttachPoint="minimizeAction" dojoAttachEvent="onClick:minimizeWindow"
+   	  		class="dojoFloatingPaneMinimizeIcon"></div>
+	  	<div dojoAttachPoint="titleBarText" class="dojoFloatingPaneTitleText">${this.title}</div>
+	</div>
+
+	<div id="${this.widgetId}_container" dojoAttachPoint="containerNode" class="dojoFloatingPaneClient"></div>
+
+	<div dojoAttachPoint="resizeBar" class="dojoFloatingPaneResizebar" style="display:none"></div>
+</div>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,24 @@
+.editLabel {
+	font-size : small;
+	padding : 0 5px;
+	display : none;
+}
+
+.editableRegion {
+	background-color : #ffc !important;
+	cursor : pointer;
+	_cursor : hand;
+}
+
+.editableRegion .editLabel {
+	display : inline;
+}
+
+.editableTextareaRegion .editLabel {
+	display : block;
+}
+
+.inlineEditBox {
+	/*background-color : #ffc;*/
+	display : inline;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlInlineEditBox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,6 @@
+<form class="inlineEditBox" style="display: none" dojoAttachPoint="form" dojoAttachEvent="onSubmit:saveEdit; onReset:cancelEdit; onKeyUp: checkForValueChange;">
+	<input type="text" dojoAttachPoint="text" style="display: none;" />
+	<textarea dojoAttachPoint="textarea" style="display: none;"></textarea>
+	<input type="submit" value="Save" dojoAttachPoint="submitButton" />
+	<input type="reset" value="Cancel" dojoAttachPoint="cancelButton" />
+</form>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenu2.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenu2.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenu2.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,202 @@
+
+.dojoPopupMenu2 {
+	position: absolute;
+	border: 1px solid;
+	border-color: ThreeDLightShadow ThreeDDarkShadow ThreeDDarkShadow ThreeDLightShadow;
+}
+
+.dojoPopupMenu2Client {
+	border: 1px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	background-color: ThreeDFace;
+	padding: 1px;
+}
+
+.dojoMenuItem2 {
+	position: relative;
+	white-space: nowrap;
+	font: menu;
+	color: WindowText;
+	margin: 0;
+}
+
+.dojoMenuItem2 span {
+	margin: 0;
+}
+
+.dojoMenuItem2Hover {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoMenuItem2Icon {
+	position: absolute;
+	background-position: center center;
+	background-repeat: no-repeat;
+	z-index: 1;
+}
+
+.dojoMenuItem2Label {
+	position: absolute;
+	vertical-align: middle;
+	z-index: 1;
+}
+
+.dojoMenuItem2Label span {
+	position: relative;
+	vertical-align: middle;
+	z-index: 2;
+}
+
+.dojoMenuItem2Label span span {
+	position: absolute;
+	color: ThreeDHighlight;
+	display: none;
+	left: 1px;
+	top: 1px;
+	z-index: -2;
+}
+
+.dojoMenuItem2Accel {
+	position: absolute;
+	vertical-align: middle;
+	z-index: 1;
+}
+
+.dojoMenuItem2Accel span {
+	position: relative;
+	vertical-align: middle;
+	z-index: 2;
+}
+
+.dojoMenuItem2Accel span span {
+	position: absolute;
+	color: ThreeDHighlight;
+	display: none;
+	left: 1px;
+	top: 1px;
+	z-index: -2;
+}
+
+.dojoMenuItem2Disabled .dojoMenuItem2Label span,
+.dojoMenuItem2Disabled .dojoMenuItem2Accel span {
+	color: ThreeDShadow;
+}
+
+.dojoMenuItem2Disabled .dojoMenuItem2Label span span,
+.dojoMenuItem2Disabled .dojoMenuItem2Accel span span {
+	color: ThreeDHighlight;
+	display: block;
+}
+
+.dojoMenuItem2Hover .dojoMenuItem2Label span span,
+.dojoMenuItem2Hover .dojoMenuItem2Accel span span {
+	display: none;
+}
+
+.dojoMenuItem2Submenu {
+	position: absolute;
+	background-position: center center;
+	background-repeat: no-repeat;
+}
+
+.dojoMenuItem2Target {
+	position: absolute;
+	z-index: 10;
+	font-size: 1px;
+	background-image: url('images/transparent.gif');
+}
+
+.dojoMenuSeparator2 {
+	font-size: 1px;
+	margin: 0;
+}
+
+.dojoMenuSeparator2Top {
+	height: 50%;
+	border-bottom: 1px solid ThreeDShadow;
+	margin: 0px 2px;
+	font-size: 1px;
+}
+
+.dojoMenuSeparator2Bottom {
+	height: 50%;
+	border-top: 1px solid ThreeDHighlight;
+	margin: 0px 2px;
+	font-size: 1px;
+}
+
+
+
+.dojoMenuBar2 {
+	/*position: relative;*/
+	background-color: ThreeDFace;
+	border-bottom: 1px solid ThreeDHighlight;
+}
+
+.dojoMenuBar2Client {
+	padding: 1px;
+	border-top: 1px solid ThreeDHighlight;
+	border-bottom: 1px solid ThreeDShadow;
+}
+
+.dojoMenuBarItem2 {
+	position: absolute;
+	white-space: nowrap;
+	font: menu;
+	color: WindowText;
+	margin: 0;
+}
+
+.dojoMenuBarItem2 span {
+	margin: 0;
+}
+
+.dojoMenuBarItem2Target {
+	position: absolute;
+	z-index: 10;
+	font-size: 1px;
+	background-image: url('images/transparent.gif');
+}
+
+.dojoMenuBarItem2Label {
+	position: absolute;
+	vertical-align: middle;
+	z-index: 1;
+	padding: 3px 8px;
+}
+
+.dojoMenuBarItem2Label span {
+	position: relative;
+	z-index: 2;
+}
+
+.dojoMenuBarItem2Label span span {
+	position: absolute;
+	color: ThreeDHighlight;
+	display: none;
+	left: 1px;
+	top: 1px;
+	z-index: -2;
+}
+
+.dojoMenuBarItem2Hover {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Label span,
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Accel span {
+	color: ThreeDShadow;
+}
+
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Label span span,
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Accel span span {
+	color: ThreeDHighlight;
+	display: block;
+}
+
+.dojoMenuBarItem2Hover .dojoMenuBarItem2Label span span,
+.dojoMenuBarItem2Hover .dojoMenuBarItem2Accel span span {
+	display: none;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,2 @@
+<div dojoAttachPoint="labelNode" dojoAttachEvent="onClick">
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,91 @@
+.datePickerContainer {
+	margin:0.5em 2em 0.5em 0;
+	/*width:10em;*/
+	float:left;
+}
+
+.previousMonth {
+	background-color:#bbbbbb;
+}
+
+.currentMonth {
+	background-color:#8f8f8f;
+}
+
+.nextMonth {
+	background-color:#eeeeee;
+}
+
+.currentDate {
+	text-decoration:underline;
+	font-style:italic;
+}
+
+.selectedItem {
+	background-color:#3a3a3a;
+	color:#ffffff;
+}
+
+.calendarContainer {
+	border-collapse:collapse;
+	border-spacing:0;
+	border-bottom:1px solid #e6e6e6;
+	overflow: hidden;
+	text-align: right;
+}
+
+.calendarContainer thead{
+	border-bottom:1px solid #e6e6e6;
+}
+
+.calendarContainer tbody * td {
+        height: 100px;
+        border: 1px solid gray;
+}
+
+.calendarContainer td {
+        width: 100px;
+        padding: 2px;
+	vertical-align: top;
+}
+
+.monthLabel {
+	font-size:0.9em;
+	font-weight:400;
+	margin:0;
+	text-align:center;
+}
+
+.monthLabel .month {
+	padding:0 0.4em 0 0.4em;
+}
+
+.yearLabel {
+	font-size:0.9em;
+	font-weight:400;
+	margin:0.25em 0 0 0;
+	text-align:right;
+	color:#a3a3a3;
+}
+
+.yearLabel .selectedYear {
+	color:#000;
+	padding:0 0.2em;
+}
+
+.nextYear, .previousYear {
+	cursor:pointer;cursor:hand;
+}
+
+.incrementControl {
+	cursor:pointer;cursor:hand;
+	width:1em;
+}
+
+.dojoMonthlyCalendarEvent {
+	font-size:0.7em;
+	overflow: hidden;
+	font-color: grey;
+	white-space: nowrap;
+	text-align: left;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,110 @@
+<div class="datePickerContainer" dojoAttachPoint="datePickerContainerNode">
+	<h3 class="monthLabel">
+	<!--
+	<span 
+		dojoAttachPoint="decreaseWeekNode" 
+		dojoAttachEvent="onClick: onIncrementWeek;" 
+		class="incrementControl">
+		<img src="${dojoRoot}src/widget/templates/decrementWeek.gif" alt="&uarr;" />
+	</span>
+	-->
+	<span 
+		dojoAttachPoint="decreaseMonthNode" 
+		dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl">
+		<img src="${dojoRoot}src/widget/templates/decrementMonth.gif" 
+			alt="&uarr;" dojoAttachPoint="decrementMonthImageNode">
+	</span>
+	<span dojoAttachPoint="monthLabelNode" class="month">July</span>
+	<span 
+		dojoAttachPoint="increaseMonthNode" 
+		dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl">
+		<img src="${dojoRoot}src/widget/templates/incrementMonth.gif" 
+			alt="&darr;"  dojoAttachPoint="incrementMonthImageNode">
+	</span>
+	<!--
+		<span dojoAttachPoint="increaseWeekNode" 
+			dojoAttachEvent="onClick: onIncrementWeek;" 
+			class="incrementControl">
+			<img src="${dojoRoot}src/widget/templates/incrementWeek.gif" 
+			alt="&darr;" />
+		</span>
+	-->
+	</h3>
+	<table class="calendarContainer">
+		<thead>
+			<tr>
+				<td>Sunday</td>
+				<td>Monday</td>
+				<td>Tuesday</td>
+				<td>Wednesday</td>
+				<td>Thursday</td>
+				<td>Friday</td>
+				<td>Saturday</td>
+			</tr>
+		</thead>
+		<tbody dojoAttachPoint="calendarDatesContainerNode" 
+			dojoAttachEvent="onClick: onSetDate;">
+			<tr dojoAttachPoint="calendarRow0">
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+			</tr>
+			<tr dojoAttachPoint="calendarRow1">
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+			</tr>
+			<tr dojoAttachPoint="calendarRow2">
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+			</tr>
+			<tr dojoAttachPoint="calendarRow3">
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+			</tr>
+			<tr dojoAttachPoint="calendarRow4">
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+			</tr>
+			<tr dojoAttachPoint="calendarRow5">
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+				<td></td>
+			</tr>
+		</tbody>
+	</table>
+	<h3 class="yearLabel">
+		<span dojoAttachPoint="previousYearLabelNode"
+			dojoAttachEvent="onClick: onIncrementYear;" class="previousYear"></span>
+		<span class="selectedYear" dojoAttachPoint="currentYearLabelNode"></span>
+		<span dojoAttachPoint="nextYearLabelNode" 
+			dojoAttachEvent="onClick: onIncrementYear;" class="nextYear"></span>
+	</h3>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,15 @@
+div.statusBar {
+	background-color: ThreeDFace;
+	height: 28px;
+	padding: 1px;
+	overflow: hidden;
+	font-size: 12px;
+}
+
+div.statusPanel {
+	background-color: ThreeDFace;
+	border: 1px solid;
+	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
+	margin: 1px;
+	padding: 2px 6px;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizableTextarea.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,14 @@
+<div>
+	<div style="border: 2px solid black; width: 90%; height: 200px;"
+		dojoAttachPoint="rootLayoutNode">
+		<div dojoAttachPoint="textAreaContainerNode" 
+			style="border: 0px; margin: 0px; overflow: hidden;">
+		</div>
+		<div dojoAttachPoint="statusBarContainerNode" class="statusBar">
+			<div dojoAttachPoint="statusLabelNode" 
+				class="statusPanel"
+				style="padding-right: 0px; z-index: 1;">drag to resize</div>
+			<div dojoAttachPoint="resizeHandleNode"></div>
+		</div>
+	</div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizeHandle.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizeHandle.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlResizeHandle.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,12 @@
+.dojoHtmlResizeHandle {
+	float: right;
+	position: absolute;
+	right: 2px;
+	bottom: 2px;
+	width: 13px;
+	height: 13px;
+	z-index: 20;
+	cursor: nw-resize;
+	background-image: url(grabCorner.gif);
+	line-height: 0px;
+}
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,59 @@
+ at media screen {
+	html, body {
+		margin: 0px;
+		padding: 0px;
+		width: 100%;
+	}
+	body {
+		display: none;
+	}
+	h1 {
+		font-size: 50px;
+	}
+	p, li {
+		font-size: 30px;
+	}
+	.dojoShowNav {
+		background: #369;
+		overflow: hidden;
+		position: absolute;
+		height: 5px;
+		bottom: 0px;
+		left: 0px;
+		width: 100%;
+		text-align: center;
+	}
+	.dojoShowNav input {
+		margin: 0px;
+	}
+	.dojoShowHider {
+		height: 5px;
+		overflow: hidden;
+		width: 100%;
+	}
+	.dojoShowPrint {
+		position: absolute;
+		left: 5px;
+		top: 0px;
+	}
+}
+ at media print {
+	.dojoShow {
+		display: none !important;
+	}
+	.dojoShowPrint {
+		display: block !important;
+	}
+	.dojoShowPrintSlide {
+		border: 1px solid #aaa;
+		padding: 10px;
+		margin-bottom: 15px;
+	}
+	.dojoShowPrintSlide, ul {
+	page-break-inside: avoid;
+	}
+	h1 {
+		margin-top: 0;
+		page-break-after: avoid;
+	}
+}
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShow.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,11 @@
+<div class="dojoShow">
+	<div dojoAttachPoint="contentNode"></div>
+	<div class="dojoShowNav" dojoAttachPoint="nav">
+		<div class="dojoShowHider" dojoAttachPoint="hider"></div>
+		<span dojoAttachEvent="onClick:previousSlide">&lt;</span>
+		<select dojoAttachEvent="onClick:gotoSlideByEvent" dojoAttachPoint="select">
+			<option dojoAttachPoint="option">Title</option>
+		</select>
+		<span dojoAttachEvent="onClick:nextSlide">&gt;</span>
+	</div>
+</div>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,12 @@
+.dojoShowSlideTitle {
+	height: 100px;
+	background: #369;
+}
+.dojoShowSlideTitle h1 {
+	margin-top: 0;
+	line-height: 100px;
+	margin-left: 30px;
+}
+.dojoShowSlideBody {
+	margin: 15px;
+}
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlShowSlide.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,6 @@
+<div class="dojoShowSlide">
+	<div class="dojoShowSlideTitle">
+		<h1 dojoAttachPoint="htmlTitle">Title</h1>
+	</div>
+	<div class="dojoShowSlideBody" dojoAttachPoint="containerNode"></div>
+</div>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,100 @@
+ul.dojoSimpleDropdownButtons {
+	margin : 0;
+	padding : 5px 0;
+}
+
+ul.dojoSimpleDropdownButtons li {
+	display : inline;
+	margin-right : 5px;
+	padding : 2px 0;
+}
+
+ul.dojoSimpleDropdownButtons li a {
+	padding : 2px 9px;
+	border : 2px outset #ccc;
+	border-right-width : 1px;
+	background : #f4f4f4;
+	color : #333;
+	text-decoration : none;
+}
+
+ul.dojoSimpleDropdownButtons li ul {
+	display : none;
+}
+
+ul.dojoSimpleDropdownButtons li a.disabled {
+	color : #999;
+	cursor : default;
+}
+
+ul.dojoSimpleDropdownButtons li .downArrow {
+	display : inline;
+	padding : 2px 4px;
+	border : 2px outset #ccc;
+	border-left : 0;
+	background : #f4f4f4 url(images/dropdownButtonsArrow.gif) no-repeat 4px 9px;
+	text-decoration : none;
+	color : black;
+	cursor : pointer;
+	_cursor : hand;
+}
+
+ul.dojoSimpleDropdownButtons li .downArrow.disabled {
+	background-image : url(images/dropdownButtonsArrow-disabled.gif);
+	cursor : default;
+}
+
+ul.dojoSimpleDropdownButtons li a:hover,
+ul.dojoSimpleDropdownButtons li span.downArrow:hover {
+	color : black;
+	background-color : #ddd;
+}
+
+ul.dojoSimpleDropdownButtons li .downArrow.pressed, ul.dojoSimpleDropdownButtons li .downArrow:focus {
+	border-style : inset;
+	background-position : 5px 10px;
+	padding : 2px 4px;
+}
+
+ul.dojoSimpleDropdownButtons li a.disabled:hover,
+ul.dojoSimpleDropdownButtons li span.downArrow.disabled:hover {
+	color : #999;
+	background-color : #f4f4f4;
+}
+
+ul.dojoSimpleDropdownButtons li a:focus {
+	padding : 3px 8px 1px 10px;
+	color : #333;
+	border-style : inset;
+}
+
+/* Menu
+ ******************** */
+ul.dojoSimpleDropdownButtonsMenu {
+	position : absolute;
+	margin : 0;
+	_margin : -2px;
+	padding : 0;
+	display : none;
+	border : 1px solid #aaa;
+	background : #f4f4f4;
+	list-style : none;
+	z-index : 99;
+}
+
+ul.dojoSimpleDropdownButtonsMenu li {
+	_display : inline;
+}
+
+ul.dojoSimpleDropdownButtonsMenu a {
+	display : block;
+	padding : 2px 5px;
+	color : #333;
+	text-decoration : none;
+}
+
+ul.dojoSimpleDropdownButtonsMenu a:hover {
+	background : #ddd;
+	color : black;
+}
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,9 @@
+.slideShowImg {
+	position: absolute;
+	left: 0px;
+	top: 0px; 
+	border: 2px solid #4d4d4d;
+	padding: 0px;
+	margin: 0px;
+}
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlideShow.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,15 @@
+<div style="position: relative; padding: 3px;">
+		<div dojoAttachPoint="controlsContainer">
+			<input type="button" value="pause" 
+				dojoAttachPoint="startStopButton"
+				dojoAttachEvent="onClick: togglePaused;">
+		</div>
+		<div style="position: relative; width: 800px; height: 600px;"
+			dojoAttachPoint="imagesContainer"
+			dojoAttachEvent="onClick: togglePaused;">
+			<img dojoAttachPoint="img1" class="slideShowImg" 
+				style="z-index: 1;"  />
+			<img dojoAttachPoint="img2" class="slideShowImg" 
+				style="z-index: 0;" />
+		</div>	
+</div>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,47 @@
+.sliderMain { 
+  position: relative; 
+  /*top: 80px; left: 0px;*/
+  padding: 0px; 
+  border: 1px solid black;
+  width: 300px; height: 300px; 
+}
+
+.sliderHandle { 
+  color: #FF0000;
+  position: relative; 
+  background-image: url(images/slider-button.png);
+  width: 25px; 
+  height: 25px;
+}
+
+.sliderMainHorizontal { 
+  position: relative; 
+  /*top: 80px; left: 0px;*/
+  padding: 0px; 
+  width: 300px; height: 35px; 
+  background: url(images/slider-bg.gif) no-repeat 0px 4px;
+}
+
+.sliderHandleHorizontal { 
+  color: #FF0000;
+  position: relative; 
+  background-image: url(images/slider-button-horz.png);
+  width: 25px; 
+  height: 35px;
+}
+
+.sliderMainVertical { 
+  position: relative; 
+  /*top: 80px; left: 0px;*/
+  padding: 0px; 
+  width: 35px; height: 300px; 
+  background: url(images/slider-bg-vert.gif) no-repeat 4px 0px;
+}
+
+.sliderHandleVertical { 
+  color: #FF0000;
+  position: relative; 
+  background-image: url(images/slider-button-vert.png);
+  width: 35px; 
+  height: 25px;
+}
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSlider.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,3 @@
+<div class="sliderMain">
+    <div class="sliderHandle" dojoAttachPoint="sliderHandle"></div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,3 @@
+<div class="sliderMainHorizontal">
+    <div class="sliderHandleHorizontal" dojoAttachPoint="sliderHandle"></div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderVertical.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderVertical.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSliderVertical.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,3 @@
+<div class="sliderMainVertical">
+    <div class="sliderHandleVertical" dojoAttachPoint="sliderHandle"></div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,39 @@
+input.dojoSpinnerInput {
+	/* font-size: 0.8em; */
+	border: 0px;
+}
+
+.dojoSpinnerOptions {
+	font-family: Verdana, Helvetica, Garamond, sans-serif;
+	/* font-size: 0.7em; */
+	background-color: white;
+	border: 1px solid #afafaf;
+	position: absolute;
+	z-index: 1000; 
+	overflow: auto;
+	-moz-opacity: 0;
+	cursor: default;
+}
+
+table.dojoSpinner {
+	border: 1px solid #afafaf;
+}
+
+.dojoSpinnerItem {
+	padding-left: 2px;
+	padding-top: 2px;
+	margin: 0px;
+}
+
+.dojoSpinnerItemEven {
+	background-color: #f4f4f4;
+}
+
+.dojoSpinnerItemOdd {
+	background-color: white;
+}
+
+.dojoSpinnerItemHighlight {
+	background-color: #63709A;
+	color: white;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSpinner.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,28 @@
+<span style="display:none;">
+	<span style="position:relative;" dojoAttachPoint="relNode">
+		<span style="position:absolute; left:0; top:0;" dojoAttachPoint="absNode">
+			<span style="position:relative;" dojoAttachPoint="innerRelNode">
+				<img border="0"
+					hspace="0"
+					vspace="0"
+					style="position:absolute; left:0;top:0; border-right:1px solid black;border-bottom:1px solid black;"
+					dojoAttachPoint="upArrowNode"
+					src="${dojoRoot}src/widget/templates/images/spinnerIncrement.gif">
+				<img border="0"
+					hspace="0"
+					vspace="0"
+					style="vertical-align:bottom;border-right:1px solid black;border-bottom:1px solid black;"
+					dojoAttachPoint="downArrowNode"
+					src="${dojoRoot}src/widget/templates/images/spinnerDecrement.gif">
+			</span>
+		</span>
+		<span style="position:relative;" dojoAttachPoint="spacerRelNode">
+			<img border="0"
+				hspace="0"
+				vspace="0"
+				style="visibility:hidden;"
+				dojoAttachPoint="spacerNode"
+				src="${dojoRoot}src/widget/templates/images/spinnerIncrement.gif">
+		</span>
+	</span>
+</span>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSplitContainer.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSplitContainer.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlSplitContainer.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,39 @@
+.dojoSplitContainer{
+	position: relative;
+	overflow: hidden;
+}
+
+.dojoSplitPane{
+	position: absolute;
+}
+
+.dojoSplitContainerSizerH,
+.dojoSplitContainerSizerV {
+	font-size: 1px;
+	cursor: move;
+	cursor: w-resize;
+	background-color: ThreeDFace;
+	border: 1px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	margin: 0;
+}
+
+.dojoSplitContainerSizerV {
+	cursor: n-resize;
+}
+
+.dojoSplitContainerVirtualSizerH,
+.dojoSplitContainerVirtualSizerV {
+	font-size: 1px;
+	cursor: move;
+	cursor: w-resize;
+	background-color: ThreeDShadow;
+	-moz-opacity: 0.5;
+	opacity: 0.5;
+	filter: Alpha(Opacity=50);
+	margin: 0;
+}
+
+.dojoSplitContainerVirtualSizerV {
+	cursor: n-resize;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,173 @@
+.dojoTabContainer {
+	position : relative;
+}
+
+.dojoTabPaneWrapper {
+	position : relative;
+	border : 1px solid #6290d2;
+	clear: both;
+}
+
+.dojoTabLabels-top {
+	position : absolute;
+	top : 0px;
+	left : 0px;
+	overflow : visible;
+	margin-bottom : -1px;
+	width : 100%;
+	z-index: 2;	/* so the bottom of the tab label will cover up the border of dojoTabPaneWrapper */
+}
+.dojoTabLabels-top-noLayout {
+	overflow : visible;
+	margin-bottom : -1px;
+	width : 100%;
+	z-index: 2;
+}
+
+.dojoTabPaneTab {
+	position : relative;
+	float : left;
+	padding-left : 9px;
+	border-bottom : 1px solid #6290d2;
+	background : url(images/tab_left.gif) no-repeat left top;
+	cursor: pointer;
+}
+
+.dojoTabPaneTab span {
+	display : block;
+	padding : 4px 15px 4px 6px;
+	background : url(images/tab_top_right.gif) no-repeat right top;
+	color : #333;
+	font-size : 90%;
+}
+
+.dojoTabPanePaneClose {
+	position : absolute;
+	bottom : 0px;
+	right : 6px;
+	height : 12px;
+	width : 12px;
+	background : url(images/tab_close.gif) no-repeat right top;
+}
+
+.dojoTabPanePaneCloseHover {
+	background-image : url(images/tab_close_h.gif);
+}
+
+.dojoTabPaneTabClose {
+	display : inline;
+	height : 12px;
+	width : 12px;
+	padding : 0 12px 0 0;
+	margin : 0 -10px 0 10px;
+	background : url(images/tab_close.gif) no-repeat right top;
+	cursor : default;
+}
+
+.dojoTabPaneTabCloseHover {
+	background-image : url(images/tab_close_h.gif);
+}
+
+.dojoTabPaneTab.current {
+	padding-bottom : 1px;
+	border-bottom : 0;
+	background-position : 0 -150px;
+}
+
+.dojoTabPaneTab.current span {
+	padding-bottom : 5px;
+	margin-bottom : -1px;
+	background-position : 100% -150px;
+}
+
+/* bottom tabs */
+
+.dojoTabLabels-bottom {
+	position : absolute;
+	bottom : 0px;
+	left : 0px;
+	overflow : visible;
+	margin-top : -1px;
+	width : 100%;
+	z-index: 2;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab {
+	border-top :  1px solid #6290d2;
+	border-bottom : 0;
+	background : url(images/tab_bot_left.gif) no-repeat left bottom;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab span {
+	background : url(images/tab_bot_right.gif) no-repeat right bottom;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab.current {
+	padding-top : 1px;
+	border-top : 0;
+	background : url(images/tab_bot_left_curr.gif) no-repeat left bottom;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab.current span {
+	padding-top : 5px;
+	margin-top : -1px;
+	background : url(images/tab_bot_right_curr.gif) no-repeat right bottom;
+}
+
+/* right-h tabs */
+
+.dojoTabLabels-right-h {
+	position : absolute;
+	top : 0px;
+	right : 0px;
+	overflow : visible;
+	margin-left : -1px;
+	z-index: 2;
+}
+
+.dojoTabLabels-right-h .dojoTabPaneTab {
+	padding-left : 0;
+	border-left :  1px solid #6290d2;
+	border-bottom : 0;
+	background : url(images/tab_bot_right.gif) no-repeat right bottom;
+	float : none;
+}
+
+.dojoTabLabels-right-h .dojoTabPaneTab span {
+	padding : 4px 15px 4px 15px;
+}
+
+.dojoTabLabels-right-h .dojoTabPaneTab.current {
+	border-left :  0;
+	border-bottom :  1px solid #6290d2;
+}
+
+/* left-h tabs */
+
+.dojoTabLabels-left-h {
+	position : absolute;
+	top : 0px;
+	left : 0px;
+	overflow : visible;
+	margin-right : -1px;
+	z-index: 2;
+}
+
+.dojoTabLabels-left-h .dojoTabPaneTab {
+	border-right :  1px solid #6290d2;
+	border-bottom : 0;
+	float : none;
+	background : url(images/tab_top_left.gif) no-repeat left top;
+}
+
+.dojoTabLabels-left-h .dojoTabPaneTab.current {
+	border-right : 0;
+	border-bottom :  1px solid #6290d2;
+	padding-bottom : 0;
+	background : url(images/tab_top_left.gif) no-repeat 0 -150px;
+}
+
+.dojoTabLabels-left-h .dojoTabPaneTab span {
+	background : 0;
+	border-bottom :  1px solid #6290d2;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTabContainer.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,4 @@
+<div id="${this.widgetId}" class="dojoTabContainer" waiRole="tabpanel">
+	<div dojoAttachPoint="dojoTabLabels"></div>
+	<div class="dojoTabPaneWrapper" dojoAttachPoint="containerNode" ></div>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,29 @@
+.dojoTaskBarItem {
+	display: inline-block;
+	background-color: ThreeDFace;
+	border: outset 2px;
+	margin-right: 5px;
+	cursor: pointer;
+	height: 35px;
+	width: 100px;
+	font-size: 10pt;
+	white-space: nowrap;
+	text-align: center;
+	float: left;
+	overflow: hidden;
+}
+
+.dojoTaskBarItem img {
+	vertical-align: middle;
+	margin-right: 5px;
+	margin-left: 5px;	
+	height: 32px;
+	width: 32px;
+}
+
+.dojoTaskBarItem a {
+	 color: black;
+	text-decoration: none;
+}
+
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,2 @@
+<div class="dojoTaskBarItem" dojoAttachEvent="onClick">
+</div>
\ No newline at end of file

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,37 @@
+.timePickerContainer {
+	margin:1.75em 0 0.5em 0;
+	width:10em;
+	float:left;
+}
+
+.timeContainer {
+	border-collapse:collapse;
+	border-spacing:0;
+}
+
+.timeContainer thead td{
+	border-bottom:1px solid #e6e6e6;
+	padding:0 0.4em 0.2em 0.4em;
+}
+
+.timeContainer td {
+	font-size:0.9em;
+	padding:0 0.25em 0 0.25em;
+	text-align:left;
+	cursor:pointer;cursor:hand;
+}
+
+.timeContainer td.minutesHeading {
+	border-left:1px solid #e6e6e6;
+	border-right:1px solid #e6e6e6;	
+}
+
+.timeContainer .minutes {
+	border-left:1px solid #e6e6e6;
+	border-right:1px solid #e6e6e6;
+}
+
+.selectedItem {
+	background-color:#3a3a3a;
+	color:#ffffff;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTimePicker.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,99 @@
+<div class="timePickerContainer" dojoAttachPoint="timePickerContainerNode">
+	<table class="timeContainer" cellspacing="0" >
+		<thead>
+			<tr>
+				<td>Hour</td>
+				<td class="minutesHeading">Minute</td>
+				<td>&nbsp;</td>
+			</tr>
+		</thead>
+		<tbody>
+			<tr>
+				<td valign="top">
+					<table>
+						<tbody dojoAttachPoint="hourContainerNode"  
+							dojoAttachEvent="onClick: onSetSelectedHour;">
+							<tr>
+								<td>12</td>
+								<td>6</td>
+							</tr>
+							<tr>
+								<td>1</td>
+								<td>7</td>
+							</tr>
+							<tr>
+								<td>2</td>
+								<td>8</td>
+							</tr>
+							<tr>
+								<td>3</td>
+								<td>9</td>
+							</tr>
+							<tr>
+								<td>4</td>
+								<td>10</td>
+							</tr>
+							<tr>
+								<td>5</td>
+								<td>11</td>
+							</tr>
+						</tbody>
+					</table>
+				</td>
+				<td valign="top" class="minutes">
+					<table>
+						<tbody dojoAttachPoint="minuteContainerNode" 
+							dojoAttachEvent="onClick: onSetSelectedMinute;">
+							<tr>
+								<td>00</td>
+								<td>30</td>
+							</tr>
+							<tr>
+								<td>05</td>
+								<td>35</td>
+							</tr>
+							<tr>
+								<td>10</td>
+								<td>40</td>
+							</tr>
+							<tr>
+								<td>15</td>
+								<td>45</td>
+							</tr>
+							<tr>
+								<td>20</td>
+								<td>50</td>
+							</tr>
+							<tr>
+								<td>25</td>
+								<td>55</td>
+							</tr>
+						</tbody>
+					</table>
+				</td>
+				<td valign="top">
+					<table>
+						<tbody dojoAttachPoint="amPmContainerNode" 
+							dojoAttachEvent="onClick: onSetSelectedAmPm;">
+							<tr>
+								<td>AM</td>
+							</tr>
+							<tr>
+								<td>PM</td>
+							</tr>
+						</tbody>
+					</table>
+				</td>
+			</tr>
+			<tr>
+				<td></td>
+				<td>
+					<div dojoAttachPoint="anyTimeContainerNode" 
+						dojoAttachEvent="onClick: onSetSelectedAnyTime;" 
+						class="anyTimeContainer">any</div>
+				</td>
+				<td></td>
+			</tr>
+		</tbody>
+	</table>
+</div>

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlToolbar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlToolbar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlToolbar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,54 @@
+.toolbarContainer {
+	border-bottom : 0;
+	background-color : #def;
+	color : ButtonText;
+	font : Menu;
+	background-image: url(images/toolbar-bg.gif);
+}
+
+.toolbar {
+	padding : 2px 4px;
+	min-height : 26px;
+	_height : 26px;
+}
+
+.toolbarItem {
+	float : left;
+	padding : 1px 2px;
+	margin : 0 2px 1px 0;
+	cursor : pointer;
+}
+
+.toolbarItem.selected, .toolbarItem.down {
+	margin : 1px 1px 0 1px;
+	padding : 0px 1px;
+	border : 1px solid #bbf;
+	background-color : #fafaff;
+}
+
+.toolbarButton img {
+	vertical-align : bottom;
+}
+
+.toolbarButton span {
+	line-height : 16px;
+	vertical-align : middle;
+}
+
+.toolbarButton.hover {
+	padding : 0px 1px;
+	border : 1px solid #99c;
+}
+
+.toolbarItem.disabled {
+	opacity : 0.3;
+	filter : alpha(opacity=30);
+	cursor : default;
+}
+
+.toolbarSeparator {
+	cursor : default;
+}
+
+.toolbarFlexibleSpace {
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,9 @@
+.dojoTooltip {
+	border: solid black 1px;
+	background: beige;
+	color: black;
+	position: absolute;
+	font-size: small;
+	padding: 2px 2px 2px 2px;
+	z-index: 10;
+}

Added: tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,2 @@
+<div class='dojoTooltip' style="display:none" dojoAttachPoint="containerNode">
+</div>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,29 +0,0 @@
-.editLabel {
-	font-size : small;
-	padding : 0 5px;
-	display : none;
-}
-
-.editableRegionDisabled {
-	cursor : pointer;
-	_cursor : hand;
-}
-
-.editableRegion {
-	background-color : #ffc !important;
-	cursor : pointer;
-	_cursor : hand;
-}
-
-.editableRegion .editLabel {
-	display : inline;
-}
-
-.editableTextareaRegion .editLabel {
-	display : block;
-}
-
-.inlineEditBox {
-	/*background-color : #ffc;*/
-	display : inline;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/InlineEditBox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,6 +0,0 @@
-<form class="inlineEditBox" style="display: none" dojoAttachPoint="form" dojoAttachEvent="onSubmit:saveEdit; onReset:cancelEdit; onKeyUp: checkForValueChange;">
-	<input type="text" dojoAttachPoint="text" style="display: none;" />
-	<textarea dojoAttachPoint="textarea" style="display: none;"></textarea>
-	<input type="submit" value="Save" dojoAttachPoint="submitButton" />
-	<input type="reset" value="Cancel" dojoAttachPoint="cancelButton" />
-</form>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Menu2.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Menu2.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Menu2.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,116 +0,0 @@
-
-.dojoPopupMenu2 {
-	position: absolute;
-	border: 1px solid #7298d0;
-	background:#85aeec url(images/soriaMenuBg.gif) repeat-x bottom left !important;
-	padding: 1px;
-	margin-top: 1px;
-	margin-bottom: 1px;
-}
-
-.dojoMenuItem2{
-	white-space: nowrap;
-	font: menu;
-	margin: 0;
-}
-
-.dojoMenuItem2Hover {
-	background-color: #D2E4FD;
-	cursor:pointer;
-	cursor:hand;
-}
-
-.dojoMenuItem2Icon {
-	position: relative;
-	background-position: center center;
-	background-repeat: no-repeat;
-	width: 16px;
-	height: 16px;
-	padding-right: 3px;
-}
-
-.dojoMenuItem2Label {
-	position: relative;
-	vertical-align: middle;
-}
-
-/* main label text */
-.dojoMenuItem2Label {
-	position: relative;
-	vertical-align: middle;
-}
-
-.dojoMenuItem2Accel {
-	position: relative;
-	vertical-align: middle;
-	padding-left: 3px;
-}
-
-.dojoMenuItem2Disabled .dojoMenuItem2Label,
-.dojoMenuItem2Disabled .dojoMenuItem2Accel {
-	color: #607a9e;
-}
-
-.dojoMenuItem2Submenu {
-	position: relative;
-	background-position: center center;
-	background-repeat: no-repeat;
-	background-image: url(images/submenu_off.gif);
-	width: 5px;
-	height: 9px;
-	padding-left: 3px;
-}
-.dojoMenuItem2Hover .dojoMenuItem2Submenu {
-	background-image: url(images/submenu_on.gif);
-}
-
-.dojoMenuItem2Disabled .dojoMenuItem2Submenu {
-	background-image: url(images/submenu_disabled.gif);
-}
-
-.dojoMenuSeparator2 {
-	font-size: 1px;
-	margin: 0;
-}
-
-.dojoMenuSeparator2Top {
-	height: 50%;
-	border-bottom: 1px solid #7a98c4;
-	margin: 0px 2px;
-	font-size: 1px;
-}
-
-.dojoMenuSeparator2Bottom {
-	height: 50%;
-	border-top: 1px solid #c9deff;
-	margin: 0px 2px;
-	font-size: 1px;
-}
-
-.dojoMenuBar2 {
-	background:#85aeec url(images/soriaBarBg.gif) repeat-x top left;
-	/*border-bottom:1px solid #6b9fec;*/
-	padding: 1px;
-}
-
-.dojoMenuBar2 .dojoMenuItem2 {
-	white-space: nowrap;
-	font: menu;
-	margin: 0;
-	position: relative;
-	vertical-align: middle;
-	z-index: 1;
-	padding: 3px 8px;
-	display: inline;/* needed in khtml to display correctly */
-	display: -moz-inline-box;/* needed in firefox */
-	cursor:pointer;
-	cursor:hand;
-}
-
-.dojoMenuBar2 .dojoMenuItem2Hover {
-	background-color:#d2e4fd;
-}
-
-.dojoMenuBar2 .dojoMenuItem2Disabled span {
-	color: #4f6582;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,91 +0,0 @@
-.datePickerContainer {
-	margin:0.5em 2em 0.5em 0;
-	/*width:10em;*/
-	float:left;
-}
-
-.previousMonth {
-	background-color:#bbbbbb;
-}
-
-.currentMonth {
-	background-color:#8f8f8f;
-}
-
-.nextMonth {
-	background-color:#eeeeee;
-}
-
-.currentDate {
-	text-decoration:underline;
-	font-style:italic;
-}
-
-.selectedItem {
-	background-color:#3a3a3a;
-	color:#ffffff;
-}
-
-.calendarContainer {
-	border-collapse:collapse;
-	border-spacing:0;
-	border-bottom:1px solid #e6e6e6;
-	overflow: hidden;
-	text-align: right;
-}
-
-.calendarContainer thead{
-	border-bottom:1px solid #e6e6e6;
-}
-
-.calendarContainer tbody * td {
-        height: 100px;
-        border: 1px solid gray;
-}
-
-.calendarContainer td {
-        width: 100px;
-        padding: 2px;
-	vertical-align: top;
-}
-
-.monthLabel {
-	font-size:0.9em;
-	font-weight:400;
-	margin:0;
-	text-align:center;
-}
-
-.monthLabel .month {
-	padding:0 0.4em 0 0.4em;
-}
-
-.yearLabel {
-	font-size:0.9em;
-	font-weight:400;
-	margin:0.25em 0 0 0;
-	text-align:right;
-	color:#a3a3a3;
-}
-
-.yearLabel .selectedYear {
-	color:#000;
-	padding:0 0.2em;
-}
-
-.nextYear, .previousYear {
-	cursor:pointer;cursor:hand;
-}
-
-.incrementControl {
-	cursor:pointer;cursor:hand;
-	width:1em;
-}
-
-.dojoMonthlyCalendarEvent {
-	font-size:0.7em;
-	overflow: hidden;
-	font-color: grey;
-	white-space: nowrap;
-	text-align: left;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/MonthlyCalendar.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,110 +0,0 @@
-<div class="datePickerContainer" dojoAttachPoint="datePickerContainerNode">
-	<h3 class="monthLabel">
-	<!--
-	<span 
-		dojoAttachPoint="decreaseWeekNode" 
-		dojoAttachEvent="onClick: onIncrementWeek;" 
-		class="incrementControl">
-		<img src="${dojoWidgetModuleUri}templates/decrementWeek.gif" alt="&uarr;" />
-	</span>
-	-->
-	<span 
-		dojoAttachPoint="decreaseMonthNode" 
-		dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl">
-		<img src="${dojoWidgetModuleUri}templates/decrementMonth.gif" 
-			alt="&uarr;" dojoAttachPoint="decrementMonthImageNode">
-	</span>
-	<span dojoAttachPoint="monthLabelNode" class="month">July</span>
-	<span 
-		dojoAttachPoint="increaseMonthNode" 
-		dojoAttachEvent="onClick: onIncrementMonth;" class="incrementControl">
-		<img src="${dojoWidgetModuleUri}templates/incrementMonth.gif" 
-			alt="&darr;"  dojoAttachPoint="incrementMonthImageNode">
-	</span>
-	<!--
-		<span dojoAttachPoint="increaseWeekNode" 
-			dojoAttachEvent="onClick: onIncrementWeek;" 
-			class="incrementControl">
-			<img src="${dojoWidgetModuleUri}templates/incrementWeek.gif" 
-			alt="&darr;" />
-		</span>
-	-->
-	</h3>
-	<table class="calendarContainer">
-		<thead>
-			<tr dojoAttachPoint="dayLabelsRow">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-		</thead>
-		<tbody dojoAttachPoint="calendarDatesContainerNode" 
-			dojoAttachEvent="onClick: onSetDate;">
-			<tr dojoAttachPoint="calendarRow0">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-			<tr dojoAttachPoint="calendarRow1">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-			<tr dojoAttachPoint="calendarRow2">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-			<tr dojoAttachPoint="calendarRow3">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-			<tr dojoAttachPoint="calendarRow4">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-			<tr dojoAttachPoint="calendarRow5">
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-				<td></td>
-			</tr>
-		</tbody>
-	</table>
-	<h3 class="yearLabel">
-		<span dojoAttachPoint="previousYearLabelNode"
-			dojoAttachEvent="onClick: onIncrementYear;" class="previousYear"></span>
-		<span class="selectedYear" dojoAttachPoint="currentYearLabelNode"></span>
-		<span dojoAttachPoint="nextYearLabelNode" 
-			dojoAttachEvent="onClick: onIncrementYear;" class="nextYear"></span>
-	</h3>
-</div>

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/PopUpButton.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/PopUpButton.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/PopUpButton.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -31,5 +31,5 @@
 ul.dropdownButtons li a.disabled:hover,
 ul.dropdownButtons li span.downArrow.disabled:hover {
 	color : #999;
-	background-color : #d2e4fd;
+	background-color : #f4f4f4;
 }

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,23 +0,0 @@
-.backBar{
-	border:1px solid #84a3d1;
-}
-.frontBar{
-	background:url("images/bar.gif") repeat bottom left;
-	background-attachment: fixed;
-}
-.h-frontBar{
-	background:url("images/h-bar.gif") repeat bottom left;
-	background-attachment: fixed;
-}
-.simpleFrontBar{
-	background: red;
-}
-.frontPercent,.backPercent{
-	font:bold 13px helvetica;
-}
-.backPercent{
-	color:#293a4b;
-}
-.frontPercent{
-	color:#fff;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ProgressBar.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,5 +0,0 @@
-<div dojoAttachPoint="containerNode" style="position:relative;overflow:hidden">
-	<div style="position:absolute;display:none;width:100%;text-align:center" dojoAttachPoint="backPercentLabel" class="dojoBackPercentLabel"></div>
-	<div style="position:absolute;overflow:hidden;width:100%;height:100%" dojoAttachPoint="internalProgress">
-	<div style="position:absolute;display:none;width:100%;text-align:center" dojoAttachPoint="frontPercentLabel" class="dojoFrontPercentLabel"></div></div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/RemoteTabControl.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/RemoteTabControl.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/RemoteTabControl.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,61 +0,0 @@
-.dojoRemoteTabController {
-	position: relative;
-}
-
-.dojoRemoteTab {
-	position : relative;
-	float : left;
-	padding-left : 9px;
-	border-bottom : 1px solid #6290d2;
-	background : url(images/tab_left.gif) no-repeat left top;
-	cursor: pointer;
-	white-space: nowrap;
-	z-index: 3;
-}
-
-.dojoRemoteTab div {
-	display : block;
-	padding : 4px 15px 4px 6px;
-	background : url(images/tab_top_right.gif) no-repeat right top;
-	color : #333;
-	font-size : 90%;
-}
-
-.dojoRemoteTabPaneClose {
-	position : absolute;
-	bottom : 0px;
-	right : 6px;
-	height : 12px;
-	width : 12px;
-	background : url(images/tab_close.gif) no-repeat right top;
-}
-
-.dojoRemoteTabPaneCloseHover {
-	background-image : url(images/tab_close_h.gif);
-}
-
-.dojoRemoteTabClose {
-	display : inline-block;
-	height : 12px;
-	width : 12px;
-	padding : 0 12px 0 0;
-	margin : 0 -10px 0 10px;
-	background : url(images/tab_close.gif) no-repeat right top;
-	cursor : default;
-}
-
-.dojoRemoteTabCloseHover {
-	background-image : url(images/tab_close_h.gif);
-}
-
-.dojoRemoteTab.current {
-	padding-bottom : 1px;
-	border-bottom : 0;
-	background-position : 0 -150px;
-}
-
-.dojoRemoteTab.current div {
-	padding-bottom : 5px;
-	margin-bottom : -1px;
-	background-position : 100% -150px;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,15 +0,0 @@
-div.statusBar {
-	background-color: ThreeDFace;
-	height: 28px;
-	padding: 1px;
-	overflow: hidden;
-	font-size: 12px;
-}
-
-div.statusPanel {
-	background-color: ThreeDFace;
-	border: 1px solid;
-	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
-	margin: 1px;
-	padding: 2px 6px;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ResizableTextarea.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,14 +0,0 @@
-<div>
-	<div style="border: 2px solid black; width: 90%; height: 200px;"
-		dojoAttachPoint="rootLayoutNode">
-		<div dojoAttachPoint="textAreaContainerNode" 
-			style="border: 0px; margin: 0px; overflow: hidden;">
-		</div>
-		<div dojoAttachPoint="statusBarContainerNode" class="statusBar">
-			<div dojoAttachPoint="statusLabelNode" 
-				class="statusPanel"
-				style="padding-right: 0px; z-index: 1;">drag to resize</div>
-			<div dojoAttachPoint="resizeHandleNode"></div>
-		</div>
-	</div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ResizeHandle.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ResizeHandle.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ResizeHandle.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,12 +0,0 @@
-.dojoHtmlResizeHandle {
-	float: right;
-	position: absolute;
-	right: 2px;
-	bottom: 2px;
-	width: 13px;
-	height: 13px;
-	z-index: 20;
-	cursor: nw-resize;
-	background-image: url(grabCorner.gif);
-	line-height: 0px;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Show.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Show.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Show.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,59 +0,0 @@
- at media screen {
-	html, body {
-		margin: 0px;
-		padding: 0px;
-		width: 100%;
-	}
-	h1 {
-		font-size: 50px;
-	}
-	p, li {
-		font-size: 30px;
-	}
-	.dojoShowNav {
-		background: #369;
-		overflow: hidden;
-		position: absolute;
-		height: 5px;
-		bottom: 0px;
-		left: 0px;
-		width: 100%;
-		text-align: center;
-	}
-	.dojoShowNav input {
-		margin: 0px;
-	}
-	.dojoShowHider {
-		height: 5px;
-		overflow: hidden;
-		width: 100%;
-	}
-	.dojoShowPrint {
-		position: absolute;
-		left: 5px;
-		top: 0px;
-	}
-	.dojoShow {
-		display: none;
-	}
-}
- at media print {
-	.dojoShow {
-		display: none !important;
-	}
-	.dojoShowPrint {
-		display: block !important;
-	}
-	.dojoShowPrintSlide {
-		border: 1px solid #aaa;
-		padding: 10px;
-		margin-bottom: 15px;
-	}
-	.dojoShowPrintSlide, ul {
-	page-break-inside: avoid;
-	}
-	h1 {
-		margin-top: 0;
-		page-break-after: avoid;
-	}
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Show.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Show.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Show.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,11 +0,0 @@
-<div class="dojoShow">
-	<div dojoAttachPoint="contentNode"></div>
-	<div class="dojoShowNav" dojoAttachPoint="nav">
-		<div class="dojoShowHider" dojoAttachPoint="hider"></div>
-		<span unselectable="on" style="cursor: default;" dojoAttachEvent="onClick:previousSlide">&lt;</span>
-		<select dojoAttachEvent="onClick:gotoSlideByEvent" dojoAttachPoint="select">
-			<option dojoAttachPoint="option">Title</option>
-		</select>
-		<span unselectable="on" style="cursor: default;" dojoAttachEvent="onClick:nextSlide">&gt;</span>
-	</div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,12 +0,0 @@
-.dojoShowSlideTitle {
-	height: 100px;
-	background: #369;
-}
-.dojoShowSlideTitle h1 {
-	margin-top: 0;
-	line-height: 100px;
-	margin-left: 30px;
-}
-.dojoShowSlideBody {
-	margin: 15px;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ShowSlide.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,6 +0,0 @@
-<div class="dojoShowSlide">
-	<div class="dojoShowSlideTitle">
-		<h1 dojoAttachPoint="htmlTitle">Title</h1>
-	</div>
-	<div class="dojoShowSlideBody" dojoAttachPoint="containerNode"></div>
-</div>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,9 +0,0 @@
-.slideShowImg {
-	position: absolute;
-	left: 0px;
-	top: 0px; 
-	border: 2px solid #4d4d4d;
-	padding: 0px;
-	margin: 0px;
-}
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/SlideShow.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,15 +0,0 @@
-<div style="position: relative; padding: 3px;">
-		<div>
-			<input type="button" value="pause" 
-				dojoAttachPoint="startStopButton"
-				dojoAttachEvent="onClick: togglePaused;">
-		</div>
-		<div style="position: relative; width: ${this.width}; height: ${this.height};"
-			dojoAttachPoint="imagesContainer"
-			dojoAttachEvent="onClick: togglePaused;">
-			<img dojoAttachPoint="img1" class="slideShowImg" 
-				style="z-index: 1; width: ${this.width}; height: ${this.height};"  />
-			<img dojoAttachPoint="img2" class="slideShowImg" 
-				style="z-index: 0; width: ${this.width}; height: ${this.height};" />
-		</div>	
-</div>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Slider.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Slider.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Slider.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,61 +0,0 @@
-.sliderMain {
-  border: 0px !important;
-  border-spacing: 0px !important;
-  line-height: 0px !important;
-  padding: 0px !important;
-  display: -moz-inline-table !important;
-  display: inline !important;
-  -moz-user-focus: normal !important;
-}
-
-.sliderComponent {
-  border: 0px;
-  padding: 0px;
-  margin: 0px;
-}
-
-.sliderHandle { 
-  top: 0px;
-  left: 0px;
-  z-index: 1000;
-  position: absolute !important;
-}
-
-.sliderOutsetButton { 
-  border-style: outset;
-  border-width: 0px 1px 1px 0px;
-  border-color: black;
-}
-
-.sliderInsetButton { 
-  border-style: inset;
-  border-width: 1px 0px 0px 1px;
-  border-color: black;
-}
-
-.sliderButtonY {
-  margin: 0px;
-  padding: 0px;
-  z-index: 900;
-}
-
-.sliderButtonX {
-  margin: 0px;
-  padding: 0px;
-  z-index: 900;
-}
-
-.sliderBackground { 
-  z-index: 0;
-  display: block !important;
-  position: relative !important;
-}
-
-.sliderProgressBackground { 
-  z-index: 800;
-  position: absolute !important;
-  clip: rect(0px,0px,0px,0px);
-}
-
-.sliderBackgroundSizeOnly { 
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Slider.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Slider.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Slider.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,56 +0,0 @@
-<table _="weird end tag formatting is to prevent whitespace from becoming &nbsp;" 
-	class="sliderMain" 
-	dojoAttachPoint="focusNode" 
-	dojoAttachEvent="onmousedown:_setFocus; onkey:_handleKeyEvents; onkeyup:_buttonReleased; onmouseup:_buttonReleased; onmousewheel:_mouseWheeled;"
-	tabindex="0" cols=3 cellpadding=0 cellspacing=0 style="">
-	<tr valign=middle align=center>
-		<td class="sliderComponent" colspan=3 dojoAttachPoint=topBorderNode style=""
-			><img class="sliderOutsetButton sliderButtonY"
-				dojoAttachPoint=topButtonNode 
-				dojoAttachEvent="onmousedown:_topButtonPressed; onmousemove:_discardEvent; ondblclick:_topButtonDoubleClicked;"
-				src="${this.topButtonSrc}" 
-				style="${this.buttonStyleY}"
-		></td>
-	</tr>
-	<tr valign=middle align=center>
-		<td class="sliderComponent" dojoAttachPoint=leftBorderNode style=""
-			><img class="sliderOutsetButton sliderButtonX"
-				dojoAttachPoint=leftButtonNode
-				dojoAttachEvent="onmousedown:_leftButtonPressed; onmousemove:_discardEvent; ondblclick:_leftButtonDoubleClicked;"
-				src="${this.leftButtonSrc}" 
-				style="${this.buttonStyleX}"
-		></td>
-		<td dojoAttachPoint=constrainingContainerNode 
-			class="sliderComponent sliderBackground"
-			style="${this.backgroundStyle}"
-			><img src="${this.handleSrc}" 
-				class=sliderHandle
-				dojoAttachPoint=sliderHandleNode
-				style="${this.handleStyle}"
-			><img src="${this.progressBackgroundSrc}"
-				class="sliderBackgroundSizeOnly sliderProgressBackground"
-				dojoAttachPoint=progressBackgroundNode
-				style="${this.backgroundSize}"
-			><img src="${this.backgroundSrc}" 
-				class=sliderBackgroundSizeOnly
-				dojoAttachPoint=sliderBackgroundNode
-				style="${this.backgroundSize}"
-		></td>
-		<td class="sliderComponent" dojoAttachPoint=rightBorderNode style=""
-			><img class="sliderOutsetButton sliderButtonX"
-				dojoAttachPoint=rightButtonNode
-				dojoAttachEvent="onmousedown:_rightButtonPressed; onmousemove:_discardEvent; ondblclick:_rightButtonDoubleClicked;"
-				src="${this.rightButtonSrc}" 
-				style="${this.buttonStyleX}"
-		></td>
-	</tr>
-	<tr valign=middle align=center>
-		<td class="sliderComponent" colspan=3 dojoAttachPoint=bottomBorderNode style=""
-			><img class="sliderOutsetButton sliderButtonY"
-				dojoAttachPoint=bottomButtonNode 
-				dojoAttachEvent="onmousedown:_bottomButtonPressed; onmousemove:_discardEvent; ondblclick:_bottomButtonDoubleClicked;"
-				src="${this.bottomButtonSrc}" 
-				style="${this.buttonStyleY}"
-		></td>
-	</tr>
-</table>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/SliderHorizontal.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/SliderHorizontal.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/SliderHorizontal.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,3 +0,0 @@
-<div class="sliderMainHorizontal">
-    <div class="sliderHandleHorizontal" dojoAttachPoint="sliderHandle"></div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/SliderVertical.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/SliderVertical.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/SliderVertical.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,3 +0,0 @@
-<div class="sliderMainVertical">
-    <div class="sliderHandleVertical" dojoAttachPoint="sliderHandle"></div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,34 +0,0 @@
-/* inline the table holding the <input> and buttons (method varies by browser) */
-.ie .dojoSpinner, .safari .dojoSpinner {
-	display: inline;
-}
-
-.moz .dojoSpinner {
-	display: -moz-inline-box;
-}
-
-.opera .dojoSpinner {
-	display: inline-table;
-}
-
-/* generic stuff for the table */
-.dojoSpinner td {
-	padding:0px;
-	margin:0px;
-	vertical-align: middle;
-}
-table.dojoSpinner {
-	border:0px;
-	border-spacing:0px;
-	line-height:0px;
-	padding:0px;
-	margin: 0px;
-	vertical-align: middle;
-}
-
-/* the buttons */
-.dojoSpinner img {
-	display: block;
-	border-width:0px 1px 1px 0px;
-	border-style:outset;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Spinner.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,25 +0,0 @@
-<span _="weird end tag formatting is to prevent whitespace from becoming &nbsp;"
-	style='float:${this.htmlfloat};'
-	><table cellpadding=0 cellspacing=0 class="dojoSpinner">
-		<tr>
-			<td
-				><input
-					dojoAttachPoint='textbox' type='${this.type}'
-					dojoAttachEvent='onblur;onfocus;onkey:_handleKeyEvents;onKeyUp:_onSpinnerKeyUp;onresize:_resize'
-					id='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'
-					value='${this.value}' class='${this.className}' autocomplete="off"
-			></td>
-			<td
-				><img dojoAttachPoint="upArrowNode"
-					dojoAttachEvent="onDblClick: _upArrowDoubleClicked;  onMouseDown: _upArrowPressed; onMouseUp: _arrowReleased; onMouseOut: _arrowReleased; onMouseMove: _discardEvent;"
-					src="${this.incrementSrc}" style="width: ${this.buttonSize.width}px; height: ${this.buttonSize.height}px;"
-				><img dojoAttachPoint="downArrowNode"
-					dojoAttachEvent="onDblClick: _downArrowDoubleClicked;  onMouseDown: _downArrowPressed; onMouseUp: _arrowReleased; onMouseOut: _arrowReleased; onMouseMove: _discardEvent;"
-					src="${this.decrementSrc}" style="width: ${this.buttonSize.width}px; height: ${this.buttonSize.height}px;"
-			></td>
-		</tr>
-	</table
-	><span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'>${this.messages.invalidMessage}</span
-	><span dojoAttachPoint='missingSpan' class='${this.missingClass}'>${this.messages.missingMessage}</span
-	><span dojoAttachPoint='rangeSpan' class='${this.rangeClass}'>${this.messages.rangeMessage}</span
-></span>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/SplitContainer.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/SplitContainer.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/SplitContainer.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,40 +0,0 @@
-.dojoSplitContainer{
-	position: relative;
-	overflow: hidden;
-	display: block;
-}
-
-.dojoSplitPane{
-	position: absolute;
-}
-
-.dojoSplitContainerSizerH,
-.dojoSplitContainerSizerV {
-	font-size: 1px;
-	cursor: move;
-	cursor: w-resize;
-	background-color: ThreeDFace;
-	border: 1px solid;
-	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
-	margin: 0;
-}
-
-.dojoSplitContainerSizerV {
-	cursor: n-resize;
-}
-
-.dojoSplitContainerVirtualSizerH,
-.dojoSplitContainerVirtualSizerV {
-	font-size: 1px;
-	cursor: move;
-	cursor: w-resize;
-	background-color: ThreeDShadow;
-	-moz-opacity: 0.5;
-	opacity: 0.5;
-	filter: Alpha(Opacity=50);
-	margin: 0;
-}
-
-.dojoSplitContainerVirtualSizerV {
-	cursor: n-resize;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,163 +0,0 @@
-.dojoTabContainer {
-	position : relative;
-}
-
-.dojoTabPaneWrapper {
-	border : 1px solid #6290d2;
-	_zoom: 1; /* force IE6 layout mode so top border doesnt disappear */
-	display: block;
-	clear: both;
-	overflow: hidden;
-}
-
-.dojoTabLabels-top {
-	position : relative;
-	top : 0px;
-	left : 0px;
-	overflow : visible;
-	margin-bottom : -1px;
-	width : 100%;
-	z-index: 2;	/* so the bottom of the tab label will cover up the border of dojoTabPaneWrapper */
-}
-
-.dojoTabNoLayout.dojoTabLabels-top .dojoTab {
-	margin-bottom: -1px;
-	_margin-bottom: 0px; /* IE filter so top border lines up correctly */
-}
-
-.dojoTab {
-	position : relative;
-	float : left;
-	padding-left : 9px;
-	border-bottom : 1px solid #6290d2;
-	background : url(images/tab_left.gif) no-repeat left top;
-	cursor: pointer;
-	white-space: nowrap;
-	z-index: 3;
-}
-
-.dojoTab div {
-	display : block;
-	padding : 4px 15px 4px 6px;
-	background : url(images/tab_top_right.gif) no-repeat right top;
-	color : #333;
-	font-size : 90%;
-}
-
-.dojoTab .close {
-	display : inline-block;
-	height : 12px;
-	width : 12px;
-	padding : 0 12px 0 0;
-	margin : 0 -10px 0 10px;
-	cursor : default;
-	font-size: small;
-}
-
-.dojoTab .closeImage {
-	background : url(images/tab_close.gif) no-repeat right top;
-}
-
-.dojoTab .closeHover {
-	background-image : url(images/tab_close_h.gif);
-}
-
-.dojoTab.current {
-	padding-bottom : 1px;
-	border-bottom : 0;
-	background-position : 0 -150px;
-}
-
-.dojoTab.current div {
-	padding-bottom : 5px;
-	margin-bottom : -1px;
-	background-position : 100% -150px;
-}
-
-/* bottom tabs */
-
-.dojoTabLabels-bottom {
-	position : relative;
-	bottom : 0px;
-	left : 0px;
-	overflow : visible;
-	margin-top : -1px;
-	width : 100%;
-	z-index: 2;
-}
-
-.dojoTabNoLayout.dojoTabLabels-bottom {
-	position : relative;
-}
-
-.dojoTabLabels-bottom .dojoTab {
-	border-top :  1px solid #6290d2;
-	border-bottom : 0;
-	background : url(images/tab_bot_left.gif) no-repeat left bottom;
-}
-
-.dojoTabLabels-bottom .dojoTab div {
-	background : url(images/tab_bot_right.gif) no-repeat right bottom;
-}
-
-.dojoTabLabels-bottom .dojoTab.current {
-	border-top : 0;
-	background : url(images/tab_bot_left_curr.gif) no-repeat left bottom;
-}
-
-.dojoTabLabels-bottom .dojoTab.current div {
-	padding-top : 4px;
-	background : url(images/tab_bot_right_curr.gif) no-repeat right bottom;
-}
-
-/* right-h tabs */
-
-.dojoTabLabels-right-h {
-	overflow : visible;
-	margin-left : -1px;
-	z-index: 2;
-}
-
-.dojoTabLabels-right-h .dojoTab {
-	padding-left : 0;
-	border-left :  1px solid #6290d2;
-	border-bottom : 0;
-	background : url(images/tab_bot_right.gif) no-repeat right bottom;
-	float : none;
-}
-
-.dojoTabLabels-right-h .dojoTab div {
-	padding : 4px 15px 4px 15px;
-}
-
-.dojoTabLabels-right-h .dojoTab.current {
-	border-left :  0;
-	border-bottom :  1px solid #6290d2;
-}
-
-/* left-h tabs */
-
-.dojoTabLabels-left-h {
-	overflow : visible;
-	margin-right : -1px;
-	z-index: 2;
-}
-
-.dojoTabLabels-left-h .dojoTab {
-	border-right :  1px solid #6290d2;
-	border-bottom : 0;
-	float : none;
-	background : url(images/tab_top_left.gif) no-repeat left top;
-}
-
-.dojoTabLabels-left-h .dojoTab.current {
-	border-right : 0;
-	border-bottom :  1px solid #6290d2;
-	padding-bottom : 0;
-	background : url(images/tab_top_left.gif) no-repeat 0 -150px;
-}
-
-.dojoTabLabels-left-h .dojoTab div {
-	background : 0;
-	border-bottom :  1px solid #6290d2;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TabContainer.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +0,0 @@
-<div id="${this.widgetId}" class="dojoTabContainer">
-	<div dojoAttachPoint="tablistNode"></div>
-	<div class="dojoTabPaneWrapper" dojoAttachPoint="containerNode" dojoAttachEvent="onKey" waiRole="tabpanel"></div>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TabContainerA11y.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TabContainerA11y.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TabContainerA11y.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,175 +0,0 @@
-.dojoTabContainer {
-	position : relative;
-}
-
-.dojoTabPaneWrapper {
-	position : relative;
-	border : 1px solid #6290d2;
-	clear: both;
-	_zoom: 1; /* force IE6 layout mode so top border doesnt disappear */
-}
-
-.dojoTabLabels-top {
-	position : absolute;
-	top : 0px;
-	left : 0px;
-	overflow : visible;
-	margin-bottom : -1px;
-	width : 100%;
-	z-index: 2;	/* so the bottom of the tab label will cover up the border of dojoTabPaneWrapper */
-}
-
-.dojoTabNoLayout.dojoTabLabels-top {
-	position : relative;
-}
-
-.dojoTabNoLayout.dojoTabLabels-top .dojoTab {
-	margin-bottom: -1px;
-	_margin-bottom: 0px; /* IE filter so top border lines up correctly */
-}
-
-.dojoTab {
-	position : relative;
-	float : left;
-	padding-left : 9px;
-	border-bottom : 1px solid #6290d2;
-	cursor: pointer;
-	white-space: nowrap;
-	z-index: 3;
-}
-
-.dojoTab div {
-	display : block;
-	padding : 4px 15px 4px 6px;
-	color : #333;
-	font-size : 90%;
-}
-
-.dojoTabPanePaneClose {
-	position : absolute;
-	bottom : 0px;
-	right : 6px;
-	height : 12px;
-	width : 12px;
-	font-size : small;
-}
-.dojoTabPanePaneCloseImage {
-}
-
-.dojoTabPanePaneCloseHover {
-}
-
-.dojoTabClose {
-	display : inline-block;
-	height : 12px;
-	width : 12px;
-	padding : 0 12px 0 0;
-	margin : 0 -10px 0 10px;
-	cursor : default;
-	font-size: small;
-}
-
-.dojoTabCloseImage {
-}
-
-.dojoTabCloseHover {
-}
-
-.dojoTab.current {
-	padding-bottom : 1px;
-	border-bottom : 0;
-	background-position : 0 -150px;
-}
-
-.dojoTab.current div {
-	padding-bottom : 5px;
-	margin-bottom : -1px;
-	background-position : 100% -150px;
-}
-
-/* bottom tabs */
-
-.dojoTabLabels-bottom {
-	position : absolute;
-	bottom : 0px;
-	left : 0px;
-	overflow : visible;
-	margin-top : -1px;
-	width : 100%;
-	z-index: 2;
-}
-
-.dojoTabNoLayout.dojoTabLabels-bottom {
-	position : relative;
-}
-
-.dojoTabLabels-bottom .dojoTab {
-	border-top :  1px solid #6290d2;
-	border-bottom : 0;
-}
-
-.dojoTabLabels-bottom .dojoTab div {
-}
-
-.dojoTabLabels-bottom .dojoTab.current {
-	border-top : 0;
-}
-
-.dojoTabLabels-bottom .dojoTab.current div {
-	padding-top : 4px;
-}
-
-/* right-h tabs */
-
-.dojoTabLabels-right-h {
-	position : absolute;
-	top : 0px;
-	right : 0px;
-	overflow : visible;
-	margin-left : -1px;
-	z-index: 2;
-}
-
-.dojoTabLabels-right-h .dojoTab {
-	padding-left : 0;
-	border-left :  1px solid #6290d2;
-	border-bottom : 0;
-	float : none;
-}
-
-.dojoTabLabels-right-h .dojoTab div {
-	padding : 4px 15px 4px 15px;
-}
-
-.dojoTabLabels-right-h .dojoTab.current {
-	border-left :  0;
-	border-bottom :  1px solid #6290d2;
-}
-
-/* left-h tabs */
-
-.dojoTabLabels-left-h {
-	position : absolute;
-	top : 0px;
-	left : 0px;
-	overflow : visible;
-	margin-right : -1px;
-	z-index: 2;
-}
-
-.dojoTabLabels-left-h .dojoTab {
-	border-right :  1px solid #6290d2;
-	border-bottom : 0;
-	float : none;
-}
-
-.dojoTabLabels-left-h .dojoTab.current {
-	border-right : 0;
-	border-bottom :  1px solid #6290d2;
-	padding-bottom : 0;
-}
-
-.dojoTabLabels-left-h .dojoTab div {
-	background : 0;
-	border-bottom :  1px solid #6290d2;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TaskBar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TaskBar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TaskBar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,29 +0,0 @@
-.dojoTaskBarItem {
-	display: inline-block;
-	background-color: ThreeDFace;
-	border: outset 2px;
-	margin-right: 5px;
-	cursor: pointer;
-	height: 35px;
-	width: 100px;
-	font-size: 10pt;
-	white-space: nowrap;
-	text-align: center;
-	float: left;
-	overflow: hidden;
-}
-
-.dojoTaskBarItem img {
-	vertical-align: middle;
-	margin-right: 5px;
-	margin-left: 5px;	
-	height: 32px;
-	width: 32px;
-}
-
-.dojoTaskBarItem a {
-	 color: black;
-	text-decoration: none;
-}
-
-

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TaskBarItemTemplate.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TaskBarItemTemplate.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TaskBarItemTemplate.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,2 +0,0 @@
-<div class="dojoTaskBarItem" dojoAttachEvent="onClick">
-</div>
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Textbox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Textbox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Textbox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,5 +0,0 @@
-<span style='float:${this.htmlfloat};'>
-	<input dojoAttachPoint='textbox' dojoAttachEvent='onblur;onfocus'
-		id='${this.widgetId}' name='${this.name}'
-		class='${this.className}' type='${this.type}' >
-</span>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,179 +0,0 @@
-/*Time Picker */
-.timePickerContainer {
-	width:122px;
-	font-family:Tahoma, Myriad, Helvetica, Arial, Verdana, sans-serif;
-	font-size:16px;
-}
-
-.timeContainer {
-	border-collapse:collapse;
-	border-spacing:0;
-}
-
-.timeContainer thead {
-	color:#293a4b;
-	font-size:0.9em;
-	font-weight:700;
-}
-
-.timeContainer thead td {
-	padding:0.25em;
-	font-size:0.80em;
-	border-bottom:1px solid #6782A8;
-}
-
-.timeCorner {
-	width:10px;
-}
-
-.cornerTopLeft {
-	background: url("images/dpCurveTL.png") top left no-repeat;
-}
-
-.cornerTopRight {
-	background: url("images/dpCurveTR.png") top right no-repeat;
-}
-
-.timeLabelContainer {
-	background: url("images/dpMonthBg.png") top left repeat-x;
-}
-
-.hours, .minutes, .timeBorder {
-	background: #7591bc url("images/dpBg.gif") top left repeat-x;
-
-}
-
-.hours td, .minutes td {
-	padding:0.2em;
-	text-align:center;
-	font-size:0.7em;
-	font-weight:bold;
-	cursor:pointer;
-	cursor:hand;
-	color:#fff;
-}
-
-.minutes {
-	border-left:1px solid #f5d1db;
-}
-
-.hours {
-	border-right:1px solid #6782A8;
-}
-
-.hourSelector {
-	border-right:1px solid #6782A8;
-	padding:5px;
-	padding-right:10px;
-}
-
-.minutesSelector {
-	padding:5px;
-	border-left:1px solid #f5c7d4;
-	text-align:center;
-}
-
-.minutesHeading {
-	padding-left:9px !important;
-}
-
-.timeOptions {
-	background-color:#F9C9D7;
-}
-
-.timeContainer .cornerBottomLeft, .timeContainer .cornerBottomRight, .timeContainer .timeOptions {
-	border-top:1px solid #6782A8;
-}
-
-.timeContainer .cornerBottomLeft {
-	background: url("images/dpCurveBL.png") bottom left no-repeat !important;
-	width:9px !important;
-	padding:0;
-	margin:0;
-}
-
-.timeContainer .cornerBottomRight {
-	background: url("images/dpCurveBR.png") bottom right no-repeat !important;
-	width:9px !important;
-	padding:0;
-	margin:0;
-}
-
-.timeOptions {
-	color:#fff;
-	background:url("images/dpYearBg.png") top left repeat-x;
-
-}
-
-.selectedItem {
-	background-color:#fff;
-	color:#6782a8 !important;
-}
-
-.timeOptions .selectedItem {
-	color:#fff !important;
-	background-color:#9ec3fb !important;
-}
-
-.anyTimeContainer {
-	text-align:center;
-	font-weight:bold;
-	font-size:0.7em;
-	padding:0.1em;
-	cursor:pointer;
-	cursor:hand;
-	color:#fff !important;
-}
-
-.amPmContainer {
-	width:100%;
-}
-
-.amPmContainer td {
-	text-align:center;
-	font-size:0.7em;
-	font-weight:bold;
-	cursor:pointer;
-	cursor:hand;
-	color:#fff;
-}
-
-
-
-/*.timePickerContainer {
-	margin:1.75em 0 0.5em 0;
-	width:10em;
-	float:left;
-}
-
-.timeContainer {
-	border-collapse:collapse;
-	border-spacing:0;
-}
-
-.timeContainer thead td{
-	border-bottom:1px solid #e6e6e6;
-	padding:0 0.4em 0.2em 0.4em;
-}
-
-.timeContainer td {
-	font-size:0.9em;
-	padding:0 0.25em 0 0.25em;
-	text-align:left;
-	cursor:pointer;cursor:hand;
-}
-
-.timeContainer td.minutesHeading {
-	border-left:1px solid #e6e6e6;
-	border-right:1px solid #e6e6e6;	
-}
-
-.timeContainer .minutes {
-	border-left:1px solid #e6e6e6;
-	border-right:1px solid #e6e6e6;
-}
-
-.selectedItem {
-	background-color:#3a3a3a;
-	color:#ffffff;
-}*/

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TimePicker.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,98 +0,0 @@
-<div class="timePickerContainer" dojoAttachPoint="timePickerContainerNode">
-	<table class="timeContainer" cellspacing="0" >
-		<thead>
-			<tr>
-				<td class="timeCorner cornerTopLeft" valign="top">&nbsp;</td>
-				<td class="timeLabelContainer hourSelector">${this.calendar.field-hour}</td>
-				<td class="timeLabelContainer minutesHeading">${this.calendar.field-minute}</td>
-				<td class="timeCorner cornerTopRight" valign="top">&nbsp;</td>
-			</tr>
-		</thead>
-		<tbody>
-			<tr>
-				<td valign="top" colspan="2" class="hours">
-					<table align="center">
-						<tbody dojoAttachPoint="hourContainerNode"  
-							dojoAttachEvent="onClick: onSetSelectedHour;">
-							<tr>
-								<td>12</td>
-								<td>6</td>
-							</tr>
-							<tr>
-								<td>1</td>
-								<td>7</td>
-							</tr>
-							<tr>
-								<td>2</td>
-								<td>8</td>
-							</tr>
-							<tr>
-								<td>3</td>
-								<td>9</td>
-							</tr>
-							<tr>
-								<td>4</td>
-								<td>10</td>
-							</tr>
-							<tr>
-								<td>5</td>
-								<td>11</td>
-							</tr>
-						</tbody>
-					</table>
-				</td>
-				<td valign="top" class="minutes" colspan="2">
-					<table align="center">
-						<tbody dojoAttachPoint="minuteContainerNode" 
-							dojoAttachEvent="onClick: onSetSelectedMinute;">
-							<tr>
-								<td>00</td>
-								<td>30</td>
-							</tr>
-							<tr>
-								<td>05</td>
-								<td>35</td>
-							</tr>
-							<tr>
-								<td>10</td>
-								<td>40</td>
-							</tr>
-							<tr>
-								<td>15</td>
-								<td>45</td>
-							</tr>
-							<tr>
-								<td>20</td>
-								<td>50</td>
-							</tr>
-							<tr>
-								<td>25</td>
-								<td>55</td>
-							</tr>
-						</tbody>
-					</table>
-				</td>
-			</tr>
-			<tr>
-				<td class="cornerBottomLeft">&nbsp;</td>
-				<td valign="top" class="timeOptions">
-					<table class="amPmContainer">
-						<tbody dojoAttachPoint="amPmContainerNode" 
-							dojoAttachEvent="onClick: onSetSelectedAmPm;">
-							<tr>
-								<td id="am">${this.calendar.am}</td>
-								<td id="pm">${this.calendar.pm}</td>
-							</tr>
-						</tbody>
-					</table>
-				</td>
-				<td class="timeOptions">
-					<div dojoAttachPoint="anyTimeContainerNode" 
-						dojoAttachEvent="onClick: onSetSelectedAnyTime;" 
-						class="anyTimeContainer">${this.widgetStrings.any}</div>
-				</td>
-				<td class="cornerBottomRight">&nbsp;</td>
-			</tr>
-		</tbody>
-	</table>
-</div>

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Toaster.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Toaster.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Toaster.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,42 +0,0 @@
-.dojoToasterClip {
-	position: absolute;
-	overflow: hidden;
-}
-
-.dojoToasterContainer {
-	display: block;
-	position: absolute;
-	width: 17.5em;
-	z-index: 5000;
-	margin: 0px;
-	font:0.75em Tahoma, Helvetica, Verdana, Arial;
-}
-
-.dojoToasterContent{
-	padding:1em;
-	padding-top:0.25em;
-	background:#73c74a;
-}
-
-.dojoToasterMessage{ 
-	color:#fff;
-}
-.dojoToasterWarning{ }
-.dojoToasterError,
-.dojoToasterFatal{
-	font-weight:bold;
-	color:#fff;
-}
-
-
-.dojoToasterWarning .dojoToasterContent{
-	padding:1em;
-	padding-top:0.25em;
-	background:#d4d943;
-} 
-
-.dojoToasterError .dojoToasterContent{
-	padding:1em;
-	padding-top:0.25em;
-	background:#c46600;
-} 

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Toolbar.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Toolbar.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Toolbar.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,54 +0,0 @@
-.toolbarContainer {
-	border-bottom : 0;
-	background-color : #def;
-	color : ButtonText;
-	font : Menu;
-	background-image: url(images/toolbar-bg.gif);
-}
-
-.toolbar {
-	padding : 2px 4px;
-	min-height : 26px;
-	_height : 26px;
-}
-
-.toolbarItem {
-	float : left;
-	padding : 1px 2px;
-	margin : 0 2px 1px 0;
-	cursor : pointer;
-}
-
-.toolbarItem.selected, .toolbarItem.down {
-	margin : 1px 1px 0 1px;
-	padding : 0px 1px;
-	border : 1px solid #bbf;
-	background-color : #fafaff;
-}
-
-.toolbarButton img {
-	vertical-align : bottom;
-}
-
-.toolbarButton span {
-	line-height : 16px;
-	vertical-align : middle;
-}
-
-.toolbarButton.hover {
-	padding : 0px 1px;
-	border : 1px solid #99c;
-}
-
-.toolbarItem.disabled {
-	opacity : 0.3;
-	filter : alpha(opacity=30);
-	cursor : default;
-}
-
-.toolbarSeparator {
-	cursor : default;
-}
-
-.toolbarFlexibleSpace {
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TooltipTemplate.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TooltipTemplate.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TooltipTemplate.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,10 +0,0 @@
-.dojoTooltip {
-	border: solid black 1px;
-	background: beige;
-	color: black;
-	position: absolute;
-	font-size: small;
-	padding: 2px 2px 2px 2px;
-	z-index: 10;
-	display: block;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TreeDisableWrap.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TreeDisableWrap.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TreeDisableWrap.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,9 +0,0 @@
-
-/* CSS for TreeDisableWrapExtension */
-
-.TreeDisableWrap {
-	white-space: nowrap;
-}
-.TreeIEDisableWrap {
-	width: expression( 5 + firstChild.offsetWidth );
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TreeDocIcon.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TreeDocIcon.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TreeDocIcon.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,55 +0,0 @@
-
-/* CSS for TreeDocIconExtension */
-
-
-/* long vertical line under docIcon, connecting w/ children */
-.TreeStateChildrenYes-ExpandOpen .TreeIconContent {
-    background-image : url('../templates/images/TreeV3/i_long.gif');
-    background-repeat : no-repeat;
-    background-position: 18px 9px;
-}
-
-/* close has higher priority */
-.TreeStateChildrenYes-ExpandClosed .TreeIconContent {
-    background-image : url();
-}
-
-/* higher priotity: same length and appear after background-definition */
-.TreeStateChildrenNo-ExpandLeaf .TreeIconContent {
-    background-image : url();
-}
-
-.TreeStateChildrenNo-ExpandClosed .TreeIconContent {
-    background-image : url();
-}
-
-.TreeStateChildrenNo-ExpandOpen .TreeIconContent {
-    background-image : url();
-}
-
-
-/* highest priority */
-.TreeIconDocument {
-    background-image: url('../templates/images/TreeV3/document.gif');
-}
-
-.TreeExpandOpen .TreeIconFolder {
-    background-image: url('../templates/images/TreeV3/open.gif');
-}
-
-.TreeExpandClosed .TreeIconFolder {
-    background-image: url('../templates/images/TreeV3/closed.gif');
-}
-
-/* generic class for docIcon */
-.TreeIcon {
-    width: 18px;
-    height: 18px;
-    float: left;
-    display: inline;
-    background-repeat : no-repeat;
-}
-
-div.TreeContent {
-    margin-left: 36px;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TreeEditor.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TreeEditor.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TreeEditor.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,4 +0,0 @@
-html, body {
-      background-color: #ffc;
-      color: black;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/TreeV3.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/TreeV3.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/TreeV3.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,82 +0,0 @@
-/* indent for all tree children excepts root */
-.TreeNode {
-    background-image : url('../templates/images/TreeV3/i.gif');
-    background-position : top left;
-    background-repeat : repeat-y;
-    margin-left: 19px;
-    zoom: 1;
-}
-.TreeIsRoot {
-    margin-left: 0;
-}
- 
-/* left vertical line (grid) for all nodes */
-.TreeIsLast {
-    background-image: url('../templates/images/TreeV3/i_half.gif');
-    background-repeat : no-repeat;
-}
- 
-.TreeExpandOpen .TreeExpand {
-    background-image: url('../templates/images/TreeV3/expand_minus.gif');
-}
- 
-/* closed is higher priority than open */
-.TreeExpandClosed .TreeExpand {
-    background-image: url('../templates/images/TreeV3/expand_plus.gif');
-}
- 
-/* highest priority */
-.TreeExpandLeaf .TreeExpand {
-    background-image: url('../templates/images/TreeV3/expand_leaf.gif');
-}
-
-/* 
-should always override any expand setting, but do not touch children.
-if I add .TreeExpand .TreeExpandLoading same time and put it to top/bottom, then it will take precedence over +- for all descendants or always fail
-so I have to remove TreeExpand and process this one specifically
-*/
-
-.TreeExpandLoading   {
-    width: 18px;
-    height: 18px;
-    float: left;
-    display: inline;
-    background-repeat : no-repeat;
-    background-image: url('../templates/images/TreeV3/expand_loading.gif');
-}
- 
-.TreeContent {
-    min-height: 18px;
-    min-width: 18px;
-    margin-left:18px;
-    cursor: default;
-    /* can't make inline - multiline bugs */
-}
-
-.TreeIEContent {
-	height: 18px;
-}
- 
-.TreeExpand {
-    width: 18px;
-    height: 18px;
-    float: left;
-    display: inline;
-    background-repeat : no-repeat;
-}
- 
-/* same style as IE selection */
-.TreeNodeEmphasized {
-    background-color: Highlight;
-    color: HighlightText;
-}
- 
-.TreeContent .RichTextEditable, .TreeContent .RichTextEditable iframe {
-      background-color: #ffc;
-      color: black;
-}
-
-/* don't use :focus due to opera's lack of support on div's */
-.TreeLabelFocused {
-      outline: 1px invert dotted;
-}

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/Validate.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Validate.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Validate.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,12 +0,0 @@
-.dojoValidateEmpty{
-	background-color: #00FFFF;
-}
-.dojoValidateValid{
-	background-color: #cfc;
-}
-.dojoValidateInvalid{
-	background-color: #fcc;
-}
-.dojoValidateRange{
-	background-color: #ccf;
-}
\ No newline at end of file

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/ValidationTextbox.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/ValidationTextbox.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/ValidationTextbox.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,8 +0,0 @@
-<span style='float:${this.htmlfloat};'>
-	<input dojoAttachPoint='textbox' type='${this.type}' dojoAttachEvent='onblur;onfocus;onkeyup'
-		id='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'
-		class='${this.className}' style=''>
-	<span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'>${this.messages.invalidMessage}</span>
-	<span dojoAttachPoint='missingSpan' class='${this.missingClass}'>${this.messages.missingMessage}</span>
-	<span dojoAttachPoint='rangeSpan' class='${this.rangeClass}'>${this.messages.rangeMessage}</span>
-</span>

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/Wizard.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/Wizard.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/Wizard.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -4,7 +4,8 @@
     <div class="WizardButtonHolder" dojoAttachPoint="wizardControlContainerNode">
         <input class="WizardButton" type="button" dojoAttachPoint="previousButton"/>
         <input class="WizardButton" type="button" dojoAttachPoint="nextButton"/>
+        <input class="WizardButton" type="button" dojoAttachPoint="cancelButton"/>
         <input class="WizardButton" type="button" dojoAttachPoint="doneButton" style="display:none"/>
-        <input class="WizardButton" type="button" dojoAttachPoint="cancelButton"/>
     </div>
 </div>
+

Added: tags/parley-0.53/root/static/magic/src/widget/templates/buttons/-.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/buttons/-.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/buttons/sep.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/check.gif
===================================================================
(Binary files differ)

Added: tags/parley-0.53/root/static/magic/src/widget/templates/check_disabled_off.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/check_disabled_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: tags/parley-0.53/root/static/magic/src/widget/templates/check_disabled_on.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/check_disabled_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: tags/parley-0.53/root/static/magic/src/widget/templates/check_hover_off.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/check_hover_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: tags/parley-0.53/root/static/magic/src/widget/templates/check_hover_on.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/check_hover_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: tags/parley-0.53/root/static/magic/src/widget/templates/check_off.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/check_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: tags/parley-0.53/root/static/magic/src/widget/templates/check_on.gif
===================================================================
(Binary files differ)


Property changes on: tags/parley-0.53/root/static/magic/src/widget/templates/check_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/Tree/Tree.css
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/images/Tree/Tree.css	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/images/Tree/Tree.css	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,36 +1,36 @@
-
-.dojoTree {
-	font: caption;
-	font-size: 11px;
-	font-weight: normal;
-	overflow: auto;
-}
-
-
-.dojoTreeNodeLabelTitle {
-	padding-left: 2px;
-	color: WindowText;
-}
-
-.dojoTreeNodeLabel {
-	cursor:hand;
-	cursor:pointer;
-}
-
-.dojoTreeNodeLabelTitle:hover {
-	text-decoration: underline;
-}
-
-.dojoTreeNodeLabelSelected {
-	background-color: Highlight;
-	color: HighlightText;
-}
-
-.dojoTree div {
-	white-space: nowrap;
-}
-
-.dojoTree img, .dojoTreeNodeLabel img {
-	vertical-align: middle;
-}
-
+
+.dojoTree {
+	font: caption;
+	font-size: 11px;
+	font-weight: normal;
+	overflow: auto;
+}
+
+
+.dojoTreeNodeLabelTitle {
+	padding-left: 2px;
+	color: WindowText;
+}
+
+.dojoTreeNodeLabel {
+	cursor:hand;
+	cursor:pointer;
+}
+
+.dojoTreeNodeLabelTitle:hover {
+	text-decoration: underline;
+}
+
+.dojoTreeNodeLabelSelected {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoTree div {
+	white-space: nowrap;
+}
+
+.dojoTree img, .dojoTreeNodeLabel img {
+	vertical-align: middle;
+}
+

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/bar.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/clock.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/decrementMonth.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveBL.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveBR.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveTL.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/dpCurveTR.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/dpMonthBg2.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/dpYearBg.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/h-bar.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/incrementMonth.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-bg-progress-vert.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-bg-vert.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-bg.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-button-horz.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-button-vert.png
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider-button.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_down_arrow.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_left_arrow.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_right_arrow.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/slider_up_arrow.png
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaAccordionOff.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaAccordionSelected.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaActive-c.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaActive-l.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaActive-r.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaBarBg.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaButton-c.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaButton-l.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaButton-r.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaDisabled-c.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaDisabled-l.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaDisabled-r.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaMenuBg.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaPressed-c.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaPressed-l.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/soriaPressed-r.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/submenu_disabled.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/submenu_off.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/images/submenu_on.gif
===================================================================
(Binary files differ)

Deleted: tags/parley-0.53/root/static/magic/src/widget/templates/images/timeIcon.gif
===================================================================
(Binary files differ)

Modified: tags/parley-0.53/root/static/magic/src/widget/templates/richtextframe.html
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/templates/richtextframe.html	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/templates/richtextframe.html	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,24 +1,21 @@
-<!-- <?xml version="1.0" encoding="UTF-8"?> -->
-
-<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
-	"DTD/xhtml1-strict.dtd">
-<html>
-	<head>
-		<title></title>
-		<script type="text/javascript">
-			function init(){
-				document.designMode = 'on';
-				try{
-					parentPageDomain = document.location.href.split('#')[1];
-					if(parentPageDomain){
-						document.domain = parentPageDomain;
-					}
-				}catch(e){ }
-			}
-			window.onload = init;
-		</script>
-	</head>
-	<body>
-		<br />
-	</body>
-</html>
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
+<html>
+  <head>
+    <title></title>
+    <script type="text/javascript">
+    function init(){
+       document.designMode = 'On';
+       parentPageDomain = document.location.href.split('#')[1];
+       if (parentPageDomain) {
+          document.domain = parentPageDomain;
+       }
+    }
+    window.onload = init;
+    </script>
+  </head>
+  <body>
+  <br />
+  </body>
+</html>

Modified: tags/parley-0.53/root/static/magic/src/widget/validate.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/validate.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/validate.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,8 +8,851 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.widget.validate");
 
+dojo.provide("dojo.widget.validate.Textbox");
+dojo.provide("dojo.widget.validate.ValidationTextbox");
+dojo.provide("dojo.widget.validate.IntegerTextbox");
+dojo.provide("dojo.widget.validate.RealNumberTextbox");
+dojo.provide("dojo.widget.validate.CurrencyTextbox");
+dojo.provide("dojo.widget.validate.IpAddressTextbox");
+dojo.provide("dojo.widget.validate.UrlTextbox");
+dojo.provide("dojo.widget.validate.EmailTextbox");
+dojo.provide("dojo.widget.validate.EmailListTextbox");
+dojo.provide("dojo.widget.validate.DateTextbox");
+dojo.provide("dojo.widget.validate.TimeTextbox");
+dojo.provide("dojo.widget.validate.UsStateTextbox");
+dojo.provide("dojo.widget.validate.UsZipTextbox");
+dojo.provide("dojo.widget.validate.UsPhoneNumberTextbox");
 
-dojo.provide("dojo.widget.validate");
-dojo.deprecated("dojo.widget.validate", "use one of the specific widgets in dojo.widget.<name>Textbox instead", "0.5");
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.Manager");
+dojo.require("dojo.widget.Parse");
+dojo.require("dojo.xml.Parse");
+dojo.require("dojo.lang");
 
+dojo.require("dojo.validate.common");
+dojo.require("dojo.validate.datetime");
+dojo.require("dojo.validate.check");
+dojo.require("dojo.validate.web");
+dojo.require("dojo.validate.us");
+
+dojo.widget.manager.registerWidgetPackage("dojo.widget.validate");
+
+
+/*
+  ****** Textbox ******
+
+  This widget is a generic textbox field.
+  Serves as a base class to derive more specialized functionality in subclasses.
+  Has the following properties that can be specified as attributes in the markup.
+
+  @attr id         The textbox id attribute.
+  @attr className  The textbox class attribute.
+  @attr name       The textbox name attribute.
+  @attr value      The textbox value attribute.
+  @attr trim       Removes leading and trailing whitespace if true.  Default is false.
+  @attr uppercase  Converts all characters to uppercase if true.  Default is false.
+  @attr lowercase  Converts all characters to lowercase if true.  Default is false.
+  @attr ucFirst    Converts the first character of each word to uppercase if true.
+  @attr lowercase  Removes all characters that are not digits if true.  Default is false.
+*/
+dojo.widget.validate.Textbox = function() {  }
+
+dojo.inherits(dojo.widget.validate.Textbox, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.validate.Textbox, {
+	// default values for new subclass properties
+	widgetId: "", 
+	widgetType: "Textbox", 
+	id: "",
+	className: "",
+	name: "",
+	value: "",
+	trim: false,
+	uppercase: false,
+	lowercase: false,
+	ucFirst: false,
+	digit: false,
+	htmlfloat: "none",
+	
+	templateString: "<span style='float:${this.htmlfloat};'><input dojoAttachPoint='textbox' dojoAttachEvent='onblur;onfocus'"
+					+ " id='${this.widgetId}' name='${this.name}' "
+					+ " value='${this.value}' class='${this.className}'></input></span>",
+
+	// our DOM nodes
+	textbox: null,
+
+	// Apply various filters to textbox value
+	filter: function() { 
+		if (this.trim) {
+			this.textbox.value = this.textbox.value.replace(/(^\s*|\s*$)/g, "");
+		} 
+		if (this.uppercase) {
+			this.textbox.value = this.textbox.value.toUpperCase();
+		} 
+		if (this.lowercase) {
+			this.textbox.value = this.textbox.value.toLowerCase();
+		} 
+		if (this.ucFirst) {
+			this.textbox.value = this.textbox.value.replace(/\b\w+\b/g, 
+				function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });
+		} 
+		if (this.digit) {
+			this.textbox.value = this.textbox.value.replace(/\D/g, "");
+		} 
+	},
+
+	// event handlers, you can over-ride these in your own subclasses
+	onfocus: function() {},
+	onblur: function() { this.filter(); },
+
+	// All functions below are called by create from dojo.widget.Widget
+	mixInProperties: function(localProperties, frag) {
+		dojo.widget.validate.Textbox.superclass.mixInProperties.apply(this, arguments);
+		if ( localProperties["class"] ) { 
+			this.className = localProperties["class"];
+		}
+	},
+
+	fillInTemplate: function() {
+		// apply any filters to initial value
+		this.filter();
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:Textbox");
+
+
+/*
+  ****** ValidationTextbox ******
+
+  A subclass of Textbox.
+  Over-ride isValid in subclasses to perform specific kinds of validation.
+  Has several new properties that can be specified as attributes in the markup.
+
+	@attr type          		Basic input tag type declaration.
+	@attr size          		Basic input tag size declaration.
+	@attr type          		Basic input tag maxlength declaration.	
+  @attr required          Can be true or false, default is false.
+  @attr validColor        The color textbox is highlighted for valid input. Default is #cfc.
+  @attr invalidColor      The color textbox is highlighted for invalid input. Default is #fcc.
+  @attr invalidClass			Class used to format displayed text in page if necessary to override default class
+  @attr invalidMessage    The message to display if value is invalid.
+  @attr missingMessage    The message to display if value is missing.
+  @attr missingClass		  Override default class used for missing input data
+  @attr listenOnKeyPress  Updates messages on each key press.  Default is true.
+  @attr promptMessage			Will not issue invalid message if field is populated with default user-prompt text
+*/
+dojo.widget.validate.ValidationTextbox = function() {}
+
+dojo.inherits(dojo.widget.validate.ValidationTextbox, dojo.widget.validate.Textbox);
+
+dojo.lang.extend(dojo.widget.validate.ValidationTextbox, {
+	// default values for new subclass properties
+	widgetType: "ValidationTextbox", 
+	type: "",
+	required: false,
+	validColor: "#cfc",
+	invalidColor: "#fcc",
+	rangeClass: "range",
+	invalidClass: "invalid",
+	missingClass: "missing",
+	size: "",
+	maxlength: "",
+	promptMessage: "",
+	invalidMessage: "* The value entered is not valid.",
+	missingMessage: "* This value is required.",
+	rangeMessage: "* This value out of range.",
+	listenOnKeyPress: true,
+	htmlfloat: "none",
+	lastCheckedValue: null,
+
+	templateString:   "<span style='float:${this.htmlfloat};'>"
+					+   "<input dojoAttachPoint='textbox' type='${this.type}' dojoAttachEvent='onblur;onfocus;onkeyup'"
+					+     " id='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'"
+					+     " value='${this.value}' class='${this.className}' style=''></input>"
+					+   "<span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'>${this.invalidMessage}</span>"
+					+   "<span dojoAttachPoint='missingSpan' class='${this.missingClass}'>${this.missingMessage}</span>"
+					+   "<span dojoAttachPoint='rangeSpan' class='${this.rangeClass}'>${this.rangeMessage}</span>"
+					+ "</span>",
+
+	// new DOM nodes
+	invalidSpan: null,
+	missingSpan: null,
+	rangeSpan: null,
+
+	getValue: function() {
+		return this.textbox.value;
+	},
+
+	setValue: function(value) {
+		this.textbox.value = value;
+		this.update();
+	},
+
+	// Need to over-ride with your own validation code in subclasses
+	isValid: function() { return true; },
+
+	// Need to over-ride with your own validation code in subclasses
+	isInRange: function() { return true; },
+
+	// Returns true if value is all whitespace
+	isEmpty: function() { 
+		return ( /^\s*$/.test(this.textbox.value) );
+	},
+
+	// Returns true if value is required and it is all whitespace.
+	isMissing: function() { 
+		return ( this.required && this.isEmpty() );
+	},
+
+	// Called oninit, onblur, and onkeypress.
+	// Show missing or invalid messages if appropriate, and highlight textbox field.
+	update: function() {
+		this.lastCheckedValue = this.textbox.value;
+		this.missingSpan.style.display = "none";
+		this.invalidSpan.style.display = "none";
+		this.rangeSpan.style.display = "none";
+
+		var empty = this.isEmpty();
+		var valid = true;
+		if(this.promptMessage != this.textbox.value){ 
+			valid = this.isValid(); 
+		}
+		var missing = this.isMissing();
+
+		// Display at most one error message
+		if(missing){
+			this.missingSpan.style.display = "";
+		}else if( !empty && !valid ){
+			this.invalidSpan.style.display = "";
+		}else if( !empty && !this.isInRange() ){
+			this.rangeSpan.style.display = "";
+		}
+		this.highlight();
+	},
+
+	// Called oninit, and onblur.
+	highlight: function() {
+		// highlight textbox background 
+		if ( this.isEmpty() ) {
+			this.textbox.style.backgroundColor = "";
+		}else if ( this.isValid() && this.isInRange() ){
+			this.textbox.style.backgroundColor = this.validColor;
+		}else if( this.textbox.value != this.promptMessage){ 
+			this.textbox.style.backgroundColor = this.invalidColor;
+		}
+	},
+
+	onfocus: function() {
+		if ( !this.listenOnKeyPress) {
+		    this.textbox.style.backgroundColor = "";
+		}
+	},
+
+	onblur: function() { 
+		this.filter();
+		this.update(); 
+	},
+
+	onkeyup: function(){ 
+		if(this.listenOnKeyPress){ 
+			//this.filter();  trim is problem if you have to type two words
+			this.update(); 
+		}else if (this.textbox.value != this.lastCheckedValue){
+		    this.textbox.style.backgroundColor = "";
+		}
+	},
+
+	// FIXME: why are there to fillInTemplate methods defined here?
+	fillInTemplate: function() {
+		// Attach isMissing and isValid methods to the textbox.
+		// We may use them later in connection with a submit button widget.
+		// TODO: this is unorthodox; it seems better to do it another way -- Bill
+		this.textbox.isValid = function() { this.isValid.call(this); };
+		this.textbox.isMissing = function() { this.isMissing.call(this); };
+		this.textbox.isInRange = function() { this.isInRange.call(this); };
+		this.filter();
+		this.update(); 
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:ValidationTextbox");
+
+
+/*
+  ****** IntegerTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid/isInRange to test for integer input.
+  Has 4 new properties that can be specified as attributes in the markup.
+
+  @attr signed     The leading plus-or-minus sign. Can be true or false, default is either.
+  @attr separator  The character used as the thousands separator.  Default is no separator.
+  @attr min  Minimum signed value.  Default is -Infinity
+  @attr max  Maximum signed value.  Default is +Infinity
+*/
+dojo.widget.validate.IntegerTextbox = function(node) {
+	// this property isn't a primitive and needs to be created on a per-item basis.
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.IntegerTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.IntegerTextbox, {
+	// new subclass properties
+	widgetType: "IntegerTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.IntegerTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if((localProperties.signed == "true")||
+			(localProperties.signed == "always")){
+			this.flags.signed = true;
+		}else if((localProperties.signed == "false")||
+				(localProperties.signed == "never")){
+			this.flags.signed = false;
+			this.flags.min = 0;
+		}else{
+			this.flags.signed = [ true, false ]; // optional
+		}
+		if(localProperties.separator){ 
+			this.flags.separator = localProperties.separator;
+		}
+		if(localProperties.min){ 
+			this.flags.min = parseInt(localProperties.min);
+		}
+		if(localProperties.max){ 
+			this.flags.max = parseInt(localProperties.max);
+		}
+	},
+
+	// Over-ride for integer validation
+	isValid: function() { 
+		return dojo.validate.isInteger(this.textbox.value, this.flags);
+	},
+	isInRange: function() { 
+		return dojo.validate.isInRange(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:IntegerTextbox");
+
+
+/*
+  ****** RealNumberTextbox ******
+
+  A subclass that extends IntegerTextbox.
+  Over-rides isValid/isInRange to test for real number input.
+  Has 5 new properties that can be specified as attributes in the markup.
+
+  @attr places    The exact number of decimal places.  If omitted, it's unlimited and optional.
+  @attr exponent  Can be true or false.  If omitted the exponential part is optional.
+  @attr eSigned   Is the exponent signed?  Can be true or false, if omitted the sign is optional.
+  @attr min  Minimum signed value.  Default is -Infinity
+  @attr max  Maximum signed value.  Default is +Infinity
+*/
+dojo.widget.validate.RealNumberTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.RealNumberTextbox, dojo.widget.validate.IntegerTextbox);
+
+dojo.lang.extend(dojo.widget.validate.RealNumberTextbox, {
+	// new subclass properties
+	widgetType: "RealNumberTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.RealNumberTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.places ) { 
+			this.flags.places = Number( localProperties.places );
+		}
+		if((localProperties.exponent == "true")||
+			(localProperties.exponent == "always")){
+			this.flags.exponent = true;
+		}else if((localProperties.exponent == "false")||(localProperties.exponent == "never")){
+			this.flags.exponent = false;
+		}else{
+			this.flags.exponent = [ true, false ]; // optional
+		}
+		if((localProperties.esigned == "true")||(localProperties.esigned == "always")){
+			this.flags.eSigned = true;
+		}else if((localProperties.esigned == "false")||(localProperties.esigned == "never")){
+			this.flags.eSigned = false;
+		}else{
+			this.flags.eSigned = [ true, false ]; // optional
+		}
+		if(localProperties.min){ 
+			this.flags.min = parseFloat(localProperties.min);
+		}
+		if(localProperties.max){ 
+			this.flags.max = parseFloat(localProperties.max);
+		}
+	},
+
+	// Over-ride for real number validation
+	isValid: function() { 
+		return dojo.validate.isRealNumber(this.textbox.value, this.flags);
+	},
+	isInRange: function() { 
+		return dojo.validate.isInRange(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:RealNumberTextbox");
+
+
+/*
+  ****** CurrencyTextbox ******
+
+  A subclass that extends IntegerTextbox.
+  Over-rides isValid/isInRange to test if input denotes a monetary value .
+  Has 5 new properties that can be specified as attributes in the markup.
+
+  @attr cents      The two decimal places for cents.  Can be true or false, optional if omitted.
+  @attr symbol     A currency symbol such as Yen "???", Pound "???", or the Euro "???". Default is "$".
+  @attr separator  Default is "," instead of no separator as in IntegerTextbox.
+  @attr min  Minimum signed value.  Default is -Infinity
+  @attr max  Maximum signed value.  Default is +Infinity
+*/
+dojo.widget.validate.CurrencyTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.CurrencyTextbox, dojo.widget.validate.IntegerTextbox);
+
+dojo.lang.extend(dojo.widget.validate.CurrencyTextbox, {
+	// new subclass properties
+	widgetType: "CurrencyTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.CurrencyTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.cents ) { 
+			this.flags.cents = ( localProperties.cents == "true" );
+		}
+		if ( localProperties.symbol ) { 
+			this.flags.symbol = localProperties.symbol;
+		}
+		if(localProperties.min){ 
+			this.flags.min = parseFloat(localProperties.min);
+		}
+		if(localProperties.max){ 
+			this.flags.max = parseFloat(localProperties.max);
+		}
+	},
+
+	// Over-ride for currency validation
+	isValid: function() { 
+		return dojo.validate.isCurrency(this.textbox.value, this.flags);
+	},
+	isInRange: function() { 
+		return dojo.validate.isInRange(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:CurrencyTextbox");
+
+
+/*
+  ****** IpAddressTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test for IP addresses.
+  Can specify formats for ipv4 or ipv6 as attributes in the markup.
+
+  @attr allowDottedDecimal  true or false, default is true.
+  @attr allowDottedHex      true or false, default is true.
+  @attr allowDottedOctal    true or false, default is true.
+  @attr allowDecimal        true or false, default is true.
+  @attr allowHex            true or false, default is true.
+  @attr allowIPv6           true or false, default is true.
+  @attr allowHybrid         true or false, default is true.
+*/
+dojo.widget.validate.IpAddressTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.IpAddressTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.IpAddressTextbox, {
+	// new subclass properties
+	widgetType: "IpAddressTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.IpAddressTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.allowdotteddecimal ) { 
+			this.flags.allowDottedDecimal = ( localProperties.allowdotteddecimal == "true" );
+		}
+		if ( localProperties.allowdottedhex ) { 
+			this.flags.allowDottedHex = ( localProperties.allowdottedhex == "true" );
+		}
+		if ( localProperties.allowdottedoctal ) { 
+			this.flags.allowDottedOctal = ( localProperties.allowdottedoctal == "true" );
+		}
+		if ( localProperties.allowdecimal ) { 
+			this.flags.allowDecimal = ( localProperties.allowdecimal == "true" );
+		}
+		if ( localProperties.allowhex ) { 
+			this.flags.allowHex = ( localProperties.allowhex == "true" );
+		}
+		if ( localProperties.allowipv6 ) { 
+			this.flags.allowIPv6 = ( localProperties.allowipv6 == "true" );
+		}
+		if ( localProperties.allowhybrid ) { 
+			this.flags.allowHybrid = ( localProperties.allowhybrid == "true" );
+		}
+	},
+
+	// Over-ride for IP address validation
+	isValid: function() { 
+		return dojo.validate.isIpAddress(this.textbox.value, this.flags);
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:IpAddressTextbox");
+
+
+/*
+  ****** UrlTextbox ******
+
+  A subclass of IpAddressTextbox.
+  Over-rides isValid to test for URL's.
+  Can specify 5 additional attributes in the markup.
+
+  @attr scheme        Can be true or false.  If omitted the scheme is optional.
+  @attr allowIP       Allow an IP address for hostname.  Default is true.
+  @attr allowLocal    Allow the host to be "localhost".  Default is false.
+  @attr allowCC       Allow 2 letter country code domains.  Default is true.
+  @attr allowGeneric  Allow generic domains.  Can be true or false, default is true.
+*/
+dojo.widget.validate.UrlTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.UrlTextbox, dojo.widget.validate.IpAddressTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UrlTextbox, {
+	// new subclass properties
+	widgetType: "UrlTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.UrlTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.scheme ) { 
+			this.flags.scheme = ( localProperties.scheme == "true" );
+		}
+		if ( localProperties.allowip ) { 
+			this.flags.allowIP = ( localProperties.allowip == "true" );
+		}
+		if ( localProperties.allowlocal ) { 
+			this.flags.allowLocal = ( localProperties.allowlocal == "true" );
+		}
+		if ( localProperties.allowcc ) { 
+			this.flags.allowCC = ( localProperties.allowcc == "true" );
+		}
+		if ( localProperties.allowgeneric ) { 
+			this.flags.allowGeneric = ( localProperties.allowgeneric == "true" );
+		}
+	},
+
+	// Over-ride for URL validation
+	isValid: function() { 
+		return dojo.validate.isUrl(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:UrlTextbox");
+
+
+/*
+  ****** EmailTextbox ******
+
+  A subclass of UrlTextbox.
+  Over-rides isValid to test for email addresses.
+  Can use all markup attributes/properties of UrlTextbox except scheme.
+  One new attribute available in the markup.
+
+  @attr allowCruft  Allow address like <mailto:foo at yahoo.com>.  Default is false.
+*/
+dojo.widget.validate.EmailTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.EmailTextbox, dojo.widget.validate.UrlTextbox);
+
+dojo.lang.extend(dojo.widget.validate.EmailTextbox, {
+	// new subclass properties
+	widgetType: "EmailTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.EmailTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.allowcruft ) { 
+			this.flags.allowCruft = ( localProperties.allowcruft == "true" );
+		}
+	},
+
+	// Over-ride for email address validation
+	isValid: function() { 
+		return dojo.validate.isEmailAddress(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:EmailTextbox");
+
+
+/*
+  ****** EmailListTextbox ******
+
+  A subclass of EmailTextbox.
+  Over-rides isValid to test for a list of email addresses.
+  Can use all markup attributes/properties of EmailTextbox and ...
+
+  @attr listSeparator  The character used to separate email addresses.  
+    Default is ";", ",", "\n" or " ".
+*/
+dojo.widget.validate.EmailListTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.EmailListTextbox, dojo.widget.validate.EmailTextbox);
+
+dojo.lang.extend(dojo.widget.validate.EmailListTextbox, {
+	// new subclass properties
+	widgetType: "EmailListTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.EmailListTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.listseparator ) { 
+			this.flags.listSeparator = localProperties.listseparator;
+		}
+	},
+
+	// Over-ride for email address list validation
+	isValid: function() { 
+		return dojo.validate.isEmailAddressList(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:EmailListTextbox");
+
+
+/*
+  ****** DateTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is in a valid date format.
+
+  @attr format  Described in dojo.validate.js.  Default is  "MM/DD/YYYY".
+*/
+dojo.widget.validate.DateTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.DateTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.DateTextbox, {
+	// new subclass properties
+	widgetType: "DateTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.DateTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.format ) { 
+			this.flags.format = localProperties.format;
+		}
+	},
+
+	// Over-ride for date validation
+	isValid: function() { 
+		return dojo.validate.isValidDate(this.textbox.value, this.flags.format);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:DateTextbox");
+
+
+/*
+  ****** TimeTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is in a valid time format.
+
+  @attr format    Described in dojo.validate.js.  Default is  "h:mm:ss t".
+  @attr amSymbol  The symbol used for AM.  Default is "AM" or "am".
+  @attr pmSymbol  The symbol used for PM.  Default is "PM" or "pm".
+*/
+dojo.widget.validate.TimeTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.TimeTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.TimeTextbox, {
+	// new subclass properties
+	widgetType: "TimeTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.TimeTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.format ) { 
+			this.flags.format = localProperties.format;
+		}
+		if ( localProperties.amsymbol ) { 
+			this.flags.amSymbol = localProperties.amsymbol;
+		}
+		if ( localProperties.pmsymbol ) { 
+			this.flags.pmSymbol = localProperties.pmsymbol;
+		}
+	},
+
+	// Over-ride for time validation
+	isValid: function() { 
+		return dojo.validate.isValidTime(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:TimeTextbox");
+
+
+/*
+  ****** UsStateTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a US state abbr.
+
+  @attr allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
+  @attr allowMilitary     Allow military 'states', e.g. Armed Forces Europe (AE). Default is true.
+*/
+dojo.widget.validate.UsStateTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.UsStateTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsStateTextbox, {
+	// new subclass properties
+	widgetType: "UsStateTextbox", 
+
+	mixInProperties: function(localProperties, frag) {
+		// Initialize properties in super-class.
+		dojo.widget.validate.UsStateTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.allowterritories ) { 
+			this.flags.allowTerritories = ( localProperties.allowterritories == "true" );
+		}
+		if ( localProperties.allowmilitary ) { 
+			this.flags.allowMilitary = ( localProperties.allowmilitary == "true" );
+		}
+	},
+
+	isValid: function() { 
+		return dojo.validate.us.isState(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:UsStateTextbox");
+
+
+/*
+  ****** UsZipTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a US zip code.
+  Validates zip-5 and zip-5 plus 4.
+*/
+dojo.widget.validate.UsZipTextbox = function(node) {}
+
+dojo.inherits(dojo.widget.validate.UsZipTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsZipTextbox, {
+	// new subclass properties
+	widgetType: "UsZipTextbox", 
+
+	isValid: function() { 
+		return dojo.validate.us.isZipCode(this.textbox.value);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:UsZipTextbox");
+
+
+/*
+  ****** UsSocialSecurityNumberTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a US Social Security Number.
+*/
+dojo.widget.validate.UsSocialSecurityNumberTextbox = function(node) {}
+
+dojo.inherits(dojo.widget.validate.UsSocialSecurityNumberTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsSocialSecurityNumberTextbox, {
+	// new subclass properties
+	widgetType: "UsSocialSecurityNumberTextbox", 
+
+	isValid: function() { 
+		return dojo.validate.us.isSocialSecurityNumber(this.textbox.value);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:UsSocialSecurityNumberTextbox");
+
+
+/*
+  ****** UsPhoneNumberTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a 10-digit US phone number, an extension is optional.
+*/
+dojo.widget.validate.UsPhoneNumberTextbox = function(node) {}
+
+dojo.inherits(dojo.widget.validate.UsPhoneNumberTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsPhoneNumberTextbox, {
+	// new subclass properties
+	widgetType: "UsPhoneNumberTextbox", 
+
+	isValid: function() { 
+		return dojo.validate.us.isPhoneNumber(this.textbox.value);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler("dojo:UsPhoneNumberTextbox");

Modified: tags/parley-0.53/root/static/magic/src/widget/vml/Chart.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/widget/vml/Chart.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/widget/vml/Chart.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,520 +8,419 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
-dojo.provide("dojo.widget.vml.Chart");
-dojo.require("dojo.widget.HtmlWidget");
-dojo.require("dojo.widget.Chart");
-dojo.require("dojo.math");
-dojo.require("dojo.html.layout");
-dojo.require("dojo.gfx.color");
-dojo.widget.defineWidget("dojo.widget.vml.Chart", [dojo.widget.HtmlWidget, dojo.widget.Chart], function () {
-	this.templatePath = null;
-	this.templateCssPath = null;
-	this._isInitialize = false;
-	this.hasData = false;
-	this.vectorNode = null;
-	this.plotArea = null;
-	this.dataGroup = null;
-	this.axisGroup = null;
-	this.properties = {height:0, width:0, defaultWidth:600, defaultHeight:400, plotType:null, padding:{top:10, bottom:2, left:60, right:30}, axes:{x:{plotAt:0, label:"", unitLabel:"", unitType:Number, nUnitsToShow:10, range:{min:0, max:200}}, y:{plotAt:0, label:"", unitLabel:"", unitType:Number, nUnitsToShow:10, range:{min:0, max:200}}}};
-}, {parseProperties:function (node) {
-	var bRangeX = false;
-	var bRangeY = false;
-	if (node.getAttribute("width")) {
-		this.properties.width = node.getAttribute("width");
-	}
-	if (node.getAttribute("height")) {
-		this.properties.height = node.getAttribute("height");
-	}
-	if (node.getAttribute("plotType")) {
-		this.properties.plotType = node.getAttribute("plotType");
-	}
-	if (node.getAttribute("padding")) {
-		if (node.getAttribute("padding").indexOf(",") > -1) {
-			var p = node.getAttribute("padding").split(",");
-		} else {
-			var p = node.getAttribute("padding").split(" ");
-		}
-		if (p.length == 1) {
-			var pad = parseFloat(p[0]);
-			this.properties.padding.top = pad;
-			this.properties.padding.right = pad;
-			this.properties.padding.bottom = pad;
-			this.properties.padding.left = pad;
-		} else {
-			if (p.length == 2) {
-				var padV = parseFloat(p[0]);
-				var padH = parseFloat(p[1]);
-				this.properties.padding.top = padV;
-				this.properties.padding.right = padH;
-				this.properties.padding.bottom = padV;
-				this.properties.padding.left = padH;
-			} else {
-				if (p.length == 4) {
-					this.properties.padding.top = parseFloat(p[0]);
-					this.properties.padding.right = parseFloat(p[1]);
-					this.properties.padding.bottom = parseFloat(p[2]);
-					this.properties.padding.left = parseFloat(p[3]);
-				}
-			}
-		}
-	}
-	if (node.getAttribute("rangeX")) {
-		var p = node.getAttribute("rangeX");
-		if (p.indexOf(",") > -1) {
-			p = p.split(",");
-		} else {
-			p = p.split(" ");
-		}
-		this.properties.axes.x.range.min = parseFloat(p[0]);
-		this.properties.axes.x.range.max = parseFloat(p[1]);
-		bRangeX = true;
-	}
-	if (node.getAttribute("rangeY")) {
-		var p = node.getAttribute("rangeY");
-		if (p.indexOf(",") > -1) {
-			p = p.split(",");
-		} else {
-			p = p.split(" ");
-		}
-		this.properties.axes.y.range.min = parseFloat(p[0]);
-		this.properties.axes.y.range.max = parseFloat(p[1]);
-		bRangeY = true;
-	}
-	return {rangeX:bRangeX, rangeY:bRangeY};
-}, setAxesPlot:function (table) {
-	if (table.getAttribute("axisAt")) {
-		var p = table.getAttribute("axisAt");
-		if (p.indexOf(",") > -1) {
-			p = p.split(",");
-		} else {
-			p = p.split(" ");
-		}
-		if (!isNaN(parseFloat(p[0]))) {
-			this.properties.axes.x.plotAt = parseFloat(p[0]);
-		} else {
-			if (p[0].toLowerCase() == "ymin") {
-				this.properties.axes.x.plotAt = this.properties.axes.y.range.min;
-			} else {
-				if (p[0].toLowerCase() == "ymax") {
-					this.properties.axes.x.plotAt = this.properties.axes.y.range.max;
-				}
-			}
-		}
-		if (!isNaN(parseFloat(p[1]))) {
-			this.properties.axes.y.plotAt = parseFloat(p[1]);
-		} else {
-			if (p[1].toLowerCase() == "xmin") {
-				this.properties.axes.y.plotAt = this.properties.axes.x.range.min;
-			} else {
-				if (p[1].toLowerCase() == "xmax") {
-					this.properties.axes.y.plotAt = this.properties.axes.x.range.max;
-				}
-			}
-		}
-	} else {
-		this.properties.axes.x.plotAt = this.properties.axes.y.range.min;
-		this.properties.axes.y.plotAt = this.properties.axes.x.range.min;
-	}
-}, drawVectorNode:function () {
-	if (this.vectorNode) {
-		this.destroy();
-	}
-	this.vectorNode = document.createElement("div");
-	this.vectorNode.style.width = this.properties.width + "px";
-	this.vectorNode.style.height = this.properties.height + "px";
-	this.vectorNode.style.position = "relative";
-	this.domNode.appendChild(this.vectorNode);
-}, drawPlotArea:function () {
-	var plotWidth = this.properties.width - this.properties.padding.left - this.properties.padding.right;
-	var plotHeight = this.properties.height - this.properties.padding.top - this.properties.padding.bottom;
-	if (this.plotArea) {
-		this.plotArea.parentNode.removeChild(this.plotArea);
-		this.plotArea = null;
-	}
-	this.plotArea = document.createElement("div");
-	this.plotArea.style.position = "absolute";
-	this.plotArea.style.backgroundColor = "#fff";
-	this.plotArea.style.top = (this.properties.padding.top) - 2 + "px";
-	this.plotArea.style.left = (this.properties.padding.left - 1) + "px";
-	this.plotArea.style.width = plotWidth + "px";
-	this.plotArea.style.height = plotHeight + "px";
-	this.plotArea.style.clip = "rect(0 " + plotWidth + " " + plotHeight + " 0)";
-	this.vectorNode.appendChild(this.plotArea);
-}, drawDataGroup:function () {
-	var plotWidth = this.properties.width - this.properties.padding.left - this.properties.padding.right;
-	var plotHeight = this.properties.height - this.properties.padding.top - this.properties.padding.bottom;
-	if (this.dataGroup) {
-		this.dataGroup.parentNode.removeChild(this.dataGroup);
-		this.dataGroup = null;
-	}
-	this.dataGroup = document.createElement("div");
-	this.dataGroup.style.position = "absolute";
-	this.dataGroup.setAttribute("title", "Data Group");
-	this.dataGroup.style.top = "0px";
-	this.dataGroup.style.left = "0px";
-	this.dataGroup.style.width = plotWidth + "px";
-	this.dataGroup.style.height = plotHeight + "px";
-	this.plotArea.appendChild(this.dataGroup);
-}, drawAxes:function () {
-	var plotWidth = this.properties.width - this.properties.padding.left - this.properties.padding.right;
-	var plotHeight = this.properties.height - this.properties.padding.top - this.properties.padding.bottom;
-	if (this.axisGroup) {
-		this.axisGroup.parentNode.removeChild(this.axisGroup);
-		this.axisGroup = null;
-	}
-	this.axisGroup = document.createElement("div");
-	this.axisGroup.style.position = "absolute";
-	this.axisGroup.setAttribute("title", "Axis Group");
-	this.axisGroup.style.top = "0px";
-	this.axisGroup.style.left = "0px";
-	this.axisGroup.style.width = plotWidth + "px";
-	this.axisGroup.style.height = plotHeight + "px";
-	this.plotArea.appendChild(this.axisGroup);
-	var stroke = 1;
-	var line = document.createElement("v:line");
-	var y = dojo.widget.vml.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
-	line.setAttribute("from", "0px," + y + "px");
-	line.setAttribute("to", plotWidth + "px," + y + "px");
-	line.style.position = "absolute";
-	line.style.top = "0px";
-	line.style.left = "0px";
-	line.style.antialias = "false";
-	line.setAttribute("strokecolor", "#666");
-	line.setAttribute("strokeweight", stroke * 2 + "px");
-	this.axisGroup.appendChild(line);
-	var line = document.createElement("v:line");
-	var x = dojo.widget.vml.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
-	line.setAttribute("from", x + "px,0px");
-	line.setAttribute("to", x + "px," + plotHeight + "px");
-	line.style.position = "absolute";
-	line.style.top = "0px";
-	line.style.left = "0px";
-	line.style.antialias = "false";
-	line.setAttribute("strokecolor", "#666");
-	line.setAttribute("strokeweight", stroke * 2 + "px");
-	this.axisGroup.appendChild(line);
-	var size = 10;
-	var t = document.createElement("div");
-	t.style.position = "absolute";
-	t.style.top = (this.properties.height - this.properties.padding.bottom) + "px";
-	t.style.left = this.properties.padding.left + "px";
-	t.style.fontFamily = "sans-serif";
-	t.style.fontSize = size + "px";
-	t.innerHTML = dojo.math.round(parseFloat(this.properties.axes.x.range.min), 2);
-	this.vectorNode.appendChild(t);
-	t = document.createElement("div");
-	t.style.position = "absolute";
-	t.style.top = (this.properties.height - this.properties.padding.bottom) + "px";
-	t.style.left = (this.properties.width - this.properties.padding.right - size) + "px";
-	t.style.fontFamily = "sans-serif";
-	t.style.fontSize = size + "px";
-	t.innerHTML = dojo.math.round(parseFloat(this.properties.axes.x.range.max), 2);
-	this.vectorNode.appendChild(t);
-	t = document.createElement("div");
-	t.style.position = "absolute";
-	t.style.top = (size / 2) + "px";
-	t.style.left = "0px";
-	t.style.width = this.properties.padding.left + "px";
-	t.style.textAlign = "right";
-	t.style.paddingRight = "4px";
-	t.style.fontFamily = "sans-serif";
-	t.style.fontSize = size + "px";
-	t.innerHTML = dojo.math.round(parseFloat(this.properties.axes.y.range.max), 2);
-	this.vectorNode.appendChild(t);
-	t = document.createElement("div");
-	t.style.position = "absolute";
-	t.style.top = (this.properties.height - this.properties.padding.bottom - size) + "px";
-	t.style.left = "0px";
-	t.style.width = this.properties.padding.left + "px";
-	t.style.textAlign = "right";
-	t.style.paddingRight = "4px";
-	t.style.fontFamily = "sans-serif";
-	t.style.fontSize = size + "px";
-	t.innerHTML = dojo.math.round(parseFloat(this.properties.axes.y.range.min), 2);
-	this.vectorNode.appendChild(t);
-}, init:function () {
-	if (!this.properties.width || !this.properties.height) {
-		var box = dojo.html.getContentBox(this.domNode);
-		if (!this.properties.width) {
-			this.properties.width = (box.width < 32) ? this.properties.defaultWidth : box.width;
-		}
-		if (!this.properties.height) {
-			this.properties.height = (box.height < 32) ? this.properties.defaultHeight : box.height;
-		}
-	}
-	this.drawVectorNode();
-	this.drawPlotArea();
-	this.drawDataGroup();
-	this.drawAxes();
-	this.assignColors();
-	this._isInitialized = true;
-}, destroy:function () {
-	while (this.domNode.childNodes.length > 0) {
-		this.domNode.removeChild(this.domNode.childNodes[0]);
-	}
-	this.vectorNode = this.plotArea = this.dataGroup = this.axisGroup = null;
-}, render:function () {
-	if (this.dataGroup) {
-		while (this.dataGroup.childNodes.length > 0) {
-			this.dataGroup.removeChild(this.dataGroup.childNodes[0]);
-		}
-	} else {
-		this.init();
-	}
-	for (var i = 0; i < this.series.length; i++) {
-		dojo.widget.vml.Chart.Plotter.plot(this.series[i], this);
-	}
-}, postCreate:function () {
-	var table = this.domNode.getElementsByTagName("table")[0];
-	if (table) {
-		var ranges = this.parseProperties(table);
-		var bRangeX = false;
-		var bRangeY = false;
-		var axisValues = this.parseData(table);
-		if (!bRangeX) {
-			this.properties.axes.x.range = {min:axisValues.x.min, max:axisValues.x.max};
-		}
-		if (!bRangeY) {
-			this.properties.axes.y.range = {min:axisValues.y.min, max:axisValues.y.max};
-		}
-		this.setAxesPlot(table);
-		this.domNode.removeChild(table);
-	}
-	if (this.series.length > 0) {
-		this.render();
-	}
-}});
-dojo.widget.vml.Chart.Plotter = new function () {
-	var self = this;
-	var plotters = {};
-	var types = dojo.widget.Chart.PlotTypes;
-	this.getX = function (value, chart) {
-		var v = parseFloat(value);
-		var min = chart.properties.axes.x.range.min;
-		var max = chart.properties.axes.x.range.max;
-		var ofst = 0 - min;
-		min += ofst;
-		max += ofst;
-		v += ofst;
-		var xmin = 0;
-		var xmax = chart.properties.width - chart.properties.padding.left - chart.properties.padding.right;
-		var x = (v * ((xmax - xmin) / max)) + xmin;
-		return x;
-	};
-	this.getY = function (value, chart) {
-		var v = parseFloat(value);
-		var max = chart.properties.axes.y.range.max;
-		var min = chart.properties.axes.y.range.min;
-		var ofst = 0;
-		if (min < 0) {
-			ofst += Math.abs(min);
-		}
-		min += ofst;
-		max += ofst;
-		v += ofst;
-		var ymin = chart.properties.height - chart.properties.padding.top - chart.properties.padding.bottom;
-		var ymax = 0;
-		var y = (((ymin - ymax) / (max - min)) * (max - v)) + ymax;
-		return y;
-	};
-	this.addPlotter = function (name, func) {
-		plotters[name] = func;
-	};
-	this.plot = function (series, chart) {
-		if (series.values.length == 0) {
-			return;
-		}
-		if (series.plotType && plotters[series.plotType]) {
-			return plotters[series.plotType](series, chart);
-		} else {
-			if (chart.plotType && plotters[chart.plotType]) {
-				return plotters[chart.plotType](series, chart);
-			}
-		}
-	};
-	plotters["bar"] = function (series, chart) {
-		var space = 1;
-		var lastW = 0;
-		var ys = [];
-		var yAxis = self.getY(chart.properties.axes.x.plotAt, chart);
-		var yA = yAxis;
-		for (var i = 0; i < series.values.length; i++) {
-			var x = self.getX(series.values[i].x, chart);
-			var w;
-			if (i == series.values.length - 1) {
-				w = lastW;
-			} else {
-				w = self.getX(series.values[i + 1].x, chart) - x - space;
-				lastW = w;
-			}
-			x -= (w / 2);
-			var y = self.getY(series.values[i].value, chart);
-			var h = Math.abs(yA - y);
-			if (parseFloat(series.values[i].value) < chart.properties.axes.x.plotAt) {
-				y = yA;
-			}
-			var bar = document.createElement("v:rect");
-			bar.style.position = "absolute";
-			bar.style.top = y + "px";
-			bar.style.left = x + "px";
-			bar.style.width = w + "px";
-			bar.style.height = h + "px";
-			bar.setAttribute("fillColor", series.color);
-			bar.setAttribute("stroked", "false");
-			bar.style.antialias = "false";
-			bar.setAttribute("title", series.label + " (" + i + "): " + series.values[i].value);
-			var fill = document.createElement("v:fill");
-			fill.setAttribute("opacity", "0.9");
-			bar.appendChild(fill);
-			chart.dataGroup.appendChild(bar);
-		}
-	};
-	plotters["line"] = function (series, chart) {
-		var tension = 1.5;
-		var line = document.createElement("v:shape");
-		line.setAttribute("strokeweight", "2px");
-		line.setAttribute("strokecolor", series.color);
-		line.setAttribute("fillcolor", "none");
-		line.setAttribute("filled", "false");
-		line.setAttribute("title", series.label);
-		line.setAttribute("coordsize", chart.properties.width + "," + chart.properties.height);
-		line.style.position = "absolute";
-		line.style.top = "0px";
-		line.style.left = "0px";
-		line.style.width = chart.properties.width + "px";
-		line.style.height = chart.properties.height + "px";
-		var stroke = document.createElement("v:stroke");
-		stroke.setAttribute("opacity", "0.85");
-		line.appendChild(stroke);
-		var path = [];
-		for (var i = 0; i < series.values.length; i++) {
-			var x = Math.round(self.getX(series.values[i].x, chart));
-			var y = Math.round(self.getY(series.values[i].value, chart));
-			if (i == 0) {
-				path.push("m");
-				path.push(x + "," + y);
-			} else {
-				var lastx = Math.round(self.getX(series.values[i - 1].x, chart));
-				var lasty = Math.round(self.getY(series.values[i - 1].value, chart));
-				var dx = x - lastx;
-				var dy = y - lasty;
-				path.push("c");
-				var cx = Math.round((x - (tension - 1) * (dx / tension)));
-				path.push(cx + "," + lasty);
-				cx = Math.round((x - (dx / tension)));
-				path.push(cx + "," + y);
-				path.push(x + "," + y);
-			}
-		}
-		line.setAttribute("path", path.join(" ") + " e");
-		chart.dataGroup.appendChild(line);
-	};
-	plotters["area"] = function (series, chart) {
-		var tension = 1.5;
-		var line = document.createElement("v:shape");
-		line.setAttribute("strokeweight", "1px");
-		line.setAttribute("strokecolor", series.color);
-		line.setAttribute("fillcolor", series.color);
-		line.setAttribute("title", series.label);
-		line.setAttribute("coordsize", chart.properties.width + "," + chart.properties.height);
-		line.style.position = "absolute";
-		line.style.top = "0px";
-		line.style.left = "0px";
-		line.style.width = chart.properties.width + "px";
-		line.style.height = chart.properties.height + "px";
-		var stroke = document.createElement("v:stroke");
-		stroke.setAttribute("opacity", "0.8");
-		line.appendChild(stroke);
-		var fill = document.createElement("v:fill");
-		fill.setAttribute("opacity", "0.4");
-		line.appendChild(fill);
-		var path = [];
-		for (var i = 0; i < series.values.length; i++) {
-			var x = Math.round(self.getX(series.values[i].x, chart));
-			var y = Math.round(self.getY(series.values[i].value, chart));
-			if (i == 0) {
-				path.push("m");
-				path.push(x + "," + y);
-			} else {
-				var lastx = Math.round(self.getX(series.values[i - 1].x, chart));
-				var lasty = Math.round(self.getY(series.values[i - 1].value, chart));
-				var dx = x - lastx;
-				var dy = y - lasty;
-				path.push("c");
-				var cx = Math.round((x - (tension - 1) * (dx / tension)));
-				path.push(cx + "," + lasty);
-				cx = Math.round((x - (dx / tension)));
-				path.push(cx + "," + y);
-				path.push(x + "," + y);
-			}
-		}
-		path.push("l");
-		path.push(x + "," + self.getY(0, chart));
-		path.push("l");
-		path.push(self.getX(0, chart) + "," + self.getY(0, chart));
-		line.setAttribute("path", path.join(" ") + " x e");
-		chart.dataGroup.appendChild(line);
-	};
-	plotters["scatter"] = function (series, chart) {
-		var r = 6;
-		for (var i = 0; i < series.values.length; i++) {
-			var x = self.getX(series.values[i].x, chart);
-			var y = self.getY(series.values[i].value, chart);
-			var mod = r / 2;
-			var point = document.createElement("v:rect");
-			point.setAttribute("fillcolor", series.color);
-			point.setAttribute("strokecolor", series.color);
-			point.setAttribute("title", series.label + ": " + series.values[i].value);
-			point.style.position = "absolute";
-			point.style.rotation = "45";
-			point.style.top = (y - mod) + "px";
-			point.style.left = (x - mod) + "px";
-			point.style.width = r + "px";
-			point.style.height = r + "px";
-			var fill = document.createElement("v:fill");
-			fill.setAttribute("opacity", "0.6");
-			point.appendChild(fill);
-			chart.dataGroup.appendChild(point);
-		}
-	};
-	plotters["bubble"] = function (series, chart) {
-		var minR = 1;
-		var min = chart.properties.axes.x.range.min;
-		var max = chart.properties.axes.x.range.max;
-		var ofst = 0 - min;
-		min += ofst;
-		max += ofst;
-		var xmin = chart.properties.padding.left;
-		var xmax = chart.properties.width - chart.properties.padding.right;
-		var factor = (max - min) / (xmax - xmin) * 25;
-		for (var i = 0; i < series.values.length; i++) {
-			var size = series.values[i].size;
-			if (isNaN(parseFloat(size))) {
-				size = minR;
-			}
-			var radius = (parseFloat(size) * factor) / 2;
-			var diameter = radius * 2;
-			var cx = self.getX(series.values[i].x, chart);
-			var cy = self.getY(series.values[i].value, chart);
-			var top = cy - radius;
-			var left = cx - radius;
-			var point = document.createElement("v:oval");
-			point.setAttribute("fillcolor", series.color);
-			point.setAttribute("title", series.label + ": " + series.values[i].value + " (" + size + ")");
-			point.setAttribute("stroked", "false");
-			point.style.position = "absolute";
-			point.style.top = top + "px";
-			point.style.left = left + "px";
-			point.style.width = diameter + "px";
-			point.style.height = diameter + "px";
-			var fill = document.createElement("v:fill");
-			fill.setAttribute("opacity", "0.8");
-			point.appendChild(fill);
-			chart.dataGroup.appendChild(point);
-		}
-	};
-}();
-
+dojo.provide("dojo.widget.vml.Chart");
+
+dojo.require("dojo.widget.HtmlWidget");
+dojo.require("dojo.widget.Chart");
+dojo.require("dojo.math");
+dojo.require("dojo.html");
+//dojo.require("dojo.vml");
+dojo.require("dojo.graphics.color");
+
+dojo.widget.vml.Chart=function(){
+	dojo.widget.Chart.call(this);
+	dojo.widget.HtmlWidget.call(this);
+};
+dojo.inherits(dojo.widget.vml.Chart, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.vml.Chart, {
+	//	widget props
+	templatePath:null,
+	templateCssPath:null,
+
+	//	state
+	_isInitialized:false,
+	hasData:false,
+
+	//	chart props
+	vectorNode:null,
+	plotArea:null,
+	dataGroup:null,
+	axisGroup:null,
+
+	properties:{
+		height:400,	//	defaults, will resize to the domNode.
+		width:600,
+		plotType:null,
+		padding:{
+			top:10,
+			bottom:2,
+			left:60,
+			right:30
+		},
+		axes:{
+			x:{
+				plotAt:0,
+				label:"",
+				unitLabel:"",
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
+			},
+			y:{
+				plotAt:0,
+				label:"",
+				unitLabel:"",
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
+			}
+		}
+	},
+	
+	fillInTemplate:function(args,frag){
+		this.initialize();
+		this.render();
+	},
+	parseData:function(){
+	},
+	initialize:function(){
+		//	parse the data first.
+		this.parseData();
+	
+		// render the body of the chart, not the chart data.
+		if(this.vectorNode){ this.destroy(); }
+		this.vectorNode=document.createElement("div");
+		this.vectorNode.style.width=this.properties.width+"px";
+		this.vectorNode.style.height=this.properties.height+"px";
+		this.vectorNode.style.position="relative";
+		this.domNode.appendChild(this.vectorNode);
+
+		var plotWidth=this.properties.width-this.properties.padding.left-this.properties.padding.right;
+		var plotHeight=this.properties.height-this.properties.padding.top-this.properties.padding.bottom;
+
+		this.plotArea=document.createElement("div");
+		this.plotArea.style.position="absolute";
+		this.plotArea.style.backgroundColor="#fff";
+		this.plotArea.style.top=(this.properties.padding.top)-2+"px";
+		this.plotArea.style.left=(this.properties.padding.left-1)+"px";
+		this.plotArea.style.width=plotWidth+"px";
+		this.plotArea.style.height=plotHeight+"px";
+		this.vectorNode.appendChild(this.plotArea);
+		
+		this.dataGroup=document.createElement("div");
+		this.dataGroup.style.position="relative";
+		this.plotArea.appendChild(this.dataGroup);
+
+		//	clipping rects, what a fucking pain.
+		var bg=this.domNode.style.backgroundColor;
+		var r=document.createElement("v:rect");
+		r.setAttribute("fillcolor", bg);
+		r.setAttribute("stroked", "false");
+		r.style.position="absolute";
+		r.style.top=(-1*this.properties.padding.top)-1+"px";
+		r.style.left=(-1*this.properties.padding.left)+"px";
+		r.style.width=(this.properties.width-3)+"px";
+		r.style.height=(this.properties.padding.top)-2+"px";
+		this.vectorNode.appendChild(r);
+
+		r=document.createElement("v:rect");
+		r.setAttribute("fillcolor", bg);
+		r.setAttribute("stroked", "false");
+		r.style.position="absolute";
+		r.style.top=plotHeight-2+"px";
+		r.style.left=(-1*this.properties.padding.left)+"px";
+		r.style.width=(this.properties.width-3)+"px";
+		r.style.height=(this.properties.padding.bottom)-2+"px"; // fixme: check this.
+		this.vectorNode.appendChild(r);
+
+		r=document.createElement("v:rect");
+		r.setAttribute("fillcolor", bg);
+		r.setAttribute("stroked", "false");
+		r.style.position="absolute";
+		r.style.top="-2px";
+		r.style.left=(-1*this.properties.padding.left)+"px";
+		r.style.width=(this.properties.padding.left-1)+"px";
+		r.style.height=plotHeight+"px";
+		this.vectorNode.appendChild(r);
+		
+		r=document.createElement("v:rect");
+		r.setAttribute("fillcolor", bg);
+		r.setAttribute("stroked", "false");
+		r.style.position="absolute";
+		r.style.top="-2px";
+		r.style.right=(-1*this.properties.padding.right)+1+"px";
+		r.style.width=(this.properties.padding.right-1)+"px";
+		r.style.height=plotHeight+"px";
+		this.vectorNode.appendChild(r);
+		//	end clipping rects.  god that sucks, i wish VML had clipping outside of that crap vmlframe...
+
+		this.axisGroup=document.createElement("div");
+		this.axisGroup.style.position="relative";
+		this.plotArea.appendChild(this.axisGroup);
+
+		var stroke=1;
+
+		//	x axis
+		var line=document.createElement("v:line");
+		var y=dojo.widget.vml.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
+		line.setAttribute("from", this.properties.padding.left-stroke + "," + y);
+		line.setAttribute("to", plotWidth + "," + y);
+		line.style.position="absolute";
+		line.style.antialias="false";
+		line.setAttribute("strokecolor", "#666");
+		line.setAttribute("strokeweight", stroke*2+"px");
+		this.axisGroup.appendChild(line);
+
+		//	y axis
+		var line=document.createElement("v:line");
+		var y=dojo.widget.vml.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
+		line.setAttribute("from", y+","+this.properties.padding.top);
+		line.setAttribute("to", y+","+this.properties.height-this.properties.padding.bottom);
+		line.style.position="absolute";
+		line.style.antialias="false";
+		line.setAttribute("strokecolor", "#666");
+		line.setAttribute("strokeweight", stroke*2+"px");
+		this.axisGroup.appendChild(line);
+		
+		//	labels
+		var size=10;
+
+		//	x axis labels.
+		var t=document.createElement("div");
+		t.style.position="absolute";
+		t.style.top=(this.properties.height-this.properties.padding.bottom+size+2)+"px";
+		t.style.left=this.properties.padding.left+"px";
+		t.style.fontFamily="sans-serif";
+		t.style.fontSize=size+"px";
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.x.range.min),2);
+		this.axisGroup.appendChild(t);
+
+		t=document.createElement("div");
+		t.style.position="absolute";
+		t.style.top=(this.properties.height-this.properties.padding.bottom+size+2)+"px";
+		t.style.left=(this.properties.width-this.properties.padding.right-(size/2))+"px";
+		t.style.fontFamily="sans-serif";
+		t.style.fontSize=size+"px";
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.x.range.max),2);
+		this.axisGroup.appendChild(t);
+
+		//	y axis labels.
+		t=document.createElement("div");
+		t.style.position="absolute";
+		t.style.top=-1*(size/2)+"px";
+		t.style.right=(plotWidth+4)+"px";
+		t.style.fontFamily="sans-serif";
+		t.style.fontSize=size+"px";
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.y.range.max),2);
+		this.axisGroup.appendChild(t);
+		
+		t=document.createElement("div");
+		t.style.position="absolute";
+		t.style.top=(this.properties.height-this.properties.padding.bottom)+"px";
+		t.style.right=(plotWidth+4)+"px";
+		t.style.fontFamily="sans-serif";
+		t.style.fontSize=size+"px";
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.y.range.min),2);
+		this.axisGroup.appendChild(t);
+		
+		//	this is last.
+		this.assignColors();
+		this._isInitialized=true;
+	},
+	destroy:function(){
+		while(this.domNode.childNodes.length>0){
+			this.domNode.removeChild(this.domNode.childNodes[0]);
+		}
+		this.vectorNode=this.plotArea=this.dataGroup=this.axisGroup=null;
+	},
+	render:function(){
+		if (this.dataGroup){
+			while(this.dataGroup.childNodes.length>0){
+				this.dataGroup.removeChild(this.dataGroup.childNodes[0]);
+			}
+		} else {
+			this.initialize();
+		}
+		for(var i=0; i<this.series.length; i++){
+			dojo.widget.vml.Chart.Plotter.plot(this.series[i], this);
+		}
+	}
+});
+
+dojo.widget.vml.Chart.Plotter=new function(){
+	var _this=this;
+	var plotters = {};
+	var types=dojo.widget.Chart.PlotTypes;
+	
+	this.getX=function(value, chart){
+		var v=parseFloat(value);
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+		min+=ofst; max+=ofst; v+=ofst;
+
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var x=(v*((xmax-xmin)/max))+xmin;
+		return x;
+	};
+	this.getY=function(value, chart){
+		var v=parseFloat(value);
+		var max=chart.properties.axes.y.range.max;
+		var min=chart.properties.axes.y.range.min;
+		var ofst=0;
+		if(min<0)ofst+=Math.abs(min);
+		min+=ofst; max+=ofst; v+=ofst;
+		
+		var ymin=chart.properties.height-chart.properties.padding.bottom;
+		var ymax=chart.properties.padding.top;
+		var y=(((ymin-ymax)/(max-min))*(max-v))+ymax;
+		return y;
+	};
+
+	this.addPlotter=function(name, func){
+		plotters[name]=func;
+	};
+	this.plot=function(series, chart){
+		if (series.values.length==0) return;
+		if (series.plotType && plotters[series.plotType]){
+			return plotters[series.plotType](series, chart);
+		}
+		else if (chart.plotType && plotters[chart.plotType]){
+			return plotters[chart.plotType](series, chart);
+		}
+	};
+
+	//	plotting
+	plotters[types.Bar]=function(series, chart){
+		var space=1;
+		var lastW = 0;
+		for (var i=0; i<series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var w;
+			if (i==series.values.length-1){
+				w=lastW;
+			} else{
+				w=_this.getX(series.values[i+1].x, chart)-x-space;
+				lastW=w;
+			}
+			x-=(w/2);
+
+			var yA=_this.getY(chart.properties.axes.x.plotAt, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var h=Math.abs(yA-y);
+			if (parseFloat(series.values[i].value)<chart.properties.axes.x.plotAt){
+				var oy=yA;
+				yA=y;
+				y=oy;
+			}
+
+			var bar=document.createElement("v:rect");
+			bar.style.position="absolute";
+			bar.style.top=x+"px";
+			bar.style.left=y+"px";
+			bar.style.width=w+"px";
+			bar.style.height=h+"px";
+			bar.setAttribute("fillColor", series.color);
+			bar.setAttribute("title", series.label + ": " + series.values[i].value);
+			bar.setAttribute("coordsize", chart.properties.width + "," + chart.properties.height);
+			var fill=document.createElement("v:fill");
+			fill.setAttribute("opacity", "0.9");
+			bar.appendChild(fill);
+			chart.dataGroup.appendChild(bar);
+		}
+	};	
+	plotters[types.Line]=function(series, chart){
+		var tension=3;
+
+		var line=document.createElement("v:shape");
+		line.setAttribute("strokeweight", "2px");
+		line.setAttribute("strokecolor", series.color);
+		line.setAttribute("fillcolor", "none");
+		line.setAttribute("filled", "false");
+		line.setAttribute("title", series.label);
+		line.setAttribute("coordsize", chart.properties.width + "," + chart.properties.height);
+		line.style.position="absolute";
+		line.style.top="0px";
+		line.style.left="0px";
+		line.style.width= chart.properties.width+"px";
+		line.style.height=chart.properties.height+"px";
+		var stroke=document.createElement("v:stroke");
+		stroke.setAttribute("opacity", "0.85");
+		line.appendChild(stroke);
+
+		var path = [];
+		for (var i=0; i<series.values.length; i++){
+			var x = _this.getX(series.values[i].x, chart)
+			var y = _this.getY(series.values[i].value, chart);
+
+			if (i==0){
+				path.push("m");
+				path.push(x+","+y);
+			}else{
+				var lastx=_this.getX(series.values[i-1].x, chart);
+				var lasty=_this.getY(series.values[i-1].value, chart);
+				var dx=x-lastx;
+				
+				path.push("v");
+				var cx=x-(tension-1)*(dx/tension);
+				path.push(cx+",0");
+				cx=x-(dx/tension);
+				path.push(cx+","+y-lasty);
+				path.push(dx, y-lasty);
+			}
+		}
+		line.setAttribute("path", path.join(" ")+" e");
+		chart.dataGroup.appendChild(line);
+	};
+	plotters[types.Scatter]=function(series, chart){
+		var r=8;
+		for (var i=0; i<series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var mod=r/2;
+
+			var point=document.createElement("v:rect");
+			point.setAttribute("fillcolor", series.color);
+			point.setAttribute("strokecolor", series.color);
+			point.setAttribute("title", series.label + ": " + series.values[i].value);
+			point.style.position="absolute";
+			point.style.rotation="45";
+			point.style.top=(y-mod)+"px";
+			point.style.left=(x-mod)+"px";
+			point.style.width=r+"px";
+			point.style.height=r+"px";
+			var fill=document.createElement("v:fill");
+			fill.setAttribute("opacity", "0.5");
+			point.appendChild(fill);
+			chart.dataGroup.appendChild(point);
+		}
+	};	
+	plotters[types.Bubble]=function(series, chart){
+		//	added param for series[n].value: size
+		var minR=1;
+		
+		//	do this off the x axis?
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+
+		min+=ofst; max+=ofst;
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var factor=(max-min)/(xmax-xmin)*25;
+		
+		for (var i=0; i<series.values.length; i++){
+			var size = series.values[i].size;
+			if (isNaN(parseFloat(size))) size=minR;
+			var mod=(parseFloat(size)*factor)/2;
+
+			var point=document.createElement("v:oval");
+			point.setAttribute("strokecolor", series.color);
+			point.setAttribute("fillcolor", series.color);
+			point.setAttribute("title", series.label + ": " + series.values[i].value + " (" + size + ")");
+			point.style.position="absolute";
+			point.style.top=(_this.getY(series.values[i].value, chart)-mod) + "px";
+			point.style.left=(_this.getX(series.values[i].x, chart)-mod) + "px";
+			point.style.width=mod+"px";
+			point.style.height=mod+"px";
+			chart.dataGroup.appendChild(point);
+		}
+	};
+}();

Modified: tags/parley-0.53/root/static/magic/src/xml/Parse.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/xml/Parse.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/xml/Parse.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,158 +8,181 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
+dojo.provide("dojo.xml.Parse");
 
+dojo.require("dojo.dom");
 
-dojo.provide("dojo.xml.Parse");
-dojo.require("dojo.dom");
-dojo.xml.Parse = function () {
-	var isIE = ((dojo.render.html.capable) && (dojo.render.html.ie));
-	function getTagName(node) {
-		try {
-			return node.tagName.toLowerCase();
-		}
-		catch (e) {
-			return "";
-		}
-	}
-	function getDojoTagName(node) {
-		var tagName = getTagName(node);
-		if (!tagName) {
-			return "";
-		}
-		if ((dojo.widget) && (dojo.widget.tags[tagName])) {
-			return tagName;
-		}
-		var p = tagName.indexOf(":");
-		if (p >= 0) {
-			return tagName;
-		}
-		if (tagName.substr(0, 5) == "dojo:") {
-			return tagName;
-		}
-		if (dojo.render.html.capable && dojo.render.html.ie && node.scopeName != "HTML") {
-			return node.scopeName.toLowerCase() + ":" + tagName;
-		}
-		if (tagName.substr(0, 4) == "dojo") {
-			return "dojo:" + tagName.substring(4);
-		}
-		var djt = node.getAttribute("dojoType") || node.getAttribute("dojotype");
-		if (djt) {
-			if (djt.indexOf(":") < 0) {
-				djt = "dojo:" + djt;
+//TODO: determine dependencies
+// currently has dependency on dojo.xml.DomUtil nodeTypes constants...
+
+/* generic method for taking a node and parsing it into an object
+
+TODO: WARNING: This comment is wrong!
+
+For example, the following xml fragment
+
+<foo bar="bar">
+	<baz xyzzy="xyzzy"/>
+</foo>
+
+can be described as:
+
+dojo.???.foo = {}
+dojo.???.foo.bar = {}
+dojo.???.foo.bar.value = "bar";
+dojo.???.foo.baz = {}
+dojo.???.foo.baz.xyzzy = {}
+dojo.???.foo.baz.xyzzy.value = "xyzzy"
+
+*/
+// using documentFragment nomenclature to generalize in case we don't want to require passing a collection of nodes with a single parent
+dojo.xml.Parse = function(){
+
+	function getDojoTagName (node) {
+		var tagName = node.tagName;
+		if (tagName.substr(0,5).toLowerCase() != "dojo:") {
+			
+			if (tagName.substr(0,4).toLowerCase() == "dojo") {
+				// FIXME: this assuumes tag names are always lower case
+				return "dojo:" + tagName.substring(4).toLowerCase();
 			}
-			return djt.toLowerCase();
-		}
-		djt = node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml, "type");
-		if (djt) {
-			return "dojo:" + djt.toLowerCase();
-		}
-		try {
-			djt = node.getAttribute("dojo:type");
-		}
-		catch (e) {
-		}
-		if (djt) {
-			return "dojo:" + djt.toLowerCase();
-		}
-		if ((dj_global["djConfig"]) && (!djConfig["ignoreClassNames"])) {
-			var classes = node.className || node.getAttribute("class");
-			if ((classes) && (classes.indexOf) && (classes.indexOf("dojo-") != -1)) {
-				var aclasses = classes.split(" ");
-				for (var x = 0, c = aclasses.length; x < c; x++) {
-					if (aclasses[x].slice(0, 5) == "dojo-") {
-						return "dojo:" + aclasses[x].substr(5).toLowerCase();
+		
+			// allow lower-casing
+			var djt = node.getAttribute("dojoType") || node.getAttribute("dojotype");
+			if (djt) { return "dojo:" + djt.toLowerCase(); }
+			
+			if (node.getAttributeNS && node.getAttributeNS(dojo.dom.dojoml,"type")) {
+				return "dojo:" + node.getAttributeNS(dojo.dom.dojoml,"type").toLowerCase();
+			}
+			try {
+				// FIXME: IE really really doesn't like this, so we squelch
+				// errors for it
+				djt = node.getAttribute("dojo:type");
+			} catch (e) { /* FIXME: log? */ }
+
+			if (djt) { return "dojo:"+djt.toLowerCase(); }
+		
+			if (!dj_global["djConfig"] || !djConfig["ignoreClassNames"]) {
+				// FIXME: should we make this optionally enabled via djConfig?
+				var classes = node.className||node.getAttribute("class");
+				// FIXME: following line, without check for existence of classes.indexOf
+				// breaks firefox 1.5's svg widgets
+				if (classes && classes.indexOf && classes.indexOf("dojo-") != -1) {
+					var aclasses = classes.split(" ");
+					for(var x=0; x<aclasses.length; x++){
+						if (aclasses[x].length > 5 && aclasses[x].indexOf("dojo-") >= 0) {
+							return "dojo:"+aclasses[x].substr(5).toLowerCase();
+						}
 					}
 				}
 			}
+		
 		}
-		return "";
+		return tagName.toLowerCase();
 	}
-	this.parseElement = function (node, hasParentNodeSet, optimizeForDojoML, thisIdx) {
-		var tagName = getTagName(node);
-		if (isIE && tagName.indexOf("/") == 0) {
-			return null;
-		}
-		try {
-			var attr = node.getAttribute("parseWidgets");
-			if (attr && attr.toLowerCase() == "false") {
-				return {};
-			}
-		}
-		catch (e) {
-		}
-		var process = true;
-		if (optimizeForDojoML) {
-			var dojoTagName = getDojoTagName(node);
-			tagName = dojoTagName || tagName;
-			process = Boolean(dojoTagName);
-		}
+
+	this.parseElement = function(node, hasParentNodeSet, optimizeForDojoML, thisIdx){
+
+        // if parseWidgets="false" don't search inside this node for widgets
+        if (node.getAttribute("parseWidgets") == "false") {
+            return {};
+        }
+
+		// TODO: make this namespace aware
 		var parsedNodeSet = {};
+
+		var tagName = getDojoTagName(node);
 		parsedNodeSet[tagName] = [];
-		var pos = tagName.indexOf(":");
-		if (pos > 0) {
-			var ns = tagName.substring(0, pos);
-			parsedNodeSet["ns"] = ns;
-			if ((dojo.ns) && (!dojo.ns.allow(ns))) {
-				process = false;
-			}
-		}
-		if (process) {
-			var attributeSet = this.parseAttributes(node);
-			for (var attr in attributeSet) {
-				if ((!parsedNodeSet[tagName][attr]) || (typeof parsedNodeSet[tagName][attr] != "array")) {
+		if((!optimizeForDojoML)||(tagName.substr(0,4).toLowerCase()=="dojo")){
+			var attributeSet = parseAttributes(node);
+			for(var attr in attributeSet){
+				if((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != "array")){
 					parsedNodeSet[tagName][attr] = [];
 				}
 				parsedNodeSet[tagName][attr].push(attributeSet[attr]);
 			}
+	
+			// FIXME: we might want to make this optional or provide cloning instead of
+			// referencing, but for now, we include a node reference to allow
+			// instantiated components to figure out their "roots"
 			parsedNodeSet[tagName].nodeRef = node;
 			parsedNodeSet.tagName = tagName;
-			parsedNodeSet.index = thisIdx || 0;
+			parsedNodeSet.index = thisIdx||0;
 		}
+	
 		var count = 0;
-		for (var i = 0; i < node.childNodes.length; i++) {
-			var tcn = node.childNodes.item(i);
-			switch (tcn.nodeType) {
-			  case dojo.dom.ELEMENT_NODE:
-				var ctn = getDojoTagName(tcn) || getTagName(tcn);
-				if (!parsedNodeSet[ctn]) {
-					parsedNodeSet[ctn] = [];
-				}
-				parsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));
-				if ((tcn.childNodes.length == 1) && (tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)) {
-					parsedNodeSet[ctn][parsedNodeSet[ctn].length - 1].value = tcn.childNodes.item(0).nodeValue;
-				}
-				count++;
-				break;
-			  case dojo.dom.TEXT_NODE:
-				if (node.childNodes.length == 1) {
-					parsedNodeSet[tagName].push({value:node.childNodes.item(0).nodeValue});
-				}
-				break;
-			  default:
-				break;
+		var tcn, i = 0, nodes = node.childNodes;
+		while(tcn = nodes[i++]){
+			switch(tcn.nodeType){
+				case  dojo.dom.ELEMENT_NODE: // element nodes, call this function recursively
+					count++;
+					var ctn = getDojoTagName(tcn);
+					if(!parsedNodeSet[ctn]){
+						parsedNodeSet[ctn] = [];
+					}
+					parsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));
+					if(	(tcn.childNodes.length == 1)&&
+						(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){
+						parsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;
+					}
+					break;
+				case  dojo.dom.TEXT_NODE: // if a single text node is the child, treat it as an attribute
+					if(node.childNodes.length == 1) {
+						parsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });
+					}
+					break;
+				default: break;
+				/*
+				case  dojo.dom.ATTRIBUTE_NODE: // attribute node... not meaningful here
+					break;
+				case  dojo.dom.CDATA_SECTION_NODE: // cdata section... not sure if this would ever be meaningful... might be...
+					break;
+				case  dojo.dom.ENTITY_REFERENCE_NODE: // entity reference node... not meaningful here
+					break;
+				case  dojo.dom.ENTITY_NODE: // entity node... not sure if this would ever be meaningful
+					break;
+				case  dojo.dom.PROCESSING_INSTRUCTION_NODE: // processing instruction node... not meaningful here
+					break;
+				case  dojo.dom.COMMENT_NODE: // comment node... not not sure if this would ever be meaningful 
+					break;
+				case  dojo.dom.DOCUMENT_NODE: // document node... not sure if this would ever be meaningful
+					break;
+				case  dojo.dom.DOCUMENT_TYPE_NODE: // document type node... not meaningful here
+					break;
+				case  dojo.dom.DOCUMENT_FRAGMENT_NODE: // document fragment node... not meaningful here
+					break;
+				case  dojo.dom.NOTATION_NODE:// notation node... not meaningful here
+					break;
+				*/
 			}
 		}
+		//return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;
 		return parsedNodeSet;
-	};
-	this.parseAttributes = function (node) {
+	}
+
+	/* parses a set of attributes on a node into an object tree */
+	function parseAttributes(node) {
+		// TODO: make this namespace aware
 		var parsedAttributeSet = {};
 		var atts = node.attributes;
-		var attnode, i = 0;
-		while ((attnode = atts[i++])) {
-			if (isIE) {
-				if (!attnode) {
-					continue;
+		// TODO: should we allow for duplicate attributes at this point...
+		// would any of the relevant dom implementations even allow this?
+		var attnode, i=0;
+		while(attnode=atts[i++]) {
+			if((dojo.render.html.capable)&&(dojo.render.html.ie)){
+				if(!attnode){ continue; }
+				if(	(typeof attnode == "object")&&
+					(typeof attnode.nodeValue == 'undefined')||
+					(attnode.nodeValue == null)||
+					(attnode.nodeValue == '')){ 
+					continue; 
 				}
-				if ((typeof attnode == "object") && (typeof attnode.nodeValue == "undefined") || (attnode.nodeValue == null) || (attnode.nodeValue == "")) {
-					continue;
-				}
 			}
-			var nn = attnode.nodeName.split(":");
-			nn = (nn.length == 2) ? nn[1] : attnode.nodeName;
-			parsedAttributeSet[nn] = {value:attnode.nodeValue};
+			var nn = (attnode.nodeName.indexOf("dojo:") == -1) ? attnode.nodeName : attnode.nodeName.split("dojo:")[1];
+			parsedAttributeSet[nn] = { 
+				value: attnode.nodeValue 
+			};
 		}
 		return parsedAttributeSet;
-	};
-};
-
+	}
+}

Deleted: tags/parley-0.53/root/static/magic/src/xml/XslTransform.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/xml/XslTransform.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/xml/XslTransform.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,159 +0,0 @@
-/*
-	Copyright (c) 2004-2006, The Dojo Foundation
-	All Rights Reserved.
-
-	Licensed under the Academic Free License version 2.1 or above OR the
-	modified BSD license. For more information on Dojo licensing, see:
-
-		http://dojotoolkit.org/community/licensing.shtml
-*/
-
-
-
-dojo.provide("dojo.xml.XslTransform");
-dojo.xml.XslTransform = function (xsltUri) {
-	dojo.debug("XslTransform is supported by Internet Explorer and Mozilla, with limited support in Opera 9 (no document function support).");
-	var IS_IE = dojo.render.html.ie;
-	var ACTIVEX_DOMS = ["Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "Msxml2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"];
-	var ACTIVEX_FT_DOMS = ["Msxml2.FreeThreadedDOMDocument.5.0", "MSXML2.FreeThreadedDOMDocument.4.0", "MSXML2.FreeThreadedDOMDocument.3.0"];
-	var ACTIVEX_TEMPLATES = ["Msxml2.XSLTemplate.5.0", "Msxml2.XSLTemplate.4.0", "MSXML2.XSLTemplate.3.0"];
-	function getActiveXImpl(activeXArray) {
-		for (var i = 0; i < activeXArray.length; i++) {
-			try {
-				var testObj = new ActiveXObject(activeXArray[i]);
-				if (testObj) {
-					return activeXArray[i];
-				}
-			}
-			catch (e) {
-			}
-		}
-		dojo.raise("Could not find an ActiveX implementation in:\n\n " + activeXArray);
-	}
-	if (xsltUri == null || xsltUri == undefined) {
-		dojo.raise("You must pass the URI String for the XSL file to be used!");
-		return false;
-	}
-	var xsltDocument = null;
-	var xsltProcessor = null;
-	if (IS_IE) {
-		xsltDocument = new ActiveXObject(getActiveXImpl(ACTIVEX_FT_DOMS));
-		xsltDocument.async = false;
-	} else {
-		xsltProcessor = new XSLTProcessor();
-		xsltDocument = document.implementation.createDocument("", "", null);
-		xsltDocument.addEventListener("load", onXslLoad, false);
-	}
-	xsltDocument.load(xsltUri);
-	if (IS_IE) {
-		var xslt = new ActiveXObject(getActiveXImpl(ACTIVEX_TEMPLATES));
-		xslt.stylesheet = xsltDocument;
-		xsltProcessor = xslt.createProcessor();
-	}
-	function onXslLoad() {
-		xsltProcessor.importStylesheet(xsltDocument);
-	}
-	function getResultDom(xmlDoc, params) {
-		if (IS_IE) {
-			addIeParams(params);
-			var result = getIeResultDom(xmlDoc);
-			removeIeParams(params);
-			return result;
-		} else {
-			return getMozillaResultDom(xmlDoc, params);
-		}
-	}
-	function addIeParams(params) {
-		if (!params) {
-			return;
-		}
-		for (var i = 0; i < params.length; i++) {
-			xsltProcessor.addParameter(params[i][0], params[i][1]);
-		}
-	}
-	function removeIeParams(params) {
-		if (!params) {
-			return;
-		}
-		for (var i = 0; i < params.length; i++) {
-			xsltProcessor.addParameter(params[i][0], "");
-		}
-	}
-	function getIeResultDom(xmlDoc) {
-		xsltProcessor.input = xmlDoc;
-		var outDoc = new ActiveXObject(getActiveXImpl(ACTIVEX_DOMS));
-		outDoc.async = false;
-		outDoc.validateOnParse = false;
-		xsltProcessor.output = outDoc;
-		xsltProcessor.transform();
-		if (outDoc.parseError.errorCode != 0) {
-			var err = outDoc.parseError;
-			dojo.raise("err.errorCode: " + err.errorCode + "\n\nerr.reason: " + err.reason + "\n\nerr.url: " + err.url + "\n\nerr.srcText: " + err.srcText);
-		}
-		return outDoc;
-	}
-	function getIeResultStr(xmlDoc, params) {
-		xsltProcessor.input = xmlDoc;
-		xsltProcessor.transform();
-		return xsltProcessor.output;
-	}
-	function addMozillaParams(params) {
-		if (!params) {
-			return;
-		}
-		for (var i = 0; i < params.length; i++) {
-			xsltProcessor.setParameter(null, params[i][0], params[i][1]);
-		}
-	}
-	function getMozillaResultDom(xmlDoc, params) {
-		addMozillaParams(params);
-		var resultDoc = xsltProcessor.transformToDocument(xmlDoc);
-		xsltProcessor.clearParameters();
-		return resultDoc;
-	}
-	function getMozillaResultStr(xmlDoc, params, parentDoc) {
-		addMozillaParams(params);
-		var resultDoc = xsltProcessor.transformToFragment(xmlDoc, parentDoc);
-		var serializer = new XMLSerializer();
-		xsltProcessor.clearParameters();
-		return serializer.serializeToString(resultDoc);
-	}
-	this.getResultString = function (xmlDoc, params, parentDoc) {
-		var content = null;
-		if (IS_IE) {
-			addIeParams(params);
-			content = getIeResultStr(xmlDoc, params);
-			removeIeParams(params);
-		} else {
-			content = getMozillaResultStr(xmlDoc, params, parentDoc);
-		}
-		return content;
-	};
-	this.transformToContentPane = function (xmlDoc, params, contentPane, parentDoc) {
-		var content = this.getResultString(xmlDoc, params, parentDoc);
-		contentPane.setContent(content);
-	};
-	this.transformToRegion = function (xmlDoc, params, region, parentDoc) {
-		try {
-			var content = this.getResultString(xmlDoc, params, parentDoc);
-			region.innerHTML = content;
-		}
-		catch (e) {
-			dojo.raise(e.message + "\n\n xsltUri: " + xsltUri);
-		}
-	};
-	this.transformToDocument = function (xmlDoc, params) {
-		return getResultDom(xmlDoc, params);
-	};
-	this.transformToWindow = function (xmlDoc, params, windowDoc, parentDoc) {
-		try {
-			windowDoc.open();
-			windowDoc.write(this.getResultString(xmlDoc, params, parentDoc));
-			windowDoc.close();
-		}
-		catch (e) {
-			dojo.raise(e.message + "\n\n xsltUri: " + xsltUri);
-		}
-	};
-};
-

Modified: tags/parley-0.53/root/static/magic/src/xml/__package__.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/xml/__package__.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/xml/__package__.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -8,9 +8,11 @@
 		http://dojotoolkit.org/community/licensing.shtml
 */
 
-
-
 dojo.require("dojo.xml.Parse");
-dojo.kwCompoundRequire({common:["dojo.dom"], browser:["dojo.html.*"], dashboard:["dojo.html.*"]});
+dojo.kwCompoundRequire({
+	common:		["dojo.xml.domUtil"],
+    browser: 	["dojo.xml.htmlUtil"],
+    dashboard: 	["dojo.xml.htmlUtil"],
+    svg: 		["dojo.xml.svgUtil"]
+});
 dojo.provide("dojo.xml.*");
-

Added: tags/parley-0.53/root/static/magic/src/xml/domUtil.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/xml/domUtil.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/xml/domUtil.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,84 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.xml.domUtil");
+dojo.require("dojo.graphics.color");
+dojo.require("dojo.dom");
+dojo.require("dojo.style");
+
+dojo.deprecated("dojo.xml.domUtil", "use dojo.dom instead", "0.4");
+
+// for loading script:
+dojo.xml.domUtil = new function(){
+	this.nodeTypes = {
+		ELEMENT_NODE                  : 1,
+		ATTRIBUTE_NODE                : 2,
+		TEXT_NODE                     : 3,
+		CDATA_SECTION_NODE            : 4,
+		ENTITY_REFERENCE_NODE         : 5,
+		ENTITY_NODE                   : 6,
+		PROCESSING_INSTRUCTION_NODE   : 7,
+		COMMENT_NODE                  : 8,
+		DOCUMENT_NODE                 : 9,
+		DOCUMENT_TYPE_NODE            : 10,
+		DOCUMENT_FRAGMENT_NODE        : 11,
+		NOTATION_NODE                 : 12
+	}
+	
+	this.dojoml = "http://www.dojotoolkit.org/2004/dojoml";
+	this.idIncrement = 0;
+	
+	this.getTagName = function(){return dojo.dom.getTagName.apply(dojo.dom, arguments);}
+	this.getUniqueId = function(){return dojo.dom.getUniqueId.apply(dojo.dom, arguments);}
+	this.getFirstChildTag = function() {return dojo.dom.getFirstChildElement.apply(dojo.dom, arguments);}
+	this.getLastChildTag = function() {return dojo.dom.getLastChildElement.apply(dojo.dom, arguments);}
+	this.getNextSiblingTag = function() {return dojo.dom.getNextSiblingElement.apply(dojo.dom, arguments);}
+	this.getPreviousSiblingTag = function() {return dojo.dom.getPreviousSiblingElement.apply(dojo.dom, arguments);}
+
+	this.forEachChildTag = function(node, unaryFunc) {
+		var child = this.getFirstChildTag(node);
+		while(child) {
+			if(unaryFunc(child) == "break") { break; }
+			child = this.getNextSiblingTag(child);
+		}
+	}
+
+	this.moveChildren = function() {return dojo.dom.moveChildren.apply(dojo.dom, arguments);}
+	this.copyChildren = function() {return dojo.dom.copyChildren.apply(dojo.dom, arguments);}
+	this.clearChildren = function() {return dojo.dom.removeChildren.apply(dojo.dom, arguments);}
+	this.replaceChildren = function() {return dojo.dom.replaceChildren.apply(dojo.dom, arguments);}
+
+	this.getStyle = function() {return dojo.style.getStyle.apply(dojo.style, arguments);}
+	this.toCamelCase = function() {return dojo.style.toCamelCase.apply(dojo.style, arguments);}
+	this.toSelectorCase = function() {return dojo.style.toSelectorCase.apply(dojo.style, arguments);}
+
+	this.getAncestors = function(){return dojo.dom.getAncestors.apply(dojo.dom, arguments);}
+	this.isChildOf = function() {return dojo.dom.isDescendantOf.apply(dojo.dom, arguments);}
+	this.createDocumentFromText = function() {return dojo.dom.createDocumentFromText.apply(dojo.dom, arguments);}
+
+	if(dojo.render.html.capable || dojo.render.svg.capable) {
+		this.createNodesFromText = function(txt, wrap){return dojo.dom.createNodesFromText.apply(dojo.dom, arguments);}
+	}
+
+	this.extractRGB = function(color) { return dojo.graphics.color.extractRGB(color); }
+	this.hex2rgb = function(hex) { return dojo.graphics.color.hex2rgb(hex); }
+	this.rgb2hex = function(r, g, b) { return dojo.graphics.color.rgb2hex(r, g, b); }
+
+	this.insertBefore = function() {return dojo.dom.insertBefore.apply(dojo.dom, arguments);}
+	this.before = this.insertBefore;
+	this.insertAfter = function() {return dojo.dom.insertAfter.apply(dojo.dom, arguments);}
+	this.after = this.insertAfter
+	this.insert = function(){return dojo.dom.insertAtPosition.apply(dojo.dom, arguments);}
+	this.insertAtIndex = function(){return dojo.dom.insertAtIndex.apply(dojo.dom, arguments);}
+	this.textContent = function () {return dojo.dom.textContent.apply(dojo.dom, arguments);}
+	this.renderedTextContent = function () {return dojo.dom.renderedTextContent.apply(dojo.dom, arguments);}
+	this.remove = function (node) {return dojo.dom.removeNode.apply(dojo.dom, arguments);}
+}
+

Added: tags/parley-0.53/root/static/magic/src/xml/htmlUtil.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/xml/htmlUtil.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/xml/htmlUtil.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,121 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.xml.htmlUtil");
+dojo.require("dojo.html");
+dojo.require("dojo.style");
+dojo.require("dojo.dom");
+
+dojo.deprecated("dojo.xml.htmlUtil", "use dojo.html instead", "0.4");
+
+dojo.xml.htmlUtil = new function(){
+	this.styleSheet = dojo.style.styleSheet;
+	
+	this._clobberSelection = function(){return dojo.html.clearSelection.apply(dojo.html, arguments);}
+	this.disableSelect = function(){return dojo.html.disableSelection.apply(dojo.html, arguments);}
+	this.enableSelect = function(){return dojo.html.enableSelection.apply(dojo.html, arguments);}
+	
+	this.getInnerWidth = function(){return dojo.style.getInnerWidth.apply(dojo.style, arguments);}
+	
+	this.getOuterWidth = function(node){
+		dojo.unimplemented("dojo.xml.htmlUtil.getOuterWidth");
+	}
+
+	this.getInnerHeight = function(){return dojo.style.getInnerHeight.apply(dojo.style, arguments);}
+
+	this.getOuterHeight = function(node){
+		dojo.unimplemented("dojo.xml.htmlUtil.getOuterHeight");
+	}
+
+	this.getTotalOffset = function(){return dojo.style.getTotalOffset.apply(dojo.style, arguments);}
+	this.totalOffsetLeft = function(){return dojo.style.totalOffsetLeft.apply(dojo.style, arguments);}
+
+	this.getAbsoluteX = this.totalOffsetLeft;
+
+	this.totalOffsetTop = function(){return dojo.style.totalOffsetTop.apply(dojo.style, arguments);}
+	
+	this.getAbsoluteY = this.totalOffsetTop;
+
+	this.getEventTarget = function(){return dojo.html.getEventTarget.apply(dojo.html, arguments);}
+	this.getScrollTop = function() {return dojo.html.getScrollTop.apply(dojo.html, arguments);}
+	this.getScrollLeft = function() {return dojo.html.getScrollLeft.apply(dojo.html, arguments);}
+
+	this.evtTgt = this.getEventTarget;
+
+	this.getParentOfType = function(){return dojo.html.getParentOfType.apply(dojo.html, arguments);}
+	this.getAttribute = function(){return dojo.html.getAttribute.apply(dojo.html, arguments);}
+	this.getAttr = function (node, attr) { // for backwards compat (may disappear!!!)
+		dojo.deprecated("dojo.xml.htmlUtil.getAttr", "use dojo.xml.htmlUtil.getAttribute instead", "0.4");
+		return dojo.xml.htmlUtil.getAttribute(node, attr);
+	}
+	this.hasAttribute = function(){return dojo.html.hasAttribute.apply(dojo.html, arguments);}
+
+	this.hasAttr = function (node, attr) { // for backwards compat (may disappear!!!)
+		dojo.deprecated("dojo.xml.htmlUtil.hasAttr", "use dojo.xml.htmlUtil.hasAttribute instead", "0.4");
+		return dojo.xml.htmlUtil.hasAttribute(node, attr);
+	}
+	
+	this.getClass = function(){return dojo.html.getClass.apply(dojo.html, arguments)}
+	this.hasClass = function(){return dojo.html.hasClass.apply(dojo.html, arguments)}
+	this.prependClass = function(){return dojo.html.prependClass.apply(dojo.html, arguments)}
+	this.addClass = function(){return dojo.html.addClass.apply(dojo.html, arguments)}
+	this.setClass = function(){return dojo.html.setClass.apply(dojo.html, arguments)}
+	this.removeClass = function(){return dojo.html.removeClass.apply(dojo.html, arguments)}
+
+	// Enum type for getElementsByClass classMatchType arg:
+	this.classMatchType = {
+		ContainsAll : 0, // all of the classes are part of the node's class (default)
+		ContainsAny : 1, // any of the classes are part of the node's class
+		IsOnly : 2 // only all of the classes are part of the node's class
+	}
+
+	this.getElementsByClass = function() {return dojo.html.getElementsByClass.apply(dojo.html, arguments)}
+	this.getElementsByClassName = this.getElementsByClass;
+	
+	this.setOpacity = function() {return dojo.style.setOpacity.apply(dojo.style, arguments)}
+	this.getOpacity = function() {return dojo.style.getOpacity.apply(dojo.style, arguments)}
+	this.clearOpacity = function() {return dojo.style.clearOpacity.apply(dojo.style, arguments)}
+	
+	this.gravity = function(){return dojo.html.gravity.apply(dojo.html, arguments)}
+	
+	this.gravity.NORTH = 1;
+	this.gravity.SOUTH = 1 << 1;
+	this.gravity.EAST = 1 << 2;
+	this.gravity.WEST = 1 << 3;
+	
+	this.overElement = function(){return dojo.html.overElement.apply(dojo.html, arguments)}
+
+	this.insertCssRule = function(){return dojo.style.insertCssRule.apply(dojo.style, arguments)}
+	
+	this.insertCSSRule = function(selector, declaration, index){
+		dojo.deprecated("dojo.xml.htmlUtil.insertCSSRule", "use dojo.style.insertCssRule instead", "0.4");
+		return dojo.xml.htmlUtil.insertCssRule(selector, declaration, index);
+	}
+	
+	this.removeCssRule = function(){return dojo.style.removeCssRule.apply(dojo.style, arguments)}
+
+	this.removeCSSRule = function(index){
+		dojo.deprecated("dojo.xml.htmlUtil.removeCSSRule", "use dojo.xml.htmlUtil.removeCssRule instead", "0.4");
+		return dojo.xml.htmlUtil.removeCssRule(index);
+	}
+
+	this.insertCssFile = function(){return dojo.style.insertCssFile.apply(dojo.style, arguments)}
+
+	this.insertCSSFile = function(URI, doc, checkDuplicates){
+		dojo.deprecated("dojo.xml.htmlUtil.insertCSSFile", "use dojo.xml.htmlUtil.insertCssFile instead", "0.4");
+		return dojo.xml.htmlUtil.insertCssFile(URI, doc, checkDuplicates);
+	}
+
+	this.getBackgroundColor = function() {return dojo.style.getBackgroundColor.apply(dojo.style, arguments)}
+
+	this.getUniqueId = function() { return dojo.dom.getUniqueId(); }
+
+	this.getStyle = function() {return dojo.style.getStyle.apply(dojo.style, arguments)}
+}

Added: tags/parley-0.53/root/static/magic/src/xml/svgUtil.js
===================================================================
--- tags/parley-0.53/root/static/magic/src/xml/svgUtil.js	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/root/static/magic/src/xml/svgUtil.js	2008-10-08 11:42:12 UTC (rev 952)
@@ -0,0 +1,32 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		http://dojotoolkit.org/community/licensing.shtml
+*/
+
+dojo.provide("dojo.xml.svgUtil");
+// FIXME: add imports for deps!
+
+dojo.xml.svgUtil = new function(){
+
+	this.getInnerWidth = function(node){
+		// FIXME: need to find out from dylan how to 
+	}
+
+	this.getOuterWidth = function(node){
+		
+	}
+
+	this.getInnerHeight = function(node){
+		
+	}
+
+	this.getOuterHeight = function(node){
+		
+	}
+
+}

Modified: tags/parley-0.53/script/parley_fastcgi.pl
===================================================================
--- tags/parley-0.53/script/parley_fastcgi.pl	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/script/parley_fastcgi.pl	2008-10-08 11:42:12 UTC (rev 952)
@@ -11,7 +11,7 @@
 use Parley;
 
 my $help = 0;
-my ( $listen, $nproc, $pidfile, $manager, $detach, $keep_stderr );
+my ( $listen, $nproc, $pidfile, $manager, $detach );
  
 GetOptions(
     'help|?'      => \$help,
@@ -20,7 +20,6 @@
     'pidfile|p=s' => \$pidfile,
     'manager|M=s' => \$manager,
     'daemon|d'    => \$detach,
-    'keeperr|e'   => \$keep_stderr,
 );
 
 pod2usage(1) if $help;
@@ -31,7 +30,6 @@
         pidfile => $pidfile, 
         manager => $manager,
         detach  => $detach,
-	keep_stderr => $keep_stderr,
     }
 );
 
@@ -60,8 +58,6 @@
    -M -manager   specify alternate process manager
                  (FCGI::ProcManager sub-class)
                  or empty string to disable
-   -e -keeperr   send error messages to STDOUT, not
-                 to the webserver
 
 =head1 DESCRIPTION
 

Modified: tags/parley-0.53/script/parley_server.pl
===================================================================
--- tags/parley-0.53/script/parley_server.pl	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/script/parley_server.pl	2008-10-08 11:42:12 UTC (rev 952)
@@ -17,12 +17,13 @@
 my $fork              = 0;
 my $help              = 0;
 my $host              = undef;
-my $port              = 3000;
+my $port              = $ENV{PARLEY_PORT} || $ENV{CATALYST_PORT} || 3000;
 my $keepalive         = 0;
-my $restart           = 0;
+my $restart           = $ENV{PARLEY_RELOAD} || $ENV{CATALYST_RELOAD} || 0;
 my $restart_delay     = 1;
-my $restart_regex     = '\.yml$|\.yaml$|\.pm$';
+my $restart_regex     = '(?:/|^)(?!\.#).+(?:\.yml$|\.yaml$|\.conf|\.pm)$';
 my $restart_directory = undef;
+my $follow_symlinks   = 0;
 
 my @argv = @ARGV;
 
@@ -36,12 +37,13 @@
     'restart|r'           => \$restart,
     'restartdelay|rd=s'   => \$restart_delay,
     'restartregex|rr=s'   => \$restart_regex,
-    'restartdirectory=s'  => \$restart_directory,
+    'restartdirectory=s@' => \$restart_directory,
+    'followsymlinks'      => \$follow_symlinks,
 );
 
 pod2usage(1) if $help;
 
-if ( $restart ) {
+if ( $restart && $ENV{CATALYST_ENGINE} eq 'HTTP' ) {
     $ENV{CATALYST_ENGINE} = 'HTTP::Restarter';
 }
 if ( $debug ) {
@@ -60,6 +62,7 @@
     restart_delay     => $restart_delay,
     restart_regex     => qr/$restart_regex/,
     restart_directory => $restart_directory,
+    follow_symlinks   => $follow_symlinks,
 } );
 
 1;
@@ -85,11 +88,12 @@
    -rd -restartdelay  delay between file checks
    -rr -restartregex  regex match files that trigger
                       a restart when modified
-                      (defaults to '\.yml$|\.yaml$|\.pm$')
+                      (defaults to '\.yml$|\.yaml$|\.conf|\.pm$')
    -restartdirectory  the directory to search for
-                      modified files
-                      (defaults to '../')
-
+                      modified files, can be set mulitple times
+                      (defaults to '[SCRIPT_DIR]/..')
+   -follow_symlinks   follow symlinks in search directories
+                      (defaults to false. this is a no-op on Win32)
  See also:
    perldoc Catalyst::Manual
    perldoc Catalyst::Manual::Intro

Modified: tags/parley-0.53/script/time_string_sample.pl
===================================================================
--- tags/parley-0.53/script/time_string_sample.pl	2008-10-08 11:17:38 UTC (rev 951)
+++ tags/parley-0.53/script/time_string_sample.pl	2008-10-08 11:42:12 UTC (rev 952)
@@ -1,7 +1,6 @@
 #!/usr/bin/perl
 use strict;
 use warnings;
-use DateTime;
 
 use POSIX 'strftime';
 
@@ -11,17 +10,8 @@
     q{%c},
     q{%A at %R},
     q{%a, %d %b; %R},
-
-    q{%R, %b %d},
-    q{%R, %b %d '%y},
-    q{%R, %b %d %Y},
 );
 
 foreach my $tf (@time_formats) {
-    my $dt = DateTime->now();
-    print $dt->strftime( $tf ), qq{\n};
-
     printf(qq{INSERT INTO preference_time_string (time_string, sample) VALUES ('%s', '%s');\n}, $tf, strftime($tf, 0, 15, 18, 13, 6, 106));
-
-    print qq{\n};
 }



From chiselwright at mail.berlios.de  Thu Oct  9 15:59:58 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Thu, 9 Oct 2008 15:59:58 +0200
Subject: [Parley-svn] r953 - / trunk/root/static trunk/t
Message-ID: <200810091359.m99DxwcC030732@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-09 15:59:58 +0200 (Thu, 09 Oct 2008)
New Revision: 953

Modified:
   /
   trunk/root/static/MessagePreview-min.js
   trunk/root/static/MessagePreview.js
   trunk/t/04_forumcode.t
Log:
 r8271 at wiggin:  chisel | 2008-10-08 19:21:18 +0100
 + added ForumCode test for string containing '+'
 + added MessagePreview fix for messages containing '+' symbols (vanish in preview, and re-appear in post)



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8204
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8271
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/root/static/MessagePreview-min.js
===================================================================
--- trunk/root/static/MessagePreview-min.js	2008-10-08 11:42:12 UTC (rev 952)
+++ trunk/root/static/MessagePreview-min.js	2008-10-09 13:59:58 UTC (rev 953)
@@ -1 +1 @@
-(function(){ParleyMessagePreview=function(){var Dom=YAHOO.util.Dom,YU=YAHOO.util;this.config={trigger:"message_preview",user_input:"thread_message",container:"message_container",trigger_evt:"click",post_url:"post/preview",label_edit:"Edit",label_preview:"Preview"};this.message_source=false;this.message_preview=false;this.handleSuccess=function(o){var data=eval("("+o.responseText+")");var obj=o.argument.obj;if(data.formatted){obj.previewElId=YU.Dom.generateId();obj.user_input.style.visibility="hidden";var pWidth=obj.user_input.clientWidth,pHeight=obj.user_input.clientHeight,pLeft=obj.user_input.offsetLeft,pTop=obj.user_input.offsetTop;obj.preview_overlay=new YAHOO.widget.Overlay("preview_overlay",{context:[obj.config.user_input,"tl","tl"],visible:true,width:obj.user_input.clientWidth+"px",height:obj.user_input.clientHeight+"px"});obj.preview_overlay.setBody(data.formatted);obj.preview_overlay.render(document.body);Dom.get("preview_overlay").style.overflow="auto";obj.trigger.!
 value=obj.config.label_edit;YU.Event.removeListener(obj.trigger,"click");YU.Event.addListener(obj.trigger,obj.config.trigger_evt,obj.edit,obj,true)}};this.handleFailure=function(o){console.log("failure")};this.edit=function(){this.trigger.value=this.config.label_preview;this.user_input.style.visibility="visible";this.preview_overlay.destroy();YU.Event.removeListener(this.trigger,"click");YU.Event.addListener(this.trigger,this.config.trigger_evt,this.preview,this,true)};this.preview=function(){var request=YU.Connect.asyncRequest("POST",this.config.post_url,{success:this.handleSuccess,failure:this.handleFailure,argument:{obj:this}},"msg_source="+escape(this.user_input.value))};this.init=function(){this.container=Dom.get(this.config.container);this.user_input=Dom.get(this.config.user_input);this.trigger=Dom.get(this.config.trigger);YU.Event.addListener(this.trigger,this.config.trigger_evt,this.preview,this,true)}}})();
\ No newline at end of file
+(function(){ParleyMessagePreview=function(){var Dom=YAHOO.util.Dom,YU=YAHOO.util;this.config={trigger:"message_preview",user_input:"thread_message",container:"message_container",trigger_evt:"click",post_url:"post/preview",label_edit:"Edit",label_preview:"Preview"};this.message_source=false;this.message_preview=false;this.handleSuccess=function(o){var data=eval("("+o.responseText+")");var obj=o.argument.obj;if(data.formatted){obj.previewElId=YU.Dom.generateId();obj.user_input.style.visibility="hidden";var pWidth=obj.user_input.clientWidth,pHeight=obj.user_input.clientHeight,pLeft=obj.user_input.offsetLeft,pTop=obj.user_input.offsetTop;obj.preview_overlay=new YAHOO.widget.Overlay("preview_overlay",{context:[obj.config.user_input,"tl","tl"],visible:true,width:obj.user_input.clientWidth+"px",height:obj.user_input.clientHeight+"px"});obj.preview_overlay.setBody(data.formatted);obj.preview_overlay.render(document.body);Dom.get("preview_overlay").style.overflow="auto";obj.trigger.!
 value=obj.config.label_edit;YU.Event.removeListener(obj.trigger,"click");YU.Event.addListener(obj.trigger,obj.config.trigger_evt,obj.edit,obj,true)}};this.handleFailure=function(o){console.log("failure")};this.edit=function(){this.trigger.value=this.config.label_preview;this.user_input.style.visibility="visible";this.preview_overlay.destroy();YU.Event.removeListener(this.trigger,"click");YU.Event.addListener(this.trigger,this.config.trigger_evt,this.preview,this,true)};this.preview=function(){var msgSource=escape(this.user_input.value);msgSource=msgSource.replace(/\+/g,"%2b");var request=YU.Connect.asyncRequest("POST",this.config.post_url,{success:this.handleSuccess,failure:this.handleFailure,argument:{obj:this}},"msg_source="+msgSource)};this.init=function(){this.container=Dom.get(this.config.container);this.user_input=Dom.get(this.config.user_input);this.trigger=Dom.get(this.config.trigger);YU.Event.addListener(this.trigger,this.config.trigger_evt,this.preview,this,true)}!
 }})();
\ No newline at end of file

Modified: trunk/root/static/MessagePreview.js
===================================================================
--- trunk/root/static/MessagePreview.js	2008-10-08 11:42:12 UTC (rev 952)
+++ trunk/root/static/MessagePreview.js	2008-10-09 13:59:58 UTC (rev 953)
@@ -114,6 +114,11 @@
         };
 
         this.preview = function() {
+            /* we need to escape the string */
+            /* we also need to (separately) escape '+' during submission */
+            var msgSource = escape(this.user_input.value);
+            msgSource = msgSource.replace(/\+/g, '%2b');
+
             var request = YU.Connect.asyncRequest(
                 'POST',
                 this.config.post_url, //'post/preview',
@@ -124,7 +129,7 @@
                         obj: this
                     }
                 },
-                'msg_source=' + escape(this.user_input.value)
+                'msg_source=' + msgSource
             );
         };
 

Modified: trunk/t/04_forumcode.t
===================================================================
--- trunk/t/04_forumcode.t	2008-10-08 11:42:12 UTC (rev 952)
+++ trunk/t/04_forumcode.t	2008-10-09 13:59:58 UTC (rev 953)
@@ -16,6 +16,10 @@
             in  => '#FF0000',
             out => '#FF0000',
         },
+        {
+            in  => '1 + 2',
+            out => '1 + 2',
+        },
 
         ## BOLD
         # [b] tag



From chiselwright at mail.berlios.de  Thu Oct  9 16:00:14 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Thu, 9 Oct 2008 16:00:14 +0200
Subject: [Parley-svn] r954 - / trunk
Message-ID: <200810091400.m99E0ESV031002@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-09 16:00:13 +0200 (Thu, 09 Oct 2008)
New Revision: 954

Modified:
   /
   trunk/Makefile.PL
   trunk/TODO
Log:
 r8272 at wiggin:  chisel | 2008-10-08 19:21:49 +0100
 + added current version numbers to Makefile.PL dependencies
 + updated ToDo list



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8271
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8272
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Makefile.PL
===================================================================
--- trunk/Makefile.PL	2008-10-09 13:59:58 UTC (rev 953)
+++ trunk/Makefile.PL	2008-10-09 14:00:13 UTC (rev 954)
@@ -11,45 +11,45 @@
 version         ('1.0.2');
 
 requires(
-    'Catalyst'                                                  => '5.008001',
-    'Catalyst::Runtime'                                         => 0,
-    'Catalyst::Action::RenderView'                              => 0,
+    'Catalyst'                                                  => '5.7014',
+    'Catalyst::Runtime'                                         => '5.7014',
+    'Catalyst::Action::RenderView'                              => '0.08',
     'Catalyst::Authentication::Store::DBIx::Class'              => '0.10',
-    'Catalyst::Model::DBIC::Schema'                             => 0,
-    'Catalyst::Plugin::Authorization::ACL'                      => 0,
-    'Catalyst::Plugin::Authorization::Roles'                    => 0,
-    'Catalyst::Plugin::ConfigLoader'                            => 0,
-    'Catalyst::Plugin::Email'                                   => 0,
-    'Catalyst::Plugin::FillInForm'                              => 0,
-    'Catalyst::Plugin::FormValidator'                           => 0,
-    'Catalyst::Plugin::I18N'                                    => 0,
-    'Catalyst::Plugin::Session'                                 => 0,
-    'Catalyst::Plugin::Session::State::Cookie'                  => 0,
-    'Cache::FastMmap'                                           => 0,
-    'Catalyst::Plugin::Session::Store::FastMmap'                => 0,
-    'Catalyst::Plugin::StackTrace'                              => 0,
-    'Catalyst::Plugin::Static::Simple'                          => 0,
-    'Catalyst::View::TT'                                        => 0,
-    'Config::General'                                           => 2.37,
+    'Catalyst::Model::DBIC::Schema'                             => '0.20',
+    'Catalyst::Plugin::Authorization::ACL'                      => '0.08',
+    'Catalyst::Plugin::Authorization::Roles'                    => '0.05',
+    'Catalyst::Plugin::ConfigLoader'                            => '0.20',
+    'Catalyst::Plugin::Email'                                   => '0.08',
+    'Catalyst::Plugin::FillInForm'                              => '0.09',
+    'Catalyst::Plugin::FormValidator'                           => '0.02',
+    'Catalyst::Plugin::I18N'                                    => '0.07',
+    'Catalyst::Plugin::Session'                                 => '0.19',
+    'Catalyst::Plugin::Session::State::Cookie'                  => '0.09',
+    'Cache::FastMmap'                                           => '1.24',
+    'Catalyst::Plugin::Session::Store::FastMmap'                => '0.05',
+    'Catalyst::Plugin::StackTrace'                              => '0.08',
+    'Catalyst::Plugin::Static::Simple'                          => '0.20',
+    'Catalyst::View::TT'                                        => '0.27',
+    'Config::General'                                           => '2.37',
     'Data::FormValidator'                                       => '4.50',
-    'Data::SpreadPagination'                                    => 0,
-    'DateTime'                                                  => 0,
-    'DateTime::Format::Pg'                                      => 0,
-    'DateTime::TimeZone'                                        => 0,
-    'Email::Valid'                                              => 0,
+    'Data::SpreadPagination'                                    => '0.1.2',
+    'DateTime'                                                  => '0.41',
+    'DateTime::Format::Pg'                                      => '0.16001',
+    'DateTime::TimeZone'                                        => '0.70',
+    'Email::Valid'                                              => '0.179',
     'Image::Magick'                                             => 0,
     'HTML::FillInForm'                                          => '1.07',
-    'Image::Size'                                               => 0,
+    'Image::Size'                                               => '3.1',
     'JSON'                                                      => '2.04',
-    'List::MoreUtils'                                           => 0,
-    'MIME::Lite'                                                => 0,
-    'Net::IP::Match::Regexp'                                    => 0,
-    'Perl6::Export::Attrs'                                      => 0,
-    'Proc::Daemon'                                              => 0,
-    'Proc::PID::File'                                           => 0,
+    'List::MoreUtils'                                           => '0.21',
+    'MIME::Lite'                                                => '3.020',
+    'Net::IP::Match::Regexp'                                    => '1.00',
+    'Perl6::Export::Attrs'                                      => '0.0.3',
+    'Proc::Daemon'                                              => '0.03',
+    'Proc::PID::File'                                           => '1.2.4',
     'Readonly'                                                  => 0,
-    'Text::Context::EitherSide'                                 => 0,
-    'Time::Piece'                                               => 0,
+    'Text::Context::EitherSide'                                 => '1.3',
+    'Time::Piece'                                               => '1.11',
 );
 
 build_requires (

Modified: trunk/TODO
===================================================================
--- trunk/TODO	2008-10-09 13:59:58 UTC (rev 953)
+++ trunk/TODO	2008-10-09 14:00:13 UTC (rev 954)
@@ -1,9 +1,12 @@
 TODO LIST
 
+  - local file permissions (for avatar uploads)
+  - optional ReCAPTCHA during sign-up
+  - optional google ads
+  - optional google analytics
   - 11:58 <marcus> btw did you consider packing the css and js to reduce the number of includes?
     http://search.cpan.org/~pmichaux/JavaScript-Minifier-1.05/lib/JavaScript/Minifier.pm
     http://search.cpan.org/~pmichaux/CSS-Minifier-0.01/lib/CSS/Minifier.pm
-  - setup guide; add mailing list details
   - Gravatar?
   - OpenID?
   - User Profile --> User Roles (for admins)
@@ -11,7 +14,6 @@
   - forumcode "quickhelp" in posting screen(s)
   - "Cancel" from post/edit
   - "Cancel" from thread/reply
-  - fix <ul>/<ol> CSS
   - Quick Reply
   - login form doesn't submit onEnter
   - TESTS, TESTS, TESTS!
@@ -35,6 +37,8 @@
   - investigate: package Your::Schema; sub connect { do the check; next::method }
   - investigate: DBIx::Class::Schema::Versioned
   - investigate: t/model_Post.t / distinct count
+D - fix <ul>/<ol> CSS
+D - setup guide; add mailing list details
 D - get latest i18n from DJ
 D - Parley::Version (a la SVK)
 D - login form flickers on IE7 page load



From chiselwright at mail.berlios.de  Thu Oct  9 16:00:30 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Thu, 9 Oct 2008 16:00:30 +0200
Subject: [Parley-svn] r955 - / trunk/lib/Parley/Controller/User
Message-ID: <200810091400.m99E0UkM031182@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-09 16:00:29 +0200 (Thu, 09 Oct 2008)
New Revision: 955

Modified:
   /
   trunk/lib/Parley/Controller/User/LostPassword.pm
   trunk/lib/Parley/Controller/User/SignUp.pm
Log:
 r8273 at wiggin:  chisel | 2008-10-08 19:23:23 +0100
 - removed ->dumper() calls [no longer use the plugin, and barfs]



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8272
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8273
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/lib/Parley/Controller/User/LostPassword.pm
===================================================================
--- trunk/lib/Parley/Controller/User/LostPassword.pm	2008-10-09 14:00:13 UTC (rev 954)
+++ trunk/lib/Parley/Controller/User/LostPassword.pm	2008-10-09 14:00:29 UTC (rev 955)
@@ -351,7 +351,6 @@
             . $matches->count
             . q{ record(s)}
         );
-        $c->log->dumper($criteria);
         #return uniq(sort @messages);
         return;
     }
@@ -390,10 +389,6 @@
     my ($self, $c, $person) = @_;
     my ($random, $pwd_reset);
 
-    $c->log->dumper( ref $self,     'REF_SELF' );
-    $c->log->dumper( ref $c,        'REF_C' );
-    $c->log->dumper( ref $person,   'REF_PERSON' );
-
     # if it's good enough for Cozens, it's good enough for me :-)
     $random = md5_hex(time.(0+{}).$$.rand);
 

Modified: trunk/lib/Parley/Controller/User/SignUp.pm
===================================================================
--- trunk/lib/Parley/Controller/User/SignUp.pm	2008-10-09 14:00:13 UTC (rev 954)
+++ trunk/lib/Parley/Controller/User/SignUp.pm	2008-10-09 14:00:29 UTC (rev 955)
@@ -122,7 +122,6 @@
     );
 
     # get the first (and should be only) match
-    $c->log->dumper($c->stash->{signup_user}->{_column_data});
 
     # mark the person as authenticated
     $c->stash->{signup_user}->authentication->authenticated(1);



From chiselwright at mail.berlios.de  Thu Oct  9 16:00:40 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Thu, 9 Oct 2008 16:00:40 +0200
Subject: [Parley-svn] r956 - / trunk
Message-ID: <200810091400.m99E0eJP031380@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-09 16:00:40 +0200 (Thu, 09 Oct 2008)
New Revision: 956

Modified:
   /
   trunk/Changes
Log:
 r8274 at wiggin:  chisel | 2008-10-08 20:00:26 +0100
 Updated change log



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8273
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8274
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-09 14:00:29 UTC (rev 955)
+++ trunk/Changes	2008-10-09 14:00:40 UTC (rev 956)
@@ -1,5 +1,10 @@
 This file documents the revision history for Parley.
 
+1.0.2
+    - fixed "vanishing '+' symbol" issue in Message Preview
+    - removed ->dumper() calls that were overlooked and caused fatal errors
+    - specified minimum version numbers for most dependencies
+
 1.0.1   Wed Oct  8 00:26:29 BST 2008
     - added config options to use quote_char and name_sep in DB calls
     - updated order_by params in searches to work with quote_char



From chiselwright at mail.berlios.de  Thu Oct  9 16:00:59 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Thu, 9 Oct 2008 16:00:59 +0200
Subject: [Parley-svn] r957 - / tags
Message-ID: <200810091400.m99E0xZZ031504@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-09 16:00:59 +0200 (Thu, 09 Oct 2008)
New Revision: 957

Added:
   tags/parley-1.0.2/
Modified:
   /
Log:
 r8275 at wiggin:  chisel | 2008-10-09 14:55:54 +0100
 Tagging 1.0.2



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8274
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8275
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Copied: tags/parley-1.0.2 (from rev 956, trunk)



From chiselwright at mail.berlios.de  Wed Oct 22 00:41:15 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 22 Oct 2008 00:41:15 +0200
Subject: [Parley-svn] r958 - / trunk trunk/lib/Parley
Message-ID: <200810212241.m9LMfFLo006238@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-22 00:41:13 +0200 (Wed, 22 Oct 2008)
New Revision: 958

Modified:
   /
   trunk/Changes
   trunk/Makefile.PL
   trunk/lib/Parley/Version.pm
Log:
 r8325 at wiggin:  chisel | 2008-10-21 08:51:11 +0100
 version bump



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8275
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8325
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-09 14:00:59 UTC (rev 957)
+++ trunk/Changes	2008-10-21 22:41:13 UTC (rev 958)
@@ -1,6 +1,9 @@
 This file documents the revision history for Parley.
 
-1.0.2
+1.0.3
+    - (nothing yet)
+
+1.0.2   Thu Oct  9 14:52:26 BST 2008
     - fixed "vanishing '+' symbol" issue in Message Preview
     - removed ->dumper() calls that were overlooked and caused fatal errors
     - specified minimum version numbers for most dependencies

Modified: trunk/Makefile.PL
===================================================================
--- trunk/Makefile.PL	2008-10-09 14:00:59 UTC (rev 957)
+++ trunk/Makefile.PL	2008-10-21 22:41:13 UTC (rev 958)
@@ -8,7 +8,7 @@
 author          ('Chisel Wright<chiselwright at users.berlios.de>');
 abstract        ('Message board / forum application');
 license         ('perl');
-version         ('1.0.2');
+version         ('1.0.3');
 
 requires(
     'Catalyst'                                                  => '5.7014',

Modified: trunk/lib/Parley/Version.pm
===================================================================
--- trunk/lib/Parley/Version.pm	2008-10-09 14:00:59 UTC (rev 957)
+++ trunk/lib/Parley/Version.pm	2008-10-21 22:41:13 UTC (rev 958)
@@ -5,7 +5,7 @@
 
 # from mst on #catalyst
 #our $VERSION = '1.000000'; $VERSION = eval $VERSION;
-use version; our $VERSION = qv(1.0.2)->numify;
+use version; our $VERSION = qv(1.0.3)->numify;
 
 
 package Parley::Version;



From chiselwright at mail.berlios.de  Wed Oct 22 00:41:35 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 22 Oct 2008 00:41:35 +0200
Subject: [Parley-svn] r959 - / trunk trunk/db trunk/lib trunk/lib/Parley
	trunk/lib/Parley/Schema
Message-ID: <200810212241.m9LMfZcH006419@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-22 00:41:28 +0200 (Wed, 22 Oct 2008)
New Revision: 959

Added:
   trunk/db/patch_1.0.0_to_1.0.3.psql
   trunk/lib/Parley/Schema/Session.pm
Modified:
   /
   trunk/Changes
   trunk/Makefile.PL
   trunk/lib/Parley.pm
   trunk/lib/Parley/Schema.pm
   trunk/parley.conf
Log:
 r8329 at wiggin:  chisel | 2008-10-21 19:10:57 +0100
 Switch to database store for sessions



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8325
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8329
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/Changes	2008-10-21 22:41:28 UTC (rev 959)
@@ -1,7 +1,7 @@
 This file documents the revision history for Parley.
 
 1.0.3
-    - (nothing yet)
+    - switch to database store for sessions
 
 1.0.2   Thu Oct  9 14:52:26 BST 2008
     - fixed "vanishing '+' symbol" issue in Message Preview

Modified: trunk/Makefile.PL
===================================================================
--- trunk/Makefile.PL	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/Makefile.PL	2008-10-21 22:41:28 UTC (rev 959)
@@ -26,7 +26,7 @@
     'Catalyst::Plugin::Session'                                 => '0.19',
     'Catalyst::Plugin::Session::State::Cookie'                  => '0.09',
     'Cache::FastMmap'                                           => '1.24',
-    'Catalyst::Plugin::Session::Store::FastMmap'                => '0.05',
+    'Catalyst::Plugin::Session::Store::DBIC'                    => '0.06',
     'Catalyst::Plugin::StackTrace'                              => '0.08',
     'Catalyst::Plugin::Static::Simple'                          => '0.20',
     'Catalyst::View::TT'                                        => '0.27',

Added: trunk/db/patch_1.0.0_to_1.0.3.psql
===================================================================
--- trunk/db/patch_1.0.0_to_1.0.3.psql	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/db/patch_1.0.0_to_1.0.3.psql	2008-10-21 22:41:28 UTC (rev 959)
@@ -0,0 +1,29 @@
+-- Patch:
+--   From: 1.0.0
+--   To:   1.0.3
+--
+-- Description:
+--
+--      add table for database based sessions
+
+BEGIN;
+
+-- patch starts here --
+
+    -- Create a table in your database for sessions
+    -- [from Catalyst::Plugin::Session::Store::DBIC docs]
+    CREATE TABLE sessions (
+        id              CHAR(72) PRIMARY KEY,
+        session_data    TEXT,
+        expires         INTEGER,
+
+        -- we like to know when a session was created
+        created         timestamp with time zone
+                        default CURRENT_TIMESTAMP
+                        not null
+    );
+    ALTER TABLE sessions OWNER TO parley;
+
+-- patch ends here --
+
+COMMIT;

Added: trunk/lib/Parley/Schema/Session.pm
===================================================================
--- trunk/lib/Parley/Schema/Session.pm	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/lib/Parley/Schema/Session.pm	2008-10-21 22:41:28 UTC (rev 959)
@@ -0,0 +1,13 @@
+package Parley::Schema::Session;
+# vim: ts=8 sts=4 et sw=4 sr sta
+use strict;
+use warnings;
+
+use base qw/DBIx::Class/;
+
+__PACKAGE__->load_components(qw/Core/);
+__PACKAGE__->table('sessions');
+__PACKAGE__->add_columns(qw/id session_data expires created/);
+__PACKAGE__->set_primary_key('id');
+
+1;

Modified: trunk/lib/Parley/Schema.pm
===================================================================
--- trunk/lib/Parley/Schema.pm	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/lib/Parley/Schema.pm	2008-10-21 22:41:28 UTC (rev 959)
@@ -24,6 +24,7 @@
         'PreferenceTimeString',
         'RegistrationAuthentication',
         'Role',
+        'Session',
         'TermsAgreed',
         'Terms',
         'Thread',

Modified: trunk/lib/Parley.pm
===================================================================
--- trunk/lib/Parley.pm	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/lib/Parley.pm	2008-10-21 22:41:28 UTC (rev 959)
@@ -18,7 +18,7 @@
     Static::Simple
 
     Session
-    Session::Store::FastMmap
+    Session::Store::DBIC
     Session::State::Cookie
 
     Authentication

Modified: trunk/parley.conf
===================================================================
--- trunk/parley.conf	2008-10-21 22:41:13 UTC (rev 958)
+++ trunk/parley.conf	2008-10-21 22:41:28 UTC (rev 959)
@@ -106,6 +106,6 @@
 
 # configure the session storage
 <session>
-    storage   /tmp/parley.session
-    expires   3600
+    dbic_class  ParleyDB::Session
+    expires     3600
 </session>



From chiselwright at mail.berlios.de  Wed Oct 22 00:41:57 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 22 Oct 2008 00:41:57 +0200
Subject: [Parley-svn] r960 - / trunk/root/static
Message-ID: <200810212241.m9LMfvxE006741@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-22 00:41:51 +0200 (Wed, 22 Oct 2008)
New Revision: 960

Removed:
   trunk/root/static/yui/
Modified:
   /
Log:
 r8330 at wiggin:  chisel | 2008-10-21 19:17:40 +0100
 - remove previous version of yui, ready for 2.6.0



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8329
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8330
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222



From chiselwright at mail.berlios.de  Wed Oct 22 00:44:22 2008
From: chiselwright at mail.berlios.de (chiselwright at BerliOS)
Date: Wed, 22 Oct 2008 00:44:22 +0200
Subject: [Parley-svn] r962 - / trunk
Message-ID: <200810212244.m9LMiM6h010899@sheep.berlios.de>

Author: chiselwright
Date: 2008-10-22 00:44:21 +0200 (Wed, 22 Oct 2008)
New Revision: 962

Modified:
   /
   trunk/Changes
   trunk/MANIFEST
Log:
 r8332 at wiggin:  chisel | 2008-10-21 19:22:11 +0100
 / update Changes and MANIFEST to reflect YUI upgrade



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8331
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222
   + 6a361f96-f029-0410-94f8-848cdd0f6ccf:/local/parley:8332
6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:5151
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
f1659af6-751b-0410-a472-c93ec2bf8afc:/local/parley:1222

Modified: trunk/Changes
===================================================================
--- trunk/Changes	2008-10-21 22:42:06 UTC (rev 961)
+++ trunk/Changes	2008-10-21 22:44:21 UTC (rev 962)
@@ -2,6 +2,7 @@
 
 1.0.3
     - switch to database store for sessions
+    - upgrade to YUI 2.6.0
 
 1.0.2   Thu Oct  9 14:52:26 BST 2008
     - fixed "vanishing '+' symbol" issue in Message Preview

Modified: trunk/MANIFEST
===================================================================
--- trunk/MANIFEST	2008-10-21 22:42:06 UTC (rev 961)
+++ trunk/MANIFEST	2008-10-21 22:44:21 UTC (rev 962)
@@ -16,6 +16,7 @@
 db/patch_0.57_to_0.58.psql
 db/patch_0.58_to_0.59.psql
 db/patch_0.59_to_1.0.0.psql
+db/patch_1.0.0_to_1.0.3.psql
 db_script/Parley-Schema-0.57_08-PostgreSQL.sql
 db_script/Parley-Schema-0.58-PostgreSQL.sql
 db_script/Parley-Schema-0.58_13-MySQL.sql
@@ -90,6 +91,7 @@
 lib/Parley/Schema/PreferenceTimeString.pm
 lib/Parley/Schema/RegistrationAuthentication.pm
 lib/Parley/Schema/Role.pm
+lib/Parley/Schema/Session.pm
 lib/Parley/Schema/Terms.pm
 lib/Parley/Schema/TermsAgreed.pm
 lib/Parley/Schema/Thread.pm
@@ -477,347 +479,383 @@
 root/static/script/prototype.js
 root/static/script/user_forum_moderate.js
 root/static/script/user_suspend.js
-root/static/yui/animation/animation-debug.js
-root/static/yui/animation/animation-min.js
-root/static/yui/animation/animation.js
-root/static/yui/animation/README
-root/static/yui/assets/skins/sam/asc.gif
-root/static/yui/assets/skins/sam/autocomplete.css
-root/static/yui/assets/skins/sam/blankimage.png
-root/static/yui/assets/skins/sam/button.css
-root/static/yui/assets/skins/sam/calendar.css
-root/static/yui/assets/skins/sam/colorpicker.css
-root/static/yui/assets/skins/sam/container.css
-root/static/yui/assets/skins/sam/datatable.css
-root/static/yui/assets/skins/sam/desc.gif
-root/static/yui/assets/skins/sam/dt-arrow-dn.png
-root/static/yui/assets/skins/sam/dt-arrow-up.png
-root/static/yui/assets/skins/sam/editor-knob.gif
-root/static/yui/assets/skins/sam/editor-sprite-active.gif
-root/static/yui/assets/skins/sam/editor-sprite.gif
-root/static/yui/assets/skins/sam/editor.css
-root/static/yui/assets/skins/sam/header_background.png
-root/static/yui/assets/skins/sam/hue_bg.png
-root/static/yui/assets/skins/sam/imagecropper.css
-root/static/yui/assets/skins/sam/layout.css
-root/static/yui/assets/skins/sam/layout_sprite.png
-root/static/yui/assets/skins/sam/logger.css
-root/static/yui/assets/skins/sam/menu-button-arrow-disabled.png
-root/static/yui/assets/skins/sam/menu-button-arrow.png
-root/static/yui/assets/skins/sam/menu.css
-root/static/yui/assets/skins/sam/menubaritem_submenuindicator.png
-root/static/yui/assets/skins/sam/menubaritem_submenuindicator_disabled.png
-root/static/yui/assets/skins/sam/menuitem_checkbox.png
-root/static/yui/assets/skins/sam/menuitem_checkbox_disabled.png
-root/static/yui/assets/skins/sam/menuitem_submenuindicator.png
-root/static/yui/assets/skins/sam/menuitem_submenuindicator_disabled.png
-root/static/yui/assets/skins/sam/picker_mask.png
-root/static/yui/assets/skins/sam/profilerviewer.css
-root/static/yui/assets/skins/sam/resize.css
-root/static/yui/assets/skins/sam/simpleeditor.css
-root/static/yui/assets/skins/sam/skin.css
-root/static/yui/assets/skins/sam/split-button-arrow-active.png
-root/static/yui/assets/skins/sam/split-button-arrow-disabled.png
-root/static/yui/assets/skins/sam/split-button-arrow-focus.png
-root/static/yui/assets/skins/sam/split-button-arrow-hover.png
-root/static/yui/assets/skins/sam/split-button-arrow.png
-root/static/yui/assets/skins/sam/sprite.png
-root/static/yui/assets/skins/sam/tabview.css
-root/static/yui/assets/skins/sam/treeview-loading.gif
-root/static/yui/assets/skins/sam/treeview-sprite.gif
-root/static/yui/assets/skins/sam/treeview.css
-root/static/yui/assets/skins/sam/wait.gif
-root/static/yui/assets/skins/sam/yuitest.css
-root/static/yui/autocomplete/assets/autocomplete-core.css
-root/static/yui/autocomplete/assets/skins/sam/autocomplete-skin.css
-root/static/yui/autocomplete/assets/skins/sam/autocomplete.css
-root/static/yui/autocomplete/autocomplete-debug.js
-root/static/yui/autocomplete/autocomplete-min.js
-root/static/yui/autocomplete/autocomplete.js
-root/static/yui/autocomplete/README
-root/static/yui/base/base-min.css
-root/static/yui/base/base.css
-root/static/yui/base/README
-root/static/yui/button/assets/button-core.css
-root/static/yui/button/assets/skins/sam/button-skin.css
-root/static/yui/button/assets/skins/sam/button.css
-root/static/yui/button/assets/skins/sam/menu-button-arrow-disabled.png
-root/static/yui/button/assets/skins/sam/menu-button-arrow.png
-root/static/yui/button/assets/skins/sam/split-button-arrow-active.png
-root/static/yui/button/assets/skins/sam/split-button-arrow-disabled.png
-root/static/yui/button/assets/skins/sam/split-button-arrow-focus.png
-root/static/yui/button/assets/skins/sam/split-button-arrow-hover.png
-root/static/yui/button/assets/skins/sam/split-button-arrow.png
-root/static/yui/button/button-debug.js
-root/static/yui/button/button-min.js
-root/static/yui/button/button.js
-root/static/yui/button/README
-root/static/yui/calendar/assets/calendar-core.css
-root/static/yui/calendar/assets/calendar.css
-root/static/yui/calendar/assets/calgrad.png
-root/static/yui/calendar/assets/callt.gif
-root/static/yui/calendar/assets/calrt.gif
-root/static/yui/calendar/assets/calx.gif
-root/static/yui/calendar/assets/skins/sam/calendar-skin.css
-root/static/yui/calendar/assets/skins/sam/calendar.css
-root/static/yui/calendar/calendar-debug.js
-root/static/yui/calendar/calendar-min.js
-root/static/yui/calendar/calendar.js
-root/static/yui/calendar/README
-root/static/yui/charts/assets/charts.swf
-root/static/yui/charts/charts-experimental-debug.js
-root/static/yui/charts/charts-experimental-min.js
-root/static/yui/charts/charts-experimental.js
-root/static/yui/charts/README
-root/static/yui/colorpicker/assets/colorpicker_core.css
-root/static/yui/colorpicker/assets/hue_thumb.png
-root/static/yui/colorpicker/assets/picker_mask.png
-root/static/yui/colorpicker/assets/picker_thumb.png
-root/static/yui/colorpicker/assets/skins/sam/colorpicker-skin.css
-root/static/yui/colorpicker/assets/skins/sam/colorpicker.css
-root/static/yui/colorpicker/assets/skins/sam/hue_bg.png
-root/static/yui/colorpicker/assets/skins/sam/picker_mask.png
-root/static/yui/colorpicker/colorpicker-debug.js
-root/static/yui/colorpicker/colorpicker-min.js
-root/static/yui/colorpicker/colorpicker.js
-root/static/yui/colorpicker/README
-root/static/yui/connection/connection-debug.js
-root/static/yui/connection/connection-min.js
-root/static/yui/connection/connection.js
-root/static/yui/connection/README
-root/static/yui/container/assets/alrt16_1.gif
-root/static/yui/container/assets/blck16_1.gif
-root/static/yui/container/assets/close12_1.gif
-root/static/yui/container/assets/container-core.css
-root/static/yui/container/assets/container.css
-root/static/yui/container/assets/hlp16_1.gif
-root/static/yui/container/assets/info16_1.gif
-root/static/yui/container/assets/skins/sam/container-skin.css
-root/static/yui/container/assets/skins/sam/container.css
-root/static/yui/container/assets/tip16_1.gif
-root/static/yui/container/assets/warn16_1.gif
-root/static/yui/container/container-debug.js
-root/static/yui/container/container-min.js
-root/static/yui/container/container.js
-root/static/yui/container/container_core-debug.js
-root/static/yui/container/container_core-min.js
-root/static/yui/container/container_core.js
-root/static/yui/container/README
-root/static/yui/cookie/cookie-beta-debug.js
-root/static/yui/cookie/cookie-beta-min.js
-root/static/yui/cookie/cookie-beta.js
-root/static/yui/cookie/README
-root/static/yui/datasource/datasource-beta-debug.js
-root/static/yui/datasource/datasource-beta-min.js
-root/static/yui/datasource/datasource-beta.js
-root/static/yui/datasource/README
-root/static/yui/datatable/assets/datatable-core.css
-root/static/yui/datatable/assets/datatable.css
-root/static/yui/datatable/assets/skins/sam/datatable-skin.css
-root/static/yui/datatable/assets/skins/sam/datatable.css
-root/static/yui/datatable/assets/skins/sam/dt-arrow-dn.png
-root/static/yui/datatable/assets/skins/sam/dt-arrow-up.png
-root/static/yui/datatable/datatable-beta-debug.js
-root/static/yui/datatable/datatable-beta-min.js
-root/static/yui/datatable/datatable-beta.js
-root/static/yui/datatable/README
-root/static/yui/dom/dom-debug.js
-root/static/yui/dom/dom-min.js
-root/static/yui/dom/dom.js
-root/static/yui/dom/README
-root/static/yui/dragdrop/dragdrop-debug.js
-root/static/yui/dragdrop/dragdrop-min.js
-root/static/yui/dragdrop/dragdrop.js
-root/static/yui/dragdrop/README
-root/static/yui/editor/assets/editor-core.css
-root/static/yui/editor/assets/simpleeditor-core.css
-root/static/yui/editor/assets/skins/sam/blankimage.png
-root/static/yui/editor/assets/skins/sam/editor-knob.gif
-root/static/yui/editor/assets/skins/sam/editor-skin.css
-root/static/yui/editor/assets/skins/sam/editor-sprite-active.gif
-root/static/yui/editor/assets/skins/sam/editor-sprite.gif
-root/static/yui/editor/assets/skins/sam/editor.css
-root/static/yui/editor/assets/skins/sam/simpleeditor-skin.css
-root/static/yui/editor/assets/skins/sam/simpleeditor.css
-root/static/yui/editor/editor-beta-debug.js
-root/static/yui/editor/editor-beta-min.js
-root/static/yui/editor/editor-beta.js
-root/static/yui/editor/README
-root/static/yui/editor/simpleeditor-beta-debug.js
-root/static/yui/editor/simpleeditor-beta-min.js
-root/static/yui/editor/simpleeditor-beta.js
-root/static/yui/element/element-beta-debug.js
-root/static/yui/element/element-beta-min.js
-root/static/yui/element/element-beta.js
-root/static/yui/element/README
-root/static/yui/event/event-debug.js
-root/static/yui/event/event-min.js
-root/static/yui/event/event.js
-root/static/yui/event/README
-root/static/yui/fonts/fonts-min.css
-root/static/yui/fonts/fonts.css
-root/static/yui/fonts/README
-root/static/yui/get/get-debug.js
-root/static/yui/get/get-min.js
-root/static/yui/get/get.js
-root/static/yui/get/README
-root/static/yui/grids/grids-min.css
-root/static/yui/grids/grids.css
-root/static/yui/grids/README
-root/static/yui/history/assets/blank.html
-root/static/yui/history/history-debug.js
-root/static/yui/history/history-min.js
-root/static/yui/history/history.js
-root/static/yui/history/README
-root/static/yui/imagecropper/assets/imagecropper-core.css
-root/static/yui/imagecropper/assets/skins/sam/imagecropper-skin.css
-root/static/yui/imagecropper/assets/skins/sam/imagecropper.css
-root/static/yui/imagecropper/imagecropper-beta-debug.js
-root/static/yui/imagecropper/imagecropper-beta-min.js
-root/static/yui/imagecropper/imagecropper-beta.js
-root/static/yui/imagecropper/README
-root/static/yui/imageloader/imageloader-debug.js
-root/static/yui/imageloader/imageloader-min.js
-root/static/yui/imageloader/imageloader.js
-root/static/yui/imageloader/README
-root/static/yui/json/json-debug.js
-root/static/yui/json/json-min.js
-root/static/yui/json/json.js
-root/static/yui/json/README
-root/static/yui/layout/assets/layout-core.css
-root/static/yui/layout/assets/skins/sam/layout-skin.css
-root/static/yui/layout/assets/skins/sam/layout.css
-root/static/yui/layout/assets/skins/sam/layout_sprite.png
-root/static/yui/layout/layout-beta-debug.js
-root/static/yui/layout/layout-beta-min.js
-root/static/yui/layout/layout-beta.js
-root/static/yui/layout/README
-root/static/yui/logger/assets/logger-core.css
-root/static/yui/logger/assets/logger.css
-root/static/yui/logger/assets/skins/sam/logger-skin.css
-root/static/yui/logger/assets/skins/sam/logger.css
-root/static/yui/logger/logger-debug.js
-root/static/yui/logger/logger-min.js
-root/static/yui/logger/logger.js
-root/static/yui/logger/README
-root/static/yui/menu/assets/menu-core.css
-root/static/yui/menu/assets/menu.css
-root/static/yui/menu/assets/menu_down_arrow.png
-root/static/yui/menu/assets/menu_down_arrow_disabled.png
-root/static/yui/menu/assets/menu_up_arrow.png
-root/static/yui/menu/assets/menu_up_arrow_disabled.png
-root/static/yui/menu/assets/menubaritem_submenuindicator.png
-root/static/yui/menu/assets/menubaritem_submenuindicator_disabled.png
-root/static/yui/menu/assets/menubaritem_submenuindicator_selected.png
-root/static/yui/menu/assets/menuitem_checkbox.png
-root/static/yui/menu/assets/menuitem_checkbox_disabled.png
-root/static/yui/menu/assets/menuitem_checkbox_selected.png
-root/static/yui/menu/assets/menuitem_submenuindicator.png
-root/static/yui/menu/assets/menuitem_submenuindicator_disabled.png
-root/static/yui/menu/assets/menuitem_submenuindicator_selected.png
-root/static/yui/menu/assets/skins/sam/menu-skin.css
-root/static/yui/menu/assets/skins/sam/menu.css
-root/static/yui/menu/assets/skins/sam/menubaritem_submenuindicator.png
-root/static/yui/menu/assets/skins/sam/menubaritem_submenuindicator_disabled.png
-root/static/yui/menu/assets/skins/sam/menuitem_checkbox.png
-root/static/yui/menu/assets/skins/sam/menuitem_checkbox_disabled.png
-root/static/yui/menu/assets/skins/sam/menuitem_submenuindicator.png
-root/static/yui/menu/assets/skins/sam/menuitem_submenuindicator_disabled.png
-root/static/yui/menu/menu-debug.js
-root/static/yui/menu/menu-min.js
-root/static/yui/menu/menu.js
-root/static/yui/menu/README
-root/static/yui/profiler/profiler-beta-debug.js
-root/static/yui/profiler/profiler-beta-min.js
-root/static/yui/profiler/profiler-beta.js
-root/static/yui/profiler/README
-root/static/yui/profilerviewer/assets/skins/sam/asc.gif
-root/static/yui/profilerviewer/assets/skins/sam/desc.gif
-root/static/yui/profilerviewer/assets/skins/sam/header_background.png
-root/static/yui/profilerviewer/assets/skins/sam/profilerviewer.css
-root/static/yui/profilerviewer/assets/skins/sam/wait.gif
-root/static/yui/profilerviewer/profilerviewer-beta-debug.js
-root/static/yui/profilerviewer/profilerviewer-beta-min.js
-root/static/yui/profilerviewer/profilerviewer-beta.js
-root/static/yui/profilerviewer/README
-root/static/yui/reset-fonts-grids/README
-root/static/yui/reset-fonts-grids/reset-fonts-grids.css
-root/static/yui/reset-fonts/README
-root/static/yui/reset-fonts/reset-fonts.css
-root/static/yui/reset/README
-root/static/yui/reset/reset-min.css
-root/static/yui/reset/reset.css
-root/static/yui/resize/assets/resize-core.css
-root/static/yui/resize/assets/skins/sam/layout_sprite.png
-root/static/yui/resize/assets/skins/sam/resize-skin.css
-root/static/yui/resize/assets/skins/sam/resize.css
-root/static/yui/resize/README
-root/static/yui/resize/resize-beta-debug.js
-root/static/yui/resize/resize-beta-min.js
-root/static/yui/resize/resize-beta.js
-root/static/yui/selector/README
-root/static/yui/selector/selector-beta-debug.js
-root/static/yui/selector/selector-beta-min.js
-root/static/yui/selector/selector-beta.js
-root/static/yui/slider/README
-root/static/yui/slider/slider-debug.js
-root/static/yui/slider/slider-min.js
-root/static/yui/slider/slider.js
-root/static/yui/tabview/assets/border_tabs.css
-root/static/yui/tabview/assets/loading.gif
-root/static/yui/tabview/assets/skin-sam.css
-root/static/yui/tabview/assets/skins/sam/tabview-skin.css
-root/static/yui/tabview/assets/skins/sam/tabview.css
-root/static/yui/tabview/assets/tabview-core.css
-root/static/yui/tabview/assets/tabview.css
-root/static/yui/tabview/README
-root/static/yui/tabview/tabview-debug.js
-root/static/yui/tabview/tabview-min.js
-root/static/yui/tabview/tabview.js
-root/static/yui/treeview/assets/skins/sam/treeview-loading.gif
-root/static/yui/treeview/assets/skins/sam/treeview-skin.css
-root/static/yui/treeview/assets/skins/sam/treeview-sprite.gif
-root/static/yui/treeview/assets/skins/sam/treeview.css
-root/static/yui/treeview/assets/sprite-menu.gif
-root/static/yui/treeview/assets/sprite-orig.gif
-root/static/yui/treeview/assets/treeview-core.css
-root/static/yui/treeview/assets/treeview-loading.gif
-root/static/yui/treeview/assets/treeview-menu.css
-root/static/yui/treeview/assets/treeview.css
-root/static/yui/treeview/README
-root/static/yui/treeview/treeview-debug.js
-root/static/yui/treeview/treeview-min.js
-root/static/yui/treeview/treeview.js
-root/static/yui/uploader/assets/uploader.swf
-root/static/yui/uploader/README
-root/static/yui/uploader/uploader-experimental-debug.js
-root/static/yui/uploader/uploader-experimental-min.js
-root/static/yui/uploader/uploader-experimental.js
-root/static/yui/utilities/README
-root/static/yui/utilities/utilities.js
-root/static/yui/yahoo-dom-event/README
-root/static/yui/yahoo-dom-event/yahoo-dom-event.js
-root/static/yui/yahoo/README
-root/static/yui/yahoo/yahoo-debug.js
-root/static/yui/yahoo/yahoo-min.js
-root/static/yui/yahoo/yahoo.js
-root/static/yui/yuiloader-dom-event/README
-root/static/yui/yuiloader-dom-event/yuiloader-dom-event.js
-root/static/yui/yuiloader/README
-root/static/yui/yuiloader/yuiloader-beta-debug.js
-root/static/yui/yuiloader/yuiloader-beta-min.js
-root/static/yui/yuiloader/yuiloader-beta.js
-root/static/yui/yuitest/assets/skins/sam/yuitest-skin.css
-root/static/yui/yuitest/assets/skins/sam/yuitest.css
-root/static/yui/yuitest/assets/testlogger.css
-root/static/yui/yuitest/assets/yuitest-core.css
-root/static/yui/yuitest/README
-root/static/yui/yuitest/yuitest-debug.js
-root/static/yui/yuitest/yuitest-min.js
-root/static/yui/yuitest/yuitest.js
-root/static/yui/yuitest/yuitest_core-debug.js
-root/static/yui/yuitest/yuitest_core-min.js
-root/static/yui/yuitest/yuitest_core.js
+root/static/yui_2.6.0/animation/animation-debug.js
+root/static/yui_2.6.0/animation/animation-min.js
+root/static/yui_2.6.0/animation/animation.js
+root/static/yui_2.6.0/animation/README
+root/static/yui_2.6.0/assets/skins/sam/asc.gif
+root/static/yui_2.6.0/assets/skins/sam/autocomplete.css
+root/static/yui_2.6.0/assets/skins/sam/blankimage.png
+root/static/yui_2.6.0/assets/skins/sam/button.css
+root/static/yui_2.6.0/assets/skins/sam/calendar.css
+root/static/yui_2.6.0/assets/skins/sam/carousel.css
+root/static/yui_2.6.0/assets/skins/sam/colorpicker.css
+root/static/yui_2.6.0/assets/skins/sam/container.css
+root/static/yui_2.6.0/assets/skins/sam/datatable.css
+root/static/yui_2.6.0/assets/skins/sam/desc.gif
+root/static/yui_2.6.0/assets/skins/sam/dt-arrow-dn.png
+root/static/yui_2.6.0/assets/skins/sam/dt-arrow-up.png
+root/static/yui_2.6.0/assets/skins/sam/editor-knob.gif
+root/static/yui_2.6.0/assets/skins/sam/editor-sprite-active.gif
+root/static/yui_2.6.0/assets/skins/sam/editor-sprite.gif
+root/static/yui_2.6.0/assets/skins/sam/editor.css
+root/static/yui_2.6.0/assets/skins/sam/header_background.png
+root/static/yui_2.6.0/assets/skins/sam/hue_bg.png
+root/static/yui_2.6.0/assets/skins/sam/imagecropper.css
+root/static/yui_2.6.0/assets/skins/sam/layout.css
+root/static/yui_2.6.0/assets/skins/sam/layout_sprite.png
+root/static/yui_2.6.0/assets/skins/sam/loading.gif
+root/static/yui_2.6.0/assets/skins/sam/logger.css
+root/static/yui_2.6.0/assets/skins/sam/menu-button-arrow-disabled.png
+root/static/yui_2.6.0/assets/skins/sam/menu-button-arrow.png
+root/static/yui_2.6.0/assets/skins/sam/menu.css
+root/static/yui_2.6.0/assets/skins/sam/menubaritem_submenuindicator.png
+root/static/yui_2.6.0/assets/skins/sam/menubaritem_submenuindicator_disabled.png
+root/static/yui_2.6.0/assets/skins/sam/menuitem_checkbox.png
+root/static/yui_2.6.0/assets/skins/sam/menuitem_checkbox_disabled.png
+root/static/yui_2.6.0/assets/skins/sam/menuitem_submenuindicator.png
+root/static/yui_2.6.0/assets/skins/sam/menuitem_submenuindicator_disabled.png
+root/static/yui_2.6.0/assets/skins/sam/paginator.css
+root/static/yui_2.6.0/assets/skins/sam/picker_mask.png
+root/static/yui_2.6.0/assets/skins/sam/profilerviewer.css
+root/static/yui_2.6.0/assets/skins/sam/resize.css
+root/static/yui_2.6.0/assets/skins/sam/simpleeditor.css
+root/static/yui_2.6.0/assets/skins/sam/skin.css
+root/static/yui_2.6.0/assets/skins/sam/slider.css
+root/static/yui_2.6.0/assets/skins/sam/split-button-arrow-active.png
+root/static/yui_2.6.0/assets/skins/sam/split-button-arrow-disabled.png
+root/static/yui_2.6.0/assets/skins/sam/split-button-arrow-focus.png
+root/static/yui_2.6.0/assets/skins/sam/split-button-arrow-hover.png
+root/static/yui_2.6.0/assets/skins/sam/split-button-arrow.png
+root/static/yui_2.6.0/assets/skins/sam/sprite.png
+root/static/yui_2.6.0/assets/skins/sam/sprite.psd
+root/static/yui_2.6.0/assets/skins/sam/tabview.css
+root/static/yui_2.6.0/assets/skins/sam/treeview-loading.gif
+root/static/yui_2.6.0/assets/skins/sam/treeview-sprite.gif
+root/static/yui_2.6.0/assets/skins/sam/treeview.css
+root/static/yui_2.6.0/assets/skins/sam/wait.gif
+root/static/yui_2.6.0/assets/skins/sam/yuitest.css
+root/static/yui_2.6.0/autocomplete/assets/autocomplete-core.css
+root/static/yui_2.6.0/autocomplete/assets/skins/sam/autocomplete-skin.css
+root/static/yui_2.6.0/autocomplete/assets/skins/sam/autocomplete.css
+root/static/yui_2.6.0/autocomplete/autocomplete-debug.js
+root/static/yui_2.6.0/autocomplete/autocomplete-min.js
+root/static/yui_2.6.0/autocomplete/autocomplete.js
+root/static/yui_2.6.0/autocomplete/README
+root/static/yui_2.6.0/base/base-min.css
+root/static/yui_2.6.0/base/base.css
+root/static/yui_2.6.0/base/README
+root/static/yui_2.6.0/button/assets/button-core.css
+root/static/yui_2.6.0/button/assets/skins/sam/button-skin.css
+root/static/yui_2.6.0/button/assets/skins/sam/button.css
+root/static/yui_2.6.0/button/assets/skins/sam/menu-button-arrow-disabled.png
+root/static/yui_2.6.0/button/assets/skins/sam/menu-button-arrow.png
+root/static/yui_2.6.0/button/assets/skins/sam/split-button-arrow-active.png
+root/static/yui_2.6.0/button/assets/skins/sam/split-button-arrow-disabled.png
+root/static/yui_2.6.0/button/assets/skins/sam/split-button-arrow-focus.png
+root/static/yui_2.6.0/button/assets/skins/sam/split-button-arrow-hover.png
+root/static/yui_2.6.0/button/assets/skins/sam/split-button-arrow.png
+root/static/yui_2.6.0/button/button-debug.js
+root/static/yui_2.6.0/button/button-min.js
+root/static/yui_2.6.0/button/button.js
+root/static/yui_2.6.0/button/README
+root/static/yui_2.6.0/calendar/assets/calendar-core.css
+root/static/yui_2.6.0/calendar/assets/calendar.css
+root/static/yui_2.6.0/calendar/assets/calgrad.png
+root/static/yui_2.6.0/calendar/assets/callt.gif
+root/static/yui_2.6.0/calendar/assets/calrt.gif
+root/static/yui_2.6.0/calendar/assets/calx.gif
+root/static/yui_2.6.0/calendar/assets/skins/sam/calendar-skin.css
+root/static/yui_2.6.0/calendar/assets/skins/sam/calendar.css
+root/static/yui_2.6.0/calendar/calendar-debug.js
+root/static/yui_2.6.0/calendar/calendar-min.js
+root/static/yui_2.6.0/calendar/calendar.js
+root/static/yui_2.6.0/calendar/README
+root/static/yui_2.6.0/carousel/assets/ajax-loader.gif
+root/static/yui_2.6.0/carousel/assets/carousel-core.css
+root/static/yui_2.6.0/carousel/assets/skins/sam/carousel-skin.css
+root/static/yui_2.6.0/carousel/assets/skins/sam/carousel.css
+root/static/yui_2.6.0/carousel/carousel-beta-debug.js
+root/static/yui_2.6.0/carousel/carousel-beta-min.js
+root/static/yui_2.6.0/carousel/carousel-beta.js
+root/static/yui_2.6.0/carousel/README
+root/static/yui_2.6.0/charts/assets/charts.swf
+root/static/yui_2.6.0/charts/charts-experimental-debug.js
+root/static/yui_2.6.0/charts/charts-experimental-min.js
+root/static/yui_2.6.0/charts/charts-experimental.js
+root/static/yui_2.6.0/charts/README
+root/static/yui_2.6.0/colorpicker/assets/colorpicker-core.css
+root/static/yui_2.6.0/colorpicker/assets/hue_thumb.png
+root/static/yui_2.6.0/colorpicker/assets/picker_mask.png
+root/static/yui_2.6.0/colorpicker/assets/picker_thumb.png
+root/static/yui_2.6.0/colorpicker/assets/skins/sam/colorpicker-skin.css
+root/static/yui_2.6.0/colorpicker/assets/skins/sam/colorpicker.css
+root/static/yui_2.6.0/colorpicker/assets/skins/sam/hue_bg.png
+root/static/yui_2.6.0/colorpicker/assets/skins/sam/picker_mask.png
+root/static/yui_2.6.0/colorpicker/colorpicker-debug.js
+root/static/yui_2.6.0/colorpicker/colorpicker-min.js
+root/static/yui_2.6.0/colorpicker/colorpicker.js
+root/static/yui_2.6.0/colorpicker/README
+root/static/yui_2.6.0/connection/connection-debug.js
+root/static/yui_2.6.0/connection/connection-min.js
+root/static/yui_2.6.0/connection/connection.js
+root/static/yui_2.6.0/connection/README
+root/static/yui_2.6.0/container/assets/alrt16_1.gif
+root/static/yui_2.6.0/container/assets/blck16_1.gif
+root/static/yui_2.6.0/container/assets/close12_1.gif
+root/static/yui_2.6.0/container/assets/container-core.css
+root/static/yui_2.6.0/container/assets/container.css
+root/static/yui_2.6.0/container/assets/hlp16_1.gif
+root/static/yui_2.6.0/container/assets/info16_1.gif
+root/static/yui_2.6.0/container/assets/skins/sam/container-skin.css
+root/static/yui_2.6.0/container/assets/skins/sam/container.css
+root/static/yui_2.6.0/container/assets/tip16_1.gif
+root/static/yui_2.6.0/container/assets/warn16_1.gif
+root/static/yui_2.6.0/container/container-debug.js
+root/static/yui_2.6.0/container/container-min.js
+root/static/yui_2.6.0/container/container.js
+root/static/yui_2.6.0/container/container_core-debug.js
+root/static/yui_2.6.0/container/container_core-min.js
+root/static/yui_2.6.0/container/container_core.js
+root/static/yui_2.6.0/container/README
+root/static/yui_2.6.0/cookie/cookie-debug.js
+root/static/yui_2.6.0/cookie/cookie-min.js
+root/static/yui_2.6.0/cookie/cookie.js
+root/static/yui_2.6.0/cookie/README
+root/static/yui_2.6.0/datasource/datasource-debug.js
+root/static/yui_2.6.0/datasource/datasource-min.js
+root/static/yui_2.6.0/datasource/datasource.js
+root/static/yui_2.6.0/datasource/README
+root/static/yui_2.6.0/datatable/assets/datatable-core.css
+root/static/yui_2.6.0/datatable/assets/datatable.css
+root/static/yui_2.6.0/datatable/assets/skins/sam/datatable-skin.css
+root/static/yui_2.6.0/datatable/assets/skins/sam/datatable.css
+root/static/yui_2.6.0/datatable/assets/skins/sam/dt-arrow-dn.png
+root/static/yui_2.6.0/datatable/assets/skins/sam/dt-arrow-up.png
+root/static/yui_2.6.0/datatable/datatable-debug.js
+root/static/yui_2.6.0/datatable/datatable-min.js
+root/static/yui_2.6.0/datatable/datatable.js
+root/static/yui_2.6.0/datatable/README
+root/static/yui_2.6.0/dom/dom-debug.js
+root/static/yui_2.6.0/dom/dom-min.js
+root/static/yui_2.6.0/dom/dom.js
+root/static/yui_2.6.0/dom/README
+root/static/yui_2.6.0/dragdrop/dragdrop-debug.js
+root/static/yui_2.6.0/dragdrop/dragdrop-min.js
+root/static/yui_2.6.0/dragdrop/dragdrop.js
+root/static/yui_2.6.0/dragdrop/README
+root/static/yui_2.6.0/editor/assets/editor-core.css
+root/static/yui_2.6.0/editor/assets/simpleeditor-core.css
+root/static/yui_2.6.0/editor/assets/skins/sam/blankimage.png
+root/static/yui_2.6.0/editor/assets/skins/sam/editor-knob.gif
+root/static/yui_2.6.0/editor/assets/skins/sam/editor-skin.css
+root/static/yui_2.6.0/editor/assets/skins/sam/editor-sprite-active.gif
+root/static/yui_2.6.0/editor/assets/skins/sam/editor-sprite.gif
+root/static/yui_2.6.0/editor/assets/skins/sam/editor.css
+root/static/yui_2.6.0/editor/assets/skins/sam/simpleeditor-skin.css
+root/static/yui_2.6.0/editor/assets/skins/sam/simpleeditor.css
+root/static/yui_2.6.0/editor/editor-debug.js
+root/static/yui_2.6.0/editor/editor-min.js
+root/static/yui_2.6.0/editor/editor.js
+root/static/yui_2.6.0/editor/README
+root/static/yui_2.6.0/editor/simpleeditor-debug.js
+root/static/yui_2.6.0/editor/simpleeditor-min.js
+root/static/yui_2.6.0/editor/simpleeditor.js
+root/static/yui_2.6.0/element/element-beta-debug.js
+root/static/yui_2.6.0/element/element-beta-min.js
+root/static/yui_2.6.0/element/element-beta.js
+root/static/yui_2.6.0/element/README
+root/static/yui_2.6.0/event/event-debug.js
+root/static/yui_2.6.0/event/event-min.js
+root/static/yui_2.6.0/event/event.js
+root/static/yui_2.6.0/event/README
+root/static/yui_2.6.0/fonts/fonts-min.css
+root/static/yui_2.6.0/fonts/fonts.css
+root/static/yui_2.6.0/fonts/README
+root/static/yui_2.6.0/get/get-debug.js
+root/static/yui_2.6.0/get/get-min.js
+root/static/yui_2.6.0/get/get.js
+root/static/yui_2.6.0/get/README
+root/static/yui_2.6.0/grids/grids-min.css
+root/static/yui_2.6.0/grids/grids.css
+root/static/yui_2.6.0/grids/README
+root/static/yui_2.6.0/history/assets/blank.html
+root/static/yui_2.6.0/history/history-debug.js
+root/static/yui_2.6.0/history/history-min.js
+root/static/yui_2.6.0/history/history.js
+root/static/yui_2.6.0/history/README
+root/static/yui_2.6.0/imagecropper/assets/imagecropper-core.css
+root/static/yui_2.6.0/imagecropper/assets/skins/sam/imagecropper-skin.css
+root/static/yui_2.6.0/imagecropper/assets/skins/sam/imagecropper.css
+root/static/yui_2.6.0/imagecropper/imagecropper-beta-debug.js
+root/static/yui_2.6.0/imagecropper/imagecropper-beta-min.js
+root/static/yui_2.6.0/imagecropper/imagecropper-beta.js
+root/static/yui_2.6.0/imagecropper/README
+root/static/yui_2.6.0/imageloader/imageloader-debug.js
+root/static/yui_2.6.0/imageloader/imageloader-min.js
+root/static/yui_2.6.0/imageloader/imageloader.js
+root/static/yui_2.6.0/imageloader/README
+root/static/yui_2.6.0/json/json-debug.js
+root/static/yui_2.6.0/json/json-min.js
+root/static/yui_2.6.0/json/json.js
+root/static/yui_2.6.0/json/README
+root/static/yui_2.6.0/layout/assets/layout-core.css
+root/static/yui_2.6.0/layout/assets/skins/sam/layout-skin.css
+root/static/yui_2.6.0/layout/assets/skins/sam/layout.css
+root/static/yui_2.6.0/layout/assets/skins/sam/layout_sprite.png
+root/static/yui_2.6.0/layout/layout-debug.js
+root/static/yui_2.6.0/layout/layout-min.js
+root/static/yui_2.6.0/layout/layout.js
+root/static/yui_2.6.0/layout/README
+root/static/yui_2.6.0/logger/assets/logger-core.css
+root/static/yui_2.6.0/logger/assets/logger.css
+root/static/yui_2.6.0/logger/assets/skins/sam/logger-skin.css
+root/static/yui_2.6.0/logger/assets/skins/sam/logger.css
+root/static/yui_2.6.0/logger/logger-debug.js
+root/static/yui_2.6.0/logger/logger-min.js
+root/static/yui_2.6.0/logger/logger.js
+root/static/yui_2.6.0/logger/README
+root/static/yui_2.6.0/menu/assets/menu-core.css
+root/static/yui_2.6.0/menu/assets/menu.css
+root/static/yui_2.6.0/menu/assets/menu_down_arrow.png
+root/static/yui_2.6.0/menu/assets/menu_down_arrow_disabled.png
+root/static/yui_2.6.0/menu/assets/menu_up_arrow.png
+root/static/yui_2.6.0/menu/assets/menu_up_arrow_disabled.png
+root/static/yui_2.6.0/menu/assets/menubaritem_submenuindicator.png
+root/static/yui_2.6.0/menu/assets/menubaritem_submenuindicator_disabled.png
+root/static/yui_2.6.0/menu/assets/menubaritem_submenuindicator_selected.png
+root/static/yui_2.6.0/menu/assets/menuitem_checkbox.png
+root/static/yui_2.6.0/menu/assets/menuitem_checkbox_disabled.png
+root/static/yui_2.6.0/menu/assets/menuitem_checkbox_selected.png
+root/static/yui_2.6.0/menu/assets/menuitem_submenuindicator.png
+root/static/yui_2.6.0/menu/assets/menuitem_submenuindicator_disabled.png
+root/static/yui_2.6.0/menu/assets/menuitem_submenuindicator_selected.png
+root/static/yui_2.6.0/menu/assets/skins/sam/menu-skin.css
+root/static/yui_2.6.0/menu/assets/skins/sam/menu.css
+root/static/yui_2.6.0/menu/assets/skins/sam/menubaritem_submenuindicator.png
+root/static/yui_2.6.0/menu/assets/skins/sam/menubaritem_submenuindicator_disabled.png
+root/static/yui_2.6.0/menu/assets/skins/sam/menuitem_checkbox.png
+root/static/yui_2.6.0/menu/assets/skins/sam/menuitem_checkbox_disabled.png
+root/static/yui_2.6.0/menu/assets/skins/sam/menuitem_submenuindicator.png
+root/static/yui_2.6.0/menu/assets/skins/sam/menuitem_submenuindicator_disabled.png
+root/static/yui_2.6.0/menu/menu-debug.js
+root/static/yui_2.6.0/menu/menu-min.js
+root/static/yui_2.6.0/menu/menu.js
+root/static/yui_2.6.0/menu/README
+root/static/yui_2.6.0/paginator/assets/paginator-core.css
+root/static/yui_2.6.0/paginator/assets/skins/sam/paginator-skin.css
+root/static/yui_2.6.0/paginator/assets/skins/sam/paginator.css
+root/static/yui_2.6.0/paginator/paginator-debug.js
+root/static/yui_2.6.0/paginator/paginator-min.js
+root/static/yui_2.6.0/paginator/paginator.js
+root/static/yui_2.6.0/paginator/README
+root/static/yui_2.6.0/profiler/profiler-debug.js
+root/static/yui_2.6.0/profiler/profiler-min.js
+root/static/yui_2.6.0/profiler/profiler.js
+root/static/yui_2.6.0/profiler/README
+root/static/yui_2.6.0/profilerviewer/assets/skins/sam/asc.gif
+root/static/yui_2.6.0/profilerviewer/assets/skins/sam/desc.gif
+root/static/yui_2.6.0/profilerviewer/assets/skins/sam/header_background.png
+root/static/yui_2.6.0/profilerviewer/assets/skins/sam/profilerviewer.css
+root/static/yui_2.6.0/profilerviewer/assets/skins/sam/wait.gif
+root/static/yui_2.6.0/profilerviewer/profilerviewer-beta-debug.js
+root/static/yui_2.6.0/profilerviewer/profilerviewer-beta-min.js
+root/static/yui_2.6.0/profilerviewer/profilerviewer-beta.js
+root/static/yui_2.6.0/profilerviewer/README
+root/static/yui_2.6.0/reset-fonts-grids/README
+root/static/yui_2.6.0/reset-fonts-grids/reset-fonts-grids.css
+root/static/yui_2.6.0/reset-fonts/README
+root/static/yui_2.6.0/reset-fonts/reset-fonts.css
+root/static/yui_2.6.0/reset/README
+root/static/yui_2.6.0/reset/reset-min.css
+root/static/yui_2.6.0/reset/reset.css
+root/static/yui_2.6.0/resize/assets/resize-core.css
+root/static/yui_2.6.0/resize/assets/skins/sam/layout_sprite.png
+root/static/yui_2.6.0/resize/assets/skins/sam/resize-skin.css
+root/static/yui_2.6.0/resize/assets/skins/sam/resize.css
+root/static/yui_2.6.0/resize/README
+root/static/yui_2.6.0/resize/resize-debug.js
+root/static/yui_2.6.0/resize/resize-min.js
+root/static/yui_2.6.0/resize/resize.js
+root/static/yui_2.6.0/selector/README
+root/static/yui_2.6.0/selector/selector-beta-debug.js
+root/static/yui_2.6.0/selector/selector-beta-min.js
+root/static/yui_2.6.0/selector/selector-beta.js
+root/static/yui_2.6.0/slider/assets/bg-fader.gif
+root/static/yui_2.6.0/slider/assets/bg-h.gif
+root/static/yui_2.6.0/slider/assets/bg-v-e.gif
+root/static/yui_2.6.0/slider/assets/bg-v.gif
+root/static/yui_2.6.0/slider/assets/left-thumb.png
+root/static/yui_2.6.0/slider/assets/right-thumb.png
+root/static/yui_2.6.0/slider/assets/skins/sam/slider-skin.css
+root/static/yui_2.6.0/slider/assets/skins/sam/slider.css
+root/static/yui_2.6.0/slider/assets/slider-core.css
+root/static/yui_2.6.0/slider/assets/thumb-bar.gif
+root/static/yui_2.6.0/slider/assets/thumb-e.gif
+root/static/yui_2.6.0/slider/assets/thumb-fader.gif
+root/static/yui_2.6.0/slider/assets/thumb-n.gif
+root/static/yui_2.6.0/slider/assets/thumb-s.gif
+root/static/yui_2.6.0/slider/assets/thumb-w.gif
+root/static/yui_2.6.0/slider/README
+root/static/yui_2.6.0/slider/slider-debug.js
+root/static/yui_2.6.0/slider/slider-min.js
+root/static/yui_2.6.0/slider/slider.js
+root/static/yui_2.6.0/tabview/assets/border_tabs.css
+root/static/yui_2.6.0/tabview/assets/loading.gif
+root/static/yui_2.6.0/tabview/assets/skin-sam.css
+root/static/yui_2.6.0/tabview/assets/skins/sam/tabview-skin.css
+root/static/yui_2.6.0/tabview/assets/skins/sam/tabview.css
+root/static/yui_2.6.0/tabview/assets/tabview-core.css
+root/static/yui_2.6.0/tabview/assets/tabview.css
+root/static/yui_2.6.0/tabview/README
+root/static/yui_2.6.0/tabview/tabview-debug.js
+root/static/yui_2.6.0/tabview/tabview-min.js
+root/static/yui_2.6.0/tabview/tabview.js
+root/static/yui_2.6.0/treeview/assets/skins/sam/loading.gif
+root/static/yui_2.6.0/treeview/assets/skins/sam/treeview-loading.gif
+root/static/yui_2.6.0/treeview/assets/skins/sam/treeview-skin.css
+root/static/yui_2.6.0/treeview/assets/skins/sam/treeview-sprite.gif
+root/static/yui_2.6.0/treeview/assets/skins/sam/treeview.css
+root/static/yui_2.6.0/treeview/assets/sprite-menu.gif
+root/static/yui_2.6.0/treeview/assets/sprite-orig.gif
+root/static/yui_2.6.0/treeview/assets/treeview-core.css
+root/static/yui_2.6.0/treeview/assets/treeview-loading.gif
+root/static/yui_2.6.0/treeview/assets/treeview-menu.css
+root/static/yui_2.6.0/treeview/assets/treeview.css
+root/static/yui_2.6.0/treeview/README
+root/static/yui_2.6.0/treeview/treeview-debug.js
+root/static/yui_2.6.0/treeview/treeview-min.js
+root/static/yui_2.6.0/treeview/treeview.js
+root/static/yui_2.6.0/uploader/assets/uploader.swf
+root/static/yui_2.6.0/uploader/README
+root/static/yui_2.6.0/uploader/uploader-experimental-debug.js
+root/static/yui_2.6.0/uploader/uploader-experimental-min.js
+root/static/yui_2.6.0/uploader/uploader-experimental.js
+root/static/yui_2.6.0/utilities/README
+root/static/yui_2.6.0/utilities/utilities.js
+root/static/yui_2.6.0/yahoo-dom-event/README
+root/static/yui_2.6.0/yahoo-dom-event/yahoo-dom-event.js
+root/static/yui_2.6.0/yahoo/README
+root/static/yui_2.6.0/yahoo/yahoo-debug.js
+root/static/yui_2.6.0/yahoo/yahoo-min.js
+root/static/yui_2.6.0/yahoo/yahoo.js
+root/static/yui_2.6.0/yuiloader-dom-event/README
+root/static/yui_2.6.0/yuiloader-dom-event/yuiloader-dom-event.js
+root/static/yui_2.6.0/yuiloader/README
+root/static/yui_2.6.0/yuiloader/yuiloader-debug.js
+root/static/yui_2.6.0/yuiloader/yuiloader-min.js
+root/static/yui_2.6.0/yuiloader/yuiloader.js
+root/static/yui_2.6.0/yuitest/assets/skins/sam/yuitest-skin.css
+root/static/yui_2.6.0/yuitest/assets/skins/sam/yuitest.css
+root/static/yui_2.6.0/yuitest/assets/testlogger.css
+root/static/yui_2.6.0/yuitest/assets/yuitest-core.css
+root/static/yui_2.6.0/yuitest/README
+root/static/yui_2.6.0/yuitest/yuitest-debug.js
+root/static/yui_2.6.0/yuitest/yuitest-min.js
+root/static/yui_2.6.0/yuitest/yuitest.js
+root/static/yui_2.6.0/yuitest/yuitest_core-debug.js
+root/static/yui_2.6.0/yuitest/yuitest_core-min.js
+root/static/yui_2.6.0/yuitest/yuitest_core.js
 script/deploy.sh
 script/i18n_todo.pl
 script/parley_cgi.pl



