<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Parley-svn] r176 - / trunk/root/static trunk/root/static/magic trunk/root/static/magic/src trunk/root/static/magic/src/animation trunk/root/static/magic/src/collections trunk/root/static/magic/src/compat trunk/root/static/magic/src/crypto trunk/root/static/magic/src/data trunk/root/static/magic/src/data/format trunk/root/static/magic/src/data/provider trunk/root/static/magic/src/debug trunk/root/static/magic/src/dnd trunk/root/static/magic/src/event trunk/root/static/magic/src/flash trunk/root/static/magic/src/flash/flash6 trunk/root/static/magic/src/flash/flash8 trunk/root/static/magic/src/fx trunk/root/static/magic/src/graphics trunk/root/static/magic/src/graphics/color trunk/root/static/magic/src/html trunk/root/static/magic/src/html/images trunk/root/static/magic/src/i18n trunk/root/static/magic/src/io trunk/root/static/magic/src/lang trunk/root/static/magic/src/lfx trunk/root/static/magic/src/logging trunk/root/static/magic/src/math trunk/root/static/magic/src/reflect trun! k/root/static/magic/src/rpc trunk/root/static/magic/src/selection trunk/root/static/magic/src/storage trunk/root/static/magic/src/string trunk/root/static/magic/src/text trunk/root/static/magic/src/undo trunk/root/static/magic/src/uri trunk/root/static/magic/src/uuid trunk/root/static/magic/src/validate trunk/root/static/magic/src/widget trunk/root/static/magic/src/widget/demoEngine trunk/root/static/magic/src/widget/demoEngine/templates trunk/root/static/magic/src/widget/demoEngine/templates/images trunk/root/static/magic/src/widget/html trunk/root/static/magic/src/widget/svg trunk/root/static/magic/src/widget/templates trunk/root/static/magic/src/widget/templates/buttons trunk/root/static/magic/src/widget/templates/images trunk/root/static/magic/src/widget/templates/images/Tree trunk/root/static/magic/src/widget/vml trunk/root/static/magic/src/xml
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/parley-svn/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:parley-svn%40lists.berlios.de?Subject=Re%3A%20%5BParley-svn%5D%20r176%20-%20/%20trunk/root/static%20trunk/root/static/magic%0A%20trunk/root/static/magic/src%20trunk/root/static/magic/src/animation%0A%20trunk/root/static/magic/src/collections%20trunk/root/static/magic/src/compat%0A%20trunk/root/static/magic/src/crypto%20trunk/root/static/magic/src/data%0A%20trunk/root/static/magic/src/data/format%0A%20trunk/root/static/magic/src/data/provider%20trunk/root/static/magic/src/debug%0A%20trunk/root/static/magic/src/dnd%20trunk/root/static/magic/src/event%0A%20trunk/root/static/magic/src/flash%20trunk/root/static/magic/src/flash/flash6%0A%20trunk/root/static/magic/src/flash/flash8%20trunk/root/static/magic/src/fx%0A%20trunk/root/static/magic/src/graphics%0A%20trunk/root/static/magic/src/graphics/color%20trunk/root/static/magic/src/html%0A%20trunk/root/static/magic/src/html/images%20trunk/root/static/magic/src/i18n%0A%20trunk/root/static/magic/src/io%20trunk/root/static/magic/src/lang%0A%20trunk/root/static/magic/src/lfx%20trunk/root/static/magic/src/logging%0A%20trunk/root/static/magic/src/math%20trunk/root/static/magic/src/reflect%20trun%21%0A%20k/root/static/magic/src/rpc%20trunk/root/static/magic/src/selection%0A%20trunk/root/static/magic/src/storage%20trunk/root/static/magic/src/string%0A%20trunk/root/static/magic/src/text%20trunk/root/static/magic/src/undo%0A%20trunk/root/static/magic/src/uri%20trunk/root/static/magic/src/uuid%0A%20trunk/root/static/magic/src/validate%20trunk/root/static/magic/src/widget%0A%20trunk/root/static/magic/src/widget/demoEngine%0A%20trunk/root/static/magic/src/widget/demoEngine/templates%0A%20trunk/root/static/magic/src/widget/demoEngine/templates/images%0A%20trunk/root/static/magic/src/widget/html%0A%20trunk/root/static/magic/src/widget/svg%0A%20trunk/root/static/magic/src/widget/templates%0A%20trunk/root/static/magic/src/widget/templates/buttons%0A%20trunk/root/static/magic/src/widget/templates/images%0A%20trunk/root/static/magic/src/widget/templates/images/Tree%0A%20trunk/root/static/magic/src/widget/vml%20trunk/root/static/magic/src/xml&In-Reply-To=%3C200607191619.k6JGJeEx017936%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000064.html">
   <LINK REL="Next"  HREF="000065.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Parley-svn] r176 - / trunk/root/static trunk/root/static/magic trunk/root/static/magic/src trunk/root/static/magic/src/animation trunk/root/static/magic/src/collections trunk/root/static/magic/src/compat trunk/root/static/magic/src/crypto trunk/root/static/magic/src/data trunk/root/static/magic/src/data/format trunk/root/static/magic/src/data/provider trunk/root/static/magic/src/debug trunk/root/static/magic/src/dnd trunk/root/static/magic/src/event trunk/root/static/magic/src/flash trunk/root/static/magic/src/flash/flash6 trunk/root/static/magic/src/flash/flash8 trunk/root/static/magic/src/fx trunk/root/static/magic/src/graphics trunk/root/static/magic/src/graphics/color trunk/root/static/magic/src/html trunk/root/static/magic/src/html/images trunk/root/static/magic/src/i18n trunk/root/static/magic/src/io trunk/root/static/magic/src/lang trunk/root/static/magic/src/lfx trunk/root/static/magic/src/logging trunk/root/static/magic/src/math trunk/root/static/magic/src/reflect trun! k/root/static/magic/src/rpc trunk/root/static/magic/src/selection trunk/root/static/magic/src/storage trunk/root/static/magic/src/string trunk/root/static/magic/src/text trunk/root/static/magic/src/undo trunk/root/static/magic/src/uri trunk/root/static/magic/src/uuid trunk/root/static/magic/src/validate trunk/root/static/magic/src/widget trunk/root/static/magic/src/widget/demoEngine trunk/root/static/magic/src/widget/demoEngine/templates trunk/root/static/magic/src/widget/demoEngine/templates/images trunk/root/static/magic/src/widget/html trunk/root/static/magic/src/widget/svg trunk/root/static/magic/src/widget/templates trunk/root/static/magic/src/widget/templates/buttons trunk/root/static/magic/src/widget/templates/images trunk/root/static/magic/src/widget/templates/images/Tree trunk/root/static/magic/src/widget/vml trunk/root/static/magic/src/xml</H1>
    <B>chiselwright at BerliOS</B> 
    <A HREF="mailto:parley-svn%40lists.berlios.de?Subject=Re%3A%20%5BParley-svn%5D%20r176%20-%20/%20trunk/root/static%20trunk/root/static/magic%0A%20trunk/root/static/magic/src%20trunk/root/static/magic/src/animation%0A%20trunk/root/static/magic/src/collections%20trunk/root/static/magic/src/compat%0A%20trunk/root/static/magic/src/crypto%20trunk/root/static/magic/src/data%0A%20trunk/root/static/magic/src/data/format%0A%20trunk/root/static/magic/src/data/provider%20trunk/root/static/magic/src/debug%0A%20trunk/root/static/magic/src/dnd%20trunk/root/static/magic/src/event%0A%20trunk/root/static/magic/src/flash%20trunk/root/static/magic/src/flash/flash6%0A%20trunk/root/static/magic/src/flash/flash8%20trunk/root/static/magic/src/fx%0A%20trunk/root/static/magic/src/graphics%0A%20trunk/root/static/magic/src/graphics/color%20trunk/root/static/magic/src/html%0A%20trunk/root/static/magic/src/html/images%20trunk/root/static/magic/src/i18n%0A%20trunk/root/static/magic/src/io%20trunk/root/static/magic/src/lang%0A%20trunk/root/static/magic/src/lfx%20trunk/root/static/magic/src/logging%0A%20trunk/root/static/magic/src/math%20trunk/root/static/magic/src/reflect%20trun%21%0A%20k/root/static/magic/src/rpc%20trunk/root/static/magic/src/selection%0A%20trunk/root/static/magic/src/storage%20trunk/root/static/magic/src/string%0A%20trunk/root/static/magic/src/text%20trunk/root/static/magic/src/undo%0A%20trunk/root/static/magic/src/uri%20trunk/root/static/magic/src/uuid%0A%20trunk/root/static/magic/src/validate%20trunk/root/static/magic/src/widget%0A%20trunk/root/static/magic/src/widget/demoEngine%0A%20trunk/root/static/magic/src/widget/demoEngine/templates%0A%20trunk/root/static/magic/src/widget/demoEngine/templates/images%0A%20trunk/root/static/magic/src/widget/html%0A%20trunk/root/static/magic/src/widget/svg%0A%20trunk/root/static/magic/src/widget/templates%0A%20trunk/root/static/magic/src/widget/templates/buttons%0A%20trunk/root/static/magic/src/widget/templates/images%0A%20trunk/root/static/magic/src/widget/templates/images/Tree%0A%20trunk/root/static/magic/src/widget/vml%20trunk/root/static/magic/src/xml&In-Reply-To=%3C200607191619.k6JGJeEx017936%40sheep.berlios.de%3E"
       TITLE="[Parley-svn] r176 - / trunk/root/static trunk/root/static/magic trunk/root/static/magic/src trunk/root/static/magic/src/animation trunk/root/static/magic/src/collections trunk/root/static/magic/src/compat trunk/root/static/magic/src/crypto trunk/root/static/magic/src/data trunk/root/static/magic/src/data/format trunk/root/static/magic/src/data/provider trunk/root/static/magic/src/debug trunk/root/static/magic/src/dnd trunk/root/static/magic/src/event trunk/root/static/magic/src/flash trunk/root/static/magic/src/flash/flash6 trunk/root/static/magic/src/flash/flash8 trunk/root/static/magic/src/fx trunk/root/static/magic/src/graphics trunk/root/static/magic/src/graphics/color trunk/root/static/magic/src/html trunk/root/static/magic/src/html/images trunk/root/static/magic/src/i18n trunk/root/static/magic/src/io trunk/root/static/magic/src/lang trunk/root/static/magic/src/lfx trunk/root/static/magic/src/logging trunk/root/static/magic/src/math trunk/root/static/magic/src/reflect trun! k/root/static/magic/src/rpc trunk/root/static/magic/src/selection trunk/root/static/magic/src/storage trunk/root/static/magic/src/string trunk/root/static/magic/src/text trunk/root/static/magic/src/undo trunk/root/static/magic/src/uri trunk/root/static/magic/src/uuid trunk/root/static/magic/src/validate trunk/root/static/magic/src/widget trunk/root/static/magic/src/widget/demoEngine trunk/root/static/magic/src/widget/demoEngine/templates trunk/root/static/magic/src/widget/demoEngine/templates/images trunk/root/static/magic/src/widget/html trunk/root/static/magic/src/widget/svg trunk/root/static/magic/src/widget/templates trunk/root/static/magic/src/widget/templates/buttons trunk/root/static/magic/src/widget/templates/images trunk/root/static/magic/src/widget/templates/images/Tree trunk/root/static/magic/src/widget/vml trunk/root/static/magic/src/xml">chiselwright at mail.berlios.de
       </A><BR>
    <I>Wed Jul 19 18:19:40 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000064.html">[Parley-svn] r175 - / trunk/issues trunk/issues/model_method	trunk/issues/model_method/ClassMethod	trunk/issues/model_method/ClassMethod/db	trunk/issues/model_method/ClassMethod/lib	trunk/issues/model_method/ClassMethod/lib/ClassMethod	trunk/issues/model_method/ClassMethod/lib/ClassMethod/Controller	trunk/issues/model_method/ClassMethod/lib/ClassMethod/Model	trunk/issues/model_method/ClassMethod/lib/ClassMethod/Model/CMDB	trunk/issues/model_method/ClassMethod/root	trunk/issues/model_method/ClassMethod/root/static	trunk/issues/model_method/ClassMethod/root/static/images	trunk/issues/model_method/ClassMethod/script	trunk/issues/model_method/ClassMethod/t
</A></li>
        <LI>Next message: <A HREF="000065.html">[Parley-svn] r177 - / trunk/script
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#75">[ date ]</a>
              <a href="thread.html#75">[ thread ]</a>
              <a href="subject.html#75">[ subject ]</a>
              <a href="author.html#75">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: chiselwright
Date: 2006-07-19 18:19:27 +0200 (Wed, 19 Jul 2006)
New Revision: 176

Added:
   trunk/root/static/magic/
   trunk/root/static/magic/dojo.js
   trunk/root/static/magic/iframe_history.html
   trunk/root/static/magic/src/
   trunk/root/static/magic/src/AdapterRegistry.js
   trunk/root/static/magic/src/Deferred.js
   trunk/root/static/magic/src/animation.js
   trunk/root/static/magic/src/animation/
   trunk/root/static/magic/src/animation/Animation.js
   trunk/root/static/magic/src/animation/AnimationEvent.js
   trunk/root/static/magic/src/animation/AnimationSequence.js
   trunk/root/static/magic/src/animation/Timer.js
   trunk/root/static/magic/src/animation/__package__.js
   trunk/root/static/magic/src/behavior.js
   trunk/root/static/magic/src/bootstrap1.js
   trunk/root/static/magic/src/bootstrap2.js
   trunk/root/static/magic/src/browser_debug.js
   trunk/root/static/magic/src/collections/
   trunk/root/static/magic/src/collections/ArrayList.js
   trunk/root/static/magic/src/collections/BinaryTree.js
   trunk/root/static/magic/src/collections/Collections.js
   trunk/root/static/magic/src/collections/Dictionary.js
   trunk/root/static/magic/src/collections/Graph.js
   trunk/root/static/magic/src/collections/Queue.js
   trunk/root/static/magic/src/collections/Set.js
   trunk/root/static/magic/src/collections/SkipList.js
   trunk/root/static/magic/src/collections/SortedList.js
   trunk/root/static/magic/src/collections/Stack.js
   trunk/root/static/magic/src/collections/__package__.js
   trunk/root/static/magic/src/compat/
   trunk/root/static/magic/src/compat/0.2.2.js
   trunk/root/static/magic/src/crypto.js
   trunk/root/static/magic/src/crypto/
   trunk/root/static/magic/src/crypto/Blowfish.js
   trunk/root/static/magic/src/crypto/LICENSE
   trunk/root/static/magic/src/crypto/MD5.js
   trunk/root/static/magic/src/crypto/Rijndael.js
   trunk/root/static/magic/src/crypto/SHA1.js
   trunk/root/static/magic/src/crypto/SHA256.js
   trunk/root/static/magic/src/crypto/__package__.js
   trunk/root/static/magic/src/data.js
   trunk/root/static/magic/src/data/
   trunk/root/static/magic/src/data/Attribute.js
   trunk/root/static/magic/src/data/Item.js
   trunk/root/static/magic/src/data/Kind.js
   trunk/root/static/magic/src/data/Observable.js
   trunk/root/static/magic/src/data/ResultSet.js
   trunk/root/static/magic/src/data/Type.js
   trunk/root/static/magic/src/data/Value.js
   trunk/root/static/magic/src/data/__package__.js
   trunk/root/static/magic/src/data/format/
   trunk/root/static/magic/src/data/format/Csv.js
   trunk/root/static/magic/src/data/format/Json.js
   trunk/root/static/magic/src/data/provider/
   trunk/root/static/magic/src/data/provider/Base.js
   trunk/root/static/magic/src/data/provider/Delicious.js
   trunk/root/static/magic/src/data/provider/FlatFile.js
   trunk/root/static/magic/src/data/provider/JotSpot.js
   trunk/root/static/magic/src/data/provider/MySql.js
   trunk/root/static/magic/src/data/to_do.txt
   trunk/root/static/magic/src/date.js
   trunk/root/static/magic/src/debug.js
   trunk/root/static/magic/src/debug/
   trunk/root/static/magic/src/debug/Firebug.js
   trunk/root/static/magic/src/debug/arrow_hide.gif
   trunk/root/static/magic/src/debug/arrow_show.gif
   trunk/root/static/magic/src/debug/deep.html
   trunk/root/static/magic/src/debug/spacer.gif
   trunk/root/static/magic/src/dnd/
   trunk/root/static/magic/src/dnd/DragAndDrop.js
   trunk/root/static/magic/src/dnd/HtmlDragAndDrop.js
   trunk/root/static/magic/src/dnd/HtmlDragManager.js
   trunk/root/static/magic/src/dnd/HtmlDragMove.js
   trunk/root/static/magic/src/dnd/Sortable.js
   trunk/root/static/magic/src/dnd/TreeDragAndDrop.js
   trunk/root/static/magic/src/dnd/__package__.js
   trunk/root/static/magic/src/doc.js
   trunk/root/static/magic/src/dom.js
   trunk/root/static/magic/src/event.js
   trunk/root/static/magic/src/event/
   trunk/root/static/magic/src/event/__package__.js
   trunk/root/static/magic/src/event/browser.js
   trunk/root/static/magic/src/event/topic.js
   trunk/root/static/magic/src/experimental.js
   trunk/root/static/magic/src/flash.js
   trunk/root/static/magic/src/flash/
   trunk/root/static/magic/src/flash/flash6/
   trunk/root/static/magic/src/flash/flash6/DojoExternalInterface.as
   trunk/root/static/magic/src/flash/flash6/flash6_gateway.fla
   trunk/root/static/magic/src/flash/flash8/
   trunk/root/static/magic/src/flash/flash8/DojoExternalInterface.as
   trunk/root/static/magic/src/flash/flash8/ExpressInstall.as
   trunk/root/static/magic/src/fx/
   trunk/root/static/magic/src/fx/__package__.js
   trunk/root/static/magic/src/fx/html.js
   trunk/root/static/magic/src/fx/svg.js
   trunk/root/static/magic/src/graphics/
   trunk/root/static/magic/src/graphics/Colorspace.js
   trunk/root/static/magic/src/graphics/__package__.js
   trunk/root/static/magic/src/graphics/color.js
   trunk/root/static/magic/src/graphics/color/
   trunk/root/static/magic/src/graphics/color/hsl.js
   trunk/root/static/magic/src/graphics/color/hsv.js
   trunk/root/static/magic/src/hostenv_adobesvg.js
   trunk/root/static/magic/src/hostenv_browser.js
   trunk/root/static/magic/src/hostenv_dashboard.js
   trunk/root/static/magic/src/hostenv_jsc.js
   trunk/root/static/magic/src/hostenv_rhino.js
   trunk/root/static/magic/src/hostenv_spidermonkey.js
   trunk/root/static/magic/src/hostenv_svg.js
   trunk/root/static/magic/src/hostenv_wsh.js
   trunk/root/static/magic/src/html.js
   trunk/root/static/magic/src/html/
   trunk/root/static/magic/src/html/__package__.js
   trunk/root/static/magic/src/html/extras.js
   trunk/root/static/magic/src/html/images/
   trunk/root/static/magic/src/html/images/shadowB.png
   trunk/root/static/magic/src/html/images/shadowBL.png
   trunk/root/static/magic/src/html/images/shadowBR.png
   trunk/root/static/magic/src/html/images/shadowL.png
   trunk/root/static/magic/src/html/images/shadowR.png
   trunk/root/static/magic/src/html/images/shadowT.png
   trunk/root/static/magic/src/html/images/shadowTL.png
   trunk/root/static/magic/src/html/images/shadowTR..png
   trunk/root/static/magic/src/html/images/shadowTR.png
   trunk/root/static/magic/src/html/layout.js
   trunk/root/static/magic/src/html/shadow.js
   trunk/root/static/magic/src/i18n/
   trunk/root/static/magic/src/i18n/common.js
   trunk/root/static/magic/src/iCalendar.js
   trunk/root/static/magic/src/io.js
   trunk/root/static/magic/src/io/
   trunk/root/static/magic/src/io/BrowserIO.js
   trunk/root/static/magic/src/io/IframeIO.js
   trunk/root/static/magic/src/io/RepubsubIO.js
   trunk/root/static/magic/src/io/RhinoIO.js
   trunk/root/static/magic/src/io/ScriptSrcIO.js
   trunk/root/static/magic/src/io/ShortBusIO.js
   trunk/root/static/magic/src/io/ShortBusInit.html
   trunk/root/static/magic/src/io/__package__.js
   trunk/root/static/magic/src/io/cookie.js
   trunk/root/static/magic/src/io/cookies.js
   trunk/root/static/magic/src/json.js
   trunk/root/static/magic/src/lang.js
   trunk/root/static/magic/src/lang/
   trunk/root/static/magic/src/lang/Lang.js
   trunk/root/static/magic/src/lang/__package__.js
   trunk/root/static/magic/src/lang/array.js
   trunk/root/static/magic/src/lang/assert.js
   trunk/root/static/magic/src/lang/common.js
   trunk/root/static/magic/src/lang/declare.js
   trunk/root/static/magic/src/lang/extras.js
   trunk/root/static/magic/src/lang/func.js
   trunk/root/static/magic/src/lang/repr.js
   trunk/root/static/magic/src/lang/type.js
   trunk/root/static/magic/src/lfx/
   trunk/root/static/magic/src/lfx/Animation.js
   trunk/root/static/magic/src/lfx/__package__.js
   trunk/root/static/magic/src/lfx/extras.js
   trunk/root/static/magic/src/lfx/html.js
   trunk/root/static/magic/src/lfx/toggle.js
   trunk/root/static/magic/src/loader.js
   trunk/root/static/magic/src/loader_xd.js
   trunk/root/static/magic/src/logging/
   trunk/root/static/magic/src/logging/Logger.js
   trunk/root/static/magic/src/logging/__package__.js
   trunk/root/static/magic/src/math.js
   trunk/root/static/magic/src/math/
   trunk/root/static/magic/src/math/Math.js
   trunk/root/static/magic/src/math/__package__.js
   trunk/root/static/magic/src/math/curves.js
   trunk/root/static/magic/src/math/matrix.js
   trunk/root/static/magic/src/math/points.js
   trunk/root/static/magic/src/profile.js
   trunk/root/static/magic/src/reflect/
   trunk/root/static/magic/src/reflect/__package__.js
   trunk/root/static/magic/src/reflect/reflection.js
   trunk/root/static/magic/src/regexp.js
   trunk/root/static/magic/src/rpc/
   trunk/root/static/magic/src/rpc/Deferred.js
   trunk/root/static/magic/src/rpc/JotService.js
   trunk/root/static/magic/src/rpc/JsonService.js
   trunk/root/static/magic/src/rpc/RpcService.js
   trunk/root/static/magic/src/rpc/YahooService.js
   trunk/root/static/magic/src/rpc/__package__.js
   trunk/root/static/magic/src/rpc/yahoo.smd
   trunk/root/static/magic/src/selection/
   trunk/root/static/magic/src/selection/Selection.js
   trunk/root/static/magic/src/storage.js
   trunk/root/static/magic/src/storage/
   trunk/root/static/magic/src/storage/Storage.as
   trunk/root/static/magic/src/storage/__package__.js
   trunk/root/static/magic/src/storage/browser.js
   trunk/root/static/magic/src/storage/dashboard.js
   trunk/root/static/magic/src/storage/storage_dialog.fla
   trunk/root/static/magic/src/string.js
   trunk/root/static/magic/src/string/
   trunk/root/static/magic/src/string/Builder.js
   trunk/root/static/magic/src/string/__package__.js
   trunk/root/static/magic/src/string/common.js
   trunk/root/static/magic/src/string/extras.js
   trunk/root/static/magic/src/style.js
   trunk/root/static/magic/src/svg.js
   trunk/root/static/magic/src/text/
   trunk/root/static/magic/src/text/Builder.js
   trunk/root/static/magic/src/text/String.js
   trunk/root/static/magic/src/text/Text.js
   trunk/root/static/magic/src/text/__package__.js
   trunk/root/static/magic/src/text/textDirectory.js
   trunk/root/static/magic/src/undo/
   trunk/root/static/magic/src/undo/Manager.js
   trunk/root/static/magic/src/undo/__package__.js
   trunk/root/static/magic/src/undo/browser.js
   trunk/root/static/magic/src/uri/
   trunk/root/static/magic/src/uri/Uri.js
   trunk/root/static/magic/src/uri/__package__.js
   trunk/root/static/magic/src/uuid/
   trunk/root/static/magic/src/uuid/LightweightGenerator.js
   trunk/root/static/magic/src/uuid/NameBasedGenerator.js
   trunk/root/static/magic/src/uuid/NilGenerator.js
   trunk/root/static/magic/src/uuid/RandomGenerator.js
   trunk/root/static/magic/src/uuid/TimeBasedGenerator.js
   trunk/root/static/magic/src/uuid/Uuid.js
   trunk/root/static/magic/src/uuid/__package__.js
   trunk/root/static/magic/src/validate.js
   trunk/root/static/magic/src/validate/
   trunk/root/static/magic/src/validate/__package__.js
   trunk/root/static/magic/src/validate/check.js
   trunk/root/static/magic/src/validate/common.js
   trunk/root/static/magic/src/validate/datetime.js
   trunk/root/static/magic/src/validate/de.js
   trunk/root/static/magic/src/validate/jp.js
   trunk/root/static/magic/src/validate/us.js
   trunk/root/static/magic/src/validate/web.js
   trunk/root/static/magic/src/widget/
   trunk/root/static/magic/src/widget/AccordionContainer.js
   trunk/root/static/magic/src/widget/AccordionPane.js
   trunk/root/static/magic/src/widget/AnimatedPng.js
   trunk/root/static/magic/src/widget/Button.js
   trunk/root/static/magic/src/widget/Button2.js
   trunk/root/static/magic/src/widget/Chart.js
   trunk/root/static/magic/src/widget/Checkbox.js
   trunk/root/static/magic/src/widget/CiviCrmDatePicker.js
   trunk/root/static/magic/src/widget/ColorPalette.js
   trunk/root/static/magic/src/widget/ComboBox.js
   trunk/root/static/magic/src/widget/ContentPane.js
   trunk/root/static/magic/src/widget/ContextMenu.js
   trunk/root/static/magic/src/widget/DatePicker.js
   trunk/root/static/magic/src/widget/DebugConsole.js
   trunk/root/static/magic/src/widget/Dialog.js
   trunk/root/static/magic/src/widget/DocPane.js
   trunk/root/static/magic/src/widget/DomWidget.js
   trunk/root/static/magic/src/widget/DropdownButton.js
   trunk/root/static/magic/src/widget/DropdownContainer.js
   trunk/root/static/magic/src/widget/DropdownDatePicker.js
   trunk/root/static/magic/src/widget/Editor.js
   trunk/root/static/magic/src/widget/Editor2.js
   trunk/root/static/magic/src/widget/Editor2Toolbar.js
   trunk/root/static/magic/src/widget/FisheyeList.js
   trunk/root/static/magic/src/widget/FloatingPane.js
   trunk/root/static/magic/src/widget/GoogleMap.js
   trunk/root/static/magic/src/widget/HtmlWidget.js
   trunk/root/static/magic/src/widget/InlineEditBox.js
   trunk/root/static/magic/src/widget/LayoutContainer.js
   trunk/root/static/magic/src/widget/LinkPane.js
   trunk/root/static/magic/src/widget/Manager.js
   trunk/root/static/magic/src/widget/Menu.js
   trunk/root/static/magic/src/widget/Menu2.js
   trunk/root/static/magic/src/widget/MenuItem.js
   trunk/root/static/magic/src/widget/MonthlyCalendar.js
   trunk/root/static/magic/src/widget/Parse.js
   trunk/root/static/magic/src/widget/PopUpButton.js
   trunk/root/static/magic/src/widget/ResizableTextarea.js
   trunk/root/static/magic/src/widget/ResizeHandle.js
   trunk/root/static/magic/src/widget/RichText.js
   trunk/root/static/magic/src/widget/Rounded.js
   trunk/root/static/magic/src/widget/Select.js
   trunk/root/static/magic/src/widget/Show.js
   trunk/root/static/magic/src/widget/ShowAction.js
   trunk/root/static/magic/src/widget/ShowSlide.js
   trunk/root/static/magic/src/widget/SimpleDropdownButtons.js
   trunk/root/static/magic/src/widget/SlideShow.js
   trunk/root/static/magic/src/widget/SortableTable.js
   trunk/root/static/magic/src/widget/Spinner.js
   trunk/root/static/magic/src/widget/SplitContainer.js
   trunk/root/static/magic/src/widget/SvgButton.js
   trunk/root/static/magic/src/widget/SvgWidget.js
   trunk/root/static/magic/src/widget/SwtWidget.js
   trunk/root/static/magic/src/widget/TabContainer.js
   trunk/root/static/magic/src/widget/TaskBar.js
   trunk/root/static/magic/src/widget/TimePicker.js
   trunk/root/static/magic/src/widget/TitlePane.js
   trunk/root/static/magic/src/widget/Toggler.js
   trunk/root/static/magic/src/widget/Toolbar.js
   trunk/root/static/magic/src/widget/Tooltip.js
   trunk/root/static/magic/src/widget/Tree.js
   trunk/root/static/magic/src/widget/TreeBasicController.js
   trunk/root/static/magic/src/widget/TreeContextMenu.js
   trunk/root/static/magic/src/widget/TreeControllerExtension.js
   trunk/root/static/magic/src/widget/TreeLoadingController.js
   trunk/root/static/magic/src/widget/TreeNode.js
   trunk/root/static/magic/src/widget/TreeRPCController.js
   trunk/root/static/magic/src/widget/TreeSelector.js
   trunk/root/static/magic/src/widget/Widget.js
   trunk/root/static/magic/src/widget/Wizard.js
   trunk/root/static/magic/src/widget/YahooMap.js
   trunk/root/static/magic/src/widget/__package__.js
   trunk/root/static/magic/src/widget/demoEngine/
   trunk/root/static/magic/src/widget/demoEngine/DemoContainer.js
   trunk/root/static/magic/src/widget/demoEngine/DemoItem.js
   trunk/root/static/magic/src/widget/demoEngine/DemoNavigator.js
   trunk/root/static/magic/src/widget/demoEngine/DemoPane.js
   trunk/root/static/magic/src/widget/demoEngine/SourcePane.js
   trunk/root/static/magic/src/widget/demoEngine/__package__.js
   trunk/root/static/magic/src/widget/demoEngine/templates/
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.css
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.html
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.css
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.html
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.css
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.html
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.css
   trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.html
   trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.css
   trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.html
   trunk/root/static/magic/src/widget/demoEngine/templates/general.css
   trunk/root/static/magic/src/widget/demoEngine/templates/images/
   trunk/root/static/magic/src/widget/demoEngine/templates/images/test_thumb.gif
   trunk/root/static/magic/src/widget/demoEngine/templates/images/viewDemo.png
   trunk/root/static/magic/src/widget/html/
   trunk/root/static/magic/src/widget/html/AccordionPane.js
   trunk/root/static/magic/src/widget/html/Button2.js
   trunk/root/static/magic/src/widget/html/Checkbox.js
   trunk/root/static/magic/src/widget/html/ComboBox.js
   trunk/root/static/magic/src/widget/html/ContentPane.js
   trunk/root/static/magic/src/widget/html/ContextMenu.js
   trunk/root/static/magic/src/widget/html/DatePicker.js
   trunk/root/static/magic/src/widget/html/DebugConsole.js
   trunk/root/static/magic/src/widget/html/DocPane.js
   trunk/root/static/magic/src/widget/html/DropdownButton.js
   trunk/root/static/magic/src/widget/html/GoogleMap.js
   trunk/root/static/magic/src/widget/html/LinkPane.js
   trunk/root/static/magic/src/widget/html/Menu.js
   trunk/root/static/magic/src/widget/html/MenuItem.js
   trunk/root/static/magic/src/widget/html/MonthlyCalendar.js
   trunk/root/static/magic/src/widget/html/Show.js
   trunk/root/static/magic/src/widget/html/ShowAction.js
   trunk/root/static/magic/src/widget/html/ShowSlide.js
   trunk/root/static/magic/src/widget/html/Slider.js
   trunk/root/static/magic/src/widget/html/SortableTable.js
   trunk/root/static/magic/src/widget/html/Spinner.js
   trunk/root/static/magic/src/widget/html/TaskBar.js
   trunk/root/static/magic/src/widget/html/TimePicker.js
   trunk/root/static/magic/src/widget/html/TitlePane.js
   trunk/root/static/magic/src/widget/html/Tooltip.js
   trunk/root/static/magic/src/widget/html/YahooMap.js
   trunk/root/static/magic/src/widget/html/stabile.js
   trunk/root/static/magic/src/widget/svg/
   trunk/root/static/magic/src/widget/svg/Chart.js
   trunk/root/static/magic/src/widget/templates/
   trunk/root/static/magic/src/widget/templates/DemoEngine.html
   trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.css
   trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.html
   trunk/root/static/magic/src/widget/templates/HtmlCheckBox.html
   trunk/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html
   trunk/root/static/magic/src/widget/templates/HtmlComboBox.css
   trunk/root/static/magic/src/widget/templates/HtmlComboBox.html
   trunk/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html
   trunk/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html
   trunk/root/static/magic/src/widget/templates/HtmlDatePicker.css
   trunk/root/static/magic/src/widget/templates/HtmlDatePicker.html
   trunk/root/static/magic/src/widget/templates/HtmlDialog.html
   trunk/root/static/magic/src/widget/templates/HtmlDocPane.css
   trunk/root/static/magic/src/widget/templates/HtmlDocPane.html
   trunk/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html
   trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.css
   trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.html
   trunk/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html
   trunk/root/static/magic/src/widget/templates/HtmlFisheyeList.css
   trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.css
   trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.html
   trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.css
   trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.html
   trunk/root/static/magic/src/widget/templates/HtmlMenu2.css
   trunk/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html
   trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css
   trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html
   trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.css
   trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.html
   trunk/root/static/magic/src/widget/templates/HtmlResizeHandle.css
   trunk/root/static/magic/src/widget/templates/HtmlShow.css
   trunk/root/static/magic/src/widget/templates/HtmlShow.html
   trunk/root/static/magic/src/widget/templates/HtmlShowSlide.css
   trunk/root/static/magic/src/widget/templates/HtmlShowSlide.html
   trunk/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css
   trunk/root/static/magic/src/widget/templates/HtmlSlideShow.css
   trunk/root/static/magic/src/widget/templates/HtmlSlideShow.html
   trunk/root/static/magic/src/widget/templates/HtmlSlider.css
   trunk/root/static/magic/src/widget/templates/HtmlSlider.html
   trunk/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html
   trunk/root/static/magic/src/widget/templates/HtmlSliderVertical.html
   trunk/root/static/magic/src/widget/templates/HtmlSpinner.css
   trunk/root/static/magic/src/widget/templates/HtmlSpinner.html
   trunk/root/static/magic/src/widget/templates/HtmlSplitContainer.css
   trunk/root/static/magic/src/widget/templates/HtmlTabContainer.css
   trunk/root/static/magic/src/widget/templates/HtmlTabContainer.html
   trunk/root/static/magic/src/widget/templates/HtmlTaskBar.css
   trunk/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html
   trunk/root/static/magic/src/widget/templates/HtmlTimePicker.css
   trunk/root/static/magic/src/widget/templates/HtmlTimePicker.html
   trunk/root/static/magic/src/widget/templates/HtmlToolbar.css
   trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css
   trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html
   trunk/root/static/magic/src/widget/templates/Menu.css
   trunk/root/static/magic/src/widget/templates/PopUpButton.css
   trunk/root/static/magic/src/widget/templates/TitlePane.html
   trunk/root/static/magic/src/widget/templates/Tree.css
   trunk/root/static/magic/src/widget/templates/Wizard.css
   trunk/root/static/magic/src/widget/templates/Wizard.html
   trunk/root/static/magic/src/widget/templates/buttons/
   trunk/root/static/magic/src/widget/templates/buttons/-.gif
   trunk/root/static/magic/src/widget/templates/buttons/aggregate.gif
   trunk/root/static/magic/src/widget/templates/buttons/backcolor.gif
   trunk/root/static/magic/src/widget/templates/buttons/bg-fade.png
   trunk/root/static/magic/src/widget/templates/buttons/bold.gif
   trunk/root/static/magic/src/widget/templates/buttons/cancel.gif
   trunk/root/static/magic/src/widget/templates/buttons/copy.gif
   trunk/root/static/magic/src/widget/templates/buttons/createlink.gif
   trunk/root/static/magic/src/widget/templates/buttons/cut.gif
   trunk/root/static/magic/src/widget/templates/buttons/delete.gif
   trunk/root/static/magic/src/widget/templates/buttons/forecolor.gif
   trunk/root/static/magic/src/widget/templates/buttons/hilitecolor.gif
   trunk/root/static/magic/src/widget/templates/buttons/indent.gif
   trunk/root/static/magic/src/widget/templates/buttons/inserthorizontalrule.gif
   trunk/root/static/magic/src/widget/templates/buttons/insertimage.gif
   trunk/root/static/magic/src/widget/templates/buttons/insertorderedlist.gif
   trunk/root/static/magic/src/widget/templates/buttons/inserttable.gif
   trunk/root/static/magic/src/widget/templates/buttons/insertunorderedlist.gif
   trunk/root/static/magic/src/widget/templates/buttons/italic.gif
   trunk/root/static/magic/src/widget/templates/buttons/justifycenter.gif
   trunk/root/static/magic/src/widget/templates/buttons/justifyfull.gif
   trunk/root/static/magic/src/widget/templates/buttons/justifyleft.gif
   trunk/root/static/magic/src/widget/templates/buttons/justifyright.gif
   trunk/root/static/magic/src/widget/templates/buttons/left_to_right.gif
   trunk/root/static/magic/src/widget/templates/buttons/list_bullet_indent.gif
   trunk/root/static/magic/src/widget/templates/buttons/list_bullet_outdent.gif
   trunk/root/static/magic/src/widget/templates/buttons/list_num_indent.gif
   trunk/root/static/magic/src/widget/templates/buttons/list_num_outdent.gif
   trunk/root/static/magic/src/widget/templates/buttons/outdent.gif
   trunk/root/static/magic/src/widget/templates/buttons/paste.gif
   trunk/root/static/magic/src/widget/templates/buttons/redo.gif
   trunk/root/static/magic/src/widget/templates/buttons/removeformat.gif
   trunk/root/static/magic/src/widget/templates/buttons/right_to_left.gif
   trunk/root/static/magic/src/widget/templates/buttons/save.gif
   trunk/root/static/magic/src/widget/templates/buttons/space.gif
   trunk/root/static/magic/src/widget/templates/buttons/strikethrough.gif
   trunk/root/static/magic/src/widget/templates/buttons/subscript.gif
   trunk/root/static/magic/src/widget/templates/buttons/superscript.gif
   trunk/root/static/magic/src/widget/templates/buttons/underline.gif
   trunk/root/static/magic/src/widget/templates/buttons/undo.gif
   trunk/root/static/magic/src/widget/templates/buttons/wikiword.gif
   trunk/root/static/magic/src/widget/templates/check_disabled_off.gif
   trunk/root/static/magic/src/widget/templates/check_disabled_on.gif
   trunk/root/static/magic/src/widget/templates/check_hover_off.gif
   trunk/root/static/magic/src/widget/templates/check_hover_on.gif
   trunk/root/static/magic/src/widget/templates/check_off.gif
   trunk/root/static/magic/src/widget/templates/check_on.gif
   trunk/root/static/magic/src/widget/templates/decrementMonth.gif
   trunk/root/static/magic/src/widget/templates/decrementWeek.gif
   trunk/root/static/magic/src/widget/templates/grabCorner.gif
   trunk/root/static/magic/src/widget/templates/images/
   trunk/root/static/magic/src/widget/templates/images/Tree/
   trunk/root/static/magic/src/widget/templates/images/Tree/Tree.css
   trunk/root/static/magic/src/widget/templates/images/Tree/blank.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/closed.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/document.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/minus.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/plus.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/transparent.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_blank.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_child.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_expand_minus.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_expand_plus.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_c.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_l.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_p.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_t.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_v.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_x.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_y.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_z.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_loading.gif
   trunk/root/static/magic/src/widget/templates/images/Tree/treenode_loading.jpg
   trunk/root/static/magic/src/widget/templates/images/bdYearBg.1.gif
   trunk/root/static/magic/src/widget/templates/images/bdYearBg.gif
   trunk/root/static/magic/src/widget/templates/images/blank.gif
   trunk/root/static/magic/src/widget/templates/images/combo_box_arrow.png
   trunk/root/static/magic/src/widget/templates/images/dateIcon.gif
   trunk/root/static/magic/src/widget/templates/images/decrementMonth.gif
   trunk/root/static/magic/src/widget/templates/images/decrementMonth.png
   trunk/root/static/magic/src/widget/templates/images/dpBg.gif
   trunk/root/static/magic/src/widget/templates/images/dpCurveBL.png
   trunk/root/static/magic/src/widget/templates/images/dpCurveBR.png
   trunk/root/static/magic/src/widget/templates/images/dpCurveTL.png
   trunk/root/static/magic/src/widget/templates/images/dpCurveTR.png
   trunk/root/static/magic/src/widget/templates/images/dpHorizLine.gif
   trunk/root/static/magic/src/widget/templates/images/dpHorizLineFoot.gif
   trunk/root/static/magic/src/widget/templates/images/dpMonthBg.gif
   trunk/root/static/magic/src/widget/templates/images/dpMonthBg.png
   trunk/root/static/magic/src/widget/templates/images/dpVertLine.gif
   trunk/root/static/magic/src/widget/templates/images/dpYearBg.png
   trunk/root/static/magic/src/widget/templates/images/dropdownButtonsArrow-disabled.gif
   trunk/root/static/magic/src/widget/templates/images/dropdownButtonsArrow.gif
   trunk/root/static/magic/src/widget/templates/images/floatingPaneClose.gif
   trunk/root/static/magic/src/widget/templates/images/floatingPaneMaximize.gif
   trunk/root/static/magic/src/widget/templates/images/floatingPaneMinimize.gif
   trunk/root/static/magic/src/widget/templates/images/floatingPaneRestore.gif
   trunk/root/static/magic/src/widget/templates/images/incrementMonth.gif
   trunk/root/static/magic/src/widget/templates/images/incrementMonth.png
   trunk/root/static/magic/src/widget/templates/images/no.gif
   trunk/root/static/magic/src/widget/templates/images/no.svg
   trunk/root/static/magic/src/widget/templates/images/scBackground.gif
   trunk/root/static/magic/src/widget/templates/images/slider-bg-vert.gif
   trunk/root/static/magic/src/widget/templates/images/slider-bg.gif
   trunk/root/static/magic/src/widget/templates/images/slider-button-horz.png
   trunk/root/static/magic/src/widget/templates/images/slider-button-vert.png
   trunk/root/static/magic/src/widget/templates/images/slider-button.png
   trunk/root/static/magic/src/widget/templates/images/soriaActive-c.gif
   trunk/root/static/magic/src/widget/templates/images/soriaActive-l.gif
   trunk/root/static/magic/src/widget/templates/images/soriaActive-r.gif
   trunk/root/static/magic/src/widget/templates/images/soriaButton-c.gif
   trunk/root/static/magic/src/widget/templates/images/soriaButton-l.gif
   trunk/root/static/magic/src/widget/templates/images/soriaButton-r.gif
   trunk/root/static/magic/src/widget/templates/images/soriaDisabled-c.gif
   trunk/root/static/magic/src/widget/templates/images/soriaDisabled-l.gif
   trunk/root/static/magic/src/widget/templates/images/soriaDisabled-r.gif
   trunk/root/static/magic/src/widget/templates/images/soriaPressed-c.gif
   trunk/root/static/magic/src/widget/templates/images/soriaPressed-l.gif
   trunk/root/static/magic/src/widget/templates/images/soriaPressed-r.gif
   trunk/root/static/magic/src/widget/templates/images/spinnerDecrement.gif
   trunk/root/static/magic/src/widget/templates/images/spinnerIncrement.gif
   trunk/root/static/magic/src/widget/templates/images/submenu_off.gif
   trunk/root/static/magic/src/widget/templates/images/submenu_on.gif
   trunk/root/static/magic/src/widget/templates/images/tab_bot_left.gif
   trunk/root/static/magic/src/widget/templates/images/tab_bot_left_curr.gif
   trunk/root/static/magic/src/widget/templates/images/tab_bot_right.gif
   trunk/root/static/magic/src/widget/templates/images/tab_bot_right_curr.gif
   trunk/root/static/magic/src/widget/templates/images/tab_close.gif
   trunk/root/static/magic/src/widget/templates/images/tab_close_h.gif
   trunk/root/static/magic/src/widget/templates/images/tab_left.gif
   trunk/root/static/magic/src/widget/templates/images/tab_left_r.gif
   trunk/root/static/magic/src/widget/templates/images/tab_left_r_curr.gif
   trunk/root/static/magic/src/widget/templates/images/tab_right.gif
   trunk/root/static/magic/src/widget/templates/images/tab_right_r.gif
   trunk/root/static/magic/src/widget/templates/images/tab_right_r_curr.gif
   trunk/root/static/magic/src/widget/templates/images/tab_top_left.gif
   trunk/root/static/magic/src/widget/templates/images/tab_top_right.gif
   trunk/root/static/magic/src/widget/templates/images/toolbar-bg.gif
   trunk/root/static/magic/src/widget/templates/images/transparent.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_blank.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_child.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_expand_minus.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_expand_plus.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_c.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_l.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_p.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_t.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_v.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_x.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_y.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_grid_z.gif
   trunk/root/static/magic/src/widget/templates/images/treenode_node.gif
   trunk/root/static/magic/src/widget/templates/images/verticalbar.gif
   trunk/root/static/magic/src/widget/templates/images/whiteDownArrow.gif
   trunk/root/static/magic/src/widget/templates/incrementMonth.gif
   trunk/root/static/magic/src/widget/templates/incrementWeek.gif
   trunk/root/static/magic/src/widget/templates/richtextframe.html
   trunk/root/static/magic/src/widget/validate.js
   trunk/root/static/magic/src/widget/vml/
   trunk/root/static/magic/src/widget/vml/Chart.js
   trunk/root/static/magic/src/xml/
   trunk/root/static/magic/src/xml/Parse.js
   trunk/root/static/magic/src/xml/__package__.js
   trunk/root/static/magic/src/xml/domUtil.js
   trunk/root/static/magic/src/xml/htmlUtil.js
   trunk/root/static/magic/src/xml/svgUtil.js
Modified:
   /
Log:
 <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">r4883 at ferrari</A>:  chisel | 2006-07-19 09:39:29 +0100
 + added dojo files



Property changes on: 
___________________________________________________________________
Name: svk:merge
   - 6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:4882
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762
   + 6fba2e3f-c318-0410-85fa-910d1bc53201:/local/parley:4883
c0683b51-46fc-0310-adae-a083e7ee0929:/local/berlios/parley:15762

Added: trunk/root/static/magic/dojo.js
===================================================================
--- trunk/root/static/magic/dojo.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/dojo.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,5593 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+	This is a compiled version of Dojo, built for deployment and not for
+	development. To get an editable version, please visit:
+
+		<A HREF="http://dojotoolkit.org">http://dojotoolkit.org</A>
+
+	for documentation and information on getting the source.
+*/
+
+if(typeof dojo==&quot;undefined&quot;){
+var dj_global=this;
+function dj_undef(_1,_2){
+if(_2==null){
+_2=dj_global;
+}
+return (typeof _2[_1]==&quot;undefined&quot;);
+}
+if(dj_undef(&quot;djConfig&quot;)){
+var djConfig={};
+}
+if(dj_undef(&quot;dojo&quot;)){
+var dojo={};
+}
+dojo.version={major:0,minor:3,patch:1,flag:&quot;&quot;,revision:Number(&quot;$Rev: 4342 $&quot;.match(/[0-9]+/)[0]),toString:function(){
+with(dojo.version){
+return major+&quot;.&quot;+minor+&quot;.&quot;+patch+flag+&quot; (&quot;+revision+&quot;)&quot;;
+}
+}};
+dojo.evalProp=function(_3,_4,_5){
+return (_4&amp;&amp;!dj_undef(_3,_4)?_4[_3]:(_5?(_4[_3]={}):undefined));
+};
+dojo.parseObjPath=function(_6,_7,_8){
+var _9=(_7!=null?_7:dj_global);
+var _a=_6.split(&quot;.&quot;);
+var _b=_a.pop();
+for(var i=0,l=_a.length;i&lt;l&amp;&amp;_9;i++){
+_9=dojo.evalProp(_a[i],_9,_8);
+}
+return {obj:_9,prop:_b};
+};
+dojo.evalObjPath=function(_d,_e){
+if(typeof _d!=&quot;string&quot;){
+return dj_global;
+}
+if(_d.indexOf(&quot;.&quot;)==-1){
+return dojo.evalProp(_d,dj_global,_e);
+}
+var _f=dojo.parseObjPath(_d,dj_global,_e);
+if(_f){
+return dojo.evalProp(_f.prop,_f.obj,_e);
+}
+return null;
+};
+dojo.errorToString=function(_10){
+if(!dj_undef(&quot;message&quot;,_10)){
+return _10.message;
+}else{
+if(!dj_undef(&quot;description&quot;,_10)){
+return _10.description;
+}else{
+return _10;
+}
+}
+};
+dojo.raise=function(_11,_12){
+if(_12){
+_11=_11+&quot;: &quot;+dojo.errorToString(_12);
+}
+try{
+dojo.hostenv.println(&quot;FATAL: &quot;+_11);
+}
+catch(e){
+}
+throw Error(_11);
+};
+dojo.debug=function(){
+};
+dojo.debugShallow=function(obj){
+};
+dojo.profile={start:function(){
+},end:function(){
+},stop:function(){
+},dump:function(){
+}};
+function dj_eval(_14){
+return dj_global.eval?dj_global.eval(_14):eval(_14);
+}
+dojo.unimplemented=function(_15,_16){
+var _17=&quot;'&quot;+_15+&quot;' not implemented&quot;;
+if(_16!=null){
+_17+=&quot; &quot;+_16;
+}
+dojo.raise(_17);
+};
+dojo.deprecated=function(_18,_19,_1a){
+var _1b=&quot;DEPRECATED: &quot;+_18;
+if(_19){
+_1b+=&quot; &quot;+_19;
+}
+if(_1a){
+_1b+=&quot; -- will be removed in version: &quot;+_1a;
+}
+dojo.debug(_1b);
+};
+dojo.inherits=function(_1c,_1d){
+if(typeof _1d!=&quot;function&quot;){
+dojo.raise(&quot;dojo.inherits: superclass argument [&quot;+_1d+&quot;] must be a function (subclass: [&quot;+_1c+&quot;']&quot;);
+}
+_1c.prototype=new _1d();
+_1c.prototype.constructor=_1c;
+_1c.superclass=_1d.prototype;
+_1c[&quot;super&quot;]=_1d.prototype;
+};
+dojo.render=(function(){
+function vscaffold(_1e,_1f){
+var tmp={capable:false,support:{builtin:false,plugin:false},prefixes:_1e};
+for(var _21 in _1f){
+tmp[_21]=false;
+}
+return tmp;
+}
+return {name:&quot;&quot;,ver:dojo.version,os:{win:false,linux:false,osx:false},html:vscaffold([&quot;html&quot;],[&quot;ie&quot;,&quot;opera&quot;,&quot;khtml&quot;,&quot;safari&quot;,&quot;moz&quot;]),svg:vscaffold([&quot;svg&quot;],[&quot;corel&quot;,&quot;adobe&quot;,&quot;batik&quot;]),vml:vscaffold([&quot;vml&quot;],[&quot;ie&quot;]),swf:vscaffold([&quot;Swf&quot;,&quot;Flash&quot;,&quot;Mm&quot;],[&quot;mm&quot;]),swt:vscaffold([&quot;Swt&quot;],[&quot;ibm&quot;])};
+})();
+dojo.hostenv=(function(){
+var _22={isDebug:false,allowQueryConfig:false,baseScriptUri:&quot;&quot;,baseRelativePath:&quot;&quot;,libraryScriptUri:&quot;&quot;,iePreventClobber:false,ieClobberMinimal:true,preventBackButtonFix:true,searchIds:[],parseWidgets:true};
+if(typeof djConfig==&quot;undefined&quot;){
+djConfig=_22;
+}else{
+for(var _23 in _22){
+if(typeof djConfig[_23]==&quot;undefined&quot;){
+djConfig[_23]=_22[_23];
+}
+}
+}
+return {name_:&quot;(unset)&quot;,version_:&quot;(unset)&quot;,getName:function(){
+return this.name_;
+},getVersion:function(){
+return this.version_;
+},getText:function(uri){
+dojo.unimplemented(&quot;getText&quot;,&quot;uri=&quot;+uri);
+}};
+})();
+dojo.hostenv.getBaseScriptUri=function(){
+if(djConfig.baseScriptUri.length){
+return djConfig.baseScriptUri;
+}
+var uri=new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);
+if(!uri){
+dojo.raise(&quot;Nothing returned by getLibraryScriptUri(): &quot;+uri);
+}
+var _26=uri.lastIndexOf(&quot;/&quot;);
+djConfig.baseScriptUri=djConfig.baseRelativePath;
+return djConfig.baseScriptUri;
+};
+(function(){
+var _27={pkgFileName:&quot;__package__&quot;,loading_modules_:{},loaded_modules_:{},addedToLoadingCount:[],removedFromLoadingCount:[],inFlightCount:0,modulePrefixes_:{dojo:{name:&quot;dojo&quot;,value:&quot;src&quot;}},setModulePrefix:function(_28,_29){
+this.modulePrefixes_[_28]={name:_28,value:_29};
+},getModulePrefix:function(_2a){
+var mp=this.modulePrefixes_;
+if((mp[_2a])&amp;&amp;(mp[_2a][&quot;name&quot;])){
+return mp[_2a].value;
+}
+return _2a;
+},getTextStack:[],loadUriStack:[],loadedUris:[],post_load_:false,modulesLoadedListeners:[],unloadListeners:[],loadNotifying:false};
+for(var _2c in _27){
+dojo.hostenv[_2c]=_27[_2c];
+}
+})();
+dojo.hostenv.loadPath=function(_2d,_2e,cb){
+var uri;
+if((_2d.charAt(0)==&quot;/&quot;)||(_2d.match(/^\w+:/))){
+uri=_2d;
+}else{
+uri=this.getBaseScriptUri()+_2d;
+}
+if(djConfig.cacheBust&amp;&amp;dojo.render.html.capable){
+uri+=&quot;?&quot;+String(djConfig.cacheBust).replace(/\W+/g,&quot;&quot;);
+}
+try{
+return ((!_2e)?this.loadUri(uri,cb):this.loadUriAndCheck(uri,_2e,cb));
+}
+catch(e){
+dojo.debug(e);
+return false;
+}
+};
+dojo.hostenv.loadUri=function(uri,cb){
+if(this.loadedUris[uri]){
+return 1;
+}
+var _33=this.getText(uri,null,true);
+if(_33==null){
+return 0;
+}
+this.loadedUris[uri]=true;
+if(cb){
+_33=&quot;(&quot;+_33+&quot;)&quot;;
+}
+var _34=dj_eval(_33);
+if(cb){
+cb(_34);
+}
+return 1;
+};
+dojo.hostenv.loadUriAndCheck=function(uri,_36,cb){
+var ok=true;
+try{
+ok=this.loadUri(uri,cb);
+}
+catch(e){
+dojo.debug(&quot;failed loading &quot;,uri,&quot; with error: &quot;,e);
+}
+return ((ok)&amp;&amp;(this.findModule(_36,false)))?true:false;
+};
+dojo.loaded=function(){
+};
+dojo.unloaded=function(){
+};
+dojo.hostenv.loaded=function(){
+this.loadNotifying=true;
+this.post_load_=true;
+var mll=this.modulesLoadedListeners;
+for(var x=0;x&lt;mll.length;x++){
+mll[x]();
+}
+this.modulesLoadedListeners=[];
+this.loadNotifying=false;
+dojo.loaded();
+};
+dojo.hostenv.unloaded=function(){
+var mll=this.unloadListeners;
+while(mll.length){
+(mll.pop())();
+}
+dojo.unloaded();
+};
+dojo.addOnLoad=function(obj,_3d){
+var dh=dojo.hostenv;
+if(arguments.length==1){
+dh.modulesLoadedListeners.push(obj);
+}else{
+if(arguments.length&gt;1){
+dh.modulesLoadedListeners.push(function(){
+obj[_3d]();
+});
+}
+}
+if(dh.post_load_&amp;&amp;dh.inFlightCount==0&amp;&amp;!dh.loadNotifying){
+dh.callLoaded();
+}
+};
+dojo.addOnUnload=function(obj,_40){
+var dh=dojo.hostenv;
+if(arguments.length==1){
+dh.unloadListeners.push(obj);
+}else{
+if(arguments.length&gt;1){
+dh.unloadListeners.push(function(){
+obj[_40]();
+});
+}
+}
+};
+dojo.hostenv.modulesLoaded=function(){
+if(this.post_load_){
+return;
+}
+if((this.loadUriStack.length==0)&amp;&amp;(this.getTextStack.length==0)){
+if(this.inFlightCount&gt;0){
+dojo.debug(&quot;files still in flight!&quot;);
+return;
+}
+dojo.hostenv.callLoaded();
+}
+};
+dojo.hostenv.callLoaded=function(){
+if(typeof setTimeout==&quot;object&quot;){
+setTimeout(&quot;dojo.hostenv.loaded();&quot;,0);
+}else{
+dojo.hostenv.loaded();
+}
+};
+dojo.hostenv.getModuleSymbols=function(_42){
+var _43=_42.split(&quot;.&quot;);
+for(var i=_43.length-1;i&gt;0;i--){
+var _45=_43.slice(0,i).join(&quot;.&quot;);
+var _46=this.getModulePrefix(_45);
+if(_46!=_45){
+_43.splice(0,i,_46);
+break;
+}
+}
+return _43;
+};
+dojo.hostenv._global_omit_module_check=false;
+dojo.hostenv.loadModule=function(_47,_48,_49){
+if(!_47){
+return;
+}
+_49=this._global_omit_module_check||_49;
+var _4a=this.findModule(_47,false);
+if(_4a){
+return _4a;
+}
+if(dj_undef(_47,this.loading_modules_)){
+this.addedToLoadingCount.push(_47);
+}
+this.loading_modules_[_47]=1;
+var _4b=_47.replace(/\./g,&quot;/&quot;)+&quot;.js&quot;;
+var _4c=this.getModuleSymbols(_47);
+var _4d=((_4c[0].charAt(0)!=&quot;/&quot;)&amp;&amp;(!_4c[0].match(/^\w+:/)));
+var _4e=_4c[_4c.length-1];
+var _4f=_47.split(&quot;.&quot;);
+if(_4e==&quot;*&quot;){
+_47=(_4f.slice(0,-1)).join(&quot;.&quot;);
+while(_4c.length){
+_4c.pop();
+_4c.push(this.pkgFileName);
+_4b=_4c.join(&quot;/&quot;)+&quot;.js&quot;;
+if(_4d&amp;&amp;(_4b.charAt(0)==&quot;/&quot;)){
+_4b=_4b.slice(1);
+}
+ok=this.loadPath(_4b,((!_49)?_47:null));
+if(ok){
+break;
+}
+_4c.pop();
+}
+}else{
+_4b=_4c.join(&quot;/&quot;)+&quot;.js&quot;;
+_47=_4f.join(&quot;.&quot;);
+var ok=this.loadPath(_4b,((!_49)?_47:null));
+if((!ok)&amp;&amp;(!_48)){
+_4c.pop();
+while(_4c.length){
+_4b=_4c.join(&quot;/&quot;)+&quot;.js&quot;;
+ok=this.loadPath(_4b,((!_49)?_47:null));
+if(ok){
+break;
+}
+_4c.pop();
+_4b=_4c.join(&quot;/&quot;)+&quot;/&quot;+this.pkgFileName+&quot;.js&quot;;
+if(_4d&amp;&amp;(_4b.charAt(0)==&quot;/&quot;)){
+_4b=_4b.slice(1);
+}
+ok=this.loadPath(_4b,((!_49)?_47:null));
+if(ok){
+break;
+}
+}
+}
+if((!ok)&amp;&amp;(!_49)){
+dojo.raise(&quot;Could not load '&quot;+_47+&quot;'; last tried '&quot;+_4b+&quot;'&quot;);
+}
+}
+if(!_49&amp;&amp;!this[&quot;isXDomain&quot;]){
+_4a=this.findModule(_47,false);
+if(!_4a){
+dojo.raise(&quot;symbol '&quot;+_47+&quot;' is not defined after loading '&quot;+_4b+&quot;'&quot;);
+}
+}
+return _4a;
+};
+dojo.hostenv.startPackage=function(_51){
+var _52=dojo.evalObjPath((_51.split(&quot;.&quot;).slice(0,-1)).join(&quot;.&quot;));
+this.loaded_modules_[(new String(_51)).toLowerCase()]=_52;
+var _53=_51.split(/\./);
+if(_53[_53.length-1]==&quot;*&quot;){
+_53.pop();
+}
+return dojo.evalObjPath(_53.join(&quot;.&quot;),true);
+};
+dojo.hostenv.findModule=function(_54,_55){
+var lmn=(new String(_54)).toLowerCase();
+if(this.loaded_modules_[lmn]){
+return this.loaded_modules_[lmn];
+}
+var _57=dojo.evalObjPath(_54);
+if((_54)&amp;&amp;(typeof _57!=&quot;undefined&quot;)&amp;&amp;(_57)){
+this.loaded_modules_[lmn]=_57;
+return _57;
+}
+if(_55){
+dojo.raise(&quot;no loaded module named '&quot;+_54+&quot;'&quot;);
+}
+return null;
+};
+dojo.kwCompoundRequire=function(_58){
+var _59=_58[&quot;common&quot;]||[];
+var _5a=(_58[dojo.hostenv.name_])?_59.concat(_58[dojo.hostenv.name_]||[]):_59.concat(_58[&quot;default&quot;]||[]);
+for(var x=0;x&lt;_5a.length;x++){
+var _5c=_5a[x];
+if(_5c.constructor==Array){
+dojo.hostenv.loadModule.apply(dojo.hostenv,_5c);
+}else{
+dojo.hostenv.loadModule(_5c);
+}
+}
+};
+dojo.require=function(){
+dojo.hostenv.loadModule.apply(dojo.hostenv,arguments);
+};
+dojo.requireIf=function(){
+if((arguments[0]===true)||(arguments[0]==&quot;common&quot;)||(arguments[0]&amp;&amp;dojo.render[arguments[0]].capable)){
+var _5d=[];
+for(var i=1;i&lt;arguments.length;i++){
+_5d.push(arguments[i]);
+}
+dojo.require.apply(dojo,_5d);
+}
+};
+dojo.requireAfterIf=dojo.requireIf;
+dojo.provide=function(){
+return dojo.hostenv.startPackage.apply(dojo.hostenv,arguments);
+};
+dojo.setModulePrefix=function(_5f,_60){
+return dojo.hostenv.setModulePrefix(_5f,_60);
+};
+dojo.exists=function(obj,_62){
+var p=_62.split(&quot;.&quot;);
+for(var i=0;i&lt;p.length;i++){
+if(!(obj[p[i]])){
+return false;
+}
+obj=obj[p[i]];
+}
+return true;
+};
+}
+if(typeof window==&quot;undefined&quot;){
+dojo.raise(&quot;no window object&quot;);
+}
+(function(){
+if(djConfig.allowQueryConfig){
+var _65=document.location.toString();
+var _66=_65.split(&quot;?&quot;,2);
+if(_66.length&gt;1){
+var _67=_66[1];
+var _68=_67.split(&quot;&amp;&quot;);
+for(var x in _68){
+var sp=_68[x].split(&quot;=&quot;);
+if((sp[0].length&gt;9)&amp;&amp;(sp[0].substr(0,9)==&quot;djConfig.&quot;)){
+var opt=sp[0].substr(9);
+try{
+djConfig[opt]=eval(sp[1]);
+}
+catch(e){
+djConfig[opt]=sp[1];
+}
+}
+}
+}
+}
+if(((djConfig[&quot;baseScriptUri&quot;]==&quot;&quot;)||(djConfig[&quot;baseRelativePath&quot;]==&quot;&quot;))&amp;&amp;(document&amp;&amp;document.getElementsByTagName)){
+var _6c=document.getElementsByTagName(&quot;script&quot;);
+var _6d=/(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
+for(var i=0;i&lt;_6c.length;i++){
+var src=_6c[i].getAttribute(&quot;src&quot;);
+if(!src){
+continue;
+}
+var m=src.match(_6d);
+if(m){
+var _71=src.substring(0,m.index);
+if(src.indexOf(&quot;bootstrap1&quot;)&gt;-1){
+_71+=&quot;../&quot;;
+}
+if(!this[&quot;djConfig&quot;]){
+djConfig={};
+}
+if(djConfig[&quot;baseScriptUri&quot;]==&quot;&quot;){
+djConfig[&quot;baseScriptUri&quot;]=_71;
+}
+if(djConfig[&quot;baseRelativePath&quot;]==&quot;&quot;){
+djConfig[&quot;baseRelativePath&quot;]=_71;
+}
+break;
+}
+}
+}
+var dr=dojo.render;
+var drh=dojo.render.html;
+var drs=dojo.render.svg;
+var dua=drh.UA=navigator.userAgent;
+var dav=drh.AV=navigator.appVersion;
+var t=true;
+var f=false;
+drh.capable=t;
+drh.support.builtin=t;
+dr.ver=parseFloat(drh.AV);
+dr.os.mac=dav.indexOf(&quot;Macintosh&quot;)&gt;=0;
+dr.os.win=dav.indexOf(&quot;Windows&quot;)&gt;=0;
+dr.os.linux=dav.indexOf(&quot;X11&quot;)&gt;=0;
+drh.opera=dua.indexOf(&quot;Opera&quot;)&gt;=0;
+drh.khtml=(dav.indexOf(&quot;Konqueror&quot;)&gt;=0)||(dav.indexOf(&quot;Safari&quot;)&gt;=0);
+drh.safari=dav.indexOf(&quot;Safari&quot;)&gt;=0;
+var _79=dua.indexOf(&quot;Gecko&quot;);
+drh.mozilla=drh.moz=(_79&gt;=0)&amp;&amp;(!drh.khtml);
+if(drh.mozilla){
+drh.geckoVersion=dua.substring(_79+6,_79+14);
+}
+drh.ie=(document.all)&amp;&amp;(!drh.opera);
+drh.ie50=drh.ie&amp;&amp;dav.indexOf(&quot;MSIE 5.0&quot;)&gt;=0;
+drh.ie55=drh.ie&amp;&amp;dav.indexOf(&quot;MSIE 5.5&quot;)&gt;=0;
+drh.ie60=drh.ie&amp;&amp;dav.indexOf(&quot;MSIE 6.0&quot;)&gt;=0;
+drh.ie70=drh.ie&amp;&amp;dav.indexOf(&quot;MSIE 7.0&quot;)&gt;=0;
+dojo.locale=(drh.ie?navigator.userLanguage:navigator.language).toLowerCase();
+dr.vml.capable=drh.ie;
+drs.capable=f;
+drs.support.plugin=f;
+drs.support.builtin=f;
+if(document.implementation&amp;&amp;document.implementation.hasFeature&amp;&amp;document.implementation.hasFeature(&quot;org.w3c.dom.svg&quot;,&quot;1.0&quot;)){
+drs.capable=t;
+drs.support.builtin=t;
+drs.support.plugin=f;
+}
+})();
+dojo.hostenv.startPackage(&quot;dojo.hostenv&quot;);
+dojo.render.name=dojo.hostenv.name_=&quot;browser&quot;;
+dojo.hostenv.searchIds=[];
+dojo.hostenv._XMLHTTP_PROGIDS=[&quot;Msxml2.XMLHTTP&quot;,&quot;Microsoft.XMLHTTP&quot;,&quot;Msxml2.XMLHTTP.4.0&quot;];
+dojo.hostenv.getXmlhttpObject=function(){
+var _7a=null;
+var _7b=null;
+try{
+_7a=new XMLHttpRequest();
+}
+catch(e){
+}
+if(!_7a){
+for(var i=0;i&lt;3;++i){
+var _7d=dojo.hostenv._XMLHTTP_PROGIDS[i];
+try{
+_7a=new ActiveXObject(_7d);
+}
+catch(e){
+_7b=e;
+}
+if(_7a){
+dojo.hostenv._XMLHTTP_PROGIDS=[_7d];
+break;
+}
+}
+}
+if(!_7a){
+return dojo.raise(&quot;XMLHTTP not available&quot;,_7b);
+}
+return _7a;
+};
+dojo.hostenv.getText=function(uri,_7f,_80){
+var _81=this.getXmlhttpObject();
+if(_7f){
+_81.onreadystatechange=function(){
+if(4==_81.readyState){
+if((!_81[&quot;status&quot;])||((200&lt;=_81.status)&amp;&amp;(300&gt;_81.status))){
+_7f(_81.responseText);
+}
+}
+};
+}
+_81.open(&quot;GET&quot;,uri,_7f?true:false);
+try{
+_81.send(null);
+if(_7f){
+return null;
+}
+if((_81[&quot;status&quot;])&amp;&amp;((200&gt;_81.status)||(300&lt;=_81.status))){
+throw Error(&quot;Unable to load &quot;+uri+&quot; status:&quot;+_81.status);
+}
+}
+catch(e){
+if((_80)&amp;&amp;(!_7f)){
+return null;
+}else{
+throw e;
+}
+}
+return _81.responseText;
+};
+dojo.hostenv.defaultDebugContainerId=&quot;dojoDebug&quot;;
+dojo.hostenv._println_buffer=[];
+dojo.hostenv._println_safe=false;
+dojo.hostenv.println=function(_82){
+if(!dojo.hostenv._println_safe){
+dojo.hostenv._println_buffer.push(_82);
+}else{
+try{
+var _83=document.getElementById(djConfig.debugContainerId?djConfig.debugContainerId:dojo.hostenv.defaultDebugContainerId);
+if(!_83){
+_83=document.getElementsByTagName(&quot;body&quot;)[0]||document.body;
+}
+var div=document.createElement(&quot;div&quot;);
+div.appendChild(document.createTextNode(_82));
+_83.appendChild(div);
+}
+catch(e){
+try{
+document.write(&quot;&lt;div&gt;&quot;+_82+&quot;&lt;/div&gt;&quot;);
+}
+catch(e2){
+window.status=_82;
+}
+}
+}
+};
+dojo.addOnLoad(function(){
+dojo.hostenv._println_safe=true;
+while(dojo.hostenv._println_buffer.length&gt;0){
+dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
+}
+});
+function dj_addNodeEvtHdlr(_85,_86,fp,_88){
+var _89=_85[&quot;on&quot;+_86]||function(){
+};
+_85[&quot;on&quot;+_86]=function(){
+fp.apply(_85,arguments);
+_89.apply(_85,arguments);
+};
+return true;
+}
+dj_addNodeEvtHdlr(window,&quot;load&quot;,function(){
+if(arguments.callee.initialized){
+return;
+}
+arguments.callee.initialized=true;
+var _8a=function(){
+if(dojo.render.html.ie){
+dojo.hostenv.makeWidgets();
+}
+};
+if(dojo.hostenv.inFlightCount==0){
+_8a();
+dojo.hostenv.modulesLoaded();
+}else{
+dojo.addOnLoad(_8a);
+}
+});
+dj_addNodeEvtHdlr(window,&quot;unload&quot;,function(){
+dojo.hostenv.unloaded();
+});
+dojo.hostenv.makeWidgets=function(){
+var _8b=[];
+if(djConfig.searchIds&amp;&amp;djConfig.searchIds.length&gt;0){
+_8b=_8b.concat(djConfig.searchIds);
+}
+if(dojo.hostenv.searchIds&amp;&amp;dojo.hostenv.searchIds.length&gt;0){
+_8b=_8b.concat(dojo.hostenv.searchIds);
+}
+if((djConfig.parseWidgets)||(_8b.length&gt;0)){
+if(dojo.evalObjPath(&quot;dojo.widget.Parse&quot;)){
+var _8c=new dojo.xml.Parse();
+if(_8b.length&gt;0){
+for(var x=0;x&lt;_8b.length;x++){
+var _8e=document.getElementById(_8b[x]);
+if(!_8e){
+continue;
+}
+var _8f=_8c.parseElement(_8e,null,true);
+dojo.widget.getParser().createComponents(_8f);
+}
+}else{
+if(djConfig.parseWidgets){
+var _8f=_8c.parseElement(document.getElementsByTagName(&quot;body&quot;)[0]||document.body,null,true);
+dojo.widget.getParser().createComponents(_8f);
+}
+}
+}
+}
+};
+dojo.addOnLoad(function(){
+if(!dojo.render.html.ie){
+dojo.hostenv.makeWidgets();
+}
+});
+try{
+if(dojo.render.html.ie){
+document.write(&quot;&lt;style&gt;v:*{ behavior:url(#default#VML); }&lt;/style&gt;&quot;);
+document.write(&quot;&lt;xml:namespace ns=\&quot;urn:schemas-microsoft-com:vml\&quot; prefix=\&quot;v\&quot;/&gt;&quot;);
+}
+}
+catch(e){
+}
+dojo.hostenv.writeIncludes=function(){
+};
+dojo.byId=function(id,doc){
+if(id&amp;&amp;(typeof id==&quot;string&quot;||id instanceof String)){
+if(!doc){
+doc=document;
+}
+return doc.getElementById(id);
+}
+return id;
+};
+(function(){
+if(typeof dj_usingBootstrap!=&quot;undefined&quot;){
+return;
+}
+var _92=false;
+var _93=false;
+var _94=false;
+if((typeof this[&quot;load&quot;]==&quot;function&quot;)&amp;&amp;((typeof this[&quot;Packages&quot;]==&quot;function&quot;)||(typeof this[&quot;Packages&quot;]==&quot;object&quot;))){
+_92=true;
+}else{
+if(typeof this[&quot;load&quot;]==&quot;function&quot;){
+_93=true;
+}else{
+if(window.widget){
+_94=true;
+}
+}
+}
+var _95=[];
+if((this[&quot;djConfig&quot;])&amp;&amp;((djConfig[&quot;isDebug&quot;])||(djConfig[&quot;debugAtAllCosts&quot;]))){
+_95.push(&quot;debug.js&quot;);
+}
+if((this[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;debugAtAllCosts&quot;])&amp;&amp;(!_92)&amp;&amp;(!_94)){
+_95.push(&quot;browser_debug.js&quot;);
+}
+if((this[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;compat&quot;])){
+_95.push(&quot;compat/&quot;+djConfig[&quot;compat&quot;]+&quot;.js&quot;);
+}
+var _96=djConfig[&quot;baseScriptUri&quot;];
+if((this[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;baseLoaderUri&quot;])){
+_96=djConfig[&quot;baseLoaderUri&quot;];
+}
+for(var x=0;x&lt;_95.length;x++){
+var _98=_96+&quot;src/&quot;+_95[x];
+if(_92||_93){
+load(_98);
+}else{
+try{
+document.write(&quot;&lt;scr&quot;+&quot;ipt type='text/javascript' src='&quot;+_98+&quot;'&gt;&lt;/scr&quot;+&quot;ipt&gt;&quot;);
+}
+catch(e){
+var _99=document.createElement(&quot;script&quot;);
+_99.src=_98;
+document.getElementsByTagName(&quot;head&quot;)[0].appendChild(_99);
+}
+}
+}
+})();
+dojo.fallback_locale=&quot;en&quot;;
+dojo.normalizeLocale=function(_9a){
+return _9a?_9a.toLowerCase():dojo.locale;
+};
+dojo.requireLocalization=function(_9b,_9c,_9d){
+dojo.debug(&quot;EXPERIMENTAL: dojo.requireLocalization&quot;);
+var _9e=dojo.hostenv.getModuleSymbols(_9b);
+var _9f=_9e.concat(&quot;nls&quot;).join(&quot;/&quot;);
+_9d=dojo.normalizeLocale(_9d);
+var _a0=_9d.split(&quot;-&quot;);
+var _a1=[];
+for(var i=_a0.length;i&gt;0;i--){
+_a1.push(_a0.slice(0,i).join(&quot;-&quot;));
+}
+if(_a1[_a1.length-1]!=dojo.fallback_locale){
+_a1.push(dojo.fallback_locale);
+}
+var _a3=[_9b,&quot;_nls&quot;,_9c].join(&quot;.&quot;);
+var _a4=dojo.hostenv.startPackage(_a3);
+dojo.hostenv.loaded_modules_[_a3]=_a4;
+var _a5=false;
+for(var i=_a1.length-1;i&gt;=0;i--){
+var loc=_a1[i];
+var pkg=[_a3,loc].join(&quot;.&quot;);
+var _a8=false;
+if(!dojo.hostenv.findModule(pkg)){
+dojo.hostenv.loaded_modules_[pkg]=null;
+var _a9=[_9f,loc,_9c].join(&quot;/&quot;)+&quot;.js&quot;;
+_a8=dojo.hostenv.loadPath(_a9,null,function(_aa){
+_a4[loc]=_aa;
+if(_a5){
+for(var x in _a5){
+if(!_a4[loc][x]){
+_a4[loc][x]=_a5[x];
+}
+}
+}
+});
+}else{
+_a8=true;
+}
+if(_a8&amp;&amp;_a4[loc]){
+_a5=_a4[loc];
+}
+}
+};
+dojo.provide(&quot;dojo.string.common&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.string.trim=function(str,wh){
+if(!str.replace){
+return str;
+}
+if(!str.length){
+return str;
+}
+var re=(wh&gt;0)?(/^\s+/):(wh&lt;0)?(/\s+$/):(/^\s+|\s+$/g);
+return str.replace(re,&quot;&quot;);
+};
+dojo.string.trimStart=function(str){
+return dojo.string.trim(str,1);
+};
+dojo.string.trimEnd=function(str){
+return dojo.string.trim(str,-1);
+};
+dojo.string.repeat=function(str,_b2,_b3){
+var out=&quot;&quot;;
+for(var i=0;i&lt;_b2;i++){
+out+=str;
+if(_b3&amp;&amp;i&lt;_b2-1){
+out+=_b3;
+}
+}
+return out;
+};
+dojo.string.pad=function(str,len,c,dir){
+var out=String(str);
+if(!c){
+c=&quot;0&quot;;
+}
+if(!dir){
+dir=1;
+}
+while(out.length&lt;len){
+if(dir&gt;0){
+out=c+out;
+}else{
+out+=c;
+}
+}
+return out;
+};
+dojo.string.padLeft=function(str,len,c){
+return dojo.string.pad(str,len,c,1);
+};
+dojo.string.padRight=function(str,len,c){
+return dojo.string.pad(str,len,c,-1);
+};
+dojo.provide(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.string.common&quot;);
+dojo.provide(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+dojo.lang._mixin=function(obj,_c2){
+var _c3={};
+for(var x in _c2){
+if(typeof _c3[x]==&quot;undefined&quot;||_c3[x]!=_c2[x]){
+obj[x]=_c2[x];
+}
+}
+if(dojo.render.html.ie&amp;&amp;dojo.lang.isFunction(_c2[&quot;toString&quot;])&amp;&amp;_c2[&quot;toString&quot;]!=obj[&quot;toString&quot;]){
+obj.toString=_c2.toString;
+}
+return obj;
+};
+dojo.lang.mixin=function(obj,_c6){
+for(var i=1,l=arguments.length;i&lt;l;i++){
+dojo.lang._mixin(obj,arguments[i]);
+}
+return obj;
+};
+dojo.lang.extend=function(_c8,_c9){
+for(var i=1,l=arguments.length;i&lt;l;i++){
+dojo.lang._mixin(_c8.prototype,arguments[i]);
+}
+return _c8;
+};
+dojo.lang.find=function(arr,val,_cd,_ce){
+if(!dojo.lang.isArrayLike(arr)&amp;&amp;dojo.lang.isArrayLike(val)){
+var a=arr;
+arr=val;
+val=a;
+}
+var _d0=dojo.lang.isString(arr);
+if(_d0){
+arr=arr.split(&quot;&quot;);
+}
+if(_ce){
+var _d1=-1;
+var i=arr.length-1;
+var end=-1;
+}else{
+var _d1=1;
+var i=0;
+var end=arr.length;
+}
+if(_cd){
+while(i!=end){
+if(arr[i]===val){
+return i;
+}
+i+=_d1;
+}
+}else{
+while(i!=end){
+if(arr[i]==val){
+return i;
+}
+i+=_d1;
+}
+}
+return -1;
+};
+dojo.lang.indexOf=dojo.lang.find;
+dojo.lang.findLast=function(arr,val,_d6){
+return dojo.lang.find(arr,val,_d6,true);
+};
+dojo.lang.lastIndexOf=dojo.lang.findLast;
+dojo.lang.inArray=function(arr,val){
+return dojo.lang.find(arr,val)&gt;-1;
+};
+dojo.lang.isObject=function(wh){
+if(typeof wh==&quot;undefined&quot;){
+return false;
+}
+return (typeof wh==&quot;object&quot;||wh===null||dojo.lang.isArray(wh)||dojo.lang.isFunction(wh));
+};
+dojo.lang.isArray=function(wh){
+return (wh instanceof Array||typeof wh==&quot;array&quot;);
+};
+dojo.lang.isArrayLike=function(wh){
+if(dojo.lang.isString(wh)){
+return false;
+}
+if(dojo.lang.isFunction(wh)){
+return false;
+}
+if(dojo.lang.isArray(wh)){
+return true;
+}
+if(typeof wh!=&quot;undefined&quot;&amp;&amp;wh&amp;&amp;dojo.lang.isNumber(wh.length)&amp;&amp;isFinite(wh.length)){
+return true;
+}
+return false;
+};
+dojo.lang.isFunction=function(wh){
+if(!wh){
+return false;
+}
+return (wh instanceof Function||typeof wh==&quot;function&quot;);
+};
+dojo.lang.isString=function(wh){
+return (wh instanceof String||typeof wh==&quot;string&quot;);
+};
+dojo.lang.isAlien=function(wh){
+if(!wh){
+return false;
+}
+return !dojo.lang.isFunction()&amp;&amp;/\{\s*\[native code\]\s*\}/.test(String(wh));
+};
+dojo.lang.isBoolean=function(wh){
+return (wh instanceof Boolean||typeof wh==&quot;boolean&quot;);
+};
+dojo.lang.isNumber=function(wh){
+return (wh instanceof Number||typeof wh==&quot;number&quot;);
+};
+dojo.lang.isUndefined=function(wh){
+return ((wh==undefined)&amp;&amp;(typeof wh==&quot;undefined&quot;));
+};
+dojo.provide(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.lang.setTimeout=function(_e2,_e3){
+var _e4=window,argsStart=2;
+if(!dojo.lang.isFunction(_e2)){
+_e4=_e2;
+_e2=_e3;
+_e3=arguments[2];
+argsStart++;
+}
+if(dojo.lang.isString(_e2)){
+_e2=_e4[_e2];
+}
+var _e5=[];
+for(var i=argsStart;i&lt;arguments.length;i++){
+_e5.push(arguments[i]);
+}
+return setTimeout(function(){
+_e2.apply(_e4,_e5);
+},_e3);
+};
+dojo.lang.getNameInObj=function(ns,_e8){
+if(!ns){
+ns=dj_global;
+}
+for(var x in ns){
+if(ns[x]===_e8){
+return new String(x);
+}
+}
+return null;
+};
+dojo.lang.shallowCopy=function(obj){
+var ret={},key;
+for(key in obj){
+if(dojo.lang.isUndefined(ret[key])){
+ret[key]=obj[key];
+}
+}
+return ret;
+};
+dojo.lang.firstValued=function(){
+for(var i=0;i&lt;arguments.length;i++){
+if(typeof arguments[i]!=&quot;undefined&quot;){
+return arguments[i];
+}
+}
+return undefined;
+};
+dojo.lang.getObjPathValue=function(_ed,_ee,_ef){
+with(dojo.parseObjPath(_ed,_ee,_ef)){
+return dojo.evalProp(prop,obj,_ef);
+}
+};
+dojo.lang.setObjPathValue=function(_f0,_f1,_f2,_f3){
+if(arguments.length&lt;4){
+_f3=true;
+}
+with(dojo.parseObjPath(_f0,_f2,_f3)){
+if(obj&amp;&amp;(_f3||(prop in obj))){
+obj[prop]=_f1;
+}
+}
+};
+dojo.provide(&quot;dojo.io.IO&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.io.transports=[];
+dojo.io.hdlrFuncNames=[&quot;load&quot;,&quot;error&quot;,&quot;timeout&quot;];
+dojo.io.Request=function(url,_f5,_f6,_f7){
+if((arguments.length==1)&amp;&amp;(arguments[0].constructor==Object)){
+this.fromKwArgs(arguments[0]);
+}else{
+this.url=url;
+if(_f5){
+this.mimetype=_f5;
+}
+if(_f6){
+this.transport=_f6;
+}
+if(arguments.length&gt;=4){
+this.changeUrl=_f7;
+}
+}
+};
+dojo.lang.extend(dojo.io.Request,{url:&quot;&quot;,mimetype:&quot;text/plain&quot;,method:&quot;GET&quot;,content:undefined,transport:undefined,changeUrl:undefined,formNode:undefined,sync:false,bindSuccess:false,useCache:false,preventCache:false,load:function(_f8,_f9,evt){
+},error:function(_fb,_fc){
+},timeout:function(_fd){
+},handle:function(){
+},timeoutSeconds:0,abort:function(){
+},fromKwArgs:function(_fe){
+if(_fe[&quot;url&quot;]){
+_fe.url=_fe.url.toString();
+}
+if(_fe[&quot;formNode&quot;]){
+_fe.formNode=dojo.byId(_fe.formNode);
+}
+if(!_fe[&quot;method&quot;]&amp;&amp;_fe[&quot;formNode&quot;]&amp;&amp;_fe[&quot;formNode&quot;].method){
+_fe.method=_fe[&quot;formNode&quot;].method;
+}
+if(!_fe[&quot;handle&quot;]&amp;&amp;_fe[&quot;handler&quot;]){
+_fe.handle=_fe.handler;
+}
+if(!_fe[&quot;load&quot;]&amp;&amp;_fe[&quot;loaded&quot;]){
+_fe.load=_fe.loaded;
+}
+if(!_fe[&quot;changeUrl&quot;]&amp;&amp;_fe[&quot;changeURL&quot;]){
+_fe.changeUrl=_fe.changeURL;
+}
+_fe.encoding=dojo.lang.firstValued(_fe[&quot;encoding&quot;],djConfig[&quot;bindEncoding&quot;],&quot;&quot;);
+_fe.sendTransport=dojo.lang.firstValued(_fe[&quot;sendTransport&quot;],djConfig[&quot;ioSendTransport&quot;],false);
+var _ff=dojo.lang.isFunction;
+for(var x=0;x&lt;dojo.io.hdlrFuncNames.length;x++){
+var fn=dojo.io.hdlrFuncNames[x];
+if(_ff(_fe[fn])){
+continue;
+}
+if(_ff(_fe[&quot;handle&quot;])){
+_fe[fn]=_fe.handle;
+}
+}
+dojo.lang.mixin(this,_fe);
+}});
+dojo.io.Error=function(msg,type,num){
+this.message=msg;
+this.type=type||&quot;unknown&quot;;
+this.number=num||0;
+};
+dojo.io.transports.addTransport=function(name){
+this.push(name);
+this[name]=dojo.io[name];
+};
+dojo.io.bind=function(_106){
+if(!(_106 instanceof dojo.io.Request)){
+try{
+_106=new dojo.io.Request(_106);
+}
+catch(e){
+dojo.debug(e);
+}
+}
+var _107=&quot;&quot;;
+if(_106[&quot;transport&quot;]){
+_107=_106[&quot;transport&quot;];
+if(!this[_107]){
+return _106;
+}
+}else{
+for(var x=0;x&lt;dojo.io.transports.length;x++){
+var tmp=dojo.io.transports[x];
+if((this[tmp])&amp;&amp;(this[tmp].canHandle(_106))){
+_107=tmp;
+}
+}
+if(_107==&quot;&quot;){
+return _106;
+}
+}
+this[_107].bind(_106);
+_106.bindSuccess=true;
+return _106;
+};
+dojo.io.queueBind=function(_10a){
+if(!(_10a instanceof dojo.io.Request)){
+try{
+_10a=new dojo.io.Request(_10a);
+}
+catch(e){
+dojo.debug(e);
+}
+}
+var _10b=_10a.load;
+_10a.load=function(){
+dojo.io._queueBindInFlight=false;
+var ret=_10b.apply(this,arguments);
+dojo.io._dispatchNextQueueBind();
+return ret;
+};
+var _10d=_10a.error;
+_10a.error=function(){
+dojo.io._queueBindInFlight=false;
+var ret=_10d.apply(this,arguments);
+dojo.io._dispatchNextQueueBind();
+return ret;
+};
+dojo.io._bindQueue.push(_10a);
+dojo.io._dispatchNextQueueBind();
+return _10a;
+};
+dojo.io._dispatchNextQueueBind=function(){
+if(!dojo.io._queueBindInFlight){
+dojo.io._queueBindInFlight=true;
+if(dojo.io._bindQueue.length&gt;0){
+dojo.io.bind(dojo.io._bindQueue.shift());
+}else{
+dojo.io._queueBindInFlight=false;
+}
+}
+};
+dojo.io._bindQueue=[];
+dojo.io._queueBindInFlight=false;
+dojo.io.argsFromMap=function(map,_110,last){
+var enc=/utf/i.test(_110||&quot;&quot;)?encodeURIComponent:dojo.string.encodeAscii;
+var _113=[];
+var _114=new Object();
+for(var name in map){
+var _116=function(elt){
+var val=enc(name)+&quot;=&quot;+enc(elt);
+_113[(last==name)?&quot;push&quot;:&quot;unshift&quot;](val);
+};
+if(!_114[name]){
+var _119=map[name];
+if(dojo.lang.isArray(_119)){
+dojo.lang.forEach(_119,_116);
+}else{
+_116(_119);
+}
+}
+}
+return _113.join(&quot;&amp;&quot;);
+};
+dojo.io.setIFrameSrc=function(_11a,src,_11c){
+try{
+var r=dojo.render.html;
+if(!_11c){
+if(r.safari){
+_11a.location=src;
+}else{
+frames[_11a.name].location=src;
+}
+}else{
+var idoc;
+if(r.ie){
+idoc=_11a.contentWindow.document;
+}else{
+if(r.safari){
+idoc=_11a.document;
+}else{
+idoc=_11a.contentWindow;
+}
+}
+if(!idoc){
+_11a.location=src;
+return;
+}else{
+idoc.location.replace(src);
+}
+}
+}
+catch(e){
+dojo.debug(e);
+dojo.debug(&quot;setIFrameSrc: &quot;+e);
+}
+};
+dojo.provide(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.lang.has=function(obj,name){
+try{
+return (typeof obj[name]!=&quot;undefined&quot;);
+}
+catch(e){
+return false;
+}
+};
+dojo.lang.isEmpty=function(obj){
+if(dojo.lang.isObject(obj)){
+var tmp={};
+var _123=0;
+for(var x in obj){
+if(obj[x]&amp;&amp;(!tmp[x])){
+_123++;
+break;
+}
+}
+return (_123==0);
+}else{
+if(dojo.lang.isArrayLike(obj)||dojo.lang.isString(obj)){
+return obj.length==0;
+}
+}
+};
+dojo.lang.map=function(arr,obj,_127){
+var _128=dojo.lang.isString(arr);
+if(_128){
+arr=arr.split(&quot;&quot;);
+}
+if(dojo.lang.isFunction(obj)&amp;&amp;(!_127)){
+_127=obj;
+obj=dj_global;
+}else{
+if(dojo.lang.isFunction(obj)&amp;&amp;_127){
+var _129=obj;
+obj=_127;
+_127=_129;
+}
+}
+if(Array.map){
+var _12a=Array.map(arr,_127,obj);
+}else{
+var _12a=[];
+for(var i=0;i&lt;arr.length;++i){
+_12a.push(_127.call(obj,arr[i]));
+}
+}
+if(_128){
+return _12a.join(&quot;&quot;);
+}else{
+return _12a;
+}
+};
+dojo.lang.forEach=function(_12c,_12d,_12e){
+if(dojo.lang.isString(_12c)){
+_12c=_12c.split(&quot;&quot;);
+}
+if(Array.forEach){
+Array.forEach(_12c,_12d,_12e);
+}else{
+if(!_12e){
+_12e=dj_global;
+}
+for(var i=0,l=_12c.length;i&lt;l;i++){
+_12d.call(_12e,_12c[i],i,_12c);
+}
+}
+};
+dojo.lang._everyOrSome=function(_130,arr,_132,_133){
+if(dojo.lang.isString(arr)){
+arr=arr.split(&quot;&quot;);
+}
+if(Array.every){
+return Array[(_130)?&quot;every&quot;:&quot;some&quot;](arr,_132,_133);
+}else{
+if(!_133){
+_133=dj_global;
+}
+for(var i=0,l=arr.length;i&lt;l;i++){
+var _135=_132.call(_133,arr[i],i,arr);
+if((_130)&amp;&amp;(!_135)){
+return false;
+}else{
+if((!_130)&amp;&amp;(_135)){
+return true;
+}
+}
+}
+return (_130)?true:false;
+}
+};
+dojo.lang.every=function(arr,_137,_138){
+return this._everyOrSome(true,arr,_137,_138);
+};
+dojo.lang.some=function(arr,_13a,_13b){
+return this._everyOrSome(false,arr,_13a,_13b);
+};
+dojo.lang.filter=function(arr,_13d,_13e){
+var _13f=dojo.lang.isString(arr);
+if(_13f){
+arr=arr.split(&quot;&quot;);
+}
+if(Array.filter){
+var _140=Array.filter(arr,_13d,_13e);
+}else{
+if(!_13e){
+if(arguments.length&gt;=3){
+dojo.raise(&quot;thisObject doesn't exist!&quot;);
+}
+_13e=dj_global;
+}
+var _140=[];
+for(var i=0;i&lt;arr.length;i++){
+if(_13d.call(_13e,arr[i],i,arr)){
+_140.push(arr[i]);
+}
+}
+}
+if(_13f){
+return _140.join(&quot;&quot;);
+}else{
+return _140;
+}
+};
+dojo.lang.unnest=function(){
+var out=[];
+for(var i=0;i&lt;arguments.length;i++){
+if(dojo.lang.isArrayLike(arguments[i])){
+var add=dojo.lang.unnest.apply(this,arguments[i]);
+out=out.concat(add);
+}else{
+out.push(arguments[i]);
+}
+}
+return out;
+};
+dojo.lang.toArray=function(_145,_146){
+var _147=[];
+for(var i=_146||0;i&lt;_145.length;i++){
+_147.push(_145[i]);
+}
+return _147;
+};
+dojo.provide(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.lang.hitch=function(_149,_14a){
+if(dojo.lang.isString(_14a)){
+var fcn=_149[_14a];
+}else{
+var fcn=_14a;
+}
+return function(){
+return fcn.apply(_149,arguments);
+};
+};
+dojo.lang.anonCtr=0;
+dojo.lang.anon={};
+dojo.lang.nameAnonFunc=function(_14c,_14d,_14e){
+var nso=(_14d||dojo.lang.anon);
+if((_14e)||((dj_global[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;slowAnonFuncLookups&quot;]==true))){
+for(var x in nso){
+if(nso[x]===_14c){
+return x;
+}
+}
+}
+var ret=&quot;__&quot;+dojo.lang.anonCtr++;
+while(typeof nso[ret]!=&quot;undefined&quot;){
+ret=&quot;__&quot;+dojo.lang.anonCtr++;
+}
+nso[ret]=_14c;
+return ret;
+};
+dojo.lang.forward=function(_152){
+return function(){
+return this[_152].apply(this,arguments);
+};
+};
+dojo.lang.curry=function(ns,func){
+var _155=[];
+ns=ns||dj_global;
+if(dojo.lang.isString(func)){
+func=ns[func];
+}
+for(var x=2;x&lt;arguments.length;x++){
+_155.push(arguments[x]);
+}
+var _157=(func[&quot;__preJoinArity&quot;]||func.length)-_155.length;
+function gather(_158,_159,_15a){
+var _15b=_15a;
+var _15c=_159.slice(0);
+for(var x=0;x&lt;_158.length;x++){
+_15c.push(_158[x]);
+}
+_15a=_15a-_158.length;
+if(_15a&lt;=0){
+var res=func.apply(ns,_15c);
+_15a=_15b;
+return res;
+}else{
+return function(){
+return gather(arguments,_15c,_15a);
+};
+}
+}
+return gather([],_155,_157);
+};
+dojo.lang.curryArguments=function(ns,func,args,_162){
+var _163=[];
+var x=_162||0;
+for(x=_162;x&lt;args.length;x++){
+_163.push(args[x]);
+}
+return dojo.lang.curry.apply(dojo.lang,[ns,func].concat(_163));
+};
+dojo.lang.tryThese=function(){
+for(var x=0;x&lt;arguments.length;x++){
+try{
+if(typeof arguments[x]==&quot;function&quot;){
+var ret=(arguments[x]());
+if(ret){
+return ret;
+}
+}
+}
+catch(e){
+dojo.debug(e);
+}
+}
+};
+dojo.lang.delayThese=function(farr,cb,_169,_16a){
+if(!farr.length){
+if(typeof _16a==&quot;function&quot;){
+_16a();
+}
+return;
+}
+if((typeof _169==&quot;undefined&quot;)&amp;&amp;(typeof cb==&quot;number&quot;)){
+_169=cb;
+cb=function(){
+};
+}else{
+if(!cb){
+cb=function(){
+};
+if(!_169){
+_169=0;
+}
+}
+}
+setTimeout(function(){
+(farr.shift())();
+cb();
+dojo.lang.delayThese(farr,cb,_169,_16a);
+},_169);
+};
+dojo.provide(&quot;dojo.string.extras&quot;);
+dojo.require(&quot;dojo.string.common&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+dojo.string.substituteParams=function(_16b,hash){
+var map=(typeof hash==&quot;object&quot;)?hash:dojo.lang.toArray(arguments,1);
+return _16b.replace(/\%\{(\w+)\}/g,function(_16e,key){
+return map[key]||dojo.raise(&quot;Substitution not found: &quot;+key);
+});
+};
+dojo.string.paramString=function(str,_171,_172){
+dojo.deprecated(&quot;dojo.string.paramString&quot;,&quot;use dojo.string.substituteParams instead&quot;,&quot;0.4&quot;);
+for(var name in _171){
+var re=new RegExp(&quot;\\%\\{&quot;+name+&quot;\\}&quot;,&quot;g&quot;);
+str=str.replace(re,_171[name]);
+}
+if(_172){
+str=str.replace(/%\{([^\}\s]+)\}/g,&quot;&quot;);
+}
+return str;
+};
+dojo.string.capitalize=function(str){
+if(!dojo.lang.isString(str)){
+return &quot;&quot;;
+}
+if(arguments.length==0){
+str=this;
+}
+var _176=str.split(&quot; &quot;);
+for(var i=0;i&lt;_176.length;i++){
+_176[i]=_176[i].charAt(0).toUpperCase()+_176[i].substring(1);
+}
+return _176.join(&quot; &quot;);
+};
+dojo.string.isBlank=function(str){
+if(!dojo.lang.isString(str)){
+return true;
+}
+return (dojo.string.trim(str).length==0);
+};
+dojo.string.encodeAscii=function(str){
+if(!dojo.lang.isString(str)){
+return str;
+}
+var ret=&quot;&quot;;
+var _17b=escape(str);
+var _17c,re=/%u([0-9A-F]{4})/i;
+while((_17c=_17b.match(re))){
+var num=Number(&quot;0x&quot;+_17c[1]);
+var _17e=escape(&quot;&amp;#&quot;+num+&quot;;&quot;);
+ret+=_17b.substring(0,_17c.index)+_17e;
+_17b=_17b.substring(_17c.index+_17c[0].length);
+}
+ret+=_17b.replace(/\+/g,&quot;%2B&quot;);
+return ret;
+};
+dojo.string.escape=function(type,str){
+var args=dojo.lang.toArray(arguments,1);
+switch(type.toLowerCase()){
+case &quot;xml&quot;:
+case &quot;html&quot;:
+case &quot;xhtml&quot;:
+return dojo.string.escapeXml.apply(this,args);
+case &quot;sql&quot;:
+return dojo.string.escapeSql.apply(this,args);
+case &quot;regexp&quot;:
+case &quot;regex&quot;:
+return dojo.string.escapeRegExp.apply(this,args);
+case &quot;javascript&quot;:
+case &quot;jscript&quot;:
+case &quot;js&quot;:
+return dojo.string.escapeJavaScript.apply(this,args);
+case &quot;ascii&quot;:
+return dojo.string.encodeAscii.apply(this,args);
+default:
+return str;
+}
+};
+dojo.string.escapeXml=function(str,_183){
+str=str.replace(/&amp;/gm,&quot;&amp;&quot;).replace(/&lt;/gm,&quot;&lt;&quot;).replace(/&gt;/gm,&quot;&gt;&quot;).replace(/&quot;/gm,&quot;&quot;&quot;);
+if(!_183){
+str=str.replace(/'/gm,&quot;&#39;&quot;);
+}
+return str;
+};
+dojo.string.escapeSql=function(str){
+return str.replace(/'/gm,&quot;''&quot;);
+};
+dojo.string.escapeRegExp=function(str){
+return str.replace(/\\/gm,&quot;\\\\&quot;).replace(/([\f\b\n\t\r[\^$|?*+(){}])/gm,&quot;\\$1&quot;);
+};
+dojo.string.escapeJavaScript=function(str){
+return str.replace(/([&quot;'\f\b\n\t\r])/gm,&quot;\\$1&quot;);
+};
+dojo.string.escapeString=function(str){
+return (&quot;\&quot;&quot;+str.replace(/([&quot;\\])/g,&quot;\\$1&quot;)+&quot;\&quot;&quot;).replace(/[\f]/g,&quot;\\f&quot;).replace(/[\b]/g,&quot;\\b&quot;).replace(/[\n]/g,&quot;\\n&quot;).replace(/[\t]/g,&quot;\\t&quot;).replace(/[\r]/g,&quot;\\r&quot;);
+};
+dojo.string.summary=function(str,len){
+if(!len||str.length&lt;=len){
+return str;
+}else{
+return str.substring(0,len).replace(/\.+$/,&quot;&quot;)+&quot;...&quot;;
+}
+};
+dojo.string.endsWith=function(str,end,_18c){
+if(_18c){
+str=str.toLowerCase();
+end=end.toLowerCase();
+}
+if((str.length-end.length)&lt;0){
+return false;
+}
+return str.lastIndexOf(end)==str.length-end.length;
+};
+dojo.string.endsWithAny=function(str){
+for(var i=1;i&lt;arguments.length;i++){
+if(dojo.string.endsWith(str,arguments[i])){
+return true;
+}
+}
+return false;
+};
+dojo.string.startsWith=function(str,_190,_191){
+if(_191){
+str=str.toLowerCase();
+_190=_190.toLowerCase();
+}
+return str.indexOf(_190)==0;
+};
+dojo.string.startsWithAny=function(str){
+for(var i=1;i&lt;arguments.length;i++){
+if(dojo.string.startsWith(str,arguments[i])){
+return true;
+}
+}
+return false;
+};
+dojo.string.has=function(str){
+for(var i=1;i&lt;arguments.length;i++){
+if(str.indexOf(arguments[i])&gt;-1){
+return true;
+}
+}
+return false;
+};
+dojo.string.normalizeNewlines=function(text,_197){
+if(_197==&quot;\n&quot;){
+text=text.replace(/\r\n/g,&quot;\n&quot;);
+text=text.replace(/\r/g,&quot;\n&quot;);
+}else{
+if(_197==&quot;\r&quot;){
+text=text.replace(/\r\n/g,&quot;\r&quot;);
+text=text.replace(/\n/g,&quot;\r&quot;);
+}else{
+text=text.replace(/([^\r])\n/g,&quot;$1\r\n&quot;);
+text=text.replace(/\r([^\n])/g,&quot;\r\n$1&quot;);
+}
+}
+return text;
+};
+dojo.string.splitEscaped=function(str,_199){
+var _19a=[];
+for(var i=0,prevcomma=0;i&lt;str.length;i++){
+if(str.charAt(i)==&quot;\\&quot;){
+i++;
+continue;
+}
+if(str.charAt(i)==_199){
+_19a.push(str.substring(prevcomma,i));
+prevcomma=i+1;
+}
+}
+_19a.push(str.substr(prevcomma));
+return _19a;
+};
+dojo.provide(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.dom.ELEMENT_NODE=1;
+dojo.dom.ATTRIBUTE_NODE=2;
+dojo.dom.TEXT_NODE=3;
+dojo.dom.CDATA_SECTION_NODE=4;
+dojo.dom.ENTITY_REFERENCE_NODE=5;
+dojo.dom.ENTITY_NODE=6;
+dojo.dom.PROCESSING_INSTRUCTION_NODE=7;
+dojo.dom.COMMENT_NODE=8;
+dojo.dom.DOCUMENT_NODE=9;
+dojo.dom.DOCUMENT_TYPE_NODE=10;
+dojo.dom.DOCUMENT_FRAGMENT_NODE=11;
+dojo.dom.NOTATION_NODE=12;
+dojo.dom.dojoml=&quot;<A HREF="http://www.dojotoolkit.org/2004/dojoml">http://www.dojotoolkit.org/2004/dojoml</A>&quot;;
+dojo.dom.xmlns={svg:&quot;<A HREF="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;,smil:&quot;<A HREF="http://www.w3.org/2001/SMIL20/">http://www.w3.org/2001/SMIL20/</A>&quot;,mml:&quot;<A HREF="http://www.w3.org/1998/Math/MathML">http://www.w3.org/1998/Math/MathML</A>&quot;,cml:&quot;<A HREF="http://www.xml-cml.org">http://www.xml-cml.org</A>&quot;,xlink:&quot;<A HREF="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</A>&quot;,xhtml:&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot;,xul:&quot;<A HREF="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul</A>&quot;,xbl:&quot;<A HREF="http://www.mozilla.org/xbl">http://www.mozilla.org/xbl</A>&quot;,fo:&quot;<A HREF="http://www.w3.org/1999/XSL/Format">http://www.w3.org/1999/XSL/Format</A>&quot;,xsl:&quot;<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>&quot;,xslt:&quot;<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>&quot;,xi:&quot;<A HREF="http://www.w3.org/2001/XInclude">http://www.w3.org/2001/XInclude</A>&quot;,xforms:&quot;<A HREF="http://www.w3.org/2002/01/xforms">http://www.w3.org/2002/01/xforms</A>&quot;,saxon:&quot;<A HREF="http://icl.com/saxon">http://icl.com/saxon</A>&quot;,xalan:&quot;<A HREF="http://xml.apache.org/xslt">http://xml.apache.org/xslt</A>&quot;,xsd:&quot;<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>&quot;,dt:&quot;<A HREF="http://www.w3.org/2001/XMLSchema-datatypes">http://www.w3.org/2001/XMLSchema-datatypes</A>&quot;,xsi:&quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot;,rdf:&quot;<A HREF="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</A>&quot;,rdfs:&quot;<A HREF="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</A>&quot;,dc:&quot;<A HREF="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</A>&quot;,dcq:&quot;<A HREF="http://purl.org/dc/qualifiers/1.0">http://purl.org/dc/qualifiers/1.0</A>&quot;,&quot;soap-env&quot;:&quot;<A HREF="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</A>&quot;,wsdl:&quot;<A HREF="http://schemas.xml!">http://schemas.xml!</A>
 soap.org/wsdl/&quot;,AdobeExtensions:&quot;<A HREF="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/">http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/</A>&quot;};
+dojo.dom.isNode=function(wh){
+if(typeof Element==&quot;object&quot;){
+try{
+return wh instanceof Element;
+}
+catch(E){
+}
+}else{
+return wh&amp;&amp;!isNaN(wh.nodeType);
+}
+};
+dojo.dom.getTagName=function(node){
+dojo.deprecated(&quot;dojo.dom.getTagName&quot;,&quot;use node.tagName instead&quot;,&quot;0.4&quot;);
+var _19e=node.tagName;
+if(_19e.substr(0,5).toLowerCase()!=&quot;dojo:&quot;){
+if(_19e.substr(0,4).toLowerCase()==&quot;dojo&quot;){
+return &quot;dojo:&quot;+_19e.substring(4).toLowerCase();
+}
+var djt=node.getAttribute(&quot;dojoType&quot;)||node.getAttribute(&quot;dojotype&quot;);
+if(djt){
+return &quot;dojo:&quot;+djt.toLowerCase();
+}
+if((node.getAttributeNS)&amp;&amp;(node.getAttributeNS(this.dojoml,&quot;type&quot;))){
+return &quot;dojo:&quot;+node.getAttributeNS(this.dojoml,&quot;type&quot;).toLowerCase();
+}
+try{
+djt=node.getAttribute(&quot;dojo:type&quot;);
+}
+catch(e){
+}
+if(djt){
+return &quot;dojo:&quot;+djt.toLowerCase();
+}
+if((!dj_global[&quot;djConfig&quot;])||(!djConfig[&quot;ignoreClassNames&quot;])){
+var _1a0=node.className||node.getAttribute(&quot;class&quot;);
+if((_1a0)&amp;&amp;(_1a0.indexOf)&amp;&amp;(_1a0.indexOf(&quot;dojo-&quot;)!=-1)){
+var _1a1=_1a0.split(&quot; &quot;);
+for(var x=0;x&lt;_1a1.length;x++){
+if((_1a1[x].length&gt;5)&amp;&amp;(_1a1[x].indexOf(&quot;dojo-&quot;)&gt;=0)){
+return &quot;dojo:&quot;+_1a1[x].substr(5).toLowerCase();
+}
+}
+}
+}
+}
+return _19e.toLowerCase();
+};
+dojo.dom.getUniqueId=function(){
+do{
+var id=&quot;dj_unique_&quot;+(++arguments.callee._idIncrement);
+}while(document.getElementById(id));
+return id;
+};
+dojo.dom.getUniqueId._idIncrement=0;
+dojo.dom.firstElement=dojo.dom.getFirstChildElement=function(_1a4,_1a5){
+var node=_1a4.firstChild;
+while(node&amp;&amp;node.nodeType!=dojo.dom.ELEMENT_NODE){
+node=node.nextSibling;
+}
+if(_1a5&amp;&amp;node&amp;&amp;node.tagName&amp;&amp;node.tagName.toLowerCase()!=_1a5.toLowerCase()){
+node=dojo.dom.nextElement(node,_1a5);
+}
+return node;
+};
+dojo.dom.lastElement=dojo.dom.getLastChildElement=function(_1a7,_1a8){
+var node=_1a7.lastChild;
+while(node&amp;&amp;node.nodeType!=dojo.dom.ELEMENT_NODE){
+node=node.previousSibling;
+}
+if(_1a8&amp;&amp;node&amp;&amp;node.tagName&amp;&amp;node.tagName.toLowerCase()!=_1a8.toLowerCase()){
+node=dojo.dom.prevElement(node,_1a8);
+}
+return node;
+};
+dojo.dom.nextElement=dojo.dom.getNextSiblingElement=function(node,_1ab){
+if(!node){
+return null;
+}
+do{
+node=node.nextSibling;
+}while(node&amp;&amp;node.nodeType!=dojo.dom.ELEMENT_NODE);
+if(node&amp;&amp;_1ab&amp;&amp;_1ab.toLowerCase()!=node.tagName.toLowerCase()){
+return dojo.dom.nextElement(node,_1ab);
+}
+return node;
+};
+dojo.dom.prevElement=dojo.dom.getPreviousSiblingElement=function(node,_1ad){
+if(!node){
+return null;
+}
+if(_1ad){
+_1ad=_1ad.toLowerCase();
+}
+do{
+node=node.previousSibling;
+}while(node&amp;&amp;node.nodeType!=dojo.dom.ELEMENT_NODE);
+if(node&amp;&amp;_1ad&amp;&amp;_1ad.toLowerCase()!=node.tagName.toLowerCase()){
+return dojo.dom.prevElement(node,_1ad);
+}
+return node;
+};
+dojo.dom.moveChildren=function(_1ae,_1af,trim){
+var _1b1=0;
+if(trim){
+while(_1ae.hasChildNodes()&amp;&amp;_1ae.firstChild.nodeType==dojo.dom.TEXT_NODE){
+_1ae.removeChild(_1ae.firstChild);
+}
+while(_1ae.hasChildNodes()&amp;&amp;_1ae.lastChild.nodeType==dojo.dom.TEXT_NODE){
+_1ae.removeChild(_1ae.lastChild);
+}
+}
+while(_1ae.hasChildNodes()){
+_1af.appendChild(_1ae.firstChild);
+_1b1++;
+}
+return _1b1;
+};
+dojo.dom.copyChildren=function(_1b2,_1b3,trim){
+var _1b5=_1b2.cloneNode(true);
+return this.moveChildren(_1b5,_1b3,trim);
+};
+dojo.dom.removeChildren=function(node){
+var _1b7=node.childNodes.length;
+while(node.hasChildNodes()){
+node.removeChild(node.firstChild);
+}
+return _1b7;
+};
+dojo.dom.replaceChildren=function(node,_1b9){
+dojo.dom.removeChildren(node);
+node.appendChild(_1b9);
+};
+dojo.dom.removeNode=function(node){
+if(node&amp;&amp;node.parentNode){
+return node.parentNode.removeChild(node);
+}
+};
+dojo.dom.getAncestors=function(node,_1bc,_1bd){
+var _1be=[];
+var _1bf=dojo.lang.isFunction(_1bc);
+while(node){
+if(!_1bf||_1bc(node)){
+_1be.push(node);
+}
+if(_1bd&amp;&amp;_1be.length&gt;0){
+return _1be[0];
+}
+node=node.parentNode;
+}
+if(_1bd){
+return null;
+}
+return _1be;
+};
+dojo.dom.getAncestorsByTag=function(node,tag,_1c2){
+tag=tag.toLowerCase();
+return dojo.dom.getAncestors(node,function(el){
+return ((el.tagName)&amp;&amp;(el.tagName.toLowerCase()==tag));
+},_1c2);
+};
+dojo.dom.getFirstAncestorByTag=function(node,tag){
+return dojo.dom.getAncestorsByTag(node,tag,true);
+};
+dojo.dom.isDescendantOf=function(node,_1c7,_1c8){
+if(_1c8&amp;&amp;node){
+node=node.parentNode;
+}
+while(node){
+if(node==_1c7){
+return true;
+}
+node=node.parentNode;
+}
+return false;
+};
+dojo.dom.innerXML=function(node){
+if(node.innerXML){
+return node.innerXML;
+}else{
+if(node.xml){
+return node.xml;
+}else{
+if(typeof XMLSerializer!=&quot;undefined&quot;){
+return (new XMLSerializer()).serializeToString(node);
+}
+}
+}
+};
+dojo.dom.createDocument=function(){
+var doc=null;
+if(!dj_undef(&quot;ActiveXObject&quot;)){
+var _1cb=[&quot;MSXML2&quot;,&quot;Microsoft&quot;,&quot;MSXML&quot;,&quot;MSXML3&quot;];
+for(var i=0;i&lt;_1cb.length;i++){
+try{
+doc=new ActiveXObject(_1cb[i]+&quot;.XMLDOM&quot;);
+}
+catch(e){
+}
+if(doc){
+break;
+}
+}
+}else{
+if((document.implementation)&amp;&amp;(document.implementation.createDocument)){
+doc=document.implementation.createDocument(&quot;&quot;,&quot;&quot;,null);
+}
+}
+return doc;
+};
+dojo.dom.createDocumentFromText=function(str,_1ce){
+if(!_1ce){
+_1ce=&quot;text/xml&quot;;
+}
+if(!dj_undef(&quot;DOMParser&quot;)){
+var _1cf=new DOMParser();
+return _1cf.parseFromString(str,_1ce);
+}else{
+if(!dj_undef(&quot;ActiveXObject&quot;)){
+var _1d0=dojo.dom.createDocument();
+if(_1d0){
+_1d0.async=false;
+_1d0.loadXML(str);
+return _1d0;
+}else{
+dojo.debug(&quot;toXml didn't work?&quot;);
+}
+}else{
+if(document.createElement){
+var tmp=document.createElement(&quot;xml&quot;);
+tmp.innerHTML=str;
+if(document.implementation&amp;&amp;document.implementation.createDocument){
+var _1d2=document.implementation.createDocument(&quot;foo&quot;,&quot;&quot;,null);
+for(var i=0;i&lt;tmp.childNodes.length;i++){
+_1d2.importNode(tmp.childNodes.item(i),true);
+}
+return _1d2;
+}
+return ((tmp.document)&amp;&amp;(tmp.document.firstChild?tmp.document.firstChild:tmp));
+}
+}
+}
+return null;
+};
+dojo.dom.prependChild=function(node,_1d5){
+if(_1d5.firstChild){
+_1d5.insertBefore(node,_1d5.firstChild);
+}else{
+_1d5.appendChild(node);
+}
+return true;
+};
+dojo.dom.insertBefore=function(node,ref,_1d8){
+if(_1d8!=true&amp;&amp;(node===ref||node.nextSibling===ref)){
+return false;
+}
+var _1d9=ref.parentNode;
+_1d9.insertBefore(node,ref);
+return true;
+};
+dojo.dom.insertAfter=function(node,ref,_1dc){
+var pn=ref.parentNode;
+if(ref==pn.lastChild){
+if((_1dc!=true)&amp;&amp;(node===ref)){
+return false;
+}
+pn.appendChild(node);
+}else{
+return this.insertBefore(node,ref.nextSibling,_1dc);
+}
+return true;
+};
+dojo.dom.insertAtPosition=function(node,ref,_1e0){
+if((!node)||(!ref)||(!_1e0)){
+return false;
+}
+switch(_1e0.toLowerCase()){
+case &quot;before&quot;:
+return dojo.dom.insertBefore(node,ref);
+case &quot;after&quot;:
+return dojo.dom.insertAfter(node,ref);
+case &quot;first&quot;:
+if(ref.firstChild){
+return dojo.dom.insertBefore(node,ref.firstChild);
+}else{
+ref.appendChild(node);
+return true;
+}
+break;
+default:
+ref.appendChild(node);
+return true;
+}
+};
+dojo.dom.insertAtIndex=function(node,_1e2,_1e3){
+var _1e4=_1e2.childNodes;
+if(!_1e4.length){
+_1e2.appendChild(node);
+return true;
+}
+var _1e5=null;
+for(var i=0;i&lt;_1e4.length;i++){
+var _1e7=_1e4.item(i)[&quot;getAttribute&quot;]?parseInt(_1e4.item(i).getAttribute(&quot;dojoinsertionindex&quot;)):-1;
+if(_1e7&lt;_1e3){
+_1e5=_1e4.item(i);
+}
+}
+if(_1e5){
+return dojo.dom.insertAfter(node,_1e5);
+}else{
+return dojo.dom.insertBefore(node,_1e4.item(0));
+}
+};
+dojo.dom.textContent=function(node,text){
+if(text){
+dojo.dom.replaceChildren(node,document.createTextNode(text));
+return text;
+}else{
+var _1ea=&quot;&quot;;
+if(node==null){
+return _1ea;
+}
+for(var i=0;i&lt;node.childNodes.length;i++){
+switch(node.childNodes[i].nodeType){
+case 1:
+case 5:
+_1ea+=dojo.dom.textContent(node.childNodes[i]);
+break;
+case 3:
+case 2:
+case 4:
+_1ea+=node.childNodes[i].nodeValue;
+break;
+default:
+break;
+}
+}
+return _1ea;
+}
+};
+dojo.dom.collectionToArray=function(_1ec){
+dojo.deprecated(&quot;dojo.dom.collectionToArray&quot;,&quot;use dojo.lang.toArray instead&quot;,&quot;0.4&quot;);
+return dojo.lang.toArray(_1ec);
+};
+dojo.dom.hasParent=function(node){
+return node&amp;&amp;node.parentNode&amp;&amp;dojo.dom.isNode(node.parentNode);
+};
+dojo.dom.isTag=function(node){
+if(node&amp;&amp;node.tagName){
+var arr=dojo.lang.toArray(arguments,1);
+return arr[dojo.lang.find(node.tagName,arr)]||&quot;&quot;;
+}
+return &quot;&quot;;
+};
+dojo.provide(&quot;dojo.undo.browser&quot;);
+dojo.require(&quot;dojo.io&quot;);
+try{
+if((!djConfig[&quot;preventBackButtonFix&quot;])&amp;&amp;(!dojo.hostenv.post_load_)){
+document.write(&quot;&lt;iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='&quot;+(dojo.hostenv.getBaseScriptUri()+&quot;iframe_history.html&quot;)+&quot;'&gt;&lt;/iframe&gt;&quot;);
+}
+}
+catch(e){
+}
+if(dojo.render.html.opera){
+dojo.debug(&quot;Opera is not supported with dojo.undo.browser, so back/forward detection will not work.&quot;);
+}
+dojo.undo.browser={initialHref:window.location.href,initialHash:window.location.hash,moveForward:false,historyStack:[],forwardStack:[],historyIframe:null,bookmarkAnchor:null,locationTimer:null,setInitialState:function(args){
+this.initialState={&quot;url&quot;:this.initialHref,&quot;kwArgs&quot;:args,&quot;urlHash&quot;:this.initialHash};
+},addToHistory:function(args){
+var hash=null;
+if(!this.historyIframe){
+this.historyIframe=window.frames[&quot;djhistory&quot;];
+}
+if(!this.bookmarkAnchor){
+this.bookmarkAnchor=document.createElement(&quot;a&quot;);
+(document.body||document.getElementsByTagName(&quot;body&quot;)[0]).appendChild(this.bookmarkAnchor);
+this.bookmarkAnchor.style.display=&quot;none&quot;;
+}
+if((!args[&quot;changeUrl&quot;])||(dojo.render.html.ie)){
+var url=dojo.hostenv.getBaseScriptUri()+&quot;iframe_history.html?&quot;+(new Date()).getTime();
+this.moveForward=true;
+dojo.io.setIFrameSrc(this.historyIframe,url,false);
+}
+if(args[&quot;changeUrl&quot;]){
+this.changingUrl=true;
+hash=&quot;#&quot;+((args[&quot;changeUrl&quot;]!==true)?args[&quot;changeUrl&quot;]:(new Date()).getTime());
+setTimeout(&quot;window.location.href = '&quot;+hash+&quot;'; dojo.undo.browser.changingUrl = false;&quot;,1);
+this.bookmarkAnchor.href=hash;
+if(dojo.render.html.ie){
+var _1f4=args[&quot;back&quot;]||args[&quot;backButton&quot;]||args[&quot;handle&quot;];
+var tcb=function(_1f6){
+if(window.location.hash!=&quot;&quot;){
+setTimeout(&quot;window.location.href = '&quot;+hash+&quot;';&quot;,1);
+}
+_1f4.apply(this,[_1f6]);
+};
+if(args[&quot;back&quot;]){
+args.back=tcb;
+}else{
+if(args[&quot;backButton&quot;]){
+args.backButton=tcb;
+}else{
+if(args[&quot;handle&quot;]){
+args.handle=tcb;
+}
+}
+}
+this.forwardStack=[];
+var _1f7=args[&quot;forward&quot;]||args[&quot;forwardButton&quot;]||args[&quot;handle&quot;];
+var tfw=function(_1f9){
+if(window.location.hash!=&quot;&quot;){
+window.location.href=hash;
+}
+if(_1f7){
+_1f7.apply(this,[_1f9]);
+}
+};
+if(args[&quot;forward&quot;]){
+args.forward=tfw;
+}else{
+if(args[&quot;forwardButton&quot;]){
+args.forwardButton=tfw;
+}else{
+if(args[&quot;handle&quot;]){
+args.handle=tfw;
+}
+}
+}
+}else{
+if(dojo.render.html.moz){
+if(!this.locationTimer){
+this.locationTimer=setInterval(&quot;dojo.undo.browser.checkLocation();&quot;,200);
+}
+}
+}
+}
+this.historyStack.push({&quot;url&quot;:url,&quot;kwArgs&quot;:args,&quot;urlHash&quot;:hash});
+},checkLocation:function(){
+if(!this.changingUrl){
+var hsl=this.historyStack.length;
+if((window.location.hash==this.initialHash||window.location.href==this.initialHref)&amp;&amp;(hsl==1)){
+this.handleBackButton();
+return;
+}
+if(this.forwardStack.length&gt;0){
+if(this.forwardStack[this.forwardStack.length-1].urlHash==window.location.hash){
+this.handleForwardButton();
+return;
+}
+}
+if((hsl&gt;=2)&amp;&amp;(this.historyStack[hsl-2])){
+if(this.historyStack[hsl-2].urlHash==window.location.hash){
+this.handleBackButton();
+return;
+}
+}
+}
+},iframeLoaded:function(evt,_1fc){
+if(!dojo.render.html.opera){
+var _1fd=this._getUrlQuery(_1fc.href);
+if(_1fd==null){
+if(this.historyStack.length==1){
+this.handleBackButton();
+}
+return;
+}
+if(this.moveForward){
+this.moveForward=false;
+return;
+}
+if(this.historyStack.length&gt;=2&amp;&amp;_1fd==this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
+this.handleBackButton();
+}else{
+if(this.forwardStack.length&gt;0&amp;&amp;_1fd==this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
+this.handleForwardButton();
+}
+}
+}
+},handleBackButton:function(){
+var _1fe=this.historyStack.pop();
+if(!_1fe){
+return;
+}
+var last=this.historyStack[this.historyStack.length-1];
+if(!last&amp;&amp;this.historyStack.length==0){
+last=this.initialState;
+}
+if(last){
+if(last.kwArgs[&quot;back&quot;]){
+last.kwArgs[&quot;back&quot;]();
+}else{
+if(last.kwArgs[&quot;backButton&quot;]){
+last.kwArgs[&quot;backButton&quot;]();
+}else{
+if(last.kwArgs[&quot;handle&quot;]){
+last.kwArgs.handle(&quot;back&quot;);
+}
+}
+}
+}
+this.forwardStack.push(_1fe);
+},handleForwardButton:function(){
+var last=this.forwardStack.pop();
+if(!last){
+return;
+}
+if(last.kwArgs[&quot;forward&quot;]){
+last.kwArgs.forward();
+}else{
+if(last.kwArgs[&quot;forwardButton&quot;]){
+last.kwArgs.forwardButton();
+}else{
+if(last.kwArgs[&quot;handle&quot;]){
+last.kwArgs.handle(&quot;forward&quot;);
+}
+}
+}
+this.historyStack.push(last);
+},_getUrlQuery:function(url){
+var _202=url.split(&quot;?&quot;);
+if(_202.length&lt;2){
+return null;
+}else{
+return _202[1];
+}
+}};
+dojo.provide(&quot;dojo.io.BrowserIO&quot;);
+dojo.require(&quot;dojo.io&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.string.extras&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.undo.browser&quot;);
+dojo.io.checkChildrenForFile=function(node){
+var _204=false;
+var _205=node.getElementsByTagName(&quot;input&quot;);
+dojo.lang.forEach(_205,function(_206){
+if(_204){
+return;
+}
+if(_206.getAttribute(&quot;type&quot;)==&quot;file&quot;){
+_204=true;
+}
+});
+return _204;
+};
+dojo.io.formHasFile=function(_207){
+return dojo.io.checkChildrenForFile(_207);
+};
+dojo.io.updateNode=function(node,_209){
+node=dojo.byId(node);
+var args=_209;
+if(dojo.lang.isString(_209)){
+args={url:_209};
+}
+args.mimetype=&quot;text/html&quot;;
+args.load=function(t,d,e){
+while(node.firstChild){
+if(dojo[&quot;event&quot;]){
+try{
+dojo.event.browser.clean(node.firstChild);
+}
+catch(e){
+}
+}
+node.removeChild(node.firstChild);
+}
+node.innerHTML=d;
+};
+dojo.io.bind(args);
+};
+dojo.io.formFilter=function(node){
+var type=(node.type||&quot;&quot;).toLowerCase();
+return !node.disabled&amp;&amp;node.name&amp;&amp;!dojo.lang.inArray(type,[&quot;file&quot;,&quot;submit&quot;,&quot;image&quot;,&quot;reset&quot;,&quot;button&quot;]);
+};
+dojo.io.encodeForm=function(_210,_211,_212){
+if((!_210)||(!_210.tagName)||(!_210.tagName.toLowerCase()==&quot;form&quot;)){
+dojo.raise(&quot;Attempted to encode a non-form element.&quot;);
+}
+if(!_212){
+_212=dojo.io.formFilter;
+}
+var enc=/utf/i.test(_211||&quot;&quot;)?encodeURIComponent:dojo.string.encodeAscii;
+var _214=[];
+for(var i=0;i&lt;_210.elements.length;i++){
+var elm=_210.elements[i];
+if(!elm||elm.tagName.toLowerCase()==&quot;fieldset&quot;||!_212(elm)){
+continue;
+}
+var name=enc(elm.name);
+var type=elm.type.toLowerCase();
+if(type==&quot;select-multiple&quot;){
+for(var j=0;j&lt;elm.options.length;j++){
+if(elm.options[j].selected){
+_214.push(name+&quot;=&quot;+enc(elm.options[j].value));
+}
+}
+}else{
+if(dojo.lang.inArray(type,[&quot;radio&quot;,&quot;checkbox&quot;])){
+if(elm.checked){
+_214.push(name+&quot;=&quot;+enc(elm.value));
+}
+}else{
+_214.push(name+&quot;=&quot;+enc(elm.value));
+}
+}
+}
+var _21a=_210.getElementsByTagName(&quot;input&quot;);
+for(var i=0;i&lt;_21a.length;i++){
+var _21b=_21a[i];
+if(_21b.type.toLowerCase()==&quot;image&quot;&amp;&amp;_21b.form==_210&amp;&amp;_212(_21b)){
+var name=enc(_21b.name);
+_214.push(name+&quot;=&quot;+enc(_21b.value));
+_214.push(name+&quot;.x=0&quot;);
+_214.push(name+&quot;.y=0&quot;);
+}
+}
+return _214.join(&quot;&amp;&quot;)+&quot;&amp;&quot;;
+};
+dojo.io.FormBind=function(args){
+this.bindArgs={};
+if(args&amp;&amp;args.formNode){
+this.init(args);
+}else{
+if(args){
+this.init({formNode:args});
+}
+}
+};
+dojo.lang.extend(dojo.io.FormBind,{form:null,bindArgs:null,clickedButton:null,init:function(args){
+var form=dojo.byId(args.formNode);
+if(!form||!form.tagName||form.tagName.toLowerCase()!=&quot;form&quot;){
+throw new Error(&quot;FormBind: Couldn't apply, invalid form&quot;);
+}else{
+if(this.form==form){
+return;
+}else{
+if(this.form){
+throw new Error(&quot;FormBind: Already applied to a form&quot;);
+}
+}
+}
+dojo.lang.mixin(this.bindArgs,args);
+this.form=form;
+this.connect(form,&quot;onsubmit&quot;,&quot;submit&quot;);
+for(var i=0;i&lt;form.elements.length;i++){
+var node=form.elements[i];
+if(node&amp;&amp;node.type&amp;&amp;dojo.lang.inArray(node.type.toLowerCase(),[&quot;submit&quot;,&quot;button&quot;])){
+this.connect(node,&quot;onclick&quot;,&quot;click&quot;);
+}
+}
+var _221=form.getElementsByTagName(&quot;input&quot;);
+for(var i=0;i&lt;_221.length;i++){
+var _222=_221[i];
+if(_222.type.toLowerCase()==&quot;image&quot;&amp;&amp;_222.form==form){
+this.connect(_222,&quot;onclick&quot;,&quot;click&quot;);
+}
+}
+},onSubmit:function(form){
+return true;
+},submit:function(e){
+e.preventDefault();
+if(this.onSubmit(this.form)){
+dojo.io.bind(dojo.lang.mixin(this.bindArgs,{formFilter:dojo.lang.hitch(this,&quot;formFilter&quot;)}));
+}
+},click:function(e){
+var node=e.currentTarget;
+if(node.disabled){
+return;
+}
+this.clickedButton=node;
+},formFilter:function(node){
+var type=(node.type||&quot;&quot;).toLowerCase();
+var _229=false;
+if(node.disabled||!node.name){
+_229=false;
+}else{
+if(dojo.lang.inArray(type,[&quot;submit&quot;,&quot;button&quot;,&quot;image&quot;])){
+if(!this.clickedButton){
+this.clickedButton=node;
+}
+_229=node==this.clickedButton;
+}else{
+_229=!dojo.lang.inArray(type,[&quot;file&quot;,&quot;submit&quot;,&quot;reset&quot;,&quot;button&quot;]);
+}
+}
+return _229;
+},connect:function(_22a,_22b,_22c){
+if(dojo.evalObjPath(&quot;dojo.event.connect&quot;)){
+dojo.event.connect(_22a,_22b,this,_22c);
+}else{
+var fcn=dojo.lang.hitch(this,_22c);
+_22a[_22b]=function(e){
+if(!e){
+e=window.event;
+}
+if(!e.currentTarget){
+e.currentTarget=e.srcElement;
+}
+if(!e.preventDefault){
+e.preventDefault=function(){
+window.event.returnValue=false;
+};
+}
+fcn(e);
+};
+}
+}});
+dojo.io.XMLHTTPTransport=new function(){
+var _22f=this;
+var _230={};
+this.useCache=false;
+this.preventCache=false;
+function getCacheKey(url,_232,_233){
+return url+&quot;|&quot;+_232+&quot;|&quot;+_233.toLowerCase();
+}
+function addToCache(url,_235,_236,http){
+_230[getCacheKey(url,_235,_236)]=http;
+}
+function getFromCache(url,_239,_23a){
+return _230[getCacheKey(url,_239,_23a)];
+}
+this.clearCache=function(){
+_230={};
+};
+function doLoad(_23b,http,url,_23e,_23f){
+if(((http.status&gt;=200)&amp;&amp;(http.status&lt;300))||(http.status==304)||(location.protocol==&quot;file:&quot;&amp;&amp;(http.status==0||http.status==undefined))||(location.protocol==&quot;chrome:&quot;&amp;&amp;(http.status==0||http.status==undefined))){
+var ret;
+if(_23b.method.toLowerCase()==&quot;head&quot;){
+var _241=http.getAllResponseHeaders();
+ret={};
+ret.toString=function(){
+return _241;
+};
+var _242=_241.split(/[\r\n]+/g);
+for(var i=0;i&lt;_242.length;i++){
+var pair=_242[i].match(/^([^:]+)\s*:\s*(.+)$/i);
+if(pair){
+ret[pair[1]]=pair[2];
+}
+}
+}else{
+if(_23b.mimetype==&quot;text/javascript&quot;){
+try{
+ret=dj_eval(http.responseText);
+}
+catch(e){
+dojo.debug(e);
+dojo.debug(http.responseText);
+ret=null;
+}
+}else{
+if(_23b.mimetype==&quot;text/json&quot;){
+try{
+ret=dj_eval(&quot;(&quot;+http.responseText+&quot;)&quot;);
+}
+catch(e){
+dojo.debug(e);
+dojo.debug(http.responseText);
+ret=false;
+}
+}else{
+if((_23b.mimetype==&quot;application/xml&quot;)||(_23b.mimetype==&quot;text/xml&quot;)){
+ret=http.responseXML;
+if(!ret||typeof ret==&quot;string&quot;||!http.getResponseHeader(&quot;Content-Type&quot;)){
+ret=dojo.dom.createDocumentFromText(http.responseText);
+}
+}else{
+ret=http.responseText;
+}
+}
+}
+}
+if(_23f){
+addToCache(url,_23e,_23b.method,http);
+}
+_23b[(typeof _23b.load==&quot;function&quot;)?&quot;load&quot;:&quot;handle&quot;](&quot;load&quot;,ret,http,_23b);
+}else{
+var _245=new dojo.io.Error(&quot;XMLHttpTransport Error: &quot;+http.status+&quot; &quot;+http.statusText);
+_23b[(typeof _23b.error==&quot;function&quot;)?&quot;error&quot;:&quot;handle&quot;](&quot;error&quot;,_245,http,_23b);
+}
+}
+function setHeaders(http,_247){
+if(_247[&quot;headers&quot;]){
+for(var _248 in _247[&quot;headers&quot;]){
+if(_248.toLowerCase()==&quot;content-type&quot;&amp;&amp;!_247[&quot;contentType&quot;]){
+_247[&quot;contentType&quot;]=_247[&quot;headers&quot;][_248];
+}else{
+http.setRequestHeader(_248,_247[&quot;headers&quot;][_248]);
+}
+}
+}
+}
+this.inFlight=[];
+this.inFlightTimer=null;
+this.startWatchingInFlight=function(){
+if(!this.inFlightTimer){
+this.inFlightTimer=setInterval(&quot;dojo.io.XMLHTTPTransport.watchInFlight();&quot;,10);
+}
+};
+this.watchInFlight=function(){
+var now=null;
+for(var x=this.inFlight.length-1;x&gt;=0;x--){
+var tif=this.inFlight[x];
+if(!tif){
+this.inFlight.splice(x,1);
+continue;
+}
+if(4==tif.http.readyState){
+this.inFlight.splice(x,1);
+doLoad(tif.req,tif.http,tif.url,tif.query,tif.useCache);
+}else{
+if(tif.startTime){
+if(!now){
+now=(new Date()).getTime();
+}
+if(tif.startTime+(tif.req.timeoutSeconds*1000)&lt;now){
+if(typeof tif.http.abort==&quot;function&quot;){
+tif.http.abort();
+}
+this.inFlight.splice(x,1);
+tif.req[(typeof tif.req.timeout==&quot;function&quot;)?&quot;timeout&quot;:&quot;handle&quot;](&quot;timeout&quot;,null,tif.http,tif.req);
+}
+}
+}
+}
+if(this.inFlight.length==0){
+clearInterval(this.inFlightTimer);
+this.inFlightTimer=null;
+}
+};
+var _24c=dojo.hostenv.getXmlhttpObject()?true:false;
+this.canHandle=function(_24d){
+return _24c&amp;&amp;dojo.lang.inArray((_24d[&quot;mimetype&quot;].toLowerCase()||&quot;&quot;),[&quot;text/plain&quot;,&quot;text/html&quot;,&quot;application/xml&quot;,&quot;text/xml&quot;,&quot;text/javascript&quot;,&quot;text/json&quot;])&amp;&amp;!(_24d[&quot;formNode&quot;]&amp;&amp;dojo.io.formHasFile(_24d[&quot;formNode&quot;]));
+};
+this.multipartBoundary=&quot;45309FFF-BD65-4d50-99C9-36986896A96F&quot;;
+this.bind=function(_24e){
+if(!_24e[&quot;url&quot;]){
+if(!_24e[&quot;formNode&quot;]&amp;&amp;(_24e[&quot;backButton&quot;]||_24e[&quot;back&quot;]||_24e[&quot;changeUrl&quot;]||_24e[&quot;watchForURL&quot;])&amp;&amp;(!djConfig.preventBackButtonFix)){
+dojo.deprecated(&quot;Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request&quot;,&quot;Use dojo.undo.browser.addToHistory() instead.&quot;,&quot;0.4&quot;);
+dojo.undo.browser.addToHistory(_24e);
+return true;
+}
+}
+var url=_24e.url;
+var _250=&quot;&quot;;
+if(_24e[&quot;formNode&quot;]){
+var ta=_24e.formNode.getAttribute(&quot;action&quot;);
+if((ta)&amp;&amp;(!_24e[&quot;url&quot;])){
+url=ta;
+}
+var tp=_24e.formNode.getAttribute(&quot;method&quot;);
+if((tp)&amp;&amp;(!_24e[&quot;method&quot;])){
+_24e.method=tp;
+}
+_250+=dojo.io.encodeForm(_24e.formNode,_24e.encoding,_24e[&quot;formFilter&quot;]);
+}
+if(url.indexOf(&quot;#&quot;)&gt;-1){
+dojo.debug(&quot;Warning: dojo.io.bind: stripping hash values from url:&quot;,url);
+url=url.split(&quot;#&quot;)[0];
+}
+if(_24e[&quot;file&quot;]){
+_24e.method=&quot;post&quot;;
+}
+if(!_24e[&quot;method&quot;]){
+_24e.method=&quot;get&quot;;
+}
+if(_24e.method.toLowerCase()==&quot;get&quot;){
+_24e.multipart=false;
+}else{
+if(_24e[&quot;file&quot;]){
+_24e.multipart=true;
+}else{
+if(!_24e[&quot;multipart&quot;]){
+_24e.multipart=false;
+}
+}
+}
+if(_24e[&quot;backButton&quot;]||_24e[&quot;back&quot;]||_24e[&quot;changeUrl&quot;]){
+dojo.undo.browser.addToHistory(_24e);
+}
+var _253=_24e[&quot;content&quot;]||{};
+if(_24e.sendTransport){
+_253[&quot;dojo.transport&quot;]=&quot;xmlhttp&quot;;
+}
+do{
+if(_24e.postContent){
+_250=_24e.postContent;
+break;
+}
+if(_253){
+_250+=dojo.io.argsFromMap(_253,_24e.encoding);
+}
+if(_24e.method.toLowerCase()==&quot;get&quot;||!_24e.multipart){
+break;
+}
+var t=[];
+if(_250.length){
+var q=_250.split(&quot;&amp;&quot;);
+for(var i=0;i&lt;q.length;++i){
+if(q[i].length){
+var p=q[i].split(&quot;=&quot;);
+t.push(&quot;--&quot;+this.multipartBoundary,&quot;Content-Disposition: form-data; name=\&quot;&quot;+p[0]+&quot;\&quot;&quot;,&quot;&quot;,p[1]);
+}
+}
+}
+if(_24e.file){
+if(dojo.lang.isArray(_24e.file)){
+for(var i=0;i&lt;_24e.file.length;++i){
+var o=_24e.file[i];
+t.push(&quot;--&quot;+this.multipartBoundary,&quot;Content-Disposition: form-data; name=\&quot;&quot;+o.name+&quot;\&quot;; filename=\&quot;&quot;+(&quot;fileName&quot; in o?o.fileName:o.name)+&quot;\&quot;&quot;,&quot;Content-Type: &quot;+(&quot;contentType&quot; in o?o.contentType:&quot;application/octet-stream&quot;),&quot;&quot;,o.content);
+}
+}else{
+var o=_24e.file;
+t.push(&quot;--&quot;+this.multipartBoundary,&quot;Content-Disposition: form-data; name=\&quot;&quot;+o.name+&quot;\&quot;; filename=\&quot;&quot;+(&quot;fileName&quot; in o?o.fileName:o.name)+&quot;\&quot;&quot;,&quot;Content-Type: &quot;+(&quot;contentType&quot; in o?o.contentType:&quot;application/octet-stream&quot;),&quot;&quot;,o.content);
+}
+}
+if(t.length){
+t.push(&quot;--&quot;+this.multipartBoundary+&quot;--&quot;,&quot;&quot;);
+_250=t.join(&quot;\r\n&quot;);
+}
+}while(false);
+var _259=_24e[&quot;sync&quot;]?false:true;
+var _25a=_24e[&quot;preventCache&quot;]||(this.preventCache==true&amp;&amp;_24e[&quot;preventCache&quot;]!=false);
+var _25b=_24e[&quot;useCache&quot;]==true||(this.useCache==true&amp;&amp;_24e[&quot;useCache&quot;]!=false);
+if(!_25a&amp;&amp;_25b){
+var _25c=getFromCache(url,_250,_24e.method);
+if(_25c){
+doLoad(_24e,_25c,url,_250,false);
+return;
+}
+}
+var http=dojo.hostenv.getXmlhttpObject(_24e);
+var _25e=false;
+if(_259){
+var _25f=this.inFlight.push({&quot;req&quot;:_24e,&quot;http&quot;:http,&quot;url&quot;:url,&quot;query&quot;:_250,&quot;useCache&quot;:_25b,&quot;startTime&quot;:_24e.timeoutSeconds?(new Date()).getTime():0});
+this.startWatchingInFlight();
+}
+if(_24e.method.toLowerCase()==&quot;post&quot;){
+http.open(&quot;POST&quot;,url,_259);
+setHeaders(http,_24e);
+http.setRequestHeader(&quot;Content-Type&quot;,_24e.multipart?(&quot;multipart/form-data; boundary=&quot;+this.multipartBoundary):(_24e.contentType||&quot;application/x-www-form-urlencoded&quot;));
+try{
+http.send(_250);
+}
+catch(e){
+if(typeof http.abort==&quot;function&quot;){
+http.abort();
+}
+doLoad(_24e,{status:404},url,_250,_25b);
+}
+}else{
+var _260=url;
+if(_250!=&quot;&quot;){
+_260+=(_260.indexOf(&quot;?&quot;)&gt;-1?&quot;&amp;&quot;:&quot;?&quot;)+_250;
+}
+if(_25a){
+_260+=(dojo.string.endsWithAny(_260,&quot;?&quot;,&quot;&amp;&quot;)?&quot;&quot;:(_260.indexOf(&quot;?&quot;)&gt;-1?&quot;&amp;&quot;:&quot;?&quot;))+&quot;dojo.preventCache=&quot;+new Date().valueOf();
+}
+http.open(_24e.method.toUpperCase(),_260,_259);
+setHeaders(http,_24e);
+try{
+http.send(null);
+}
+catch(e){
+if(typeof http.abort==&quot;function&quot;){
+http.abort();
+}
+doLoad(_24e,{status:404},url,_250,_25b);
+}
+}
+if(!_259){
+doLoad(_24e,http,url,_250,_25b);
+}
+_24e.abort=function(){
+return http.abort();
+};
+return;
+};
+dojo.io.transports.addTransport(&quot;XMLHTTPTransport&quot;);
+};
+dojo.provide(&quot;dojo.event&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.event=new function(){
+this.canTimeout=dojo.lang.isFunction(dj_global[&quot;setTimeout&quot;])||dojo.lang.isAlien(dj_global[&quot;setTimeout&quot;]);
+function interpolateArgs(args,_262){
+var dl=dojo.lang;
+var ao={srcObj:dj_global,srcFunc:null,adviceObj:dj_global,adviceFunc:null,aroundObj:null,aroundFunc:null,adviceType:(args.length&gt;2)?args[0]:&quot;after&quot;,precedence:&quot;last&quot;,once:false,delay:null,rate:0,adviceMsg:false};
+switch(args.length){
+case 0:
+return;
+case 1:
+return;
+case 2:
+ao.srcFunc=args[0];
+ao.adviceFunc=args[1];
+break;
+case 3:
+if((dl.isObject(args[0]))&amp;&amp;(dl.isString(args[1]))&amp;&amp;(dl.isString(args[2]))){
+ao.adviceType=&quot;after&quot;;
+ao.srcObj=args[0];
+ao.srcFunc=args[1];
+ao.adviceFunc=args[2];
+}else{
+if((dl.isString(args[1]))&amp;&amp;(dl.isString(args[2]))){
+ao.srcFunc=args[1];
+ao.adviceFunc=args[2];
+}else{
+if((dl.isObject(args[0]))&amp;&amp;(dl.isString(args[1]))&amp;&amp;(dl.isFunction(args[2]))){
+ao.adviceType=&quot;after&quot;;
+ao.srcObj=args[0];
+ao.srcFunc=args[1];
+var _265=dl.nameAnonFunc(args[2],ao.adviceObj,_262);
+ao.adviceFunc=_265;
+}else{
+if((dl.isFunction(args[0]))&amp;&amp;(dl.isObject(args[1]))&amp;&amp;(dl.isString(args[2]))){
+ao.adviceType=&quot;after&quot;;
+ao.srcObj=dj_global;
+var _265=dl.nameAnonFunc(args[0],ao.srcObj,_262);
+ao.srcFunc=_265;
+ao.adviceObj=args[1];
+ao.adviceFunc=args[2];
+}
+}
+}
+}
+break;
+case 4:
+if((dl.isObject(args[0]))&amp;&amp;(dl.isObject(args[2]))){
+ao.adviceType=&quot;after&quot;;
+ao.srcObj=args[0];
+ao.srcFunc=args[1];
+ao.adviceObj=args[2];
+ao.adviceFunc=args[3];
+}else{
+if((dl.isString(args[0]))&amp;&amp;(dl.isString(args[1]))&amp;&amp;(dl.isObject(args[2]))){
+ao.adviceType=args[0];
+ao.srcObj=dj_global;
+ao.srcFunc=args[1];
+ao.adviceObj=args[2];
+ao.adviceFunc=args[3];
+}else{
+if((dl.isString(args[0]))&amp;&amp;(dl.isFunction(args[1]))&amp;&amp;(dl.isObject(args[2]))){
+ao.adviceType=args[0];
+ao.srcObj=dj_global;
+var _265=dl.nameAnonFunc(args[1],dj_global,_262);
+ao.srcFunc=_265;
+ao.adviceObj=args[2];
+ao.adviceFunc=args[3];
+}else{
+if((dl.isString(args[0]))&amp;&amp;(dl.isObject(args[1]))&amp;&amp;(dl.isString(args[2]))&amp;&amp;(dl.isFunction(args[3]))){
+ao.srcObj=args[1];
+ao.srcFunc=args[2];
+var _265=dl.nameAnonFunc(args[3],dj_global,_262);
+ao.adviceObj=dj_global;
+ao.adviceFunc=_265;
+}else{
+if(dl.isObject(args[1])){
+ao.srcObj=args[1];
+ao.srcFunc=args[2];
+ao.adviceObj=dj_global;
+ao.adviceFunc=args[3];
+}else{
+if(dl.isObject(args[2])){
+ao.srcObj=dj_global;
+ao.srcFunc=args[1];
+ao.adviceObj=args[2];
+ao.adviceFunc=args[3];
+}else{
+ao.srcObj=ao.adviceObj=ao.aroundObj=dj_global;
+ao.srcFunc=args[1];
+ao.adviceFunc=args[2];
+ao.aroundFunc=args[3];
+}
+}
+}
+}
+}
+}
+break;
+case 6:
+ao.srcObj=args[1];
+ao.srcFunc=args[2];
+ao.adviceObj=args[3];
+ao.adviceFunc=args[4];
+ao.aroundFunc=args[5];
+ao.aroundObj=dj_global;
+break;
+default:
+ao.srcObj=args[1];
+ao.srcFunc=args[2];
+ao.adviceObj=args[3];
+ao.adviceFunc=args[4];
+ao.aroundObj=args[5];
+ao.aroundFunc=args[6];
+ao.once=args[7];
+ao.delay=args[8];
+ao.rate=args[9];
+ao.adviceMsg=args[10];
+break;
+}
+if(dl.isFunction(ao.aroundFunc)){
+var _265=dl.nameAnonFunc(ao.aroundFunc,ao.aroundObj,_262);
+ao.aroundFunc=_265;
+}
+if(dl.isFunction(ao.srcFunc)){
+ao.srcFunc=dl.getNameInObj(ao.srcObj,ao.srcFunc);
+}
+if(dl.isFunction(ao.adviceFunc)){
+ao.adviceFunc=dl.getNameInObj(ao.adviceObj,ao.adviceFunc);
+}
+if((ao.aroundObj)&amp;&amp;(dl.isFunction(ao.aroundFunc))){
+ao.aroundFunc=dl.getNameInObj(ao.aroundObj,ao.aroundFunc);
+}
+if(!ao.srcObj){
+dojo.raise(&quot;bad srcObj for srcFunc: &quot;+ao.srcFunc);
+}
+if(!ao.adviceObj){
+dojo.raise(&quot;bad adviceObj for adviceFunc: &quot;+ao.adviceFunc);
+}
+return ao;
+}
+this.connect=function(){
+if(arguments.length==1){
+var ao=arguments[0];
+}else{
+var ao=interpolateArgs(arguments,true);
+}
+if(dojo.lang.isArray(ao.srcObj)&amp;&amp;ao.srcObj!=&quot;&quot;){
+var _267={};
+for(var x in ao){
+_267[x]=ao[x];
+}
+var mjps=[];
+dojo.lang.forEach(ao.srcObj,function(src){
+if((dojo.render.html.capable)&amp;&amp;(dojo.lang.isString(src))){
+src=dojo.byId(src);
+}
+_267.srcObj=src;
+mjps.push(dojo.event.connect.call(dojo.event,_267));
+});
+return mjps;
+}
+var mjp=dojo.event.MethodJoinPoint.getForMethod(ao.srcObj,ao.srcFunc);
+if(ao.adviceFunc){
+var mjp2=dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj,ao.adviceFunc);
+}
+mjp.kwAddAdvice(ao);
+return mjp;
+};
+this.log=function(a1,a2){
+var _26f;
+if((arguments.length==1)&amp;&amp;(typeof a1==&quot;object&quot;)){
+_26f=a1;
+}else{
+_26f={srcObj:a1,srcFunc:a2};
+}
+_26f.adviceFunc=function(){
+var _270=[];
+for(var x=0;x&lt;arguments.length;x++){
+_270.push(arguments[x]);
+}
+dojo.debug(&quot;(&quot;+_26f.srcObj+&quot;).&quot;+_26f.srcFunc,&quot;:&quot;,_270.join(&quot;, &quot;));
+};
+this.kwConnect(_26f);
+};
+this.connectBefore=function(){
+var args=[&quot;before&quot;];
+for(var i=0;i&lt;arguments.length;i++){
+args.push(arguments[i]);
+}
+return this.connect.apply(this,args);
+};
+this.connectAround=function(){
+var args=[&quot;around&quot;];
+for(var i=0;i&lt;arguments.length;i++){
+args.push(arguments[i]);
+}
+return this.connect.apply(this,args);
+};
+this.connectOnce=function(){
+var ao=interpolateArgs(arguments,true);
+ao.once=true;
+return this.connect(ao);
+};
+this._kwConnectImpl=function(_277,_278){
+var fn=(_278)?&quot;disconnect&quot;:&quot;connect&quot;;
+if(typeof _277[&quot;srcFunc&quot;]==&quot;function&quot;){
+_277.srcObj=_277[&quot;srcObj&quot;]||dj_global;
+var _27a=dojo.lang.nameAnonFunc(_277.srcFunc,_277.srcObj,true);
+_277.srcFunc=_27a;
+}
+if(typeof _277[&quot;adviceFunc&quot;]==&quot;function&quot;){
+_277.adviceObj=_277[&quot;adviceObj&quot;]||dj_global;
+var _27a=dojo.lang.nameAnonFunc(_277.adviceFunc,_277.adviceObj,true);
+_277.adviceFunc=_27a;
+}
+return dojo.event[fn]((_277[&quot;type&quot;]||_277[&quot;adviceType&quot;]||&quot;after&quot;),_277[&quot;srcObj&quot;]||dj_global,_277[&quot;srcFunc&quot;],_277[&quot;adviceObj&quot;]||_277[&quot;targetObj&quot;]||dj_global,_277[&quot;adviceFunc&quot;]||_277[&quot;targetFunc&quot;],_277[&quot;aroundObj&quot;],_277[&quot;aroundFunc&quot;],_277[&quot;once&quot;],_277[&quot;delay&quot;],_277[&quot;rate&quot;],_277[&quot;adviceMsg&quot;]||false);
+};
+this.kwConnect=function(_27b){
+return this._kwConnectImpl(_27b,false);
+};
+this.disconnect=function(){
+var ao=interpolateArgs(arguments,true);
+if(!ao.adviceFunc){
+return;
+}
+var mjp=dojo.event.MethodJoinPoint.getForMethod(ao.srcObj,ao.srcFunc);
+return mjp.removeAdvice(ao.adviceObj,ao.adviceFunc,ao.adviceType,ao.once);
+};
+this.kwDisconnect=function(_27e){
+return this._kwConnectImpl(_27e,true);
+};
+};
+dojo.event.MethodInvocation=function(_27f,obj,args){
+this.jp_=_27f;
+this.object=obj;
+this.args=[];
+for(var x=0;x&lt;args.length;x++){
+this.args[x]=args[x];
+}
+this.around_index=-1;
+};
+dojo.event.MethodInvocation.prototype.proceed=function(){
+this.around_index++;
+if(this.around_index&gt;=this.jp_.around.length){
+return this.jp_.object[this.jp_.methodname].apply(this.jp_.object,this.args);
+}else{
+var ti=this.jp_.around[this.around_index];
+var mobj=ti[0]||dj_global;
+var meth=ti[1];
+return mobj[meth].call(mobj,this);
+}
+};
+dojo.event.MethodJoinPoint=function(obj,_287){
+this.object=obj||dj_global;
+this.methodname=_287;
+this.methodfunc=this.object[_287];
+this.before=[];
+this.after=[];
+this.around=[];
+};
+dojo.event.MethodJoinPoint.getForMethod=function(obj,_289){
+if(!obj){
+obj=dj_global;
+}
+if(!obj[_289]){
+obj[_289]=function(){
+};
+if(!obj[_289]){
+dojo.raise(&quot;Cannot set do-nothing method on that object &quot;+_289);
+}
+}else{
+if((!dojo.lang.isFunction(obj[_289]))&amp;&amp;(!dojo.lang.isAlien(obj[_289]))){
+return null;
+}
+}
+var _28a=_289+&quot;$joinpoint&quot;;
+var _28b=_289+&quot;$joinpoint$method&quot;;
+var _28c=obj[_28a];
+if(!_28c){
+var _28d=false;
+if(dojo.event[&quot;browser&quot;]){
+if((obj[&quot;attachEvent&quot;])||(obj[&quot;nodeType&quot;])||(obj[&quot;addEventListener&quot;])){
+_28d=true;
+dojo.event.browser.addClobberNodeAttrs(obj,[_28a,_28b,_289]);
+}
+}
+var _28e=obj[_289].length;
+obj[_28b]=obj[_289];
+_28c=obj[_28a]=new dojo.event.MethodJoinPoint(obj,_28b);
+obj[_289]=function(){
+var args=[];
+if((_28d)&amp;&amp;(!arguments.length)){
+var evt=null;
+try{
+if(obj.ownerDocument){
+evt=obj.ownerDocument.parentWindow.event;
+}else{
+if(obj.documentElement){
+evt=obj.documentElement.ownerDocument.parentWindow.event;
+}else{
+evt=window.event;
+}
+}
+}
+catch(e){
+evt=window.event;
+}
+if(evt){
+args.push(dojo.event.browser.fixEvent(evt,this));
+}
+}else{
+for(var x=0;x&lt;arguments.length;x++){
+if((x==0)&amp;&amp;(_28d)&amp;&amp;(dojo.event.browser.isEvent(arguments[x]))){
+args.push(dojo.event.browser.fixEvent(arguments[x],this));
+}else{
+args.push(arguments[x]);
+}
+}
+}
+return _28c.run.apply(_28c,args);
+};
+obj[_289].__preJoinArity=_28e;
+}
+return _28c;
+};
+dojo.lang.extend(dojo.event.MethodJoinPoint,{unintercept:function(){
+this.object[this.methodname]=this.methodfunc;
+this.before=[];
+this.after=[];
+this.around=[];
+},disconnect:dojo.lang.forward(&quot;unintercept&quot;),run:function(){
+var obj=this.object||dj_global;
+var args=arguments;
+var _294=[];
+for(var x=0;x&lt;args.length;x++){
+_294[x]=args[x];
+}
+var _296=function(marr){
+if(!marr){
+dojo.debug(&quot;Null argument to unrollAdvice()&quot;);
+return;
+}
+var _298=marr[0]||dj_global;
+var _299=marr[1];
+if(!_298[_299]){
+dojo.raise(&quot;function \&quot;&quot;+_299+&quot;\&quot; does not exist on \&quot;&quot;+_298+&quot;\&quot;&quot;);
+}
+var _29a=marr[2]||dj_global;
+var _29b=marr[3];
+var msg=marr[6];
+var _29d;
+var to={args:[],jp_:this,object:obj,proceed:function(){
+return _298[_299].apply(_298,to.args);
+}};
+to.args=_294;
+var _29f=parseInt(marr[4]);
+var _2a0=((!isNaN(_29f))&amp;&amp;(marr[4]!==null)&amp;&amp;(typeof marr[4]!=&quot;undefined&quot;));
+if(marr[5]){
+var rate=parseInt(marr[5]);
+var cur=new Date();
+var _2a3=false;
+if((marr[&quot;last&quot;])&amp;&amp;((cur-marr.last)&lt;=rate)){
+if(dojo.event.canTimeout){
+if(marr[&quot;delayTimer&quot;]){
+clearTimeout(marr.delayTimer);
+}
+var tod=parseInt(rate*2);
+var mcpy=dojo.lang.shallowCopy(marr);
+marr.delayTimer=setTimeout(function(){
+mcpy[5]=0;
+_296(mcpy);
+},tod);
+}
+return;
+}else{
+marr.last=cur;
+}
+}
+if(_29b){
+_29a[_29b].call(_29a,to);
+}else{
+if((_2a0)&amp;&amp;((dojo.render.html)||(dojo.render.svg))){
+dj_global[&quot;setTimeout&quot;](function(){
+if(msg){
+_298[_299].call(_298,to);
+}else{
+_298[_299].apply(_298,args);
+}
+},_29f);
+}else{
+if(msg){
+_298[_299].call(_298,to);
+}else{
+_298[_299].apply(_298,args);
+}
+}
+}
+};
+if(this.before.length&gt;0){
+dojo.lang.forEach(this.before,_296);
+}
+var _2a6;
+if(this.around.length&gt;0){
+var mi=new dojo.event.MethodInvocation(this,obj,args);
+_2a6=mi.proceed();
+}else{
+if(this.methodfunc){
+_2a6=this.object[this.methodname].apply(this.object,args);
+}
+}
+if(this.after.length&gt;0){
+dojo.lang.forEach(this.after,_296);
+}
+return (this.methodfunc)?_2a6:null;
+},getArr:function(kind){
+var arr=this.after;
+if((typeof kind==&quot;string&quot;)&amp;&amp;(kind.indexOf(&quot;before&quot;)!=-1)){
+arr=this.before;
+}else{
+if(kind==&quot;around&quot;){
+arr=this.around;
+}
+}
+return arr;
+},kwAddAdvice:function(args){
+this.addAdvice(args[&quot;adviceObj&quot;],args[&quot;adviceFunc&quot;],args[&quot;aroundObj&quot;],args[&quot;aroundFunc&quot;],args[&quot;adviceType&quot;],args[&quot;precedence&quot;],args[&quot;once&quot;],args[&quot;delay&quot;],args[&quot;rate&quot;],args[&quot;adviceMsg&quot;]);
+},addAdvice:function(_2ab,_2ac,_2ad,_2ae,_2af,_2b0,once,_2b2,rate,_2b4){
+var arr=this.getArr(_2af);
+if(!arr){
+dojo.raise(&quot;bad this: &quot;+this);
+}
+var ao=[_2ab,_2ac,_2ad,_2ae,_2b2,rate,_2b4];
+if(once){
+if(this.hasAdvice(_2ab,_2ac,_2af,arr)&gt;=0){
+return;
+}
+}
+if(_2b0==&quot;first&quot;){
+arr.unshift(ao);
+}else{
+arr.push(ao);
+}
+},hasAdvice:function(_2b7,_2b8,_2b9,arr){
+if(!arr){
+arr=this.getArr(_2b9);
+}
+var ind=-1;
+for(var x=0;x&lt;arr.length;x++){
+var aao=(typeof _2b8==&quot;object&quot;)?(new String(_2b8)).toString():_2b8;
+var a1o=(typeof arr[x][1]==&quot;object&quot;)?(new String(arr[x][1])).toString():arr[x][1];
+if((arr[x][0]==_2b7)&amp;&amp;(a1o==aao)){
+ind=x;
+}
+}
+return ind;
+},removeAdvice:function(_2bf,_2c0,_2c1,once){
+var arr=this.getArr(_2c1);
+var ind=this.hasAdvice(_2bf,_2c0,_2c1,arr);
+if(ind==-1){
+return false;
+}
+while(ind!=-1){
+arr.splice(ind,1);
+if(once){
+break;
+}
+ind=this.hasAdvice(_2bf,_2c0,_2c1,arr);
+}
+return true;
+}});
+dojo.require(&quot;dojo.event&quot;);
+dojo.provide(&quot;dojo.event.topic&quot;);
+dojo.event.topic=new function(){
+this.topics={};
+this.getTopic=function(_2c5){
+if(!this.topics[_2c5]){
+this.topics[_2c5]=new this.TopicImpl(_2c5);
+}
+return this.topics[_2c5];
+};
+this.registerPublisher=function(_2c6,obj,_2c8){
+var _2c6=this.getTopic(_2c6);
+_2c6.registerPublisher(obj,_2c8);
+};
+this.subscribe=function(_2c9,obj,_2cb){
+var _2c9=this.getTopic(_2c9);
+_2c9.subscribe(obj,_2cb);
+};
+this.unsubscribe=function(_2cc,obj,_2ce){
+var _2cc=this.getTopic(_2cc);
+_2cc.unsubscribe(obj,_2ce);
+};
+this.destroy=function(_2cf){
+this.getTopic(_2cf).destroy();
+delete this.topics[_2cf];
+};
+this.publishApply=function(_2d0,args){
+var _2d0=this.getTopic(_2d0);
+_2d0.sendMessage.apply(_2d0,args);
+};
+this.publish=function(_2d2,_2d3){
+var _2d2=this.getTopic(_2d2);
+var args=[];
+for(var x=1;x&lt;arguments.length;x++){
+args.push(arguments[x]);
+}
+_2d2.sendMessage.apply(_2d2,args);
+};
+};
+dojo.event.topic.TopicImpl=function(_2d6){
+this.topicName=_2d6;
+this.subscribe=function(_2d7,_2d8){
+var tf=_2d8||_2d7;
+var to=(!_2d8)?dj_global:_2d7;
+dojo.event.kwConnect({srcObj:this,srcFunc:&quot;sendMessage&quot;,adviceObj:to,adviceFunc:tf});
+};
+this.unsubscribe=function(_2db,_2dc){
+var tf=(!_2dc)?_2db:_2dc;
+var to=(!_2dc)?null:_2db;
+dojo.event.kwDisconnect({srcObj:this,srcFunc:&quot;sendMessage&quot;,adviceObj:to,adviceFunc:tf});
+};
+this.destroy=function(){
+dojo.event.MethodJoinPoint.getForMethod(this,&quot;sendMessage&quot;).disconnect();
+};
+this.registerPublisher=function(_2df,_2e0){
+dojo.event.connect(_2df,_2e0,this,&quot;sendMessage&quot;);
+};
+this.sendMessage=function(_2e1){
+};
+};
+dojo.provide(&quot;dojo.event.browser&quot;);
+dojo.require(&quot;dojo.event&quot;);
+dojo._ie_clobber=new function(){
+this.clobberNodes=[];
+function nukeProp(node,prop){
+try{
+node[prop]=null;
+}
+catch(e){
+}
+try{
+delete node[prop];
+}
+catch(e){
+}
+try{
+node.removeAttribute(prop);
+}
+catch(e){
+}
+}
+this.clobber=function(_2e4){
+var na;
+var tna;
+if(_2e4){
+tna=_2e4.all||_2e4.getElementsByTagName(&quot;*&quot;);
+na=[_2e4];
+for(var x=0;x&lt;tna.length;x++){
+if(tna[x][&quot;__doClobber__&quot;]){
+na.push(tna[x]);
+}
+}
+}else{
+try{
+window.onload=null;
+}
+catch(e){
+}
+na=(this.clobberNodes.length)?this.clobberNodes:document.all;
+}
+tna=null;
+var _2e8={};
+for(var i=na.length-1;i&gt;=0;i=i-1){
+var el=na[i];
+if(el[&quot;__clobberAttrs__&quot;]){
+for(var j=0;j&lt;el.__clobberAttrs__.length;j++){
+nukeProp(el,el.__clobberAttrs__[j]);
+}
+nukeProp(el,&quot;__clobberAttrs__&quot;);
+nukeProp(el,&quot;__doClobber__&quot;);
+}
+}
+na=null;
+};
+};
+if(dojo.render.html.ie){
+dojo.addOnUnload(function(){
+dojo._ie_clobber.clobber();
+try{
+if((dojo[&quot;widget&quot;])&amp;&amp;(dojo.widget[&quot;manager&quot;])){
+dojo.widget.manager.destroyAll();
+}
+}
+catch(e){
+}
+try{
+window.onload=null;
+}
+catch(e){
+}
+try{
+window.onunload=null;
+}
+catch(e){
+}
+dojo._ie_clobber.clobberNodes=[];
+});
+}
+dojo.event.browser=new function(){
+var _2ec=0;
+this.clean=function(node){
+if(dojo.render.html.ie){
+dojo._ie_clobber.clobber(node);
+}
+};
+this.addClobberNode=function(node){
+if(!dojo.render.html.ie){
+return;
+}
+if(!node[&quot;__doClobber__&quot;]){
+node.__doClobber__=true;
+dojo._ie_clobber.clobberNodes.push(node);
+node.__clobberAttrs__=[];
+}
+};
+this.addClobberNodeAttrs=function(node,_2f0){
+if(!dojo.render.html.ie){
+return;
+}
+this.addClobberNode(node);
+for(var x=0;x&lt;_2f0.length;x++){
+node.__clobberAttrs__.push(_2f0[x]);
+}
+};
+this.removeListener=function(node,_2f3,fp,_2f5){
+if(!_2f5){
+var _2f5=false;
+}
+_2f3=_2f3.toLowerCase();
+if(_2f3.substr(0,2)==&quot;on&quot;){
+_2f3=_2f3.substr(2);
+}
+if(node.removeEventListener){
+node.removeEventListener(_2f3,fp,_2f5);
+}
+};
+this.addListener=function(node,_2f7,fp,_2f9,_2fa){
+if(!node){
+return;
+}
+if(!_2f9){
+var _2f9=false;
+}
+_2f7=_2f7.toLowerCase();
+if(_2f7.substr(0,2)!=&quot;on&quot;){
+_2f7=&quot;on&quot;+_2f7;
+}
+if(!_2fa){
+var _2fb=function(evt){
+if(!evt){
+evt=window.event;
+}
+var ret=fp(dojo.event.browser.fixEvent(evt,this));
+if(_2f9){
+dojo.event.browser.stopEvent(evt);
+}
+return ret;
+};
+}else{
+_2fb=fp;
+}
+if(node.addEventListener){
+node.addEventListener(_2f7.substr(2),_2fb,_2f9);
+return _2fb;
+}else{
+if(typeof node[_2f7]==&quot;function&quot;){
+var _2fe=node[_2f7];
+node[_2f7]=function(e){
+_2fe(e);
+return _2fb(e);
+};
+}else{
+node[_2f7]=_2fb;
+}
+if(dojo.render.html.ie){
+this.addClobberNodeAttrs(node,[_2f7]);
+}
+return _2fb;
+}
+};
+this.isEvent=function(obj){
+return (typeof obj!=&quot;undefined&quot;)&amp;&amp;(typeof Event!=&quot;undefined&quot;)&amp;&amp;(obj.eventPhase);
+};
+this.currentEvent=null;
+this.callListener=function(_301,_302){
+if(typeof _301!=&quot;function&quot;){
+dojo.raise(&quot;listener not a function: &quot;+_301);
+}
+dojo.event.browser.currentEvent.currentTarget=_302;
+return _301.call(_302,dojo.event.browser.currentEvent);
+};
+this.stopPropagation=function(){
+dojo.event.browser.currentEvent.cancelBubble=true;
+};
+this.preventDefault=function(){
+dojo.event.browser.currentEvent.returnValue=false;
+};
+this.keys={KEY_BACKSPACE:8,KEY_TAB:9,KEY_ENTER:13,KEY_SHIFT:16,KEY_CTRL:17,KEY_ALT:18,KEY_PAUSE:19,KEY_CAPS_LOCK:20,KEY_ESCAPE:27,KEY_SPACE:32,KEY_PAGE_UP:33,KEY_PAGE_DOWN:34,KEY_END:35,KEY_HOME:36,KEY_LEFT_ARROW:37,KEY_UP_ARROW:38,KEY_RIGHT_ARROW:39,KEY_DOWN_ARROW:40,KEY_INSERT:45,KEY_DELETE:46,KEY_LEFT_WINDOW:91,KEY_RIGHT_WINDOW:92,KEY_SELECT:93,KEY_F1:112,KEY_F2:113,KEY_F3:114,KEY_F4:115,KEY_F5:116,KEY_F6:117,KEY_F7:118,KEY_F8:119,KEY_F9:120,KEY_F10:121,KEY_F11:122,KEY_F12:123,KEY_NUM_LOCK:144,KEY_SCROLL_LOCK:145};
+this.revKeys=[];
+for(var key in this.keys){
+this.revKeys[this.keys[key]]=key;
+}
+this.fixEvent=function(evt,_305){
+if((!evt)&amp;&amp;(window[&quot;event&quot;])){
+var evt=window.event;
+}
+if((evt[&quot;type&quot;])&amp;&amp;(evt[&quot;type&quot;].indexOf(&quot;key&quot;)==0)){
+evt.keys=this.revKeys;
+for(var key in this.keys){
+evt[key]=this.keys[key];
+}
+if((dojo.render.html.ie)&amp;&amp;(evt[&quot;type&quot;]==&quot;keypress&quot;)){
+evt.charCode=evt.keyCode;
+}
+}
+if(dojo.render.html.ie){
+if(!evt.target){
+evt.target=evt.srcElement;
+}
+if(!evt.currentTarget){
+evt.currentTarget=(_305?_305:evt.srcElement);
+}
+if(!evt.layerX){
+evt.layerX=evt.offsetX;
+}
+if(!evt.layerY){
+evt.layerY=evt.offsetY;
+}
+var _307=((dojo.render.html.ie55)||(document[&quot;compatMode&quot;]==&quot;BackCompat&quot;))?document.body:document.documentElement;
+if(!evt.pageX){
+evt.pageX=evt.clientX+(_307.scrollLeft||0);
+}
+if(!evt.pageY){
+evt.pageY=evt.clientY+(_307.scrollTop||0);
+}
+if(evt.type==&quot;mouseover&quot;){
+evt.relatedTarget=evt.fromElement;
+}
+if(evt.type==&quot;mouseout&quot;){
+evt.relatedTarget=evt.toElement;
+}
+this.currentEvent=evt;
+evt.callListener=this.callListener;
+evt.stopPropagation=this.stopPropagation;
+evt.preventDefault=this.preventDefault;
+}
+return evt;
+};
+this.stopEvent=function(ev){
+if(window.event){
+ev.returnValue=false;
+ev.cancelBubble=true;
+}else{
+ev.preventDefault();
+ev.stopPropagation();
+}
+};
+};
+dojo.kwCompoundRequire({common:[&quot;dojo.event&quot;,&quot;dojo.event.topic&quot;],browser:[&quot;dojo.event.browser&quot;],dashboard:[&quot;dojo.event.browser&quot;]});
+dojo.provide(&quot;dojo.event.*&quot;);
+dojo.provide(&quot;dojo.lfx.Animation&quot;);
+dojo.provide(&quot;dojo.lfx.Line&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.lfx.Line=function(_309,end){
+this.start=_309;
+this.end=end;
+if(dojo.lang.isArray(_309)){
+var diff=[];
+dojo.lang.forEach(this.start,function(s,i){
+diff[i]=this.end[i]-s;
+},this);
+this.getValue=function(n){
+var res=[];
+dojo.lang.forEach(this.start,function(s,i){
+res[i]=(diff[i]*n)+s;
+},this);
+return res;
+};
+}else{
+var diff=end-_309;
+this.getValue=function(n){
+return (diff*n)+this.start;
+};
+}
+};
+dojo.lfx.easeIn=function(n){
+return Math.pow(n,3);
+};
+dojo.lfx.easeOut=function(n){
+return (1-Math.pow(1-n,3));
+};
+dojo.lfx.easeInOut=function(n){
+return ((3*Math.pow(n,2))-(2*Math.pow(n,3)));
+};
+dojo.lfx.IAnimation=function(){
+};
+dojo.lang.extend(dojo.lfx.IAnimation,{curve:null,duration:1000,easing:null,repeatCount:0,rate:25,handler:null,beforeBegin:null,onBegin:null,onAnimate:null,onEnd:null,onPlay:null,onPause:null,onStop:null,play:null,pause:null,stop:null,fire:function(evt,args){
+if(this[evt]){
+this[evt].apply(this,(args||[]));
+}
+},_active:false,_paused:false});
+dojo.lfx.Animation=function(_318,_319,_31a,_31b,_31c,rate){
+dojo.lfx.IAnimation.call(this);
+if(dojo.lang.isNumber(_318)||(!_318&amp;&amp;_319.getValue)){
+rate=_31c;
+_31c=_31b;
+_31b=_31a;
+_31a=_319;
+_319=_318;
+_318=null;
+}else{
+if(_318.getValue||dojo.lang.isArray(_318)){
+rate=_31b;
+_31c=_31a;
+_31b=_319;
+_31a=_318;
+_319=null;
+_318=null;
+}
+}
+if(dojo.lang.isArray(_31a)){
+this.curve=new dojo.lfx.Line(_31a[0],_31a[1]);
+}else{
+this.curve=_31a;
+}
+if(_319!=null&amp;&amp;_319&gt;0){
+this.duration=_319;
+}
+if(_31c){
+this.repeatCount=_31c;
+}
+if(rate){
+this.rate=rate;
+}
+if(_318){
+this.handler=_318.handler;
+this.beforeBegin=_318.beforeBegin;
+this.onBegin=_318.onBegin;
+this.onEnd=_318.onEnd;
+this.onPlay=_318.onPlay;
+this.onPause=_318.onPause;
+this.onStop=_318.onStop;
+this.onAnimate=_318.onAnimate;
+}
+if(_31b&amp;&amp;dojo.lang.isFunction(_31b)){
+this.easing=_31b;
+}
+};
+dojo.inherits(dojo.lfx.Animation,dojo.lfx.IAnimation);
+dojo.lang.extend(dojo.lfx.Animation,{_startTime:null,_endTime:null,_timer:null,_percent:0,_startRepeatCount:0,play:function(_31e,_31f){
+if(_31f){
+clearTimeout(this._timer);
+this._active=false;
+this._paused=false;
+this._percent=0;
+}else{
+if(this._active&amp;&amp;!this._paused){
+return this;
+}
+}
+this.fire(&quot;handler&quot;,[&quot;beforeBegin&quot;]);
+this.fire(&quot;beforeBegin&quot;);
+if(_31e&gt;0){
+setTimeout(dojo.lang.hitch(this,function(){
+this.play(null,_31f);
+}),_31e);
+return this;
+}
+this._startTime=new Date().valueOf();
+if(this._paused){
+this._startTime-=(this.duration*this._percent/100);
+}
+this._endTime=this._startTime+this.duration;
+this._active=true;
+this._paused=false;
+var step=this._percent/100;
+var _321=this.curve.getValue(step);
+if(this._percent==0){
+if(!this._startRepeatCount){
+this._startRepeatCount=this.repeatCount;
+}
+this.fire(&quot;handler&quot;,[&quot;begin&quot;,_321]);
+this.fire(&quot;onBegin&quot;,[_321]);
+}
+this.fire(&quot;handler&quot;,[&quot;play&quot;,_321]);
+this.fire(&quot;onPlay&quot;,[_321]);
+this._cycle();
+return this;
+},pause:function(){
+clearTimeout(this._timer);
+if(!this._active){
+return this;
+}
+this._paused=true;
+var _322=this.curve.getValue(this._percent/100);
+this.fire(&quot;handler&quot;,[&quot;pause&quot;,_322]);
+this.fire(&quot;onPause&quot;,[_322]);
+return this;
+},gotoPercent:function(pct,_324){
+clearTimeout(this._timer);
+this._active=true;
+this._paused=true;
+this._percent=pct;
+if(_324){
+this.play();
+}
+},stop:function(_325){
+clearTimeout(this._timer);
+var step=this._percent/100;
+if(_325){
+step=1;
+}
+var _327=this.curve.getValue(step);
+this.fire(&quot;handler&quot;,[&quot;stop&quot;,_327]);
+this.fire(&quot;onStop&quot;,[_327]);
+this._active=false;
+this._paused=false;
+return this;
+},status:function(){
+if(this._active){
+return this._paused?&quot;paused&quot;:&quot;playing&quot;;
+}else{
+return &quot;stopped&quot;;
+}
+},_cycle:function(){
+clearTimeout(this._timer);
+if(this._active){
+var curr=new Date().valueOf();
+var step=(curr-this._startTime)/(this._endTime-this._startTime);
+if(step&gt;=1){
+step=1;
+this._percent=100;
+}else{
+this._percent=step*100;
+}
+if((this.easing)&amp;&amp;(dojo.lang.isFunction(this.easing))){
+step=this.easing(step);
+}
+var _32a=this.curve.getValue(step);
+this.fire(&quot;handler&quot;,[&quot;animate&quot;,_32a]);
+this.fire(&quot;onAnimate&quot;,[_32a]);
+if(step&lt;1){
+this._timer=setTimeout(dojo.lang.hitch(this,&quot;_cycle&quot;),this.rate);
+}else{
+this._active=false;
+this.fire(&quot;handler&quot;,[&quot;end&quot;]);
+this.fire(&quot;onEnd&quot;);
+if(this.repeatCount&gt;0){
+this.repeatCount--;
+this.play(null,true);
+}else{
+if(this.repeatCount==-1){
+this.play(null,true);
+}else{
+if(this._startRepeatCount){
+this.repeatCount=this._startRepeatCount;
+this._startRepeatCount=0;
+}
+}
+}
+}
+}
+return this;
+}});
+dojo.lfx.Combine=function(){
+dojo.lfx.IAnimation.call(this);
+this._anims=[];
+this._animsEnded=0;
+var _32b=arguments;
+if(_32b.length==1&amp;&amp;(dojo.lang.isArray(_32b[0])||dojo.lang.isArrayLike(_32b[0]))){
+_32b=_32b[0];
+}
+var _32c=this;
+dojo.lang.forEach(_32b,function(anim){
+_32c._anims.push(anim);
+var _32e=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_32e();
+_32c._onAnimsEnded();
+};
+});
+};
+dojo.inherits(dojo.lfx.Combine,dojo.lfx.IAnimation);
+dojo.lang.extend(dojo.lfx.Combine,{_animsEnded:0,play:function(_32f,_330){
+if(!this._anims.length){
+return this;
+}
+this.fire(&quot;beforeBegin&quot;);
+if(_32f&gt;0){
+setTimeout(dojo.lang.hitch(this,function(){
+this.play(null,_330);
+}),_32f);
+return this;
+}
+if(_330||this._anims[0].percent==0){
+this.fire(&quot;onBegin&quot;);
+}
+this.fire(&quot;onPlay&quot;);
+this._animsCall(&quot;play&quot;,null,_330);
+return this;
+},pause:function(){
+this.fire(&quot;onPause&quot;);
+this._animsCall(&quot;pause&quot;);
+return this;
+},stop:function(_331){
+this.fire(&quot;onStop&quot;);
+this._animsCall(&quot;stop&quot;,_331);
+return this;
+},_onAnimsEnded:function(){
+this._animsEnded++;
+if(this._animsEnded&gt;=this._anims.length){
+this.fire(&quot;onEnd&quot;);
+}
+return this;
+},_animsCall:function(_332){
+var args=[];
+if(arguments.length&gt;1){
+for(var i=1;i&lt;arguments.length;i++){
+args.push(arguments[i]);
+}
+}
+var _335=this;
+dojo.lang.forEach(this._anims,function(anim){
+anim[_332](args);
+},_335);
+return this;
+}});
+dojo.lfx.Chain=function(){
+dojo.lfx.IAnimation.call(this);
+this._anims=[];
+this._currAnim=-1;
+var _337=arguments;
+if(_337.length==1&amp;&amp;(dojo.lang.isArray(_337[0])||dojo.lang.isArrayLike(_337[0]))){
+_337=_337[0];
+}
+var _338=this;
+dojo.lang.forEach(_337,function(anim,i,_33b){
+_338._anims.push(anim);
+var _33c=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+if(i&lt;_33b.length-1){
+anim.onEnd=function(){
+_33c();
+_338._playNext();
+};
+}else{
+anim.onEnd=function(){
+_33c();
+_338.fire(&quot;onEnd&quot;);
+};
+}
+},_338);
+};
+dojo.inherits(dojo.lfx.Chain,dojo.lfx.IAnimation);
+dojo.lang.extend(dojo.lfx.Chain,{_currAnim:-1,play:function(_33d,_33e){
+if(!this._anims.length){
+return this;
+}
+if(_33e||!this._anims[this._currAnim]){
+this._currAnim=0;
+}
+var _33f=this._anims[this._currAnim];
+this.fire(&quot;beforeBegin&quot;);
+if(_33d&gt;0){
+setTimeout(dojo.lang.hitch(this,function(){
+this.play(null,_33e);
+}),_33d);
+return this;
+}
+if(_33f){
+if(this._currAnim==0){
+this.fire(&quot;handler&quot;,[&quot;begin&quot;,this._currAnim]);
+this.fire(&quot;onBegin&quot;,[this._currAnim]);
+}
+this.fire(&quot;onPlay&quot;,[this._currAnim]);
+_33f.play(null,_33e);
+}
+return this;
+},pause:function(){
+if(this._anims[this._currAnim]){
+this._anims[this._currAnim].pause();
+this.fire(&quot;onPause&quot;,[this._currAnim]);
+}
+return this;
+},playPause:function(){
+if(this._anims.length==0){
+return this;
+}
+if(this._currAnim==-1){
+this._currAnim=0;
+}
+var _340=this._anims[this._currAnim];
+if(_340){
+if(!_340._active||_340._paused){
+this.play();
+}else{
+this.pause();
+}
+}
+return this;
+},stop:function(){
+var _341=this._anims[this._currAnim];
+if(_341){
+_341.stop();
+this.fire(&quot;onStop&quot;,[this._currAnim]);
+}
+return _341;
+},_playNext:function(){
+if(this._currAnim==-1||this._anims.length==0){
+return this;
+}
+this._currAnim++;
+if(this._anims[this._currAnim]){
+this._anims[this._currAnim].play(null,true);
+}
+return this;
+}});
+dojo.lfx.combine=function(){
+var _342=arguments;
+if(dojo.lang.isArray(arguments[0])){
+_342=arguments[0];
+}
+return new dojo.lfx.Combine(_342);
+};
+dojo.lfx.chain=function(){
+var _343=arguments;
+if(dojo.lang.isArray(arguments[0])){
+_343=arguments[0];
+}
+return new dojo.lfx.Chain(_343);
+};
+dojo.provide(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.graphics.color.Color=function(r,g,b,a){
+if(dojo.lang.isArray(r)){
+this.r=r[0];
+this.g=r[1];
+this.b=r[2];
+this.a=r[3]||1;
+}else{
+if(dojo.lang.isString(r)){
+var rgb=dojo.graphics.color.extractRGB(r);
+this.r=rgb[0];
+this.g=rgb[1];
+this.b=rgb[2];
+this.a=g||1;
+}else{
+if(r instanceof dojo.graphics.color.Color){
+this.r=r.r;
+this.b=r.b;
+this.g=r.g;
+this.a=r.a;
+}else{
+this.r=r;
+this.g=g;
+this.b=b;
+this.a=a;
+}
+}
+}
+};
+dojo.graphics.color.Color.fromArray=function(arr){
+return new dojo.graphics.color.Color(arr[0],arr[1],arr[2],arr[3]);
+};
+dojo.lang.extend(dojo.graphics.color.Color,{toRgb:function(_34a){
+if(_34a){
+return this.toRgba();
+}else{
+return [this.r,this.g,this.b];
+}
+},toRgba:function(){
+return [this.r,this.g,this.b,this.a];
+},toHex:function(){
+return dojo.graphics.color.rgb2hex(this.toRgb());
+},toCss:function(){
+return &quot;rgb(&quot;+this.toRgb().join()+&quot;)&quot;;
+},toString:function(){
+return this.toHex();
+},blend:function(_34b,_34c){
+return dojo.graphics.color.blend(this.toRgb(),new dojo.graphics.color.Color(_34b).toRgb(),_34c);
+}});
+dojo.graphics.color.named={white:[255,255,255],black:[0,0,0],red:[255,0,0],green:[0,255,0],blue:[0,0,255],navy:[0,0,128],gray:[128,128,128],silver:[192,192,192]};
+dojo.graphics.color.blend=function(a,b,_34f){
+if(typeof a==&quot;string&quot;){
+return dojo.graphics.color.blendHex(a,b,_34f);
+}
+if(!_34f){
+_34f=0;
+}else{
+if(_34f&gt;1){
+_34f=1;
+}else{
+if(_34f&lt;-1){
+_34f=-1;
+}
+}
+}
+var c=new Array(3);
+for(var i=0;i&lt;3;i++){
+var half=Math.abs(a[i]-b[i])/2;
+c[i]=Math.floor(Math.min(a[i],b[i])+half+(half*_34f));
+}
+return c;
+};
+dojo.graphics.color.blendHex=function(a,b,_355){
+return dojo.graphics.color.rgb2hex(dojo.graphics.color.blend(dojo.graphics.color.hex2rgb(a),dojo.graphics.color.hex2rgb(b),_355));
+};
+dojo.graphics.color.extractRGB=function(_356){
+var hex=&quot;0123456789abcdef&quot;;
+_356=_356.toLowerCase();
+if(_356.indexOf(&quot;rgb&quot;)==0){
+var _358=_356.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
+var ret=_358.splice(1,3);
+return ret;
+}else{
+var _35a=dojo.graphics.color.hex2rgb(_356);
+if(_35a){
+return _35a;
+}else{
+return dojo.graphics.color.named[_356]||[255,255,255];
+}
+}
+};
+dojo.graphics.color.hex2rgb=function(hex){
+var _35c=&quot;0123456789ABCDEF&quot;;
+var rgb=new Array(3);
+if(hex.indexOf(&quot;#&quot;)==0){
+hex=hex.substring(1);
+}
+hex=hex.toUpperCase();
+if(hex.replace(new RegExp(&quot;[&quot;+_35c+&quot;]&quot;,&quot;g&quot;),&quot;&quot;)!=&quot;&quot;){
+return null;
+}
+if(hex.length==3){
+rgb[0]=hex.charAt(0)+hex.charAt(0);
+rgb[1]=hex.charAt(1)+hex.charAt(1);
+rgb[2]=hex.charAt(2)+hex.charAt(2);
+}else{
+rgb[0]=hex.substring(0,2);
+rgb[1]=hex.substring(2,4);
+rgb[2]=hex.substring(4);
+}
+for(var i=0;i&lt;rgb.length;i++){
+rgb[i]=_35c.indexOf(rgb[i].charAt(0))*16+_35c.indexOf(rgb[i].charAt(1));
+}
+return rgb;
+};
+dojo.graphics.color.rgb2hex=function(r,g,b){
+if(dojo.lang.isArray(r)){
+g=r[1]||0;
+b=r[2]||0;
+r=r[0]||0;
+}
+var ret=dojo.lang.map([r,g,b],function(x){
+x=new Number(x);
+var s=x.toString(16);
+while(s.length&lt;2){
+s=&quot;0&quot;+s;
+}
+return s;
+});
+ret.unshift(&quot;#&quot;);
+return ret.join(&quot;&quot;);
+};
+dojo.provide(&quot;dojo.uri.Uri&quot;);
+dojo.uri=new function(){
+this.joinPath=function(){
+var arr=[];
+for(var i=0;i&lt;arguments.length;i++){
+arr.push(arguments[i]);
+}
+return arr.join(&quot;/&quot;).replace(/\/{2,}/g,&quot;/&quot;).replace(/((https*|ftps*):)/i,&quot;$1/&quot;);
+};
+this.dojoUri=function(uri){
+return new dojo.uri.Uri(dojo.hostenv.getBaseScriptUri(),uri);
+};
+this.Uri=function(){
+var uri=arguments[0];
+for(var i=1;i&lt;arguments.length;i++){
+if(!arguments[i]){
+continue;
+}
+var _36a=new dojo.uri.Uri(arguments[i].toString());
+var _36b=new dojo.uri.Uri(uri.toString());
+if(_36a.path==&quot;&quot;&amp;&amp;_36a.scheme==null&amp;&amp;_36a.authority==null&amp;&amp;_36a.query==null){
+if(_36a.fragment!=null){
+_36b.fragment=_36a.fragment;
+}
+_36a=_36b;
+}else{
+if(_36a.scheme==null){
+_36a.scheme=_36b.scheme;
+if(_36a.authority==null){
+_36a.authority=_36b.authority;
+if(_36a.path.charAt(0)!=&quot;/&quot;){
+var path=_36b.path.substring(0,_36b.path.lastIndexOf(&quot;/&quot;)+1)+_36a.path;
+var segs=path.split(&quot;/&quot;);
+for(var j=0;j&lt;segs.length;j++){
+if(segs[j]==&quot;.&quot;){
+if(j==segs.length-1){
+segs[j]=&quot;&quot;;
+}else{
+segs.splice(j,1);
+j--;
+}
+}else{
+if(j&gt;0&amp;&amp;!(j==1&amp;&amp;segs[0]==&quot;&quot;)&amp;&amp;segs[j]==&quot;..&quot;&amp;&amp;segs[j-1]!=&quot;..&quot;){
+if(j==segs.length-1){
+segs.splice(j,1);
+segs[j-1]=&quot;&quot;;
+}else{
+segs.splice(j-1,2);
+j-=2;
+}
+}
+}
+}
+_36a.path=segs.join(&quot;/&quot;);
+}
+}
+}
+}
+uri=&quot;&quot;;
+if(_36a.scheme!=null){
+uri+=_36a.scheme+&quot;:&quot;;
+}
+if(_36a.authority!=null){
+uri+=&quot;//&quot;+_36a.authority;
+}
+uri+=_36a.path;
+if(_36a.query!=null){
+uri+=&quot;?&quot;+_36a.query;
+}
+if(_36a.fragment!=null){
+uri+=&quot;#&quot;+_36a.fragment;
+}
+}
+this.uri=uri.toString();
+var _36f=&quot;^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$&quot;;
+var r=this.uri.match(new RegExp(_36f));
+this.scheme=r[2]||(r[1]?&quot;&quot;:null);
+this.authority=r[4]||(r[3]?&quot;&quot;:null);
+this.path=r[5];
+this.query=r[7]||(r[6]?&quot;&quot;:null);
+this.fragment=r[9]||(r[8]?&quot;&quot;:null);
+if(this.authority!=null){
+_36f=&quot;^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$&quot;;
+r=this.authority.match(new RegExp(_36f));
+this.user=r[3]||null;
+this.password=r[4]||null;
+this.host=r[5];
+this.port=r[7]||null;
+}
+this.toString=function(){
+return this.uri;
+};
+};
+};
+dojo.provide(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.uri.Uri&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+(function(){
+var h=dojo.render.html;
+var ds=dojo.style;
+var db=document[&quot;body&quot;]||document[&quot;documentElement&quot;];
+ds.boxSizing={MARGIN_BOX:&quot;margin-box&quot;,BORDER_BOX:&quot;border-box&quot;,PADDING_BOX:&quot;padding-box&quot;,CONTENT_BOX:&quot;content-box&quot;};
+var bs=ds.boxSizing;
+ds.getBoxSizing=function(node){
+if((h.ie)||(h.opera)){
+var cm=document[&quot;compatMode&quot;];
+if((cm==&quot;BackCompat&quot;)||(cm==&quot;QuirksMode&quot;)){
+return bs.BORDER_BOX;
+}else{
+return bs.CONTENT_BOX;
+}
+}else{
+if(arguments.length==0){
+node=document.documentElement;
+}
+var _377=ds.getStyle(node,&quot;-moz-box-sizing&quot;);
+if(!_377){
+_377=ds.getStyle(node,&quot;box-sizing&quot;);
+}
+return (_377?_377:bs.CONTENT_BOX);
+}
+};
+ds.isBorderBox=function(node){
+return (ds.getBoxSizing(node)==bs.BORDER_BOX);
+};
+ds.getUnitValue=function(node,_37a,_37b){
+var s=ds.getComputedStyle(node,_37a);
+if((!s)||((s==&quot;auto&quot;)&amp;&amp;(_37b))){
+return {value:0,units:&quot;px&quot;};
+}
+if(dojo.lang.isUndefined(s)){
+return ds.getUnitValue.bad;
+}
+var _37d=s.match(/(\-?[\d.]+)([a-z%]*)/i);
+if(!_37d){
+return ds.getUnitValue.bad;
+}
+return {value:Number(_37d[1]),units:_37d[2].toLowerCase()};
+};
+ds.getUnitValue.bad={value:NaN,units:&quot;&quot;};
+ds.getPixelValue=function(node,_37f,_380){
+var _381=ds.getUnitValue(node,_37f,_380);
+if(isNaN(_381.value)){
+return 0;
+}
+if((_381.value)&amp;&amp;(_381.units!=&quot;px&quot;)){
+return NaN;
+}
+return _381.value;
+};
+ds.getNumericStyle=function(){
+dojo.deprecated(&quot;dojo.(style|html).getNumericStyle&quot;,&quot;in favor of dojo.(style|html).getPixelValue&quot;,&quot;0.4&quot;);
+return ds.getPixelValue.apply(this,arguments);
+};
+ds.setPositivePixelValue=function(node,_383,_384){
+if(isNaN(_384)){
+return false;
+}
+node.style[_383]=Math.max(0,_384)+&quot;px&quot;;
+return true;
+};
+ds._sumPixelValues=function(node,_386,_387){
+var _388=0;
+for(var x=0;x&lt;_386.length;x++){
+_388+=ds.getPixelValue(node,_386[x],_387);
+}
+return _388;
+};
+ds.isPositionAbsolute=function(node){
+return (ds.getComputedStyle(node,&quot;position&quot;)==&quot;absolute&quot;);
+};
+ds.getBorderExtent=function(node,side){
+return (ds.getStyle(node,&quot;border-&quot;+side+&quot;-style&quot;)==&quot;none&quot;?0:ds.getPixelValue(node,&quot;border-&quot;+side+&quot;-width&quot;));
+};
+ds.getMarginWidth=function(node){
+return ds._sumPixelValues(node,[&quot;margin-left&quot;,&quot;margin-right&quot;],ds.isPositionAbsolute(node));
+};
+ds.getBorderWidth=function(node){
+return ds.getBorderExtent(node,&quot;left&quot;)+ds.getBorderExtent(node,&quot;right&quot;);
+};
+ds.getPaddingWidth=function(node){
+return ds._sumPixelValues(node,[&quot;padding-left&quot;,&quot;padding-right&quot;],true);
+};
+ds.getPadBorderWidth=function(node){
+return ds.getPaddingWidth(node)+ds.getBorderWidth(node);
+};
+ds.getContentBoxWidth=function(node){
+node=dojo.byId(node);
+return node.offsetWidth-ds.getPadBorderWidth(node);
+};
+ds.getBorderBoxWidth=function(node){
+node=dojo.byId(node);
+return node.offsetWidth;
+};
+ds.getMarginBoxWidth=function(node){
+return ds.getInnerWidth(node)+ds.getMarginWidth(node);
+};
+ds.setContentBoxWidth=function(node,_395){
+node=dojo.byId(node);
+if(ds.isBorderBox(node)){
+_395+=ds.getPadBorderWidth(node);
+}
+return ds.setPositivePixelValue(node,&quot;width&quot;,_395);
+};
+ds.setMarginBoxWidth=function(node,_397){
+node=dojo.byId(node);
+if(!ds.isBorderBox(node)){
+_397-=ds.getPadBorderWidth(node);
+}
+_397-=ds.getMarginWidth(node);
+return ds.setPositivePixelValue(node,&quot;width&quot;,_397);
+};
+ds.getContentWidth=ds.getContentBoxWidth;
+ds.getInnerWidth=ds.getBorderBoxWidth;
+ds.getOuterWidth=ds.getMarginBoxWidth;
+ds.setContentWidth=ds.setContentBoxWidth;
+ds.setOuterWidth=ds.setMarginBoxWidth;
+ds.getMarginHeight=function(node){
+return ds._sumPixelValues(node,[&quot;margin-top&quot;,&quot;margin-bottom&quot;],ds.isPositionAbsolute(node));
+};
+ds.getBorderHeight=function(node){
+return ds.getBorderExtent(node,&quot;top&quot;)+ds.getBorderExtent(node,&quot;bottom&quot;);
+};
+ds.getPaddingHeight=function(node){
+return ds._sumPixelValues(node,[&quot;padding-top&quot;,&quot;padding-bottom&quot;],true);
+};
+ds.getPadBorderHeight=function(node){
+return ds.getPaddingHeight(node)+ds.getBorderHeight(node);
+};
+ds.getContentBoxHeight=function(node){
+node=dojo.byId(node);
+return node.offsetHeight-ds.getPadBorderHeight(node);
+};
+ds.getBorderBoxHeight=function(node){
+node=dojo.byId(node);
+return node.offsetHeight;
+};
+ds.getMarginBoxHeight=function(node){
+return ds.getInnerHeight(node)+ds.getMarginHeight(node);
+};
+ds.setContentBoxHeight=function(node,_3a0){
+node=dojo.byId(node);
+if(ds.isBorderBox(node)){
+_3a0+=ds.getPadBorderHeight(node);
+}
+return ds.setPositivePixelValue(node,&quot;height&quot;,_3a0);
+};
+ds.setMarginBoxHeight=function(node,_3a2){
+node=dojo.byId(node);
+if(!ds.isBorderBox(node)){
+_3a2-=ds.getPadBorderHeight(node);
+}
+_3a2-=ds.getMarginHeight(node);
+return ds.setPositivePixelValue(node,&quot;height&quot;,_3a2);
+};
+ds.getContentHeight=ds.getContentBoxHeight;
+ds.getInnerHeight=ds.getBorderBoxHeight;
+ds.getOuterHeight=ds.getMarginBoxHeight;
+ds.setContentHeight=ds.setContentBoxHeight;
+ds.setOuterHeight=ds.setMarginBoxHeight;
+ds.getAbsolutePosition=ds.abs=function(node,_3a4){
+node=dojo.byId(node);
+var ret=[];
+ret.x=ret.y=0;
+var st=dojo.html.getScrollTop();
+var sl=dojo.html.getScrollLeft();
+if(h.ie){
+with(node.getBoundingClientRect()){
+ret.x=left-2;
+ret.y=top-2;
+}
+}else{
+if(document.getBoxObjectFor){
+var bo=document.getBoxObjectFor(node);
+ret.x=bo.x-ds.sumAncestorProperties(node,&quot;scrollLeft&quot;);
+ret.y=bo.y-ds.sumAncestorProperties(node,&quot;scrollTop&quot;);
+}else{
+if(node[&quot;offsetParent&quot;]){
+var _3a9;
+if((h.safari)&amp;&amp;(node.style.getPropertyValue(&quot;position&quot;)==&quot;absolute&quot;)&amp;&amp;(node.parentNode==db)){
+_3a9=db;
+}else{
+_3a9=db.parentNode;
+}
+if(node.parentNode!=db){
+var nd=node;
+if(window.opera){
+nd=db;
+}
+ret.x-=ds.sumAncestorProperties(nd,&quot;scrollLeft&quot;);
+ret.y-=ds.sumAncestorProperties(nd,&quot;scrollTop&quot;);
+}
+do{
+var n=node[&quot;offsetLeft&quot;];
+ret.x+=isNaN(n)?0:n;
+var m=node[&quot;offsetTop&quot;];
+ret.y+=isNaN(m)?0:m;
+node=node.offsetParent;
+}while((node!=_3a9)&amp;&amp;(node!=null));
+}else{
+if(node[&quot;x&quot;]&amp;&amp;node[&quot;y&quot;]){
+ret.x+=isNaN(node.x)?0:node.x;
+ret.y+=isNaN(node.y)?0:node.y;
+}
+}
+}
+}
+if(_3a4){
+ret.y+=st;
+ret.x+=sl;
+}
+ret[0]=ret.x;
+ret[1]=ret.y;
+return ret;
+};
+ds.sumAncestorProperties=function(node,prop){
+node=dojo.byId(node);
+if(!node){
+return 0;
+}
+var _3af=0;
+while(node){
+var val=node[prop];
+if(val){
+_3af+=val-0;
+if(node==document.body){
+break;
+}
+}
+node=node.parentNode;
+}
+return _3af;
+};
+ds.getTotalOffset=function(node,type,_3b3){
+return ds.abs(node,_3b3)[(type==&quot;top&quot;)?&quot;y&quot;:&quot;x&quot;];
+};
+ds.getAbsoluteX=ds.totalOffsetLeft=function(node,_3b5){
+return ds.getTotalOffset(node,&quot;left&quot;,_3b5);
+};
+ds.getAbsoluteY=ds.totalOffsetTop=function(node,_3b7){
+return ds.getTotalOffset(node,&quot;top&quot;,_3b7);
+};
+ds.styleSheet=null;
+ds.insertCssRule=function(_3b8,_3b9,_3ba){
+if(!ds.styleSheet){
+if(document.createStyleSheet){
+ds.styleSheet=document.createStyleSheet();
+}else{
+if(document.styleSheets[0]){
+ds.styleSheet=document.styleSheets[0];
+}else{
+return null;
+}
+}
+}
+if(arguments.length&lt;3){
+if(ds.styleSheet.cssRules){
+_3ba=ds.styleSheet.cssRules.length;
+}else{
+if(ds.styleSheet.rules){
+_3ba=ds.styleSheet.rules.length;
+}else{
+return null;
+}
+}
+}
+if(ds.styleSheet.insertRule){
+var rule=_3b8+&quot; { &quot;+_3b9+&quot; }&quot;;
+return ds.styleSheet.insertRule(rule,_3ba);
+}else{
+if(ds.styleSheet.addRule){
+return ds.styleSheet.addRule(_3b8,_3b9,_3ba);
+}else{
+return null;
+}
+}
+};
+ds.removeCssRule=function(_3bc){
+if(!ds.styleSheet){
+dojo.debug(&quot;no stylesheet defined for removing rules&quot;);
+return false;
+}
+if(h.ie){
+if(!_3bc){
+_3bc=ds.styleSheet.rules.length;
+ds.styleSheet.removeRule(_3bc);
+}
+}else{
+if(document.styleSheets[0]){
+if(!_3bc){
+_3bc=ds.styleSheet.cssRules.length;
+}
+ds.styleSheet.deleteRule(_3bc);
+}
+}
+return true;
+};
+ds.insertCssFile=function(URI,doc,_3bf){
+if(!URI){
+return;
+}
+if(!doc){
+doc=document;
+}
+var _3c0=dojo.hostenv.getText(URI);
+_3c0=ds.fixPathsInCssText(_3c0,URI);
+if(_3bf){
+var _3c1=doc.getElementsByTagName(&quot;style&quot;);
+var _3c2=&quot;&quot;;
+for(var i=0;i&lt;_3c1.length;i++){
+_3c2=(_3c1[i].styleSheet&amp;&amp;_3c1[i].styleSheet.cssText)?_3c1[i].styleSheet.cssText:_3c1[i].innerHTML;
+if(_3c0==_3c2){
+return;
+}
+}
+}
+var _3c4=ds.insertCssText(_3c0);
+if(_3c4&amp;&amp;djConfig.isDebug){
+_3c4.setAttribute(&quot;dbgHref&quot;,URI);
+}
+return _3c4;
+};
+ds.insertCssText=function(_3c5,doc,URI){
+if(!_3c5){
+return;
+}
+if(!doc){
+doc=document;
+}
+if(URI){
+_3c5=ds.fixPathsInCssText(_3c5,URI);
+}
+var _3c8=doc.createElement(&quot;style&quot;);
+_3c8.setAttribute(&quot;type&quot;,&quot;text/css&quot;);
+var head=doc.getElementsByTagName(&quot;head&quot;)[0];
+if(!head){
+dojo.debug(&quot;No head tag in document, aborting styles&quot;);
+return;
+}else{
+head.appendChild(_3c8);
+}
+if(_3c8.styleSheet){
+_3c8.styleSheet.cssText=_3c5;
+}else{
+var _3ca=doc.createTextNode(_3c5);
+_3c8.appendChild(_3ca);
+}
+return _3c8;
+};
+ds.fixPathsInCssText=function(_3cb,URI){
+if(!_3cb||!URI){
+return;
+}
+var pos=0;
+var str=&quot;&quot;;
+var url=&quot;&quot;;
+while(pos!=-1){
+pos=0;
+url=&quot;&quot;;
+pos=_3cb.indexOf(&quot;url(&quot;,pos);
+if(pos&lt;0){
+break;
+}
+str+=_3cb.slice(0,pos+4);
+_3cb=_3cb.substring(pos+4,_3cb.length);
+url+=_3cb.match(/^[\t\s\w()\/.\\'&quot;-:#=&amp;?]*\)/)[0];
+_3cb=_3cb.substring(url.length-1,_3cb.length);
+url=url.replace(/^[\s\t]*(['&quot;]?)([\w()\/.\\'&quot;-:#=&amp;?]*)\1[\s\t]*?\)/,&quot;$2&quot;);
+if(url.search(/(file|https?|ftps?):\/\//)==-1){
+url=(new dojo.uri.Uri(URI,url).toString());
+}
+str+=url;
+}
+return str+_3cb;
+};
+ds.getBackgroundColor=function(node){
+node=dojo.byId(node);
+var _3d1;
+do{
+_3d1=ds.getStyle(node,&quot;background-color&quot;);
+if(_3d1.toLowerCase()==&quot;rgba(0, 0, 0, 0)&quot;){
+_3d1=&quot;transparent&quot;;
+}
+if(node==document.getElementsByTagName(&quot;body&quot;)[0]){
+node=null;
+break;
+}
+node=node.parentNode;
+}while(node&amp;&amp;dojo.lang.inArray(_3d1,[&quot;transparent&quot;,&quot;&quot;]));
+if(_3d1==&quot;transparent&quot;){
+_3d1=[255,255,255,0];
+}else{
+_3d1=dojo.graphics.color.extractRGB(_3d1);
+}
+return _3d1;
+};
+ds.getComputedStyle=function(node,_3d3,_3d4){
+node=dojo.byId(node);
+var _3d3=ds.toSelectorCase(_3d3);
+var _3d5=ds.toCamelCase(_3d3);
+if(!node||!node.style){
+return _3d4;
+}else{
+if(document.defaultView){
+try{
+var cs=document.defaultView.getComputedStyle(node,&quot;&quot;);
+if(cs){
+return cs.getPropertyValue(_3d3);
+}
+}
+catch(e){
+if(node.style.getPropertyValue){
+return node.style.getPropertyValue(_3d3);
+}else{
+return _3d4;
+}
+}
+}else{
+if(node.currentStyle){
+return node.currentStyle[_3d5];
+}
+}
+}
+if(node.style.getPropertyValue){
+return node.style.getPropertyValue(_3d3);
+}else{
+return _3d4;
+}
+};
+ds.getStyleProperty=function(node,_3d8){
+node=dojo.byId(node);
+return (node&amp;&amp;node.style?node.style[ds.toCamelCase(_3d8)]:undefined);
+};
+ds.getStyle=function(node,_3da){
+var _3db=ds.getStyleProperty(node,_3da);
+return (_3db?_3db:ds.getComputedStyle(node,_3da));
+};
+ds.setStyle=function(node,_3dd,_3de){
+node=dojo.byId(node);
+if(node&amp;&amp;node.style){
+var _3df=ds.toCamelCase(_3dd);
+node.style[_3df]=_3de;
+}
+};
+ds.toCamelCase=function(_3e0){
+var arr=_3e0.split(&quot;-&quot;),cc=arr[0];
+for(var i=1;i&lt;arr.length;i++){
+cc+=arr[i].charAt(0).toUpperCase()+arr[i].substring(1);
+}
+return cc;
+};
+ds.toSelectorCase=function(_3e3){
+return _3e3.replace(/([A-Z])/g,&quot;-$1&quot;).toLowerCase();
+};
+ds.setOpacity=function setOpacity(node,_3e5,_3e6){
+node=dojo.byId(node);
+if(!_3e6){
+if(_3e5&gt;=1){
+if(h.ie){
+ds.clearOpacity(node);
+return;
+}else{
+_3e5=0.999999;
+}
+}else{
+if(_3e5&lt;0){
+_3e5=0;
+}
+}
+}
+if(h.ie){
+if(node.nodeName.toLowerCase()==&quot;tr&quot;){
+var tds=node.getElementsByTagName(&quot;td&quot;);
+for(var x=0;x&lt;tds.length;x++){
+tds[x].style.filter=&quot;Alpha(Opacity=&quot;+_3e5*100+&quot;)&quot;;
+}
+}
+node.style.filter=&quot;Alpha(Opacity=&quot;+_3e5*100+&quot;)&quot;;
+}else{
+if(h.moz){
+node.style.opacity=_3e5;
+node.style.MozOpacity=_3e5;
+}else{
+if(h.safari){
+node.style.opacity=_3e5;
+node.style.KhtmlOpacity=_3e5;
+}else{
+node.style.opacity=_3e5;
+}
+}
+}
+};
+ds.getOpacity=function getOpacity(node){
+node=dojo.byId(node);
+if(h.ie){
+var opac=(node.filters&amp;&amp;node.filters.alpha&amp;&amp;typeof node.filters.alpha.opacity==&quot;number&quot;?node.filters.alpha.opacity:100)/100;
+}else{
+var opac=node.style.opacity||node.style.MozOpacity||node.style.KhtmlOpacity||1;
+}
+return opac&gt;=0.999999?1:Number(opac);
+};
+ds.clearOpacity=function clearOpacity(node){
+node=dojo.byId(node);
+var ns=node.style;
+if(h.ie){
+try{
+if(node.filters&amp;&amp;node.filters.alpha){
+ns.filter=&quot;&quot;;
+}
+}
+catch(e){
+}
+}else{
+if(h.moz){
+ns.opacity=1;
+ns.MozOpacity=1;
+}else{
+if(h.safari){
+ns.opacity=1;
+ns.KhtmlOpacity=1;
+}else{
+ns.opacity=1;
+}
+}
+}
+};
+ds.setStyleAttributes=function(node,_3ee){
+var _3ef={&quot;opacity&quot;:dojo.style.setOpacity,&quot;content-height&quot;:dojo.style.setContentHeight,&quot;content-width&quot;:dojo.style.setContentWidth,&quot;outer-height&quot;:dojo.style.setOuterHeight,&quot;outer-width&quot;:dojo.style.setOuterWidth};
+var _3f0=_3ee.replace(/(;)?\s*$/,&quot;&quot;).split(&quot;;&quot;);
+for(var i=0;i&lt;_3f0.length;i++){
+var _3f2=_3f0[i].split(&quot;:&quot;);
+var name=_3f2[0].replace(/\s*$/,&quot;&quot;).replace(/^\s*/,&quot;&quot;).toLowerCase();
+var _3f4=_3f2[1].replace(/\s*$/,&quot;&quot;).replace(/^\s*/,&quot;&quot;);
+if(dojo.lang.has(_3ef,name)){
+_3ef[name](node,_3f4);
+}else{
+node.style[dojo.style.toCamelCase(name)]=_3f4;
+}
+}
+};
+ds._toggle=function(node,_3f6,_3f7){
+node=dojo.byId(node);
+_3f7(node,!_3f6(node));
+return _3f6(node);
+};
+ds.show=function(node){
+node=dojo.byId(node);
+if(ds.getStyleProperty(node,&quot;display&quot;)==&quot;none&quot;){
+ds.setStyle(node,&quot;display&quot;,(node.dojoDisplayCache||&quot;&quot;));
+node.dojoDisplayCache=undefined;
+}
+};
+ds.hide=function(node){
+node=dojo.byId(node);
+if(typeof node[&quot;dojoDisplayCache&quot;]==&quot;undefined&quot;){
+var d=ds.getStyleProperty(node,&quot;display&quot;);
+if(d!=&quot;none&quot;){
+node.dojoDisplayCache=d;
+}
+}
+ds.setStyle(node,&quot;display&quot;,&quot;none&quot;);
+};
+ds.setShowing=function(node,_3fc){
+ds[(_3fc?&quot;show&quot;:&quot;hide&quot;)](node);
+};
+ds.isShowing=function(node){
+return (ds.getStyleProperty(node,&quot;display&quot;)!=&quot;none&quot;);
+};
+ds.toggleShowing=function(node){
+return ds._toggle(node,ds.isShowing,ds.setShowing);
+};
+ds.displayMap={tr:&quot;&quot;,td:&quot;&quot;,th:&quot;&quot;,img:&quot;inline&quot;,span:&quot;inline&quot;,input:&quot;inline&quot;,button:&quot;inline&quot;};
+ds.suggestDisplayByTagName=function(node){
+node=dojo.byId(node);
+if(node&amp;&amp;node.tagName){
+var tag=node.tagName.toLowerCase();
+return (tag in ds.displayMap?ds.displayMap[tag]:&quot;block&quot;);
+}
+};
+ds.setDisplay=function(node,_402){
+ds.setStyle(node,&quot;display&quot;,(dojo.lang.isString(_402)?_402:(_402?ds.suggestDisplayByTagName(node):&quot;none&quot;)));
+};
+ds.isDisplayed=function(node){
+return (ds.getComputedStyle(node,&quot;display&quot;)!=&quot;none&quot;);
+};
+ds.toggleDisplay=function(node){
+return ds._toggle(node,ds.isDisplayed,ds.setDisplay);
+};
+ds.setVisibility=function(node,_406){
+ds.setStyle(node,&quot;visibility&quot;,(dojo.lang.isString(_406)?_406:(_406?&quot;visible&quot;:&quot;hidden&quot;)));
+};
+ds.isVisible=function(node){
+return (ds.getComputedStyle(node,&quot;visibility&quot;)!=&quot;hidden&quot;);
+};
+ds.toggleVisibility=function(node){
+return ds._toggle(node,ds.isVisible,ds.setVisibility);
+};
+ds.toCoordinateArray=function(_409,_40a){
+if(dojo.lang.isArray(_409)){
+while(_409.length&lt;4){
+_409.push(0);
+}
+while(_409.length&gt;4){
+_409.pop();
+}
+var ret=_409;
+}else{
+var node=dojo.byId(_409);
+var pos=ds.getAbsolutePosition(node,_40a);
+var ret=[pos.x,pos.y,ds.getBorderBoxWidth(node),ds.getBorderBoxHeight(node)];
+}
+ret.x=ret[0];
+ret.y=ret[1];
+ret.w=ret[2];
+ret.h=ret[3];
+return ret;
+};
+})();
+dojo.provide(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.lang.mixin(dojo.html,dojo.dom);
+dojo.lang.mixin(dojo.html,dojo.style);
+dojo.html.clearSelection=function(){
+try{
+if(window[&quot;getSelection&quot;]){
+if(dojo.render.html.safari){
+window.getSelection().collapse();
+}else{
+window.getSelection().removeAllRanges();
+}
+}else{
+if(document.selection){
+if(document.selection.empty){
+document.selection.empty();
+}else{
+if(document.selection.clear){
+document.selection.clear();
+}
+}
+}
+}
+return true;
+}
+catch(e){
+dojo.debug(e);
+return false;
+}
+};
+dojo.html.disableSelection=function(_40e){
+_40e=dojo.byId(_40e)||document.body;
+var h=dojo.render.html;
+if(h.mozilla){
+_40e.style.MozUserSelect=&quot;none&quot;;
+}else{
+if(h.safari){
+_40e.style.KhtmlUserSelect=&quot;none&quot;;
+}else{
+if(h.ie){
+_40e.unselectable=&quot;on&quot;;
+}else{
+return false;
+}
+}
+}
+return true;
+};
+dojo.html.enableSelection=function(_410){
+_410=dojo.byId(_410)||document.body;
+var h=dojo.render.html;
+if(h.mozilla){
+_410.style.MozUserSelect=&quot;&quot;;
+}else{
+if(h.safari){
+_410.style.KhtmlUserSelect=&quot;&quot;;
+}else{
+if(h.ie){
+_410.unselectable=&quot;off&quot;;
+}else{
+return false;
+}
+}
+}
+return true;
+};
+dojo.html.selectElement=function(_412){
+_412=dojo.byId(_412);
+if(document.selection&amp;&amp;document.body.createTextRange){
+var _413=document.body.createTextRange();
+_413.moveToElementText(_412);
+_413.select();
+}else{
+if(window[&quot;getSelection&quot;]){
+var _414=window.getSelection();
+if(_414[&quot;selectAllChildren&quot;]){
+_414.selectAllChildren(_412);
+}
+}
+}
+};
+dojo.html.selectInputText=function(_415){
+_415=dojo.byId(_415);
+if(document.selection&amp;&amp;document.body.createTextRange){
+var _416=_415.createTextRange();
+_416.moveStart(&quot;character&quot;,0);
+_416.moveEnd(&quot;character&quot;,_415.value.length);
+_416.select();
+}else{
+if(window[&quot;getSelection&quot;]){
+var _417=window.getSelection();
+_415.setSelectionRange(0,_415.value.length);
+}
+}
+_415.focus();
+};
+dojo.html.isSelectionCollapsed=function(){
+if(document[&quot;selection&quot;]){
+return document.selection.createRange().text==&quot;&quot;;
+}else{
+if(window[&quot;getSelection&quot;]){
+var _418=window.getSelection();
+if(dojo.lang.isString(_418)){
+return _418==&quot;&quot;;
+}else{
+return _418.isCollapsed;
+}
+}
+}
+};
+dojo.html.getEventTarget=function(evt){
+if(!evt){
+evt=window.event||{};
+}
+var t=(evt.srcElement?evt.srcElement:(evt.target?evt.target:null));
+while((t)&amp;&amp;(t.nodeType!=1)){
+t=t.parentNode;
+}
+return t;
+};
+dojo.html.getDocumentWidth=function(){
+dojo.deprecated(&quot;dojo.html.getDocument*&quot;,&quot;replaced by dojo.html.getViewport*&quot;,&quot;0.4&quot;);
+return dojo.html.getViewportWidth();
+};
+dojo.html.getDocumentHeight=function(){
+dojo.deprecated(&quot;dojo.html.getDocument*&quot;,&quot;replaced by dojo.html.getViewport*&quot;,&quot;0.4&quot;);
+return dojo.html.getViewportHeight();
+};
+dojo.html.getDocumentSize=function(){
+dojo.deprecated(&quot;dojo.html.getDocument*&quot;,&quot;replaced of dojo.html.getViewport*&quot;,&quot;0.4&quot;);
+return dojo.html.getViewportSize();
+};
+dojo.html.getViewportWidth=function(){
+var w=0;
+if(window.innerWidth){
+w=window.innerWidth;
+}
+if(dojo.exists(document,&quot;documentElement.clientWidth&quot;)){
+var w2=document.documentElement.clientWidth;
+if(!w||w2&amp;&amp;w2&lt;w){
+w=w2;
+}
+return w;
+}
+if(document.body){
+return document.body.clientWidth;
+}
+return 0;
+};
+dojo.html.getViewportHeight=function(){
+if(window.innerHeight){
+return window.innerHeight;
+}
+if(dojo.exists(document,&quot;documentElement.clientHeight&quot;)){
+return document.documentElement.clientHeight;
+}
+if(document.body){
+return document.body.clientHeight;
+}
+return 0;
+};
+dojo.html.getViewportSize=function(){
+var ret=[dojo.html.getViewportWidth(),dojo.html.getViewportHeight()];
+ret.w=ret[0];
+ret.h=ret[1];
+return ret;
+};
+dojo.html.getScrollTop=function(){
+return window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;
+};
+dojo.html.getScrollLeft=function(){
+return window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;
+};
+dojo.html.getScrollOffset=function(){
+var off=[dojo.html.getScrollLeft(),dojo.html.getScrollTop()];
+off.x=off[0];
+off.y=off[1];
+return off;
+};
+dojo.html.getParentOfType=function(node,type){
+dojo.deprecated(&quot;dojo.html.getParentOfType&quot;,&quot;replaced by dojo.html.getParentByType*&quot;,&quot;0.4&quot;);
+return dojo.html.getParentByType(node,type);
+};
+dojo.html.getParentByType=function(node,type){
+var _423=dojo.byId(node);
+type=type.toLowerCase();
+while((_423)&amp;&amp;(_423.nodeName.toLowerCase()!=type)){
+if(_423==(document[&quot;body&quot;]||document[&quot;documentElement&quot;])){
+return null;
+}
+_423=_423.parentNode;
+}
+return _423;
+};
+dojo.html.getAttribute=function(node,attr){
+node=dojo.byId(node);
+if((!node)||(!node.getAttribute)){
+return null;
+}
+var ta=typeof attr==&quot;string&quot;?attr:new String(attr);
+var v=node.getAttribute(ta.toUpperCase());
+if((v)&amp;&amp;(typeof v==&quot;string&quot;)&amp;&amp;(v!=&quot;&quot;)){
+return v;
+}
+if(v&amp;&amp;v.value){
+return v.value;
+}
+if((node.getAttributeNode)&amp;&amp;(node.getAttributeNode(ta))){
+return (node.getAttributeNode(ta)).value;
+}else{
+if(node.getAttribute(ta)){
+return node.getAttribute(ta);
+}else{
+if(node.getAttribute(ta.toLowerCase())){
+return node.getAttribute(ta.toLowerCase());
+}
+}
+}
+return null;
+};
+dojo.html.hasAttribute=function(node,attr){
+node=dojo.byId(node);
+return dojo.html.getAttribute(node,attr)?true:false;
+};
+dojo.html.getClass=function(node){
+node=dojo.byId(node);
+if(!node){
+return &quot;&quot;;
+}
+var cs=&quot;&quot;;
+if(node.className){
+cs=node.className;
+}else{
+if(dojo.html.hasAttribute(node,&quot;class&quot;)){
+cs=dojo.html.getAttribute(node,&quot;class&quot;);
+}
+}
+return dojo.string.trim(cs);
+};
+dojo.html.getClasses=function(node){
+var c=dojo.html.getClass(node);
+return (c==&quot;&quot;)?[]:c.split(/\s+/g);
+};
+dojo.html.hasClass=function(node,_42f){
+return dojo.lang.inArray(dojo.html.getClasses(node),_42f);
+};
+dojo.html.prependClass=function(node,_431){
+_431+=&quot; &quot;+dojo.html.getClass(node);
+return dojo.html.setClass(node,_431);
+};
+dojo.html.addClass=function(node,_433){
+if(dojo.html.hasClass(node,_433)){
+return false;
+}
+_433=dojo.string.trim(dojo.html.getClass(node)+&quot; &quot;+_433);
+return dojo.html.setClass(node,_433);
+};
+dojo.html.setClass=function(node,_435){
+node=dojo.byId(node);
+var cs=new String(_435);
+try{
+if(typeof node.className==&quot;string&quot;){
+node.className=cs;
+}else{
+if(node.setAttribute){
+node.setAttribute(&quot;class&quot;,_435);
+node.className=cs;
+}else{
+return false;
+}
+}
+}
+catch(e){
+dojo.debug(&quot;dojo.html.setClass() failed&quot;,e);
+}
+return true;
+};
+dojo.html.removeClass=function(node,_438,_439){
+var _438=dojo.string.trim(new String(_438));
+try{
+var cs=dojo.html.getClasses(node);
+var nca=[];
+if(_439){
+for(var i=0;i&lt;cs.length;i++){
+if(cs[i].indexOf(_438)==-1){
+nca.push(cs[i]);
+}
+}
+}else{
+for(var i=0;i&lt;cs.length;i++){
+if(cs[i]!=_438){
+nca.push(cs[i]);
+}
+}
+}
+dojo.html.setClass(node,nca.join(&quot; &quot;));
+}
+catch(e){
+dojo.debug(&quot;dojo.html.removeClass() failed&quot;,e);
+}
+return true;
+};
+dojo.html.replaceClass=function(node,_43e,_43f){
+dojo.html.removeClass(node,_43f);
+dojo.html.addClass(node,_43e);
+};
+dojo.html.classMatchType={ContainsAll:0,ContainsAny:1,IsOnly:2};
+dojo.html.getElementsByClass=function(_440,_441,_442,_443,_444){
+_441=dojo.byId(_441)||document;
+var _445=_440.split(/\s+/g);
+var _446=[];
+if(_443!=1&amp;&amp;_443!=2){
+_443=0;
+}
+var _447=new RegExp(&quot;(\\s|^)((&quot;+_445.join(&quot;)|(&quot;)+&quot;))(\\s|$)&quot;);
+var _448=[];
+if(!_444&amp;&amp;document.evaluate){
+var _449=&quot;//&quot;+(_442||&quot;*&quot;)+&quot;[contains(&quot;;
+if(_443!=dojo.html.classMatchType.ContainsAny){
+_449+=&quot;concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot;+_445.join(&quot; ') and contains(concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot;)+&quot; ')]&quot;;
+}else{
+_449+=&quot;concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot;+_445.join(&quot; ')) or contains(concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot;)+&quot; ')]&quot;;
+}
+var _44a=document.evaluate(_449,_441,null,XPathResult.ANY_TYPE,null);
+var _44b=_44a.iterateNext();
+while(_44b){
+try{
+_448.push(_44b);
+_44b=_44a.iterateNext();
+}
+catch(e){
+break;
+}
+}
+return _448;
+}else{
+if(!_442){
+_442=&quot;*&quot;;
+}
+_448=_441.getElementsByTagName(_442);
+var node,i=0;
+outer:
+while(node=_448[i++]){
+var _44d=dojo.html.getClasses(node);
+if(_44d.length==0){
+continue outer;
+}
+var _44e=0;
+for(var j=0;j&lt;_44d.length;j++){
+if(_447.test(_44d[j])){
+if(_443==dojo.html.classMatchType.ContainsAny){
+_446.push(node);
+continue outer;
+}else{
+_44e++;
+}
+}else{
+if(_443==dojo.html.classMatchType.IsOnly){
+continue outer;
+}
+}
+}
+if(_44e==_445.length){
+if((_443==dojo.html.classMatchType.IsOnly)&amp;&amp;(_44e==_44d.length)){
+_446.push(node);
+}else{
+if(_443==dojo.html.classMatchType.ContainsAll){
+_446.push(node);
+}
+}
+}
+}
+return _446;
+}
+};
+dojo.html.getElementsByClassName=dojo.html.getElementsByClass;
+dojo.html.getCursorPosition=function(e){
+e=e||window.event;
+var _451={x:0,y:0};
+if(e.pageX||e.pageY){
+_451.x=e.pageX;
+_451.y=e.pageY;
+}else{
+var de=document.documentElement;
+var db=document.body;
+_451.x=e.clientX+((de||db)[&quot;scrollLeft&quot;])-((de||db)[&quot;clientLeft&quot;]);
+_451.y=e.clientY+((de||db)[&quot;scrollTop&quot;])-((de||db)[&quot;clientTop&quot;]);
+}
+return _451;
+};
+dojo.html.overElement=function(_454,e){
+_454=dojo.byId(_454);
+var _456=dojo.html.getCursorPosition(e);
+with(dojo.html){
+var top=getAbsoluteY(_454,true);
+var _458=top+getInnerHeight(_454);
+var left=getAbsoluteX(_454,true);
+var _45a=left+getInnerWidth(_454);
+}
+return (_456.x&gt;=left&amp;&amp;_456.x&lt;=_45a&amp;&amp;_456.y&gt;=top&amp;&amp;_456.y&lt;=_458);
+};
+dojo.html.setActiveStyleSheet=function(_45b){
+var i=0,a,els=document.getElementsByTagName(&quot;link&quot;);
+while(a=els[i++]){
+if(a.getAttribute(&quot;rel&quot;).indexOf(&quot;style&quot;)!=-1&amp;&amp;a.getAttribute(&quot;title&quot;)){
+a.disabled=true;
+if(a.getAttribute(&quot;title&quot;)==_45b){
+a.disabled=false;
+}
+}
+}
+};
+dojo.html.getActiveStyleSheet=function(){
+var i=0,a,els=document.getElementsByTagName(&quot;link&quot;);
+while(a=els[i++]){
+if(a.getAttribute(&quot;rel&quot;).indexOf(&quot;style&quot;)!=-1&amp;&amp;a.getAttribute(&quot;title&quot;)&amp;&amp;!a.disabled){
+return a.getAttribute(&quot;title&quot;);
+}
+}
+return null;
+};
+dojo.html.getPreferredStyleSheet=function(){
+var i=0,a,els=document.getElementsByTagName(&quot;link&quot;);
+while(a=els[i++]){
+if(a.getAttribute(&quot;rel&quot;).indexOf(&quot;style&quot;)!=-1&amp;&amp;a.getAttribute(&quot;rel&quot;).indexOf(&quot;alt&quot;)==-1&amp;&amp;a.getAttribute(&quot;title&quot;)){
+return a.getAttribute(&quot;title&quot;);
+}
+}
+return null;
+};
+dojo.html.body=function(){
+return document.body||document.getElementsByTagName(&quot;body&quot;)[0];
+};
+dojo.html.isTag=function(node){
+node=dojo.byId(node);
+if(node&amp;&amp;node.tagName){
+var arr=dojo.lang.map(dojo.lang.toArray(arguments,1),function(a){
+return String(a).toLowerCase();
+});
+return arr[dojo.lang.find(node.tagName.toLowerCase(),arr)]||&quot;&quot;;
+}
+return &quot;&quot;;
+};
+dojo.html.copyStyle=function(_462,_463){
+if(dojo.lang.isUndefined(_463.style.cssText)){
+_462.setAttribute(&quot;style&quot;,_463.getAttribute(&quot;style&quot;));
+}else{
+_462.style.cssText=_463.style.cssText;
+}
+dojo.html.addClass(_462,dojo.html.getClass(_463));
+};
+dojo.html._callExtrasDeprecated=function(_464,args){
+var _466=&quot;dojo.html.extras&quot;;
+dojo.deprecated(&quot;dojo.html.&quot;+_464,&quot;moved to &quot;+_466,&quot;0.4&quot;);
+dojo[&quot;require&quot;](_466);
+return dojo.html[_464].apply(dojo.html,args);
+};
+dojo.html.createNodesFromText=function(){
+return dojo.html._callExtrasDeprecated(&quot;createNodesFromText&quot;,arguments);
+};
+dojo.html.gravity=function(){
+return dojo.html._callExtrasDeprecated(&quot;gravity&quot;,arguments);
+};
+dojo.html.placeOnScreen=function(){
+return dojo.html._callExtrasDeprecated(&quot;placeOnScreen&quot;,arguments);
+};
+dojo.html.placeOnScreenPoint=function(){
+return dojo.html._callExtrasDeprecated(&quot;placeOnScreenPoint&quot;,arguments);
+};
+dojo.html.renderedTextContent=function(){
+return dojo.html._callExtrasDeprecated(&quot;renderedTextContent&quot;,arguments);
+};
+dojo.html.BackgroundIframe=function(){
+return dojo.html._callExtrasDeprecated(&quot;BackgroundIframe&quot;,arguments);
+};
+dojo.provide(&quot;dojo.lfx.html&quot;);
+dojo.require(&quot;dojo.lfx.Animation&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.lfx.html._byId=function(_467){
+if(!_467){
+return [];
+}
+if(dojo.lang.isArray(_467)){
+if(!_467.alreadyChecked){
+var n=[];
+dojo.lang.forEach(_467,function(node){
+n.push(dojo.byId(node));
+});
+n.alreadyChecked=true;
+return n;
+}else{
+return _467;
+}
+}else{
+var n=[];
+n.push(dojo.byId(_467));
+n.alreadyChecked=true;
+return n;
+}
+};
+dojo.lfx.html.propertyAnimation=function(_46a,_46b,_46c,_46d){
+_46a=dojo.lfx.html._byId(_46a);
+if(_46a.length==1){
+dojo.lang.forEach(_46b,function(prop){
+if(typeof prop[&quot;start&quot;]==&quot;undefined&quot;){
+if(prop.property!=&quot;opacity&quot;){
+prop.start=parseInt(dojo.style.getComputedStyle(_46a[0],prop.property));
+}else{
+prop.start=dojo.style.getOpacity(_46a[0]);
+}
+}
+});
+}
+var _46f=function(_470){
+var _471=new Array(_470.length);
+for(var i=0;i&lt;_470.length;i++){
+_471[i]=Math.round(_470[i]);
+}
+return _471;
+};
+var _473=function(n,_475){
+n=dojo.byId(n);
+if(!n||!n.style){
+return;
+}
+for(var s in _475){
+if(s==&quot;opacity&quot;){
+dojo.style.setOpacity(n,_475[s]);
+}else{
+n.style[s]=_475[s];
+}
+}
+};
+var _477=function(_478){
+this._properties=_478;
+this.diffs=new Array(_478.length);
+dojo.lang.forEach(_478,function(prop,i){
+if(dojo.lang.isArray(prop.start)){
+this.diffs[i]=null;
+}else{
+if(prop.start instanceof dojo.graphics.color.Color){
+prop.startRgb=prop.start.toRgb();
+prop.endRgb=prop.end.toRgb();
+}else{
+this.diffs[i]=prop.end-prop.start;
+}
+}
+},this);
+this.getValue=function(n){
+var ret={};
+dojo.lang.forEach(this._properties,function(prop,i){
+var _47f=null;
+if(dojo.lang.isArray(prop.start)){
+}else{
+if(prop.start instanceof dojo.graphics.color.Color){
+_47f=(prop.units||&quot;rgb&quot;)+&quot;(&quot;;
+for(var j=0;j&lt;prop.startRgb.length;j++){
+_47f+=Math.round(((prop.endRgb[j]-prop.startRgb[j])*n)+prop.startRgb[j])+(j&lt;prop.startRgb.length-1?&quot;,&quot;:&quot;&quot;);
+}
+_47f+=&quot;)&quot;;
+}else{
+_47f=((this.diffs[i])*n)+prop.start+(prop.property!=&quot;opacity&quot;?prop.units||&quot;px&quot;:&quot;&quot;);
+}
+}
+ret[dojo.style.toCamelCase(prop.property)]=_47f;
+},this);
+return ret;
+};
+};
+var anim=new dojo.lfx.Animation({onAnimate:function(_482){
+dojo.lang.forEach(_46a,function(node){
+_473(node,_482);
+});
+}},_46c,new _477(_46b),_46d);
+return anim;
+};
+dojo.lfx.html._makeFadeable=function(_484){
+var _485=function(node){
+if(dojo.render.html.ie){
+if((node.style.zoom.length==0)&amp;&amp;(dojo.style.getStyle(node,&quot;zoom&quot;)==&quot;normal&quot;)){
+node.style.zoom=&quot;1&quot;;
+}
+if((node.style.width.length==0)&amp;&amp;(dojo.style.getStyle(node,&quot;width&quot;)==&quot;auto&quot;)){
+node.style.width=&quot;auto&quot;;
+}
+}
+};
+if(dojo.lang.isArrayLike(_484)){
+dojo.lang.forEach(_484,_485);
+}else{
+_485(_484);
+}
+};
+dojo.lfx.html.fadeIn=function(_487,_488,_489,_48a){
+_487=dojo.lfx.html._byId(_487);
+dojo.lfx.html._makeFadeable(_487);
+var anim=dojo.lfx.propertyAnimation(_487,[{property:&quot;opacity&quot;,start:dojo.style.getOpacity(_487[0]),end:1}],_488,_489);
+if(_48a){
+var _48c=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_48c();
+_48a(_487,anim);
+};
+}
+return anim;
+};
+dojo.lfx.html.fadeOut=function(_48d,_48e,_48f,_490){
+_48d=dojo.lfx.html._byId(_48d);
+dojo.lfx.html._makeFadeable(_48d);
+var anim=dojo.lfx.propertyAnimation(_48d,[{property:&quot;opacity&quot;,start:dojo.style.getOpacity(_48d[0]),end:0}],_48e,_48f);
+if(_490){
+var _492=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_492();
+_490(_48d,anim);
+};
+}
+return anim;
+};
+dojo.lfx.html.fadeShow=function(_493,_494,_495,_496){
+var anim=dojo.lfx.html.fadeIn(_493,_494,_495,_496);
+var _498=(anim[&quot;beforeBegin&quot;])?dojo.lang.hitch(anim,&quot;beforeBegin&quot;):function(){
+};
+anim.beforeBegin=function(){
+_498();
+if(dojo.lang.isArrayLike(_493)){
+dojo.lang.forEach(_493,dojo.style.show);
+}else{
+dojo.style.show(_493);
+}
+};
+return anim;
+};
+dojo.lfx.html.fadeHide=function(_499,_49a,_49b,_49c){
+var anim=dojo.lfx.html.fadeOut(_499,_49a,_49b,function(){
+if(dojo.lang.isArrayLike(_499)){
+dojo.lang.forEach(_499,dojo.style.hide);
+}else{
+dojo.style.hide(_499);
+}
+if(_49c){
+_49c(_499,anim);
+}
+});
+return anim;
+};
+dojo.lfx.html.wipeIn=function(_49e,_49f,_4a0,_4a1){
+_49e=dojo.lfx.html._byId(_49e);
+var _4a2=[];
+dojo.lang.forEach(_49e,function(node){
+var _4a4=dojo.style.getStyle(node,&quot;overflow&quot;);
+if(_4a4==&quot;visible&quot;){
+node.style.overflow=&quot;hidden&quot;;
+}
+node.style.height=&quot;0px&quot;;
+dojo.style.show(node);
+var anim=dojo.lfx.propertyAnimation(node,[{property:&quot;height&quot;,start:0,end:node.scrollHeight}],_49f,_4a0);
+var _4a6=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4a6();
+node.style.overflow=_4a4;
+node.style.height=&quot;auto&quot;;
+if(_4a1){
+_4a1(node,anim);
+}
+};
+_4a2.push(anim);
+});
+if(_49e.length&gt;1){
+return dojo.lfx.combine(_4a2);
+}else{
+return _4a2[0];
+}
+};
+dojo.lfx.html.wipeOut=function(_4a7,_4a8,_4a9,_4aa){
+_4a7=dojo.lfx.html._byId(_4a7);
+var _4ab=[];
+dojo.lang.forEach(_4a7,function(node){
+var _4ad=dojo.style.getStyle(node,&quot;overflow&quot;);
+if(_4ad==&quot;visible&quot;){
+node.style.overflow=&quot;hidden&quot;;
+}
+dojo.style.show(node);
+var anim=dojo.lfx.propertyAnimation(node,[{property:&quot;height&quot;,start:dojo.style.getContentBoxHeight(node),end:0}],_4a8,_4a9);
+var _4af=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4af();
+dojo.style.hide(node);
+node.style.overflow=_4ad;
+if(_4aa){
+_4aa(node,anim);
+}
+};
+_4ab.push(anim);
+});
+if(_4a7.length&gt;1){
+return dojo.lfx.combine(_4ab);
+}else{
+return _4ab[0];
+}
+};
+dojo.lfx.html.slideTo=function(_4b0,_4b1,_4b2,_4b3,_4b4){
+_4b0=dojo.lfx.html._byId(_4b0);
+var _4b5=[];
+dojo.lang.forEach(_4b0,function(node){
+var top=null;
+var left=null;
+var init=(function(){
+var _4ba=node;
+return function(){
+top=_4ba.offsetTop;
+left=_4ba.offsetLeft;
+if(!dojo.style.isPositionAbsolute(_4ba)){
+var ret=dojo.style.abs(_4ba,true);
+dojo.style.setStyleAttributes(_4ba,&quot;position:absolute;top:&quot;+ret.y+&quot;px;left:&quot;+ret.x+&quot;px;&quot;);
+top=ret.y;
+left=ret.x;
+}
+};
+})();
+init();
+var anim=dojo.lfx.propertyAnimation(node,[{property:&quot;top&quot;,start:top,end:_4b1[0]},{property:&quot;left&quot;,start:left,end:_4b1[1]}],_4b2,_4b3);
+var _4bd=(anim[&quot;beforeBegin&quot;])?dojo.lang.hitch(anim,&quot;beforeBegin&quot;):function(){
+};
+anim.beforeBegin=function(){
+_4bd();
+init();
+};
+if(_4b4){
+var _4be=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4be();
+_4b4(_4b0,anim);
+};
+}
+_4b5.push(anim);
+});
+if(_4b0.length&gt;1){
+return dojo.lfx.combine(_4b5);
+}else{
+return _4b5[0];
+}
+};
+dojo.lfx.html.slideBy=function(_4bf,_4c0,_4c1,_4c2,_4c3){
+_4bf=dojo.lfx.html._byId(_4bf);
+var _4c4=[];
+dojo.lang.forEach(_4bf,function(node){
+var top=null;
+var left=null;
+var init=(function(){
+var _4c9=node;
+return function(){
+top=node.offsetTop;
+left=node.offsetLeft;
+if(!dojo.style.isPositionAbsolute(_4c9)){
+var ret=dojo.style.abs(_4c9);
+dojo.style.setStyleAttributes(_4c9,&quot;position:absolute;top:&quot;+ret.y+&quot;px;left:&quot;+ret.x+&quot;px;&quot;);
+top=ret.y;
+left=ret.x;
+}
+};
+})();
+init();
+var anim=dojo.lfx.propertyAnimation(node,[{property:&quot;top&quot;,start:top,end:top+_4c0[0]},{property:&quot;left&quot;,start:left,end:left+_4c0[1]}],_4c1,_4c2);
+var _4cc=(anim[&quot;beforeBegin&quot;])?dojo.lang.hitch(anim,&quot;beforeBegin&quot;):function(){
+};
+anim.beforeBegin=function(){
+_4cc();
+init();
+};
+if(_4c3){
+var _4cd=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4cd();
+_4c3(_4bf,anim);
+};
+}
+_4c4.push(anim);
+});
+if(_4bf.length&gt;1){
+return dojo.lfx.combine(_4c4);
+}else{
+return _4c4[0];
+}
+};
+dojo.lfx.html.explode=function(_4ce,_4cf,_4d0,_4d1,_4d2){
+_4ce=dojo.byId(_4ce);
+_4cf=dojo.byId(_4cf);
+var _4d3=dojo.style.toCoordinateArray(_4ce,true);
+var _4d4=document.createElement(&quot;div&quot;);
+dojo.html.copyStyle(_4d4,_4cf);
+with(_4d4.style){
+position=&quot;absolute&quot;;
+display=&quot;none&quot;;
+}
+document.body.appendChild(_4d4);
+with(_4cf.style){
+visibility=&quot;hidden&quot;;
+display=&quot;block&quot;;
+}
+var _4d5=dojo.style.toCoordinateArray(_4cf,true);
+with(_4cf.style){
+display=&quot;none&quot;;
+visibility=&quot;visible&quot;;
+}
+var anim=new dojo.lfx.propertyAnimation(_4d4,[{property:&quot;height&quot;,start:_4d3[3],end:_4d5[3]},{property:&quot;width&quot;,start:_4d3[2],end:_4d5[2]},{property:&quot;top&quot;,start:_4d3[1],end:_4d5[1]},{property:&quot;left&quot;,start:_4d3[0],end:_4d5[0]},{property:&quot;opacity&quot;,start:0.3,end:1}],_4d0,_4d1);
+anim.beforeBegin=function(){
+dojo.style.setDisplay(_4d4,&quot;block&quot;);
+};
+anim.onEnd=function(){
+dojo.style.setDisplay(_4cf,&quot;block&quot;);
+_4d4.parentNode.removeChild(_4d4);
+};
+if(_4d2){
+var _4d7=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4d7();
+_4d2(_4cf,anim);
+};
+}
+return anim;
+};
+dojo.lfx.html.implode=function(_4d8,end,_4da,_4db,_4dc){
+_4d8=dojo.byId(_4d8);
+end=dojo.byId(end);
+var _4dd=dojo.style.toCoordinateArray(_4d8,true);
+var _4de=dojo.style.toCoordinateArray(end,true);
+var _4df=document.createElement(&quot;div&quot;);
+dojo.html.copyStyle(_4df,_4d8);
+dojo.style.setOpacity(_4df,0.3);
+with(_4df.style){
+position=&quot;absolute&quot;;
+display=&quot;none&quot;;
+}
+document.body.appendChild(_4df);
+var anim=new dojo.lfx.propertyAnimation(_4df,[{property:&quot;height&quot;,start:_4dd[3],end:_4de[3]},{property:&quot;width&quot;,start:_4dd[2],end:_4de[2]},{property:&quot;top&quot;,start:_4dd[1],end:_4de[1]},{property:&quot;left&quot;,start:_4dd[0],end:_4de[0]},{property:&quot;opacity&quot;,start:1,end:0.3}],_4da,_4db);
+anim.beforeBegin=function(){
+dojo.style.hide(_4d8);
+dojo.style.show(_4df);
+};
+anim.onEnd=function(){
+_4df.parentNode.removeChild(_4df);
+};
+if(_4dc){
+var _4e1=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4e1();
+_4dc(_4d8,anim);
+};
+}
+return anim;
+};
+dojo.lfx.html.highlight=function(_4e2,_4e3,_4e4,_4e5,_4e6){
+_4e2=dojo.lfx.html._byId(_4e2);
+var _4e7=[];
+dojo.lang.forEach(_4e2,function(node){
+var _4e9=dojo.style.getBackgroundColor(node);
+var bg=dojo.style.getStyle(node,&quot;background-color&quot;).toLowerCase();
+var _4eb=dojo.style.getStyle(node,&quot;background-image&quot;);
+var _4ec=(bg==&quot;transparent&quot;||bg==&quot;rgba(0, 0, 0, 0)&quot;);
+while(_4e9.length&gt;3){
+_4e9.pop();
+}
+var rgb=new dojo.graphics.color.Color(_4e3);
+var _4ee=new dojo.graphics.color.Color(_4e9);
+var anim=dojo.lfx.propertyAnimation(node,[{property:&quot;background-color&quot;,start:rgb,end:_4ee}],_4e4,_4e5);
+var _4f0=(anim[&quot;beforeBegin&quot;])?dojo.lang.hitch(anim,&quot;beforeBegin&quot;):function(){
+};
+anim.beforeBegin=function(){
+_4f0();
+if(_4eb){
+node.style.backgroundImage=&quot;none&quot;;
+}
+node.style.backgroundColor=&quot;rgb(&quot;+rgb.toRgb().join(&quot;,&quot;)+&quot;)&quot;;
+};
+var _4f1=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4f1();
+if(_4eb){
+node.style.backgroundImage=_4eb;
+}
+if(_4ec){
+node.style.backgroundColor=&quot;transparent&quot;;
+}
+if(_4e6){
+_4e6(node,anim);
+}
+};
+_4e7.push(anim);
+});
+if(_4e2.length&gt;1){
+return dojo.lfx.combine(_4e7);
+}else{
+return _4e7[0];
+}
+};
+dojo.lfx.html.unhighlight=function(_4f2,_4f3,_4f4,_4f5,_4f6){
+_4f2=dojo.lfx.html._byId(_4f2);
+var _4f7=[];
+dojo.lang.forEach(_4f2,function(node){
+var _4f9=new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node));
+var rgb=new dojo.graphics.color.Color(_4f3);
+var _4fb=dojo.style.getStyle(node,&quot;background-image&quot;);
+var anim=dojo.lfx.propertyAnimation(node,[{property:&quot;background-color&quot;,start:_4f9,end:rgb}],_4f4,_4f5);
+var _4fd=(anim[&quot;beforeBegin&quot;])?dojo.lang.hitch(anim,&quot;beforeBegin&quot;):function(){
+};
+anim.beforeBegin=function(){
+_4fd();
+if(_4fb){
+node.style.backgroundImage=&quot;none&quot;;
+}
+node.style.backgroundColor=&quot;rgb(&quot;+_4f9.toRgb().join(&quot;,&quot;)+&quot;)&quot;;
+};
+var _4fe=(anim[&quot;onEnd&quot;])?dojo.lang.hitch(anim,&quot;onEnd&quot;):function(){
+};
+anim.onEnd=function(){
+_4fe();
+if(_4f6){
+_4f6(node,anim);
+}
+};
+_4f7.push(anim);
+});
+if(_4f2.length&gt;1){
+return dojo.lfx.combine(_4f7);
+}else{
+return _4f7[0];
+}
+};
+dojo.lang.mixin(dojo.lfx,dojo.lfx.html);
+dojo.kwCompoundRequire({browser:[&quot;dojo.lfx.html&quot;],dashboard:[&quot;dojo.lfx.html&quot;]});
+dojo.provide(&quot;dojo.lfx.*&quot;);
+

Added: trunk/root/static/magic/iframe_history.html
===================================================================
--- trunk/root/static/magic/iframe_history.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/iframe_history.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,54 @@
+&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;
+	&quot;<A HREF="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</A>&quot;&gt;
+
+&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
+&lt;head&gt;
+	&lt;title&gt;&lt;/title&gt;
+	&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;&lt;/meta&gt;
+	&lt;script type=&quot;text/javascript&quot;&gt;
+	// &lt;!--
+	var noInit = false;
+	var domain = &quot;&quot;;
+	// document.domain = &quot;localhost&quot;;
+	function init(){
+		// parse the query string if there is one to try to get args that
+		// we can act on
+		var sparams = document.location.search;
+		if(sparams.length &gt;= 0){
+			if(sparams.charAt(0) == &quot;?&quot;){
+				sparams = sparams.substring(1);
+			}
+			var ss = (sparams.indexOf(&quot;&amp;&quot;) &gt;= 0) ? &quot;&amp;&quot; : &quot;&amp;&quot;;
+			sparams = sparams.split(ss);
+			for(var x=0; x&lt;sparams.length; x++){
+				var tp = sparams[x].split(&quot;=&quot;);
+				if(typeof window[tp[0]] != &quot;undefined&quot;){
+					window[tp[0]] = ((tp[1]==&quot;true&quot;)||(tp[1]==&quot;false&quot;)) ? eval(tp[1]) : tp[1];
+				}
+			}
+		}
+
+		if(noInit){ return; }
+		if(domain.length &gt; 0){
+			document.domain = domain;
+		}
+		if((window.parent != window)&amp;&amp;(window.parent[&quot;dojo&quot;])){
+			//Set the page title so IE history shows up with a somewhat correct name.
+			document.title = window.parent.document.title;
+			
+			//Notify parent that we are loaded.
+			var pdj = window.parent.dojo;
+			if(pdj[&quot;undo&quot;] &amp;&amp; pdj[&quot;undo&quot;][&quot;browser&quot;]){
+				pdj.undo.browser.iframeLoaded(null, window.location);
+			}
+		}
+	}
+	// --&gt;
+	&lt;/script&gt;
+&lt;/head&gt;
+&lt;body onload=&quot;try{ init(); }catch(e){ alert(e); }&quot;&gt;
+	&lt;h4&gt;The Dojo Toolkit -- iframe_history.html&lt;/h4&gt;
+
+	&lt;p&gt;This file is used in Dojo's back/fwd button management.&lt;/p&gt;
+&lt;/body&gt;
+&lt;/html&gt;

Added: trunk/root/static/magic/src/AdapterRegistry.js
===================================================================
--- trunk/root/static/magic/src/AdapterRegistry.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/AdapterRegistry.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,72 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.AdapterRegistry&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+
+dojo.AdapterRegistry = function(){
+    /***
+        A registry to facilitate adaptation.
+
+        Pairs is an array of [name, check, wrap] triples
+        
+        All check/wrap functions in this registry should be of the same arity.
+    ***/
+    this.pairs = [];
+}
+
+dojo.lang.extend(dojo.AdapterRegistry, {
+    register: function (name, check, wrap, /* optional */ override){
+        /***
+			The check function should return true if the given arguments are
+			appropriate for the wrap function.
+
+			If override is given and true, the check function will be given
+			highest priority.  Otherwise, it will be the lowest priority
+			adapter.
+        ***/
+
+        if (override) {
+            this.pairs.unshift([name, check, wrap]);
+        } else {
+            this.pairs.push([name, check, wrap]);
+        }
+    },
+
+    match: function (/* ... */) {
+        /***
+			Find an adapter for the given arguments.
+
+			If no suitable adapter is found, throws NotFound.
+        ***/
+        for(var i = 0; i &lt; this.pairs.length; i++){
+            var pair = this.pairs[i];
+            if(pair[1].apply(this, arguments)){
+                return pair[2].apply(this, arguments);
+            }
+        }
+		throw new Error(&quot;No match found&quot;);
+        // dojo.raise(&quot;No match found&quot;);
+    },
+
+    unregister: function (name) {
+        /***
+			Remove a named adapter from the registry
+        ***/
+        for(var i = 0; i &lt; this.pairs.length; i++){
+            var pair = this.pairs[i];
+            if(pair[0] == name){
+                this.pairs.splice(i, 1);
+                return true;
+            }
+        }
+        return false;
+    }
+});

Added: trunk/root/static/magic/src/Deferred.js
===================================================================
--- trunk/root/static/magic/src/Deferred.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/Deferred.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,309 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.Deferred&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+
+dojo.Deferred = function(/* optional */ canceller){
+	/*
+	NOTE: this namespace and documentation are imported wholesale 
+		from MochiKit
+
+	Encapsulates a sequence of callbacks in response to a value that
+	may not yet be available.  This is modeled after the Deferred class
+	from Twisted &lt;<A HREF="http://twistedmatrix.com">http://twistedmatrix.com</A>&gt;.
+
+	Why do we want this?  JavaScript has no threads, and even if it did,
+	threads are hard.  Deferreds are a way of abstracting non-blocking
+	events, such as the final response to an XMLHttpRequest.
+
+	The sequence of callbacks is internally represented as a list
+	of 2-tuples containing the callback/errback pair.  For example,
+	the following call sequence::
+
+		var d = new Deferred();
+		d.addCallback(myCallback);
+		d.addErrback(myErrback);
+		d.addBoth(myBoth);
+		d.addCallbacks(myCallback, myErrback);
+
+	is translated into a Deferred with the following internal
+	representation::
+
+		[
+			[myCallback, null],
+			[null, myErrback],
+			[myBoth, myBoth],
+			[myCallback, myErrback]
+		]
+
+	The Deferred also keeps track of its current status (fired).
+	Its status may be one of three things:
+
+		-1: no value yet (initial condition)
+		0: success
+		1: error
+
+	A Deferred will be in the error state if one of the following
+	three conditions are met:
+
+		1. The result given to callback or errback is &quot;instanceof&quot; Error
+		2. The previous callback or errback raised an exception while
+		   executing
+		3. The previous callback or errback returned a value &quot;instanceof&quot;
+			Error
+
+	Otherwise, the Deferred will be in the success state.  The state of
+	the Deferred determines the next element in the callback sequence to
+	run.
+
+	When a callback or errback occurs with the example deferred chain,
+	something equivalent to the following will happen (imagine that
+	exceptions are caught and returned)::
+
+		// d.callback(result) or d.errback(result)
+		if(!(result instanceof Error)){
+			result = myCallback(result);
+		}
+		if(result instanceof Error){
+			result = myErrback(result);
+		}
+		result = myBoth(result);
+		if(result instanceof Error){
+			result = myErrback(result);
+		}else{
+			result = myCallback(result);
+		}
+
+	The result is then stored away in case another step is added to the
+	callback sequence.	Since the Deferred already has a value available,
+	any new callbacks added will be called immediately.
+
+	There are two other &quot;advanced&quot; details about this implementation that
+	are useful:
+
+	Callbacks are allowed to return Deferred instances themselves, so you
+	can build complicated sequences of events with ease.
+
+	The creator of the Deferred may specify a canceller.  The canceller
+	is a function that will be called if Deferred.cancel is called before
+	the Deferred fires.	 You can use this to implement clean aborting of
+	an XMLHttpRequest, etc.	 Note that cancel will fire the deferred with
+	a CancelledError (unless your canceller returns another kind of
+	error), so the errbacks should be prepared to handle that error for
+	cancellable Deferreds.
+
+	*/
+	
+	this.chain = [];
+	this.id = this._nextId();
+	this.fired = -1;
+	this.paused = 0;
+	this.results = [null, null];
+	this.canceller = canceller;
+	this.silentlyCancelled = false;
+};
+
+dojo.lang.extend(dojo.Deferred, {
+	getFunctionFromArgs: function(){
+		var a = arguments;
+		if((a[0])&amp;&amp;(!a[1])){
+			if(dojo.lang.isFunction(a[0])){
+				return a[0];
+			}else if(dojo.lang.isString(a[0])){
+				return dj_global[a[0]];
+			}
+		}else if((a[0])&amp;&amp;(a[1])){
+			return dojo.lang.hitch(a[0], a[1]);
+		}
+		return null;
+	},
+
+	repr: function(){
+		var state;
+		if(this.fired == -1){
+			state = 'unfired';
+		}else if(this.fired == 0){
+			state = 'success';
+		} else {
+			state = 'error';
+		}
+		return 'Deferred(' + this.id + ', ' + state + ')';
+	},
+
+	toString: dojo.lang.forward(&quot;repr&quot;),
+
+	_nextId: (function(){
+		var n = 1;
+		return function(){ return n++; };
+	})(),
+
+	cancel: function(){
+		/***
+		Cancels a Deferred that has not yet received a value, or is
+		waiting on another Deferred as its value.
+
+		If a canceller is defined, the canceller is called. If the
+		canceller did not return an error, or there was no canceller,
+		then the errback chain is started with CancelledError.
+		***/
+		if(this.fired == -1){
+			if (this.canceller){
+				this.canceller(this);
+			}else{
+				this.silentlyCancelled = true;
+			}
+			if(this.fired == -1){
+				this.errback(new Error(this.repr()));
+			}
+		}else if(	(this.fired == 0)&amp;&amp;
+					(this.results[0] instanceof dojo.Deferred)){
+			this.results[0].cancel();
+		}
+	},
+			
+
+	_pause: function(){
+		// Used internally to signal that it's waiting on another Deferred
+		this.paused++;
+	},
+
+	_unpause: function(){
+		// Used internally to signal that it's no longer waiting on
+		// another Deferred.
+		this.paused--;
+		if ((this.paused == 0) &amp;&amp; (this.fired &gt;= 0)) {
+			this._fire();
+		}
+	},
+
+	_continue: function(res){
+		// Used internally when a dependent deferred fires.
+		this._resback(res);
+		this._unpause();
+	},
+
+	_resback: function(res){
+		// The primitive that means either callback or errback
+		this.fired = ((res instanceof Error) ? 1 : 0);
+		this.results[this.fired] = res;
+		this._fire();
+	},
+
+	_check: function(){
+		if(this.fired != -1){
+			if(!this.silentlyCancelled){
+				dojo.raise(&quot;already called!&quot;);
+			}
+			this.silentlyCancelled = false;
+			return;
+		}
+	},
+
+	callback: function(res){
+		/*
+		Begin the callback sequence with a non-error value.
+		
+		callback or errback should only be called once on a given
+		Deferred.
+		*/
+		this._check();
+		this._resback(res);
+	},
+
+	errback: function(res){
+		// Begin the callback sequence with an error result.
+		this._check();
+		if(!(res instanceof Error)){
+			res = new Error(res);
+		}
+		this._resback(res);
+	},
+
+	addBoth: function(cb, cbfn){
+		/*
+		Add the same function as both a callback and an errback as the
+		next element on the callback sequence.	This is useful for code
+		that you want to guarantee to run, e.g. a finalizer.
+		*/
+		var enclosed = this.getFunctionFromArgs(cb, cbfn);
+		if(arguments.length &gt; 2){
+			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
+		}
+		return this.addCallbacks(enclosed, enclosed);
+	},
+
+	addCallback: function(cb, cbfn){
+		// Add a single callback to the end of the callback sequence.
+		var enclosed = this.getFunctionFromArgs(cb, cbfn);
+		if(arguments.length &gt; 2){
+			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
+		}
+		return this.addCallbacks(enclosed, null);
+	},
+
+	addErrback: function(cb, cbfn){
+		// Add a single callback to the end of the callback sequence.
+		var enclosed = this.getFunctionFromArgs(cb, cbfn);
+		if(arguments.length &gt; 2){
+			enclosed = dojo.lang.curryArguments(null, enclosed, arguments, 2);
+		}
+		return this.addCallbacks(null, enclosed);
+		return this.addCallbacks(null, cbfn);
+	},
+
+	addCallbacks: function (cb, eb) {
+		// Add separate callback and errback to the end of the callback
+		// sequence.
+		this.chain.push([cb, eb])
+		if (this.fired &gt;= 0) {
+			this._fire();
+		}
+		return this;
+	},
+
+	_fire: function(){
+		// Used internally to exhaust the callback sequence when a result
+		// is available.
+		var chain = this.chain;
+		var fired = this.fired;
+		var res = this.results[fired];
+		var self = this;
+		var cb = null;
+		while (chain.length &gt; 0 &amp;&amp; this.paused == 0) {
+			// Array
+			var pair = chain.shift();
+			var f = pair[fired];
+			if (f == null) {
+				continue;
+			}
+			try {
+				res = f(res);
+				fired = ((res instanceof Error) ? 1 : 0);
+				if(res instanceof dojo.Deferred) {
+					cb = function(res){
+						self._continue(res);
+					}
+					this._pause();
+				}
+			}catch(err){
+				fired = 1;
+				res = err;
+			}
+		}
+		this.fired = fired;
+		this.results[fired] = res;
+		if((cb)&amp;&amp;(this.paused)){
+			// this is for &quot;tail recursion&quot; in case the dependent
+			// deferred is already fired
+			res.addBoth(cb);
+		}
+	}
+});

Added: trunk/root/static/magic/src/animation/Animation.js
===================================================================
--- trunk/root/static/magic/src/animation/Animation.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/animation/Animation.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,217 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.animation.Animation&quot;);
+dojo.require(&quot;dojo.animation.AnimationEvent&quot;);
+
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.math&quot;);
+dojo.require(&quot;dojo.math.curves&quot;);
+
+/*
+Animation package based off of Dan Pupius' work on Animations:
+<A HREF="http://pupius.co.uk/js/Toolkit.Drawing.js">http://pupius.co.uk/js/Toolkit.Drawing.js</A>
+*/
+
+dojo.animation.Animation = function(/*dojo.math.curves.Line*/ curve, /*int*/ duration, /*Decimal?*/ accel, /*int?*/ repeatCount, /*int?*/ rate) {
+	// public properties
+	if(dojo.lang.isArray(curve)) {
+		// curve: Array
+		// id: i
+		curve = new dojo.math.curves.Line(curve[0], curve[1]);
+	}
+	this.curve = curve;
+	this.duration = duration;
+	this.repeatCount = repeatCount || 0;
+	this.rate = rate || 25;
+	if(accel) {
+		// accel: Decimal
+		// id: j
+		if(dojo.lang.isFunction(accel.getValue)) {
+			// accel: dojo.math.curves.CatmullRom
+			// id: k
+			this.accel = accel;
+		} else {
+			var i = 0.35*accel+0.5;	// 0.15 &lt;= i &lt;= 0.85
+			this.accel = new dojo.math.curves.CatmullRom([[0], [i], [1]], 0.45);
+		}
+	}
+}
+
+dojo.lang.extend(dojo.animation.Animation, {
+	// public properties
+	curve: null,
+	duration: 0,
+	repeatCount: 0,
+	accel: null,
+
+	// events
+	onBegin: null,
+	onAnimate: null,
+	onEnd: null,
+	onPlay: null,
+	onPause: null,
+	onStop: null,
+	handler: null,
+
+	// &quot;private&quot; properties
+	_animSequence: null,
+	_startTime: null,
+	_endTime: null,
+	_lastFrame: null,
+	_timer: null,
+	_percent: 0,
+	_active: false,
+	_paused: false,
+	_startRepeatCount: 0,
+
+	// public methods
+	play: function(gotoStart) {
+		if( gotoStart ) {
+			clearTimeout(this._timer);
+			this._active = false;
+			this._paused = false;
+			this._percent = 0;
+		} else if( this._active &amp;&amp; !this._paused ) {
+			return;
+		}
+
+		this._startTime = new Date().valueOf();
+		if( this._paused ) {
+			this._startTime -= (this.duration * this._percent / 100);
+		}
+		this._endTime = this._startTime + this.duration;
+		this._lastFrame = this._startTime;
+
+		var e = new dojo.animation.AnimationEvent(this, null, this.curve.getValue(this._percent),
+			this._startTime, this._startTime, this._endTime, this.duration, this._percent, 0);
+
+		this._active = true;
+		this._paused = false;
+
+		if( this._percent == 0 ) {
+			if(!this._startRepeatCount) {
+				this._startRepeatCount = this.repeatCount;
+			}
+			e.type = &quot;begin&quot;;
+			if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+			if(typeof this.onBegin == &quot;function&quot;) { this.onBegin(e); }
+		}
+
+		e.type = &quot;play&quot;;
+		if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+		if(typeof this.onPlay == &quot;function&quot;) { this.onPlay(e); }
+
+		if(this._animSequence) { this._animSequence._setCurrent(this); }
+
+		this._cycle();
+	},
+
+	pause: function() {
+		clearTimeout(this._timer);
+		if( !this._active ) { return; }
+		this._paused = true;
+		var e = new dojo.animation.AnimationEvent(this, &quot;pause&quot;, this.curve.getValue(this._percent),
+			this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent, 0);
+		if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+		if(typeof this.onPause == &quot;function&quot;) { this.onPause(e); }
+	},
+
+	playPause: function() {
+		if( !this._active || this._paused ) {
+			this.play();
+		} else {
+			this.pause();
+		}
+	},
+
+	gotoPercent: function(pct, andPlay) {
+		clearTimeout(this._timer);
+		this._active = true;
+		this._paused = true;
+		this._percent = pct;
+		if( andPlay ) { this.play(); }
+	},
+
+	stop: function(gotoEnd) {
+		clearTimeout(this._timer);
+		var step = this._percent / 100;
+		if( gotoEnd ) {
+			step = 1;
+		}
+		var e = new dojo.animation.AnimationEvent(this, &quot;stop&quot;, this.curve.getValue(step),
+			this._startTime, new Date().valueOf(), this._endTime, this.duration, this._percent);
+		if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+		if(typeof this.onStop == &quot;function&quot;) { this.onStop(e); }
+		this._active = false;
+		this._paused = false;
+	},
+
+	status: function() {
+		if( this._active ) {
+			return this._paused ? &quot;paused&quot; : &quot;playing&quot;;
+		} else {
+			return &quot;stopped&quot;;
+		}
+	},
+
+	// &quot;private&quot; methods
+	_cycle: function() {
+		clearTimeout(this._timer);
+		if( this._active ) {
+			var curr = new Date().valueOf();
+			var step = (curr - this._startTime) / (this._endTime - this._startTime);
+			var fps = 1000 / (curr - this._lastFrame);
+			this._lastFrame = curr;
+
+			if( step &gt;= 1 ) {
+				step = 1;
+				this._percent = 100;
+			} else {
+				this._percent = step * 100;
+			}
+			
+			// Perform accelleration
+			if(this.accel &amp;&amp; this.accel.getValue) {
+				step = this.accel.getValue(step);
+			}
+
+			var e = new dojo.animation.AnimationEvent(this, &quot;animate&quot;, this.curve.getValue(step),
+				this._startTime, curr, this._endTime, this.duration, this._percent, Math.round(fps));
+
+			if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+			if(typeof this.onAnimate == &quot;function&quot;) { this.onAnimate(e); }
+
+			if( step &lt; 1 ) {
+				this._timer = setTimeout(dojo.lang.hitch(this, &quot;_cycle&quot;), this.rate);
+			} else {
+				e.type = &quot;end&quot;;
+				this._active = false;
+				if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+				if(typeof this.onEnd == &quot;function&quot;) { this.onEnd(e); }
+
+				if( this.repeatCount &gt; 0 ) {
+					this.repeatCount--;
+					this.play(true);
+				} else if( this.repeatCount == -1 ) {
+					this.play(true);
+				} else {
+					if(this._startRepeatCount) {
+						this.repeatCount = this._startRepeatCount;
+						this._startRepeatCount = 0;
+					}
+					if( this._animSequence ) {
+						this._animSequence._playNext();
+					}
+				}
+			}
+		}
+	}
+});

Added: trunk/root/static/magic/src/animation/AnimationEvent.js
===================================================================
--- trunk/root/static/magic/src/animation/AnimationEvent.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/animation/AnimationEvent.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,40 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.animation.AnimationEvent&quot;);
+
+dojo.require(&quot;dojo.lang&quot;);
+
+dojo.animation.AnimationEvent = function(anim, type, coords, sTime, cTime, eTime, dur, pct, fps) {
+	this.type = type; // &quot;animate&quot;, &quot;begin&quot;, &quot;end&quot;, &quot;play&quot;, &quot;pause&quot;, &quot;stop&quot;
+	this.animation = anim;
+
+	this.coords = coords;
+	this.x = coords[0];
+	this.y = coords[1];
+	this.z = coords[2];
+
+	this.startTime = sTime;
+	this.currentTime = cTime;
+	this.endTime = eTime;
+
+	this.duration = dur;
+	this.percent = pct;
+	this.fps = fps;
+};
+dojo.lang.extend(dojo.animation.AnimationEvent, {
+	coordsAsInts: function() {
+		var cints = new Array(this.coords.length);
+		for(var i = 0; i &lt; this.coords.length; i++) {
+			cints[i] = Math.round(this.coords[i]);
+		}
+		return cints;
+	}
+});

Added: trunk/root/static/magic/src/animation/AnimationSequence.js
===================================================================
--- trunk/root/static/magic/src/animation/AnimationSequence.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/animation/AnimationSequence.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,136 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.animation.AnimationSequence&quot;);
+dojo.require(&quot;dojo.animation.AnimationEvent&quot;);
+dojo.require(&quot;dojo.animation.Animation&quot;);
+
+dojo.animation.AnimationSequence = function(repeatCount){
+	this._anims = [];
+	this.repeatCount = repeatCount || 0;
+}
+
+dojo.lang.extend(dojo.animation.AnimationSequence, {
+	repeateCount: 0,
+
+	_anims: [],
+	_currAnim: -1,
+
+	onBegin: null,
+	onEnd: null,
+	onNext: null,
+	handler: null,
+
+	add: function() {
+		for(var i = 0; i &lt; arguments.length; i++) {
+			this._anims.push(arguments[i]);
+			arguments[i]._animSequence = this;
+		}
+	},
+
+	remove: function(anim) {
+		for(var i = 0; i &lt; this._anims.length; i++) {
+			if( this._anims[i] == anim ) {
+				this._anims[i]._animSequence = null;
+				this._anims.splice(i, 1);
+				break;
+			}
+		}
+	},
+
+	removeAll: function() {
+		for(var i = 0; i &lt; this._anims.length; i++) {
+			this._anims[i]._animSequence = null;
+		}
+		this._anims = [];
+		this._currAnim = -1;
+	},
+
+	clear: function() {
+		this.removeAll();
+	},
+
+	play: function(gotoStart) {
+		if( this._anims.length == 0 ) { return; }
+		if( gotoStart || !this._anims[this._currAnim] ) {
+			this._currAnim = 0;
+		}
+		if( this._anims[this._currAnim] ) {
+			if( this._currAnim == 0 ) {
+				var e = {type: &quot;begin&quot;, animation: this._anims[this._currAnim]};
+				if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+				if(typeof this.onBegin == &quot;function&quot;) { this.onBegin(e); }
+			}
+			this._anims[this._currAnim].play(gotoStart);
+		}
+	},
+
+	pause: function() {
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].pause();
+		}
+	},
+
+	playPause: function() {
+		if( this._anims.length == 0 ) { return; }
+		if( this._currAnim == -1 ) { this._currAnim = 0; }
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].playPause();
+		}
+	},
+
+	stop: function() {
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].stop();
+		}
+	},
+
+	status: function() {
+		if( this._anims[this._currAnim] ) {
+			return this._anims[this._currAnim].status();
+		} else {
+			return &quot;stopped&quot;;
+		}
+	},
+
+	_setCurrent: function(anim) {
+		for(var i = 0; i &lt; this._anims.length; i++) {
+			if( this._anims[i] == anim ) {
+				this._currAnim = i;
+				break;
+			}
+		}
+	},
+
+	_playNext: function() {
+		if( this._currAnim == -1 || this._anims.length == 0 ) { return; }
+		this._currAnim++;
+		if( this._anims[this._currAnim] ) {
+			var e = {type: &quot;next&quot;, animation: this._anims[this._currAnim]};
+			if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+			if(typeof this.onNext == &quot;function&quot;) { this.onNext(e); }
+			this._anims[this._currAnim].play(true);
+		} else {
+			var e = {type: &quot;end&quot;, animation: this._anims[this._anims.length-1]};
+			if(typeof this.handler == &quot;function&quot;) { this.handler(e); }
+			if(typeof this.onEnd == &quot;function&quot;) { this.onEnd(e); }
+			if(this.repeatCount &gt; 0) {
+				this._currAnim = 0;
+				this.repeatCount--;
+				this._anims[this._currAnim].play(true);
+			} else if(this.repeatCount == -1) {
+				this._currAnim = 0;
+				this._anims[this._currAnim].play(true);
+			} else {
+				this._currAnim = -1;
+			}
+		}
+	}
+});

Added: trunk/root/static/magic/src/animation/Timer.js
===================================================================
--- trunk/root/static/magic/src/animation/Timer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/animation/Timer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,39 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.animation.Timer&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+
+dojo.animation.Timer = function(intvl){
+	var timer = null;
+	this.isRunning = false;
+	this.interval = intvl;
+
+	this.onTick = function(){};
+	this.onStart = null;
+	this.onStop = null;
+
+	this.setInterval = function(ms){
+		if (this.isRunning) window.clearInterval(timer);
+		this.interval = ms;
+		if (this.isRunning) timer = window.setInterval(dojo.lang.hitch(this, &quot;onTick&quot;), this.interval);
+	};
+
+	this.start = function(){
+		if (typeof this.onStart == &quot;function&quot;) this.onStart();
+		this.isRunning = true;
+		timer = window.setInterval(this.onTick, this.interval);
+	};
+	this.stop = function(){
+		if (typeof this.onStop == &quot;function&quot;) this.onStop();
+		this.isRunning = false;
+		window.clearInterval(timer);
+	};
+};

Added: trunk/root/static/magic/src/animation/__package__.js
===================================================================
--- trunk/root/static/magic/src/animation/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/animation/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,18 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.animation.AnimationEvent&quot;,
+		&quot;dojo.animation.Animation&quot;,
+		&quot;dojo.animation.AnimationSequence&quot;
+	]
+});
+dojo.provide(&quot;dojo.animation.*&quot;);

Added: trunk/root/static/magic/src/animation.js
===================================================================
--- trunk/root/static/magic/src/animation.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/animation.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.animation&quot;);
+dojo.require(&quot;dojo.animation.Animation&quot;);

Added: trunk/root/static/magic/src/behavior.js
===================================================================
--- trunk/root/static/magic/src/behavior.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/behavior.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,248 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.behavior&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+dojo.require(&quot;dojo.experimental&quot;);
+dojo.experimental(&quot;dojo.behavior&quot;);
+
+dojo.behavior = new function(){
+	function arrIn(obj, name){
+		if(!obj[name]){ obj[name] = []; }
+		return obj[name];
+	}
+
+	function forIn(obj, scope, func){
+		var tmpObj = {};
+		for(var x in obj){
+			if(typeof tmpObj[x] == &quot;undefined&quot;){
+				if(!func){
+					scope(obj[x], x);
+				}else{
+					func.call(scope, obj[x], x);
+				}
+			}
+		}
+	}
+
+	// FIXME: need a better test so we don't exclude nightly Safari's!
+	this.behaviors = {};
+	this.add = function(behaviorObj){
+		/*	behavior objects are specified in the following format:
+		 *
+		 *	{ 
+		 *	 	&quot;#id&quot;: {
+		 *			&quot;found&quot;: function(element){
+		 *				// ...
+		 *			},
+		 *
+		 *			&quot;onblah&quot;: {targetObj: foo, targetFunc: &quot;bar&quot;},
+		 *
+		 *			&quot;onblarg&quot;: &quot;/foo/bar/baz/blarg&quot;,
+		 *
+		 *			&quot;onevent&quot;: function(evt){
+		 *			},
+		 *
+		 *			&quot;onotherevent: function(evt){
+		 *				// ...
+		 *			}
+		 *		},
+		 *
+		 *		&quot;#id2&quot;: {
+		 *			// ...
+		 *		},
+		 *
+		 *		&quot;#id3&quot;: function(element){
+		 *			// ...
+		 *		},
+		 *
+		 *		// publish the match on a topic
+		 *		&quot;#id4&quot;: &quot;/found/topic/name&quot;,
+		 *
+		 *		// match all direct descendants
+		 *		&quot;#id4 &gt; *&quot;: function(element){
+		 *			// ...
+		 *		},
+		 *
+		 *		// match the first child node that's an element
+		 *		&quot;#id4 &gt; @firstElement&quot;: { ... },
+		 *
+		 *		// match the last child node that's an element
+		 *		&quot;#id4 &gt; @lastElement&quot;:  { ... },
+		 *
+		 *		// all elements of type tagname
+		 *		&quot;tagname&quot;: {
+		 *			// ...
+		 *		},
+		 *
+		 *		// maps to roughly:
+		 *		//	dojo.lang.forEach(body.getElementsByTagName(&quot;tagname1&quot;), function(node){
+		 *		//		dojo.lang.forEach(node.getElementsByTagName(&quot;tagname2&quot;), function(node2){
+		 *		//			dojo.lang.forEach(node2.getElementsByTagName(&quot;tagname3&quot;, function(node3){
+		 *		//				// apply rules
+		 *		//			});
+		 *		//		});
+		 *		//	});
+		 *		&quot;tagname1 tagname2 tagname3&quot;: {
+		 *			// ...
+		 *		},
+		 *
+		 *		&quot;.classname&quot;: {
+		 *			// ...
+		 *		},
+		 *
+		 *		&quot;tagname.classname&quot;: {
+		 *			// ...
+		 *		},
+		 *	}
+		 *
+		 *	The &quot;found&quot; method is a generalized handler that's called as soon
+		 *	as the node matches the selector. Rules for values that follow also
+		 *	apply to the &quot;found&quot; key.
+		 *	
+		 *	The &quot;on*&quot; handlers are attached with dojo.event.connect(). If the
+		 *	value is not a function but is rather an object, it's assumed to be
+		 *	the &quot;other half&quot; of a dojo.event.kwConnect() argument object. It
+		 *	may contain any/all properties of such a connection modifier save
+		 *	for the sourceObj and sourceFunc properties which are filled in by
+		 *	the system automatically. If a string is instead encountered, the
+		 *	node publishes the specified event on the topic contained in the
+		 *	string value.
+		 *
+		 *	If the value corresponding to the ID key is a function and not a
+		 *	list, it's treated as though it was the value of &quot;found&quot;.
+		 *
+		 */
+
+		var tmpObj = {};
+		forIn(behaviorObj, this, function(behavior, name){
+			var tBehavior = arrIn(this.behaviors, name);
+			if((dojo.lang.isString(behavior))||(dojo.lang.isFunction(behavior))){
+				behavior = { found: behavior };
+			}
+			forIn(behavior, function(rule, ruleName){
+				arrIn(tBehavior, ruleName).push(rule);
+			});
+		});
+	}
+
+	this.apply = function(){
+		dojo.profile.start(&quot;dojo.behavior.apply&quot;);
+		var r = dojo.render.html;
+		// note, we apply one way for fast queries and one way for slow
+		// iteration. So be it.
+		var safariGoodEnough = (!r.safari);
+		if(r.safari){
+			// Anything over release #420 should work the fast way
+			var uas = r.UA.split(&quot;AppleWebKit/&quot;)[1];
+			if(parseInt(uas.match(/[0-9.]{3,}/)) &gt;= 420){
+				safariGoodEnough = true;
+			}
+		}
+		if((dj_undef(&quot;behaviorFastParse&quot;, djConfig) ? (safariGoodEnough) : djConfig[&quot;behaviorFastParse&quot;])){
+			this.applyFast();
+		}else{
+			this.applySlow();
+		}
+		dojo.profile.end(&quot;dojo.behavior.apply&quot;);
+	}
+
+	this.matchCache = {};
+
+	this.elementsById = function(id, handleRemoved){
+		var removed = [];
+		var added = [];
+		arrIn(this.matchCache, id);
+		if(handleRemoved){
+			var nodes = this.matchCache[id];
+			for(var x=0; x&lt;nodes.length; x++){
+				if(nodes[x].id != &quot;&quot;){
+					removed.push(nodes[x]);
+					nodes.splice(x, 1);
+					x--;
+				}
+			}
+		}
+		var tElem = dojo.byId(id);
+		while(tElem){
+			if(!tElem[&quot;idcached&quot;]){
+				added.push(tElem);
+			}
+			tElem.id = &quot;&quot;;
+			tElem = dojo.byId(id);
+		}
+		this.matchCache[id] = this.matchCache[id].concat(added);
+		dojo.lang.forEach(this.matchCache[id], function(node){
+			node.id = id;
+			node.idcached = true;
+		});
+		return { &quot;removed&quot;: removed, &quot;added&quot;: added, &quot;match&quot;: this.matchCache[id] };
+	}
+
+	this.applyToNode = function(node, action, ruleSetName){
+		if(typeof action == &quot;string&quot;){
+			dojo.event.topic.registerPublisher(action, node, ruleSetName);
+		}else if(typeof action == &quot;function&quot;){
+			if(ruleSetName == &quot;found&quot;){
+				action(node);
+			}else{
+				dojo.event.connect(node, ruleSetName, action);
+			}
+		}else{
+			action.srcObj = node;
+			action.srcFunc = ruleSetName;
+			dojo.event.kwConnect(action);
+		}
+	}
+
+	this.applyFast = function(){
+		dojo.profile.start(&quot;dojo.behavior.applyFast&quot;);
+		// fast DOM queries...wheeee!
+		forIn(this.behaviors, function(tBehavior, id){
+			var elems = dojo.behavior.elementsById(id);
+			dojo.lang.forEach(elems.added, 
+				function(elem){
+					forIn(tBehavior, function(ruleSet, ruleSetName){
+						if(dojo.lang.isArray(ruleSet)){
+							dojo.lang.forEach(ruleSet, function(action){
+								dojo.behavior.applyToNode(elem, action, ruleSetName);
+							});
+						}
+					});
+				}
+			);
+		});
+		dojo.profile.end(&quot;dojo.behavior.applyFast&quot;);
+	}
+	
+	this.applySlow = function(){
+		// iterate. Ugg.
+		dojo.profile.start(&quot;dojo.behavior.applySlow&quot;);
+		var all = document.getElementsByTagName(&quot;*&quot;);
+		var allLen = all.length;
+		for(var x=0; x&lt;allLen; x++){
+			var elem = all[x];
+			if((elem.id)&amp;&amp;(!elem[&quot;behaviorAdded&quot;])&amp;&amp;(this.behaviors[elem.id])){
+				elem[&quot;behaviorAdded&quot;] = true;
+				forIn(this.behaviors[elem.id], function(ruleSet, ruleSetName){
+					if(dojo.lang.isArray(ruleSet)){
+						dojo.lang.forEach(ruleSet, function(action){
+							dojo.behavior.applyToNode(elem, action, ruleSetName);
+						});
+					}
+				});
+			}
+		}
+		dojo.profile.end(&quot;dojo.behavior.applySlow&quot;);
+	}
+}
+
+dojo.addOnLoad(dojo.behavior, &quot;apply&quot;);

Added: trunk/root/static/magic/src/bootstrap1.js
===================================================================
--- trunk/root/static/magic/src/bootstrap1.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/bootstrap1.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,339 @@
+/**
+* @file bootstrap1.js
+*
+* summary: First file that is loaded that 'bootstraps' the entire dojo library suite.
+* note:  Must run before hostenv_*.js file.
+*
+* @author  Copyright 2004 Mark D. Anderson (<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">mda at discerning.com</A>)
+* TODOC: should the copyright be changed to Dojo Foundation?
+* @license Licensed under the Academic Free License 2.1 <A HREF="http://www.opensource.org/licenses/afl-2.1.php">http://www.opensource.org/licenses/afl-2.1.php</A>
+*
+* $Id: bootstrap1.js 4342 2006-06-11 23:03:30Z alex $
+*/
+
+// TODOC: HOW TO DOC THE BELOW?
+// @global: djConfig
+// summary:  
+//		Application code can set the global 'djConfig' prior to loading
+//		the library to override certain global settings for how dojo works.  
+// description:  The variables that can be set are as follows:
+//			- isDebug: false
+//			- allowQueryConfig: false
+//			- baseScriptUri: &quot;&quot;
+//			- baseRelativePath: &quot;&quot;
+//			- libraryScriptUri: &quot;&quot;
+//			- iePreventClobber: false
+//			- ieClobberMinimal: true
+//			- preventBackButtonFix: true
+//			- searchIds: []
+//			- parseWidgets: true
+// TODOC: HOW TO DOC THESE VARIABLES?
+// TODOC: IS THIS A COMPLETE LIST?
+// note:
+//		'djConfig' does not exist under 'dojo.*' so that it can be set before the 
+//		'dojo' variable exists.  
+// note:
+//		Setting any of these variables *after* the library has loaded does nothing at all. 
+// TODOC: is this still true?  Release notes for 0.3 indicated they could be set after load.
+//
+
+
+
+//TODOC:  HOW TO DOC THIS?
+// @global: dj_global
+// summary: 
+//		an alias for the top-level global object in the host environment
+//		(e.g., the window object in a browser).
+// description:  
+//		Refer to 'dj_global' rather than referring to window to ensure your
+//		code runs correctly in contexts other than web browsers (eg: Rhino on a server).
+var dj_global = this;
+
+
+
+function dj_undef(/*String*/ name, /*Object?*/ object){
+	//summary: Returns true if 'name' is defined on 'object' (or globally if 'object' is null).
+	//description: Note that 'defined' and 'exists' are not the same concept.
+	if(object==null){ object = dj_global; }
+	// exception if object is not an Object
+	return (typeof object[name] == &quot;undefined&quot;);	// Boolean
+}
+
+
+// make sure djConfig is defined
+if(dj_undef(&quot;djConfig&quot;)){ 
+	var djConfig = {}; 
+}
+
+
+//TODOC:  HOW TO DOC THIS?
+// dojo is the root variable of (almost all) our public symbols -- make sure it is defined.
+if(dj_undef(&quot;dojo&quot;)){ 
+	var dojo = {}; 
+}
+
+//TODOC:  HOW TO DOC THIS?
+dojo.version = {
+	// summary: version number of this instance of dojo.
+	major: 0, minor: 3, patch: 1, flag: &quot;&quot;,
+	revision: Number(&quot;$Rev: 4342 $&quot;.match(/[0-9]+/)[0]),
+	toString: function(){
+		with(dojo.version){
+			return major + &quot;.&quot; + minor + &quot;.&quot; + patch + flag + &quot; (&quot; + revision + &quot;)&quot;;	// String
+		}
+	}
+}
+
+dojo.evalProp = function(/*String*/ name, /*Object*/ object, /*Boolean?*/ create){
+	// summary: Returns 'object[name]'.  If not defined and 'create' is true, will return a new Object.
+	// description: 
+	//		Returns null if 'object[name]' is not defined and 'create' is not true.
+	// 		Note: 'defined' and 'exists' are not the same concept.	
+	return (object &amp;&amp; !dj_undef(name, object) ? object[name] : (create ? (object[name]={}) : undefined));	// mixed
+}
+
+
+dojo.parseObjPath = function(/*String*/ path, /*Object?*/ context, /*Boolean?*/ create){
+	// summary: Parse string path to an object, and return corresponding object reference and property name.
+	// description: 
+	//		Returns an object with two properties, 'obj' and 'prop'.  
+	//		'obj[prop]' is the reference indicated by 'path'.
+	// path: Path to an object, in the form &quot;A.B.C&quot;.
+	// context: Object to use as root of path.  Defaults to 'dj_global'.
+	// create: If true, Objects will be created at any point along the 'path' that is undefined.
+	var object = (context != null ? context : dj_global);
+	var names = path.split('.');
+	var prop = names.pop();
+	for (var i=0,l=names.length;i&lt;l &amp;&amp; object;i++){
+		object = dojo.evalProp(names[i], object, create);
+	}
+	return {obj: object, prop: prop};	// Object: {obj: Object, prop: String}
+}
+
+
+dojo.evalObjPath = function(/*String*/ path, /*Boolean?*/ create){
+	// summary: Return the value of object at 'path' in the global scope, without using 'eval()'.
+	// path: Path to an object, in the form &quot;A.B.C&quot;.
+	// create: If true, Objects will be created at any point along the 'path' that is undefined.
+	if(typeof path != &quot;string&quot;){ 
+		return dj_global; 
+	}
+	// fast path for no periods
+	if(path.indexOf('.') == -1){
+		return dojo.evalProp(path, dj_global, create);		// mixed
+	}
+
+	//MOW: old 'with' syntax was confusing and would throw an error if parseObjPath returned null.
+	var ref = dojo.parseObjPath(path, dj_global, create);
+	if(ref){
+		return dojo.evalProp(ref.prop, ref.obj, create);	// mixed
+	}
+	return null;
+}
+
+// ****************************************************************
+// global public utils
+// TODOC: DO WE WANT TO NOTE THAT THESE ARE GLOBAL PUBLIC UTILS?
+// ****************************************************************
+
+dojo.errorToString = function(/*Error*/ exception){
+	// summary: Return an exception's 'message', 'description' or text.
+
+	// TODO: overriding Error.prototype.toString won't accomplish this?
+ 	// 		... since natively generated Error objects do not always reflect such things?
+	if(!dj_undef(&quot;message&quot;, exception)){
+		return exception.message;		// String
+	}else if(!dj_undef(&quot;description&quot;, exception)){
+		return exception.description;	// String
+	}else{
+		return exception;				// Error
+	}
+}
+
+
+dojo.raise = function(/*String*/ message, /*Error?*/ exception){
+	// summary: Throw an error message, appending text of 'exception' if provided.
+	// note: Also prints a message to the user using 'dojo.hostenv.println'.
+	if(exception){
+		message = message + &quot;: &quot;+dojo.errorToString(exception);
+	}
+
+	// print the message to the user if hostenv.println is defined
+	try {	dojo.hostenv.println(&quot;FATAL: &quot;+message); } catch (e) {}
+
+	throw Error(message);
+}
+
+//Stub functions so things don't break.
+//TODOC:  HOW TO DOC THESE?
+dojo.debug = function(){}
+dojo.debugShallow = function(obj){}
+dojo.profile = { start: function(){}, end: function(){}, stop: function(){}, dump: function(){} };
+
+
+function dj_eval(/*String*/ scriptFragment){ 
+	// summary: Perform an evaluation in the global scope.  Use this rather than calling 'eval()' directly.
+	// description: Placed in a separate function to minimize size of trapped evaluation context.
+	// note:
+	//	 - JSC eval() takes an optional second argument which can be 'unsafe'.
+	//	 - Mozilla/SpiderMonkey eval() takes an optional second argument which is the
+	//  	 scope object for new symbols.
+	return dj_global.eval ? dj_global.eval(scriptFragment) : eval(scriptFragment); 	// mixed
+}
+
+
+
+dojo.unimplemented = function(/*String*/ funcname, /*String?*/ extra){
+	// summary: Throw an exception because some function is not implemented.
+	// extra: Text to append to the exception message.
+	var message = &quot;'&quot; + funcname + &quot;' not implemented&quot;;
+	if (extra != null) { message += &quot; &quot; + extra; }
+	dojo.raise(message);
+}
+
+
+dojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){
+	// summary: Log a debug message to indicate that a behavior has been deprecated.
+	// extra: Text to append to the message.
+	// removal: Text to indicate when in the future the behavior will be removed.
+	var message = &quot;DEPRECATED: &quot; + behaviour;
+	if(extra){ message += &quot; &quot; + extra; }
+	if(removal){ message += &quot; -- will be removed in version: &quot; + removal; }
+	dojo.debug(message);
+}
+
+
+
+dojo.inherits = function(/*Function*/ subclass, /*Function*/ superclass){
+	// summary: Set up inheritance between two classes.
+	if(typeof superclass != 'function'){ 
+		dojo.raise(&quot;dojo.inherits: superclass argument [&quot;+superclass+&quot;] must be a function (subclass: [&quot; + subclass + &quot;']&quot;);
+	}
+	subclass.prototype = new superclass();
+	subclass.prototype.constructor = subclass;
+	subclass.superclass = superclass.prototype;
+	// DEPRICATED: super is a reserved word, use 'superclass'
+	subclass['super'] = superclass.prototype;
+}
+
+dojo.render = (function(){
+	//TODOC: HOW TO DOC THIS?
+	// summary: Details rendering support, OS and browser of the current environment.
+	// TODOC: is this something many folks will interact with?  If so, we should doc the structure created...
+	function vscaffold(prefs, names){
+		var tmp = {
+			capable: false,
+			support: {
+				builtin: false,
+				plugin: false
+			},
+			prefixes: prefs
+		};
+		for(var prop in names){
+			tmp[prop] = false;
+		}
+		return tmp;
+	}
+
+	return {
+		name: &quot;&quot;,
+		ver: dojo.version,
+		os: { win: false, linux: false, osx: false },
+		html: vscaffold([&quot;html&quot;], [&quot;ie&quot;, &quot;opera&quot;, &quot;khtml&quot;, &quot;safari&quot;, &quot;moz&quot;]),
+		svg: vscaffold([&quot;svg&quot;], [&quot;corel&quot;, &quot;adobe&quot;, &quot;batik&quot;]),
+		vml: vscaffold([&quot;vml&quot;], [&quot;ie&quot;]),
+		swf: vscaffold([&quot;Swf&quot;, &quot;Flash&quot;, &quot;Mm&quot;], [&quot;mm&quot;]),
+		swt: vscaffold([&quot;Swt&quot;], [&quot;ibm&quot;])
+	};
+})();
+
+// ****************************************************************
+// dojo.hostenv methods that must be defined in hostenv_*.js
+// ****************************************************************
+
+/**
+ * The interface definining the interaction with the EcmaScript host environment.
+*/
+
+/*
+ * None of these methods should ever be called directly by library users.
+ * Instead public methods such as loadModule should be called instead.
+ */
+dojo.hostenv = (function(){
+	// TODOC:  HOW TO DOC THIS?
+	// summary: Provides encapsulation of behavior that changes across different 'host environments' 
+	//			(different browsers, server via Rhino, etc).
+	// description: None of these methods should ever be called directly by library users.
+	//				Use public methods such as 'loadModule' instead.
+	
+	// default configuration options
+	var config = {
+		isDebug: false,
+		allowQueryConfig: false,
+		baseScriptUri: &quot;&quot;,
+		baseRelativePath: &quot;&quot;,
+		libraryScriptUri: &quot;&quot;,
+		iePreventClobber: false,
+		ieClobberMinimal: true,
+		preventBackButtonFix: true,
+		searchIds: [],
+		parseWidgets: true
+	};
+
+	if (typeof djConfig == &quot;undefined&quot;) { djConfig = config; }
+	else {
+		for (var option in config) {
+			if (typeof djConfig[option] == &quot;undefined&quot;) {
+				djConfig[option] = config[option];
+			}
+		}
+	}
+
+	return {
+		name_: '(unset)',
+		version_: '(unset)',
+
+
+		getName: function(){ 
+			// sumary: Return the name of the host environment.
+			return this.name_; 	// String
+		},
+
+
+		getVersion: function(){ 
+			// summary: Return the version of the hostenv.
+			return this.version_; // String
+		},
+
+		getText: function(/*String*/ uri){
+			// summary:	Read the plain/text contents at the specified 'uri'.
+			// description: 
+			//			If 'getText()' is not implemented, then it is necessary to override 
+			//			'loadUri()' with an implementation that doesn't rely on it.
+
+			dojo.unimplemented('getText', &quot;uri=&quot; + uri);
+		}
+	};
+})();
+
+
+dojo.hostenv.getBaseScriptUri = function(){
+	// summary: Return the base script uri that other scripts are found relative to.
+	// TODOC: HUH?  This comment means nothing to me.  What other scripts? Is this the path to other dojo libraries?
+	//		MAYBE:  Return the base uri to scripts in the dojo library.	 ???
+	// return: Empty string or a path ending in '/'.
+	if(djConfig.baseScriptUri.length){ 
+		return djConfig.baseScriptUri;
+	}
+
+	// MOW: Why not:
+	//			uri = djConfig.libraryScriptUri || djConfig.baseRelativePath
+	//		??? Why 'new String(...)'
+	var uri = new String(djConfig.libraryScriptUri||djConfig.baseRelativePath);
+	if (!uri) { dojo.raise(&quot;Nothing returned by getLibraryScriptUri(): &quot; + uri); }
+
+	// MOW: uri seems to not be actually used.  Seems to be hard-coding to djConfig.baseRelativePath... ???
+	var lastslash = uri.lastIndexOf('/');		// MOW ???
+	djConfig.baseScriptUri = djConfig.baseRelativePath;
+	return djConfig.baseScriptUri;	// String
+}

Added: trunk/root/static/magic/src/bootstrap2.js
===================================================================
--- trunk/root/static/magic/src/bootstrap2.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/bootstrap2.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,174 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+//Semicolon is for when this file is integrated with a custom build on one line
+//with some other file's contents. Sometimes that makes things not get defined
+//properly, particularly with the using the closure below to do all the work.
+;(function(){
+	//Don't do this work if dojo.js has already done it.
+	if(typeof dj_usingBootstrap != &quot;undefined&quot;){
+		return;
+	}
+
+	var isRhino = false;
+	var isSpidermonkey = false;
+	var isDashboard = false;
+	if((typeof this[&quot;load&quot;] == &quot;function&quot;)&amp;&amp;((typeof this[&quot;Packages&quot;] == &quot;function&quot;)||(typeof this[&quot;Packages&quot;] == &quot;object&quot;))){
+		isRhino = true;
+	}else if(typeof this[&quot;load&quot;] == &quot;function&quot;){
+		isSpidermonkey  = true;
+	}else if(window.widget){
+		isDashboard = true;
+	}
+
+	var tmps = [];
+	if((this[&quot;djConfig&quot;])&amp;&amp;((djConfig[&quot;isDebug&quot;])||(djConfig[&quot;debugAtAllCosts&quot;]))){
+		tmps.push(&quot;debug.js&quot;);
+	}
+
+	if((this[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;debugAtAllCosts&quot;])&amp;&amp;(!isRhino)&amp;&amp;(!isDashboard)){
+		tmps.push(&quot;browser_debug.js&quot;);
+	}
+
+	//Support compatibility packages. Right now this only allows setting one
+	//compatibility package. Might need to revisit later down the line to support
+	//more than one.
+	if((this[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;compat&quot;])){
+		tmps.push(&quot;compat/&quot; + djConfig[&quot;compat&quot;] + &quot;.js&quot;);
+	}
+
+	var loaderRoot = djConfig[&quot;baseScriptUri&quot;];
+	if((this[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;baseLoaderUri&quot;])){
+		loaderRoot = djConfig[&quot;baseLoaderUri&quot;];
+	}
+
+	for(var x=0; x &lt; tmps.length; x++){
+		var spath = loaderRoot+&quot;src/&quot;+tmps[x];
+		if(isRhino||isSpidermonkey){
+			load(spath);
+		} else {
+			try {
+				document.write(&quot;&lt;scr&quot;+&quot;ipt type='text/javascript' src='&quot;+spath+&quot;'&gt;&lt;/scr&quot;+&quot;ipt&gt;&quot;);
+			} catch (e) {
+				var script = document.createElement(&quot;script&quot;);
+				script.src = spath;
+				document.getElementsByTagName(&quot;head&quot;)[0].appendChild(script);
+			}
+		}
+	}
+})();
+
+// Localization routines
+
+/**
+ * The locale to look for string bundles if none are defined for your locale.  Translations for all strings
+ * should be provided in this locale.
+ */
+//TODO: this really belongs in translation metadata, not in code
+dojo.fallback_locale = 'en';
+
+/**
+ * Returns canonical form of locale, as used by Dojo.  All variants are case-insensitive and are separated by '-'
+ * as specified in RFC 3066
+ */
+dojo.normalizeLocale = function(locale) {
+	return locale ? locale.toLowerCase() : dojo.locale;
+};
+
+/**
+ * requireLocalization() is for loading translated bundles provided within a package in the namespace.
+ * Contents are typically strings, but may be any name/value pair, represented in JSON format.
+ * A bundle is structured in a program as follows:
+ *
+ * &lt;package&gt;/
+ *  nls/
+ *   de/
+ *    mybundle.js
+ *   de-at/
+ *    mybundle.js
+ *   en/
+ *    mybundle.js
+ *   en-us/
+ *    mybundle.js
+ *   en-gb/
+ *    mybundle.js
+ *   es/
+ *    mybundle.js
+ *  ...etc
+ *
+ * where package is part of the namespace as used by dojo.require().  Each directory is named for a
+ * locale as specified by RFC 3066, (<A HREF="http://www.ietf.org/rfc/rfc3066.txt">http://www.ietf.org/rfc/rfc3066.txt</A>), normalized in lowercase.
+ *
+ * For a given locale, string bundles will be loaded for that locale and all general locales above it, as well
+ * as a system-specified fallback.  For example, &quot;de_at&quot; will also load &quot;de&quot; and &quot;en&quot;.  Lookups will traverse
+ * the locales in this order.  A build step can preload the bundles to avoid data redundancy and extra network hits.
+ *
+ * @param modulename package in which the bundle is found
+ * @param bundlename bundle name, typically the filename without the '.js' suffix
+ * @param locale the locale to load (optional)  By default, the browser's user locale as defined
+ *	in dojo.locale
+ */
+dojo.requireLocalization = function(modulename, bundlename, locale /*optional*/){
+
+	dojo.debug(&quot;EXPERIMENTAL: dojo.requireLocalization&quot;); //dojo.experimental
+
+	var syms = dojo.hostenv.getModuleSymbols(modulename);
+	var modpath = syms.concat(&quot;nls&quot;).join(&quot;/&quot;);
+
+	locale = dojo.normalizeLocale(locale);
+
+	var elements = locale.split('-');
+	var searchlist = [];
+	for(var i = elements.length; i &gt; 0; i--){
+		searchlist.push(elements.slice(0, i).join('-'));
+	}
+	if(searchlist[searchlist.length-1] != dojo.fallback_locale){
+		searchlist.push(dojo.fallback_locale);
+	}
+
+	var bundlepackage = [modulename, &quot;_nls&quot;, bundlename].join(&quot;.&quot;);
+	var bundle = dojo.hostenv.startPackage(bundlepackage);
+	dojo.hostenv.loaded_modules_[bundlepackage] = bundle;
+	
+	var inherit = false;
+	for(var i = searchlist.length - 1; i &gt;= 0; i--){
+		var loc = searchlist[i];
+		var pkg = [bundlepackage, loc].join(&quot;.&quot;);
+		var loaded = false;
+		if(!dojo.hostenv.findModule(pkg)){
+			// Mark loaded whether it's found or not, so that further load attempts will not be made
+			dojo.hostenv.loaded_modules_[pkg] = null;
+
+			var filespec = [modpath, loc, bundlename].join(&quot;/&quot;) + '.js';
+			loaded = dojo.hostenv.loadPath(filespec, null, function(hash) {
+ 				bundle[loc] = hash;
+ 				if(inherit){
+					// Use mixins approach to copy string references from inherit bundle, but skip overrides.
+					for(var x in inherit){
+						if(!bundle[loc][x]){
+							bundle[loc][x] = inherit[x];
+						}
+					}
+ 				}
+/*
+				// Use prototype to point to other bundle, then copy in result from loadPath
+				bundle[loc] = new function(){};
+				if(inherit){ bundle[loc].prototype = inherit; }
+				for(var i in hash){ bundle[loc][i] = hash[i]; }
+*/
+			});
+		}else{
+			loaded = true;
+		}
+		if(loaded &amp;&amp; bundle[loc]){
+			inherit = bundle[loc];
+		}
+	}
+};

Added: trunk/root/static/magic/src/browser_debug.js
===================================================================
--- trunk/root/static/magic/src/browser_debug.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/browser_debug.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,162 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.hostenv.loadedUris.push(&quot;../src/bootstrap1.js&quot;);
+dojo.hostenv.loadedUris.push(&quot;../src/loader.js&quot;);
+dojo.hostenv.loadedUris.push(&quot;../src/hostenv_browser.js&quot;);
+dojo.hostenv.loadedUris.push(&quot;../src/bootstrap2.js&quot;);
+
+function removeComments(contents){
+	contents = new String((!contents) ? &quot;&quot; : contents);
+	// clobber all comments
+	contents = contents.replace( /^(.*?)\/\/(.*)$/mg , &quot;$1&quot;);
+	contents = contents.replace( /(\n)/mg , &quot;__DOJONEWLINE&quot;);
+	contents = contents.replace( /\/\*(.*?)\*\//g , &quot;&quot;);
+	return contents.replace( /__DOJONEWLINE/mg , &quot;\n&quot;);
+}
+
+dojo.hostenv.getRequiresAndProvides = function(contents){
+	// FIXME: should probably memoize this!
+	if(!contents){ return []; }
+	
+
+	// check to see if we need to load anything else first. Ugg.
+	var deps = [];
+	var tmp;
+	RegExp.lastIndex = 0;
+	var testExp = /dojo.(hostenv.loadModule|hosetnv.require|require|requireIf|kwCompoundRequire|hostenv.conditionalLoadModule|hostenv.startPackage|provide)\([\w\W]*?\)/mg;
+	while((tmp = testExp.exec(contents)) != null){
+		deps.push(tmp[0]);
+	}
+	return deps;
+}
+
+dojo.hostenv.getDelayRequiresAndProvides = function(contents){
+	// FIXME: should probably memoize this!
+	if(!contents){ return []; }
+
+	// check to see if we need to load anything else first. Ugg.
+	var deps = [];
+	var tmp;
+	RegExp.lastIndex = 0;
+	var testExp = /dojo.(requireAfterIf)\([\w\W]*?\)/mg;
+	while((tmp = testExp.exec(contents)) != null){
+		deps.push(tmp[0]);
+	}
+	return deps;
+}
+
+/*
+dojo.getNonExistantDescendants = function(objpath){
+	var ret = [];
+	// fast path for no periods
+	if(typeof objpath != &quot;string&quot;){ return dj_global; }
+	if(objpath.indexOf('.') == -1){
+		if(dj_undef(objpath, dj_global)){
+			ret.push[objpath];
+		}
+		return ret;
+	}
+
+	var syms = objpath.split(/\./);
+	var obj = dj_global;
+	for(var i=0;i&lt;syms.length;++i){
+		if(dj_undef(syms[i], obj)){
+			for(var j=i; j&lt;syms.length; j++){
+				ret.push(syms.slice(0, j+1).join(&quot;.&quot;));
+			}
+			break;
+		}
+	}
+	return ret;
+}
+*/
+
+dojo.clobberLastObject = function(objpath){
+	if(objpath.indexOf('.') == -1){
+		if(!dj_undef(objpath, dj_global)){
+			delete dj_global[objpath];
+		}
+		return true;
+	}
+
+	var syms = objpath.split(/\./);
+	var base = dojo.evalObjPath(syms.slice(0, -1).join(&quot;.&quot;), false);
+	var child = syms[syms.length-1];
+	if(!dj_undef(child, base)){
+		// alert(objpath);
+		delete base[child];
+		return true;
+	}
+	return false;
+}
+
+var removals = [];
+
+function zip(arr){
+	var ret = [];
+	var seen = {};
+	for(var x=0; x&lt;arr.length; x++){
+		if(!seen[arr[x]]){
+			ret.push(arr[x]);
+			seen[arr[x]] = true;
+		}
+	}
+	return ret;
+}
+
+// over-write dj_eval to prevent actual loading of subsequent files
+var old_dj_eval = dj_eval;
+dj_eval = function(){ return true; }
+dojo.hostenv.oldLoadUri = dojo.hostenv.loadUri;
+dojo.hostenv.loadUri = function(uri){
+	if(dojo.hostenv.loadedUris[uri]){
+		return true; // fixes endless recursion opera trac 471
+	}
+	try{
+		var text = this.getText(uri, null, true);
+		var requires = dojo.hostenv.getRequiresAndProvides(text);
+		eval(requires.join(&quot;;&quot;));
+		dojo.hostenv.loadedUris.push(uri);
+		dojo.hostenv.loadedUris[uri] = true;
+		var delayRequires = dojo.hostenv.getDelayRequiresAndProvides(text);
+		eval(delayRequires.join(&quot;;&quot;));
+	}catch(e){ 
+		alert(e);
+	}
+	return true;
+}
+
+dojo.hostenv.writeIncludes = function(){
+	for(var x=removals.length-1; x&gt;=0; x--){
+		dojo.clobberLastObject(removals[x]);
+	}
+	var depList = [];
+	var seen = {};
+	for(var x=0; x&lt;dojo.hostenv.loadedUris.length; x++){
+		var curi = dojo.hostenv.loadedUris[x];
+		// dojo.debug(curi);
+		if(!seen[curi]){
+			seen[curi] = true;
+			depList.push(curi);
+		}
+	}
+
+	dojo.hostenv._global_omit_module_check = true;
+	for(var x=4; x&lt;depList.length; x++){
+		document.write(&quot;&lt;script type='text/javascript' src='&quot;+depList[x]+&quot;'&gt;&lt;/script&gt;&quot;);
+	}
+	document.write(&quot;&lt;script type='text/javascript'&gt;dojo.hostenv._global_omit_module_check = false;&lt;/script&gt;&quot;);
+
+	// turn off debugAtAllCosts, so that dojo.require() calls inside of ContentPane hrefs
+	// work correctly
+	dj_eval = old_dj_eval;
+	dojo.hostenv.loadUri = dojo.hostenv.oldLoadUri;
+}

Added: trunk/root/static/magic/src/collections/ArrayList.js
===================================================================
--- trunk/root/static/magic/src/collections/ArrayList.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/ArrayList.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,146 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.ArrayList&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+dojo.collections.ArrayList=function(/* array? */arr){
+	//	summary
+	//	Returns a new object of type dojo.collections.ArrayList
+	var items=[];
+	if(arr) items=items.concat(arr);
+	this.count=items.length;
+	this.add=function(/* object */obj){
+		//	summary
+		//	Add an element to the collection.
+		items.push(obj);
+		this.count=items.length;
+	};
+	this.addRange=function(/* array */a){
+		//	summary
+		//	Add a range of objects to the ArrayList
+		if(a.getIterator){
+			var e=a.getIterator();
+			while(!e.atEnd()){
+				this.add(e.get());
+			}
+			this.count=items.length;
+		}else{
+			for(var i=0; i&lt;a.length; i++){
+				items.push(a[i]);
+			}
+			this.count=items.length;
+		}
+	};
+	this.clear=function(){
+		//	summary
+		//	Clear all elements out of the collection, and reset the count.
+		items.splice(0, items.length);
+		this.count=0;
+	};
+	this.clone=function(){
+		//	summary
+		//	Clone the array list
+		return new dojo.collections.ArrayList(items);	//	dojo.collections.ArrayList
+	};
+	this.contains=function(/* object */obj){
+		//	summary
+		//	Check to see if the passed object is a member in the ArrayList
+		for(var i=0; i &lt; items.length; i++){
+			if(items[i] == obj) {
+				return true;	//	bool
+			}
+		}
+		return false;	//	bool
+	};
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
+			Array.forEach(items, fn, s);
+		}else{
+			for(var i=0; i&lt;items.length; i++){
+				fn.call(s, items[i], i, items);
+			}
+		}
+	};
+	this.getIterator=function(){
+		//	summary
+		//	Get an Iterator for this object
+		return new dojo.collections.Iterator(items);	//	dojo.collections.Iterator
+	};
+	this.indexOf=function(/* object */obj){
+		//	summary
+		//	Return the numeric index of the passed object; will return -1 if not found.
+		for(var i=0; i &lt; items.length; i++){
+			if(items[i] == obj) {
+				return i;	//	int
+			}
+		}
+		return -1;	// int
+	};
+	this.insert=function(/* int */ i, /* object */ obj){
+		//	summary
+		//	Insert the passed object at index i
+		items.splice(i,0,obj);
+		this.count=items.length;
+	};
+	this.item=function(/* int */ i){
+		//	summary
+		//	return the element at index i
+		return items[i];	//	object
+	};
+	this.remove=function(/* object */obj){
+		//	summary
+		//	Look for the passed object, and if found, remove it from the internal array.
+		var i=this.indexOf(obj);
+		if(i &gt;=0) {
+			items.splice(i,1);
+		}
+		this.count=items.length;
+	};
+	this.removeAt=function(/* int */ i){
+		//	summary
+		//	return an array with function applied to all elements
+		items.splice(i,1);
+		this.count=items.length;
+	};
+	this.reverse=function(){
+		//	summary
+		//	Reverse the internal array
+		items.reverse();
+	};
+	this.sort=function(/* function? */ fn){
+		//	summary
+		//	sort the internal array
+		if(fn){
+			items.sort(fn);
+		}else{
+			items.sort();
+		}
+	};
+	this.setByIndex=function(/* int */ i, /* object */ obj){
+		//	summary
+		//	Set an element in the array by the passed index.
+		items[i]=obj;
+		this.count=items.length;
+	};
+	this.toArray=function(){
+		//	summary
+		//	Return a new array with all of the items of the internal array concatenated.
+		return [].concat(items);
+	}
+	this.toString=function(/* string */ delim){
+		//	summary
+		//	implementation of toString, follows [].toString();
+		return items.join((delim||&quot;,&quot;));
+	};
+};

Added: trunk/root/static/magic/src/collections/BinaryTree.js
===================================================================
--- trunk/root/static/magic/src/collections/BinaryTree.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/BinaryTree.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,203 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.BinaryTree&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+dojo.require(&quot;dojo.experimental&quot;);
+
+dojo.experimental(&quot;dojo.collections.BinaryTree&quot;);
+
+dojo.collections.BinaryTree=function(data){
+	function node(data, rnode, lnode){
+		this.value=data||null;
+		this.right=rnode||null;
+		this.left=lnode||null;
+		this.clone=function(){
+			var c=new node();
+			if (this.value.value) c.value=this.value.clone();
+			else c.value=this.value;
+			if (this.left) c.left=this.left.clone();
+			if (this.right) c.right=this.right.clone();
+		}
+		this.compare=function(n){
+			if (this.value &gt; n.value) return 1;
+			if (this.value &lt; n.value) return -1;
+			return 0;
+		}
+		this.compareData=function(d){
+			if (this.value &gt; d) return 1;
+			if (this.value &lt; d) return -1;
+			return 0;
+		}
+	}
+
+	function inorderTraversalBuildup(current, a){
+		if (current){
+			inorderTraversalBuildup(current.left, a);
+			a.add(current);
+			inorderTraversalBuildup(current.right, a);
+		}
+	}
+
+	function preorderTraversal(current, sep){
+		var s=&quot;&quot;;
+		if (current){
+			s=current.value.toString() + sep;
+			s += preorderTraversal(current.left, sep);
+			s += preorderTraversal(current.right, sep);
+		}
+		return s;
+	}
+	function inorderTraversal(current, sep){
+		var s=&quot;&quot;;
+		if (current){
+			s=inorderTraversal(current.left, sep);
+			s += current.value.toString() + sep;
+			s += inorderTraversal(current.right, sep);
+		}
+		return s;
+	}
+	function postorderTraversal(current, sep){
+		var s=&quot;&quot;;
+		if (current){
+			s=postorderTraversal(current.left, sep);
+			s += postorderTraversal(current.right, sep);
+			s += current.value.toString() + sep;
+		}
+		return s;
+	}
+	
+	function searchHelper(current, data){
+		if (!current) return null;
+		var i=current.compareData(data);
+		if (i==0) return current;
+		if (i&gt;0) return searchHelper(current.left, data);
+		else return searchHelper(current.right, data);
+	}
+
+	this.add=function(data){
+		var n=new node(data);
+		var i;
+		var current=root;
+		var parent=null;
+		while (current){
+			i=current.compare(n);
+			if (i == 0) return;
+			parent=current;
+			if (i &gt; 0) current=current.left;
+			else current=current.right;
+		}
+		this.count++;
+		if (!parent) root=n;
+		else {
+			i=parent.compare(n);
+			if (i &gt; 0) parent.left=n;
+			else parent.right=n;
+		}
+	};
+	this.clear=function(){
+		root=null;
+		this.count=0;
+	};
+	this.clone=function(){
+		var c=new dojo.collections.BinaryTree();
+		c.root=root.clone();
+		c.count=this.count;
+		return c;
+	};
+	this.contains=function(data){
+		return this.search(data) != null;
+	};
+	this.deleteData=function(data){
+		var current=root;
+		var parent=null;
+		var i=current.compareData(data);
+		while (i != 0 &amp;&amp; current != null){
+			if (i &gt; 0){
+				parent=current;
+				current=current.left;
+			} else if (i &lt; 0) {
+				parent=current;
+				current=current.right;
+			}
+			i=current.compareData(data);
+		}
+		if (!current) return;
+		this.count--;
+		if (!current.right) {
+			if (!parent) root=current.left;
+			else {
+				i=parent.compare(current);
+				if (i &gt; 0) parent.left=current.left;
+				else if (i &lt; 0) parent.right=current.left;
+			}
+		} else if (!current.right.left){
+			if (!parent) root=current.right;
+			else {
+				i=parent.compare(current);
+				if (i &gt; 0) parent.left=current.right;
+				else if (i &lt; 0) parent.right=current.right;
+			}
+		} else {
+			var leftmost=current.right.left;
+			var lmParent=current.right;
+			while (leftmost.left != null){
+				lmParent=leftmost;
+				leftmost=leftmost.left;
+			}
+			lmParent.left=leftmost.right;
+			leftmost.left=current.left;
+			leftmost.right=current.right;
+			if (!parent) root=leftmost;
+			else {
+				i=parent.compare(current);
+				if (i &gt; 0) parent.left=leftmost;
+				else if (i &lt; 0) parent.right=leftmost;
+			}
+		}
+	};
+	this.getIterator=function(){
+		var a=[];
+		inorderTraversalBuildup(root, a);
+		return new dojo.collections.Iterator(a);
+	};
+	this.search=function(data){
+		return searchHelper(root, data);
+	};
+	this.toString=function(order, sep){
+		if (!order) var order=dojo.collections.BinaryTree.TraversalMethods.Inorder;
+		if (!sep) var sep=&quot; &quot;;
+		var s=&quot;&quot;;
+		switch (order){
+			case dojo.collections.BinaryTree.TraversalMethods.Preorder:
+				s=preorderTraversal(root, sep);
+				break;
+			case dojo.collections.BinaryTree.TraversalMethods.Inorder:
+				s=inorderTraversal(root, sep);
+				break;
+			case dojo.collections.BinaryTree.TraversalMethods.Postorder:
+				s=postorderTraversal(root, sep);
+				break;
+		};
+		if (s.length == 0) return &quot;&quot;;
+		else return s.substring(0, s.length - sep.length);
+	};
+
+	this.count=0;
+	var root=this.root=null;
+	if (data) {
+		this.add(data);
+	}
+}
+dojo.collections.BinaryTree.TraversalMethods={
+	Preorder : 0,
+	Inorder : 1,
+	Postorder : 2
+};

Added: trunk/root/static/magic/src/collections/Collections.js
===================================================================
--- trunk/root/static/magic/src/collections/Collections.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/Collections.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,125 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.Collections&quot;);
+
+dojo.collections={Collections:true};
+dojo.collections.DictionaryEntry=function(/* string */k, /* object */v){
+	//	summary
+	//	return an object of type dojo.collections.DictionaryEntry
+	this.key=k;
+	this.value=v;
+	this.valueOf=function(){ 
+		return this.value; 	//	object
+	};
+	this.toString=function(){ 
+		return String(this.value);	//	string 
+	};
+}
+
+/*	Iterators
+ *	The collections.Iterators (Iterator and DictionaryIterator) are built to
+ *	work with the Collections included in this namespace.  However, they *can*
+ *	be used with arrays and objects, respectively, should one choose to do so.
+ */
+dojo.collections.Iterator=function(/* array */arr){
+	//	summary
+	//	return an object of type dojo.collections.Iterator
+	var a=arr;
+	var position=0;
+	this.element=a[position]||null;
+	this.atEnd=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		return (position&gt;=a.length);	//	bool
+	};
+	this.get=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		if(this.atEnd()){
+			return null;		//	object
+		}
+		this.element=a[position++];
+		return this.element;	//	object
+	};
+	this.map=function(/* function */fn, /* object? */scope){
+		//	summary
+		//	Functional iteration with optional scope.
+		var s=scope||dj_global;
+		if(Array.map){
+			return Array.map(a,fn,s);	//	array
+		}else{
+			var arr=[];
+			for(var i=0; i&lt;a.length; i++){
+				arr.push(fn.call(s,a[i]));
+			}
+			return arr;		//	array
+		}
+	};
+	this.reset=function(){
+		//	summary
+		//	reset the internal cursor.
+		position=0;
+		this.element=a[position];
+	};
+}
+
+/*	Notes:
+ *	The DictionaryIterator no longer supports a key and value property;
+ *	the reality is that you can use this to iterate over a JS object
+ *	being used as a hashtable.
+ */
+dojo.collections.DictionaryIterator=function(/* object */obj){
+	//	summary
+	//	return an object of type dojo.collections.DictionaryIterator
+	var a=[];	//	Create an indexing array
+	var testObject={};
+	for(var p in obj){
+		if(!testObject[p]){
+			a.push(obj[p]);	//	fill it up
+		}
+	}
+	var position=0;
+	this.element=a[position]||null;
+	this.atEnd=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		return (position&gt;=a.length);	//	bool
+	};
+	this.get=function(){
+		//	summary
+		//	Test to see if the internal cursor has reached the end of the internal collection.
+		if(this.atEnd()){
+			return null;		//	object
+		}
+		this.element=a[position++];
+		return this.element;	//	object
+	};
+	this.map=function(/* function */fn, /* object? */scope){
+		//	summary
+		//	Functional iteration with optional scope.
+		var s=scope||dj_global;
+		if(Array.map){
+			return Array.map(a,fn,s);	//	array
+		}else{
+			var arr=[];
+			for(var i=0; i&lt;a.length; i++){
+				arr.push(fn.call(s,a[i]));
+			}
+			return arr;		//	array
+		}
+	};
+	this.reset=function() { 
+		//	summary
+		//	reset the internal cursor.
+		position=0; 
+		this.element=a[position];
+	};
+};

Added: trunk/root/static/magic/src/collections/Dictionary.js
===================================================================
--- trunk/root/static/magic/src/collections/Dictionary.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/Dictionary.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,129 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.Dictionary&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+dojo.collections.Dictionary=function(/* dojo.collections.Dictionary? */dictionary){
+	//	summary
+	//	Returns an object of type dojo.collections.Dictionary
+	var items={};
+	this.count=0;
+
+	//	comparator for property addition and access.
+	var testObject={};
+
+	this.add=function(/* string */k, /* object */v){
+		//	summary
+		//	Add a new item to the Dictionary.
+		var b=(k in items);
+		items[k]=new dojo.collections.DictionaryEntry(k,v);
+		if(!b){
+			this.count++;
+		}
+	};
+	this.clear=function(){
+		//	summary
+		//	Clears the internal dictionary.
+		items={};
+		this.count=0;
+	};
+	this.clone=function(){
+		//	summary
+		//	Returns a new instance of dojo.collections.Dictionary; note the the dictionary is a clone but items might not be.
+		return new dojo.collections.Dictionary(this);	//	dojo.collections.Dictionary
+	};
+	this.contains=this.containsKey=function(/* string */k){
+		//	summary
+		//	Check to see if the dictionary has an entry at key &quot;k&quot;.
+		if(testObject[k]){
+			return false;			// bool
+		}
+		return (items[k]!=null);	//	bool
+	};
+	this.containsValue=function(/* object */v){
+		//	summary
+		//	Check to see if the dictionary has an entry with value &quot;v&quot;.
+		var e=this.getIterator();
+		while(e.get()){
+			if(e.element.value==v){
+				return true;	//	bool
+			}
+		}
+		return false;	//	bool
+	};
+	this.entry=function(/* string */k){
+		//	summary
+		//	Accessor method; similar to dojo.collections.Dictionary.item but returns the actual Entry object.
+		return items[k];	//	dojo.collections.DictionaryEntry
+	};
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var a=[];	//	Create an indexing array
+		for(var p in items) {
+			if(!testObject[p]){
+				a.push(items[p]);	//	fill it up
+			}
+		}
+		var s=scope||dj_global;
+		if(Array.forEach){
+			Array.forEach(a, fn, s);
+		}else{
+			for(var i=0; i&lt;a.length; i++){
+				fn.call(s, a[i], i, a);
+			}
+		}
+	};
+	this.getKeyList=function(){
+		//	summary
+		//	Returns an array of the keys in the dictionary.
+		return (this.getIterator()).map(function(entry){ 
+			return entry.key; 
+		});	//	array
+	};
+	this.getValueList=function(){
+		//	summary
+		//	Returns an array of the values in the dictionary.
+		return (this.getIterator()).map(function(entry){ 
+			return entry.value; 
+		});	//	array
+	};
+	this.item=function(/* string */k){
+		//	summary
+		//	Accessor method.
+		if(k in items){
+			return items[k].valueOf();	//	object
+		}
+		return undefined;	//	object
+	};
+	this.getIterator=function(){
+		//	summary
+		//	Gets a dojo.collections.DictionaryIterator for iteration purposes.
+		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
+	};
+	this.remove=function(/* string */k){
+		//	summary
+		//	Removes the item at k from the internal collection.
+		if(k in items &amp;&amp; !testObject[k]){
+			delete items[k];
+			this.count--;
+			return true;	//	bool
+		}
+		return false;	//	bool
+	};
+
+	if (dictionary){
+		var e=dictionary.getIterator();
+		while(e.get()) {
+			 this.add(e.element.key, e.element.value);
+		}
+	}
+};

Added: trunk/root/static/magic/src/collections/Graph.js
===================================================================
--- trunk/root/static/magic/src/collections/Graph.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/Graph.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,153 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.Graph&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+dojo.experimental(&quot;dojo.collections.Graph&quot;);
+
+dojo.collections.Graph=function(nodes){
+	function node(key, data, neighbors) {
+		this.key=key;
+		this.data=data;
+		this.neighbors=neighbors||new adjacencyList();
+		this.addDirected=function(){
+			if (arguments[0].constructor==edgeToNeighbor){
+				this.neighbors.add(arguments[0]);
+			}else{
+				var n=arguments[0];
+				var cost=arguments[1]||0;
+				this.neighbors.add(new edgeToNeighbor(n, cost));
+			}
+		}
+	}
+	function nodeList(){
+		var d=new dojo.collections.Dictionary();
+		function nodelistiterator(){
+			var o=[] ;	//	Create an indexing array
+			var e=d.getIterator();
+			while(e.get()){
+				o[o.length]=e.element;
+			}
+
+			var position=0;
+			this.element=o[position]||null;
+			this.atEnd=function(){
+				return (position&gt;=o.length);
+			}
+			this.get=function(){
+				if(this.atEnd()){
+					return null;		//	object
+				}
+				this.element=o[position++];
+				return this.element;	//	object
+			};
+			this.map=function(/* function */fn, /* object? */scope){
+				var s=scope||dj_global;
+				if(Array.map){
+					return Array.map(o,fn,s);	//	array
+				}else{
+					var arr=[];
+					for(var i=0; i&lt;o.length; i++){
+						arr.push(fn.call(s,o[i]));
+					}
+					return arr;		//	array
+				}
+			};
+			this.reset=function(){
+				position=0;
+				this.element=o[position];
+			};
+		}
+		
+		this.add=function(node){
+			d.add(node.key, node);
+		};
+		this.clear=function(){
+			d.clear();
+		};
+		this.containsKey=function(key){
+			return d.containsKey(key);
+		};
+		this.getIterator=function(){
+			return new nodelistiterator(this);
+		};
+		this.item=function(key){
+			return d.item(key);
+		};
+		this.remove=function(node){
+			d.remove(node.key);
+		};
+	}
+	function edgeToNeighbor(node, cost){
+		this.neighbor=node;
+		this.cost=cost;
+	}
+	function adjacencyList(){
+		var d=[];
+		this.add=function(o){
+			d.push(o);
+		};
+		this.item=function(i){
+			return d[i];
+		};
+		this.getIterator=function(){
+			return new dojo.collections.Iterator([].concat(d));
+		};
+	}
+
+	this.nodes=nodes||new nodeList();
+	this.count=this.nodes.count;
+	this.clear=function(){
+		this.nodes.clear();
+		this.count=0;
+	};
+	this.addNode=function(){
+		var n=arguments[0];
+		if(arguments.length &gt; 1){
+			n=new node(arguments[0],arguments[1]);
+		}
+		if(!this.nodes.containsKey(n.key)){
+			this.nodes.add(n);
+			this.count++;
+		}
+	};
+	this.addDirectedEdge=function(uKey, vKey, cost){
+		var uNode,vNode;
+		if(uKey.constructor!= node){
+			uNode=this.nodes.item(uKey);
+			vNode=this.nodes.item(vKey);
+		}else{
+			uNode=uKey;
+			vNode=vKey;
+		}
+		var c=cost||0;
+		uNode.addDirected(vNode,c);
+	};
+	this.addUndirectedEdge=function(uKey, vKey, cost){
+		var uNode, vNode;
+		if(uKey.constructor!=node){
+			uNode=this.nodes.item(uKey);
+			vNode=this.nodes.item(vKey);
+		}else{
+			uNode=uKey;
+			vNode=vKey;
+		}
+		var c=cost||0;
+		uNode.addDirected(vNode,c);
+		vNode.addDirected(uNode,c);
+	};
+	this.contains=function(n){
+		return this.nodes.containsKey(n.key);
+	};
+	this.containsKey=function(k){
+		return this.nodes.containsKey(k);
+	};
+}

Added: trunk/root/static/magic/src/collections/Queue.js
===================================================================
--- trunk/root/static/magic/src/collections/Queue.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/Queue.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,87 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.Queue&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+dojo.collections.Queue=function(/* array? */arr){
+	//	summary
+	//	return an object of type dojo.collections.Queue
+	var q=[];
+	if (arr){
+		q=q.concat(arr);
+	}
+	this.count=q.length;
+	this.clear=function(){
+		//	summary
+		//	clears the internal collection
+		q=[];
+		this.count=q.length;
+	};
+	this.clone=function(){
+		//	summary
+		//	creates a new Queue based on this one
+		return new dojo.collections.Queue(q);	//	dojo.collections.Queue
+	};
+	this.contains=function(/* object */ o){
+		//	summary
+		//	Check to see if the passed object is an element in this queue
+		for(var i=0; i&lt;q.length; i++){
+			if (q[i]==o){
+				return true;	//	bool
+			}
+		}
+		return false;	//	bool
+	};
+	this.copyTo=function(/* array */ arr, /* int */ i){
+		//	summary
+		//	Copy the contents of this queue into the passed array at index i.
+		arr.splice(i,0,q);
+	};
+	this.dequeue=function(){
+		//	summary
+		//	shift the first element off the queue and return it
+		var r=q.shift();
+		this.count=q.length;
+		return r;	//	object
+	};
+	this.enqueue=function(/* object */ o){
+		//	summary
+		//	put the passed object at the end of the queue
+		this.count=q.push(o);
+	};
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
+			Array.forEach(q, fn, s);
+		}else{
+			for(var i=0; i&lt;q.length; i++){
+				fn.call(s, q[i], i, q);
+			}
+		}
+	};
+	this.getIterator=function(){
+		//	summary
+		//	get an Iterator based on this queue.
+		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
+	};
+	this.peek=function(){
+		//	summary
+		//	get the next element in the queue without altering the queue.
+		return q[0];
+	};
+	this.toArray=function(){
+		//	summary
+		//	return an array based on the internal array of the queue.
+		return [].concat(q);
+	};
+};

Added: trunk/root/static/magic/src/collections/Set.js
===================================================================
--- trunk/root/static/magic/src/collections/Set.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/Set.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,84 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.Set&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+dojo.require(&quot;dojo.collections.ArrayList&quot;);
+
+//	straight up sets are based on arrays or array-based collections.
+dojo.collections.Set = new function(){
+	this.union = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise(&quot;Set operations can only be performed on array-based collections.&quot;);
+		var result = new dojo.collections.ArrayList(setA.toArray());
+		var e = setB.getIterator();
+		while(!e.atEnd()){
+			var item=e.get();
+			if(!result.contains(item)){
+				result.add(item);
+			}
+		}
+		return result;
+	};
+	this.intersection = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise(&quot;Set operations can only be performed on array-based collections.&quot;);
+		var result = new dojo.collections.ArrayList();
+		var e = setB.getIterator();
+		while(!e.atEnd()){
+			var item=e.get();
+			if(setA.contains(item)){
+				result.add(item);
+			}
+		}
+		return result;
+	};
+	//	returns everything in setA that is not in setB.
+	this.difference = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise(&quot;Set operations can only be performed on array-based collections.&quot;);
+		var result = new dojo.collections.ArrayList();
+		var e=setA.getIterator();
+		while(!e.atEnd()){
+			var item=e.get();
+			if(!setB.contains(item)){
+				result.add(item);
+			}
+		}
+		return result;
+	};
+	this.isSubSet = function(setA, setB) {
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise(&quot;Set operations can only be performed on array-based collections.&quot;);
+		var e = setA.getIterator();
+		while(!e.atEnd()){
+			if(!setB.contains(e.get())){
+				return false;
+			}
+		}
+		return true;
+	};
+	this.isSuperSet = function(setA, setB){
+		if (setA.constructor == Array) var setA = new dojo.collections.ArrayList(setA);
+		if (setB.constructor == Array) var setB = new dojo.collections.ArrayList(setB);
+		if (!setA.toArray || !setB.toArray) dojo.raise(&quot;Set operations can only be performed on array-based collections.&quot;);
+		var e = setB.getIterator();
+		while(!e.atEnd()){
+			if(!setA.contains(e.get())){
+				return false;
+			}
+		}
+		return true;
+	};
+}();

Added: trunk/root/static/magic/src/collections/SkipList.js
===================================================================
--- trunk/root/static/magic/src/collections/SkipList.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/SkipList.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,146 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.SkipList&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+dojo.require(&quot;dojo.experimental&quot;);
+
+dojo.experimental(&quot;dojo.collections.SkipList&quot;);
+
+dojo.collections.SkipList = function(){
+	function node(height, val){
+		this.value = val;
+		this.height = height;
+		this.nodes = new nodeList(height);
+		this.compare = function(val){
+			if (this.value &gt; val) return 1;
+			if (this.value &lt; val) return -1;
+			return 0;
+		}
+		this.incrementHeight = function(){
+			this.nodes.incrementHeight();
+			this.height++;
+		};
+		this.decrementHeight = function(){
+			this.nodes.decrementHeight();
+			this.height--;
+		};
+	}
+	function nodeList(height){
+		var arr = [];
+		this.height = height;
+		for (var i = 0; i &lt; height; i++) arr[i] = null;
+		this.item = function(i){
+			return arr[i];
+		};
+		this.incrementHeight = function(){
+			this.height++;
+			arr[this.height] = null;
+		};
+		this.decrementHeight = function(){
+			arr.splice(arr.length - 1, 1);
+			this.height--;
+		};
+	}
+	function iterator(list){
+		this.current = list.head;
+		this.atEnd = false;
+		this.moveNext = function(){
+			if (this.atEnd) return !this.atEnd;
+			this.current = this.current.nodes[0];
+			this.atEnd = (this.current == null);
+			return !this.atEnd;
+		};
+		this.reset = function(){
+			this.current = null;
+		};
+	}
+
+	function chooseRandomHeight(max){
+		var level = 1;
+		while (Math.random() &lt; PROB &amp;&amp; level &lt; max) level++;
+		return level;
+	}
+
+	var PROB = 0.5;
+	var comparisons = 0;
+
+	this.head = new node(1);
+	this.count = 0;
+	this.add = function(val){
+		var updates = [];
+		var current = this.head;
+		for (var i = this.head.height; i &gt;= 0; i--){
+			if (!(current.nodes[i] != null &amp;&amp; current.nodes[i].compare(val) &lt; 0)) comparisons++;
+			while (current.nodes[i] != null &amp;&amp; current.nodes[i].compare(val) &lt; 0){
+				current = current.nodes[i];
+				comparisons++;
+			}
+			updates[i] = current;
+		}
+		if (current.nodes[0] != null &amp;&amp; current.nodes[0].compare(val) == 0) return;
+		var n = new node(val, chooseRandomHeight(this.head.height + 1));
+		this.count++;
+		if (n.height &gt; this.head.height){
+			this.head.incrementHeight();
+			this.head.nodes[this.head.height - 1] = n;
+		}
+		for (i = 0; i &lt; n.height; i++){
+			if (i &lt; updates.length) {
+				n.nodes[i] = updates[i].nodes[i];
+				updates[i].nodes[i] = n;
+			}
+		}
+	};
+	
+	this.contains = function(val){
+		var current = this.head;
+		var i;
+		for (i = this.head.height - 1; i &gt;= 0; i--) {
+			while (current.item(i) != null) {
+				comparisons++;
+				var result = current.nodes[i].compare(val);
+				if (result == 0) return true;
+				else if (result &lt; 0) current = current.nodes[i];
+				else break;
+			}
+		}
+		return false;
+	};
+	this.getIterator = function(){
+		return new iterator(this);
+	};
+
+	this.remove = function(val){
+		var updates = [];
+		var current = this.head;
+		for (var i = this.head.height - 1; i &gt;= 0; i--){
+			if (!(current.nodes[i] != null &amp;&amp; current.nodes[i].compare(val) &lt; 0)) comparisons++;
+			while (current.nodes[i] != null &amp;&amp; current.nodes[i].compare(val) &lt; 0) {
+				current = current.nodes[i];
+				comparisons++;
+			}
+			updates[i] = current;
+		}
+		
+		current = current.nodes[0];
+		if (current != null &amp;&amp; current.compare(val) == 0){
+			this.count--;
+			for (var i = 0; i &lt; this.head.height; i++){
+				if (updates[i].nodes[i] != current) break;
+				else updates[i].nodes[i] = current.nodes[i];
+			}
+			if (this.head.nodes[this.head.height - 1] == null) this.head.decrementHeight();
+		}
+	};
+	this.resetComparisons = function(){ 
+		comparisons = 0; 
+	};
+}

Added: trunk/root/static/magic/src/collections/SortedList.js
===================================================================
--- trunk/root/static/magic/src/collections/SortedList.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/SortedList.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,211 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.SortedList&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+dojo.collections.SortedList=function(/* object? */ dictionary){
+	//	summary
+	//	creates a collection that acts like a dictionary but is also internally sorted.
+	//	Note that the act of adding any elements forces an internal resort, making this object potentially slow.
+	var _this=this;
+	var items={};
+	var q=[];
+	var sorter=function(a,b){
+		if (a.key &gt; b.key) return 1;
+		if (a.key &lt; b.key) return -1;
+		return 0;
+	};
+	var build=function(){
+		q=[];
+		var e=_this.getIterator();
+		while (!e.atEnd()){
+			q.push(e.get());
+		}
+		q.sort(sorter);
+	};
+	var testObject={};
+
+	this.count=q.length;
+	this.add=function(/* string */ k,/* object */v){
+		//	summary
+		//	add the passed value to the dictionary at location k
+		if (!items[k]) {
+			items[k]=new dojo.collections.DictionaryEntry(k,v);
+			this.count=q.push(items[k]);
+			q.sort(sorter);
+		}
+	};
+	this.clear=function(){
+		//	summary
+		//	clear the internal collections
+		items={};
+		q=[];
+		this.count=q.length;
+	};
+	this.clone=function(){
+		//	summary
+		//	create a clone of this sorted list
+		return new dojo.collections.SortedList(this);	//	dojo.collections.SortedList
+	};
+	this.contains=this.containsKey=function(/* string */ k){
+		//	summary
+		//	Check to see if the list has a location k
+		if(testObject[k]){
+			return false;			//	bool
+		}
+		return (items[k]!=null);	//	bool
+	};
+	this.containsValue=function(/* object */ o){
+		//	summary
+		//	Check to see if this list contains the passed object
+		var e=this.getIterator();
+		while (!e.atEnd()){
+			var item=e.get();
+			if(item.value==o){ 
+				return true;	//	bool
+			}
+		}
+		return false;	//	bool
+	};
+	this.copyTo=function(/* array */ arr, /* int */ i){
+		//	summary
+		//	copy the contents of the list into array arr at index i
+		var e=this.getIterator();
+		var idx=i;
+		while(!e.atEnd()){
+			arr.splice(idx,0,e.get());
+			idx++;
+		}
+	};
+	this.entry=function(/* string */ k){
+		//	summary
+		//	return the object at location k
+		return items[k];	//	dojo.collections.DictionaryEntry
+	};
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
+			Array.forEach(q, fn, s);
+		}else{
+			for(var i=0; i&lt;q.length; i++){
+				fn.call(s, q[i], i, q);
+			}
+		}
+	};
+	this.getByIndex=function(/* int */ i){
+		//	summary
+		//	return the item at index i
+		return q[i].valueOf();	//	object
+	};
+	this.getIterator=function(){
+		//	summary
+		//	get an iterator for this object
+		return new dojo.collections.DictionaryIterator(items);	//	dojo.collections.DictionaryIterator
+	};
+	this.getKey=function(/* int */ i){
+		//	summary
+		//	return the key of the item at index i
+		return q[i].key;
+	};
+	this.getKeyList=function(){
+		//	summary
+		//	return an array of the keys set in this list
+		var arr=[];
+		var e=this.getIterator();
+		while (!e.atEnd()){
+			arr.push(e.get().key);
+		}
+		return arr;	//	array
+	};
+	this.getValueList=function(){
+		//	summary
+		//	return an array of values in this list
+		var arr=[];
+		var e=this.getIterator();
+		while (!e.atEnd()){
+			arr.push(e.get().value);
+		}
+		return arr;	//	array
+	};
+	this.indexOfKey=function(/* string */ k){
+		//	summary
+		//	return the index of the passed key.
+		for (var i=0; i&lt;q.length; i++){
+			if (q[i].key==k){
+				return i;	//	int
+			}
+		}
+		return -1;	//	int
+	};
+	this.indexOfValue=function(/* object */ o){
+		//	summary
+		//	return the first index of object o
+		for (var i=0; i&lt;q.length; i++){
+			if (q[i].value==o){
+				return i;	//	int
+			}
+		}
+		return -1;	//	int
+	};
+	this.item=function(/* string */ k){
+		// 	summary
+		//	return the value of the object at location k.
+		if(k in items &amp;&amp; !testObject[k]){
+			return items[k].valueOf();	//	object
+		}
+		return undefined;	//	object
+	};
+	this.remove=function(/* string */k){
+		// 	summary
+		//	remove the item at location k and rebuild the internal collections.
+		delete items[k];
+		build();
+		this.count=q.length;
+	};
+	this.removeAt=function(/* int */ i){
+		//	summary
+		//	remove the item at index i, and rebuild the internal collections.
+		delete items[q[i].key];
+		build();
+		this.count=q.length;
+	};
+	this.replace=function(/* string */ k, /* object */ v){
+		//	summary
+		//	Replace an existing item if it's there, and add a new one if not.
+		if (!items[k]){
+			//	we're adding a new object, return false
+			this.add(k,v);
+			return false; // bool
+		}else{
+			//	we're replacing an object, return true
+			items[k]=new dojo.collections.DictionaryEntry(k,v);
+			q.sort(sorter);
+			return true; // bool
+		}
+	};
+	this.setByIndex=function(/* int */ i, /* object */ o){
+		//	summary
+		//	set an item by index
+		items[q[i].key].value=o;
+		build();
+		this.count=q.length;
+	};
+	if (dictionary){
+		var e=dictionary.getIterator();
+		while (!e.atEnd()){
+			var item=e.get();
+			q[q.length]=items[item.key]=new dojo.collections.DictionaryEntry(item.key,item.value);
+		}
+		q.sort(sorter);
+	}
+}

Added: trunk/root/static/magic/src/collections/Stack.js
===================================================================
--- trunk/root/static/magic/src/collections/Stack.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/Stack.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,85 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.collections.Stack&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+dojo.collections.Stack=function(/* array? */arr){
+	//	summary
+	//	returns an object of type dojo.collections.Stack
+	var q=[];
+	if (arr) q=q.concat(arr);
+	this.count=q.length;
+	this.clear=function(){
+		//	summary
+		//	Clear the internal array and reset the count
+		q=[];
+		this.count=q.length;
+	};
+	this.clone=function(){
+		//	summary
+		//	Create and return a clone of this Stack
+		return new dojo.collections.Stack(q);
+	};
+	this.contains=function(/* object */o){
+		//	summary
+		//	check to see if the stack contains object o
+		for (var i=0; i&lt;q.length; i++){
+			if (q[i] == o){
+				return true;	//	bool
+			}
+		}
+		return false;	//	bool
+	};
+	this.copyTo=function(/* array */ arr, /* int */ i){
+		//	summary
+		//	copy the stack into array arr at index i
+		arr.splice(i,0,q);
+	};
+	this.forEach=function(/* function */ fn, /* object? */ scope){
+		//	summary
+		//	functional iterator, following the mozilla spec.
+		var s=scope||dj_global;
+		if(Array.forEach){
+			Array.forEach(q, fn, s);
+		}else{
+			for(var i=0; i&lt;q.length; i++){
+				fn.call(s, q[i], i, q);
+			}
+		}
+	};
+	this.getIterator=function(){
+		//	summary
+		//	get an iterator for this collection
+		return new dojo.collections.Iterator(q);	//	dojo.collections.Iterator
+	};
+	this.peek=function(){
+		//	summary
+		//	Return the next item without altering the stack itself.
+		return q[(q.length-1)];	//	object
+	};
+	this.pop=function(){
+		//	summary
+		//	pop and return the next item on the stack
+		var r=q.pop();
+		this.count=q.length;
+		return r;	//	object
+	};
+	this.push=function(/* object */ o){
+		//	summary
+		//	Push object o onto the stack
+		this.count=q.push(o);
+	};
+	this.toArray=function(){
+		//	summary
+		//	create and return an array based on the internal collection
+		return [].concat(q);	//	array
+	};
+}

Added: trunk/root/static/magic/src/collections/__package__.js
===================================================================
--- trunk/root/static/magic/src/collections/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/collections/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.collections.Collections&quot;,
+		&quot;dojo.collections.SortedList&quot;, 
+		&quot;dojo.collections.Dictionary&quot;, 
+		&quot;dojo.collections.Queue&quot;, 
+		&quot;dojo.collections.ArrayList&quot;, 
+		&quot;dojo.collections.Stack&quot;,
+		&quot;dojo.collections.Set&quot;
+	]
+});
+dojo.provide(&quot;dojo.collections.*&quot;);

Added: trunk/root/static/magic/src/compat/0.2.2.js
===================================================================
--- trunk/root/static/magic/src/compat/0.2.2.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/compat/0.2.2.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,75 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+Compatibility package to get 0.2.2 functionality in later Dojo releases.
+*/
+
+//**********************************
+//From bootstrap1.js
+dj_throw = dj_rethrow = function(m, e){
+	dojo.deprecated(&quot;dj_throw and dj_rethrow&quot;, &quot;use dojo.raise instead&quot;, &quot;0.4&quot;);
+	dojo.raise(m, e);
+}
+
+dj_debug = dojo.debug;
+dj_unimplemented = dojo.unimplemented;
+dj_deprecated = dojo.deprecated;
+
+dj_inherits = function(subclass, superclass){
+	dojo.deprecated(&quot;dj_inherits&quot;, &quot;use dojo.inherits instead&quot;, &quot;0.4&quot;);
+	dojo.inherits(subclass, superclass);
+}
+
+/**
+* Set the base script uri.
+*/
+// In JScript .NET, see interface System._AppDomain implemented by
+// System.AppDomain.CurrentDomain. Members include AppendPrivatePath,
+// RelativeSearchPath, BaseDirectory.
+dojo.hostenv.setBaseScriptUri = function(uri){ djConfig.baseScriptUri = uri }
+
+//**********************************
+//From the old bootstrap2.js
+dojo.hostenv.moduleLoaded = function(){
+	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
+}
+
+dojo.hostenv.require = dojo.hostenv.loadModule;
+dojo.requireAfter = dojo.require;
+dojo.conditionalRequire = dojo.requireIf;
+
+dojo.requireAll = function() {
+	for(var i = 0; i &lt; arguments.length; i++) { dojo.require(arguments[i]); }
+}
+
+dojo.hostenv.conditionalLoadModule = function(){
+	dojo.kwCompoundRequire.apply(dojo, arguments);
+}
+
+dojo.hostenv.provide = dojo.hostenv.startPackage;
+
+//**********************************
+//From hostenv_browser.js
+dojo.hostenv.byId = dojo.byId;
+
+dojo.hostenv.byIdArray = dojo.byIdArray = function(){
+	var ids = [];
+	for(var i = 0; i &lt; arguments.length; i++){
+		if((arguments[i] instanceof Array)||(typeof arguments[i] == &quot;array&quot;)){
+			for(var j = 0; j &lt; arguments[i].length; j++){
+				ids = ids.concat(dojo.hostenv.byIdArray(arguments[i][j]));
+			}
+		}else{
+			ids.push(dojo.hostenv.byId(arguments[i]));
+		}
+	}
+	return ids;
+}

Added: trunk/root/static/magic/src/crypto/Blowfish.js
===================================================================
--- trunk/root/static/magic/src/crypto/Blowfish.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/Blowfish.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,548 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.crypto&quot;);
+dojo.provide(&quot;dojo.crypto.Blowfish&quot;);
+
+/*	Blowfish
+ *	Created based on the C# implementation by Marcus Hahn (<A HREF="http://www.hotpixel.net/">http://www.hotpixel.net/</A>)
+ *	Unsigned math functions derived from Joe Gregorio's SecureSyndication GM script
+ *	<A HREF="http://bitworking.org/projects/securesyndication/">http://bitworking.org/projects/securesyndication/</A>
+ *	(Note that this is *not* an adaption of the above script)
+ *
+ *	version 1.0 
+ *	TRT 
+ *	2005-12-08
+ */
+dojo.crypto.Blowfish = new function(){
+	var POW2=Math.pow(2,2);
+	var POW3=Math.pow(2,3);
+	var POW4=Math.pow(2,4);
+	var POW8=Math.pow(2,8);
+	var POW16=Math.pow(2,16);
+	var POW24=Math.pow(2,24);
+	var iv=null;	//	CBC mode initialization vector
+	var boxes={
+		p:[
+			0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89, 
+			0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917, 
+			0x9216d5d9, 0x8979fb1b
+		],
+		s0:[
+			0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
+			0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
+			0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
+			0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
+			0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
+			0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
+			0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
+			0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
+			0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
+			0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
+			0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98, 
+			0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe, 
+			0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d, 
+			0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
+			0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
+			0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
+			0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb, 
+			0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8, 
+			0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82, 
+			0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573, 
+			0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
+			0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8, 
+			0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
+			0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c, 
+			0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
+			0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
+			0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
+			0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
+			0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
+			0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
+			0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
+			0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
+		],
+		s1:[
+			0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
+			0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
+			0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
+			0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
+			0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
+			0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
+			0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
+			0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331, 
+			0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af, 
+			0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
+			0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2, 
+			0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
+			0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509, 
+			0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3, 
+			0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
+			0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960, 
+			0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
+			0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84, 
+			0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
+			0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e, 
+			0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7, 
+			0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281, 
+			0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
+			0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
+			0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0, 
+			0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
+			0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
+			0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
+			0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
+			0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
+			0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
+			0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
+		],
+		s2:[
+			0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
+			0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
+			0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
+			0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
+			0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
+			0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
+			0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
+			0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
+			0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
+			0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
+			0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
+			0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
+			0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
+			0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
+			0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
+			0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
+			0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
+			0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
+			0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
+			0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
+			0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc, 
+			0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
+			0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
+			0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c, 
+			0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633, 
+			0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169, 
+			0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027, 
+			0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
+			0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
+			0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc, 
+			0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
+			0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
+		],
+		s3:[
+			0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
+			0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
+			0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6, 
+			0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
+			0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6, 
+			0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59, 
+			0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
+			0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c, 
+			0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28, 
+			0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd, 
+			0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
+			0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f, 
+			0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32, 
+			0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166, 
+			0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
+			0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
+			0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d, 
+			0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
+			0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd, 
+			0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7, 
+			0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f, 
+			0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525, 
+			0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
+			0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e, 
+			0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
+			0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299, 
+			0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc, 
+			0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a, 
+			0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b, 
+			0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
+			0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
+			0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
+		]
+	}
+////////////////////////////////////////////////////////////////////////////
+	function add(x,y){
+		var sum=(x+y)&amp;0xffffffff;
+		if (sum&lt;0){
+			sum=-sum;
+			return (0x10000*((sum&gt;&gt;16)^0xffff))+(((sum&amp;0xffff)^0xffff)+1);
+		}
+		return sum;
+	}
+	function split(x){
+		var r=x&amp;0xffffffff;
+		if(r&lt;0) {
+			r=-r;
+			return [((r&amp;0xffff)^0xffff)+1,(r&gt;&gt;16)^0xffff];
+		}
+		return [r&amp;0xffff,(r&gt;&gt;16)];
+	}
+	function xor(x,y){
+		var xs=split(x);
+		var ys=split(y);
+		return (0x10000*(xs[1]^ys[1]))+(xs[0]^ys[0]);
+	}
+	function $(v, box){
+		var d=v&amp;0xff; v&gt;&gt;=8;
+		var c=v&amp;0xff; v&gt;&gt;=8;
+		var b=v&amp;0xff; v&gt;&gt;=8;
+		var a=v&amp;0xff;
+		var r=add(box.s0[a],box.s1[b]);
+		r=xor(r,box.s2[c]);
+		return add(r,box.s3[d]);
+	}
+////////////////////////////////////////////////////////////////////////////
+	function eb(o, box){
+		var l=o.left;
+		var r=o.right;
+		l=xor(l,box.p[0]);
+		r=xor(r,xor($(l,box),box.p[1]));
+		l=xor(l,xor($(r,box),box.p[2]));
+		r=xor(r,xor($(l,box),box.p[3]));
+		l=xor(l,xor($(r,box),box.p[4]));
+		r=xor(r,xor($(l,box),box.p[5]));
+		l=xor(l,xor($(r,box),box.p[6]));
+		r=xor(r,xor($(l,box),box.p[7]));
+		l=xor(l,xor($(r,box),box.p[8]));
+		r=xor(r,xor($(l,box),box.p[9]));
+		l=xor(l,xor($(r,box),box.p[10]));
+		r=xor(r,xor($(l,box),box.p[11]));
+		l=xor(l,xor($(r,box),box.p[12]));
+		r=xor(r,xor($(l,box),box.p[13]));
+		l=xor(l,xor($(r,box),box.p[14]));
+		r=xor(r,xor($(l,box),box.p[15]));
+		l=xor(l,xor($(r,box),box.p[16]));
+		o.right=l;
+		o.left=xor(r,box.p[17]);
+	}
+
+	function db(o, box){
+		var l=o.left;
+		var r=o.right;
+		l=xor(l,box.p[17]);
+		r=xor(r,xor($(l,box),box.p[16]));
+		l=xor(l,xor($(r,box),box.p[15]));
+		r=xor(r,xor($(l,box),box.p[14]));
+		l=xor(l,xor($(r,box),box.p[13]));
+		r=xor(r,xor($(l,box),box.p[12]));
+		l=xor(l,xor($(r,box),box.p[11]));
+		r=xor(r,xor($(l,box),box.p[10]));
+		l=xor(l,xor($(r,box),box.p[9]));
+		r=xor(r,xor($(l,box),box.p[8]));
+		l=xor(l,xor($(r,box),box.p[7]));
+		r=xor(r,xor($(l,box),box.p[6]));
+		l=xor(l,xor($(r,box),box.p[5]));
+		r=xor(r,xor($(l,box),box.p[4]));
+		l=xor(l,xor($(r,box),box.p[3]));
+		r=xor(r,xor($(l,box),box.p[2]));
+		l=xor(l,xor($(r,box),box.p[1]));
+		o.right=l;
+		o.left=xor(r,box.p[0]);
+	}
+
+	//	Note that we aren't caching contexts here; it might take a little longer
+	//	but we should be more secure this way.
+	function init(key){
+		var k=key;
+		if (typeof(k)==&quot;string&quot;){
+			var a=[];
+			for(var i=0; i&lt;k.length; i++) 
+				a.push(k.charCodeAt(i)&amp;0xff);
+			k=a;
+		}
+		//	init the boxes
+		var box = { p:[], s0:[], s1:[], s2:[], s3:[] };
+		for(var i=0; i&lt;boxes.p.length; i++) box.p.push(boxes.p[i]);
+		for(var i=0; i&lt;boxes.s0.length; i++) box.s0.push(boxes.s0[i]);
+		for(var i=0; i&lt;boxes.s1.length; i++) box.s1.push(boxes.s1[i]);
+		for(var i=0; i&lt;boxes.s2.length; i++) box.s2.push(boxes.s2[i]);
+		for(var i=0; i&lt;boxes.s3.length; i++) box.s3.push(boxes.s3[i]);
+
+		//	init p with the key
+		var pos=0;
+		var data=0;
+		for(var i=0; i &lt; box.p.length; i++){
+			for (var j=0; j&lt;4; j++){
+				data = (data*POW8) | k[pos];
+				if(++pos==k.length) pos=0;
+			}
+			box.p[i] = xor(box.p[i], data);
+		}
+
+		//	encrypt p and the s boxes
+		var res={ left:0, right:0 };
+		for(var i=0; i&lt;box.p.length;){
+			eb(res, box);
+			box.p[i++]=res.left;
+			box.p[i++]=res.right;
+		}
+		for (var i=0; i&lt;4; i++){
+			for(var j=0; j&lt;box[&quot;s&quot;+i].length;){
+				eb(res, box);
+				box[&quot;s&quot;+i][j++]=res.left;
+				box[&quot;s&quot;+i][j++]=res.right;
+			}
+		}
+		return box;
+	}
+
+////////////////////////////////////////////////////////////////////////////
+//	CONVERSION FUNCTIONS
+////////////////////////////////////////////////////////////////////////////
+	//	these operate on byte arrays, NOT word arrays.
+	function toBase64(ba){ 
+		var p=&quot;=&quot;;
+		var tab=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
+		var s=[];
+		var count=0;
+		for (var i =0; i&lt;ba.length;){
+			var t=ba[i++]&lt;&lt;16|ba[i++]&lt;&lt;8|ba[i++];
+			s.push(tab.charAt((t&gt;&gt;&gt;18)&amp;0x3f)); 
+			s.push(tab.charAt((t&gt;&gt;&gt;12)&amp;0x3f));
+			s.push(tab.charAt((t&gt;&gt;&gt;6)&amp;0x3f));
+			s.push(tab.charAt(t&amp;0x3f));
+			count+=4;
+		}
+		var pa=i-ba.length;
+		while((pa--)&gt;0)	s.push(p);	
+		return s.join(&quot;&quot;);
+	}
+	function fromBase64(str){
+		var s=str.split(&quot;&quot;);
+		var p=&quot;=&quot;;
+		var tab=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
+		var out=[];
+		var l=s.length;
+		while(s[--l]==p){ }
+		for (var i=0; i&lt;l;){
+			var t=tab.indexOf(s[i++])&lt;&lt;18|tab.indexOf(s[i++])&lt;&lt;12|tab.indexOf(s[i++])&lt;&lt;6|tab.indexOf(s[i++]);
+			out.push((t&gt;&gt;&gt;16)&amp;0xff);
+			out.push((t&gt;&gt;&gt;8)&amp;0xff);
+			out.push(t&amp;0xff);
+		}
+		return out;
+	}
+////////////////////////////////////////////////////////////////////////////
+//	PUBLIC FUNCTIONS
+//	0.2: Only supporting ECB mode for now.
+////////////////////////////////////////////////////////////////////////////
+	this.getIV=function(outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				var s=[];
+				for(var i=0; i&lt;iv.length; i++)
+					s.push((iv[i]).toString(16));
+				return s.join(&quot;&quot;);
+			}
+			case dojo.crypto.outputTypes.String:{
+				return iv.join(&quot;&quot;);
+			}
+			case dojo.crypto.outputTypes.Raw:{
+				return iv;
+			}
+			default:{
+				return toBase64(iv);
+			}
+		}
+	};
+	this.setIV=function(data, inputType){
+		var ip=inputType||dojo.crypto.outputTypes.Base64;
+		var ba=null;
+		switch(ip){
+			case dojo.crypto.outputTypes.String:{
+				ba=[];
+				for (var i=0; i&lt;data.length; i++){
+					ba.push(data.charCodeAt(i));
+				}
+				break;
+			}
+			case dojo.crypto.outputTypes.Hex:{
+				ba=[];
+				var i=0;
+				while (i+1&lt;data.length){
+					ba.push(parseInt(data.substr(i,2),16));
+					i+=2;
+				}
+				break;
+			}
+			case dojo.crypto.outputTypes.Raw:{
+				ba=data;
+				break;
+			}
+			default:{
+				ba=fromBase64(data);
+				break;
+			}
+		}
+		//	make it a pair of words now
+		iv={};
+		iv.left=ba[0]*POW24|ba[1]*POW16|ba[2]*POW8|ba[3];
+		iv.right=ba[4]*POW24|ba[5]*POW16|ba[6]*POW8|ba[7];
+	}
+	this.encrypt = function(plaintext, key, ao){
+		var out=dojo.crypto.outputTypes.Base64;
+		var mode=dojo.crypto.cipherModes.EBC;
+		if (ao){
+			if (ao.outputType) out=ao.outputType;
+			if (ao.cipherMode) mode=ao.cipherMode;
+		}
+
+		var bx = init(key);
+		var padding = 8-(plaintext.length&amp;7);
+		for (var i=0; i&lt;padding; i++) plaintext+=String.fromCharCode(padding);
+		var cipher=[];
+		var count=plaintext.length &gt;&gt; 3;
+		var pos=0;
+		var o={};
+		var isCBC=(mode==dojo.crypto.cipherModes.CBC);
+		var vector={left:iv.left||null, right:iv.right||null};
+		for(var i=0; i&lt;count; i++){
+			o.left=plaintext.charCodeAt(pos)*POW24
+				|plaintext.charCodeAt(pos+1)*POW16
+				|plaintext.charCodeAt(pos+2)*POW8
+				|plaintext.charCodeAt(pos+3);
+			o.right=plaintext.charCodeAt(pos+4)*POW24
+				|plaintext.charCodeAt(pos+5)*POW16
+				|plaintext.charCodeAt(pos+6)*POW8
+				|plaintext.charCodeAt(pos+7);
+
+			if(isCBC){
+				o.left=xor(o.left, vector.left);
+				o.right=xor(o.right, vector.right);
+			}
+
+			eb(o, bx);	//	encrypt the block
+
+			if(isCBC){
+				vector.left=o.left;
+				vector.right=o.right;dojo.crypto.outputTypes.Hex
+			}
+
+			cipher.push((o.left&gt;&gt;24)&amp;0xff); 
+			cipher.push((o.left&gt;&gt;16)&amp;0xff); 
+			cipher.push((o.left&gt;&gt;8)&amp;0xff);
+			cipher.push(o.left&amp;0xff);
+			cipher.push((o.right&gt;&gt;24)&amp;0xff); 
+			cipher.push((o.right&gt;&gt;16)&amp;0xff); 
+			cipher.push((o.right&gt;&gt;8)&amp;0xff);
+			cipher.push(o.right&amp;0xff);
+			pos+=8;
+		}
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				var s=[];
+				for(var i=0; i&lt;cipher.length; i++)
+					s.push((cipher[i]).toString(16));
+				return s.join(&quot;&quot;);
+			}
+			case dojo.crypto.outputTypes.String:{
+				return cipher.join(&quot;&quot;);
+			}
+			case dojo.crypto.outputTypes.Raw:{
+				return cipher;
+			}
+			default:{
+				return toBase64(cipher);
+			}
+		}
+	};
+
+	this.decrypt = function(ciphertext, key, ao){
+		var ip=dojo.crypto.outputTypes.Base64;
+		var mode=dojo.crypto.cipherModes.EBC;
+		if (ao){
+			if (ao.outputType) ip=ao.outputType;
+			if (ao.cipherMode) mode=ao.cipherMode;
+		}
+		var bx = init(key);
+		var pt=[];
+	
+		var c=null;
+		switch(ip){
+			case dojo.crypto.outputTypes.Hex:{
+				c=[];
+				var i=0;
+				while (i+1&lt;ciphertext.length){
+					c.push(parseInt(ciphertext.substr(i,2),16));
+					i+=2;
+				}
+				break;
+			}
+			case dojo.crypto.outputTypes.String:{
+				c=[];
+				for (var i=0; i&lt;ciphertext.length; i++){
+					c.push(ciphertext.charCodeAt(i));
+				}
+				break;
+			}
+			case dojo.crypto.outputTypes.Raw:{
+				c=ciphertext;	//	should be a byte array
+				break;
+			}
+			default:{
+				c=fromBase64(ciphertext);
+				break;
+			}
+		}
+
+		var count=c.length &gt;&gt; 3;
+		var pos=0;
+		var o={};
+		var isCBC=(mode==dojo.crypto.cipherModes.CBC);
+		var vector={left:iv.left||null, right:iv.right||null};
+		for(var i=0; i&lt;count; i++){
+			o.left=c[pos]*POW24|c[pos+1]*POW16|c[pos+2]*POW8|c[pos+3];
+			o.right=c[pos+4]*POW24|c[pos+5]*POW16|c[pos+6]*POW8|c[pos+7];
+
+			if(isCBC){
+				var left=o.left;
+				var right=o.right;
+			}
+
+			db(o, bx);	//	decrypt the block
+
+			if(isCBC){
+				o.left=xor(o.left, vector.left);
+				o.right=xor(o.right, vector.right);
+				vector.left=left;
+				vector.right=right;
+			}
+
+			pt.push((o.left&gt;&gt;24)&amp;0xff);
+			pt.push((o.left&gt;&gt;16)&amp;0xff);
+			pt.push((o.left&gt;&gt;8)&amp;0xff);
+			pt.push(o.left&amp;0xff);
+			pt.push((o.right&gt;&gt;24)&amp;0xff);
+			pt.push((o.right&gt;&gt;16)&amp;0xff);
+			pt.push((o.right&gt;&gt;8)&amp;0xff);
+			pt.push(o.right&amp;0xff);
+			pos+=8;
+		}
+
+		//	check for padding, and remove.
+		if(pt[pt.length-1]==pt[pt.length-2]||pt[pt.length-1]==0x01){
+			var n=pt[pt.length-1];
+			pt.splice(pt.length-n, n);
+		}
+
+		//	convert to string
+		for(var i=0; i&lt;pt.length; i++)
+			pt[i]=String.fromCharCode(pt[i]);
+		return pt.join(&quot;&quot;);
+	};
+
+	this.setIV(&quot;0000000000000000&quot;, dojo.crypto.outputTypes.Hex);
+}();

Added: trunk/root/static/magic/src/crypto/LICENSE
===================================================================
--- trunk/root/static/magic/src/crypto/LICENSE	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/LICENSE	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,11 @@
+License Disclaimer:
+
+All contents of this directory are Copyright (c) the Dojo Foundation, with the
+following exceptions:
+-------------------------------------------------------------------------------
+
+MD5.js, SHA1.js:
+	* Copyright 1998-2005, Paul Johnstone
+	  Distributed under the terms of the BSD License
+
+

Added: trunk/root/static/magic/src/crypto/MD5.js
===================================================================
--- trunk/root/static/magic/src/crypto/MD5.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/MD5.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,193 @@
+dojo.require(&quot;dojo.crypto&quot;);
+dojo.provide(&quot;dojo.crypto.MD5&quot;);
+
+/*	Return to a port of Paul Johnstone's MD5 implementation
+ *	<A HREF="http://pajhome.org.uk/crypt/md5/index.html">http://pajhome.org.uk/crypt/md5/index.html</A>
+ *
+ *	Copyright (C) Paul Johnston 1999 - 2002.
+ *	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
+ * 	Distributed under the BSD License
+ *
+ *	Dojo port by Tom Trenka
+ *
+ *	2005-12-7
+ *	All conversions are internalized (no dependencies)
+ *	implemented getHMAC for message digest auth.
+ */
+dojo.crypto.MD5 = new function(){
+	var chrsz=8;
+	var mask=(1&lt;&lt;chrsz)-1;
+	function toWord(s) {
+	  var wa=[];
+	  for(var i=0; i&lt;s.length*chrsz; i+=chrsz)
+		wa[i&gt;&gt;5]|=(s.charCodeAt(i/chrsz)&amp;mask)&lt;&lt;(i%32);
+	  return wa;
+	}
+	function toString(wa){
+		var s=[];
+		for(var i=0; i&lt;wa.length*32; i+=chrsz)
+			s.push(String.fromCharCode((wa[i&gt;&gt;5]&gt;&gt;&gt;(i%32))&amp;mask));
+		return s.join(&quot;&quot;);
+	}
+	function toHex(wa) {
+		var h=&quot;0123456789abcdef&quot;;
+		var s=[];
+		for(var i=0; i&lt;wa.length*4; i++){
+			s.push(h.charAt((wa[i&gt;&gt;2]&gt;&gt;((i%4)*8+4))&amp;0xF)+h.charAt((wa[i&gt;&gt;2]&gt;&gt;((i%4)*8))&amp;0xF));
+		}
+		return s.join(&quot;&quot;);
+	}
+	function toBase64(wa){
+		var p=&quot;=&quot;;
+		var tab=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
+		var s=[];
+		for(var i=0; i&lt;wa.length*4; i+=3){
+			var t=(((wa[i&gt;&gt;2]&gt;&gt;8*(i%4))&amp;0xFF)&lt;&lt;16)|(((wa[i+1&gt;&gt;2]&gt;&gt;8*((i+1)%4))&amp;0xFF)&lt;&lt;8)|((wa[i+2&gt;&gt;2]&gt;&gt;8*((i+2)%4))&amp;0xFF);
+			for(var j=0; j&lt;4; j++){
+				if(i*8+j*6&gt;wa.length*32) s.push(p);
+				else s.push(tab.charAt((t&gt;&gt;6*(3-j))&amp;0x3F));
+			}
+		}
+		return s.join(&quot;&quot;);
+	}
+	function add(x,y) {
+		var l=(x&amp;0xFFFF)+(y&amp;0xFFFF);
+		var m=(x&gt;&gt;16)+(y&gt;&gt;16)+(l&gt;&gt;16);
+		return (m&lt;&lt;16)|(l&amp;0xFFFF);
+	}
+	function R(n,c){ return (n&lt;&lt;c)|(n&gt;&gt;&gt;(32-c)); }
+	function C(q,a,b,x,s,t){ return add(R(add(add(a,q),add(x,t)),s),b); }
+	function FF(a,b,c,d,x,s,t){ return C((b&amp;c)|((~b)&amp;d),a,b,x,s,t); }
+	function GG(a,b,c,d,x,s,t){ return C((b&amp;d)|(c&amp;(~d)),a,b,x,s,t); }
+	function HH(a,b,c,d,x,s,t){ return C(b^c^d,a,b,x,s,t); }
+	function II(a,b,c,d,x,s,t){ return C(c^(b|(~d)),a,b,x,s,t); }
+	function core(x,len){
+		x[len&gt;&gt;5]|=0x80&lt;&lt;((len)%32);
+		x[(((len+64)&gt;&gt;&gt;9)&lt;&lt;4)+14]=len;
+		var a= 1732584193;
+		var b=-271733879;
+		var c=-1732584194;
+		var d= 271733878;
+		for(var i=0; i&lt;x.length; i+=16){
+			var olda=a;
+			var oldb=b;
+			var oldc=c;
+			var oldd=d;
+
+			a=FF(a,b,c,d,x[i+ 0],7 ,-680876936);
+			d=FF(d,a,b,c,x[i+ 1],12,-389564586);
+			c=FF(c,d,a,b,x[i+ 2],17, 606105819);
+			b=FF(b,c,d,a,x[i+ 3],22,-1044525330);
+			a=FF(a,b,c,d,x[i+ 4],7 ,-176418897);
+			d=FF(d,a,b,c,x[i+ 5],12, 1200080426);
+			c=FF(c,d,a,b,x[i+ 6],17,-1473231341);
+			b=FF(b,c,d,a,x[i+ 7],22,-45705983);
+			a=FF(a,b,c,d,x[i+ 8],7 , 1770035416);
+			d=FF(d,a,b,c,x[i+ 9],12,-1958414417);
+			c=FF(c,d,a,b,x[i+10],17,-42063);
+			b=FF(b,c,d,a,x[i+11],22,-1990404162);
+			a=FF(a,b,c,d,x[i+12],7 , 1804603682);
+			d=FF(d,a,b,c,x[i+13],12,-40341101);
+			c=FF(c,d,a,b,x[i+14],17,-1502002290);
+			b=FF(b,c,d,a,x[i+15],22, 1236535329);
+
+			a=GG(a,b,c,d,x[i+ 1],5 ,-165796510);
+			d=GG(d,a,b,c,x[i+ 6],9 ,-1069501632);
+			c=GG(c,d,a,b,x[i+11],14, 643717713);
+			b=GG(b,c,d,a,x[i+ 0],20,-373897302);
+			a=GG(a,b,c,d,x[i+ 5],5 ,-701558691);
+			d=GG(d,a,b,c,x[i+10],9 , 38016083);
+			c=GG(c,d,a,b,x[i+15],14,-660478335);
+			b=GG(b,c,d,a,x[i+ 4],20,-405537848);
+			a=GG(a,b,c,d,x[i+ 9],5 , 568446438);
+			d=GG(d,a,b,c,x[i+14],9 ,-1019803690);
+			c=GG(c,d,a,b,x[i+ 3],14,-187363961);
+			b=GG(b,c,d,a,x[i+ 8],20, 1163531501);
+			a=GG(a,b,c,d,x[i+13],5 ,-1444681467);
+			d=GG(d,a,b,c,x[i+ 2],9 ,-51403784);
+			c=GG(c,d,a,b,x[i+ 7],14, 1735328473);
+			b=GG(b,c,d,a,x[i+12],20,-1926607734);
+
+			a=HH(a,b,c,d,x[i+ 5],4 ,-378558);
+			d=HH(d,a,b,c,x[i+ 8],11,-2022574463);
+			c=HH(c,d,a,b,x[i+11],16, 1839030562);
+			b=HH(b,c,d,a,x[i+14],23,-35309556);
+			a=HH(a,b,c,d,x[i+ 1],4 ,-1530992060);
+			d=HH(d,a,b,c,x[i+ 4],11, 1272893353);
+			c=HH(c,d,a,b,x[i+ 7],16,-155497632);
+			b=HH(b,c,d,a,x[i+10],23,-1094730640);
+			a=HH(a,b,c,d,x[i+13],4 , 681279174);
+			d=HH(d,a,b,c,x[i+ 0],11,-358537222);
+			c=HH(c,d,a,b,x[i+ 3],16,-722521979);
+			b=HH(b,c,d,a,x[i+ 6],23, 76029189);
+			a=HH(a,b,c,d,x[i+ 9],4 ,-640364487);
+			d=HH(d,a,b,c,x[i+12],11,-421815835);
+			c=HH(c,d,a,b,x[i+15],16, 530742520);
+			b=HH(b,c,d,a,x[i+ 2],23,-995338651);
+
+			a=II(a,b,c,d,x[i+ 0],6 ,-198630844);
+			d=II(d,a,b,c,x[i+ 7],10, 1126891415);
+			c=II(c,d,a,b,x[i+14],15,-1416354905);
+			b=II(b,c,d,a,x[i+ 5],21,-57434055);
+			a=II(a,b,c,d,x[i+12],6 , 1700485571);
+			d=II(d,a,b,c,x[i+ 3],10,-1894986606);
+			c=II(c,d,a,b,x[i+10],15,-1051523);
+			b=II(b,c,d,a,x[i+ 1],21,-2054922799);
+			a=II(a,b,c,d,x[i+ 8],6 , 1873313359);
+			d=II(d,a,b,c,x[i+15],10,-30611744);
+			c=II(c,d,a,b,x[i+ 6],15,-1560198380);
+			b=II(b,c,d,a,x[i+13],21, 1309151649);
+			a=II(a,b,c,d,x[i+ 4],6 ,-145523070);
+			d=II(d,a,b,c,x[i+11],10,-1120210379);
+			c=II(c,d,a,b,x[i+ 2],15, 718787259);
+			b=II(b,c,d,a,x[i+ 9],21,-343485551);
+
+			a = add(a,olda);
+			b = add(b,oldb);
+			c = add(c,oldc);
+			d = add(d,oldd);
+		}
+		return [a,b,c,d];
+	}
+	function hmac(data,key){
+		var wa=toWord(key);
+		if(wa.length&gt;16) wa=core(wa,key.length*chrsz);
+		var l=[], r=[];
+		for(var i=0; i&lt;16; i++){
+			l[i]=wa[i]^0x36363636;
+			r[i]=wa[i]^0x5c5c5c5c;
+		}
+		var h=core(l.concat(toWord(data)),512+data.length*chrsz);
+		return core(r.concat(h),640);
+	}
+
+	//	Public functions
+	this.compute=function(data,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(core(toWord(data),data.length*chrsz));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(core(toWord(data),data.length*chrsz));
+			}
+			default:{
+				return toBase64(core(toWord(data),data.length*chrsz));
+			}
+		}
+	};
+	this.getHMAC=function(data,key,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(hmac(data,key));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(hmac(data,key));
+			}
+			default:{
+				return toBase64(hmac(data,key));
+			}
+		}
+	};
+}();

Added: trunk/root/static/magic/src/crypto/Rijndael.js
===================================================================
--- trunk/root/static/magic/src/crypto/Rijndael.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/Rijndael.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.crypto.Rijndael&quot;);
+dojo.require(&quot;dojo.crypto&quot;);
+dojo.require(&quot;dojo.experimental&quot;);
+
+dojo.experimental(&quot;dojo.crypto.Rijndael&quot;);
+
+dojo.crypto.Rijndael = new function(){
+	this.encrypt=function(plaintext, key){
+	};
+	this.decrypt=function(ciphertext, key){
+	};
+}();

Added: trunk/root/static/magic/src/crypto/SHA1.js
===================================================================
--- trunk/root/static/magic/src/crypto/SHA1.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/SHA1.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,154 @@
+dojo.require(&quot;dojo.crypto&quot;);
+dojo.provide(&quot;dojo.crypto.SHA1&quot;);
+dojo.require(&quot;dojo.experimental&quot;);
+
+/*
+ *	A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
+ *	in FIPS PUB 180-1
+ *
+ * 	Version 2.1a Copyright Paul Johnston 2000 - 2002.
+ * 	Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
+ * 	Distributed under the BSD License
+ * 	See <A HREF="http://pajhome.org.uk/crypt/md5">http://pajhome.org.uk/crypt/md5</A> for details.
+ *
+ *	Dojo port by Tom Trenka
+ */
+dojo.experimental(&quot;dojo.crypto.SHA1&quot;);
+
+dojo.crypto.SHA1 = new function(){
+	var chrsz=8;
+	var mask=(1&lt;&lt;chrsz)-1;
+	function toWord(s) {
+	  var wa=[];
+	  for(var i=0; i&lt;s.length*chrsz; i+=chrsz)
+		wa[i&gt;&gt;5]|=(s.charCodeAt(i/chrsz)&amp;mask)&lt;&lt;(i%32);
+	  return wa;
+	}
+	function toString(wa){
+		var s=[];
+		for(var i=0; i&lt;wa.length*32; i+=chrsz)
+			s.push(String.fromCharCode((wa[i&gt;&gt;5]&gt;&gt;&gt;(i%32))&amp;mask));
+		return s.join(&quot;&quot;);
+	}
+	function toHex(wa) {
+		var h=&quot;0123456789abcdef&quot;;
+		var s=[];
+		for(var i=0; i&lt;wa.length*4; i++){
+			s.push(h.charAt((wa[i&gt;&gt;2]&gt;&gt;((i%4)*8+4))&amp;0xF)+h.charAt((wa[i&gt;&gt;2]&gt;&gt;((i%4)*8))&amp;0xF));
+		}
+		return s.join(&quot;&quot;);
+	}
+	function toBase64(wa){
+		var p=&quot;=&quot;;
+		var tab=&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;;
+		var s=[];
+		for(var i=0; i&lt;wa.length*4; i+=3){
+			var t=(((wa[i&gt;&gt;2]&gt;&gt;8*(i%4))&amp;0xFF)&lt;&lt;16)|(((wa[i+1&gt;&gt;2]&gt;&gt;8*((i+1)%4))&amp;0xFF)&lt;&lt;8)|((wa[i+2&gt;&gt;2]&gt;&gt;8*((i+2)%4))&amp;0xFF);
+			for(var j=0; j&lt;4; j++){
+				if(i*8+j*6&gt;wa.length*32) s.push(p);
+				else s.push(tab.charAt((t&gt;&gt;6*(3-j))&amp;0x3F));
+			}
+		}
+		return s.join(&quot;&quot;);
+	}
+
+	//	math
+	function add(x,y){
+		var l=(x&amp;0xffff)+(y&amp;0xffff);
+		var m=(x&gt;&gt;16)+(y&gt;&gt;16)+(l&gt;&gt;16);
+		return (m&lt;&lt;16)|(l&amp;0xffff);
+	}
+	function r(x,n){  return (x&lt;&lt;n)|(x&gt;&gt;&gt;(32-n)); }
+	
+	//	SHA rounds
+	function f(u,v,w){ return ((u&amp;v)|(~u&amp;w)); }
+	function g(u,v,w){ return ((u&amp;v)|(u&amp;w)|(v&amp;w)); }
+	function h(u,v,w){ return (u^v^w); }
+	
+	function fn(i,u,v,w){
+		if(i&lt;20) return f(u,v,w);
+		if(i&lt;40) return h(u,v,w);
+		if(i&lt;60) return g(u,v,w);
+		return h(u,v,w);
+	}
+	function cnst(i){
+		if(i&lt;20) return 1518500249;
+		if(i&lt;40) return 1859775393;
+		if(i&lt;60) return -1894007588;
+		return -899497514;
+	}
+
+	function core(x,len){
+		x[len&gt;&gt;5]|=0x80&lt;&lt;(24-len%32);
+		x[((len+64&gt;&gt;9)&lt;&lt;4)+15]=len;
+
+		var w=[];
+		var a= 1732584193;		//	0x67452301
+		var b=-271733879;		//	0xefcdab89
+		var c=-1732584194;		//	0x98badcfe
+		var d= 271733878;		//	0x10325476
+		var e=-1009589776;		//	0xc3d2e1f0
+		
+		for(var i=0; i&lt;x.length; i+=16){
+			var olda=a;
+			var oldb=b;
+			var oldc=c;
+			var oldd=d;
+			var olde=e;
+
+			for(var j=0; j&lt;80; j++){
+				if(j&lt;16) w[j]=x[i+j];
+				else w[j]=r(w[j-3]^w[j-8]^w[j-14]^w[j-16],1);
+				var t=add(add(r(a,5),fn(j,b,c,d)),add(add(e,w[j]),cnst(j)));
+				e=d; d=c; c=r(b,30); b=a; a=t;
+			}
+
+			a=add(a,olda);
+			b=add(b,oldb);
+			c=add(c,oldc);
+			d=add(d,oldd);
+			e=add(e,olde);
+		}
+		return [a,b,c,d,e];
+	}
+	function hmac(data,key){
+		var wa=toWord(key);
+		if(wa.length&gt;16) wa=core(wa,key.length*chrsz);
+		var l=[], r=[];
+		for(var i=0; i&lt;16; i++){
+			l[i]=wa[i]^0x36363636;
+			r[i]=wa[i]^0x5c5c5c5c;
+		}
+		var h=core(l.concat(toWord(data)),512+data.length*chrsz);
+		return core(r.concat(h),640);
+	}
+
+	this.compute=function(data,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(core(toWord(data),data.length*chrsz));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(core(toWord(data),data.length*chrsz));
+			}
+			default:{
+				return toBase64(core(toWord(data),data.length*chrsz));
+			}
+		}
+	};
+	this.getHMAC=function(data,key,outputType){
+		var out=outputType||dojo.crypto.outputTypes.Base64;
+		switch(out){
+			case dojo.crypto.outputTypes.Hex:{
+				return toHex(hmac(data,key));
+			}
+			case dojo.crypto.outputTypes.String:{
+				return toString(hmac(data,key));
+			}
+			default:{
+				return toBase64(hmac(data,key));
+			}
+		}
+	};
+}();

Added: trunk/root/static/magic/src/crypto/SHA256.js
===================================================================
--- trunk/root/static/magic/src/crypto/SHA256.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/SHA256.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,20 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.crypto.SHA256&quot;);
+dojo.require(&quot;dojo.crypto&quot;);
+dojo.require(&quot;dojo.experimental&quot;);
+
+dojo.experimental(&quot;dojo.crypto.SHA256&quot;);
+
+dojo.crypto.SHA256 = new function(){
+	this.compute=function(s){
+	};
+}();

Added: trunk/root/static/magic/src/crypto/__package__.js
===================================================================
--- trunk/root/static/magic/src/crypto/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,17 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.crypto&quot;,
+		&quot;dojo.crypto.MD5&quot;
+	]
+});
+dojo.provide(&quot;dojo.crypto.*&quot;);

Added: trunk/root/static/magic/src/crypto.js
===================================================================
--- trunk/root/static/magic/src/crypto.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/crypto.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.crypto&quot;);
+
+//	enumerations for use in crypto code. Note that 0 == default, for the most part.
+dojo.crypto.cipherModes={ ECB:0, CBC:1, PCBC:2, CFB:3, OFB:4, CTR:5 };
+dojo.crypto.outputTypes={ Base64:0,Hex:1,String:2,Raw:3 };

Added: trunk/root/static/magic/src/data/Attribute.js
===================================================================
--- trunk/root/static/magic/src/data/Attribute.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/Attribute.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,62 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.Attribute&quot;);
+dojo.require(&quot;dojo.data.Item&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Attribute = function(/* dojo.data.provider.Base */ dataProvider, /* string */ attributeId) {
+	/**
+	 * summary:
+	 * An Attribute object represents something like a column in 
+	 * a relational database.
+	 */
+	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, &quot;optional&quot;]);
+	dojo.lang.assertType(attributeId, String);
+	dojo.data.Item.call(this, dataProvider);
+	this._attributeId = attributeId;
+};
+dojo.inherits(dojo.data.Attribute, dojo.data.Item);
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Attribute.prototype.toString = function() {
+	return this._attributeId; // string
+};
+
+dojo.data.Attribute.prototype.getAttributeId = function() {
+	/**
+	 * summary: 
+	 * Returns the string token that uniquely identifies this
+	 * attribute within the context of a data provider.
+	 * For a data provider that accesses relational databases,
+	 * typical attributeIds might be tokens like &quot;name&quot;, &quot;age&quot;, 
+	 * &quot;ssn&quot;, or &quot;dept_key&quot;.
+	 */ 
+	return this._attributeId; // string
+};
+
+dojo.data.Attribute.prototype.getType = function() {
+	/**
+	 * summary: Returns the data type of the values of this attribute.
+	 */ 
+	return this.get('type'); // dojo.data.Type or null
+};
+
+dojo.data.Attribute.prototype.setType = function(/* dojo.data.Type or null */ type) {
+	/**
+	 * summary: Sets the data type for this attribute.
+	 */ 
+	this.set('type', type);
+};

Added: trunk/root/static/magic/src/data/Item.js
===================================================================
--- trunk/root/static/magic/src/data/Item.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/Item.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,332 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.Item&quot;);
+dojo.require(&quot;dojo.data.Observable&quot;);
+dojo.require(&quot;dojo.data.Value&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Item = function(/* dojo.data.provider.Base */ dataProvider) {
+	/**
+	 * summary:
+	 * An Item has attributes and attribute values, sort of like 
+	 * a record in a database, or a 'struct' in C.  Instances of
+	 * the Item class know how to store and retrieve their
+	 * attribute values.
+	 */
+	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, &quot;optional&quot;]);
+	dojo.data.Observable.call(this);
+	this._dataProvider = dataProvider;
+	this._dictionaryOfAttributeValues = {};
+};
+dojo.inherits(dojo.data.Item, dojo.data.Observable);
+
+// -------------------------------------------------------------------
+// Public class methods
+// -------------------------------------------------------------------
+dojo.data.Item.compare = function(/* dojo.data.Item */ itemOne, /* dojo.data.Item */ itemTwo) {
+	/**
+	 * summary:
+	 * Given two Items to compare, this method returns 0, 1, or -1.
+	 * This method is designed to be used by sorting routines, like
+	 * the JavaScript built-in Array sort() method.
+	 * 
+	 * Example:
+	 * &lt;pre&gt;
+	 *   var a = dataProvider.newItem(&quot;kermit&quot;);
+	 *   var b = dataProvider.newItem(&quot;elmo&quot;);
+	 *   var c = dataProvider.newItem(&quot;grover&quot;);
+	 *   var array = new Array(a, b, c);
+	 *   array.sort(dojo.data.Item.compare);
+	 * &lt;/pre&gt;
+	 */
+	dojo.lang.assertType(itemOne, dojo.data.Item);
+	if (!dojo.lang.isOfType(itemTwo, dojo.data.Item)) {
+		return -1;
+	}
+	var nameOne = itemOne.getName();
+	var nameTwo = itemTwo.getName();
+	if (nameOne == nameTwo) {
+		var attributeArrayOne = itemOne.getAttributes();
+		var attributeArrayTwo = itemTwo.getAttributes();
+		if (attributeArrayOne.length != attributeArrayTwo.length) {
+			if (attributeArrayOne.length &gt; attributeArrayTwo.length) {
+				return 1; 
+			} else {
+				return -1;
+			}
+		}
+		for (var i in attributeArrayOne) {
+			var attribute = attributeArrayOne[i];
+			var arrayOfValuesOne = itemOne.getValues(attribute);
+			var arrayOfValuesTwo = itemTwo.getValues(attribute);
+			dojo.lang.assert(arrayOfValuesOne &amp;&amp; (arrayOfValuesOne.length &gt; 0));
+			if (!arrayOfValuesTwo) {
+				return 1;
+			}
+			if (arrayOfValuesOne.length != arrayOfValuesTwo.length) {
+				if (arrayOfValuesOne.length &gt; arrayOfValuesTwo.length) {
+					return 1; 
+				} else {
+					return -1;
+				}
+			}
+			for (var j in arrayOfValuesOne) {
+				var value = arrayOfValuesOne[j];
+				if (!itemTwo.hasAttributeValue(value)) {
+					return 1;
+				}
+			}
+			return 0;
+		}
+	} else {
+		if (nameOne &gt; nameTwo) {
+			return 1; 
+		} else {
+			return -1;  // 0, 1, or -1
+		}
+	}
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Item.prototype.toString = function() {
+	/**
+	 * Returns a simple string representation of the item.
+	 */
+	var arrayOfStrings = [];
+	var attributes = this.getAttributes();
+	for (var i in attributes) {
+		var attribute = attributes[i];
+		var arrayOfValues = this.getValues(attribute);
+		var valueString;
+		if (arrayOfValues.length == 1) {
+			valueString = arrayOfValues[0];
+		} else {
+			valueString = '[';
+			valueString += arrayOfValues.join(', ');
+			valueString += ']';
+		}
+		arrayOfStrings.push('  ' + attribute + ': ' + valueString);
+	}
+	var returnString = '{ ';
+	returnString += arrayOfStrings.join(',\n');
+	returnString += ' }';
+	return returnString; // string
+};
+
+dojo.data.Item.prototype.compare = function(/* dojo.data.Item */ otherItem) {
+	/**
+	 * summary: Compares this Item to another Item, and returns 0, 1, or -1.
+	 */ 
+	return dojo.data.Item.compare(this, otherItem); // 0, 1, or -1
+};
+
+dojo.data.Item.prototype.isEqual = function(/* dojo.data.Item */ otherItem) {
+	/**
+	 * summary: Returns true if this Item is equal to the otherItem, or false otherwise.
+	 */
+	return (this.compare(otherItem) == 0); // boolean
+};
+
+dojo.data.Item.prototype.getName = function() {
+	return this.get('name');
+};
+
+dojo.data.Item.prototype.get = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns a single literal value, like &quot;foo&quot; or 33.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		return null; // null
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		return literalOrValueOrArray.getValue(); // literal
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		var dojoDataValue = literalOrValueOrArray[0];
+		return dojoDataValue.getValue(); // literal
+	}
+	return literalOrValueOrArray; // literal
+};
+
+dojo.data.Item.prototype.getValue = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns a single instance of dojo.data.Value.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		return null; // null
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		return literalOrValueOrArray; // dojo.data.Value
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		var dojoDataValue = literalOrValueOrArray[0];
+		return dojoDataValue; // dojo.data.Value
+	}
+	var literal = literalOrValueOrArray;
+	dojoDataValue = new dojo.data.Value(literal);
+	this._dictionaryOfAttributeValues[attributeId] = dojoDataValue;
+	return dojoDataValue; // dojo.data.Value
+};
+
+dojo.data.Item.prototype.getValues = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns an array of dojo.data.Value objects.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		return null; // null
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		var array = [literalOrValueOrArray];
+		this._dictionaryOfAttributeValues[attributeId] = array;
+		return array; // Array
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		return literalOrValueOrArray; // Array
+	}
+	var literal = literalOrValueOrArray;
+	var dojoDataValue = new dojo.data.Value(literal);
+	array = [dojoDataValue];
+	this._dictionaryOfAttributeValues[attributeId] = array;
+	return array; // Array
+};
+
+dojo.data.Item.prototype.load = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: 
+	 * Used for loading an attribute value into an item when
+	 * the item is first being loaded into memory from some
+	 * data store (such as a file).
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	this._dataProvider.registerAttribute(attributeId);
+	var literalOrValueOrArray = this._dictionaryOfAttributeValues[attributeId];
+	if (dojo.lang.isUndefined(literalOrValueOrArray)) {
+		this._dictionaryOfAttributeValues[attributeId] = value;
+		return;
+	}
+	if (!(value instanceof dojo.data.Value)) {
+		value = new dojo.data.Value(value);
+	}
+	if (literalOrValueOrArray instanceof dojo.data.Value) {
+		var array = [literalOrValueOrArray, value];
+		this._dictionaryOfAttributeValues[attributeId] = array;
+		return;
+	}
+	if (dojo.lang.isArray(literalOrValueOrArray)) {
+		literalOrValueOrArray.push(value);
+		return;
+	}
+	var literal = literalOrValueOrArray;
+	var dojoDataValue = new dojo.data.Value(literal);
+	array = [dojoDataValue, value];
+	this._dictionaryOfAttributeValues[attributeId] = array;
+};
+
+dojo.data.Item.prototype.set = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: 
+	 * Used for setting an attribute value as a result of a
+	 * user action.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	this._dataProvider.registerAttribute(attributeId);
+	this._dictionaryOfAttributeValues[attributeId] = value;
+	this._dataProvider.noteChange(this, attributeId, value);
+};
+
+dojo.data.Item.prototype.setValue = function(/* string or dojo.data.Attribute */ attributeId, /* dojo.data.Value */ value) {
+	this.set(attributeId, value);
+};
+
+dojo.data.Item.prototype.addValue = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: 
+	 * Used for adding an attribute value as a result of a
+	 * user action.
+	 */ 
+	this.load(attributeId, value);
+	this._dataProvider.noteChange(this, attributeId, value);
+};
+
+dojo.data.Item.prototype.setValues = function(/* string or dojo.data.Attribute */ attributeId, /* Array */ arrayOfValues) {
+	/**
+	 * summary: 
+	 * Used for setting an array of attribute values as a result of a
+	 * user action.
+	 */
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	dojo.lang.assertType(arrayOfValues, Array);
+	this._dataProvider.registerAttribute(attributeId);
+	var finalArray = [];
+	this._dictionaryOfAttributeValues[attributeId] = finalArray;
+	for (var i in arrayOfValues) {
+		var value = arrayOfValues[i];
+		if (!(value instanceof dojo.data.Value)) {
+			value = new dojo.data.Value(value);
+		}
+		finalArray.push(value);
+		this._dataProvider.noteChange(this, attributeId, value);
+	}
+};
+
+dojo.data.Item.prototype.getAttributes = function() {
+	/**
+	 * summary: 
+	 * Returns an array containing all of the attributes for which
+	 * this item has attribute values.
+	 */ 
+	var arrayOfAttributes = [];
+	for (var key in this._dictionaryOfAttributeValues) {
+		arrayOfAttributes.push(this._dataProvider.getAttribute(key));
+	}
+	return arrayOfAttributes; // Array
+};
+
+dojo.data.Item.prototype.hasAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
+	/**
+	 * summary: Returns true if the given attribute of the item has been assigned any value.
+	 */ 
+	// dojo.lang.assertType(attributeId, [String, dojo.data.Attribute]);
+	for (var key in this._dictionaryOfAttributeValues) {
+		if (key == attributeId) {
+			return true; // boolean
+		}
+	}
+	return false; // boolean
+};
+
+dojo.data.Item.prototype.hasAttributeValue = function(/* string or dojo.data.Attribute */ attributeId, /* anything */ value) {
+	/**
+	 * summary: Returns true if the given attribute of the item has been assigned the given value.
+	 */ 
+	var arrayOfValues = this.getValues(attributeId);
+	for (var i in arrayOfValues) {
+		var candidateValue = arrayOfValues[i];
+		if (candidateValue.isEqual(value)) {
+			return true; // boolean
+		}
+	}
+	return false; // boolean
+};
+
+

Added: trunk/root/static/magic/src/data/Kind.js
===================================================================
--- trunk/root/static/magic/src/data/Kind.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/Kind.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,28 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.Kind&quot;);
+dojo.require(&quot;dojo.data.Item&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Kind = function(/* dojo.data.provider.Base */ dataProvider) {
+	/**
+	 * summary:
+	 * A Kind represents a kind of item.  In the dojo data model
+	 * the item Snoopy might belong to the 'kind' Dog, where in
+	 * a Java program the object Snoopy would belong to the 'class'
+	 * Dog, and in MySQL the record for Snoopy would be in the 
+	 * table Dog.
+	 */
+	dojo.data.Item.call(this, dataProvider);
+};
+dojo.inherits(dojo.data.Kind, dojo.data.Item);

Added: trunk/root/static/magic/src/data/Observable.js
===================================================================
--- trunk/root/static/magic/src/data/Observable.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/Observable.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,59 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.Observable&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Observable = function() {
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Observable.prototype.addObserver = function(/* object */ observer) {
+	/**
+	 * summary: Registers an object as an observer of this item,
+	 * so that the object will be notified when the item changes.
+	 */ 
+	dojo.lang.assertType(observer, Object);
+	dojo.lang.assertType(observer.observedObjectHasChanged, Function);
+	if (!this._arrayOfObservers) {
+		this._arrayOfObservers = [];
+	}
+	if (!dojo.lang.inArray(this._arrayOfObservers, observer)) {
+		this._arrayOfObservers.push(observer);
+	}
+};
+
+dojo.data.Observable.prototype.removeObserver = function(/* object */ observer) {
+	/**
+	 * summary: Removes the observer registration for a previously
+	 * registered object.
+	 */ 
+	if (!this._arrayOfObservers) {
+		return;
+	}
+	var index = dojo.lang.indexOf(this._arrayOfObservers, observer);
+	if (index != -1) {
+		this._arrayOfObservers.splice(index, 1);
+	}
+};
+
+dojo.data.Observable.prototype.getObservers = function() {
+	/**
+	 * summary: Returns an array with all the observers of this item.
+	 */ 
+	return this._arrayOfObservers; // Array or undefined
+};
+

Added: trunk/root/static/magic/src/data/ResultSet.js
===================================================================
--- trunk/root/static/magic/src/data/ResultSet.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/ResultSet.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,70 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.ResultSet&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+dojo.require(&quot;dojo.collections.Collections&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.ResultSet = function(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfItems) {
+	/**
+	 * summary:
+	 * A ResultSet holds a collection of Items.  A data provider
+	 * returns a ResultSet in reponse to a query.
+	 * (The name &quot;Result Set&quot; comes from the MySQL terminology.)
+	 */
+	dojo.lang.assertType(dataProvider, [dojo.data.provider.Base, &quot;optional&quot;]);
+	dojo.lang.assertType(arrayOfItems, [Array, &quot;optional&quot;]);
+	dojo.data.Observable.call(this);
+	this._dataProvider = dataProvider;
+	this._arrayOfItems = [];
+	if (arrayOfItems) {
+		this._arrayOfItems = arrayOfItems;
+	}
+};
+dojo.inherits(dojo.data.ResultSet, dojo.data.Observable);
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.ResultSet.prototype.toString = function() {
+	var returnString = this._arrayOfItems.join(', ');
+	return returnString; // string
+};
+
+dojo.data.ResultSet.prototype.toArray = function() {
+	return this._arrayOfItems; // Array
+};
+
+dojo.data.ResultSet.prototype.getIterator = function() {
+	return new dojo.collections.Iterator(this._arrayOfItems);
+};
+
+dojo.data.ResultSet.prototype.getLength = function() {
+	return this._arrayOfItems.length; // integer
+};
+
+dojo.data.ResultSet.prototype.getItemAt = function(/* numeric */ index) {
+	return this._arrayOfItems[index];
+};
+
+dojo.data.ResultSet.prototype.indexOf = function(/* dojo.data.Item */ item) {
+	return dojo.lang.indexOf(this._arrayOfItems, item); // integer
+};
+
+dojo.data.ResultSet.prototype.contains = function(/* dojo.data.Item */ item) {
+	return dojo.lang.inArray(this._arrayOfItems, item); // boolean
+};
+
+dojo.data.ResultSet.prototype.getDataProvider = function() {
+	return this._dataProvider; // dojo.data.provider.Base
+};
\ No newline at end of file

Added: trunk/root/static/magic/src/data/Type.js
===================================================================
--- trunk/root/static/magic/src/data/Type.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/Type.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,25 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.Type&quot;);
+dojo.require(&quot;dojo.data.Item&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Type = function(/* dojo.data.provider.Base */ dataProvider) {
+	/**
+	 * summary:
+	 * A Type represents a type of value, like Text, Number, Picture,
+	 * or Varchar.
+	 */
+	dojo.data.Item.call(this, dataProvider);
+};
+dojo.inherits(dojo.data.Type, dojo.data.Item);

Added: trunk/root/static/magic/src/data/Value.js
===================================================================
--- trunk/root/static/magic/src/data/Value.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/Value.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,55 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.Value&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.Value = function(/* anything */ value) {
+	/**
+	 * summary:
+	 * A Value represents a simple literal value (like &quot;foo&quot; or 334),
+	 * or a reference value (a pointer to an Item).
+	 */
+	this._value = value;
+	this._type = null;
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.Value.prototype.toString = function() {
+	return this._value.toString(); // string
+};
+
+dojo.data.Value.prototype.getValue = function() {
+	/**
+	 * summary: Returns the value itself.
+	 */ 
+	return this._value; // anything
+};
+
+dojo.data.Value.prototype.getType = function() {
+	/**
+	 * summary: Returns the data type of the value.
+	 */ 
+	dojo.unimplemented('dojo.data.Value.prototype.getType');
+	return this._type; // dojo.data.Type
+};
+
+dojo.data.Value.prototype.compare = function() {
+	dojo.unimplemented('dojo.data.Value.prototype.compare');
+};
+
+dojo.data.Value.prototype.isEqual = function() {
+	dojo.unimplemented('dojo.data.Value.prototype.isEqual');
+};

Added: trunk/root/static/magic/src/data/__package__.js
===================================================================
--- trunk/root/static/magic/src/data/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.experimental&quot;);
+
+dojo.experimental(&quot;dojo.data.*&quot;);
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.data.Item&quot;,
+		&quot;dojo.data.ResultSet&quot;,
+		&quot;dojo.data.provider.FlatFile&quot;
+	]
+});
+dojo.provide(&quot;dojo.data.*&quot;);
+

Added: trunk/root/static/magic/src/data/format/Csv.js
===================================================================
--- trunk/root/static/magic/src/data/format/Csv.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/format/Csv.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,112 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.format.Csv&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+
+dojo.data.format.Csv = new function() {
+
+	// -------------------------------------------------------------------
+	// Public functions
+	// -------------------------------------------------------------------
+	this.getArrayStructureFromCsvFileContents = function(/* string */ csvFileContents) {
+		/**
+		 * Given a string containing CSV records, this method parses
+		 * the string and returns a data structure containing the parsed
+		 * content.  The data structure we return is an array of length
+		 * R, where R is the number of rows (lines) in the CSV data.  The 
+		 * return array contains one sub-array for each CSV line, and each 
+		 * sub-array contains C string values, where C is the number of 
+		 * columns in the CSV data.
+		 * 
+		 * For example, given this CSV string as input:
+		 * &lt;pre&gt;
+		 *   &quot;Title, Year, Producer \n Alien, 1979, Ridley Scott \n Blade Runner, 1982, Ridley Scott&quot;
+		 * &lt;/pre&gt;
+		 * We will return this data structure:
+		 * &lt;pre&gt;
+		 *   [[&quot;Title&quot;, &quot;Year&quot;, &quot;Producer&quot;]
+		 *    [&quot;Alien&quot;, &quot;1979&quot;, &quot;Ridley Scott&quot;],  
+		 *    [&quot;Blade Runner&quot;, &quot;1982&quot;, &quot;Ridley Scott&quot;]]
+		 * &lt;/pre&gt;
+		 */
+		dojo.lang.assertType(csvFileContents, String);
+		
+		var lineEndingCharacters = new RegExp(&quot;\r\n|\n|\r&quot;);
+		var leadingWhiteSpaceCharacters = new RegExp(&quot;^\\s+&quot;,'g');
+		var trailingWhiteSpaceCharacters = new RegExp(&quot;\\s+$&quot;,'g');
+		var doubleQuotes = new RegExp('&quot;&quot;','g');
+		var arrayOfOutputRecords = [];
+		
+		var arrayOfInputLines = csvFileContents.split(lineEndingCharacters);
+		for (var i in arrayOfInputLines) {
+			var singleLine = arrayOfInputLines[i];
+			if (singleLine.length &gt; 0) {
+				var listOfFields = singleLine.split(',');
+				var j = 0;
+				while (j &lt; listOfFields.length) {
+					var space_field_space = listOfFields[j];
+					var field_space = space_field_space.replace(leadingWhiteSpaceCharacters, ''); // trim leading whitespace
+					var field = field_space.replace(trailingWhiteSpaceCharacters, ''); // trim trailing whitespace
+					var firstChar = field.charAt(0);
+					var lastChar = field.charAt(field.length - 1);
+					var secondToLastChar = field.charAt(field.length - 2);
+					var thirdToLastChar = field.charAt(field.length - 3);
+					if ((firstChar == '&quot;') &amp;&amp; 
+							((lastChar != '&quot;') || 
+							 ((lastChar == '&quot;') &amp;&amp; (secondToLastChar == '&quot;') &amp;&amp; (thirdToLastChar != '&quot;')) )) {
+						if (j+1 === listOfFields.length) {
+							// alert(&quot;The last field in record &quot; + i + &quot; is corrupted:\n&quot; + field);
+							return null;
+						}
+						var nextField = listOfFields[j+1];
+						listOfFields[j] = field_space + ',' + nextField;
+						listOfFields.splice(j+1, 1); // delete element [j+1] from the list
+					} else {
+						if ((firstChar == '&quot;') &amp;&amp; (lastChar == '&quot;')) {
+							field = field.slice(1, (field.length - 1)); // trim the &quot; characters off the ends
+							field = field.replace(doubleQuotes, '&quot;');   // replace &quot;&quot; with &quot;
+						}
+						listOfFields[j] = field;
+						j += 1;
+					}
+				}
+				arrayOfOutputRecords.push(listOfFields);
+			}
+		}
+		return arrayOfOutputRecords; // Array
+	};
+
+	this.loadDataProviderFromFileContents = function(/* dojo.data.provider.Base */ dataProvider, /* string */ csvFileContents) {
+		dojo.lang.assertType(dataProvider, dojo.data.provider.Base);
+		dojo.lang.assertType(csvFileContents, String);
+		var arrayOfArrays = this.getArrayStructureFromCsvFileContents(csvFileContents);
+		if (arrayOfArrays) {
+			var arrayOfKeys = arrayOfArrays[0];
+			for (var i = 1; i &lt; arrayOfArrays.length; ++i) {
+				var row = arrayOfArrays[i];
+				var item = dataProvider.getNewItemToLoad();
+				for (var j in row) {
+					var value = row[j];
+					var key = arrayOfKeys[j];
+					item.load(key, value);
+				}
+			}
+		}
+	};
+	
+	this.getCsvStringFromResultSet = function(/* dojo.data.ResultSet */ resultSet) {
+		dojo.unimplemented('dojo.data.format.Csv.getCsvStringFromResultSet');
+		var csvString = null;
+		return csvString; // String
+	};
+	
+}();

Added: trunk/root/static/magic/src/data/format/Json.js
===================================================================
--- trunk/root/static/magic/src/data/format/Json.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/format/Json.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,103 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.format.Json&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+dojo.data.format.Json = new function() {
+
+	// -------------------------------------------------------------------
+	// Public functions
+	// -------------------------------------------------------------------
+	this.loadDataProviderFromFileContents = function(/* dojo.data.provider.Base */ dataProvider, /* string */ jsonFileContents) {
+		dojo.lang.assertType(dataProvider, dojo.data.provider.Base);
+		dojo.lang.assertType(jsonFileContents, String);
+		var arrayOfJsonData = eval(&quot;(&quot; + jsonFileContents + &quot;)&quot;);
+		this.loadDataProviderFromArrayOfJsonData(dataProvider, arrayOfJsonData);
+	};
+	
+	this.loadDataProviderFromArrayOfJsonData = function(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
+		dojo.lang.assertType(arrayOfJsonData, [Array, &quot;optional&quot;]);
+		if (arrayOfJsonData &amp;&amp; (arrayOfJsonData.length &gt; 0)) {
+			var firstRow = arrayOfJsonData[0];
+			dojo.lang.assertType(firstRow, [Array, &quot;pureobject&quot;]);
+			if (dojo.lang.isArray(firstRow)) {
+				_loadDataProviderFromArrayOfArrays(dataProvider, arrayOfJsonData);
+			} else {
+				dojo.lang.assertType(firstRow, &quot;pureobject&quot;);
+				_loadDataProviderFromArrayOfObjects(dataProvider, arrayOfJsonData);
+			}
+		}
+	};
+
+	this.getJsonStringFromResultSet = function(/* dojo.data.ResultSet */ resultSet) {
+		dojo.unimplemented('dojo.data.format.Json.getJsonStringFromResultSet');
+		var jsonString = null;
+		return jsonString; // String
+	};
+
+	// -------------------------------------------------------------------
+	// Private functions
+	// -------------------------------------------------------------------
+	function _loadDataProviderFromArrayOfArrays(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
+		/** 
+		 * Example: 
+		 * var arrayOfJsonStates = [
+		 * 	 [ &quot;abbr&quot;,  &quot;population&quot;,  &quot;name&quot; ]
+		 * 	 [  &quot;WA&quot;,     5894121,      &quot;Washington&quot;    ],
+		 * 	 [  &quot;WV&quot;,     1808344,      &quot;West Virginia&quot; ],
+		 * 	 [  &quot;WI&quot;,     5453896,      &quot;Wisconsin&quot;     ],
+		 *   [  &quot;WY&quot;,      493782,      &quot;Wyoming&quot;       ] ];
+		 * this._loadFromArrayOfArrays(arrayOfJsonStates);
+		 */
+		var arrayOfKeys = arrayOfJsonData[0];
+		for (var i = 1; i &lt; arrayOfJsonData.length; ++i) {
+			var row = arrayOfJsonData[i];
+			var item = dataProvider.getNewItemToLoad();
+			for (var j in row) {
+				var value = row[j];
+				var key = arrayOfKeys[j];
+				item.load(key, value);
+			}
+		}
+	}
+
+	function _loadDataProviderFromArrayOfObjects(/* dojo.data.provider.Base */ dataProvider, /* Array */ arrayOfJsonData) {
+		/** 
+		 * Example: 
+		 * var arrayOfJsonStates = [
+		 * 	 { abbr: &quot;WA&quot;, name: &quot;Washington&quot; },
+		 * 	 { abbr: &quot;WV&quot;, name: &quot;West Virginia&quot; },
+		 * 	 { abbr: &quot;WI&quot;, name: &quot;Wisconsin&quot;, song: &quot;On, Wisconsin!&quot; },
+		 * 	 { abbr: &quot;WY&quot;, name: &quot;Wyoming&quot;, cities: [&quot;Lander&quot;, &quot;Cheyenne&quot;, &quot;Laramie&quot;] } ];
+		 * this._loadFromArrayOfArrays(arrayOfJsonStates);
+		 */
+		// dojo.debug(&quot;_loadDataProviderFromArrayOfObjects&quot;);
+		for (var i in arrayOfJsonData) {
+			var row = arrayOfJsonData[i];
+			var item = dataProvider.getNewItemToLoad();
+			for (var key in row) {
+				var value = row[key];
+				if (dojo.lang.isArray(value)) {
+					var arrayOfValues = value;
+					for (var j in arrayOfValues) {
+						value = arrayOfValues[j];
+						item.load(key, value);
+						// dojo.debug(&quot;loaded: &quot; + key + &quot; = &quot; + value); 
+					}
+				} else {
+					item.load(key, value);
+				}
+			}
+		}
+	}
+	
+}();
+

Added: trunk/root/static/magic/src/data/provider/Base.js
===================================================================
--- trunk/root/static/magic/src/data/provider/Base.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/provider/Base.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,183 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.provider.Base&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.Base = function() {
+	/**
+	 * summary:
+	 * A Data Provider serves as a connection to some data source,
+	 * like a relational database.  This data provider Base class
+	 * serves as an abstract superclass for other data provider
+	 * classes.
+	 */
+	this._countOfNestedTransactions = 0;
+	this._changesInCurrentTransaction = null;
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.Base.prototype.beginTransaction = function() {
+	/**
+	 * Marks the beginning of a transaction.
+	 *
+	 * Each time you call beginTransaction() you open a new transaction, 
+	 * which you need to close later using endTransaction().  Transactions
+	 * may be nested, but the beginTransaction and endTransaction calls
+	 * always need to come in pairs.
+	 */
+	if (this._countOfNestedTransactions === 0) {
+		this._changesInCurrentTransaction = [];
+	}
+	this._countOfNestedTransactions += 1;
+};
+
+dojo.data.provider.Base.prototype.endTransaction = function() {
+	/**
+	 * Marks the end of a transaction.
+	 */
+	this._countOfNestedTransactions -= 1;
+	dojo.lang.assert(this._countOfNestedTransactions &gt;= 0);
+
+	if (this._countOfNestedTransactions === 0) {
+		var listOfChangesMade = this._saveChanges();
+		this._changesInCurrentTransaction = null;
+		if (listOfChangesMade.length &gt; 0) {
+			// dojo.debug(&quot;endTransaction: &quot; + listOfChangesMade.length + &quot; changes made&quot;);
+			this._notifyObserversOfChanges(listOfChangesMade);
+		}
+	}
+};
+
+dojo.data.provider.Base.prototype.getNewItemToLoad = function() {
+	return this._newItem(); // dojo.data.Item
+};
+
+dojo.data.provider.Base.prototype.newItem = function(/* string */ itemName) {
+	/**
+	 * Creates a new item.
+	 */
+	dojo.lang.assertType(itemName, [String, &quot;optional&quot;]);
+	var item = this._newItem();
+	if (itemName) {
+		item.set('name', itemName);
+	}
+	return item; // dojo.data.Item
+};
+
+dojo.data.provider.Base.prototype.newAttribute = function(/* string */ attributeId) {
+	/**
+	 * Creates a new attribute.
+	 */
+	dojo.lang.assertType(attributeId, String); // FIXME: should be optional
+	var attribute = this._newAttribute(attributeId);
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype.getAttribute = function(/* string */ attributeId) {
+	dojo.unimplemented('dojo.data.provider.Base');
+	var attribute;
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype.getAttributes = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	return this._arrayOfAttributes; // Array
+};
+
+dojo.data.provider.Base.prototype.fetchArray = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	return []; // Array
+};
+
+dojo.data.provider.Base.prototype.fetchResultSet = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	var resultSet;
+	return resultSet; // dojo.data.ResultSet
+};
+
+dojo.data.provider.Base.prototype.noteChange = function(/* dojo.data.Item */ item, /* string or dojo.data.Attribute */ attribute, /* anything */ value) {
+	var change = {item: item, attribute: attribute, value: value};
+	if (this._countOfNestedTransactions === 0) {
+		this.beginTransaction();
+		this._changesInCurrentTransaction.push(change);
+		this.endTransaction();
+	} else {
+		this._changesInCurrentTransaction.push(change);
+	}
+};
+
+dojo.data.provider.Base.prototype.addItemObserver = function(/* dojo.data.Item */ item, /* object */ observer) {
+	/**
+	 * summary: Registers an object as an observer of an item,
+	 * so that the object will be notified when the item changes.
+	 */
+	dojo.lang.assertType(item, dojo.data.Item);
+	item.addObserver(observer);
+};
+
+dojo.data.provider.Base.prototype.removeItemObserver = function(/* dojo.data.Item */ item, /* object */ observer) {
+	/**
+	 * summary: Removes the observer registration for a previously
+	 * registered object.
+	 */ 
+	dojo.lang.assertType(item, dojo.data.Item);
+	item.removeObserver(observer);
+};
+
+// -------------------------------------------------------------------
+// Private instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.Base.prototype._newItem = function() {
+	var item = new dojo.data.Item(this);
+	return item; // dojo.data.Item
+};
+
+dojo.data.provider.Base.prototype._newAttribute = function(/* String */ attributeId) {
+	var attribute = new dojo.data.Attribute(this);
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype._saveChanges = function() {
+	var arrayOfChangesMade = this._changesInCurrentTransaction;
+	return arrayOfChangesMade; // Array
+};
+
+dojo.data.provider.Base.prototype._notifyObserversOfChanges = function(/* Array */ arrayOfChanges) {
+	var arrayOfResultSets = this._getResultSets();
+	for (var i in arrayOfChanges) {
+		var change = arrayOfChanges[i];
+		var changedItem = change.item;
+		var arrayOfItemObservers = changedItem.getObservers();
+		for (var j in arrayOfItemObservers) {
+			var observer = arrayOfItemObservers[j];
+			observer.observedObjectHasChanged(changedItem, change);
+		}
+		for (var k in arrayOfResultSets) {
+			var resultSet = arrayOfResultSets[k];
+			var arrayOfResultSetObservers = resultSet.getObservers();
+			for (var m in arrayOfResultSetObservers) {
+				observer = arrayOfResultSetObservers[m];
+				observer.observedObjectHasChanged(resultSet, change);
+			}
+		}
+	}
+};
+
+dojo.data.provider.Base.prototype._getResultSets = function() {
+	dojo.unimplemented('dojo.data.provider.Base');
+	return []; // Array
+};
+

Added: trunk/root/static/magic/src/data/provider/Delicious.js
===================================================================
--- trunk/root/static/magic/src/data/provider/Delicious.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/provider/Delicious.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,85 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.provider.Delicious&quot;);
+dojo.require(&quot;dojo.data.provider.FlatFile&quot;);
+dojo.require(&quot;dojo.data.format.Json&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.Delicious = function() {
+	/**
+	 * summary:
+	 * The Delicious Data Provider can be used to take data from
+	 * del.icio.us and make it available as dojo.data.Items
+	 * In order to use the Delicious Data Provider, you need 
+	 * to have loaded a script tag that looks like this:
+	 * &lt;script type=&quot;text/javascript&quot; src=&quot;<A HREF="http://del.icio.us/feeds/json/gumption?count=8">http://del.icio.us/feeds/json/gumption?count=8</A>&quot;&gt;&lt;/script&gt;
+	 */
+	dojo.data.provider.FlatFile.call(this);
+	// Delicious = null;
+	if (Delicious &amp;&amp; Delicious.posts) {
+		dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, Delicious.posts);
+	} else {
+		// document.write(&quot;&lt;script type='text/javascript'&gt;dojo.data.provider.Delicious._fetchComplete()&lt;/script&gt;&quot;);		
+		/*
+		document.write(&quot;&lt;script type='text/javascript'&gt;alert('boo!');&lt;/script&gt;&quot;);		
+		document.write(&quot;&lt;script type='text/javascript'&gt;var foo = 'not dojo'; alert('dojo == ' + foo);&lt;/script&gt;&quot;);		
+		document.write(&quot;&lt;script type='text/javascript'&gt;var foo = fetchComplete; alert('dojo == ' + foo);&lt;/script&gt;&quot;);		
+		fetchComplete();
+		*/
+		// dojo.debug(&quot;Delicious line 29: constructor&quot;);
+	}
+	var u = this.registerAttribute('u');
+	var d = this.registerAttribute('d');
+	var t = this.registerAttribute('t');
+	
+	u.load('name', 'Bookmark');
+	d.load('name', 'Description');
+	t.load('name', 'Tags');
+	
+	u.load('type', 'String');
+	d.load('type', 'String');
+	t.load('type', 'String');
+};
+dojo.inherits(dojo.data.provider.Delicious, dojo.data.provider.FlatFile);
+
+/********************************************************************
+ * FIXME: the rest of this is work in progress
+ *
+ 
+dojo.data.provider.Delicious.prototype.getNewItemToLoad = function() {
+	var newItem = this._newItem();
+	this._currentArray.push(newItem);
+	return newItem; // dojo.data.Item
+};
+
+dojo.data.provider.Delicious.prototype.fetchArray = function(query) {
+	if (!query) {	
+		query = &quot;gumption&quot;;
+	}
+	this._currentArray = [];
+	alert(&quot;Delicious line 60: loadDataProviderFromArrayOfJsonData&quot;);
+	alert(&quot;Delicious line 61: &quot; + dojo);
+		var sourceUrl = &quot;<A HREF="http://del.icio.us/feeds/json/">http://del.icio.us/feeds/json/</A>&quot; + query + &quot;?count=8&quot;;
+		document.write(&quot;&lt;script type='text/javascript' src='&quot; + sourceUrl + &quot;'&gt;&lt;/script&gt;&quot;);
+		document.write(&quot;&lt;script type='text/javascript'&gt;alert('line 63: ' + Delicious.posts[0].u);&lt;/script&gt;&quot;);		
+		document.write(&quot;&lt;script type='text/javascript'&gt;callMe();&lt;/script&gt;&quot;);		
+	alert(&quot;line 66&quot;);
+	dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, Delicious.posts);
+	return this._currentArray; // Array
+};
+
+callMe = function() {
+	alert(&quot;callMe!&quot;);
+};
+
+*/

Added: trunk/root/static/magic/src/data/provider/FlatFile.js
===================================================================
--- trunk/root/static/magic/src/data/provider/FlatFile.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/provider/FlatFile.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,153 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.provider.FlatFile&quot;);
+dojo.require(&quot;dojo.data.provider.Base&quot;);
+dojo.require(&quot;dojo.data.Item&quot;);
+dojo.require(&quot;dojo.data.Attribute&quot;);
+dojo.require(&quot;dojo.data.ResultSet&quot;);
+dojo.require(&quot;dojo.data.format.Json&quot;);
+dojo.require(&quot;dojo.data.format.Csv&quot;);
+dojo.require(&quot;dojo.lang.assert&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.FlatFile = function(/* keywords */ keywordParameters) {
+	/**
+	 * summary:
+	 * A Json Data Provider knows how to read in simple JSON data
+	 * tables and make their contents accessable as Items.
+	 */
+	dojo.lang.assertType(keywordParameters, [&quot;pureobject&quot;, &quot;optional&quot;]);
+	dojo.data.provider.Base.call(this);
+	this._arrayOfItems = [];
+	this._resultSet = null;
+	this._dictionaryOfAttributes = {};
+
+	if (keywordParameters) {
+		var jsonObjects = keywordParameters[&quot;jsonObjects&quot;];
+		var jsonString  = keywordParameters[&quot;jsonString&quot;];
+		var fileUrl     = keywordParameters[&quot;url&quot;];
+		if (jsonObjects) {
+			dojo.data.format.Json.loadDataProviderFromArrayOfJsonData(this, jsonObjects);
+		}
+		if (jsonString) {
+			dojo.data.format.Json.loadDataProviderFromFileContents(this, jsonString);
+		}
+		if (fileUrl) {
+			var arrayOfParts = fileUrl.split('.');
+			var lastPart = arrayOfParts[(arrayOfParts.length - 1)];
+			var formatParser = null;
+			if (lastPart == &quot;json&quot;) {
+				formatParser = dojo.data.format.Json;
+			}
+			if (lastPart == &quot;csv&quot;) {
+				formatParser = dojo.data.format.Csv;
+			}
+			if (formatParser) {
+				var fileContents = dojo.hostenv.getText(fileUrl);
+				formatParser.loadDataProviderFromFileContents(this, fileContents);
+			} else {
+				dojo.lang.assert(false, &quot;new dojo.data.provider.FlatFile({url: }) was passed a file without a .csv or .json suffix&quot;);
+			}
+		}
+	}
+};
+dojo.inherits(dojo.data.provider.FlatFile, dojo.data.provider.Base);
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.FlatFile.prototype.getProviderCapabilities = function(/* string */ keyword) {
+	dojo.lang.assertType(keyword, [String, &quot;optional&quot;]);
+	if (!this._ourCapabilities) {
+		this._ourCapabilities = {
+			transactions: false,
+			undo: false,
+			login: false,
+			versioning: false,
+			anonymousRead: true,
+			anonymousWrite: false,
+			permissions: false,
+			queries: false,
+			strongTyping: false,
+			datatypes: [String, Date, Number]
+		};
+	}
+	if (keyword) {
+		return this._ourCapabilities[keyword];
+	} else {
+		return this._ourCapabilities;
+	}
+};
+
+dojo.data.provider.FlatFile.prototype.registerAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
+	var registeredAttribute = this.getAttribute(attributeId);
+	if (!registeredAttribute) {
+		var newAttribute = new dojo.data.Attribute(this, attributeId);
+		this._dictionaryOfAttributes[attributeId] = newAttribute;
+		registeredAttribute = newAttribute;
+	}
+	return registeredAttribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.FlatFile.prototype.getAttribute = function(/* string or dojo.data.Attribute */ attributeId) {
+	var attribute = (this._dictionaryOfAttributes[attributeId] || null);
+	return attribute; // dojo.data.Attribute or null
+};
+
+dojo.data.provider.FlatFile.prototype.getAttributes = function() {
+	var arrayOfAttributes = [];
+	for (var key in this._dictionaryOfAttributes) {
+		var attribute = this._dictionaryOfAttributes[key];
+		arrayOfAttributes.push(attribute);
+	}
+	return arrayOfAttributes; // Array
+};
+
+dojo.data.provider.FlatFile.prototype.fetchArray = function(query) {
+	/**
+	 * summary: Returns an Array containing all of the Items.
+	 */ 
+	return this._arrayOfItems; // Array
+};
+
+dojo.data.provider.FlatFile.prototype.fetchResultSet = function(query) {
+	/**
+	 * summary: Returns a ResultSet containing all of the Items.
+	 */ 
+	if (!this._resultSet) {
+		this._resultSet = new dojo.data.ResultSet(this, this.fetchArray(query));
+	}
+	return this._resultSet; // dojo.data.ResultSet
+};
+
+// -------------------------------------------------------------------
+// Private instance methods
+// -------------------------------------------------------------------
+dojo.data.provider.FlatFile.prototype._newItem = function() {
+	var item = new dojo.data.Item(this);
+	this._arrayOfItems.push(item);
+	return item; // dojo.data.Item
+};
+
+dojo.data.provider.FlatFile.prototype._newAttribute = function(/* String */ attributeId) {
+	dojo.lang.assertType(attributeId, String);
+	dojo.lang.assert(this.getAttribute(attributeId) === null);
+	var attribute = new dojo.data.Attribute(this, attributeId);
+	this._dictionaryOfAttributes[attributeId] = attribute;
+	return attribute; // dojo.data.Attribute
+};
+
+dojo.data.provider.Base.prototype._getResultSets = function() {
+	return [this._resultSet]; // Array
+};
+

Added: trunk/root/static/magic/src/data/provider/JotSpot.js
===================================================================
--- trunk/root/static/magic/src/data/provider/JotSpot.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/provider/JotSpot.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,27 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.provider.JotSpot&quot;);
+dojo.require(&quot;dojo.data.provider.Base&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.JotSpot = function() {
+	/**
+	 * summary:
+	 * A JotSpot Data Provider knows how to read data from a JotSpot data 
+	 * store and make the contents accessable as dojo.data.Items.
+	 */
+	dojo.unimplemented('dojo.data.provider.JotSpot');
+};
+
+dojo.inherits(dojo.data.provider.JotSpot, dojo.data.provider.Base);
+

Added: trunk/root/static/magic/src/data/provider/MySql.js
===================================================================
--- trunk/root/static/magic/src/data/provider/MySql.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/provider/MySql.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,27 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data.provider.MySql&quot;);
+dojo.require(&quot;dojo.data.provider.Base&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+dojo.data.provider.MySql = function() {
+	/**
+	 * summary:
+	 * A MySql Data Provider knows how to connect to a MySQL database
+	 * on a server and and make the content records available as 
+	 * dojo.data.Items.
+	 */
+	dojo.unimplemented('dojo.data.provider.MySql');
+};
+
+dojo.inherits(dojo.data.provider.MySql, dojo.data.provider.Base);

Added: trunk/root/static/magic/src/data/to_do.txt
===================================================================
--- trunk/root/static/magic/src/data/to_do.txt	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data/to_do.txt	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,45 @@
+Existing Features
+ * can import data from .json or .csv format files
+ * can import data from del.icio.us
+ * can create and modify data programmatically
+ * can bind data to dojo.widget.Chart
+ * can bind data to dojo.widget.SortableTable
+ * can bind one data set to multiple widgets
+ * notifications: widgets are notified when data changes
+ * notification available per-item or per-resultSet
+ * can create ad-hoc attributes
+ * attributes can be loosely-typed 
+ * attributes can have meta-data like type and display name
+ * half-implemented support for sorting
+ * half-implemented support for export to .json
+ * API for getting data in simple arrays 
+ * API for getting ResultSets with iterators (precursor to support for something like the openrico.org live grid)
+ 
+~~~~~~~~~~~~~~~~~~~~~~~~
+To-Do List
+ * be able to import data from an html &lt;table&gt;&lt;/table&gt;
+ * think about being able to import data from some type of XML 
+ * think about integration with dojo.undo.Manager
+ * think more about how to represent the notion of different data types
+ * think about what problems we'll run into when we have a MySQL data provider
+ * in TableBindingHack, improve support for data types in the SortableTable binding
+ * deal with ids (including MySQL multi-field keys)
+ * add support for item-references:  employeeItem.set('department', departmentItem);
+ * deal with Attributes as instances of Items, not just subclasses of Items
+ * unit tests for compare/sort code
+ * unit tests for everything
+ * implement item.toString('json') and item.toString('xml')
+ * implement dataProvider.newItem({name: 'foo', age: 26})
+ * deal better with transactions
+ * add support for deleting items
+ * don't send out multiple notifications to the same observer
+ * deal with item versions
+ * prototype a Yahoo data provider -- <A HREF="http://developer.yahoo.net/common/json.html">http://developer.yahoo.net/common/json.html</A>
+ * prototype a data provider that enforces strong typing
+ * prototype a data provider that prevents ad-hoc attributes
+ * prototype a data provider that enforces single-kind item
+ * prototype a data provider that allows for login/authentication
+ * have loosely typed result sets play nicely with widgets that expect strong typing
+ * prototype an example of spreadsheet-style formulas or derivation rules
+ * experiment with some sort of fetch() that returns only a subset of a data provider's items
+

Added: trunk/root/static/magic/src/data.js
===================================================================
--- trunk/root/static/magic/src/data.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/data.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.data&quot;);
+
+// currently a stub for dojo.data
+
+dojo.data = {};

Added: trunk/root/static/magic/src/date.js
===================================================================
--- trunk/root/static/magic/src/date.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/date.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,761 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.date&quot;);
+
+
+/* Supplementary Date Functions
+ *******************************/
+
+dojo.date.setDayOfYear = function (dateObject, dayofyear) {
+	dateObject.setMonth(0);
+	dateObject.setDate(dayofyear);
+	return dateObject;
+}
+
+dojo.date.getDayOfYear = function (dateObject) {
+	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);
+	return Math.floor((dateObject.getTime() -
+		firstDayOfYear.getTime()) / 86400000);
+}
+
+
+
+
+dojo.date.setWeekOfYear = function (dateObject, week, firstDay) {
+	if (arguments.length == 1) { firstDay = 0; } // Sunday
+	dojo.unimplemented(&quot;dojo.date.setWeekOfYear&quot;);
+}
+
+dojo.date.getWeekOfYear = function (dateObject, firstDay) {
+	if (arguments.length == 1) { firstDay = 0; } // Sunday
+
+	// work out the first day of the year corresponding to the week
+	var firstDayOfYear = new Date(dateObject.getFullYear(), 0, 1);
+	var day = firstDayOfYear.getDay();
+	firstDayOfYear.setDate(firstDayOfYear.getDate() -
+			day + firstDay - (day &gt; firstDay ? 7 : 0));
+
+	return Math.floor((dateObject.getTime() -
+		firstDayOfYear.getTime()) / 604800000);
+}
+
+
+
+
+dojo.date.setIsoWeekOfYear = function (dateObject, week, firstDay) {
+	if (arguments.length == 1) { firstDay = 1; } // Monday
+	dojo.unimplemented(&quot;dojo.date.setIsoWeekOfYear&quot;);
+}
+
+dojo.date.getIsoWeekOfYear = function (dateObject, firstDay) {
+	if (arguments.length == 1) { firstDay = 1; } // Monday
+	dojo.unimplemented(&quot;dojo.date.getIsoWeekOfYear&quot;);
+}
+
+
+
+
+/* ISO 8601 Functions
+ *********************/
+
+dojo.date.setIso8601 = function (dateObject, string){
+	var comps = (string.indexOf(&quot;T&quot;) == -1) ? string.split(&quot; &quot;) : string.split(&quot;T&quot;);
+	dojo.date.setIso8601Date(dateObject, comps[0]);
+	if (comps.length == 2) { dojo.date.setIso8601Time(dateObject, comps[1]); }
+	return dateObject;
+}
+
+dojo.date.fromIso8601 = function (string) {
+	return dojo.date.setIso8601(new Date(0, 0), string);
+}
+
+
+
+
+dojo.date.setIso8601Date = function (dateObject, string) {
+	var regexp = &quot;^([0-9]{4})((-?([0-9]{2})(-?([0-9]{2}))?)|&quot; +
+			&quot;(-?([0-9]{3}))|(-?W([0-9]{2})(-?([1-7]))?))?$&quot;;
+	var d = string.match(new RegExp(regexp));
+	if(!d) {
+		dojo.debug(&quot;invalid date string: &quot; + string);
+		return false;
+	}
+	var year = d[1];
+	var month = d[4];
+	var date = d[6];
+	var dayofyear = d[8];
+	var week = d[10];
+	var dayofweek = (d[12]) ? d[12] : 1;
+
+	dateObject.setYear(year);
+	
+	if (dayofyear) { dojo.date.setDayOfYear(dateObject, Number(dayofyear)); }
+	else if (week) {
+		dateObject.setMonth(0);
+		dateObject.setDate(1);
+		var gd = dateObject.getDay();
+		var day =  (gd) ? gd : 7;
+		var offset = Number(dayofweek) + (7 * Number(week));
+		
+		if (day &lt;= 4) { dateObject.setDate(offset + 1 - day); }
+		else { dateObject.setDate(offset + 8 - day); }
+	} else {
+		if (month) { 
+			dateObject.setDate(1);
+			dateObject.setMonth(month - 1); 
+		}
+		if (date) { dateObject.setDate(date); }
+	}
+	
+	return dateObject;
+}
+
+dojo.date.fromIso8601Date = function (string) {
+	return dojo.date.setIso8601Date(new Date(0, 0), string);
+}
+
+
+
+
+dojo.date.setIso8601Time = function (dateObject, string) {
+	// first strip timezone info from the end
+	var timezone = &quot;Z|(([-+])([0-9]{2})(:?([0-9]{2}))?)$&quot;;
+	var d = string.match(new RegExp(timezone));
+
+	var offset = 0; // local time if no tz info
+	if (d) {
+		if (d[0] != 'Z') {
+			offset = (Number(d[3]) * 60) + Number(d[5]);
+			offset *= ((d[2] == '-') ? 1 : -1);
+		}
+		offset -= dateObject.getTimezoneOffset();
+		string = string.substr(0, string.length - d[0].length);
+	}
+
+	// then work out the time
+	var regexp = &quot;^([0-9]{2})(:?([0-9]{2})(:?([0-9]{2})(\.([0-9]+))?)?)?$&quot;;
+	var d = string.match(new RegExp(regexp));
+	if(!d) {
+		dojo.debug(&quot;invalid time string: &quot; + string);
+		return false;
+	}
+	var hours = d[1];
+	var mins = Number((d[3]) ? d[3] : 0);
+	var secs = (d[5]) ? d[5] : 0;
+	var ms = d[7] ? (Number(&quot;0.&quot; + d[7]) * 1000) : 0;
+
+	dateObject.setHours(hours);
+	dateObject.setMinutes(mins);
+	dateObject.setSeconds(secs);
+	dateObject.setMilliseconds(ms);
+	
+	return dateObject;
+}
+
+dojo.date.fromIso8601Time = function (string) {
+	return dojo.date.setIso8601Time(new Date(0, 0), string);
+}
+
+
+
+/* Informational Functions
+ **************************/
+
+dojo.date.shortTimezones = [&quot;IDLW&quot;, &quot;BET&quot;, &quot;HST&quot;, &quot;MART&quot;, &quot;AKST&quot;, &quot;PST&quot;, &quot;MST&quot;,
+	&quot;CST&quot;, &quot;EST&quot;, &quot;AST&quot;, &quot;NFT&quot;, &quot;BST&quot;, &quot;FST&quot;, &quot;AT&quot;, &quot;GMT&quot;, &quot;CET&quot;, &quot;EET&quot;, &quot;MSK&quot;,
+	&quot;IRT&quot;, &quot;GST&quot;, &quot;AFT&quot;, &quot;AGTT&quot;, &quot;IST&quot;, &quot;NPT&quot;, &quot;ALMT&quot;, &quot;MMT&quot;, &quot;JT&quot;, &quot;AWST&quot;,
+	&quot;JST&quot;, &quot;ACST&quot;, &quot;AEST&quot;, &quot;LHST&quot;, &quot;VUT&quot;, &quot;NFT&quot;, &quot;NZT&quot;, &quot;CHAST&quot;, &quot;PHOT&quot;,
+	&quot;LINT&quot;];
+dojo.date.timezoneOffsets = [-720, -660, -600, -570, -540, -480, -420, -360,
+	-300, -240, -210, -180, -120, -60, 0, 60, 120, 180, 210, 240, 270, 300,
+	330, 345, 360, 390, 420, 480, 540, 570, 600, 630, 660, 690, 720, 765, 780,
+	840];
+/*
+dojo.date.timezones = [&quot;International Date Line West&quot;, &quot;Bering Standard Time&quot;,
+	&quot;Hawaiian Standard Time&quot;, &quot;Marquesas Time&quot;, &quot;Alaska Standard Time&quot;,
+	&quot;Pacific Standard Time (USA)&quot;, &quot;Mountain Standard Time&quot;,
+	&quot;Central Standard Time (USA)&quot;, &quot;Eastern Standard Time (USA)&quot;,
+	&quot;Atlantic Standard Time&quot;, &quot;Newfoundland Time&quot;, &quot;Brazil Standard Time&quot;,
+	&quot;Fernando de Noronha Standard Time (Brazil)&quot;, &quot;Azores Time&quot;,
+	&quot;Greenwich Mean Time&quot;, &quot;Central Europe Time&quot;, &quot;Eastern Europe Time&quot;,
+	&quot;Moscow Time&quot;, &quot;Iran Standard Time&quot;, &quot;Gulf Standard Time&quot;,
+	&quot;Afghanistan Time&quot;, &quot;Aqtobe Time&quot;, &quot;Indian Standard Time&quot;, &quot;Nepal Time&quot;,
+	&quot;Almaty Time&quot;, &quot;Myanmar Time&quot;, &quot;Java Time&quot;,
+	&quot;Australian Western Standard Time&quot;, &quot;Japan Standard Time&quot;,
+	&quot;Australian Central Standard Time&quot;, &quot;Lord Hove Standard Time (Australia)&quot;,
+	&quot;Vanuata Time&quot;, &quot;Norfolk Time (Australia)&quot;, &quot;New Zealand Standard Time&quot;,
+	&quot;Chatham Standard Time (New Zealand)&quot;, &quot;Phoenix Islands Time (Kribati)&quot;,
+	&quot;Line Islands Time (Kribati)&quot;];
+*/
+dojo.date.months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;,
+	&quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
+dojo.date.shortMonths = [&quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;June&quot;,
+	&quot;July&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;];
+dojo.date.days = [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;,
+	&quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;];
+dojo.date.shortDays = [&quot;Sun&quot;, &quot;Mon&quot;, &quot;Tues&quot;, &quot;Wed&quot;, &quot;Thur&quot;, &quot;Fri&quot;, &quot;Sat&quot;];
+
+
+dojo.date.getDaysInMonth = function (dateObject) {
+	var month = dateObject.getMonth();
+	var days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
+	if (month == 1 &amp;&amp; dojo.date.isLeapYear(dateObject)) { return 29; }
+	else { return days[month]; }
+}
+
+dojo.date.isLeapYear = function (dateObject) {
+	/*
+	 * Leap years are years with an additional day YYYY-02-29, where the year
+	 * number is a multiple of four with the following exception: If a year
+	 * is a multiple of 100, then it is only a leap year if it is also a
+	 * multiple of 400. For example, 1900 was not a leap year, but 2000 is one.
+	 */
+	var year = dateObject.getFullYear();
+	return (year%400 == 0) ? true : (year%100 == 0) ? false : (year%4 == 0) ? true : false;
+}
+
+
+
+dojo.date.getDayName = function (dateObject) {
+	return dojo.date.days[dateObject.getDay()];
+}
+
+dojo.date.getDayShortName = function (dateObject) {
+	return dojo.date.shortDays[dateObject.getDay()];
+}
+
+
+
+
+dojo.date.getMonthName = function (dateObject) {
+	return dojo.date.months[dateObject.getMonth()];
+}
+
+dojo.date.getMonthShortName = function (dateObject) {
+	return dojo.date.shortMonths[dateObject.getMonth()];
+}
+
+
+
+
+dojo.date.getTimezoneName = function (dateObject) {
+	// need to negate timezones to get it right 
+	// i.e UTC+1 is CET winter, but getTimezoneOffset returns -60
+	var timezoneOffset = -(dateObject.getTimezoneOffset());
+	
+	for (var i = 0; i &lt; dojo.date.timezoneOffsets.length; i++) {
+		if (dojo.date.timezoneOffsets[i] == timezoneOffset) {
+			return dojo.date.shortTimezones[i];
+		}
+	}
+	
+	// we don't know so return it formatted as &quot;+HH:MM&quot;
+	function $ (s) { s = String(s); while (s.length &lt; 2) { s = &quot;0&quot; + s; } return s; }
+	return (timezoneOffset &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + $(Math.floor(Math.abs(
+		timezoneOffset)/60)) + &quot;:&quot; + $(Math.abs(timezoneOffset)%60);
+}
+
+
+
+
+dojo.date.getOrdinal = function (dateObject) {
+	var date = dateObject.getDate();
+
+	if (date%100 != 11 &amp;&amp; date%10 == 1) { return &quot;st&quot;; }
+	else if (date%100 != 12 &amp;&amp; date%10 == 2) { return &quot;nd&quot;; }
+	else if (date%100 != 13 &amp;&amp; date%10 == 3) { return &quot;rd&quot;; }
+	else { return &quot;th&quot;; }
+}
+
+
+
+/* Date Formatter Functions
+ ***************************/
+
+// POSIX strftime
+// see &lt;<A HREF="http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html">http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html</A>&gt;
+dojo.date.format = dojo.date.strftime = function (dateObject, format) {
+
+	// zero pad
+	var padChar = null;
+	function _ (s, n) {
+		s = String(s);
+		n = (n || 2) - s.length;
+		while (n-- &gt; 0) { s = (padChar == null ? &quot;0&quot; : padChar) + s; }
+		return s;
+	}
+	
+	function $ (property) {
+		switch (property) {
+			case &quot;a&quot;: // abbreviated weekday name according to the current locale
+				return dojo.date.getDayShortName(dateObject); break;
+
+			case &quot;A&quot;: // full weekday name according to the current locale
+				return dojo.date.getDayName(dateObject); break;
+
+			case &quot;b&quot;:
+			case &quot;h&quot;: // abbreviated month name according to the current locale
+				return dojo.date.getMonthShortName(dateObject); break;
+				
+			case &quot;B&quot;: // full month name according to the current locale
+				return dojo.date.getMonthName(dateObject); break;
+				
+			case &quot;c&quot;: // preferred date and time representation for the current
+				      // locale
+				return dateObject.toLocaleString(); break;
+
+			case &quot;C&quot;: // century number (the year divided by 100 and truncated
+				      // to an integer, range 00 to 99)
+				return _(Math.floor(dateObject.getFullYear()/100)); break;
+				
+			case &quot;d&quot;: // day of the month as a decimal number (range 01 to 31)
+				return _(dateObject.getDate()); break;
+				
+			case &quot;D&quot;: // same as %m/%d/%y
+				return $(&quot;m&quot;) + &quot;/&quot; + $(&quot;d&quot;) + &quot;/&quot; + $(&quot;y&quot;); break;
+					
+			case &quot;e&quot;: // day of the month as a decimal number, a single digit is
+				      // preceded by a space (range ' 1' to '31')
+				if (padChar == null) { padChar = &quot; &quot;; }
+				return _(dateObject.getDate(), 2); break;
+			
+			case &quot;g&quot;: // like %G, but without the century.
+				break;
+			
+			case &quot;G&quot;: // The 4-digit year corresponding to the ISO week number
+				      // (see %V).  This has the same format and value as %Y,
+				      // except that if the ISO week number belongs to the
+				      // previous or next year, that year is used instead.
+				break;
+			
+			case &quot;F&quot;: // same as %Y-%m-%d
+				return $(&quot;Y&quot;) + &quot;-&quot; + $(&quot;m&quot;) + &quot;-&quot; + $(&quot;d&quot;); break;
+				
+			case &quot;H&quot;: // hour as a decimal number using a 24-hour clock (range
+				      // 00 to 23)
+				return _(dateObject.getHours()); break;
+				
+			case &quot;I&quot;: // hour as a decimal number using a 12-hour clock (range
+				      // 01 to 12)
+				return _(dateObject.getHours() % 12 || 12); break;
+				
+			case &quot;j&quot;: // day of the year as a decimal number (range 001 to 366)
+				return _(dojo.date.getDayOfYear(dateObject), 3); break;
+				
+			case &quot;m&quot;: // month as a decimal number (range 01 to 12)
+				return _(dateObject.getMonth() + 1); break;
+				
+			case &quot;M&quot;: // minute as a decimal numbe
+				return _(dateObject.getMinutes()); break;
+			
+			case &quot;n&quot;:
+				return &quot;\n&quot;; break;
+
+			case &quot;p&quot;: // either `am' or `pm' according to the given time value,
+				      // or the corresponding strings for the current locale
+				return dateObject.getHours() &lt; 12 ? &quot;am&quot; : &quot;pm&quot;; break;
+				
+			case &quot;r&quot;: // time in a.m. and p.m. notation
+				return $(&quot;I&quot;) + &quot;:&quot; + $(&quot;M&quot;) + &quot;:&quot; + $(&quot;S&quot;) + &quot; &quot; + $(&quot;p&quot;); break;
+				
+			case &quot;R&quot;: // time in 24 hour notation
+				return $(&quot;H&quot;) + &quot;:&quot; + $(&quot;M&quot;); break;
+				
+			case &quot;S&quot;: // second as a decimal number
+				return _(dateObject.getSeconds()); break;
+
+			case &quot;t&quot;:
+				return &quot;\t&quot;; break;
+
+			case &quot;T&quot;: // current time, equal to %H:%M:%S
+				return $(&quot;H&quot;) + &quot;:&quot; + $(&quot;M&quot;) + &quot;:&quot; + $(&quot;S&quot;); break;
+				
+			case &quot;u&quot;: // weekday as a decimal number [1,7], with 1 representing
+				      // Monday
+				return String(dateObject.getDay() || 7); break;
+				
+			case &quot;U&quot;: // week number of the current year as a decimal number,
+				      // starting with the first Sunday as the first day of the
+				      // first week
+				return _(dojo.date.getWeekOfYear(dateObject)); break;
+
+			case &quot;V&quot;: // week number of the year (Monday as the first day of the
+				      // week) as a decimal number [01,53]. If the week containing
+				      // 1 January has four or more days in the new year, then it 
+				      // is considered week 1. Otherwise, it is the last week of 
+				      // the previous year, and the next week is week 1.
+				return _(dojo.date.getIsoWeekOfYear(dateObject)); break;
+				
+			case &quot;W&quot;: // week number of the current year as a decimal number,
+				      // starting with the first Monday as the first day of the
+				      // first week
+				return _(dojo.date.getWeekOfYear(dateObject, 1)); break;
+				
+			case &quot;w&quot;: // day of the week as a decimal, Sunday being 0
+				return String(dateObject.getDay()); break;
+
+			case &quot;x&quot;: // preferred date representation for the current locale
+				      // without the time
+				break;
+
+			case &quot;X&quot;: // preferred date representation for the current locale
+				      // without the time
+				break;
+
+			case &quot;y&quot;: // year as a decimal number without a century (range 00 to
+				      // 99)
+				return _(dateObject.getFullYear()%100); break;
+				
+			case &quot;Y&quot;: // year as a decimal number including the century
+				return String(dateObject.getFullYear()); break;
+			
+			case &quot;z&quot;: // time zone or name or abbreviation
+				var timezoneOffset = dateObject.getTimezoneOffset();
+				return (timezoneOffset &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + 
+					_(Math.floor(Math.abs(timezoneOffset)/60)) + &quot;:&quot; +
+					_(Math.abs(timezoneOffset)%60); break;
+				
+			case &quot;Z&quot;: // time zone or name or abbreviation
+				return dojo.date.getTimezoneName(dateObject); break;
+			
+			case &quot;%&quot;:
+				return &quot;%&quot;; break;
+		}
+	}
+
+	// parse the formatting string and construct the resulting string
+	var string = &quot;&quot;;
+	var i = 0, index = 0, switchCase;
+	while ((index = format.indexOf(&quot;%&quot;, i)) != -1) {
+		string += format.substring(i, index++);
+		
+		// inspect modifier flag
+		switch (format.charAt(index++)) {
+			case &quot;_&quot;: // Pad a numeric result string with spaces.
+				padChar = &quot; &quot;; break;
+			case &quot;-&quot;: // Do not pad a numeric result string.
+				padChar = &quot;&quot;; break;
+			case &quot;0&quot;: // Pad a numeric result string with zeros.
+				padChar = &quot;0&quot;; break;
+			case &quot;^&quot;: // Convert characters in result string to upper case.
+				switchCase = &quot;upper&quot;; break;
+			case &quot;#&quot;: // Swap the case of the result string.
+				switchCase = &quot;swap&quot;; break;
+			default: // no modifer flag so decremenet the index
+				padChar = null; index--; break;
+		}
+
+		// toggle case if a flag is set
+		var property = $(format.charAt(index++));
+		if (switchCase == &quot;upper&quot; ||
+			(switchCase == &quot;swap&quot; &amp;&amp; /[a-z]/.test(property))) {
+			property = property.toUpperCase();
+		} else if (switchCase == &quot;swap&quot; &amp;&amp; !/[a-z]/.test(property)) {
+			property = property.toLowerCase();
+		}
+		var swicthCase = null;
+		
+		string += property;
+		i = index;
+	}
+	string += format.substring(i);
+	
+	return string;
+}
+
+/* compare and add
+ ******************/
+dojo.date.compareTypes={
+	// 	summary
+	//	bitmask for comparison operations.
+	DATE:1, TIME:2 
+};
+dojo.date.compare=function(/* Date */ dateA, /* Date */ dateB, /* int */ options){
+	//	summary
+	//	Compare two date objects by date, time, or both.
+	var dA=dateA;
+	var dB=dateB||new Date();
+	var now=new Date();
+	var opt=options||(dojo.date.compareTypes.DATE|dojo.date.compareTypes.TIME);
+	var d1=new Date(
+		((opt&amp;dojo.date.compareTypes.DATE)?(dA.getFullYear()):now.getFullYear()), 
+		((opt&amp;dojo.date.compareTypes.DATE)?(dA.getMonth()):now.getMonth()), 
+		((opt&amp;dojo.date.compareTypes.DATE)?(dA.getDate()):now.getDate()), 
+		((opt&amp;dojo.date.compareTypes.TIME)?(dA.getHours()):0), 
+		((opt&amp;dojo.date.compareTypes.TIME)?(dA.getMinutes()):0), 
+		((opt&amp;dojo.date.compareTypes.TIME)?(dA.getSeconds()):0)
+	);
+	var d2=new Date(
+		((opt&amp;dojo.date.compareTypes.DATE)?(dB.getFullYear()):now.getFullYear()), 
+		((opt&amp;dojo.date.compareTypes.DATE)?(dB.getMonth()):now.getMonth()), 
+		((opt&amp;dojo.date.compareTypes.DATE)?(dB.getDate()):now.getDate()), 
+		((opt&amp;dojo.date.compareTypes.TIME)?(dB.getHours()):0), 
+		((opt&amp;dojo.date.compareTypes.TIME)?(dB.getMinutes()):0), 
+		((opt&amp;dojo.date.compareTypes.TIME)?(dB.getSeconds()):0)
+	);
+	if(d1.valueOf()&gt;d2.valueOf()){
+		return 1;	//	int
+	}
+	if(d1.valueOf()&lt;d2.valueOf()){
+		return -1;	//	int
+	}
+	return 0;	//	int
+}
+
+dojo.date.dateParts={ 
+	//	summary
+	//	constants for use in dojo.date.add
+	YEAR:0, MONTH:1, DAY:2, HOUR:3, MINUTE:4, SECOND:5, MILLISECOND:6 
+};
+dojo.date.add=function(/* Date */ d, /* dojo.date.dateParts */ unit, /* int */ amount){
+	var n=(amount)?amount:1;
+	var v;
+	switch(unit){
+		case dojo.date.dateParts.YEAR:{
+			v=new Date(d.getFullYear()+n, d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.MONTH:{
+			v=new Date(d.getFullYear(), d.getMonth()+n, d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.HOUR:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours()+n, d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.MINUTE:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes()+n, d.getSeconds(), d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.SECOND:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds()+n, d.getMilliseconds());
+			break;
+		}
+		case dojo.date.dateParts.MILLISECOND:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds()+n);
+			break;
+		}
+		default:{
+			v=new Date(d.getFullYear(), d.getMonth(), d.getDate()+n, d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
+		}
+	};
+	return v;	//	Date
+};
+
+/* Deprecated
+ *************/
+
+
+dojo.date.toString = function(date, format){
+	dojo.deprecated(&quot;dojo.date.toString&quot;,
+		&quot;use dojo.date.format instead&quot;, &quot;0.4&quot;);
+
+	if (format.indexOf(&quot;#d&quot;) &gt; -1) {
+		format = format.replace(/#dddd/g, dojo.date.getDayOfWeekName(date));
+		format = format.replace(/#ddd/g, dojo.date.getShortDayOfWeekName(date));
+		format = format.replace(/#dd/g, (date.getDate().toString().length==1?&quot;0&quot;:&quot;&quot;)+date.getDate());
+		format = format.replace(/#d/g, date.getDate());
+	}
+
+	if (format.indexOf(&quot;#M&quot;) &gt; -1) {
+		format = format.replace(/#MMMM/g, dojo.date.getMonthName(date));
+		format = format.replace(/#MMM/g, dojo.date.getShortMonthName(date));
+		format = format.replace(/#MM/g, ((date.getMonth()+1).toString().length==1?&quot;0&quot;:&quot;&quot;)+(date.getMonth()+1));
+		format = format.replace(/#M/g, date.getMonth() + 1);
+	}
+
+	if (format.indexOf(&quot;#y&quot;) &gt; -1) {
+		var fullYear = date.getFullYear().toString();
+		format = format.replace(/#yyyy/g, fullYear);
+		format = format.replace(/#yy/g, fullYear.substring(2));
+		format = format.replace(/#y/g, fullYear.substring(3));
+	}
+
+	// Return if only date needed;
+	if (format.indexOf(&quot;#&quot;) == -1) {
+		return format;
+	}
+	
+	if (format.indexOf(&quot;#h&quot;) &gt; -1) {
+		var hours = date.getHours();
+		hours = (hours &gt; 12 ? hours - 12 : (hours == 0) ? 12 : hours);
+		format = format.replace(/#hh/g, (hours.toString().length==1?&quot;0&quot;:&quot;&quot;)+hours);
+		format = format.replace(/#h/g, hours);
+	}
+	
+	if (format.indexOf(&quot;#H&quot;) &gt; -1) {
+		format = format.replace(/#HH/g, (date.getHours().toString().length==1?&quot;0&quot;:&quot;&quot;)+date.getHours());
+		format = format.replace(/#H/g, date.getHours());
+	}
+	
+	if (format.indexOf(&quot;#m&quot;) &gt; -1) {
+		format = format.replace(/#mm/g, (date.getMinutes().toString().length==1?&quot;0&quot;:&quot;&quot;)+date.getMinutes());
+		format = format.replace(/#m/g, date.getMinutes());
+	}
+
+	if (format.indexOf(&quot;#s&quot;) &gt; -1) {
+		format = format.replace(/#ss/g, (date.getSeconds().toString().length==1?&quot;0&quot;:&quot;&quot;)+date.getSeconds());
+		format = format.replace(/#s/g, date.getSeconds());
+	}
+	
+	if (format.indexOf(&quot;#T&quot;) &gt; -1) {
+		format = format.replace(/#TT/g, date.getHours() &gt;= 12 ? &quot;PM&quot; : &quot;AM&quot;);
+		format = format.replace(/#T/g, date.getHours() &gt;= 12 ? &quot;P&quot; : &quot;A&quot;);
+	}
+
+	if (format.indexOf(&quot;#t&quot;) &gt; -1) {
+		format = format.replace(/#tt/g, date.getHours() &gt;= 12 ? &quot;pm&quot; : &quot;am&quot;);
+		format = format.replace(/#t/g, date.getHours() &gt;= 12 ? &quot;p&quot; : &quot;a&quot;);
+	}
+					
+	return format;
+	
+}
+
+
+dojo.date.daysInMonth = function (month, year) {
+	dojo.deprecated(&quot;daysInMonth(month, year)&quot;,
+		&quot;replaced by getDaysInMonth(dateObject)&quot;, &quot;0.4&quot;);
+	return dojo.date.getDaysInMonth(new Date(year, month, 1));
+}
+
+/**
+ *
+ * Returns a string of the date in the version &quot;January 1, 2004&quot;
+ *
+ * @param date The date object
+ */
+dojo.date.toLongDateString = function(date) {
+	dojo.deprecated(&quot;dojo.date.toLongDateString&quot;,
+		'use dojo.date.format(date, &quot;%B %e, %Y&quot;) instead', &quot;0.4&quot;);
+	return dojo.date.format(date, &quot;%B %e, %Y&quot;)
+}
+
+/**
+ *
+ * Returns a string of the date in the version &quot;Jan 1, 2004&quot;
+ *
+ * @param date The date object
+ */
+dojo.date.toShortDateString = function(date) {
+	dojo.deprecated(&quot;dojo.date.toShortDateString&quot;,
+		'use dojo.date.format(date, &quot;%b %e, %Y&quot;) instead', &quot;0.4&quot;);
+	return dojo.date.format(date, &quot;%b %e, %Y&quot;);
+}
+
+/**
+ *
+ * Returns military formatted time
+ *
+ * @param date the date object
+ */
+dojo.date.toMilitaryTimeString = function(date){
+	dojo.deprecated(&quot;dojo.date.toMilitaryTimeString&quot;,
+		'use dojo.date.format(date, &quot;%T&quot;)', &quot;0.4&quot;);
+	return dojo.date.format(date, &quot;%T&quot;);
+}
+
+/**
+ *
+ * Returns a string of the date relative to the current date.
+ *
+ * @param date The date object
+ *
+ * Example returns:
+ * - &quot;1 minute ago&quot;
+ * - &quot;4 minutes ago&quot;
+ * - &quot;Yesterday&quot;
+ * - &quot;2 days ago&quot;
+ */
+dojo.date.toRelativeString = function(date) {
+	var now = new Date();
+	var diff = (now - date) / 1000;
+	var end = &quot; ago&quot;;
+	var future = false;
+	if(diff &lt; 0) {
+		future = true;
+		end = &quot; from now&quot;;
+		diff = -diff;
+	}
+
+	if(diff &lt; 60) {
+		diff = Math.round(diff);
+		return diff + &quot; second&quot; + (diff == 1 ? &quot;&quot; : &quot;s&quot;) + end;
+	} else if(diff &lt; 3600) {
+		diff = Math.round(diff/60);
+		return diff + &quot; minute&quot; + (diff == 1 ? &quot;&quot; : &quot;s&quot;) + end;
+	} else if(diff &lt; 3600*24 &amp;&amp; date.getDay() == now.getDay()) {
+		diff = Math.round(diff/3600);
+		return diff + &quot; hour&quot; + (diff == 1 ? &quot;&quot; : &quot;s&quot;) + end;
+	} else if(diff &lt; 3600*24*7) {
+		diff = Math.round(diff/(3600*24));
+		if(diff == 1) {
+			return future ? &quot;Tomorrow&quot; : &quot;Yesterday&quot;;
+		} else {
+			return diff + &quot; days&quot; + end;
+		}
+	} else {
+		return dojo.date.toShortDateString(date);
+	}
+}
+
+/**
+ * Retrieves the day of the week the Date is set to.
+ *
+ * @return The day of the week
+ */
+dojo.date.getDayOfWeekName = function (date) {
+	dojo.deprecated(&quot;dojo.date.getDayOfWeekName&quot;,
+		&quot;use dojo.date.getDayName instead&quot;, &quot;0.4&quot;);
+	return dojo.date.days[date.getDay()];
+}
+
+/**
+ * Retrieves the short day of the week name the Date is set to.
+ *
+ * @return The short day of the week name
+ */
+dojo.date.getShortDayOfWeekName = function (date) {
+	dojo.deprecated(&quot;dojo.date.getShortDayOfWeekName&quot;,
+		&quot;use dojo.date.getDayShortName instead&quot;, &quot;0.4&quot;);
+	return dojo.date.shortDays[date.getDay()];
+}
+
+/**
+ * Retrieves the short month name the Date is set to.
+ *
+ * @return The short month name
+ */
+dojo.date.getShortMonthName = function (date) {
+	dojo.deprecated(&quot;dojo.date.getShortMonthName&quot;,
+		&quot;use dojo.date.getMonthShortName instead&quot;, &quot;0.4&quot;);
+	return dojo.date.shortMonths[date.getMonth()];
+}
+
+
+/**
+ * Convert a Date to a SQL string, optionally ignoring the HH:MM:SS portion of the Date
+ */
+dojo.date.toSql = function(date, noTime) {
+	return dojo.date.format(date, &quot;%F&quot; + !noTime ? &quot; %T&quot; : &quot;&quot;);
+}
+
+/**
+ * Convert a SQL date string to a JavaScript Date object
+ */
+dojo.date.fromSql = function(sqlDate) {
+	var parts = sqlDate.split(/[\- :]/g);
+	while(parts.length &lt; 6) {
+		parts.push(0);
+	}
+	return new Date(parts[0], (parseInt(parts[1],10)-1), parts[2], parts[3], parts[4], parts[5]);
+}
+

Added: trunk/root/static/magic/src/debug/Firebug.js
===================================================================
--- trunk/root/static/magic/src/debug/Firebug.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/debug/Firebug.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,17 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.debug.Firebug&quot;);
+
+if (console.log) {
+	dojo.hostenv.println=console.log;
+} else {
+	dojo.debug(&quot;dojo.debug.Firebug requires Firebug &gt; 0.4&quot;);
+}

Added: trunk/root/static/magic/src/debug/arrow_hide.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/debug/arrow_hide.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/debug/arrow_show.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/debug/arrow_show.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/debug/deep.html
===================================================================
--- trunk/root/static/magic/src/debug/deep.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/debug/deep.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,359 @@
+&lt;html&gt;
+&lt;head&gt;
+&lt;title&gt;Deep Debugger&lt;/title&gt;
+&lt;script&gt;
+
+var tableRows = {};
+var tableCels = {};
+var tableObjs = {};
+var tablesBuilt = {};
+var tableShows = {};
+var tableHides = {};
+
+// IE: nodes w/id need to be redeclared or getElementById is b0rked
+var frame = null;
+
+window.onload = function(){
+	// if IE loads this page too quickly (instantly) then 
+	// window.debugVar might not have been set
+	window.setTimeout(startMeUp, 100);
+}
+
+function startMeUp(){
+	frame = document.getElementById('frame');
+	buildTable('root', frame, window.debugVar);
+}
+
+function buildTable(path, parent, obj){
+
+	var keys = [];
+	var vals = [];
+	for(var prop in obj){
+		keys.push(prop);
+		try {
+			vals[prop] = obj[prop];
+		} catch(E) {
+			vals[prop] = 'ERROR: ' + E.message;
+		}
+	}
+	keys.sort(keySorter);
+
+	if (!keys.length){
+
+		var div = document.createElement('div');
+		div.appendChild(document.createTextNode('Object has no properties.'));
+
+		parent.appendChild(div);
+		return;
+	}
+
+
+	var t = document.createElement('table');
+	t.border = &quot;1&quot;;
+
+	var tb = document.createElement('tbody');
+	t.appendChild(tb);
+
+
+	for(var i = 0; i &lt; keys.length; i++) {
+		buildTableRow(path+'-'+keys[i], tb, keys[i], vals[keys[i]]);
+	}
+
+	if (path == 'root'){
+		//t.style.width = '90%';
+	}
+	t.style.width = '100%';
+
+	parent.appendChild(t);
+
+	tablesBuilt[path] = true;
+}
+
+function buildTableRow(path, tb, name, value) {
+
+	var simpleType = typeof(value);
+	var createSubrow = (simpleType == 'object');
+	var complexType = simpleType;
+
+	if (simpleType == 'object'){
+		var cls = getConstructorClass(value);
+		if (cls){
+			if (cls == 'Object'){
+			}else if (cls == 'Array'){
+				complexType = 'array';
+			}else{
+				complexType += ' ('+cls+')';
+			}
+		}
+	}
+
+/*var tr1 = document.createElement('tr');
+	var td1 = document.createElement('td');
+	var td2 = document.createElement('td');
+	var td3 = document.createElement('td');
+	var td4 = document.createElement('td');*/
+
+	var row = tb.rows.length;
+	var tr1 = tb.insertRow(row++);
+	var td1 = tr1.insertCell(0);
+	var td2 = tr1.insertCell(1);
+	var td3 = tr1.insertCell(2);
+	var td4 = tr1.insertCell(3);
+	
+	tr1.style.verticalAlign = 'top';
+	td1.style.verticalAlign = 'middle';
+
+	td1.className = 'propPlus';
+	td2.className = 'propName';
+	td3.className = 'propType';
+	td4.className = 'propVal';
+
+	//tr1.appendChild(td1);
+	//tr1.appendChild(td2);
+	//tr1.appendChild(td3);
+	//tr1.appendChild(td4);
+
+	if (createSubrow){
+		var img1 = document.createElement('img');
+		img1.width = 9;
+		img1.height = 9;
+		img1.src = 'arrow_show.gif';
+		var a1 = document.createElement('a');
+		a1.appendChild(img1);
+		a1.href = '#';
+		a1.onclick = function(){ showTableRow(path); return false; };
+
+		var img2 = document.createElement('img');
+		img2.width = 9;
+		img2.height = 9;
+		img2.src = 'arrow_hide.gif';
+		var a2 = document.createElement('a');
+		a2.appendChild(img2);
+		a2.href = '#';
+		a2.onclick = function(){ hideTableRow(path); return false; };
+		a2.style.display = 'none';
+
+		tableShows[path] = a1;
+		tableHides[path] = a2;
+
+		td1.appendChild(a1);
+		td1.appendChild(a2);
+	}else{
+		var img = document.createElement('img');
+		img.width = 9;
+		img.height = 9;
+		img.src = 'spacer.gif';
+
+		td1.appendChild(img);
+	}
+
+	td2.appendChild(document.createTextNode(name));
+	td3.appendChild(document.createTextNode(complexType));
+	td4.appendChild(buildPreBlock(value));
+
+	//tb.appendChild(tr1);
+
+	if (createSubrow){
+		var tr2 = tb.insertRow(row++);
+		var td5 = tr2.insertCell(0);
+		var td6 = tr2.insertCell(1);
+		
+		//var tr2 = document.createElement('tr');
+		//var td5 = document.createElement('td');
+		//var td6 = document.createElement('td');
+
+		td5.innerHTML = '&nbsp;';
+		//td6.innerHTML = '&nbsp;';
+
+		td6.colSpan = '3';
+
+		tr2.appendChild(td5);
+		tr2.appendChild(td6);
+
+		tr2.style.display = 'none';
+
+		tb.appendChild(tr2);
+
+		tableRows[path] = tr2;
+		tableCels[path] = td6;
+		tableObjs[path] = value;
+	}
+}
+
+function showTableRow(path){
+
+	var tr = tableRows[path];
+	var td = tableCels[path];
+	var a1 = tableShows[path];
+	var a2 = tableHides[path];
+
+	if (!tablesBuilt[path]){
+
+		//alert('building table for '+path);
+		buildTable(path, td, tableObjs[path]);
+	}
+
+	tr.style.display = 'table-row';
+
+	a1.style.display = 'none';
+	a2.style.display = 'inline';
+}
+
+function hideTableRow(path){
+
+	var tr = tableRows[path];
+	var a1 = tableShows[path];
+	var a2 = tableHides[path];
+
+	tr.style.display = 'none';
+
+	a1.style.display = 'inline';
+	a2.style.display = 'none';
+}
+
+function buildPreBlock(value){
+
+	//
+	// how many lines ?
+	//
+
+	var s = ''+value;
+	s = s.replace(&quot;\r\n&quot;, &quot;\n&quot;);
+	s = s.replace(&quot;\r&quot;, &quot;&quot;);
+	var lines = s.split(&quot;\n&quot;);
+
+
+	if (lines.length &lt; 2){
+
+		if (lines[0].length &lt; 60){
+
+			var pre = document.createElement('pre');
+			pre.appendChild(document.createTextNode(s));
+			return pre;
+		}
+	}
+
+
+	//
+	// multiple lines :(
+	//
+
+	var preview = lines[0].substr(0, 60) + ' ...';
+
+	var pre1 = document.createElement('pre');
+	pre1.appendChild(document.createTextNode(preview));
+	pre1.className = 'clicky';
+
+	var pre2 = document.createElement('pre');
+	pre2.appendChild(document.createTextNode(s));
+	pre2.style.display = 'none';
+	pre2.className = 'clicky';
+
+	pre1.onclick = function(){
+		pre1.style.display = 'none';
+		pre2.style.display = 'block';
+	}
+
+	pre2.onclick = function(){
+		pre1.style.display = 'block';
+		pre2.style.display = 'none';
+	}
+
+	var pre = document.createElement('div');
+
+	pre.appendChild(pre1);
+	pre.appendChild(pre2);
+
+	return pre;
+}
+
+function getConstructorClass(obj){
+
+	if (!obj.constructor || !obj.constructor.toString) return;
+
+	var m = obj.constructor.toString().match(/function\s*(\w+)/);
+
+	if (m &amp;&amp; m.length == 2) return m[1];
+
+	return null;
+}
+
+function keySorter(a, b){
+
+	if (a == parseInt(a) &amp;&amp; b == parseInt(b)){
+
+		return (parseInt(a) &gt; parseInt(b)) ? 1 : ((parseInt(a) &lt; parseInt(b)) ? -1 : 0);
+	}
+
+	// sort by lowercase string
+
+	var a2 = String(a).toLowerCase();
+	var b2 = String(b).toLowerCase();
+
+	return (a2 &gt; b2) ? 1 : ((a2 &lt; b2) ? -1 : 0);
+}
+
+&lt;/script&gt;
+&lt;style&gt;
+
+body {
+	font-family: arial, helvetica, sans-serif;
+}
+
+table {
+	border-width: 0px;
+	border-spacing: 1px;
+	border-collapse: separate;
+}
+
+td {
+	border-width: 0px;
+	padding: 2px;
+}
+
+img {
+	border: 0;
+}
+
+pre {
+	margin: 0;
+	padding: 0;
+	white-space: -moz-pre-wrap;  /* Mozilla, supported since 1999 */
+	white-space: -pre-wrap;      /* Opera 4 - 6 */
+	white-space: -o-pre-wrap;    /* Opera 7 */
+	white-space: pre-wrap;       /* CSS3 - Text module (Candidate Recommendation) <A HREF="http://www.w3.org/TR/css3-text/#white-space">http://www.w3.org/TR/css3-text/#white-space</A> */
+	word-wrap: break-word;       /* IE 5.5+ */
+}
+
+pre.clicky {
+	cursor: hand;
+	cursor: pointer;
+}
+
+td.propPlus {
+	width: 9px;
+	background-color: #ddd;
+}
+
+td.propName {
+	background-color: #ddd;
+}
+
+td.propType {
+	background-color: #ddd;
+}
+
+td.propVal {
+	background-color: #ddd;
+}
+
+&lt;/style&gt;
+&lt;/head&gt;
+&lt;body&gt;
+
+&lt;h2&gt;Javascript Object Browser&lt;/h2&gt;
+
+&lt;div id=&quot;frame&quot;&gt;&lt;/div&gt;
+
+&lt;/body&gt;
+&lt;/html&gt;
\ No newline at end of file


Property changes on: trunk/root/static/magic/src/debug/deep.html
___________________________________________________________________
Name: svn:mime-type
   + text/html

Added: trunk/root/static/magic/src/debug/spacer.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/debug/spacer.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/debug.js
===================================================================
--- trunk/root/static/magic/src/debug.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/debug.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,80 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+ * Produce a line of debug output. 
+ * Does nothing unless djConfig.isDebug is true.
+ * varargs, joined with ''.
+ * Caller should not supply a trailing &quot;\n&quot;.
+ */
+dojo.debug = function(){
+	if (!djConfig.isDebug) { return; }
+	var args = arguments;
+	if(dj_undef(&quot;println&quot;, dojo.hostenv)){
+		dojo.raise(&quot;dojo.debug not available (yet?)&quot;);
+	}
+	var isJUM = dj_global[&quot;jum&quot;] &amp;&amp; !dj_global[&quot;jum&quot;].isBrowser;
+	var s = [(isJUM ? &quot;&quot;: &quot;DEBUG: &quot;)];
+	for(var i=0;i&lt;args.length;++i){
+		if(!false &amp;&amp; args[i] &amp;&amp; args[i] instanceof Error){
+			var msg = &quot;[&quot; + args[i].name + &quot;: &quot; + dojo.errorToString(args[i]) +
+				(args[i].fileName ? &quot;, file: &quot; + args[i].fileName : &quot;&quot;) +
+				(args[i].lineNumber ? &quot;, line: &quot; + args[i].lineNumber : &quot;&quot;) + &quot;]&quot;;
+		} else {
+			try {
+				var msg = String(args[i]);
+			} catch(e) {
+				if(dojo.render.html.ie) {
+					var msg = &quot;[ActiveXObject]&quot;;
+				} else {
+					var msg = &quot;[unknown]&quot;;
+				}
+			}
+		}
+		s.push(msg);
+	}
+	if(isJUM){ // this seems to be the only way to get JUM to &quot;play nice&quot;
+		jum.debug(s.join(&quot; &quot;));
+	}else{
+		dojo.hostenv.println(s.join(&quot; &quot;));
+	}
+}
+
+/**
+ * this is really hacky for now - just 
+ * display the properties of the object
+**/
+
+dojo.debugShallow = function(obj){
+	if (!djConfig.isDebug) { return; }
+	dojo.debug('------------------------------------------------------------');
+	dojo.debug('Object: '+obj);
+	var props = [];
+	for(var prop in obj){
+		try {
+			props.push(prop + ': ' + obj[prop]);
+		} catch(E) {
+			props.push(prop + ': ERROR - ' + E.message);
+		}
+	}
+	props.sort();
+	for(var i = 0; i &lt; props.length; i++) {
+		dojo.debug(props[i]);
+	}
+	dojo.debug('------------------------------------------------------------');
+}
+
+dojo.debugDeep = function(obj){
+	if (!djConfig.isDebug) { return; }
+	if (!dojo.uri || !dojo.uri.dojoUri){ return dojo.debug(&quot;You'll need to load dojo.uri.* for deep debugging - sorry!&quot;); }
+	if (!window.open){ return dojo.debug('Deep debugging is only supported in host environments with window.open'); }
+	var win = window.open(dojo.uri.dojoUri(&quot;src/debug/deep.html&quot;), '_blank', 'width=600, height=400, resizable=yes, scrollbars=yes, status=yes');
+	win.debugVar = obj;
+}

Added: trunk/root/static/magic/src/dnd/DragAndDrop.js
===================================================================
--- trunk/root/static/magic/src/dnd/DragAndDrop.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/DragAndDrop.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,175 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.lang&quot;);
+dojo.provide(&quot;dojo.dnd.DragSource&quot;);
+dojo.provide(&quot;dojo.dnd.DropTarget&quot;);
+dojo.provide(&quot;dojo.dnd.DragObject&quot;);
+dojo.provide(&quot;dojo.dnd.DragAndDrop&quot;);
+
+dojo.dnd.DragSource = function(){
+	var dm = dojo.dnd.dragManager;
+	if(dm[&quot;registerDragSource&quot;]){ // side-effect prevention
+		dm.registerDragSource(this);
+	}
+}
+
+dojo.lang.extend(dojo.dnd.DragSource, {
+	type: &quot;&quot;,
+
+	onDragEnd: function(){
+	},
+
+	onDragStart: function(){
+	},
+
+	/*
+	 * This function gets called when the DOM element was 
+	 * selected for dragging by the HtmlDragAndDropManager.
+	 */
+	onSelected: function(){
+	},
+
+	unregister: function(){
+		dojo.dnd.dragManager.unregisterDragSource(this);
+	},
+
+	reregister: function(){
+		dojo.dnd.dragManager.registerDragSource(this);
+	}
+});
+
+dojo.dnd.DragObject = function(){
+	var dm = dojo.dnd.dragManager;
+	if(dm[&quot;registerDragObject&quot;]){ // side-effect prevention
+		dm.registerDragObject(this);
+	}
+}
+
+dojo.lang.extend(dojo.dnd.DragObject, {
+	type: &quot;&quot;,
+
+	onDragStart: function(){
+		// gets called directly after being created by the DragSource
+		// default action is to clone self as icon
+	},
+
+	onDragMove: function(){
+		// this changes the UI for the drag icon
+		//	&quot;it moves itself&quot;
+	},
+
+	onDragOver: function(){
+	},
+
+	onDragOut: function(){
+	},
+
+	onDragEnd: function(){
+	},
+
+	// normal aliases
+	onDragLeave: this.onDragOut,
+	onDragEnter: this.onDragOver,
+
+	// non-camel aliases
+	ondragout: this.onDragOut,
+	ondragover: this.onDragOver
+});
+
+dojo.dnd.DropTarget = function(){
+	if (this.constructor == dojo.dnd.DropTarget) { return; } // need to be subclassed
+	this.acceptedTypes = [];
+	dojo.dnd.dragManager.registerDropTarget(this);
+}
+
+dojo.lang.extend(dojo.dnd.DropTarget, {
+
+	acceptsType: function(type){
+		if(!dojo.lang.inArray(this.acceptedTypes, &quot;*&quot;)){ // wildcard
+			if(!dojo.lang.inArray(this.acceptedTypes, type)) { return false; }
+		}
+		return true;
+	},
+
+	accepts: function(dragObjects){
+		if(!dojo.lang.inArray(this.acceptedTypes, &quot;*&quot;)){ // wildcard
+			for (var i = 0; i &lt; dragObjects.length; i++) {
+				if (!dojo.lang.inArray(this.acceptedTypes,
+					dragObjects[i].type)) { return false; }
+			}
+		}
+		return true;
+	},
+
+	onDragOver: function(){
+	},
+
+	onDragOut: function(){
+	},
+
+	onDragMove: function(){
+	},
+
+	onDropStart: function(){
+	},
+
+	onDrop: function(){
+	},
+
+	onDropEnd: function(){
+	}
+});
+
+// NOTE: this interface is defined here for the convenience of the DragManager
+// implementor. It is expected that in most cases it will be satisfied by
+// extending a native event (DOM event in HTML and SVG).
+dojo.dnd.DragEvent = function(){
+	this.dragSource = null;
+	this.dragObject = null;
+	this.target = null;
+	this.eventStatus = &quot;success&quot;;
+	//
+	// can be one of:
+	//	[	&quot;dropSuccess&quot;, &quot;dropFailure&quot;, &quot;dragMove&quot;,
+	//		&quot;dragStart&quot;, &quot;dragEnter&quot;, &quot;dragLeave&quot;]
+	//
+}
+
+dojo.dnd.DragManager = function(){
+	/*
+	 *	The DragManager handles listening for low-level events and dispatching
+	 *	them to higher-level primitives like drag sources and drop targets. In
+	 *	order to do this, it must keep a list of the items.
+	 */
+}
+
+dojo.lang.extend(dojo.dnd.DragManager, {
+	selectedSources: [],
+	dragObjects: [],
+	dragSources: [],
+	registerDragSource: function(){},
+	dropTargets: [],
+	registerDropTarget: function(){},
+	lastDragTarget: null,
+	currentDragTarget: null,
+	onKeyDown: function(){},
+	onMouseOut: function(){},
+	onMouseMove: function(){},
+	onMouseUp: function(){}
+});
+
+// NOTE: despite the existance of the DragManager class, there will be a
+// singleton drag manager provided by the renderer-specific D&amp;D support code.
+// It is therefore sane for us to assign instance variables to the DragManager
+// prototype
+
+// The renderer-specific file will define the following object:
+// dojo.dnd.dragManager = null;

Added: trunk/root/static/magic/src/dnd/HtmlDragAndDrop.js
===================================================================
--- trunk/root/static/magic/src/dnd/HtmlDragAndDrop.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/HtmlDragAndDrop.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,475 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.dnd.HtmlDragAndDrop&quot;);
+dojo.provide(&quot;dojo.dnd.HtmlDragSource&quot;);
+dojo.provide(&quot;dojo.dnd.HtmlDropTarget&quot;);
+dojo.provide(&quot;dojo.dnd.HtmlDragObject&quot;);
+
+dojo.require(&quot;dojo.dnd.HtmlDragManager&quot;);
+dojo.require(&quot;dojo.dnd.DragAndDrop&quot;);
+
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.html.extras&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+dojo.require(&quot;dojo.event&quot;);
+
+dojo.dnd.HtmlDragSource = function(node, type){
+	node = dojo.byId(node);
+	this.dragObjects = [];
+	this.constrainToContainer = false;
+	if(node){
+		this.domNode = node;
+		this.dragObject = node;
+		// register us
+		dojo.dnd.DragSource.call(this);
+		// set properties that might have been clobbered by the mixin
+		this.type = (type)||(this.domNode.nodeName.toLowerCase());
+	}
+}
+dojo.inherits(dojo.dnd.HtmlDragSource, dojo.dnd.DragSource);
+dojo.lang.extend(dojo.dnd.HtmlDragSource, {
+	dragClass: &quot;&quot;, // CSS classname(s) applied to node when it is being dragged
+
+	onDragStart: function(){
+		var dragObj = new dojo.dnd.HtmlDragObject(this.dragObject, this.type);
+		if(this.dragClass) { dragObj.dragClass = this.dragClass; }
+
+		if (this.constrainToContainer) {
+			dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
+		}
+
+		return dragObj;
+	},
+
+	setDragHandle: function(node){
+		node = dojo.byId(node);
+		dojo.dnd.dragManager.unregisterDragSource(this);
+		this.domNode = node;
+		dojo.dnd.dragManager.registerDragSource(this);
+	},
+
+	setDragTarget: function(node){
+		this.dragObject = node;
+	},
+
+	constrainTo: function(container) {
+		this.constrainToContainer = true;
+		if (container) {
+			this.constrainingContainer = container;
+		}
+	},
+	
+	/*
+	*
+	* see dojo.dnd.DragSource.onSelected
+	*/
+	onSelected: function() {
+		for (var i=0; i&lt;this.dragObjects.length; i++) {
+			dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragSource(this.dragObjects[i]));
+		}
+	},
+
+	/**
+	* Register elements that should be dragged along with
+	* the actual DragSource.
+	*
+	* Example usage:
+	* 	var dragSource = new dojo.dnd.HtmlDragSource(...);
+	*	// add a single element
+	*	dragSource.addDragObjects(dojo.byId('id1'));
+	*	// add multiple elements to drag along
+	*	dragSource.addDragObjects(dojo.byId('id2'), dojo.byId('id3'));
+	*
+	* el A dom node to add to the drag list.
+	*/
+	addDragObjects: function(/*DOMNode*/ el) {
+		for (var i=0; i&lt;arguments.length; i++) {
+			this.dragObjects.push(arguments[i]);
+		}
+	}
+});
+
+dojo.dnd.HtmlDragObject = function(node, type){
+	this.domNode = dojo.byId(node);
+	this.type = type;
+	this.constrainToContainer = false;
+	this.dragSource = null;
+}
+dojo.inherits(dojo.dnd.HtmlDragObject, dojo.dnd.DragObject);
+dojo.lang.extend(dojo.dnd.HtmlDragObject, {
+	dragClass: &quot;&quot;,
+	opacity: 0.5,
+	createIframe: true,		// workaround IE6 bug
+
+	// if true, node will not move in X and/or Y direction
+	disableX: false,
+	disableY: false,
+
+	createDragNode: function() {
+		var node = this.domNode.cloneNode(true);
+		if(this.dragClass) { dojo.html.addClass(node, this.dragClass); }
+		if(this.opacity &lt; 1) { dojo.style.setOpacity(node, this.opacity); }
+		if(node.tagName.toLowerCase() == &quot;tr&quot;){
+			// dojo.debug(&quot;Dragging table row&quot;)
+			// Create a table for the cloned row
+			var doc = this.domNode.ownerDocument;
+			var table = doc.createElement(&quot;table&quot;);
+			var tbody = doc.createElement(&quot;tbody&quot;);
+			tbody.appendChild(node);
+			table.appendChild(tbody);
+
+			// Set a fixed width to the cloned TDs
+			var domTds = this.domNode.childNodes;
+			var cloneTds = node.childNodes;
+			for(var i = 0; i &lt; domTds.length; i++){
+			    if((cloneTds[i])&amp;&amp;(cloneTds[i].style)){
+				    cloneTds[i].style.width = dojo.style.getContentWidth(domTds[i]) + &quot;px&quot;;
+			    }
+			}
+			node = table;
+		}
+
+		if((dojo.render.html.ie55||dojo.render.html.ie60) &amp;&amp; this.createIframe){
+			with(node.style) {
+				top=&quot;0px&quot;;
+				left=&quot;0px&quot;;
+			}
+			var outer = document.createElement(&quot;div&quot;);
+			outer.appendChild(node);
+			this.bgIframe = new dojo.html.BackgroundIframe(outer);
+			outer.appendChild(this.bgIframe.iframe);
+			node = outer;
+		}
+		node.style.zIndex = 999;
+		return node;
+	},
+
+	onDragStart: function(e){
+		dojo.html.clearSelection();
+
+		this.scrollOffset = dojo.html.getScrollOffset();
+		this.dragStartPosition = dojo.style.getAbsolutePosition(this.domNode, true);
+
+		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
+			x: this.dragStartPosition.x - e.pageX};
+
+		this.dragClone = this.createDragNode();
+
+		this.containingBlockPosition = this.domNode.offsetParent ? 
+			dojo.style.getAbsolutePosition(this.domNode.offsetParent) : {x:0, y:0};
+
+		if (this.constrainToContainer) {
+			this.constraints = this.getConstraints();
+		}
+
+		// set up for dragging
+		with(this.dragClone.style){
+			position = &quot;absolute&quot;;
+			top = this.dragOffset.y + e.pageY + &quot;px&quot;;
+			left = this.dragOffset.x + e.pageX + &quot;px&quot;;
+		}
+
+		document.body.appendChild(this.dragClone);
+
+		dojo.event.topic.publish('dragStart', { source: this } );
+	},
+
+	/** Return min/max x/y (relative to document.body) for this object) **/
+	getConstraints: function() {
+		if (this.constrainingContainer.nodeName.toLowerCase() == 'body') {
+			var width = dojo.html.getViewportWidth();
+			var height = dojo.html.getViewportHeight();
+			var x = 0;
+			var y = 0;
+		} else {
+			width = dojo.style.getContentWidth(this.constrainingContainer);
+			height = dojo.style.getContentHeight(this.constrainingContainer);
+			x =
+				this.containingBlockPosition.x +
+				dojo.style.getPixelValue(this.constrainingContainer, &quot;padding-left&quot;, true) +
+				dojo.style.getBorderExtent(this.constrainingContainer, &quot;left&quot;);
+			y =
+				this.containingBlockPosition.y +
+				dojo.style.getPixelValue(this.constrainingContainer, &quot;padding-top&quot;, true) +
+				dojo.style.getBorderExtent(this.constrainingContainer, &quot;top&quot;);
+		}
+
+		return {
+			minX: x,
+			minY: y,
+			maxX: x + width - dojo.style.getOuterWidth(this.domNode),
+			maxY: y + height - dojo.style.getOuterHeight(this.domNode)
+		}
+	},
+
+	updateDragOffset: function() {
+		var scroll = dojo.html.getScrollOffset();
+		if(scroll.y != this.scrollOffset.y) {
+			var diff = scroll.y - this.scrollOffset.y;
+			this.dragOffset.y += diff;
+			this.scrollOffset.y = scroll.y;
+		}
+		if(scroll.x != this.scrollOffset.x) {
+			var diff = scroll.x - this.scrollOffset.x;
+			this.dragOffset.x += diff;
+			this.scrollOffset.x = scroll.x;
+		}
+	},
+
+	/** Moves the node to follow the mouse */
+	onDragMove: function(e){
+		this.updateDragOffset();
+		var x = this.dragOffset.x + e.pageX;
+		var y = this.dragOffset.y + e.pageY;
+
+		if (this.constrainToContainer) {
+			if (x &lt; this.constraints.minX) { x = this.constraints.minX; }
+			if (y &lt; this.constraints.minY) { y = this.constraints.minY; }
+			if (x &gt; this.constraints.maxX) { x = this.constraints.maxX; }
+			if (y &gt; this.constraints.maxY) { y = this.constraints.maxY; }
+		}
+
+		this.setAbsolutePosition(x, y);
+
+		dojo.event.topic.publish('dragMove', { source: this } );
+	},
+
+	/**
+	 * Set the position of the drag clone.  (x,y) is relative to &lt;body&gt;.
+	 */
+	setAbsolutePosition: function(x, y){
+		// The drag clone is attached to document.body so this is trivial
+		if(!this.disableY) { this.dragClone.style.top = y + &quot;px&quot;; }
+		if(!this.disableX) { this.dragClone.style.left = x + &quot;px&quot;; }
+	},
+
+
+	/**
+	 * If the drag operation returned a success we reomve the clone of
+	 * ourself from the original position. If the drag operation returned
+	 * failure we slide back over to where we came from and end the operation
+	 * with a little grace.
+	 */
+	onDragEnd: function(e){
+		switch(e.dragStatus){
+
+			case &quot;dropSuccess&quot;:
+				dojo.dom.removeNode(this.dragClone);
+				this.dragClone = null;
+				break;
+
+			case &quot;dropFailure&quot;: // slide back to the start
+				var startCoords = dojo.style.getAbsolutePosition(this.dragClone, true);
+				// offset the end so the effect can be seen
+				var endCoords = [this.dragStartPosition.x + 1,
+					this.dragStartPosition.y + 1];
+
+				// animate
+				var line = new dojo.lfx.Line(startCoords, endCoords);
+				var anim = new dojo.lfx.Animation(500, line, dojo.lfx.easeOut);
+				var dragObject = this;
+				dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+					dragObject.dragClone.style.left = e[0] + &quot;px&quot;;
+					dragObject.dragClone.style.top = e[1] + &quot;px&quot;;
+				});
+				dojo.event.connect(anim, &quot;onEnd&quot;, function (e) {
+					// pause for a second (not literally) and disappear
+					dojo.lang.setTimeout(function() {
+							dojo.dom.removeNode(dragObject.dragClone);
+							// Allow drag clone to be gc'ed
+							dragObject.dragClone = null;
+						},
+						200);
+				});
+				anim.play();
+				break;
+		}
+
+		// shortly the browser will fire an onClick() event,
+		// but since this was really a drag, just squelch it
+		dojo.event.connect(this.domNode, &quot;onclick&quot;, this, &quot;squelchOnClick&quot;);
+
+		dojo.event.topic.publish('dragEnd', { source: this } );
+	},
+
+	squelchOnClick: function(e){
+		// squelch this onClick() event because it's the result of a drag (it's not a real click)
+		e.preventDefault();
+
+		// but if a real click comes along, allow it
+		dojo.event.disconnect(this.domNode, &quot;onclick&quot;, this, &quot;squelchOnClick&quot;);
+	},
+
+	constrainTo: function(container) {
+		this.constrainToContainer=true;
+		if (container) {
+			this.constrainingContainer = container;
+		} else {
+			this.constrainingContainer = this.domNode.parentNode;
+		}
+	}
+});
+
+dojo.dnd.HtmlDropTarget = function(node, types){
+	if (arguments.length == 0) { return; }
+	this.domNode = dojo.byId(node);
+	dojo.dnd.DropTarget.call(this);
+	if(types &amp;&amp; dojo.lang.isString(types)) {
+		types = [types];
+	}
+	this.acceptedTypes = types || [];
+}
+dojo.inherits(dojo.dnd.HtmlDropTarget, dojo.dnd.DropTarget);
+
+dojo.lang.extend(dojo.dnd.HtmlDropTarget, {
+	onDragOver: function(e){
+		if(!this.accepts(e.dragObjects)){ return false; }
+
+		// cache the positions of the child nodes
+		this.childBoxes = [];
+		for (var i = 0, child; i &lt; this.domNode.childNodes.length; i++) {
+			child = this.domNode.childNodes[i];
+			if (child.nodeType != dojo.dom.ELEMENT_NODE) { continue; }
+			var pos = dojo.style.getAbsolutePosition(child, true);
+			var height = dojo.style.getInnerHeight(child);
+			var width = dojo.style.getInnerWidth(child);
+			this.childBoxes.push({top: pos.y, bottom: pos.y+height,
+				left: pos.x, right: pos.x+width, node: child});
+		}
+
+		// TODO: use dummy node
+
+		return true;
+	},
+
+	_getNodeUnderMouse: function(e){
+		// find the child
+		for (var i = 0, child; i &lt; this.childBoxes.length; i++) {
+			with (this.childBoxes[i]) {
+				if (e.pageX &gt;= left &amp;&amp; e.pageX &lt;= right &amp;&amp;
+					e.pageY &gt;= top &amp;&amp; e.pageY &lt;= bottom) { return i; }
+			}
+		}
+
+		return -1;
+	},
+
+	createDropIndicator: function() {
+		this.dropIndicator = document.createElement(&quot;div&quot;);
+		with (this.dropIndicator.style) {
+			position = &quot;absolute&quot;;
+			zIndex = 999;
+			borderTopWidth = &quot;1px&quot;;
+			borderTopColor = &quot;black&quot;;
+			borderTopStyle = &quot;solid&quot;;
+			width = dojo.style.getInnerWidth(this.domNode) + &quot;px&quot;;
+			left = dojo.style.getAbsoluteX(this.domNode, true) + &quot;px&quot;;
+		}
+	},
+
+	onDragMove: function(e, dragObjects){
+		var i = this._getNodeUnderMouse(e);
+
+		if(!this.dropIndicator){
+			this.createDropIndicator();
+		}
+
+		if(i &lt; 0) {
+			if(this.childBoxes.length) {
+				var before = (dojo.html.gravity(this.childBoxes[0].node, e) &amp; dojo.html.gravity.NORTH);
+			} else {
+				var before = true;
+			}
+		} else {
+			var child = this.childBoxes[i];
+			var before = (dojo.html.gravity(child.node, e) &amp; dojo.html.gravity.NORTH);
+		}
+		this.placeIndicator(e, dragObjects, i, before);
+
+		if(!dojo.html.hasParent(this.dropIndicator)) {
+			document.body.appendChild(this.dropIndicator);
+		}
+	},
+
+	/**
+	 * Position the horizontal line that indicates &quot;insert between these two items&quot;
+	 */
+	placeIndicator: function(e, dragObjects, boxIndex, before) {
+		with(this.dropIndicator.style){
+			if (boxIndex &lt; 0) {
+				if (this.childBoxes.length) {
+					top = (before ? this.childBoxes[0].top
+						: this.childBoxes[this.childBoxes.length - 1].bottom) + &quot;px&quot;;
+				} else {
+					top = dojo.style.getAbsoluteY(this.domNode, true) + &quot;px&quot;;
+				}
+			} else {
+				var child = this.childBoxes[boxIndex];
+				top = (before ? child.top : child.bottom) + &quot;px&quot;;
+			}
+		}
+	},
+
+	onDragOut: function(e) {
+		if(this.dropIndicator) {
+			dojo.dom.removeNode(this.dropIndicator);
+			delete this.dropIndicator;
+		}
+	},
+
+	/**
+	 * Inserts the DragObject as a child of this node relative to the
+	 * position of the mouse.
+	 *
+	 * @return true if the DragObject was inserted, false otherwise
+	 */
+	onDrop: function(e){
+		this.onDragOut(e);
+
+		var i = this._getNodeUnderMouse(e);
+
+		if (i &lt; 0) {
+			if (this.childBoxes.length) {
+				if (dojo.html.gravity(this.childBoxes[0].node, e) &amp; dojo.html.gravity.NORTH) {
+					return this.insert(e, this.childBoxes[0].node, &quot;before&quot;);
+				} else {
+					return this.insert(e, this.childBoxes[this.childBoxes.length-1].node, &quot;after&quot;);
+				}
+			}
+			return this.insert(e, this.domNode, &quot;append&quot;);
+		}
+
+		var child = this.childBoxes[i];
+		if (dojo.html.gravity(child.node, e) &amp; dojo.html.gravity.NORTH) {
+			return this.insert(e, child.node, &quot;before&quot;);
+		} else {
+			return this.insert(e, child.node, &quot;after&quot;);
+		}
+	},
+
+	insert: function(e, refNode, position) {
+		var node = e.dragObject.domNode;
+
+		if(position == &quot;before&quot;) {
+			return dojo.html.insertBefore(node, refNode);
+		} else if(position == &quot;after&quot;) {
+			return dojo.html.insertAfter(node, refNode);
+		} else if(position == &quot;append&quot;) {
+			refNode.appendChild(node);
+			return true;
+		}
+
+		return false;
+	}
+});

Added: trunk/root/static/magic/src/dnd/HtmlDragManager.js
===================================================================
--- trunk/root/static/magic/src/dnd/HtmlDragManager.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/HtmlDragManager.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,475 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.dnd.HtmlDragManager&quot;);
+dojo.require(&quot;dojo.dnd.DragAndDrop&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+// NOTE: there will only ever be a single instance of HTMLDragManager, so it's
+// safe to use prototype properties for book-keeping.
+dojo.dnd.HtmlDragManager = function(){
+}
+
+dojo.inherits(dojo.dnd.HtmlDragManager, dojo.dnd.DragManager);
+
+dojo.lang.extend(dojo.dnd.HtmlDragManager, {
+	/**
+	 * There are several sets of actions that the DnD code cares about in the
+	 * HTML context:
+	 *	1.) mouse-down -&gt;
+	 *			(draggable selection)
+	 *			(dragObject generation)
+	 *		mouse-move -&gt;
+	 *			(draggable movement)
+	 *			(droppable detection)
+	 *			(inform droppable)
+	 *			(inform dragObject)
+	 *		mouse-up
+	 *			(inform/destroy dragObject)
+	 *			(inform draggable)
+	 *			(inform droppable)
+	 *	2.) mouse-down -&gt; mouse-down
+	 *			(click-hold context menu)
+	 *	3.) mouse-click -&gt;
+	 *			(draggable selection)
+	 *		shift-mouse-click -&gt;
+	 *			(augment draggable selection)
+	 *		mouse-down -&gt;
+	 *			(dragObject generation)
+	 *		mouse-move -&gt;
+	 *			(draggable movement)
+	 *			(droppable detection)
+	 *			(inform droppable)
+	 *			(inform dragObject)
+	 *		mouse-up
+	 *			(inform draggable)
+	 *			(inform droppable)
+	 *	4.) mouse-up
+	 *			(clobber draggable selection)
+	 */
+	disabled: false, // to kill all dragging!
+	nestedTargets: false,
+	mouseDownTimer: null, // used for click-hold operations
+	dsCounter: 0,
+	dsPrefix: &quot;dojoDragSource&quot;,
+
+	// dimension calculation cache for use durring drag
+	dropTargetDimensions: [],
+
+	currentDropTarget: null,
+	// currentDropTargetPoints: null,
+	previousDropTarget: null,
+	_dragTriggered: false,
+
+	selectedSources: [],
+	dragObjects: [],
+
+	// mouse position properties
+	currentX: null,
+	currentY: null,
+	lastX: null,
+	lastY: null,
+	mouseDownX: null,
+	mouseDownY: null,
+	threshold: 7,
+
+	dropAcceptable: false,
+
+	cancelEvent: function(e){ e.stopPropagation(); e.preventDefault();},
+
+	// method over-rides
+	registerDragSource: function(ds){
+		if(ds[&quot;domNode&quot;]){
+			// FIXME: dragSource objects SHOULD have some sort of property that
+			// references their DOM node, we shouldn't just be passing nodes and
+			// expecting it to work.
+			var dp = this.dsPrefix;
+			var dpIdx = dp+&quot;Idx_&quot;+(this.dsCounter++);
+			ds.dragSourceId = dpIdx;
+			this.dragSources[dpIdx] = ds;
+			ds.domNode.setAttribute(dp, dpIdx);
+
+			// so we can drag links
+			if(dojo.render.html.ie){
+				dojo.event.connect(ds.domNode, &quot;ondragstart&quot;, this.cancelEvent);
+			}
+		}
+	},
+
+	unregisterDragSource: function(ds){
+		if (ds[&quot;domNode&quot;]){
+
+			var dp = this.dsPrefix;
+			var dpIdx = ds.dragSourceId;
+			delete ds.dragSourceId;
+			delete this.dragSources[dpIdx];
+			ds.domNode.setAttribute(dp, null);
+		}
+		if(dojo.render.html.ie){
+			dojo.event.disconnect(ds.domNode, &quot;ondragstart&quot;, this.cancelEvent );
+		}
+	},
+
+	registerDropTarget: function(dt){
+		this.dropTargets.push(dt);
+	},
+
+	unregisterDropTarget: function(dt){
+		var index = dojo.lang.find(this.dropTargets, dt, true);
+		if (index&gt;=0) {
+			this.dropTargets.splice(index, 1);
+		}
+	},
+
+	/**
+	* Get the DOM element that is meant to drag.
+	* Loop through the parent nodes of the event target until
+	* the element is found that was created as a DragSource and 
+	* return it.
+	*
+	* @param event object The event for which to get the drag source.
+	*/
+	getDragSource: function(e){
+		var tn = e.target;
+		if(tn === document.body){ return; }
+		var ta = dojo.html.getAttribute(tn, this.dsPrefix);
+		while((!ta)&amp;&amp;(tn)){
+			tn = tn.parentNode;
+			if((!tn)||(tn === document.body)){ return; }
+			ta = dojo.html.getAttribute(tn, this.dsPrefix);
+		}
+		return this.dragSources[ta];
+	},
+
+	onKeyDown: function(e){
+	},
+
+	onMouseDown: function(e){
+		if(this.disabled) { return; }
+
+		// only begin on left click
+		if(dojo.render.html.ie) {
+			if(e.button != 1) { return; }
+		} else if(e.which != 1) {
+			return;
+		}
+
+		var target = e.target.nodeType == dojo.dom.TEXT_NODE ?
+			e.target.parentNode : e.target;
+
+		// do not start drag involvement if the user is interacting with
+		// a form element.
+		if(dojo.html.isTag(target, &quot;button&quot;, &quot;textarea&quot;, &quot;input&quot;, &quot;select&quot;, &quot;option&quot;)) {
+			return;
+		}
+
+		// find a selection object, if one is a parent of the source node
+		var ds = this.getDragSource(e);
+		
+		// this line is important.  if we aren't selecting anything then
+		// we need to return now, so preventDefault() isn't called, and thus
+		// the event is propogated to other handling code
+		if(!ds){ return; }
+
+		if(!dojo.lang.inArray(this.selectedSources, ds)){
+			this.selectedSources.push(ds);
+			ds.onSelected();
+		}
+
+ 		this.mouseDownX = e.pageX;
+ 		this.mouseDownY = e.pageY;
+
+		// Must stop the mouse down from being propogated, or otherwise can't
+		// drag links in firefox.
+		// WARNING: preventing the default action on all mousedown events
+		// prevents user interaction with the contents.
+		e.preventDefault();
+
+		dojo.event.connect(document, &quot;onmousemove&quot;, this, &quot;onMouseMove&quot;);
+	},
+
+	onMouseUp: function(e, cancel){
+		// if we aren't dragging then ignore the mouse-up
+		// (in particular, don't call preventDefault(), because other
+		// code may need to process this event)
+		if(this.selectedSources.length==0){
+			return;
+		}
+
+		this.mouseDownX = null;
+		this.mouseDownY = null;
+		this._dragTriggered = false;
+ 		// e.preventDefault();
+		e.dragSource = this.dragSource;
+		if((!e.shiftKey)&amp;&amp;(!e.ctrlKey)){
+			if(this.currentDropTarget) {
+				this.currentDropTarget.onDropStart();
+			}
+			dojo.lang.forEach(this.dragObjects, function(tempDragObj){
+				var ret = null;
+				if(!tempDragObj){ return; }
+				if(this.currentDropTarget) {
+					e.dragObject = tempDragObj;
+
+					// NOTE: we can't get anything but the current drop target
+					// here since the drag shadow blocks mouse-over events.
+					// This is probelematic for dropping &quot;in&quot; something
+					var ce = this.currentDropTarget.domNode.childNodes;
+					if(ce.length &gt; 0){
+						e.dropTarget = ce[0];
+						while(e.dropTarget == tempDragObj.domNode){
+							e.dropTarget = e.dropTarget.nextSibling;
+						}
+					}else{
+						e.dropTarget = this.currentDropTarget.domNode;
+					}
+					if(this.dropAcceptable){
+						ret = this.currentDropTarget.onDrop(e);
+					}else{
+						 this.currentDropTarget.onDragOut(e);
+					}
+				}
+
+				e.dragStatus = this.dropAcceptable &amp;&amp; ret ? &quot;dropSuccess&quot; : &quot;dropFailure&quot;;
+				// decouple the calls for onDragEnd, so they don't block the execution here
+				// ie. if the onDragEnd would call an alert, the execution here is blocked until the
+				// user has confirmed the alert box and then the rest of the dnd code is executed
+				// while the mouse doesnt &quot;hold&quot; the dragged object anymore ... and so on
+				dojo.lang.delayThese([
+					function() {
+						// in FF1.5 this throws an exception, see 
+						// <A HREF="http://dojotoolkit.org/pipermail/dojo-interest/2006-April/006751.html">http://dojotoolkit.org/pipermail/dojo-interest/2006-April/006751.html</A>
+						try{
+							tempDragObj.dragSource.onDragEnd(e)
+						} catch(err) {
+							// since the problem seems passing e, we just copy all 
+							// properties and try the copy ...
+							var ecopy = {};
+							for (var i in e) {
+								if (i==&quot;type&quot;) { // the type property contains the exception, no idea why...
+									ecopy.type = &quot;mouseup&quot;;
+									continue;
+								}
+								ecopy[i] = e[i];
+							}
+							tempDragObj.dragSource.onDragEnd(ecopy);
+						}
+					}
+					, function() {tempDragObj.onDragEnd(e)}]);
+			}, this);
+
+			this.selectedSources = [];
+			this.dragObjects = [];
+			this.dragSource = null;
+			if(this.currentDropTarget) {
+				this.currentDropTarget.onDropEnd();
+			}
+		}
+
+		dojo.event.disconnect(document, &quot;onmousemove&quot;, this, &quot;onMouseMove&quot;);
+		this.currentDropTarget = null;
+	},
+
+	onScroll: function(){
+		for(var i = 0; i &lt; this.dragObjects.length; i++) {
+			if(this.dragObjects[i].updateDragOffset) {
+				this.dragObjects[i].updateDragOffset();
+			}
+		}
+		// TODO: do not recalculate, only adjust coordinates
+		this.cacheTargetLocations();
+	},
+
+	_dragStartDistance: function(x, y){
+		if((!this.mouseDownX)||(!this.mouseDownX)){
+			return;
+		}
+		var dx = Math.abs(x-this.mouseDownX);
+		var dx2 = dx*dx;
+		var dy = Math.abs(y-this.mouseDownY);
+		var dy2 = dy*dy;
+		return parseInt(Math.sqrt(dx2+dy2), 10);
+	},
+
+	cacheTargetLocations: function(){
+		this.dropTargetDimensions = [];
+		dojo.lang.forEach(this.dropTargets, function(tempTarget){
+			var tn = tempTarget.domNode;
+			if(!tn){ return; }
+			var ttx = dojo.style.getAbsoluteX(tn, true);
+			var tty = dojo.style.getAbsoluteY(tn, true);
+			this.dropTargetDimensions.push([
+				[ttx, tty],	// upper-left
+				// lower-right
+				[ ttx+dojo.style.getInnerWidth(tn), tty+dojo.style.getInnerHeight(tn) ],
+				tempTarget
+			]);
+			//dojo.debug(&quot;Cached for &quot;+tempTarget)
+		}, this);
+		//dojo.debug(&quot;Cache locations&quot;)
+	},
+
+	onMouseMove: function(e){
+		if((dojo.render.html.ie)&amp;&amp;(e.button != 1)){
+			// Oooops - mouse up occurred - e.g. when mouse was not over the
+			// window. I don't think we can detect this for FF - but at least
+			// we can be nice in IE.
+			this.currentDropTarget = null;
+			this.onMouseUp(e, true);
+			return;
+		}
+
+		// if we've got some sources, but no drag objects, we need to send
+		// onDragStart to all the right parties and get things lined up for
+		// drop target detection
+
+		if(	(this.selectedSources.length)&amp;&amp;
+			(!this.dragObjects.length) ){
+			var dx;
+			var dy;
+			if(!this._dragTriggered){
+				this._dragTriggered = (this._dragStartDistance(e.pageX, e.pageY) &gt; this.threshold);
+				if(!this._dragTriggered){ return; }
+				dx = e.pageX - this.mouseDownX;
+				dy = e.pageY - this.mouseDownY;
+			}
+
+			// the first element is always our dragSource, if there are multiple
+			// selectedSources (elements that move along) then the first one is the master
+			// and for it the events will be fired etc.
+			this.dragSource = this.selectedSources[0];
+			
+			dojo.lang.forEach(this.selectedSources, function(tempSource){
+				if(!tempSource){ return; }
+				var tdo = tempSource.onDragStart(e);
+				if(tdo){
+					tdo.onDragStart(e);
+
+					// &quot;bump&quot; the drag object to account for the drag threshold
+					tdo.dragOffset.top += dy;
+					tdo.dragOffset.left += dx;
+					tdo.dragSource = tempSource;
+
+					this.dragObjects.push(tdo);
+				}
+			}, this);
+
+			/* clean previous drop target in dragStart */
+			this.previousDropTarget = null;
+
+			this.cacheTargetLocations();
+		}
+
+		// FIXME: we need to add dragSources and dragObjects to e
+		dojo.lang.forEach(this.dragObjects, function(dragObj){
+			if(dragObj){ dragObj.onDragMove(e); }
+		});
+
+		// if we have a current drop target, check to see if we're outside of
+		// it. If so, do all the actions that need doing.
+		if(this.currentDropTarget){
+			//dojo.debug(dojo.dom.hasParent(this.currentDropTarget.domNode))
+			var c = dojo.style.toCoordinateArray(this.currentDropTarget.domNode, true);
+			//		var dtp = this.currentDropTargetPoints;
+			var dtp = [
+				[c[0],c[1]], [c[0]+c[2], c[1]+c[3]]
+			];
+		}
+
+		if((!this.nestedTargets)&amp;&amp;(dtp)&amp;&amp;(this.isInsideBox(e, dtp))){
+			if(this.dropAcceptable){
+				this.currentDropTarget.onDragMove(e, this.dragObjects);
+			}
+		}else{
+			// FIXME: need to fix the event object!
+			// see if we can find a better drop target
+			var bestBox = this.findBestTarget(e);
+
+			if(bestBox.target === null){
+				if(this.currentDropTarget){
+					this.currentDropTarget.onDragOut(e);
+					this.previousDropTarget = this.currentDropTarget;
+					this.currentDropTarget = null;
+					// this.currentDropTargetPoints = null;
+				}
+				this.dropAcceptable = false;
+				return;
+			}
+
+			if(this.currentDropTarget !== bestBox.target){
+				if(this.currentDropTarget){
+					this.previousDropTarget = this.currentDropTarget;
+					this.currentDropTarget.onDragOut(e);
+				}
+				this.currentDropTarget = bestBox.target;
+				// this.currentDropTargetPoints = bestBox.points;
+				e.dragObjects = this.dragObjects;
+				this.dropAcceptable = this.currentDropTarget.onDragOver(e);
+
+			}else{
+				if(this.dropAcceptable){
+					this.currentDropTarget.onDragMove(e, this.dragObjects);
+				}
+			}
+		}
+	},
+
+	findBestTarget: function(e) {
+		var _this = this;
+		var bestBox = new Object();
+		bestBox.target = null;
+		bestBox.points = null;
+		dojo.lang.every(this.dropTargetDimensions, function(tmpDA) {
+			if(!_this.isInsideBox(e, tmpDA))
+				return true;
+			bestBox.target = tmpDA[2];
+			bestBox.points = tmpDA;
+			// continue iterating only if _this.nestedTargets == true
+			return Boolean(_this.nestedTargets);
+		});
+
+		return bestBox;
+	},
+
+	isInsideBox: function(e, coords){
+		if(	(e.pageX &gt; coords[0][0])&amp;&amp;
+			(e.pageX &lt; coords[1][0])&amp;&amp;
+			(e.pageY &gt; coords[0][1])&amp;&amp;
+			(e.pageY &lt; coords[1][1]) ){
+			return true;
+		}
+		return false;
+	},
+
+	onMouseOver: function(e){
+	},
+
+	onMouseOut: function(e){
+	}
+});
+
+dojo.dnd.dragManager = new dojo.dnd.HtmlDragManager();
+
+// global namespace protection closure
+(function(){
+	var d = document;
+	var dm = dojo.dnd.dragManager;
+	// set up event handlers on the document
+	dojo.event.connect(d, &quot;onkeydown&quot;, 		dm, &quot;onKeyDown&quot;);
+	dojo.event.connect(d, &quot;onmouseover&quot;,	dm, &quot;onMouseOver&quot;);
+	dojo.event.connect(d, &quot;onmouseout&quot;, 	dm, &quot;onMouseOut&quot;);
+	dojo.event.connect(d, &quot;onmousedown&quot;,	dm, &quot;onMouseDown&quot;);
+	dojo.event.connect(d, &quot;onmouseup&quot;,		dm, &quot;onMouseUp&quot;);
+	// TODO: process scrolling of elements, not only window
+	dojo.event.connect(window, &quot;onscroll&quot;,	dm, &quot;onScroll&quot;);
+})();

Added: trunk/root/static/magic/src/dnd/HtmlDragMove.js
===================================================================
--- trunk/root/static/magic/src/dnd/HtmlDragMove.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/HtmlDragMove.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,76 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.dnd.HtmlDragMove&quot;);
+dojo.provide(&quot;dojo.dnd.HtmlDragMoveSource&quot;);
+dojo.provide(&quot;dojo.dnd.HtmlDragMoveObject&quot;);
+dojo.require(&quot;dojo.dnd.*&quot;);
+
+dojo.dnd.HtmlDragMoveSource = function(node, type){
+	dojo.dnd.HtmlDragSource.call(this, node, type);
+}
+dojo.inherits(dojo.dnd.HtmlDragMoveSource, dojo.dnd.HtmlDragSource);
+dojo.lang.extend(dojo.dnd.HtmlDragMoveSource, {
+	onDragStart: function(){
+		var dragObj =  new dojo.dnd.HtmlDragMoveObject(this.dragObject, this.type);
+		if (this.constrainToContainer) {
+			dragObj.constrainTo(this.constrainingContainer);
+		}
+		return dragObj;
+	},
+	/*
+	 * see dojo.dnd.HtmlDragSource.onSelected
+	 */
+	onSelected: function() {
+		for (var i=0; i&lt;this.dragObjects.length; i++) {
+			dojo.dnd.dragManager.selectedSources.push(new dojo.dnd.HtmlDragMoveSource(this.dragObjects[i]));
+		}
+	}
+});
+
+dojo.dnd.HtmlDragMoveObject = function(node, type){
+	dojo.dnd.HtmlDragObject.call(this, node, type);
+}
+dojo.inherits(dojo.dnd.HtmlDragMoveObject, dojo.dnd.HtmlDragObject);
+dojo.lang.extend(dojo.dnd.HtmlDragMoveObject, {
+	onDragEnd: function(e){
+		// shortly the browser will fire an onClick() event,
+		// but since this was really a drag, just squelch it
+		dojo.event.connect(this.domNode, &quot;onclick&quot;, this, &quot;squelchOnClick&quot;);
+	},
+	onDragStart: function(e){
+		dojo.html.clearSelection();
+
+		this.dragClone = this.domNode;
+
+		this.scrollOffset = dojo.html.getScrollOffset();
+		this.dragStartPosition = dojo.style.getAbsolutePosition(this.domNode, true);
+		
+		this.dragOffset = {y: this.dragStartPosition.y - e.pageY,
+			x: this.dragStartPosition.x - e.pageX};
+
+		this.containingBlockPosition = this.domNode.offsetParent ? 
+			dojo.style.getAbsolutePosition(this.domNode.offsetParent, true) : {x:0, y:0};
+
+		this.dragClone.style.position = &quot;absolute&quot;;
+
+		if (this.constrainToContainer) {
+			this.constraints = this.getConstraints();
+		}
+	},
+	/**
+	 * Set the position of the drag node.  (x,y) is relative to &lt;body&gt;.
+	 */
+	setAbsolutePosition: function(x, y){
+		// The drag clone is attached to it's constraining container so offset for that
+		if(!this.disableY) { this.domNode.style.top = (y-this.containingBlockPosition.y) + &quot;px&quot;; }
+		if(!this.disableX) { this.domNode.style.left = (x-this.containingBlockPosition.x) + &quot;px&quot;; }
+	}
+});

Added: trunk/root/static/magic/src/dnd/Sortable.js
===================================================================
--- trunk/root/static/magic/src/dnd/Sortable.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/Sortable.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,28 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.dnd.Sortable&quot;);
+dojo.require(&quot;dojo.dnd.*&quot;);
+
+dojo.dnd.Sortable = function () {}
+
+dojo.lang.extend(dojo.dnd.Sortable, {
+
+	ondragstart: function (e) {
+		var dragObject = e.target;
+		while (dragObject.parentNode &amp;&amp; dragObject.parentNode != this) {
+			dragObject = dragObject.parentNode;
+		}
+		// TODO: should apply HtmlDropTarget interface to self
+		// TODO: should apply HtmlDragObject interface?
+		return dragObject;
+	}
+
+});

Added: trunk/root/static/magic/src/dnd/TreeDragAndDrop.js
===================================================================
--- trunk/root/static/magic/src/dnd/TreeDragAndDrop.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/TreeDragAndDrop.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,473 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+ * TreeDrag* specialized on managing subtree drags
+ * It selects nodes and visualises what's going on,
+ * but delegates real actions upon tree to the controller
+ *
+ * This code is considered a part of controller
+*/
+
+dojo.provide(&quot;dojo.dnd.TreeDragAndDrop&quot;);
+dojo.provide(&quot;dojo.dnd.TreeDragSource&quot;);
+dojo.provide(&quot;dojo.dnd.TreeDropTarget&quot;);
+dojo.provide(&quot;dojo.dnd.TreeDNDController&quot;);
+
+dojo.require(&quot;dojo.dnd.HtmlDragAndDrop&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+
+dojo.dnd.TreeDragSource = function(node, syncController, type, treeNode){
+	this.controller = syncController;
+	this.treeNode = treeNode;
+
+	dojo.dnd.HtmlDragSource.call(this, node, type);
+}
+
+dojo.inherits(dojo.dnd.TreeDragSource, dojo.dnd.HtmlDragSource);
+
+dojo.lang.extend(dojo.dnd.TreeDragSource, {
+	onDragStart: function(){
+		/* extend adds functions to prototype */
+		var dragObject = dojo.dnd.HtmlDragSource.prototype.onDragStart.call(this);
+		//dojo.debugShallow(dragObject)
+
+		dragObject.treeNode = this.treeNode;
+
+		dragObject.onDragStart = dojo.lang.hitch(dragObject, function(e) {
+
+			/* save selection */
+			this.savedSelectedNode = this.treeNode.tree.selector.selectedNode;
+			if (this.savedSelectedNode) {
+				this.savedSelectedNode.unMarkSelected();
+			}
+
+			var result = dojo.dnd.HtmlDragObject.prototype.onDragStart.apply(this, arguments);
+
+
+			/* remove background grid from cloned object */
+			var cloneGrid = this.dragClone.getElementsByTagName('img');
+			for(var i=0; i&lt;cloneGrid.length; i++) {
+				cloneGrid.item(i).style.backgroundImage='url()';
+			}
+
+			return result;
+
+
+		});
+
+		dragObject.onDragEnd = function(e) {
+
+			/* restore selection */
+			if (this.savedSelectedNode) {
+				this.savedSelectedNode.markSelected();
+			}
+			//dojo.debug(e.dragStatus);
+
+			return dojo.dnd.HtmlDragObject.prototype.onDragEnd.apply(this, arguments);
+		}
+		//dojo.debug(dragObject.domNode.outerHTML)
+
+
+		return dragObject;
+	},
+
+	onDragEnd: function(e){
+
+
+		 var res = dojo.dnd.HtmlDragSource.prototype.onDragEnd.call(this, e);
+
+
+		 return res;
+	}
+});
+
+// .......................................
+
+dojo.dnd.TreeDropTarget = function(domNode, controller, type, treeNode, DNDMode){
+
+	this.treeNode = treeNode;
+	this.controller = controller; // I will sync-ly process drops
+	this.DNDMode = DNDMode;
+
+	dojo.dnd.HtmlDropTarget.apply(this, [domNode, type]);
+}
+
+dojo.inherits(dojo.dnd.TreeDropTarget, dojo.dnd.HtmlDropTarget);
+
+dojo.lang.extend(dojo.dnd.TreeDropTarget, {
+
+	autoExpandDelay: 1500,
+	autoExpandTimer: null,
+
+
+	position: null,
+
+	indicatorStyle: &quot;2px black solid&quot;,
+
+	showIndicator: function(position) {
+
+		// do not change style too often, cause of blinking possible
+		if (this.position == position) {
+			return;
+		}
+
+		//dojo.debug(position)
+
+		this.hideIndicator();
+
+		this.position = position;
+
+		if (position == &quot;before&quot;) {
+			this.treeNode.labelNode.style.borderTop = this.indicatorStyle;
+		} else if (position == &quot;after&quot;) {
+			this.treeNode.labelNode.style.borderBottom = this.indicatorStyle;
+		} else if (position == &quot;onto&quot;) {
+			this.treeNode.markSelected();
+		}
+
+
+	},
+
+	hideIndicator: function() {
+		this.treeNode.labelNode.style.borderBottom=&quot;&quot;;
+		this.treeNode.labelNode.style.borderTop=&quot;&quot;;
+		this.treeNode.unMarkSelected();
+		this.position = null;
+	},
+
+
+
+	// is the target possibly ok ?
+	// This function is run on dragOver, but drop possibility is also determined by position over node
+	// that's why acceptsWithPosition is called
+	// doesnt take index into account ( can change while moving mouse w/o changing target )
+
+
+	/**
+	 * Coarse (tree-level) access check.
+	 * We can't determine real accepts status w/o position
+	*/
+	onDragOver: function(e){
+//dojo.debug(&quot;onDragOver for &quot;+e);
+
+
+		var accepts = dojo.dnd.HtmlDropTarget.prototype.onDragOver.apply(this, arguments);
+
+		//dojo.debug(&quot;TreeDropTarget.onDragOver accepts:&quot;+accepts)
+
+		if (accepts &amp;&amp; this.treeNode.isFolder &amp;&amp; !this.treeNode.isExpanded) {
+			this.setAutoExpandTimer();
+		}
+
+		return accepts;
+	},
+
+	/* Parent.onDragOver calls this function to get accepts status */
+	accepts: function(dragObjects) {
+
+		var accepts = dojo.dnd.HtmlDropTarget.prototype.accepts.apply(this, arguments);
+
+		if (!accepts) return false;
+
+		var sourceTreeNode = dragObjects[0].treeNode;
+
+		if (dojo.lang.isUndefined(sourceTreeNode) || !sourceTreeNode || !sourceTreeNode.isTreeNode) {
+			dojo.raise(&quot;Source is not TreeNode or not found&quot;);
+		}
+
+		if (sourceTreeNode === this.treeNode) return false;
+
+		return true;
+	},
+
+
+
+	setAutoExpandTimer: function() {
+		// set up autoexpand timer
+		var _this = this;
+
+		var autoExpand = function () {
+			if (dojo.dnd.dragManager.currentDropTarget === _this) {
+				_this.controller.expand(_this.treeNode);
+			}
+		}
+
+		this.autoExpandTimer = dojo.lang.setTimeout(autoExpand, _this.autoExpandDelay);
+	},
+
+
+	getAcceptPosition: function(e, sourceTreeNode) {
+
+		var DNDMode = this.DNDMode;
+
+		if (DNDMode &amp; dojo.widget.Tree.prototype.DNDModes.ONTO &amp;&amp;
+			// check if ONTO is allowed localy
+			!(
+			  !this.treeNode.actionIsDisabled(dojo.widget.TreeNode.prototype.actions.ADDCHILD) // check dynamically cause may change w/o regeneration of dropTarget
+			  &amp;&amp; sourceTreeNode.parent !== this.treeNode
+			  &amp;&amp; this.controller.canMove(sourceTreeNode, this.treeNode)
+			 )
+		) {
+			// disable ONTO if can't move
+			DNDMode &amp;= ~dojo.widget.Tree.prototype.DNDModes.ONTO;
+		}
+
+
+		var position = this.getPosition(e, DNDMode);
+
+		//dojo.debug(DNDMode &amp; +&quot; : &quot;+position);
+
+
+		// if onto is here =&gt; it was allowed before, no accept check is needed
+		if (position==&quot;onto&quot; ||
+			(!this.isAdjacentNode(sourceTreeNode, position)
+			 &amp;&amp; this.controller.canMove(sourceTreeNode, this.treeNode.parent)
+			)
+		) {
+			return position;
+		} else {
+			return false;
+		}
+
+	},
+
+	onDragOut: function(e) {
+		this.clearAutoExpandTimer();
+
+		this.hideIndicator();
+	},
+
+
+	clearAutoExpandTimer: function() {
+		if (this.autoExpandTimer) {
+			clearTimeout(this.autoExpandTimer);
+			this.autoExpandTimer = null;
+		}
+	},
+
+
+
+	onDragMove: function(e, dragObjects){
+
+		var sourceTreeNode = dragObjects[0].treeNode;
+
+		var position = this.getAcceptPosition(e, sourceTreeNode);
+
+		if (position) {
+			this.showIndicator(position);
+		}
+
+	},
+
+	isAdjacentNode: function(sourceNode, position) {
+
+		if (sourceNode === this.treeNode) return true;
+		if (sourceNode.getNextSibling() === this.treeNode &amp;&amp; position==&quot;before&quot;) return true;
+		if (sourceNode.getPreviousSibling() === this.treeNode &amp;&amp; position==&quot;after&quot;) return true;
+
+		return false;
+	},
+
+
+	/* get DNDMode and see which position e fits */
+	getPosition: function(e, DNDMode) {
+		node = dojo.byId(this.treeNode.labelNode);
+		var mousey = e.pageY || e.clientY + document.body.scrollTop;
+		var nodey = dojo.html.getAbsoluteY(node);
+		var height = dojo.html.getInnerHeight(node);
+
+		var relY = mousey - nodey;
+		var p = relY / height;
+
+		var position = &quot;&quot;; // &quot;&quot; &lt;=&gt; forbidden
+		if (DNDMode &amp; dojo.widget.Tree.prototype.DNDModes.ONTO
+		  &amp;&amp; DNDMode &amp; dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
+			if (p&lt;=0.3) {
+				position = &quot;before&quot;;
+			} else if (p&lt;=0.7) {
+				position = &quot;onto&quot;;
+			} else {
+				position = &quot;after&quot;;
+			}
+		} else if (DNDMode &amp; dojo.widget.Tree.prototype.DNDModes.BETWEEN) {
+			if (p&lt;=0.5) {
+				position = &quot;before&quot;;
+			} else {
+				position = &quot;after&quot;;
+			}
+		}
+		else if (DNDMode &amp; dojo.widget.Tree.prototype.DNDModes.ONTO) {
+			position = &quot;onto&quot;;
+		}
+
+
+		return position;
+	},
+
+
+
+	getTargetParentIndex: function(sourceTreeNode, position) {
+
+		var index = position == &quot;before&quot; ? this.treeNode.getParentIndex() : this.treeNode.getParentIndex()+1;
+		if (this.treeNode.parent === sourceTreeNode.parent
+		  &amp;&amp; this.treeNode.getParentIndex() &gt; sourceTreeNode.getParentIndex()) {
+		  	index--;  // dragging a node is different for simple move bacause of before-after issues
+		}
+
+		return index;
+	},
+
+
+	onDrop: function(e){
+		// onDragOut will clean position
+
+
+		var position = this.position;
+
+//dojo.debug(position);
+
+		this.onDragOut(e);
+
+		var sourceTreeNode = e.dragObject.treeNode;
+
+		if (!dojo.lang.isObject(sourceTreeNode)) {
+			dojo.raise(&quot;TreeNode not found in dragObject&quot;)
+		}
+
+		if (position == &quot;onto&quot;) {
+			return this.controller.move(sourceTreeNode, this.treeNode, 0);
+		} else {
+			var index = this.getTargetParentIndex(sourceTreeNode, position);
+			return this.controller.move(sourceTreeNode, this.treeNode.parent, index);
+		}
+
+		//dojo.debug('drop2');
+
+
+
+	}
+
+
+});
+
+
+
+dojo.dnd.TreeDNDController = function(treeController) {
+
+	// I use this controller to perform actions
+	this.treeController = treeController;
+
+	this.dragSources = {};
+
+	this.dropTargets = {};
+
+}
+
+dojo.lang.extend(dojo.dnd.TreeDNDController, {
+
+
+	listenTree: function(tree) {
+		//dojo.debug(&quot;Listen tree &quot;+tree);
+		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, &quot;onCreateDOMNode&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, &quot;onMoveFrom&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.moveTo, this, &quot;onMoveTo&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.addChild, this, &quot;onAddChild&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, &quot;onRemoveNode&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+	},
+
+
+	unlistenTree: function(tree) {
+		//dojo.debug(&quot;Listen tree &quot;+tree);
+		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, &quot;onCreateDOMNode&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, &quot;onMoveFrom&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, &quot;onMoveTo&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, &quot;onAddChild&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, &quot;onRemoveNode&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+	},
+
+	onTreeDestroy: function(message) {
+		this.unlistenTree(message.source);
+		// I'm not widget so don't use destroy() call and dieWithTree
+	},
+
+	onCreateDOMNode: function(message) {
+		this.registerDNDNode(message.source);
+	},
+
+	onAddChild: function(message) {
+		this.registerDNDNode(message.child);
+	},
+
+	onMoveFrom: function(message) {
+		var _this = this;
+		dojo.lang.forEach(
+			message.child.getDescendants(),
+			function(node) { _this.unregisterDNDNode(node); }
+		);
+	},
+
+	onMoveTo: function(message) {
+		var _this = this;
+		dojo.lang.forEach(
+			message.child.getDescendants(),
+			function(node) { _this.registerDNDNode(node); }
+		);
+	},
+
+	/**
+	 * Controller(node model) creates DNDNodes because it passes itself to node for synchroneous drops processing
+	 * I can't process DnD with events cause an event can't return result success/false
+	*/
+	registerDNDNode: function(node) {
+		if (!node.tree.DNDMode) return;
+
+//dojo.debug(&quot;registerDNDNode &quot;+node);
+
+		/* I drag label, not domNode, because large domNodes are very slow to copy and large to drag */
+
+		var source = null;
+		var target = null;
+
+		if (!node.actionIsDisabled(node.actions.MOVE)) {
+			//dojo.debug(&quot;reg source&quot;)
+			var source = new dojo.dnd.TreeDragSource(node.labelNode, this, node.tree.widgetId, node);
+			this.dragSources[node.widgetId] = source;
+		}
+
+		var target = new dojo.dnd.TreeDropTarget(node.labelNode, this.treeController, node.tree.DNDAcceptTypes, node, node.tree.DNDMode);
+
+		this.dropTargets[node.widgetId] = target;
+
+	},
+
+
+	unregisterDNDNode: function(node) {
+
+		if (this.dragSources[node.widgetId]) {
+			dojo.dnd.dragManager.unregisterDragSource(this.dragSources[node.widgetId]);
+			delete this.dragSources[node.widgetId];
+		}
+
+		if (this.dropTargets[node.widgetId]) {
+			dojo.dnd.dragManager.unregisterDropTarget(this.dropTargets[node.widgetId]);
+			delete this.dropTargets[node.widgetId];
+		}
+	}
+
+
+
+
+
+});

Added: trunk/root/static/magic/src/dnd/__package__.js
===================================================================
--- trunk/root/static/magic/src/dnd/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dnd/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,16 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.dnd.DragAndDrop&quot;],
+	browser: [&quot;dojo.dnd.HtmlDragAndDrop&quot;],
+	dashboard: [&quot;dojo.dnd.HtmlDragAndDrop&quot;]
+});
+dojo.provide(&quot;dojo.dnd.*&quot;);

Added: trunk/root/static/magic/src/doc.js
===================================================================
--- trunk/root/static/magic/src/doc.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/doc.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,622 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.doc&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.event.topic&quot;);
+dojo.require(&quot;dojo.rpc.JotService&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+
+/*
+ * TODO:
+ *
+ * Package summary needs to compensate for &quot;is&quot;
+ * Handle host environments
+ * Deal with dojo.widget weirdness
+ * Parse parameters
+ * Limit function parameters to only the valid ones (Involves packing parameters onto meta during rewriting)
+ * Package display page
+ *
+ */
+
+dojo.doc._count = 0;
+dojo.doc._keys = {};
+dojo.doc._myKeys = [];
+dojo.doc._callbacks = {function_names: []};
+dojo.doc._cache = {}; // Saves the JSON objects in cache
+dojo.doc._rpc = new dojo.rpc.JotService;
+dojo.doc._rpc.serviceUrl = &quot;<A HREF="http://dojotoolkit.org/~pottedmeat/jsonrpc.php">http://dojotoolkit.org/~pottedmeat/jsonrpc.php</A>&quot;;
+
+dojo.lang.mixin(dojo.doc, {
+	functionNames: function(/*mixed*/ selectKey, /*Function*/ callback){
+		// summary: Returns an ordered list of package and function names.
+		dojo.debug(&quot;functionNames()&quot;);
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		dojo.doc._buildCache({
+			type: &quot;function_names&quot;,
+			callbacks: [dojo.doc._functionNames, callback],
+			selectKey: selectKey
+		});
+	},
+
+	_functionNames: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_functionNames()&quot;);
+		var searchData = [];
+		for(var key in data){
+			// Add the package if it doesn't exist in its children
+			if(!dojo.lang.inArray(data[key], key)){
+				searchData.push([key, key]);
+			}
+			// Add the functions
+			for(var pkg_key in data[key]){
+				searchData.push([data[key][pkg_key], data[key][pkg_key]]);
+			}
+		}
+
+		searchData = searchData.sort(dojo.doc._sort);
+
+		if(evt.callbacks &amp;&amp; evt.callbacks.length){
+			var callback = evt.callbacks.shift();
+			callback.call(null, type, searchData, evt);
+		}
+	},
+
+	getMeta: function(/*mixed*/ selectKey, /*Function*/ callback, /*Function*/ name, /*String?*/ id){
+		// summary: Gets information about a function in regards to its meta data
+		dojo.debug(&quot;getMeta(&quot; + name + &quot;)&quot;);
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		dojo.doc._buildCache({
+			type: &quot;meta&quot;,
+			callbacks: [callback],
+			name: name,
+			id: id,
+			selectKey: selectKey
+		});
+	},
+
+	_getMeta: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_getMeta(&quot; + evt.name + &quot;) has package: &quot; + evt.pkg + &quot; with: &quot; + type);
+		if(&quot;load&quot; == type &amp;&amp; evt.pkg){
+			evt.type = &quot;meta&quot;;
+			dojo.doc._buildCache(evt);
+		}else{
+			if(evt.callbacks &amp;&amp; evt.callbacks.length){
+				var callback = evt.callbacks.shift();
+				callback.call(null, &quot;error&quot;, {}, evt);
+			}
+		}
+	},
+
+	getSrc: function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name, /*String?*/ id){
+		// summary: Gets src file (created by the doc parser)
+		dojo.debug(&quot;getSrc()&quot;);
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}	
+		dojo.doc._buildCache({
+			type: &quot;src&quot;,
+			callbacks: [callback],
+			name: name,
+			id: id,
+			selectKey: selectKey
+		});
+	},
+
+	_getSrc: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_getSrc()&quot;);
+		if(evt.pkg){	
+			evt.type = &quot;src&quot;;
+			dojo.doc._buildCache(evt);
+		}else{
+			if(evt.callbacks &amp;&amp; evt.callbacks.length){
+				var callback =  evt.callbacks.shift();
+				callback.call(null, &quot;error&quot;, {}, evt);
+			}
+		}
+	},
+
+	getDoc: function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name, /*String?*/ id){
+		// summary: Gets external documentation stored on jot
+		dojo.debug(&quot;getDoc()&quot;);
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		var input = {
+			type: &quot;doc&quot;,
+			callbacks: [callback],
+			name: name,
+			id: id,
+			selectKey: selectKey
+		}
+		dojo.doc.functionPackage(dojo.doc._getDoc, input);
+	},
+
+	_getDoc: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_getDoc(&quot; + evt.pkg + &quot;/&quot; + evt.name + &quot;)&quot;);
+	
+		dojo.doc._keys[evt.selectKey] = {count: 0};
+
+		var search = {};
+		search.forFormName = &quot;DocFnForm&quot;;
+		search.limit = 1;
+
+		if(!evt.id){
+			search.filter = &quot;it/DocFnForm/require = '&quot; + evt.pkg + &quot;' and it/DocFnForm/name = '&quot; + evt.name + &quot;' and not(it/DocFnForm/id)&quot;;
+		}else{
+			search.filter = &quot;it/DocFnForm/require = '&quot; + evt.pkg + &quot;' and it/DocFnForm/name = '&quot; + evt.name + &quot;' and it/DocFnForm/id = '&quot; + evt.id + &quot;'&quot;;
+		}
+		dojo.debug(dojo.json.serialize(search));
+	
+		dojo.doc._rpc.callRemote(&quot;search&quot;, search).addCallbacks(function(data){ evt.type = &quot;fn&quot;; dojo.doc._gotDoc(&quot;load&quot;, data.list[0], evt); }, function(data){ evt.type = &quot;fn&quot;; dojo.doc._gotDoc(&quot;error&quot;, {}, evt); });
+	
+		search.forFormName = &quot;DocParamForm&quot;;
+
+		if(!evt.id){
+			search.filter = &quot;it/DocParamForm/fns = '&quot; + evt.pkg + &quot;=&gt;&quot; + evt.name + &quot;'&quot;;
+		}else{
+			search.filter = &quot;it/DocParamForm/fns = '&quot; + evt.pkg + &quot;=&gt;&quot; + evt.name + &quot;=&gt;&quot; + evt.id + &quot;'&quot;;
+		}
+		delete search.limit;
+
+		dojo.doc._rpc.callRemote(&quot;search&quot;, search).addCallbacks(function(data){ evt.type = &quot;param&quot;; dojo.doc._gotDoc(&quot;load&quot;, data.list, evt); }, function(data){ evt.type = &quot;param&quot;; dojo.doc._gotDoc(&quot;error&quot;, {}, evt); });
+	},
+
+	_gotDoc: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_gotDoc(&quot; + evt.type + &quot;) for &quot; + evt.selectKey);
+		dojo.doc._keys[evt.selectKey][evt.type] = data;
+		if(++dojo.doc._keys[evt.selectKey].count == 2){
+			dojo.debug(&quot;_gotDoc() finished&quot;);
+			var keys = dojo.doc._keys[evt.selectKey];
+			var description = '';
+			if(!keys.fn){
+				keys.fn = {}
+			}
+			if(keys.fn[&quot;main/text&quot;]){
+				description = dojo.dom.createDocumentFromText(keys.fn[&quot;main/text&quot;]).childNodes[0].innerHTML;
+				if(!description){
+					description = keys.fn[&quot;main/text&quot;];
+				}			
+			}
+			data = {
+				description: description,
+				returns: keys.fn[&quot;DocFnForm/returns&quot;],
+				id: keys.fn[&quot;DocFnForm/id&quot;],
+				parameters: {},
+				variables: []
+			}
+			for(var i = 0, param; param = keys[&quot;param&quot;][i]; i++){
+				data.parameters[param[&quot;DocParamForm/name&quot;]] = {
+					description: param[&quot;DocParamForm/desc&quot;]
+				};
+			}
+
+			delete dojo.doc._keys[evt.selectKey];
+		
+			if(evt.callbacks &amp;&amp; evt.callbacks.length){
+				var callback = evt.callbacks.shift();
+				callback.call(null, &quot;load&quot;, data, evt);
+			}
+		}
+	},
+
+	getPkgMeta: function(/*mixed*/ selectKey, /*Function*/ callback, /*String*/ name){
+		dojo.debug(&quot;getPkgMeta(&quot; + name + &quot;)&quot;);
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+		dojo.doc._buildCache({
+			type: &quot;pkgmeta&quot;,
+			callbacks: [callback],
+			name: name,
+			selectKey: selectKey
+		});
+	},
+
+	_getPkgMeta: function(/*Object*/ input){
+		dojo.debug(&quot;_getPkgMeta(&quot; + input.name + &quot;)&quot;);
+		input.type = &quot;pkgmeta&quot;;
+		dojo.doc._buildCache(input);
+	},
+
+	_onDocSearch: function(/*Object*/ input){
+		dojo.debug(&quot;_onDocSearch(&quot; + input.name + &quot;)&quot;);
+		if(!input.name){
+			return;
+		}
+		if(!input.selectKey){
+			input.selectKey = ++dojo.doc._count;
+		}
+		input.callbacks = [dojo.doc._onDocSearchFn];
+		input.name = input.name.toLowerCase();
+		input.type = &quot;function_names&quot;;
+
+		dojo.doc._buildCache(input);
+	},
+
+	_onDocSearchFn: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_onDocSearchFn(&quot; + evt.name + &quot;)&quot;);
+		var packages = [];
+		var size = 0;
+		pkgLoop:
+		for(var pkg in data){
+			for(var i = 0, fn; fn = data[pkg][i]; i++){
+				if(fn.toLowerCase().indexOf(evt.name) != -1){
+					// Build a list of all packages that need to be loaded and their loaded state.
+					++size;
+					packages.push(pkg);
+					continue pkgLoop;
+				}
+			}
+		}
+		dojo.doc._keys[evt.selectKey] = {};
+		dojo.doc._keys[evt.selectKey].pkgs = packages;
+		dojo.doc._keys[evt.selectKey].pkg = evt.name; // Remember what we were searching for
+		dojo.doc._keys[evt.selectKey].loaded = 0;
+		for(var i = 0, pkg; pkg = packages[i]; i++){
+			setTimeout(&quot;dojo.doc.getPkgMeta(\&quot;&quot; + evt.selectKey + &quot;\&quot;, dojo.doc._onDocResults, \&quot;&quot; + pkg + &quot;\&quot;);&quot;, i*10);
+		}
+	},
+
+	_onDocResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_onDocResults(&quot; + evt.name + &quot;/&quot; + dojo.doc._keys[evt.selectKey].pkg + &quot;) &quot; + type);
+		++dojo.doc._keys[evt.selectKey].loaded;
+
+		if(dojo.doc._keys[evt.selectKey].loaded == dojo.doc._keys[evt.selectKey].pkgs.length){
+			var info = dojo.doc._keys[evt.selectKey];
+			var pkgs = info.pkgs;
+			var name = info.pkg;
+			delete dojo.doc._keys[evt.selectKey];
+			var results = {selectKey: evt.selectKey, docResults: []};
+			data = dojo.doc._cache;
+
+			for(var i = 0, pkg; pkg = pkgs[i]; i++){
+				if(!data[pkg]){
+					continue;
+				}
+				for(var fn in data[pkg][&quot;meta&quot;]){
+					if(fn.toLowerCase().indexOf(name) == -1){
+						continue;
+					}
+					if(fn != &quot;requires&quot;){
+						for(var pId in data[pkg][&quot;meta&quot;][fn]){
+							var result = {
+								pkg: pkg,
+								name: fn,
+								summary: &quot;&quot;
+							}
+							if(data[pkg][&quot;meta&quot;][fn][pId].summary){
+								result.summary = data[pkg][&quot;meta&quot;][fn][pId].summary;
+							}
+							results.docResults.push(result);
+						}
+					}
+				}
+			}
+
+			dojo.debug(&quot;Publishing docResults&quot;);
+			dojo.doc._printResults(results);
+		}
+	},
+	
+	_printResults: function(results){
+		dojo.debug(&quot;_printResults(): called&quot;);
+		// summary: Call this function to send the /doc/results topic
+	},
+
+	_onDocSelectFunction: function(/*Object*/ input){
+		// summary: Get doc, meta, and src
+		var name = input.name;
+		var selectKey = selectKey;
+		dojo.debug(&quot;_onDocSelectFunction(&quot; + name + &quot;)&quot;);
+		if(!name){
+			return false;
+		}
+		if(!selectKey){
+			selectKey = ++dojo.doc._count;
+		}
+
+		dojo.doc._keys[selectKey] = {size: 0};
+		dojo.doc._myKeys[++dojo.doc._count] = {selectKey: selectKey, type: &quot;meta&quot;}
+		dojo.doc.getMeta(dojo.doc._count, dojo.doc._onDocSelectResults, name);
+		dojo.doc._myKeys[++dojo.doc._count] = {selectKey: selectKey, type: &quot;src&quot;}
+		dojo.doc.getSrc(dojo.doc._count, dojo.doc._onDocSelectResults, name);
+		dojo.doc._myKeys[++dojo.doc._count] = {selectKey: selectKey, type: &quot;doc&quot;}
+		dojo.doc.getDoc(dojo.doc._count, dojo.doc._onDocSelectResults, name);
+	},
+
+	_onDocSelectResults: function(/*String*/ type, /*Object*/ data, /*Object*/ evt){
+		dojo.debug(&quot;dojo.doc._onDocSelectResults(&quot; + evt.type + &quot;, &quot; + evt.name + &quot;)&quot;);
+		var myKey = dojo.doc._myKeys[evt.selectKey];
+		dojo.doc._keys[myKey.selectKey][myKey.type] = data;
+		dojo.doc._keys[myKey.selectKey].size;
+		if(++dojo.doc._keys[myKey.selectKey].size == 3){
+			var key = dojo.lang.mixin(evt, dojo.doc._keys[myKey.selectKey]);
+			delete key.size;
+			dojo.debug(&quot;Publishing docFunctionDetail&quot;);
+			dojo.doc._printFunctionDetail(key);
+			delete dojo.doc._keys[myKey.selectKey];
+			delete dojo.doc._myKeys[evt.selectKey];
+		}
+	},
+	
+	_printFunctionDetail: function(results) {
+		// summary: Call this function to send the /doc/functionDetail topic event
+	},
+
+	_buildCache: function(/*Object*/ input){
+		var type = input.type;
+		var pkg = input.pkg;
+		var callbacks = input.callbacks;
+		var id = input.id;
+		if(!id){
+			id = &quot;_&quot;;
+		}
+		var name = input.name;
+	
+		dojo.debug(&quot;_buildCache() type: &quot; + type);
+		if(type == &quot;function_names&quot;){
+			if(!dojo.doc._cache[&quot;function_names&quot;]){
+				dojo.debug(&quot;_buildCache() new cache&quot;);
+				if(callbacks &amp;&amp; callbacks.length){
+					dojo.doc._callbacks.function_names.push([input, callbacks.shift()]);
+				}
+				dojo.doc._cache[&quot;function_names&quot;] = {loading: true};
+				dojo.io.bind({
+					url: &quot;json/function_names&quot;,
+					mimetype: &quot;text/json&quot;,
+					error: function(type, data, evt){
+						dojo.debug(&quot;Unable to load function names&quot;);
+						for(var i = 0, callback; callback = dojo.doc._callbacks.function_names[i]; i++){
+							callback[1].call(null, &quot;error&quot;, {}, callback[0]);
+						}
+					},
+					load: function(type, data, evt){
+						dojo.doc._cache['function_names'] = data;
+						for(var i = 0, callback; callback = dojo.doc._callbacks.function_names[i]; i++){
+							callback[1].call(null, &quot;load&quot;, data, callback[0]);
+						}
+					}
+				});
+			}else if(dojo.doc._cache[&quot;function_names&quot;].loading){
+				dojo.debug(&quot;_buildCache() loading cache&quot;);
+				if(callbacks &amp;&amp; callbacks.length){
+					dojo.doc._callbacks.function_names.push([input, callbacks.shift()]);
+				}
+			}else{
+				dojo.debug(&quot;_buildCache() from cache&quot;);
+				if(callbacks &amp;&amp; callbacks.length){
+					var callback = callbacks.shift();
+					callback.call(null, &quot;load&quot;, dojo.doc._cache[&quot;function_names&quot;], input);
+				}
+			}
+		}else if(type == &quot;meta&quot; || type == &quot;src&quot;){
+			if(!pkg){
+				if(type == &quot;meta&quot;){
+					dojo.doc.functionPackage(dojo.doc._getMeta, input);
+				}else{
+					dojo.doc.functionPackage(dojo.doc._getSrc, input);
+				}
+			}else{
+				try{
+					var cached = dojo.doc._cache[pkg][name][id][type];
+				}catch(e){}
+
+				if(cached){
+					if(callbacks &amp;&amp; callbacks.length){
+						var callback = callbacks.shift();
+						callback.call(null, &quot;load&quot;, cached, input);
+						return;
+					}
+				}
+
+				dojo.debug(&quot;Finding &quot; + type + &quot; for: &quot; + pkg + &quot;, function: &quot; + name + &quot;, id: &quot; + id);
+
+				var mimetype = &quot;text/json&quot;;
+				if(type == &quot;src&quot;){
+					mimetype = &quot;text/plain&quot;
+				}
+
+				var url = &quot;json/&quot; + pkg + &quot;/&quot; + name + &quot;/&quot; + id + &quot;/&quot; + type;
+
+				dojo.io.bind({
+					url: url,
+					input: input,
+					mimetype: mimetype,
+					error: function(type, data, evt, args){
+						var input = args.input;
+						var pkg = input.pkg;
+						var type = input.type;
+						var callbacks = input.callbacks;
+						var id = input.id;
+						var name = input.name;
+
+						if(callbacks &amp;&amp; callbacks.length){
+							if(!data){
+								data = {};
+							}
+							if(!dojo.doc._cache[pkg]){
+								dojo.doc._cache[pkg] = {};
+							}
+							if(!dojo.doc._cache[pkg][name]){
+								dojo.doc._cache[pkg][name] = {};
+							}
+							if(type == &quot;meta&quot;){
+								data.sig = dojo.doc._cache[pkg][name][id].sig;
+								data.params = dojo.doc._cache[pkg][name][id].params;
+							}
+							var callback = callbacks.shift();
+							callback.call(null, &quot;error&quot;, data, args.input);
+						}
+					},
+					load: function(type, data, evt, args){
+						var input = args.input;
+						var pkg = input.pkg;
+						var type = input.type;
+						var id = input.id;
+						var name = input.name;
+						var cache = dojo.doc._cache;
+						dojo.debug(&quot;_buildCache() loaded &quot; + type);
+
+						if(!data){
+							data = {};
+						}
+						if(!cache[pkg]){
+							dojo.doc._cache[pkg] = {};
+						}
+						if(!cache[pkg][name]){
+							dojo.doc._cache[pkg][name] = {};
+						}
+						if(!cache[pkg][name][id]){
+							dojo.doc._cache[pkg][name][id] = {};
+						}
+						if(!cache[pkg][name][id].meta){
+							dojo.doc._cache[pkg][name][id].meta = {};
+						}
+						dojo.doc._cache[pkg][name][id][type] = data;
+						if(callbacks &amp;&amp; callbacks.length){
+							var callback = callbacks.shift();
+							callback.call(null, &quot;load&quot;, data, args.input);
+						}
+					}
+				});
+			}
+		}else if(type == &quot;pkgmeta&quot;){
+			try{
+				var cached = dojo.doc._cache[name][&quot;meta&quot;];
+			}catch(e){}
+
+			if(cached){
+				if(callbacks &amp;&amp; callbacks.length){
+					var callback = callbacks.shift();
+					callback.call(null, &quot;load&quot;, cached, input);
+					return;
+				}
+			}
+
+			dojo.debug(&quot;Finding package meta for: &quot; + name);
+
+			dojo.io.bind({
+				url: &quot;json/&quot; + name + &quot;/meta&quot;,
+				input: input,
+				mimetype: &quot;text/json&quot;,
+				error: function(type, data, evt, args){
+					var callbacks = args.input.callbacks;
+					if(callbacks &amp;&amp; callbacks.length){
+						var callback = callbacks.shift();
+						callback.call(null, &quot;error&quot;, {}, args.input);
+					}
+				},
+				load: function(type, data, evt, args){
+					var pkg = args.input.name;
+					var cache = dojo.doc._cache;
+
+					dojo.debug(&quot;_buildCache() loaded for: &quot; + pkg);
+					if(!cache[pkg]){
+						dojo.doc._cache[pkg] = {};
+					}
+				
+					if(!cache[pkg][&quot;meta&quot;]){
+						dojo.doc._cache[pkg][&quot;meta&quot;] = {};
+					}
+				
+					var methods = data.methods;
+					if(methods){
+						for(var method in methods){
+							if (method == &quot;is&quot;) {
+								continue;
+							}
+							for(var pId in methods[method]){
+								if(!cache[pkg][&quot;meta&quot;][method]){
+									dojo.doc._cache[pkg][&quot;meta&quot;][method] = {};
+								}
+								if(!cache[pkg][&quot;meta&quot;][method][pId]){
+									dojo.doc._cache[pkg][&quot;meta&quot;][method][pId] = {};
+								}
+								dojo.doc._cache[pkg][&quot;meta&quot;][method][pId].summary = methods[method][pId];
+							}
+						}
+					}
+
+					dojo.doc._cache[pkg][&quot;meta&quot;].methods = methods;
+					var requires = data.requires;
+					if(requires){
+						dojo.doc._cache[pkg][&quot;meta&quot;].requires = requires;
+					}
+					if(callbacks &amp;&amp; callbacks.length){
+						var callback = callbacks.shift();
+						callback.call(null, &quot;load&quot;, methods, input);
+					}
+				}
+			});
+		}
+	},
+
+	selectFunction: function(/*String*/ name, /*String?*/ id){
+		// summary: The combined information
+	},
+
+	savePackage: function(/*String*/ name, /*String*/ description){
+		dojo.doc._rpc.callRemote(
+			&quot;saveForm&quot;,
+			{
+				form: &quot;DocPkgForm&quot;,
+				path: &quot;/WikiHome/DojoDotDoc/id&quot;,
+				pname1: &quot;main/text&quot;,
+				pvalue1: &quot;Test&quot;
+			}
+		).addCallbacks(dojo.doc._results, dojo.doc._results);
+	},
+
+	functionPackage: function(/*Function*/ callback, /*Object*/ input){
+		dojo.debug(&quot;functionPackage() name: &quot; + input.name + &quot; for type: &quot; + input.type);
+		input.type = &quot;function_names&quot;;
+		input.callbacks.unshift(callback);
+		input.callbacks.unshift(dojo.doc._functionPackage);
+		dojo.doc._buildCache(input);
+	},
+
+	_functionPackage: function(/*String*/ type, /*Array*/ data, /*Object*/ evt){
+		dojo.debug(&quot;_functionPackage() name: &quot; + evt.name + &quot; for: &quot; + evt.type + &quot; with: &quot; + type);
+		evt.pkg = '';
+
+		var data = dojo.doc._cache['function_names'];
+		for(var key in data){
+			if(dojo.lang.inArray(data[key], evt.name)){
+				evt.pkg = key;
+				break;
+			}
+		}
+
+		if(evt.callbacks &amp;&amp; evt.callbacks.length){
+			var callback = evt.callbacks.shift();
+			callback.call(null, type, data[key], evt);
+		}
+	},
+
+	_sort: function(a, b){
+		if(a[0] &lt; b[0]){
+			return -1;
+		}
+		if(a[0] &gt; b[0]){
+			return 1;
+		}
+	  return 0;
+	}
+});
+
+dojo.event.topic.subscribe(&quot;/doc/search&quot;, dojo.doc, &quot;_onDocSearch&quot;);
+dojo.event.topic.subscribe(&quot;/doc/selectFunction&quot;, dojo.doc, &quot;_onDocSelectFunction&quot;);
+
+dojo.event.topic.registerPublisher(&quot;/doc/results&quot;, dojo.doc, &quot;_printResults&quot;);
+dojo.event.topic.registerPublisher(&quot;/doc/functionDetail&quot;, dojo.doc, &quot;_printFunctionDetail&quot;);
\ No newline at end of file

Added: trunk/root/static/magic/src/dom.js
===================================================================
--- trunk/root/static/magic/src/dom.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/dom.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,485 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+
+dojo.dom.ELEMENT_NODE                  = 1;
+dojo.dom.ATTRIBUTE_NODE                = 2;
+dojo.dom.TEXT_NODE                     = 3;
+dojo.dom.CDATA_SECTION_NODE            = 4;
+dojo.dom.ENTITY_REFERENCE_NODE         = 5;
+dojo.dom.ENTITY_NODE                   = 6;
+dojo.dom.PROCESSING_INSTRUCTION_NODE   = 7;
+dojo.dom.COMMENT_NODE                  = 8;
+dojo.dom.DOCUMENT_NODE                 = 9;
+dojo.dom.DOCUMENT_TYPE_NODE            = 10;
+dojo.dom.DOCUMENT_FRAGMENT_NODE        = 11;
+dojo.dom.NOTATION_NODE                 = 12;
+	
+dojo.dom.dojoml = &quot;<A HREF="http://www.dojotoolkit.org/2004/dojoml">http://www.dojotoolkit.org/2004/dojoml</A>&quot;;
+
+/**
+ *	comprehensive list of XML namespaces
+**/
+dojo.dom.xmlns = {
+	svg : &quot;<A HREF="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;,
+	smil : &quot;<A HREF="http://www.w3.org/2001/SMIL20/">http://www.w3.org/2001/SMIL20/</A>&quot;,
+	mml : &quot;<A HREF="http://www.w3.org/1998/Math/MathML">http://www.w3.org/1998/Math/MathML</A>&quot;,
+	cml : &quot;<A HREF="http://www.xml-cml.org">http://www.xml-cml.org</A>&quot;,
+	xlink : &quot;<A HREF="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</A>&quot;,
+	xhtml : &quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot;,
+	xul : &quot;<A HREF="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul</A>&quot;,
+	xbl : &quot;<A HREF="http://www.mozilla.org/xbl">http://www.mozilla.org/xbl</A>&quot;,
+	fo : &quot;<A HREF="http://www.w3.org/1999/XSL/Format">http://www.w3.org/1999/XSL/Format</A>&quot;,
+	xsl : &quot;<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>&quot;,
+	xslt : &quot;<A HREF="http://www.w3.org/1999/XSL/Transform">http://www.w3.org/1999/XSL/Transform</A>&quot;,
+	xi : &quot;<A HREF="http://www.w3.org/2001/XInclude">http://www.w3.org/2001/XInclude</A>&quot;,
+	xforms : &quot;<A HREF="http://www.w3.org/2002/01/xforms">http://www.w3.org/2002/01/xforms</A>&quot;,
+	saxon : &quot;<A HREF="http://icl.com/saxon">http://icl.com/saxon</A>&quot;,
+	xalan : &quot;<A HREF="http://xml.apache.org/xslt">http://xml.apache.org/xslt</A>&quot;,
+	xsd : &quot;<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>&quot;,
+	dt: &quot;<A HREF="http://www.w3.org/2001/XMLSchema-datatypes">http://www.w3.org/2001/XMLSchema-datatypes</A>&quot;,
+	xsi : &quot;<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>&quot;,
+	rdf : &quot;<A HREF="http://www.w3.org/1999/02/22-rdf-syntax-ns#">http://www.w3.org/1999/02/22-rdf-syntax-ns#</A>&quot;,
+	rdfs : &quot;<A HREF="http://www.w3.org/2000/01/rdf-schema#">http://www.w3.org/2000/01/rdf-schema#</A>&quot;,
+	dc : &quot;<A HREF="http://purl.org/dc/elements/1.1/">http://purl.org/dc/elements/1.1/</A>&quot;,
+	dcq: &quot;<A HREF="http://purl.org/dc/qualifiers/1.0">http://purl.org/dc/qualifiers/1.0</A>&quot;,
+	&quot;soap-env&quot; : &quot;<A HREF="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</A>&quot;,
+	wsdl : &quot;<A HREF="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</A>&quot;,
+	AdobeExtensions : &quot;<A HREF="http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/">http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/</A>&quot;
+};
+
+dojo.dom.isNode = function(wh){
+	if(typeof Element == &quot;object&quot;) {
+		try {
+			return wh instanceof Element;
+		} catch(E) {}
+	} else {
+		// best-guess
+		return wh &amp;&amp; !isNaN(wh.nodeType);
+	}
+}
+
+dojo.dom.getTagName = function(node){
+	dojo.deprecated(&quot;dojo.dom.getTagName&quot;, &quot;use node.tagName instead&quot;, &quot;0.4&quot;);
+
+	var tagName = node.tagName;
+	if(tagName.substr(0,5).toLowerCase()!=&quot;dojo:&quot;){
+		
+		if(tagName.substr(0,4).toLowerCase()==&quot;dojo&quot;){
+			// FIXME: this assuumes tag names are always lower case
+			return &quot;dojo:&quot; + tagName.substring(4).toLowerCase();
+		}
+
+		// allow lower-casing
+		var djt = node.getAttribute(&quot;dojoType&quot;)||node.getAttribute(&quot;dojotype&quot;);
+		if(djt){
+			return &quot;dojo:&quot;+djt.toLowerCase();
+		}
+		
+		if((node.getAttributeNS)&amp;&amp;(node.getAttributeNS(this.dojoml,&quot;type&quot;))){
+			return &quot;dojo:&quot; + node.getAttributeNS(this.dojoml,&quot;type&quot;).toLowerCase();
+		}
+		try{
+			// FIXME: IE really really doesn't like this, so we squelch
+			// errors for it
+			djt = node.getAttribute(&quot;dojo:type&quot;);
+		}catch(e){ /* FIXME: log? */ }
+		if(djt){
+			return &quot;dojo:&quot;+djt.toLowerCase();
+		}
+
+		if((!dj_global[&quot;djConfig&quot;])||(!djConfig[&quot;ignoreClassNames&quot;])){
+			// FIXME: should we make this optionally enabled via djConfig?
+			var classes = node.className||node.getAttribute(&quot;class&quot;);
+			// FIXME: following line, without check for existence of classes.indexOf
+			// breaks firefox 1.5's svg widgets
+			if((classes)&amp;&amp;(classes.indexOf)&amp;&amp;(classes.indexOf(&quot;dojo-&quot;) != -1)){
+				var aclasses = classes.split(&quot; &quot;);
+				for(var x=0; x&lt;aclasses.length; x++){
+					if((aclasses[x].length&gt;5)&amp;&amp;(aclasses[x].indexOf(&quot;dojo-&quot;)&gt;=0)){
+						return &quot;dojo:&quot;+aclasses[x].substr(5).toLowerCase();
+					}
+				}
+			}
+		}
+
+	}
+	return tagName.toLowerCase();
+}
+
+dojo.dom.getUniqueId = function(){
+	do {
+		var id = &quot;dj_unique_&quot; + (++arguments.callee._idIncrement);
+	}while(document.getElementById(id));
+	return id;
+}
+dojo.dom.getUniqueId._idIncrement = 0;
+
+dojo.dom.firstElement = dojo.dom.getFirstChildElement = function(parentNode, tagName){
+	var node = parentNode.firstChild;
+	while(node &amp;&amp; node.nodeType != dojo.dom.ELEMENT_NODE){
+		node = node.nextSibling;
+	}
+	if(tagName &amp;&amp; node &amp;&amp; node.tagName &amp;&amp; node.tagName.toLowerCase() != tagName.toLowerCase()) {
+		node = dojo.dom.nextElement(node, tagName);
+	}
+	return node;
+}
+
+dojo.dom.lastElement = dojo.dom.getLastChildElement = function(parentNode, tagName){
+	var node = parentNode.lastChild;
+	while(node &amp;&amp; node.nodeType != dojo.dom.ELEMENT_NODE) {
+		node = node.previousSibling;
+	}
+	if(tagName &amp;&amp; node &amp;&amp; node.tagName &amp;&amp; node.tagName.toLowerCase() != tagName.toLowerCase()) {
+		node = dojo.dom.prevElement(node, tagName);
+	}
+	return node;
+}
+
+dojo.dom.nextElement = dojo.dom.getNextSiblingElement = function(node, tagName){
+	if(!node) { return null; }
+	do {
+		node = node.nextSibling;
+	} while(node &amp;&amp; node.nodeType != dojo.dom.ELEMENT_NODE);
+
+	if(node &amp;&amp; tagName &amp;&amp; tagName.toLowerCase() != node.tagName.toLowerCase()) {
+		return dojo.dom.nextElement(node, tagName);
+	}
+	return node;
+}
+
+dojo.dom.prevElement = dojo.dom.getPreviousSiblingElement = function(node, tagName){
+	if(!node) { return null; }
+	if(tagName) { tagName = tagName.toLowerCase(); }
+	do {
+		node = node.previousSibling;
+	} while(node &amp;&amp; node.nodeType != dojo.dom.ELEMENT_NODE);
+
+	if(node &amp;&amp; tagName &amp;&amp; tagName.toLowerCase() != node.tagName.toLowerCase()) {
+		return dojo.dom.prevElement(node, tagName);
+	}
+	return node;
+}
+
+// TODO: hmph
+/*this.forEachChildTag = function(node, unaryFunc) {
+	var child = this.getFirstChildTag(node);
+	while(child) {
+		if(unaryFunc(child) == &quot;break&quot;) { break; }
+		child = this.getNextSiblingTag(child);
+	}
+}*/
+
+dojo.dom.moveChildren = function(srcNode, destNode, trim){
+	var count = 0;
+	if(trim) {
+		while(srcNode.hasChildNodes() &amp;&amp;
+			srcNode.firstChild.nodeType == dojo.dom.TEXT_NODE) {
+			srcNode.removeChild(srcNode.firstChild);
+		}
+		while(srcNode.hasChildNodes() &amp;&amp;
+			srcNode.lastChild.nodeType == dojo.dom.TEXT_NODE) {
+			srcNode.removeChild(srcNode.lastChild);
+		}
+	}
+	while(srcNode.hasChildNodes()){
+		destNode.appendChild(srcNode.firstChild);
+		count++;
+	}
+	return count;
+}
+
+dojo.dom.copyChildren = function(srcNode, destNode, trim){
+	var clonedNode = srcNode.cloneNode(true);
+	return this.moveChildren(clonedNode, destNode, trim);
+}
+
+dojo.dom.removeChildren = function(node){
+	var count = node.childNodes.length;
+	while(node.hasChildNodes()){ node.removeChild(node.firstChild); }
+	return count;
+}
+
+dojo.dom.replaceChildren = function(node, newChild){
+	// FIXME: what if newChild is an array-like object?
+	dojo.dom.removeChildren(node);
+	node.appendChild(newChild);
+}
+
+dojo.dom.removeNode = function(node){
+	if(node &amp;&amp; node.parentNode){
+		// return a ref to the removed child
+		return node.parentNode.removeChild(node);
+	}
+}
+
+dojo.dom.getAncestors = function(node, filterFunction, returnFirstHit) {
+	var ancestors = [];
+	var isFunction = dojo.lang.isFunction(filterFunction);
+	while(node) {
+		if (!isFunction || filterFunction(node)) {
+			ancestors.push(node);
+		}
+		if (returnFirstHit &amp;&amp; ancestors.length &gt; 0) { return ancestors[0]; }
+		
+		node = node.parentNode;
+	}
+	if (returnFirstHit) { return null; }
+	return ancestors;
+}
+
+dojo.dom.getAncestorsByTag = function(node, tag, returnFirstHit) {
+	tag = tag.toLowerCase();
+	return dojo.dom.getAncestors(node, function(el){
+		return ((el.tagName)&amp;&amp;(el.tagName.toLowerCase() == tag));
+	}, returnFirstHit);
+}
+
+dojo.dom.getFirstAncestorByTag = function(node, tag) {
+	return dojo.dom.getAncestorsByTag(node, tag, true);
+}
+
+dojo.dom.isDescendantOf = function(node, ancestor, guaranteeDescendant){
+	// guaranteeDescendant allows us to be a &quot;true&quot; isDescendantOf function
+	if(guaranteeDescendant &amp;&amp; node) { node = node.parentNode; }
+	while(node) {
+		if(node == ancestor){ return true; }
+		node = node.parentNode;
+	}
+	return false;
+}
+
+dojo.dom.innerXML = function(node){
+	if(node.innerXML){
+		return node.innerXML;
+	}else if (node.xml){
+		return node.xml;
+	}else if(typeof XMLSerializer != &quot;undefined&quot;){
+		return (new XMLSerializer()).serializeToString(node);
+	}
+}
+
+dojo.dom.createDocument = function(){
+	var doc = null;
+
+	if(!dj_undef(&quot;ActiveXObject&quot;)){
+		var prefixes = [ &quot;MSXML2&quot;, &quot;Microsoft&quot;, &quot;MSXML&quot;, &quot;MSXML3&quot; ];
+		for(var i = 0; i&lt;prefixes.length; i++){
+			try{
+				doc = new ActiveXObject(prefixes[i]+&quot;.XMLDOM&quot;);
+			}catch(e){ /* squelch */ };
+
+			if(doc){ break; }
+		}
+	}else if((document.implementation)&amp;&amp;
+		(document.implementation.createDocument)){
+		doc = document.implementation.createDocument(&quot;&quot;, &quot;&quot;, null);
+	}
+	
+	return doc;
+}
+
+dojo.dom.createDocumentFromText = function(str, mimetype){
+	if(!mimetype){ mimetype = &quot;text/xml&quot;; }
+	if(!dj_undef(&quot;DOMParser&quot;)){
+		var parser = new DOMParser();
+		return parser.parseFromString(str, mimetype);
+	}else if(!dj_undef(&quot;ActiveXObject&quot;)){
+		var domDoc = dojo.dom.createDocument();
+		if(domDoc){
+			domDoc.async = false;
+			domDoc.loadXML(str);
+			return domDoc;
+		}else{
+			dojo.debug(&quot;toXml didn't work?&quot;);
+		}
+	/*
+	}else if((dojo.render.html.capable)&amp;&amp;(dojo.render.html.safari)){
+		// FIXME: this doesn't appear to work!
+		// from: <A HREF="http://web-graphics.com/mtarchive/001606.php">http://web-graphics.com/mtarchive/001606.php</A>
+		// var xml = '&lt;?xml version=&quot;1.0&quot;?&gt;'+str;
+		var mtype = &quot;text/xml&quot;;
+		var xml = '&lt;?xml version=&quot;1.0&quot;?&gt;'+str;
+		var url = &quot;data:&quot;+mtype+&quot;;charset=utf-8,&quot;+encodeURIComponent(xml);
+		var req = new XMLHttpRequest();
+		req.open(&quot;GET&quot;, url, false);
+		req.overrideMimeType(mtype);
+		req.send(null);
+		return req.responseXML;
+	*/
+	}else if(document.createElement){
+		// FIXME: this may change all tags to uppercase!
+		var tmp = document.createElement(&quot;xml&quot;);
+		tmp.innerHTML = str;
+		if(document.implementation &amp;&amp; document.implementation.createDocument) {
+			var xmlDoc = document.implementation.createDocument(&quot;foo&quot;, &quot;&quot;, null);
+			for(var i = 0; i &lt; tmp.childNodes.length; i++) {
+				xmlDoc.importNode(tmp.childNodes.item(i), true);
+			}
+			return xmlDoc;
+		}
+		// FIXME: probably not a good idea to have to return an HTML fragment
+		// FIXME: the tmp.doc.firstChild is as tested from IE, so it may not
+		// work that way across the board
+		return ((tmp.document)&amp;&amp;
+			(tmp.document.firstChild ?  tmp.document.firstChild : tmp));
+	}
+	return null;
+}
+
+dojo.dom.prependChild = function(node, parent) {
+	if(parent.firstChild) {
+		parent.insertBefore(node, parent.firstChild);
+	} else {
+		parent.appendChild(node);
+	}
+	return true;
+}
+
+dojo.dom.insertBefore = function(node, ref, force){
+	if (force != true &amp;&amp;
+		(node === ref || node.nextSibling === ref)){ return false; }
+	var parent = ref.parentNode;
+	parent.insertBefore(node, ref);
+	return true;
+}
+
+dojo.dom.insertAfter = function(node, ref, force){
+	var pn = ref.parentNode;
+	if(ref == pn.lastChild){
+		if((force != true)&amp;&amp;(node === ref)){
+			return false;
+		}
+		pn.appendChild(node);
+	}else{
+		return this.insertBefore(node, ref.nextSibling, force);
+	}
+	return true;
+}
+
+dojo.dom.insertAtPosition = function(node, ref, position){
+	if((!node)||(!ref)||(!position)){ return false; }
+	switch(position.toLowerCase()){
+		case &quot;before&quot;:
+			return dojo.dom.insertBefore(node, ref);
+		case &quot;after&quot;:
+			return dojo.dom.insertAfter(node, ref);
+		case &quot;first&quot;:
+			if(ref.firstChild){
+				return dojo.dom.insertBefore(node, ref.firstChild);
+			}else{
+				ref.appendChild(node);
+				return true;
+			}
+			break;
+		default: // aka: last
+			ref.appendChild(node);
+			return true;
+	}
+}
+
+dojo.dom.insertAtIndex = function(node, containingNode, insertionIndex){
+	var siblingNodes = containingNode.childNodes;
+
+	// if there aren't any kids yet, just add it to the beginning
+
+	if (!siblingNodes.length){
+		containingNode.appendChild(node);
+		return true;
+	}
+
+	// otherwise we need to walk the childNodes
+	// and find our spot
+
+	var after = null;
+
+	for(var i=0; i&lt;siblingNodes.length; i++){
+
+		var sibling_index = siblingNodes.item(i)[&quot;getAttribute&quot;] ? parseInt(siblingNodes.item(i).getAttribute(&quot;dojoinsertionindex&quot;)) : -1;
+
+		if (sibling_index &lt; insertionIndex){
+			after = siblingNodes.item(i);
+		}
+	}
+
+	if (after){
+		// add it after the node in {after}
+
+		return dojo.dom.insertAfter(node, after);
+	}else{
+		// add it to the start
+
+		return dojo.dom.insertBefore(node, siblingNodes.item(0));
+	}
+}
+	
+/**
+ * implementation of the DOM Level 3 attribute.
+ * 
+ * @param node The node to scan for text
+ * @param text Optional, set the text to this value.
+ */
+dojo.dom.textContent = function(node, text){
+	if (text) {
+		dojo.dom.replaceChildren(node, document.createTextNode(text));
+		return text;
+	} else {
+		var _result = &quot;&quot;;
+		if (node == null) { return _result; }
+		for (var i = 0; i &lt; node.childNodes.length; i++) {
+			switch (node.childNodes[i].nodeType) {
+				case 1: // ELEMENT_NODE
+				case 5: // ENTITY_REFERENCE_NODE
+					_result += dojo.dom.textContent(node.childNodes[i]);
+					break;
+				case 3: // TEXT_NODE
+				case 2: // ATTRIBUTE_NODE
+				case 4: // CDATA_SECTION_NODE
+					_result += node.childNodes[i].nodeValue;
+					break;
+				default:
+					break;
+			}
+		}
+		return _result;
+	}
+}
+
+dojo.dom.collectionToArray = function(collection){
+	dojo.deprecated(&quot;dojo.dom.collectionToArray&quot;, &quot;use dojo.lang.toArray instead&quot;, &quot;0.4&quot;);
+	return dojo.lang.toArray(collection);
+}
+
+dojo.dom.hasParent = function (node) {
+	return node &amp;&amp; node.parentNode &amp;&amp; dojo.dom.isNode(node.parentNode);
+}
+
+/**
+ * Determines if node has any of the provided tag names and
+ * returns the tag name that matches, empty string otherwise.
+ *
+ * Examples:
+ *
+ * myFooNode = &lt;foo /&gt;
+ * isTag(myFooNode, &quot;foo&quot;); // returns &quot;foo&quot;
+ * isTag(myFooNode, &quot;bar&quot;); // returns &quot;&quot;
+ * isTag(myFooNode, &quot;FOO&quot;); // returns &quot;&quot;
+ * isTag(myFooNode, &quot;hey&quot;, &quot;foo&quot;, &quot;bar&quot;); // returns &quot;foo&quot;
+**/
+dojo.dom.isTag = function(node /* ... */) {
+	if(node &amp;&amp; node.tagName) {
+		var arr = dojo.lang.toArray(arguments, 1);
+		return arr[ dojo.lang.find(node.tagName, arr) ] || &quot;&quot;;
+	}
+	return &quot;&quot;;
+}

Added: trunk/root/static/magic/src/event/__package__.js
===================================================================
--- trunk/root/static/magic/src/event/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/event/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,16 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.event&quot;, &quot;dojo.event.topic&quot;],
+	browser: [&quot;dojo.event.browser&quot;],
+	dashboard: [&quot;dojo.event.browser&quot;]
+});
+dojo.provide(&quot;dojo.event.*&quot;);

Added: trunk/root/static/magic/src/event/browser.js
===================================================================
--- trunk/root/static/magic/src/event/browser.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/event/browser.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,273 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.event.browser&quot;);
+dojo.require(&quot;dojo.event&quot;);
+
+// FIXME: any particular reason this is in the global scope?
+dojo._ie_clobber = new function(){
+	this.clobberNodes = [];
+
+	function nukeProp(node, prop){
+		// try{ node.removeAttribute(prop); 	}catch(e){ /* squelch */ }
+		try{ node[prop] = null; 			}catch(e){ /* squelch */ }
+		try{ delete node[prop]; 			}catch(e){ /* squelch */ }
+		// FIXME: JotLive needs this, but I'm not sure if it's too slow or not
+		try{ node.removeAttribute(prop);	}catch(e){ /* squelch */ }
+	}
+
+	this.clobber = function(nodeRef){
+		var na;
+		var tna;
+		if(nodeRef){
+			tna = nodeRef.all || nodeRef.getElementsByTagName(&quot;*&quot;);
+			na = [nodeRef];
+			for(var x=0; x&lt;tna.length; x++){
+				// if we're gonna be clobbering the thing, at least make sure
+				// we aren't trying to do it twice
+				if(tna[x][&quot;__doClobber__&quot;]){
+					na.push(tna[x]);
+				}
+			}
+		}else{
+			try{ window.onload = null; }catch(e){}
+			na = (this.clobberNodes.length) ? this.clobberNodes : document.all;
+		}
+		tna = null;
+		var basis = {};
+		for(var i = na.length-1; i&gt;=0; i=i-1){
+			var el = na[i];
+			if(el[&quot;__clobberAttrs__&quot;]){
+				for(var j=0; j&lt;el.__clobberAttrs__.length; j++){
+					nukeProp(el, el.__clobberAttrs__[j]);
+				}
+				nukeProp(el, &quot;__clobberAttrs__&quot;);
+				nukeProp(el, &quot;__doClobber__&quot;);
+			}
+		}
+		na = null;
+	}
+}
+
+if(dojo.render.html.ie){
+	dojo.addOnUnload(function(){
+		dojo._ie_clobber.clobber();
+		try{
+			if((dojo[&quot;widget&quot;])&amp;&amp;(dojo.widget[&quot;manager&quot;])){
+				dojo.widget.manager.destroyAll();
+			}
+		}catch(e){}
+		try{ window.onload = null; }catch(e){}
+		try{ window.onunload = null; }catch(e){}
+		dojo._ie_clobber.clobberNodes = [];
+		// CollectGarbage();
+	});
+}
+
+dojo.event.browser = new function(){
+
+	var clobberIdx = 0;
+
+	this.clean = function(node){
+		if(dojo.render.html.ie){ 
+			dojo._ie_clobber.clobber(node);
+		}
+	}
+
+	this.addClobberNode = function(node){
+		if(!dojo.render.html.ie){ return; }
+		if(!node[&quot;__doClobber__&quot;]){
+			node.__doClobber__ = true;
+			dojo._ie_clobber.clobberNodes.push(node);
+			// this might not be the most efficient thing to do, but it's
+			// much less error prone than other approaches which were
+			// previously tried and failed
+			node.__clobberAttrs__ = [];
+		}
+	}
+
+	this.addClobberNodeAttrs = function(node, props){
+		if(!dojo.render.html.ie){ return; }
+		this.addClobberNode(node);
+		for(var x=0; x&lt;props.length; x++){
+			node.__clobberAttrs__.push(props[x]);
+		}
+	}
+
+	this.removeListener = function(node, evtName, fp, capture){
+		if(!capture){ var capture = false; }
+		evtName = evtName.toLowerCase();
+		if(evtName.substr(0,2)==&quot;on&quot;){ evtName = evtName.substr(2); }
+		// FIXME: this is mostly a punt, we aren't actually doing anything on IE
+		if(node.removeEventListener){
+			node.removeEventListener(evtName, fp, capture);
+		}
+	}
+
+	this.addListener = function(node, evtName, fp, capture, dontFix){
+		if(!node){ return; } // FIXME: log and/or bail?
+		if(!capture){ var capture = false; }
+		evtName = evtName.toLowerCase();
+		if(evtName.substr(0,2)!=&quot;on&quot;){ evtName = &quot;on&quot;+evtName; }
+
+		if(!dontFix){
+			// build yet another closure around fp in order to inject fixEvent
+			// around the resulting event
+			var newfp = function(evt){
+				if(!evt){ evt = window.event; }
+				var ret = fp(dojo.event.browser.fixEvent(evt, this));
+				if(capture){
+					dojo.event.browser.stopEvent(evt);
+				}
+				return ret;
+			}
+		}else{
+			newfp = fp;
+		}
+
+		if(node.addEventListener){ 
+			node.addEventListener(evtName.substr(2), newfp, capture);
+			return newfp;
+		}else{
+			if(typeof node[evtName] == &quot;function&quot; ){
+				var oldEvt = node[evtName];
+				node[evtName] = function(e){
+					oldEvt(e);
+					return newfp(e);
+				}
+			}else{
+				node[evtName]=newfp;
+			}
+			if(dojo.render.html.ie){
+				this.addClobberNodeAttrs(node, [evtName]);
+			}
+			return newfp;
+		}
+	}
+
+	this.isEvent = function(obj){
+		// FIXME: event detection hack ... could test for additional attributes
+		// if necessary
+		return (typeof obj != &quot;undefined&quot;)&amp;&amp;(typeof Event != &quot;undefined&quot;)&amp;&amp;(obj.eventPhase);
+		// Event does not support instanceof in Opera, otherwise:
+		//return (typeof Event != &quot;undefined&quot;)&amp;&amp;(obj instanceof Event);
+	}
+
+	this.currentEvent = null;
+	
+	this.callListener = function(listener, curTarget){
+		if(typeof listener != 'function'){
+			dojo.raise(&quot;listener not a function: &quot; + listener);
+		}
+		dojo.event.browser.currentEvent.currentTarget = curTarget;
+		return listener.call(curTarget, dojo.event.browser.currentEvent);
+	}
+
+	this.stopPropagation = function(){
+		dojo.event.browser.currentEvent.cancelBubble = true;
+	}
+
+	this.preventDefault = function(){
+	  dojo.event.browser.currentEvent.returnValue = false;
+	}
+
+	this.keys = {
+		KEY_BACKSPACE: 8,
+		KEY_TAB: 9,
+		KEY_ENTER: 13,
+		KEY_SHIFT: 16,
+		KEY_CTRL: 17,
+		KEY_ALT: 18,
+		KEY_PAUSE: 19,
+		KEY_CAPS_LOCK: 20,
+		KEY_ESCAPE: 27,
+		KEY_SPACE: 32,
+		KEY_PAGE_UP: 33,
+		KEY_PAGE_DOWN: 34,
+		KEY_END: 35,
+		KEY_HOME: 36,
+		KEY_LEFT_ARROW: 37,
+		KEY_UP_ARROW: 38,
+		KEY_RIGHT_ARROW: 39,
+		KEY_DOWN_ARROW: 40,
+		KEY_INSERT: 45,
+		KEY_DELETE: 46,
+		KEY_LEFT_WINDOW: 91,
+		KEY_RIGHT_WINDOW: 92,
+		KEY_SELECT: 93,
+		KEY_F1: 112,
+		KEY_F2: 113,
+		KEY_F3: 114,
+		KEY_F4: 115,
+		KEY_F5: 116,
+		KEY_F6: 117,
+		KEY_F7: 118,
+		KEY_F8: 119,
+		KEY_F9: 120,
+		KEY_F10: 121,
+		KEY_F11: 122,
+		KEY_F12: 123,
+		KEY_NUM_LOCK: 144,
+		KEY_SCROLL_LOCK: 145
+	};
+
+	// reverse lookup
+	this.revKeys = [];
+	for(var key in this.keys){
+		this.revKeys[this.keys[key]] = key;
+	}
+
+	this.fixEvent = function(evt, sender){
+		if((!evt)&amp;&amp;(window[&quot;event&quot;])){
+			var evt = window.event;
+		}
+		
+		if((evt[&quot;type&quot;])&amp;&amp;(evt[&quot;type&quot;].indexOf(&quot;key&quot;) == 0)){ // key events
+			evt.keys = this.revKeys;
+			// FIXME: how can we eliminate this iteration?
+			for(var key in this.keys) {
+				evt[key] = this.keys[key];
+			}
+			if((dojo.render.html.ie)&amp;&amp;(evt[&quot;type&quot;] == &quot;keypress&quot;)){
+				evt.charCode = evt.keyCode;
+			}
+		}
+	
+		if(dojo.render.html.ie){
+			if(!evt.target){ evt.target = evt.srcElement; }
+			if(!evt.currentTarget){ evt.currentTarget = (sender ? sender : evt.srcElement); }
+			if(!evt.layerX){ evt.layerX = evt.offsetX; }
+			if(!evt.layerY){ evt.layerY = evt.offsetY; }
+			// FIXME: scroll position query is duped from dojo.html to avoid dependency on that entire module
+			var docBody = ((dojo.render.html.ie55)||(document[&quot;compatMode&quot;] == &quot;BackCompat&quot;)) ? document.body : document.documentElement;
+			if(!evt.pageX){ evt.pageX = evt.clientX + (docBody.scrollLeft || 0) }
+			if(!evt.pageY){ evt.pageY = evt.clientY + (docBody.scrollTop || 0) }
+			// mouseover
+			if(evt.type == &quot;mouseover&quot;){ evt.relatedTarget = evt.fromElement; }
+			// mouseout
+			if(evt.type == &quot;mouseout&quot;){ evt.relatedTarget = evt.toElement; }
+			this.currentEvent = evt;
+			evt.callListener = this.callListener;
+			evt.stopPropagation = this.stopPropagation;
+			evt.preventDefault = this.preventDefault;
+		}
+		return evt;
+	}
+
+	this.stopEvent = function(ev) {
+		if(window.event){
+			ev.returnValue = false;
+			ev.cancelBubble = true;
+		}else{
+			ev.preventDefault();
+			ev.stopPropagation();
+		}
+	}
+}

Added: trunk/root/static/magic/src/event/topic.js
===================================================================
--- trunk/root/static/magic/src/event/topic.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/event/topic.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,99 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.event&quot;);
+dojo.provide(&quot;dojo.event.topic&quot;);
+
+dojo.event.topic = new function(){
+	this.topics = {};
+
+	this.getTopic = function(topicName){
+		if(!this.topics[topicName]){
+			this.topics[topicName] = new this.TopicImpl(topicName);
+		}
+		return this.topics[topicName];
+	}
+
+	this.registerPublisher = function(topic, obj, funcName){
+		var topic = this.getTopic(topic);
+		topic.registerPublisher(obj, funcName);
+	}
+
+	this.subscribe = function(topic, obj, funcName){
+		var topic = this.getTopic(topic);
+		topic.subscribe(obj, funcName);
+	}
+
+	this.unsubscribe = function(topic, obj, funcName){
+		var topic = this.getTopic(topic);
+		topic.unsubscribe(obj, funcName);
+	}
+
+	this.destroy = function(topic){
+		this.getTopic(topic).destroy();
+		delete this.topics[topic];
+	}
+
+	this.publishApply = function(topic, args){
+		var topic = this.getTopic(topic);
+		topic.sendMessage.apply(topic, args);
+	}
+
+	this.publish = function(topic, message){
+		var topic = this.getTopic(topic);
+		// if message is an array, we treat it as a set of arguments,
+		// otherwise, we just pass on the arguments passed in as-is
+		var args = [];
+		// could we use concat instead here?
+		for(var x=1; x&lt;arguments.length; x++){
+			args.push(arguments[x]);
+		}
+		topic.sendMessage.apply(topic, args);
+	}
+}
+
+dojo.event.topic.TopicImpl = function(topicName){
+	this.topicName = topicName;
+
+	this.subscribe = function(listenerObject, listenerMethod){
+		var tf = listenerMethod||listenerObject;
+		var to = (!listenerMethod) ? dj_global : listenerObject;
+		dojo.event.kwConnect({
+			srcObj:		this, 
+			srcFunc:	&quot;sendMessage&quot;, 
+			adviceObj:	to,
+			adviceFunc: tf
+		});
+	}
+
+	this.unsubscribe = function(listenerObject, listenerMethod){
+		var tf = (!listenerMethod) ? listenerObject : listenerMethod;
+		var to = (!listenerMethod) ? null : listenerObject;
+		dojo.event.kwDisconnect({
+			srcObj:		this, 
+			srcFunc:	&quot;sendMessage&quot;, 
+			adviceObj:	to,
+			adviceFunc: tf
+		});
+	}
+
+	this.destroy = function(){
+		dojo.event.MethodJoinPoint.getForMethod(this, &quot;sendMessage&quot;).disconnect();
+	}
+
+	this.registerPublisher = function(publisherObject, publisherMethod){
+		dojo.event.connect(publisherObject, publisherMethod, this, &quot;sendMessage&quot;);
+	}
+
+	this.sendMessage = function(message){
+		// The message has been propagated
+	}
+}
+

Added: trunk/root/static/magic/src/event.js
===================================================================
--- trunk/root/static/magic/src/event.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/event.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,575 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.event&quot;);
+
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+
+dojo.event = new function(){
+	this.canTimeout = dojo.lang.isFunction(dj_global[&quot;setTimeout&quot;])||dojo.lang.isAlien(dj_global[&quot;setTimeout&quot;]);
+
+	// FIXME: where should we put this method (not here!)?
+	function interpolateArgs(args, searchForNames){
+		var dl = dojo.lang;
+		var ao = {
+			srcObj: dj_global,
+			srcFunc: null,
+			adviceObj: dj_global,
+			adviceFunc: null,
+			aroundObj: null,
+			aroundFunc: null,
+			adviceType: (args.length&gt;2) ? args[0] : &quot;after&quot;,
+			precedence: &quot;last&quot;,
+			once: false,
+			delay: null,
+			rate: 0,
+			adviceMsg: false
+		};
+
+		switch(args.length){
+			case 0: return;
+			case 1: return;
+			case 2:
+				ao.srcFunc = args[0];
+				ao.adviceFunc = args[1];
+				break;
+			case 3:
+				if((dl.isObject(args[0]))&amp;&amp;(dl.isString(args[1]))&amp;&amp;(dl.isString(args[2]))){
+					ao.adviceType = &quot;after&quot;;
+					ao.srcObj = args[0];
+					ao.srcFunc = args[1];
+					ao.adviceFunc = args[2];
+				}else if((dl.isString(args[1]))&amp;&amp;(dl.isString(args[2]))){
+					ao.srcFunc = args[1];
+					ao.adviceFunc = args[2];
+				}else if((dl.isObject(args[0]))&amp;&amp;(dl.isString(args[1]))&amp;&amp;(dl.isFunction(args[2]))){
+					ao.adviceType = &quot;after&quot;;
+					ao.srcObj = args[0];
+					ao.srcFunc = args[1];
+					var tmpName  = dl.nameAnonFunc(args[2], ao.adviceObj, searchForNames);
+					ao.adviceFunc = tmpName;
+				}else if((dl.isFunction(args[0]))&amp;&amp;(dl.isObject(args[1]))&amp;&amp;(dl.isString(args[2]))){
+					ao.adviceType = &quot;after&quot;;
+					ao.srcObj = dj_global;
+					var tmpName  = dl.nameAnonFunc(args[0], ao.srcObj, searchForNames);
+					ao.srcFunc = tmpName;
+					ao.adviceObj = args[1];
+					ao.adviceFunc = args[2];
+				}
+				break;
+			case 4:
+				if((dl.isObject(args[0]))&amp;&amp;(dl.isObject(args[2]))){
+					// we can assume that we've got an old-style &quot;connect&quot; from
+					// the sigslot school of event attachment. We therefore
+					// assume after-advice.
+					ao.adviceType = &quot;after&quot;;
+					ao.srcObj = args[0];
+					ao.srcFunc = args[1];
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else if((dl.isString(args[0]))&amp;&amp;(dl.isString(args[1]))&amp;&amp;(dl.isObject(args[2]))){
+					ao.adviceType = args[0];
+					ao.srcObj = dj_global;
+					ao.srcFunc = args[1];
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else if((dl.isString(args[0]))&amp;&amp;(dl.isFunction(args[1]))&amp;&amp;(dl.isObject(args[2]))){
+					ao.adviceType = args[0];
+					ao.srcObj = dj_global;
+					var tmpName  = dl.nameAnonFunc(args[1], dj_global, searchForNames);
+					ao.srcFunc = tmpName;
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else if((dl.isString(args[0]))&amp;&amp;(dl.isObject(args[1]))&amp;&amp;(dl.isString(args[2]))&amp;&amp;(dl.isFunction(args[3]))){
+					ao.srcObj = args[1];
+					ao.srcFunc = args[2];
+					var tmpName  = dl.nameAnonFunc(args[3], dj_global, searchForNames);
+					ao.adviceObj = dj_global;
+					ao.adviceFunc = tmpName;
+				}else if(dl.isObject(args[1])){
+					ao.srcObj = args[1];
+					ao.srcFunc = args[2];
+					ao.adviceObj = dj_global;
+					ao.adviceFunc = args[3];
+				}else if(dl.isObject(args[2])){
+					ao.srcObj = dj_global;
+					ao.srcFunc = args[1];
+					ao.adviceObj = args[2];
+					ao.adviceFunc = args[3];
+				}else{
+					ao.srcObj = ao.adviceObj = ao.aroundObj = dj_global;
+					ao.srcFunc = args[1];
+					ao.adviceFunc = args[2];
+					ao.aroundFunc = args[3];
+				}
+				break;
+			case 6:
+				ao.srcObj = args[1];
+				ao.srcFunc = args[2];
+				ao.adviceObj = args[3]
+				ao.adviceFunc = args[4];
+				ao.aroundFunc = args[5];
+				ao.aroundObj = dj_global;
+				break;
+			default:
+				ao.srcObj = args[1];
+				ao.srcFunc = args[2];
+				ao.adviceObj = args[3]
+				ao.adviceFunc = args[4];
+				ao.aroundObj = args[5];
+				ao.aroundFunc = args[6];
+				ao.once = args[7];
+				ao.delay = args[8];
+				ao.rate = args[9];
+				ao.adviceMsg = args[10];
+				break;
+		}
+
+		if(dl.isFunction(ao.aroundFunc)){
+			var tmpName  = dl.nameAnonFunc(ao.aroundFunc, ao.aroundObj, searchForNames);
+			ao.aroundFunc = tmpName;
+		}
+
+		if(dl.isFunction(ao.srcFunc)){
+			ao.srcFunc = dl.getNameInObj(ao.srcObj, ao.srcFunc);
+		}
+
+		if(dl.isFunction(ao.adviceFunc)){
+			ao.adviceFunc = dl.getNameInObj(ao.adviceObj, ao.adviceFunc);
+		}
+
+		if((ao.aroundObj)&amp;&amp;(dl.isFunction(ao.aroundFunc))){
+			ao.aroundFunc = dl.getNameInObj(ao.aroundObj, ao.aroundFunc);
+		}
+
+		if(!ao.srcObj){
+			dojo.raise(&quot;bad srcObj for srcFunc: &quot;+ao.srcFunc);
+		}
+		if(!ao.adviceObj){
+			dojo.raise(&quot;bad adviceObj for adviceFunc: &quot;+ao.adviceFunc);
+		}
+		return ao;
+	}
+
+	this.connect = function(){
+		if(arguments.length == 1){
+			var ao = arguments[0];
+		}else{
+			var ao = interpolateArgs(arguments, true);
+		}
+
+		if(dojo.lang.isArray(ao.srcObj) &amp;&amp; ao.srcObj!=&quot;&quot;){
+			var tmpAO = {};
+			for(var x in ao){
+				tmpAO[x] = ao[x];
+			}
+			var mjps = [];
+			dojo.lang.forEach(ao.srcObj, function(src){
+				if((dojo.render.html.capable)&amp;&amp;(dojo.lang.isString(src))){
+					src = dojo.byId(src);
+					// dojo.debug(src);
+				}
+				tmpAO.srcObj = src;
+				// dojo.debug(tmpAO.srcObj, tmpAO.srcFunc);
+				// dojo.debug(tmpAO.adviceObj, tmpAO.adviceFunc);
+				mjps.push(dojo.event.connect.call(dojo.event, tmpAO));
+			});
+			return mjps;
+		}
+
+		// FIXME: just doing a &quot;getForMethod()&quot; seems to be enough to put this into infinite recursion!!
+		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
+		if(ao.adviceFunc){
+			var mjp2 = dojo.event.MethodJoinPoint.getForMethod(ao.adviceObj, ao.adviceFunc);
+		}
+
+		mjp.kwAddAdvice(ao);
+
+		return mjp;	// advanced users might want to fsck w/ the join point
+					// manually
+	}
+
+	this.log = function(a1, a2){
+		var kwArgs;
+		if((arguments.length == 1)&amp;&amp;(typeof a1 == &quot;object&quot;)){
+			kwArgs = a1;
+		}else{
+			kwArgs = {
+				srcObj: a1,
+				srcFunc: a2
+			};
+		}
+		kwArgs.adviceFunc = function(){
+			var argsStr = [];
+			for(var x=0; x&lt;arguments.length; x++){
+				argsStr.push(arguments[x]);
+			}
+			dojo.debug(&quot;(&quot;+kwArgs.srcObj+&quot;).&quot;+kwArgs.srcFunc, &quot;:&quot;, argsStr.join(&quot;, &quot;));
+		}
+		this.kwConnect(kwArgs);
+	}
+
+	this.connectBefore = function(){
+		var args = [&quot;before&quot;];
+		for(var i = 0; i &lt; arguments.length; i++) { args.push(arguments[i]); }
+		return this.connect.apply(this, args);
+	}
+
+	this.connectAround = function(){
+		var args = [&quot;around&quot;];
+		for(var i = 0; i &lt; arguments.length; i++) { args.push(arguments[i]); }
+		return this.connect.apply(this, args);
+	}
+
+	this.connectOnce = function(){
+		var ao = interpolateArgs(arguments, true);
+		ao.once = true;
+		return this.connect(ao);
+	}
+
+	this._kwConnectImpl = function(kwArgs, disconnect){
+		var fn = (disconnect) ? &quot;disconnect&quot; : &quot;connect&quot;;
+		if(typeof kwArgs[&quot;srcFunc&quot;] == &quot;function&quot;){
+			kwArgs.srcObj = kwArgs[&quot;srcObj&quot;]||dj_global;
+			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.srcFunc, kwArgs.srcObj, true);
+			kwArgs.srcFunc = tmpName;
+		}
+		if(typeof kwArgs[&quot;adviceFunc&quot;] == &quot;function&quot;){
+			kwArgs.adviceObj = kwArgs[&quot;adviceObj&quot;]||dj_global;
+			var tmpName  = dojo.lang.nameAnonFunc(kwArgs.adviceFunc, kwArgs.adviceObj, true);
+			kwArgs.adviceFunc = tmpName;
+		}
+		return dojo.event[fn](	(kwArgs[&quot;type&quot;]||kwArgs[&quot;adviceType&quot;]||&quot;after&quot;),
+									kwArgs[&quot;srcObj&quot;]||dj_global,
+									kwArgs[&quot;srcFunc&quot;],
+									kwArgs[&quot;adviceObj&quot;]||kwArgs[&quot;targetObj&quot;]||dj_global,
+									kwArgs[&quot;adviceFunc&quot;]||kwArgs[&quot;targetFunc&quot;],
+									kwArgs[&quot;aroundObj&quot;],
+									kwArgs[&quot;aroundFunc&quot;],
+									kwArgs[&quot;once&quot;],
+									kwArgs[&quot;delay&quot;],
+									kwArgs[&quot;rate&quot;],
+									kwArgs[&quot;adviceMsg&quot;]||false );
+	}
+
+	this.kwConnect = function(kwArgs){
+		return this._kwConnectImpl(kwArgs, false);
+
+	}
+
+	this.disconnect = function(){
+		var ao = interpolateArgs(arguments, true);
+		if(!ao.adviceFunc){ return; } // nothing to disconnect
+		var mjp = dojo.event.MethodJoinPoint.getForMethod(ao.srcObj, ao.srcFunc);
+		return mjp.removeAdvice(ao.adviceObj, ao.adviceFunc, ao.adviceType, ao.once);
+	}
+
+	this.kwDisconnect = function(kwArgs){
+		return this._kwConnectImpl(kwArgs, true);
+	}
+}
+
+// exactly one of these is created whenever a method with a joint point is run,
+// if there is at least one 'around' advice.
+dojo.event.MethodInvocation = function(join_point, obj, args) {
+	this.jp_ = join_point;
+	this.object = obj;
+	this.args = [];
+	for(var x=0; x&lt;args.length; x++){
+		this.args[x] = args[x];
+	}
+	// the index of the 'around' that is currently being executed.
+	this.around_index = -1;
+}
+
+dojo.event.MethodInvocation.prototype.proceed = function() {
+	this.around_index++;
+	if(this.around_index &gt;= this.jp_.around.length){
+		return this.jp_.object[this.jp_.methodname].apply(this.jp_.object, this.args);
+		// return this.jp_.run_before_after(this.object, this.args);
+	}else{
+		var ti = this.jp_.around[this.around_index];
+		var mobj = ti[0]||dj_global;
+		var meth = ti[1];
+		return mobj[meth].call(mobj, this);
+	}
+} 
+
+
+dojo.event.MethodJoinPoint = function(obj, methname){
+	this.object = obj||dj_global;
+	this.methodname = methname;
+	this.methodfunc = this.object[methname];
+	this.before = [];
+	this.after = [];
+	this.around = [];
+}
+
+dojo.event.MethodJoinPoint.getForMethod = function(obj, methname) {
+	// if(!(methname in obj)){
+	if(!obj){ obj = dj_global; }
+	if(!obj[methname]){
+		// supply a do-nothing method implementation
+		obj[methname] = function(){};
+		if(!obj[methname]){
+			// e.g. cannot add to inbuilt objects in IE6
+			dojo.raise(&quot;Cannot set do-nothing method on that object &quot;+methname);
+		}
+	}else if((!dojo.lang.isFunction(obj[methname]))&amp;&amp;(!dojo.lang.isAlien(obj[methname]))){
+		return null; // FIXME: should we throw an exception here instead?
+	}
+	// we hide our joinpoint instance in obj[methname + '$joinpoint']
+	var jpname = methname + &quot;$joinpoint&quot;;
+	var jpfuncname = methname + &quot;$joinpoint$method&quot;;
+	var joinpoint = obj[jpname];
+	if(!joinpoint){
+		var isNode = false;
+		if(dojo.event[&quot;browser&quot;]){
+			if( (obj[&quot;attachEvent&quot;])||
+				(obj[&quot;nodeType&quot;])||
+				(obj[&quot;addEventListener&quot;]) ){
+				isNode = true;
+				dojo.event.browser.addClobberNodeAttrs(obj, [jpname, jpfuncname, methname]);
+			}
+		}
+		var origArity = obj[methname].length;
+		obj[jpfuncname] = obj[methname];
+		// joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, methname);
+		joinpoint = obj[jpname] = new dojo.event.MethodJoinPoint(obj, jpfuncname);
+		obj[methname] = function(){ 
+			var args = [];
+
+			if((isNode)&amp;&amp;(!arguments.length)){
+				var evt = null;
+				try{
+					if(obj.ownerDocument){
+						evt = obj.ownerDocument.parentWindow.event;
+					}else if(obj.documentElement){
+						evt = obj.documentElement.ownerDocument.parentWindow.event;
+					}else{
+						evt = window.event;
+					}
+				}catch(e){
+					evt = window.event;
+				}
+
+				if(evt){
+					args.push(dojo.event.browser.fixEvent(evt, this));
+				}
+			}else{
+				for(var x=0; x&lt;arguments.length; x++){
+					if((x==0)&amp;&amp;(isNode)&amp;&amp;(dojo.event.browser.isEvent(arguments[x]))){
+						args.push(dojo.event.browser.fixEvent(arguments[x], this));
+					}else{
+						args.push(arguments[x]);
+					}
+				}
+			}
+			// return joinpoint.run.apply(joinpoint, arguments); 
+			return joinpoint.run.apply(joinpoint, args); 
+		}
+		obj[methname].__preJoinArity = origArity;
+	}
+	return joinpoint;
+}
+
+dojo.lang.extend(dojo.event.MethodJoinPoint, {
+	unintercept: function(){
+		this.object[this.methodname] = this.methodfunc;
+		this.before = [];
+		this.after = [];
+		this.around = [];
+	},
+
+	disconnect: dojo.lang.forward(&quot;unintercept&quot;),
+
+	run: function() {
+		var obj = this.object||dj_global;
+		var args = arguments;
+
+		// optimization. We only compute once the array version of the arguments
+		// pseudo-arr in order to prevent building it each time advice is unrolled.
+		var aargs = [];
+		for(var x=0; x&lt;args.length; x++){
+			aargs[x] = args[x];
+		}
+
+		var unrollAdvice  = function(marr){ 
+			if(!marr){
+				dojo.debug(&quot;Null argument to unrollAdvice()&quot;);
+				return;
+			}
+		  
+			var callObj = marr[0]||dj_global;
+			var callFunc = marr[1];
+			
+			if(!callObj[callFunc]){
+				dojo.raise(&quot;function \&quot;&quot; + callFunc + &quot;\&quot; does not exist on \&quot;&quot; + callObj + &quot;\&quot;&quot;);
+			}
+			
+			var aroundObj = marr[2]||dj_global;
+			var aroundFunc = marr[3];
+			var msg = marr[6];
+			var undef;
+
+			var to = {
+				args: [],
+				jp_: this,
+				object: obj,
+				proceed: function(){
+					return callObj[callFunc].apply(callObj, to.args);
+				}
+			};
+			to.args = aargs;
+
+			var delay = parseInt(marr[4]);
+			var hasDelay = ((!isNaN(delay))&amp;&amp;(marr[4]!==null)&amp;&amp;(typeof marr[4] != &quot;undefined&quot;));
+			if(marr[5]){
+				var rate = parseInt(marr[5]);
+				var cur = new Date();
+				var timerSet = false;
+				if((marr[&quot;last&quot;])&amp;&amp;((cur-marr.last)&lt;=rate)){
+					if(dojo.event.canTimeout){
+						if(marr[&quot;delayTimer&quot;]){
+							clearTimeout(marr.delayTimer);
+						}
+						var tod = parseInt(rate*2); // is rate*2 naive?
+						var mcpy = dojo.lang.shallowCopy(marr);
+						marr.delayTimer = setTimeout(function(){
+							// FIXME: on IE at least, event objects from the
+							// browser can go out of scope. How (or should?) we
+							// deal with it?
+							mcpy[5] = 0;
+							unrollAdvice(mcpy);
+						}, tod);
+					}
+					return;
+				}else{
+					marr.last = cur;
+				}
+			}
+
+			// FIXME: need to enforce rates for a connection here!
+
+			if(aroundFunc){
+				// NOTE: around advice can't delay since we might otherwise depend
+				// on execution order!
+				aroundObj[aroundFunc].call(aroundObj, to);
+			}else{
+				// var tmjp = dojo.event.MethodJoinPoint.getForMethod(obj, methname);
+				if((hasDelay)&amp;&amp;((dojo.render.html)||(dojo.render.svg))){  // FIXME: the render checks are grotty!
+					dj_global[&quot;setTimeout&quot;](function(){
+						if(msg){
+							callObj[callFunc].call(callObj, to); 
+						}else{
+							callObj[callFunc].apply(callObj, args); 
+						}
+					}, delay);
+				}else{ // many environments can't support delay!
+					if(msg){
+						callObj[callFunc].call(callObj, to); 
+					}else{
+						callObj[callFunc].apply(callObj, args); 
+					}
+				}
+			}
+		}
+
+		if(this.before.length&gt;0){
+			dojo.lang.forEach(this.before, unrollAdvice);
+		}
+
+		var result;
+		if(this.around.length&gt;0){
+			var mi = new dojo.event.MethodInvocation(this, obj, args);
+			result = mi.proceed();
+		}else if(this.methodfunc){
+			result = this.object[this.methodname].apply(this.object, args);
+		}
+
+		if(this.after.length&gt;0){
+			dojo.lang.forEach(this.after, unrollAdvice);
+		}
+
+		return (this.methodfunc) ? result : null;
+	},
+
+	getArr: function(kind){
+		var arr = this.after;
+		// FIXME: we should be able to do this through props or Array.in()
+		if((typeof kind == &quot;string&quot;)&amp;&amp;(kind.indexOf(&quot;before&quot;)!=-1)){
+			arr = this.before;
+		}else if(kind==&quot;around&quot;){
+			arr = this.around;
+		}
+		return arr;
+	},
+
+	kwAddAdvice: function(args){
+		this.addAdvice(	args[&quot;adviceObj&quot;], args[&quot;adviceFunc&quot;], 
+						args[&quot;aroundObj&quot;], args[&quot;aroundFunc&quot;], 
+						args[&quot;adviceType&quot;], args[&quot;precedence&quot;], 
+						args[&quot;once&quot;], args[&quot;delay&quot;], args[&quot;rate&quot;], 
+						args[&quot;adviceMsg&quot;]);
+	},
+
+	addAdvice: function(	thisAdviceObj, thisAdvice, 
+							thisAroundObj, thisAround, 
+							advice_kind, precedence, 
+							once, delay, rate, asMessage){
+		var arr = this.getArr(advice_kind);
+		if(!arr){
+			dojo.raise(&quot;bad this: &quot; + this);
+		}
+
+		var ao = [thisAdviceObj, thisAdvice, thisAroundObj, thisAround, delay, rate, asMessage];
+		
+		if(once){
+			if(this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr) &gt;= 0){
+				return;
+			}
+		}
+
+		if(precedence == &quot;first&quot;){
+			arr.unshift(ao);
+		}else{
+			arr.push(ao);
+		}
+	},
+
+	hasAdvice: function(thisAdviceObj, thisAdvice, advice_kind, arr){
+		if(!arr){ arr = this.getArr(advice_kind); }
+		var ind = -1;
+		for(var x=0; x&lt;arr.length; x++){
+			var aao = (typeof thisAdvice == &quot;object&quot;) ? (new String(thisAdvice)).toString() : thisAdvice;
+			var a1o = (typeof arr[x][1] == &quot;object&quot;) ? (new String(arr[x][1])).toString() : arr[x][1];
+			if((arr[x][0] == thisAdviceObj)&amp;&amp;(a1o == aao)){
+				ind = x;
+			}
+		}
+		return ind;
+	},
+
+	removeAdvice: function(thisAdviceObj, thisAdvice, advice_kind, once){
+		var arr = this.getArr(advice_kind);
+		var ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);
+		if(ind == -1){
+			return false;
+		}
+		while(ind != -1){
+			arr.splice(ind, 1);
+			if(once){ break; }
+			ind = this.hasAdvice(thisAdviceObj, thisAdvice, advice_kind, arr);
+		}
+		return true;
+	}
+});

Added: trunk/root/static/magic/src/experimental.js
===================================================================
--- trunk/root/static/magic/src/experimental.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/experimental.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,21 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.experimental&quot;);
+
+/**
+ * Convenience for informing of experimental code.
+ */
+dojo.experimental = function(packageName, extra){
+	var mess = &quot;EXPERIMENTAL: &quot; + packageName;
+	mess += &quot; -- Not yet ready for use.  APIs subject to change without notice.&quot;;
+	if(extra){ mess += &quot; &quot; + extra; }
+	dojo.debug(mess);
+}

Added: trunk/root/static/magic/src/flash/flash6/DojoExternalInterface.as
===================================================================
--- trunk/root/static/magic/src/flash/flash6/DojoExternalInterface.as	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/flash/flash6/DojoExternalInterface.as	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,214 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/** 
+		An implementation of Flash 8's ExternalInterface that works with Flash 6
+		and which is source-compatible with Flash 8. 
+		
+		@author Brad Neuberg, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">bkn3 at columbia.edu</A> 
+*/
+
+class DojoExternalInterface{
+	public static var available:Boolean;
+	public static var dojoPath = &quot;&quot;;
+	
+	public static var _fscommandReady = false;
+	public static var _callbacks = new Array();
+
+	public static function initialize(){ 
+		//getURL(&quot;javascript:dojo.debug('FLASH:DojoExternalInterface initialize')&quot;);
+		// FIXME: Set available variable by testing for capabilities
+		DojoExternalInterface.available = true;
+		
+		// extract the dojo base path
+		DojoExternalInterface.dojoPath = DojoExternalInterface.getDojoPath();
+		//getURL(&quot;javascript:dojo.debug('FLASH:dojoPath=&quot;+DojoExternalInterface.dojoPath+&quot;')&quot;);
+		
+		// Sometimes, on IE, the fscommand infrastructure can take a few hundred
+		// milliseconds the first time a page loads. Set a timer to keep checking
+		// to make sure we can issue fscommands; otherwise, our calls to fscommand
+		// for setCallback() and loaded() will just &quot;disappear&quot;
+		_root.fscommandReady = false;
+		var fsChecker = function(){
+			// issue a test fscommand
+			fscommand(&quot;fscommandReady&quot;);
+			
+			// JavaScript should set _root.fscommandReady if it got the call
+			if(_root.fscommandReady == &quot;true&quot;){
+				DojoExternalInterface._fscommandReady = true;
+				clearInterval(_root.fsTimer);
+			}
+		};
+		_root.fsTimer = setInterval(fsChecker, 100);
+	}
+	
+	public static function addCallback(methodName:String, instance:Object, 
+											method:Function) : Boolean{
+		// A variable that indicates whether the call below succeeded
+		_root._succeeded = null;
+		
+		// Callbacks are registered with the JavaScript side as follows.
+		// On the Flash side, we maintain a lookup table that associates
+		// the methodName with the actual instance and method that are
+		// associated with this method.
+		// Using fscommand, we send over the action &quot;addCallback&quot;, with the
+		// argument being the methodName to add, such as &quot;foobar&quot;.
+		// The JavaScript takes these values and registers the existence of
+		// this callback point.
+		
+		// precede the method name with a _ character in case it starts
+		// with a number
+		_callbacks[&quot;_&quot; + methodName] = {_instance: instance, _method: method};
+		_callbacks[_callbacks.length] = methodName;
+		
+		// The API for ExternalInterface says we have to make sure the call
+		// succeeded; check to see if there is a value 
+		// for _succeeded, which is set by the JavaScript side
+		if(_root._succeeded == null){
+			return false;
+		}else{
+			return true;
+		}
+	}
+	
+	public static function call(methodName:String, 
+								resultsCallback:Function) : Void{
+		// FIXME: support full JSON serialization
+		
+		// First, we pack up all of the arguments to this call and set them
+		// as Flash variables, which the JavaScript side will unpack using
+		// plugin.GetVariable(). We set the number of arguments as &quot;_numArgs&quot;,
+		// and add each argument as a variable, such as &quot;_1&quot;, &quot;_2&quot;, etc., starting
+		// from 0.
+		// We then execute an fscommand with the action &quot;call&quot; and the
+		// argument being the method name. JavaScript takes the method name,
+		// retrieves the arguments using GetVariable, executes the method,
+		// and then places the return result in a Flash variable
+		// named &quot;_returnResult&quot;.
+		_root._numArgs = arguments.length - 2;
+		for(var i = 2; i &lt; arguments.length; i++){
+			var argIndex = i - 2;
+			_root[&quot;_&quot; + argIndex] = arguments[i];
+		}
+		
+		_root._returnResult = undefined;
+		fscommand(&quot;call&quot;, methodName);
+		
+		// immediately return if the caller is not waiting for return results
+		if(resultsCallback == undefined || resultsCallback == null){
+			return;
+		}
+		
+		// check at regular intervals for return results	
+		var resultsChecker = function(){
+			if(_root._returnResult != undefined){
+				clearInterval(_root._callbackID);
+				resultsCallback.call(null, _root._returnResult);
+			}
+		};	
+		_root._callbackID = setInterval(resultsChecker, 100);
+	}
+	
+	/** 
+			Called by Flash to indicate to JavaScript that we are ready to have
+			our Flash functions called. Calling loaded()
+			will fire the dojo.flash.loaded() event, so that JavaScript can know that
+			Flash has finished loading and adding its callbacks, and can begin to
+			interact with the Flash file.
+	*/
+	public static function loaded(){
+		//getURL(&quot;javascript:dojo.debug('FLASH:loaded')&quot;);
+		
+		// one more step: see if fscommands are ready to be executed; if not,
+		// set an interval that will keep running until fscommands are ready;
+		// make sure the gateway is loaded as well
+		var execLoaded = function(){
+			if(DojoExternalInterface._fscommandReady == true){
+				clearInterval(_root.loadedInterval);
+				
+				// initialize the small Flash file that helps gateway JS to Flash
+				// calls
+				DojoExternalInterface._initializeFlashRunner();
+			}	
+		};
+		
+		if(_fscommandReady == true){
+			execLoaded();
+		}else{
+			_root.loadedInterval = setInterval(execLoaded, 50);
+		}
+	}
+	
+	/** 
+			Handles and executes a JavaScript to Flash method call. Used by
+			initializeFlashRunner. 
+	*/
+	public static function _handleJSCall(){
+		// get our parameters
+		var numArgs = parseInt(_root._numArgs);
+		var jsArgs = new Array();
+		for(var i = 0; i &lt; numArgs; i++){
+			var currentValue = _root[&quot;_&quot; + i];
+			jsArgs.push(currentValue);
+		}
+		
+		// get our function name
+		var functionName = _root._functionName;
+		
+		// now get the actual instance and method object to execute on,
+		// using our lookup table that was constructed by calls to
+		// addCallback on initialization
+		var instance = _callbacks[&quot;_&quot; + functionName]._instance;
+		var method = _callbacks[&quot;_&quot; + functionName]._method;
+		
+		// execute it
+		var results = method.apply(instance, jsArgs);
+		
+		// return the results
+		_root._returnResult = results;
+	}
+	
+	/** Called by the flash6_gateway.swf to indicate that it is loaded. */
+	public static function _gatewayReady(){
+		for(var i = 0; i &lt; _callbacks.length; i++){
+			fscommand(&quot;addCallback&quot;, _callbacks[i]);
+		}
+		call(&quot;dojo.flash.loaded&quot;);
+	}
+	
+	/** 
+			When JavaScript wants to communicate with Flash it simply sets
+			the Flash variable &quot;_execute&quot; to true; this method creates the
+			internal Movie Clip, called the Flash Runner, that makes this
+			magic happen.
+	*/
+	public static function _initializeFlashRunner(){
+		// figure out where our Flash movie is
+		var swfLoc = DojoExternalInterface.dojoPath + &quot;flash6_gateway.swf&quot;;
+		
+		// load our gateway helper file
+		_root.createEmptyMovieClip(&quot;_flashRunner&quot;, 5000);
+		_root._flashRunner._lockroot = true;
+		_root._flashRunner.loadMovie(swfLoc);
+	}
+	
+	private static function getDojoPath(){
+		var url = _root._url;
+		var start = url.indexOf(&quot;baseRelativePath=&quot;) + &quot;baseRelativePath=&quot;.length;
+		var path = url.substring(start);
+		var end = path.indexOf(&quot;&amp;&quot;);
+		if(end != -1){
+			path = path.substring(0, end);
+		}
+		return path;
+	}
+}
+
+// vim:ts=4:noet:tw=0:

Added: trunk/root/static/magic/src/flash/flash6/flash6_gateway.fla
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/flash/flash6/flash6_gateway.fla
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/root/static/magic/src/flash/flash8/DojoExternalInterface.as
===================================================================
--- trunk/root/static/magic/src/flash/flash8/DojoExternalInterface.as	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/flash/flash8/DojoExternalInterface.as	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,234 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+	A wrapper around Flash 8's ExternalInterface; DojoExternalInterface is needed so that we
+	can do a Flash 6 implementation of ExternalInterface, and be able
+	to support having a single codebase that uses DojoExternalInterface
+	across Flash versions rather than having two seperate source bases,
+	where one uses ExternalInterface and the other uses DojoExternalInterface.
+	
+	DojoExternalInterface class does a variety of optimizations to bypass ExternalInterface's
+	unbelievably bad performance so that we can have good performance
+	on Safari; see the blog post
+	<A HREF="http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html">http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html</A>
+	for details.
+	
+	@author Brad Neuberg, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">bkn3 at columbia.edu</A>
+*/
+import flash.external.ExternalInterface;
+
+class DojoExternalInterface{
+	public static var available:Boolean;
+	public static var dojoPath = &quot;&quot;;
+	
+	private static var flashMethods:Array = new Array();
+	private static var numArgs:Number;
+	private static var argData:Array;
+	private static var resultData = null;
+	
+	public static function initialize(){
+		// extract the dojo base path
+		DojoExternalInterface.dojoPath = DojoExternalInterface.getDojoPath();
+		
+		// see if we need to do an express install
+		var install:ExpressInstall = new ExpressInstall();
+		if(install.needsUpdate){
+			install.init();
+		}
+		
+		// register our callback functions
+		ExternalInterface.addCallback(&quot;startExec&quot;, DojoExternalInterface, startExec);
+		ExternalInterface.addCallback(&quot;setNumberArguments&quot;, DojoExternalInterface,
+																	setNumberArguments);
+		ExternalInterface.addCallback(&quot;chunkArgumentData&quot;, DojoExternalInterface,
+																	chunkArgumentData);
+		ExternalInterface.addCallback(&quot;exec&quot;, DojoExternalInterface, exec);
+		ExternalInterface.addCallback(&quot;getReturnLength&quot;, DojoExternalInterface,
+																	getReturnLength);
+		ExternalInterface.addCallback(&quot;chunkReturnData&quot;, DojoExternalInterface,
+																	chunkReturnData);
+		ExternalInterface.addCallback(&quot;endExec&quot;, DojoExternalInterface, endExec);
+		
+		// set whether communication is available
+		DojoExternalInterface.available = ExternalInterface.available;
+		DojoExternalInterface.call(&quot;loaded&quot;);
+	}
+	
+	public static function addCallback(methodName:String, instance:Object, 
+										 								 method:Function) : Boolean{
+		// register DojoExternalInterface methodName with it's instance
+		DojoExternalInterface.flashMethods[methodName] = instance;
+		
+		// tell JavaScript about DojoExternalInterface new method so we can create a proxy
+		ExternalInterface.call(&quot;dojo.flash.comm._addExternalInterfaceCallback&quot;, 
+													 methodName);
+													 
+		return true;
+	}
+	
+	public static function call(methodName:String,
+								resultsCallback:Function) : Void{
+		// we might have any number of optional arguments, so we have to 
+		// pass them in dynamically; strip out the results callback
+		var parameters = new Array();
+		for(var i = 0; i &lt; arguments.length; i++){
+			if(i != 1){ // skip the callback
+				parameters.push(arguments[i]);
+			}
+		}
+		
+		var results = ExternalInterface.call.apply(ExternalInterface, parameters);
+		
+		// immediately give the results back, since ExternalInterface is
+		// synchronous
+		if(resultsCallback != null &amp;&amp; typeof resultsCallback != &quot;undefined&quot;){
+			resultsCallback.call(null, results);
+		}
+	}
+	
+	/** 
+			Called by Flash to indicate to JavaScript that we are ready to have
+			our Flash functions called. Calling loaded()
+			will fire the dojo.flash.loaded() event, so that JavaScript can know that
+			Flash has finished loading and adding its callbacks, and can begin to
+			interact with the Flash file.
+	*/
+	public static function loaded(){
+		DojoExternalInterface.call(&quot;dojo.flash.loaded&quot;);
+	}
+	
+	public static function startExec():Void{
+		DojoExternalInterface.numArgs = null;
+		DojoExternalInterface.argData = null;
+		DojoExternalInterface.resultData = null;
+	}
+	
+	public static function setNumberArguments(numArgs):Void{
+		DojoExternalInterface.numArgs = numArgs;
+		DojoExternalInterface.argData = new Array(DojoExternalInterface.numArgs);
+	}
+	
+	public static function chunkArgumentData(value, argIndex:Number):Void{
+		//getURL(&quot;javascript:dojo.debug('FLASH: chunkArgumentData, value=&quot;+value+&quot;, argIndex=&quot;+argIndex+&quot;')&quot;);
+		var currentValue = DojoExternalInterface.argData[argIndex];
+		if(currentValue == null || typeof currentValue == &quot;undefined&quot;){
+			DojoExternalInterface.argData[argIndex] = value;
+		}else{
+			DojoExternalInterface.argData[argIndex] += value;
+		}
+	}
+	
+	public static function exec(methodName):Void{
+		// decode all of the arguments that were passed in
+		for(var i = 0; i &lt; DojoExternalInterface.argData.length; i++){
+			DojoExternalInterface.argData[i] = 
+				DojoExternalInterface.decodeData(DojoExternalInterface.argData[i]);
+		}
+		
+		var instance = DojoExternalInterface.flashMethods[methodName];
+		DojoExternalInterface.resultData = instance[methodName].apply(
+																			instance, DojoExternalInterface.argData);
+		// encode the result data
+		DojoExternalInterface.resultData = 
+			DojoExternalInterface.encodeData(DojoExternalInterface.resultData);
+			
+		//getURL(&quot;javascript:dojo.debug('FLASH: encoded result data=&quot;+DojoExternalInterface.resultData+&quot;')&quot;);
+	}
+	
+	public static function getReturnLength():Number{
+	 if(DojoExternalInterface.resultData == null || 
+	 					typeof DojoExternalInterface.resultData == &quot;undefined&quot;){
+	 	return 0;
+	 }
+	 var segments = Math.ceil(DojoExternalInterface.resultData.length / 1024);
+	 return segments;
+	}
+	
+	public static function chunkReturnData(segment:Number):String{
+		var numSegments = DojoExternalInterface.getReturnLength();
+		var startCut = segment * 1024;
+		var endCut = segment * 1024 + 1024;
+		if(segment == (numSegments - 1)){
+			endCut = segment * 1024 + DojoExternalInterface.resultData.length;
+		}
+			
+		var piece = DojoExternalInterface.resultData.substring(startCut, endCut);
+		
+		//getURL(&quot;javascript:dojo.debug('FLASH: chunking return piece=&quot;+piece+&quot;')&quot;);
+		
+		return piece;
+	}
+	
+	public static function endExec():Void{
+	}
+	
+	private static function decodeData(data):String{
+		// we have to use custom encodings for certain characters when passing
+		// them over; for example, passing a backslash over as //// from JavaScript
+		// to Flash doesn't work
+		data = DojoExternalInterface.replaceStr(data, &quot;&amp;custom_backslash;&quot;, &quot;\\&quot;);
+		
+		data = DojoExternalInterface.replaceStr(data, &quot;\\\'&quot;, &quot;\'&quot;);
+		data = DojoExternalInterface.replaceStr(data, &quot;\\\&quot;&quot;, &quot;\&quot;&quot;);
+		
+		return data;
+	}
+	
+	private static function encodeData(data){
+		//getURL(&quot;javascript:dojo.debug('inside flash, data before=&quot;+data+&quot;')&quot;);
+
+		// double encode all entity values, or they will be mis-decoded
+		// by Flash when returned
+		data = DojoExternalInterface.replaceStr(data, &quot;&amp;&quot;, &quot;&amp;&quot;);
+		
+		// certain XMLish characters break Flash's wire serialization for
+		// ExternalInterface; encode these into a custom encoding, rather than
+		// the standard entity encoding, because otherwise we won't be able to
+		// differentiate between our own encoding and any entity characters
+		// that are being used in the string itself
+		data = DojoExternalInterface.replaceStr(data, '&lt;', '&amp;custom_lt;');
+		data = DojoExternalInterface.replaceStr(data, '&gt;', '&amp;custom_gt;');
+		
+		// encode control characters and JavaScript delimiters
+		data = DojoExternalInterface.replaceStr(data, &quot;\n&quot;, &quot;\\n&quot;);
+		data = DojoExternalInterface.replaceStr(data, &quot;\r&quot;, &quot;\\r&quot;);
+		data = DojoExternalInterface.replaceStr(data, &quot;\f&quot;, &quot;\\f&quot;);
+		data = DojoExternalInterface.replaceStr(data, &quot;'&quot;, &quot;\\'&quot;);
+		data = DojoExternalInterface.replaceStr(data, '&quot;', '\&quot;');
+		
+		//getURL(&quot;javascript:dojo.debug('inside flash, data after=&quot;+data+&quot;')&quot;);
+		return data;
+	}
+	
+	/** 
+			Flash ActionScript has no String.replace method or support for
+			Regular Expressions! We roll our own very simple one.
+	*/
+	private static function replaceStr(inputStr:String, replaceThis:String, 
+																		 withThis:String):String {
+		var splitStr = inputStr.split(replaceThis)
+		inputStr = splitStr.join(withThis)
+		return inputStr;
+	}
+	
+	private static function getDojoPath(){
+		var url = _root._url;
+		var start = url.indexOf(&quot;baseRelativePath=&quot;) + &quot;baseRelativePath=&quot;.length;
+		var path = url.substring(start);
+		var end = path.indexOf(&quot;&amp;&quot;);
+		if(end != -1){
+			path = path.substring(0, end);
+		}
+		return path;
+	}
+}
+
+// vim:ts=4:noet:tw=0:

Added: trunk/root/static/magic/src/flash/flash8/ExpressInstall.as
===================================================================
--- trunk/root/static/magic/src/flash/flash8/ExpressInstall.as	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/flash/flash8/ExpressInstall.as	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,81 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+ * Based on the expressinstall.as class created by Geoff Stearns as part
+ * of the FlashObject library.
+ *
+ * Use this file to invoke the Macromedia Flash Player Express Install functionality
+ * This file is intended for use with the FlashObject embed script. You can download FlashObject 
+ * and this file at the following URL: <A HREF="http://blog.deconcept.com/flashobject/">http://blog.deconcept.com/flashobject/</A>
+ *
+ * Usage: 
+ *          var ExpressInstall = new ExpressInstall();
+ *          
+ *          // test to see if install is needed:
+ *          if (ExpressInstall.needsUpdate) { // returns true if update is needed
+ *              ExpressInstall.init(); // starts the update
+ *          }
+ *
+ *	NOTE: Your Flash movie must be at least 214px by 137px in order to use ExpressInstall.
+ *
+ */
+
+class ExpressInstall {
+	public var needsUpdate:Boolean;
+	private var updater:MovieClip;
+	private var hold:MovieClip;
+	
+	public function ExpressInstall(){
+		// does the user need to update?
+		this.needsUpdate = (_root.MMplayerType == undefined) ? false : true;	
+	}
+
+	public function init():Void{
+		this.loadUpdater();
+	}
+
+	public function loadUpdater():Void {
+		System.security.allowDomain(&quot;fpdownload.macromedia.com&quot;);
+
+		// hope that nothing is at a depth of 10000000, you can change this depth if needed, but you want
+		// it to be on top of your content if you have any stuff on the first frame
+		this.updater = _root.createEmptyMovieClip(&quot;expressInstallHolder&quot;, 10000000);
+
+		// register the callback so we know if they cancel or there is an error
+		var _self = this;
+		this.updater.installStatus = _self.onInstallStatus;
+		this.hold = this.updater.createEmptyMovieClip(&quot;hold&quot;, 1);
+
+		// can't use movieClipLoader because it has to work in 6.0.65
+		this.updater.onEnterFrame = function():Void {
+			if(typeof this.hold.startUpdate == 'function'){
+				_self.initUpdater();
+				this.onEnterFrame = null;
+			}
+		}
+
+		var cacheBuster:Number = Math.random();
+
+		this.hold.loadMovie(&quot;<A HREF="http://fpdownload.macromedia.com/pub/flashplayer/">http://fpdownload.macromedia.com/pub/flashplayer/</A>&quot;
+												+&quot;update/current/swf/autoUpdater.swf?&quot;+ cacheBuster);
+	}
+
+	private function initUpdater():Void{
+		this.hold.redirectURL = _root.MMredirectURL;
+		this.hold.MMplayerType = _root.MMplayerType;
+		this.hold.MMdoctitle = _root.MMdoctitle;
+		this.hold.startUpdate();
+	}
+
+	public function onInstallStatus(msg):Void{
+		getURL(&quot;javascript:dojo.flash.install._onInstallStatus('&quot;+msg+&quot;')&quot;);
+	}
+}

Added: trunk/root/static/magic/src/flash.js
===================================================================
--- trunk/root/static/magic/src/flash.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/flash.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,1244 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.flash&quot;);
+
+dojo.require(&quot;dojo.string.*&quot;);
+dojo.require(&quot;dojo.uri.*&quot;);
+
+
+/** 
+		The goal of dojo.flash is to make it easy to extend Flash's capabilities
+		into an AJAX/DHTML environment. Robust, performant, reliable 
+		JavaScript/Flash communication is harder than most realize when they
+		delve into the topic, especially if you want it
+		to work on Internet Explorer, Firefox, and Safari, and to be able to
+		push around hundreds of K of information quickly. Dojo.flash makes it
+		possible to support these platforms; you have to jump through a few
+		hoops to get its capabilites, but if you are a library writer 
+		who wants to bring Flash's storage or streaming sockets ability into
+		DHTML, for example, then dojo.flash is perfect for you.
+  
+		Dojo.flash provides an easy object for interacting with the Flash plugin. 
+		This object provides methods to determine the current version of the Flash
+		plugin (dojo.flash.info); execute Flash instance methods 
+		independent of the Flash version
+		being used (dojo.flash.comm); write out the necessary markup to 
+		dynamically insert a Flash object into the page (dojo.flash.Embed; and 
+		do dynamic installation and upgrading of the current Flash plugin in 
+		use (dojo.flash.Install).
+		
+		To use dojo.flash, you must first wait until Flash is finished loading 
+		and initializing before you attempt communication or interaction. 
+		To know when Flash is finished use dojo.event.connect:
+		
+		dojo.event.connect(dojo.flash, &quot;loaded&quot;, myInstance, &quot;myCallback&quot;);
+		
+		Then, while the page is still loading provide the file name
+		and the major version of Flash that will be used for Flash/JavaScript
+		communication (see &quot;Flash Communication&quot; below for information on the 
+		different kinds of Flash/JavaScript communication supported and how they 
+		depend on the version of Flash installed):
+		
+		dojo.flash.setSwf({flash6: &quot;src/storage/storage_flash6.swf&quot;,
+											 flash8: &quot;src/storage/storage_flash8.swf&quot;});
+		
+		This will cause dojo.flash to pick the best way of communicating
+		between Flash and JavaScript based on the platform.
+		
+		If no SWF files are specified, then Flash is not initialized.
+		
+		Your Flash must use DojoExternalInterface to expose Flash methods and
+		to call JavaScript; see &quot;Flash Communication&quot; below for details.
+		
+		setSwf can take an optional 'visible' attribute to control whether
+		the Flash object is visible or not on the page; the default is visible:
+		
+		dojo.flash.setSwf({flash6: &quot;src/storage/storage_flash6.swf&quot;,
+											 flash8: &quot;src/storage/storage_flash8.swf&quot;,
+											 visible: false});
+		
+		Once finished, you can query Flash version information:
+		
+		dojo.flash.info.version
+		
+		Or can communicate with Flash methods that were exposed:
+		
+		var results = dojo.flash.comm.sayHello(&quot;Some Message&quot;);
+		
+		Only string values are currently supported for both arguments and
+		for return results. Everything will be cast to a string on both
+		the JavaScript and Flash sides.
+		
+		-------------------
+		Flash Communication
+		-------------------
+		
+		dojo.flash allows Flash/JavaScript communication in 
+		a way that can pass large amounts of data back and forth reliably and
+		very fast. The dojo.flash
+		framework encapsulates the specific way in which this communication occurs,
+		presenting a common interface to JavaScript irrespective of the underlying
+		Flash version.
+		
+		There are currently three major ways to do Flash/JavaScript communication
+		in the Flash community:
+		
+		1) Flash 6+ - Uses Flash methods, such as SetVariable and TCallLabel,
+		and the fscommand handler to do communication. Strengths: Very fast,
+		mature, and can send extremely large amounts of data; can do
+		synchronous method calls. Problems: Does not work on Safari; works on 
+		Firefox/Mac OS X only if Flash 8 plugin is installed; cryptic to work with.
+		
+		2) Flash 8+ - Uses ExternalInterface, which provides a way for Flash
+		methods to register themselves for callbacks from JavaScript, and a way
+		for Flash to call JavaScript. Strengths: Works on Safari; elegant to
+		work with; can do synchronous method calls. Problems: Extremely buggy 
+		(fails if there are new lines in the data, for example); performance
+		degrades drastically in O(n^2) time as data grows; locks up the browser while
+		it is communicating; does not work in Internet Explorer if Flash
+		object is dynamically added to page with document.writeln, DOM methods,
+		or innerHTML.
+		
+		3) Flash 6+ - Uses two seperate Flash applets, one that we 
+		create over and over, passing input data into it using the PARAM tag, 
+		which then uses a Flash LocalConnection to pass the data to the main Flash
+		applet; communication back to Flash is accomplished using a getURL
+		call with a javascript protocol handler, such as &quot;javascript:myMethod()&quot;.
+		Strengths: the most cross browser, cross platform pre-Flash 8 method
+		of Flash communication known; works on Safari. Problems: Timing issues;
+		clunky and complicated; slow; can only send very small amounts of
+		data (several K); all method calls are asynchronous.
+		
+		dojo.flash.comm uses only the first two methods. This framework
+		was created primarily for dojo.storage, which needs to pass very large
+		amounts of data synchronously and reliably across the Flash/JavaScript
+		boundary. We use the first method, the Flash 6 method, on all platforms
+		that support it, while using the Flash 8 ExternalInterface method
+		only on Safari with some special code to help correct ExternalInterface's
+		bugs.
+		
+		Since dojo.flash needs to have two versions of the Flash
+		file it wants to generate, a Flash 6 and a Flash 8 version to gain
+		true cross-browser compatibility, several tools are provided to ease
+		development on the Flash side.
+		
+		In your Flash file, if you want to expose Flash methods that can be
+		called, use the DojoExternalInterface class to register methods. This
+		class is an exact API clone of the standard ExternalInterface class, but
+		can work in Flash 6+ browsers. Under the covers it uses the best
+		mechanism to do communication:
+		
+		class HelloWorld{
+			function HelloWorld(){
+				// Initialize the DojoExternalInterface class
+				DojoExternalInterface.initialize();
+				
+				// Expose your methods
+				DojoExternalInterface.addCallback(&quot;sayHello&quot;, this, this.sayHello);
+				
+				// Tell JavaScript that you are ready to have method calls
+				DojoExternalInterface.loaded();
+				
+				// Call some JavaScript
+				var resultsReady = function(results){
+					trace(&quot;Received the following results from JavaScript: &quot; + results);
+				}
+				DojoExternalInterface.call(&quot;someJavaScriptMethod&quot;, resultsReady, 
+																	 someParameter);
+			}
+			
+			function sayHello(){ ... }
+			
+			static main(){ ... }
+		}
+		
+		DojoExternalInterface adds two new functions to the ExternalInterface
+		API: initialize() and loaded(). initialize() must be called before
+		any addCallback() or call() methods are run, and loaded() must be
+		called after you are finished adding your callbacks. Calling loaded()
+		will fire the dojo.flash.loaded() event, so that JavaScript can know that
+		Flash has finished loading and adding its callbacks, and can begin to
+		interact with the Flash file.
+		
+		To generate your SWF files, use the ant task
+		&quot;buildFlash&quot;. You must have the open source Motion Twin ActionScript 
+		compiler (mtasc) installed and in your path to use the &quot;buildFlash&quot;
+		ant task; download and install mtasc from <A HREF="http://www.mtasc.org/.">http://www.mtasc.org/.</A>
+		
+		
+		
+		buildFlash usage:
+		
+		ant buildFlash -Ddojo.flash.file=../tests/flash/HelloWorld.as
+		
+		where &quot;dojo.flash.file&quot; is the relative path to your Flash 
+		ActionScript file.
+		
+		This will generate two SWF files, one ending in _flash6.swf and the other
+		ending in _flash8.swf in the same directory as your ActionScript method:
+		
+		HelloWorld_flash6.swf
+		HelloWorld_flash8.swf
+		
+		Initialize dojo.flash with the filename and Flash communication version to
+		use during page load; see the documentation for dojo.flash for details:
+		
+		dojo.flash.setSwf({flash6: &quot;tests/flash/HelloWorld_flash6.swf&quot;,
+											 flash8: &quot;tests/flash/HelloWorld_flash8.swf&quot;});
+		
+		Now, your Flash methods can be called from JavaScript as if they are native
+		Flash methods, mirrored exactly on the JavaScript side:
+		
+		dojo.flash.comm.sayHello();
+		
+		Only Strings are supported being passed back and forth currently.
+		
+		JavaScript to Flash communication is synchronous; i.e., results are returned
+		directly from the method call:
+		
+		var results = dojo.flash.comm.sayHello();
+		
+		Flash to JavaScript communication is asynchronous due to limitations in
+		the underlying technologies; you must use a results callback to handle
+		results returned by JavaScript in your Flash AS files:
+		
+		var resultsReady = function(results){
+			trace(&quot;Received the following results from JavaScript: &quot; + results);
+		}
+		DojoExternalInterface.call(&quot;someJavaScriptMethod&quot;, resultsReady);
+		
+		
+		
+		-------------------
+		Notes
+		-------------------
+		
+		If you have both Flash 6 and Flash 8 versions of your file:
+		
+		dojo.flash.setSwf({flash6: &quot;tests/flash/HelloWorld_flash6.swf&quot;,
+											 flash8: &quot;tests/flash/HelloWorld_flash8.swf&quot;});
+											 
+		but want to force the browser to use a certain version of Flash for
+		all platforms (for testing, for example), use the djConfig
+		variable 'forceFlashComm' with the version number to force:
+		
+		var djConfig = { forceFlashComm: 6 };
+		
+		Two values are currently supported, 6 and 8, for the two styles of
+		communication described above. Just because you force dojo.flash
+		to use a particular communication style is no guarantee that it will
+		work; for example, Flash 8 communication doesn't work in Internet
+		Explorer due to bugs in Flash, and Flash 6 communication does not work
+		in Safari. It is best to let dojo.flash determine the best communication
+		mechanism, and to use the value above only for debugging the dojo.flash
+		framework itself.
+		
+		Also note that dojo.flash can currently only work with one Flash object
+		on the page; it and the API do not yet support multiple Flash objects on
+		the same page.
+		
+		We use some special tricks to get decent, linear performance
+		out of Flash 8's ExternalInterface on Safari; see the blog
+		post 
+		<A HREF="http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html">http://codinginparadise.org/weblog/2006/02/how-to-speed-up-flash-8s.html</A>
+		for details.
+		
+		Your code can detect whether the Flash player is installing or having
+		its version revved in two ways. First, if dojo.flash detects that
+		Flash installation needs to occur, it sets dojo.flash.info.installing
+		to true. Second, you can detect if installation is necessary with the
+		following callback:
+		
+		dojo.event.connect(dojo.flash, &quot;installing&quot;, myInstance, &quot;myCallback&quot;);
+		
+		You can use this callback to delay further actions that might need Flash;
+		when installation is finished the full page will be refreshed and the
+		user will be placed back on your page with Flash installed.
+		
+		Two utility methods exist if you want to add loading and installing
+		listeners without creating dependencies on dojo.event; these are
+		'addLoadingListener' and 'addInstallingListener'.
+		
+		-------------------
+		Todo/Known Issues
+		-------------------
+
+		There are several tasks I was not able to do, or did not need to fix
+		to get dojo.storage out:		
+		
+		* When using Flash 8 communication, Flash method calls to JavaScript
+		are not working properly; serialization might also be broken for certain
+		invalid characters when it is Flash invoking JavaScript methods.
+		The Flash side needs to have more sophisticated serialization/
+		deserialization mechanisms like JavaScript currently has. The
+		test_flash2.html unit tests should also be updated to have much more
+		sophisticated Flash to JavaScript unit tests, including large
+		amounts of data.
+		
+		* On Internet Explorer, after doing a basic install, the page is
+		not refreshed or does not detect that Flash is now available. The way
+		to fix this is to create a custom small Flash file that is pointed to
+		during installation; when it is finished loading, it does a callback
+		that says that Flash installation is complete on IE, and we can proceed
+		to initialize the dojo.flash subsystem.
+		
+		@author Brad Neuberg, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">bkn3 at columbia.edu</A>
+*/
+
+dojo.flash = {
+	flash6_version: null,
+	flash8_version: null,
+	ready: false,
+	_visible: true,
+	_loadedListeners: new Array(),
+	_installingListeners: new Array(),
+	
+	/** Sets the SWF files and versions we are using. */
+	setSwf: function(fileInfo){
+		//dojo.debug(&quot;setSwf&quot;);
+		if(fileInfo == null || dojo.lang.isUndefined(fileInfo)){
+			return;
+		}
+		
+		if(fileInfo.flash6 != null &amp;&amp; !dojo.lang.isUndefined(fileInfo.flash6)){
+			this.flash6_version = fileInfo.flash6;
+		}
+		
+		if(fileInfo.flash8 != null &amp;&amp; !dojo.lang.isUndefined(fileInfo.flash8)){
+			this.flash8_version = fileInfo.flash8;
+		}
+		
+		if(!dojo.lang.isUndefined(fileInfo.visible)){
+			this._visible = fileInfo.visible;
+		}
+		
+		// initialize ourselves		
+		this._initialize();
+	},
+	
+	/** Returns whether we are using Flash 6 for communication on this platform. */
+	useFlash6: function(){
+		if(this.flash6_version == null){
+			return false;
+		}else if (this.flash6_version != null &amp;&amp; dojo.flash.info.commVersion == 6){
+			// if we have a flash 6 version of this SWF, and this browser supports 
+			// communicating using Flash 6 features...
+			return true;
+		}else{
+			return false;
+		}
+	},
+	
+	/** Returns whether we are using Flash 8 for communication on this platform. */
+	useFlash8: function(){
+		if(this.flash8_version == null){
+			return false;
+		}else if (this.flash8_version != null &amp;&amp; dojo.flash.info.commVersion == 8){
+			// if we have a flash 8 version of this SWF, and this browser supports
+			// communicating using Flash 8 features...
+			return true;
+		}else{
+			return false;
+		}
+	},
+	
+	/** Adds a listener to know when Flash is finished loading. 
+			Useful if you don't want a dependency on dojo.event. */
+	addLoadedListener: function(listener){
+		this._loadedListeners.push(listener);
+	},
+
+	/** Adds a listener to know if Flash is being installed. 
+			Useful if you don't want a dependency on dojo.event. */
+	addInstallingListener: function(listener){
+		this._installingListeners.push(listener);
+	},	
+	
+	/** 
+			A callback when the Flash subsystem is finished loading and can be
+			worked with. To be notified when Flash is finished loading, connect
+			your callback to this method using the following:
+			
+			dojo.event.connect(dojo.flash, &quot;loaded&quot;, myInstance, &quot;myCallback&quot;);
+	*/
+	loaded: function(){
+		//dojo.debug(&quot;dojo.flash.loaded&quot;);
+		dojo.flash.ready = true;
+		if(dojo.flash._loadedListeners.length &gt; 0){
+			for(var i = 0;i &lt; dojo.flash._loadedListeners.length; i++){
+				dojo.flash._loadedListeners[i].call(null);
+			}
+		}
+	},
+	
+	/** 
+			A callback to know if Flash is currently being installed or
+			having its version revved. To be notified if Flash is installing, connect
+			your callback to this method using the following:
+			
+			dojo.event.connect(dojo.flash, &quot;installing&quot;, myInstance, &quot;myCallback&quot;);
+	*/
+	installing: function(){
+	 //dojo.debug(&quot;installing&quot;);
+	 if(dojo.flash._installingListeners.length &gt; 0){
+			for(var i = 0; i &lt; dojo.flash._installingListeners.length; i++){
+				dojo.flash._installingListeners[i].call(null);
+			}
+		}
+	},
+	
+	/** Initializes dojo.flash. */
+	_initialize: function(){
+		//dojo.debug(&quot;dojo.flash._initialize&quot;);
+		// see if we need to rev or install Flash on this platform
+		var installer = new dojo.flash.Install();
+		dojo.flash.installer = installer;
+
+		if(installer.needed() == true){		
+			installer.install();
+		}else{
+			//dojo.debug(&quot;Writing object out&quot;);
+			// write the flash object into the page
+			dojo.flash.obj = new dojo.flash.Embed(this._visible);
+			dojo.flash.obj.write(dojo.flash.info.commVersion);
+			
+			// initialize the way we do Flash/JavaScript communication
+			dojo.flash.comm = new dojo.flash.Communicator();
+		}
+	}
+};
+
+
+/** 
+		A class that helps us determine whether Flash is available,
+		it's major and minor versions, and what Flash version features should
+		be used for Flash/JavaScript communication. Parts of this code
+		are adapted from the automatic Flash plugin detection code autogenerated 
+		by the Macromedia Flash 8 authoring environment. 
+		
+		An instance of this class can be accessed on dojo.flash.info after
+		the page is finished loading.
+		
+		This constructor must be called before the page is finished loading. 
+*/
+dojo.flash.Info = function(){
+	// Visual basic helper required to detect Flash Player ActiveX control 
+	// version information on Internet Explorer
+	if(dojo.render.html.ie){
+		document.writeln('&lt;script language=&quot;VBScript&quot; type=&quot;text/vbscript&quot;\&gt;');
+		document.writeln('Function VBGetSwfVer(i)');
+		document.writeln('  on error resume next');
+		document.writeln('  Dim swControl, swVersion');
+		document.writeln('  swVersion = 0');
+		document.writeln('  set swControl = CreateObject(&quot;ShockwaveFlash.ShockwaveFlash.&quot; + CStr(i))');
+		document.writeln('  if (IsObject(swControl)) then');
+		document.writeln('    swVersion = swControl.GetVariable(&quot;$version&quot;)');
+		document.writeln('  end if');
+		document.writeln('  VBGetSwfVer = swVersion');
+		document.writeln('End Function');
+		document.writeln('&lt;/script\&gt;');
+	}
+	
+	this._detectVersion();
+	this._detectCommunicationVersion();
+}
+
+dojo.flash.Info.prototype = {
+	/** The full version string, such as &quot;8r22&quot;. */
+	version: -1,
+	
+	/** 
+			The major, minor, and revisions of the plugin. For example, if the
+			plugin is 8r22, then the major version is 8, the minor version is 0,
+			and the revision is 22. 
+	*/
+	versionMajor: -1,
+	versionMinor: -1,
+	versionRevision: -1,
+	
+	/** Whether this platform has Flash already installed. */
+	capable: false,
+	
+	/** 
+			The major version number for how our Flash and JavaScript communicate.
+			This can currently be the following values:
+			6 - We use a combination of the Flash plugin methods, such as SetVariable
+			and TCallLabel, along with fscommands, to do communication.
+			8 - We use the ExternalInterface API. 
+			-1 - For some reason neither method is supported, and no communication
+			is possible. 
+	*/
+	commVersion: 6,
+	
+	/** Set if we are in the middle of a Flash installation session. */
+	installing: false,
+	
+	/** 
+			Asserts that this environment has the given major, minor, and revision
+			numbers for the Flash player. Returns true if the player is equal
+			or above the given version, false otherwise.
+			
+			Example: To test for Flash Player 7r14:
+			
+			dojo.flash.info.isVersionOrAbove(7, 0, 14)
+	*/
+	isVersionOrAbove: function(reqMajorVer, reqMinorVer, reqVer){
+		// make the revision a decimal (i.e. transform revision 14 into
+		// 0.14
+		reqVer = parseFloat(&quot;.&quot; + reqVer);
+		
+		if(this.versionMajor &gt;= reqMajorVer &amp;&amp; this.versionMinor &gt;= reqMinorVer
+			 &amp;&amp; this.versionRevision &gt;= reqVer){
+			return true;
+		}else{
+			return false;
+		}
+	},
+	
+	_detectVersion: function(){
+		var versionStr;
+		
+		// loop backwards through the versions until we find the newest version	
+		for(var testVersion = 25; testVersion &gt; 0; testVersion--){
+			if(dojo.render.html.ie){
+				versionStr = VBGetSwfVer(testVersion);
+			}else{
+				versionStr = this._JSFlashInfo(testVersion);		
+			}
+				
+			if(versionStr == -1 ){
+				this.capable = false; 
+				return;
+			}else if(versionStr != 0){
+				var versionArray;
+				if(dojo.render.html.ie){
+					var tempArray = versionStr.split(&quot; &quot;);
+					var tempString = tempArray[1];
+					versionArray = tempString.split(&quot;,&quot;);
+				}else{
+					versionArray = versionStr.split(&quot;.&quot;);
+				}
+					
+				this.versionMajor = versionArray[0];
+				this.versionMinor = versionArray[1];
+				this.versionRevision = versionArray[2];
+				
+				// 7.0r24 == 7.24
+				var versionString = this.versionMajor + &quot;.&quot; + this.versionRevision;
+				this.version = parseFloat(versionString);
+				
+				this.capable = true;
+				
+				break;
+			}
+		}
+	},
+	
+	/** 
+			JavaScript helper required to detect Flash Player PlugIn version 
+			information. Internet Explorer uses a corresponding Visual Basic
+			version to interact with the Flash ActiveX control. 
+	*/
+	_JSFlashInfo: function(testVersion){
+		// NS/Opera version &gt;= 3 check for Flash plugin in plugin array
+		if(navigator.plugins != null &amp;&amp; navigator.plugins.length &gt; 0){
+			if(navigator.plugins[&quot;Shockwave Flash 2.0&quot;] || 
+				 navigator.plugins[&quot;Shockwave Flash&quot;]){
+				var swVer2 = navigator.plugins[&quot;Shockwave Flash 2.0&quot;] ? &quot; 2.0&quot; : &quot;&quot;;
+				var flashDescription = navigator.plugins[&quot;Shockwave Flash&quot; + swVer2].description;
+				var descArray = flashDescription.split(&quot; &quot;);
+				var tempArrayMajor = descArray[2].split(&quot;.&quot;);
+				var versionMajor = tempArrayMajor[0];
+				var versionMinor = tempArrayMajor[1];
+				if(descArray[3] != &quot;&quot;){
+					var tempArrayMinor = descArray[3].split(&quot;r&quot;);
+				}else{
+					var tempArrayMinor = descArray[4].split(&quot;r&quot;);
+				}
+				var versionRevision = tempArrayMinor[1] &gt; 0 ? tempArrayMinor[1] : 0;
+				var version = versionMajor + &quot;.&quot; + versionMinor + &quot;.&quot; 
+											+ versionRevision;
+											
+				return version;
+			}
+		}
+		
+		return -1;
+	},
+	
+	/** 
+			Detects the mechanisms that should be used for Flash/JavaScript 
+			communication, setting 'commVersion' to either 6 or 8. If the value is
+			6, we use Flash Plugin 6+ features, such as GetVariable, TCallLabel,
+			and fscommand, to do Flash/JavaScript communication; if the value is
+			8, we use the ExternalInterface API for communication. 
+	*/
+	_detectCommunicationVersion: function(){
+		if(this.capable == false){
+			this.commVersion = null;
+			return;
+		}
+		
+		// detect if the user has over-ridden the default flash version
+		if (typeof djConfig[&quot;forceFlashComm&quot;] != &quot;undefined&quot; &amp;&amp;
+				typeof djConfig[&quot;forceFlashComm&quot;] != null){
+			this.commVersion = djConfig[&quot;forceFlashComm&quot;];
+			return;
+		}
+		
+		// we prefer Flash 6 features over Flash 8, because they are much faster
+		// and much less buggy
+		
+		// at this point, we don't have a flash file to detect features on,
+		// so we need to instead look at the browser environment we are in
+		if(dojo.render.html.safari == true || dojo.render.html.opera == true){
+			this.commVersion = 8;
+		}else{
+			this.commVersion = 6;
+		}
+	}
+};
+
+/** A class that is used to write out the Flash object into the page. */
+dojo.flash.Embed = function(visible){
+	this._visible = visible;
+}
+
+dojo.flash.Embed.prototype = {
+	/** 
+			The width of this Flash applet. The default is the minimal width
+			necessary to show the Flash settings dialog. 
+	*/
+	width: 215,
+	
+	/** 
+			The height of this Flash applet. The default is the minimal height
+			necessary to show the Flash settings dialog. 
+	*/
+	height: 138,
+	
+	/** The id of the Flash object. */
+	id: &quot;flashObject&quot;,
+	
+	/** Controls whether this is a visible Flash applet or not. */
+	_visible: true,
+			
+	/** 
+			Writes the Flash into the page. This must be called before the page
+			is finished loading. 
+			@param flashVer The Flash version to write.
+			@param doExpressInstall Whether to write out Express Install
+			information. Optional value; defaults to false.
+	*/
+	write: function(flashVer, doExpressInstall){
+		//dojo.debug(&quot;write&quot;);
+		if(dojo.lang.isUndefined(doExpressInstall)){
+			doExpressInstall = false;
+		}
+		
+		// determine our container div's styling
+		var containerStyle = new dojo.string.Builder();
+		containerStyle.append(&quot;width: &quot; + this.width + &quot;px; &quot;);
+		containerStyle.append(&quot;height: &quot; + this.height + &quot;px; &quot;);
+		if(this._visible == false){
+			containerStyle.append(&quot;position: absolute; &quot;);
+			containerStyle.append(&quot;z-index: 10000; &quot;);
+			containerStyle.append(&quot;top: -1000px; &quot;);
+			containerStyle.append(&quot;left: -1000px; &quot;);
+		}
+		containerStyle = containerStyle.toString();
+
+		// figure out the SWF file to get and how to write out the correct HTML
+		// for this Flash version
+		var objectHTML;
+		var swfloc;
+		// Flash 6
+		if(flashVer == 6){
+			swfloc = dojo.flash.flash6_version;
+			var dojoPath = djConfig.baseRelativePath;
+			swfloc = swfloc + &quot;?baseRelativePath=&quot; + escape(dojoPath);
+			
+			objectHTML = 
+						  '&lt;embed id=&quot;' + this.id + '&quot; src=&quot;' + swfloc + '&quot; '
+						+ '    quality=&quot;high&quot; bgcolor=&quot;#ffffff&quot; '
+						+ '    width=&quot;' + this.width + '&quot; height=&quot;' + this.height + '&quot; '
+						+ '    name=&quot;' + this.id + '&quot; '
+						+ '    align=&quot;middle&quot; allowScriptAccess=&quot;sameDomain&quot; '
+						+ '    type=&quot;application/x-shockwave-flash&quot; swLiveConnect=&quot;true&quot; '
+						+ '    pluginspage=&quot;<A HREF="http://www.macromedia.com/go/getflashplayer">http://www.macromedia.com/go/getflashplayer</A>&quot;&gt;';
+		}else{ // Flash 8
+			swfloc = dojo.flash.flash8_version;
+			var swflocObject = swfloc;
+			var swflocEmbed = swfloc;
+			var dojoPath = djConfig.baseRelativePath;
+			if(doExpressInstall){
+				// the location to redirect to after installing
+				var redirectURL = escape(window.location);
+				document.title = document.title.slice(0, 47) + &quot; - Flash Player Installation&quot;;
+				var docTitle = escape(document.title);
+				swflocObject += &quot;?MMredirectURL=&quot; + redirectURL
+				                + &quot;&amp;MMplayerType=ActiveX&quot;
+				                + &quot;&amp;MMdoctitle=&quot; + docTitle
+								+ &quot;&amp;baseRelativePath=&quot; + escape(dojoPath);
+				swflocEmbed += &quot;?MMredirectURL=&quot; + redirectURL 
+								+ &quot;&amp;MMplayerType=PlugIn&quot;
+								+ &quot;&amp;baseRelativePath=&quot; + escape(dojoPath);
+			}
+			
+			objectHTML =
+				'&lt;object classid=&quot;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&quot; '
+				  + 'codebase=&quot;<A HREF="http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0">http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0</A>&quot; '
+				  + 'width=&quot;' + this.width + '&quot; '
+				  + 'height=&quot;' + this.height + '&quot; '
+				  + 'id=&quot;' + this.id + '&quot; '
+				  + 'align=&quot;middle&quot;&gt; '
+				  + '&lt;param name=&quot;allowScriptAccess&quot; value=&quot;sameDomain&quot; /&gt; '
+				  + '&lt;param name=&quot;movie&quot; value=&quot;' + swflocObject + '&quot; /&gt; '
+				  + '&lt;param name=&quot;quality&quot; value=&quot;high&quot; /&gt; '
+				  + '&lt;param name=&quot;bgcolor&quot; value=&quot;#ffffff&quot; /&gt; '
+				  + '&lt;embed src=&quot;' + swflocEmbed + '&quot; '
+				  + 'quality=&quot;high&quot; '
+				  + 'bgcolor=&quot;#ffffff&quot; '
+				  + 'width=&quot;' + this.width + '&quot; '
+				  + 'height=&quot;' + this.height + '&quot; '
+				  + 'id=&quot;' + this.id + '&quot; '
+				  + 'name=&quot;' + this.id + '&quot; '
+				  + 'swLiveConnect=&quot;true&quot; '
+				  + 'align=&quot;middle&quot; '
+				  + 'allowScriptAccess=&quot;sameDomain&quot; '
+				  + 'type=&quot;application/x-shockwave-flash&quot; '+ &quot;&amp;baseRelativePath=&quot; + escape(dojoPath);
+				  + 'pluginspage=&quot;<A HREF="http://www.macromedia.com/go/getflashplayer">http://www.macromedia.com/go/getflashplayer</A>&quot; /&gt;'
+				+ '&lt;/object&gt;';
+		}
+
+		// now write everything out
+		objectHTML = '&lt;div id=&quot;' + this.id + 'Container&quot; style=&quot;' + containerStyle + '&quot;&gt; '
+						+ objectHTML
+					 + '&lt;/div&gt;';
+		document.writeln(objectHTML);
+	},  
+	
+	/** Gets the Flash object DOM node. */
+	get: function(){
+		//return (dojo.render.html.ie) ? window[this.id] : document[this.id];
+		
+		// more robust way to get Flash object; version above can break
+		// communication on IE sometimes
+		return document.getElementById(this.id);
+	},
+	
+	/** Sets the visibility of this Flash object. */
+	setVisible: function(visible){
+		var container = dojo.byId(this.id + &quot;Container&quot;);
+		if(visible == true){
+			container.style.visibility = &quot;visible&quot;;
+		}else{
+			container.style.position = &quot;absolute&quot;;
+			container.style.x = &quot;-1000px&quot;;
+			container.style.y = &quot;-1000px&quot;;
+			container.style.visibility = &quot;hidden&quot;;
+		}
+	},
+	
+	/** Centers the flash applet on the page. */
+	center: function(){
+		// FIXME: replace this with Dojo's centering code rather than our own
+		// We want to center the Flash applet vertically and horizontally
+		var elementWidth = this.width;
+		var elementHeight = this.height;
+    
+		// get the browser width and height; the code below
+		// works in IE and Firefox in compatibility, non-strict
+		// mode
+		var browserWidth = document.body.clientWidth;
+		var browserHeight = document.body.clientHeight;
+    
+		// in Firefox if we are in standards compliant mode
+		// (with a strict doctype), then the browser width
+		// and height have to be computed from the root level
+		// HTML element not the BODY element
+		if(!dojo.render.html.ie &amp;&amp; document.compatMode == &quot;CSS1Compat&quot;){
+			browserWidth = document.body.parentNode.clientWidth;
+			browserHeight = document.body.parentNode.clientHeight;
+		}else if(dojo.render.html.ie &amp;&amp; document.compatMode == &quot;CSS1Compat&quot;){
+			// IE 6 in standards compliant mode has to be calculated
+			// differently
+			browserWidth = document.documentElement.clientWidth;
+			browserHeight = document.documentElement.clientHeight;
+		}else if(dojo.render.html.safari){ // Safari works different
+			browserHeight = self.innerHeight;
+		}
+    
+		// get where we are scrolled to in the document
+		// the code below works in FireFox
+		var scrolledByWidth = window.scrollX;
+		var scrolledByHeight = window.scrollY;
+		// compute these values differently for IE;
+		// IE has two possibilities; it is either in standards
+		// compatibility mode or it is not
+		if(typeof scrolledByWidth == &quot;undefined&quot;){
+			if(document.compatMode == &quot;CSS1Compat&quot;){ // standards mode
+				scrolledByWidth = document.documentElement.scrollLeft;
+				scrolledByHeight = document.documentElement.scrollTop;
+			}else{ // Pre IE6 non-standards mode
+				scrolledByWidth = document.body.scrollLeft;
+				scrolledByHeight = document.body.scrollTop;
+			}
+		}
+
+		// compute the centered position    
+		var x = scrolledByWidth + (browserWidth - elementWidth) / 2;
+		var y = scrolledByHeight + (browserHeight - elementHeight) / 2; 
+
+		// set the centered position
+		var container = dojo.byId(this.id + &quot;Container&quot;);
+		container.style.top = y + &quot;px&quot;;
+		container.style.left = x + &quot;px&quot;;
+	}
+};
+
+
+/** 
+		A class that is used to communicate between Flash and JavaScript in 
+		a way that can pass large amounts of data back and forth reliably,
+		very fast, and with synchronous method calls. This class encapsulates the 
+		specific way in which this communication occurs,
+		presenting a common interface to JavaScript irrespective of the underlying
+		Flash version.
+*/
+dojo.flash.Communicator = function(){
+	if(dojo.flash.useFlash6()){
+		this._writeFlash6();
+	}else if (dojo.flash.useFlash8()){
+		this._writeFlash8();
+	}
+}
+
+dojo.flash.Communicator.prototype = {
+	_writeFlash6: function(){
+		var id = dojo.flash.obj.id;
+		
+		// global function needed for Flash 6 callback;
+		// we write it out as a script tag because the VBScript hook for IE
+		// callbacks does not work properly if this function is evalled() from
+		// within the Dojo system
+		document.writeln('&lt;script language=&quot;JavaScript&quot;&gt;');
+		document.writeln('  function ' + id + '_DoFSCommand(command, args){ ');
+		document.writeln('    dojo.flash.comm._handleFSCommand(command, args); ');
+		document.writeln('}');
+		document.writeln('&lt;/script&gt;');
+		
+		// hook for Internet Explorer to receive FSCommands from Flash
+		if(dojo.render.html.ie){
+			document.writeln('&lt;SCRIPT LANGUAGE=VBScript\&gt; ');
+			document.writeln('on error resume next ');
+			document.writeln('Sub ' + id + '_FSCommand(ByVal command, ByVal args)');
+			document.writeln(' call ' + id + '_DoFSCommand(command, args)');
+			document.writeln('end sub');
+			document.writeln('&lt;/SCRIPT\&gt; ');
+		}
+	},
+	
+	_writeFlash8: function(){
+		// nothing needs to be written out for Flash 8 communication; 
+		// happens automatically
+	},
+	
+	/** Flash 6 communication. */
+	
+	/** Handles fscommand's from Flash to JavaScript. Flash 6 communication. */
+	_handleFSCommand: function(command, args){
+		//dojo.debug(&quot;fscommand, command=&quot;+command+&quot;, args=&quot;+args);
+		// Flash 8 on Mac/Firefox precedes all commands with the string &quot;FSCommand:&quot;;
+		// strip it off if it is present
+		if(command != null &amp;&amp; !dojo.lang.isUndefined(command)
+			&amp;&amp; /^FSCommand:(.*)/.test(command) == true){
+			command = command.match(/^FSCommand:(.*)/)[1];
+		}
+		 
+		if(command == &quot;addCallback&quot;){ // add Flash method for JavaScript callback
+			this._fscommandAddCallback(command, args);
+		}else if(command == &quot;call&quot;){ // Flash to JavaScript method call
+			this._fscommandCall(command, args);
+		}else if(command == &quot;fscommandReady&quot;){ // see if fscommands are ready
+			this._fscommandReady();
+		}
+	},
+	
+	/** Handles registering a callable Flash function. Flash 6 communication. */
+	_fscommandAddCallback: function(command, args){
+		var functionName = args;
+			
+		// do a trick, where we link this function name to our wrapper
+		// function, _call, that does the actual JavaScript to Flash call
+		var callFunc = function(){
+			return dojo.flash.comm._call(functionName, arguments);
+		};			
+		dojo.flash.comm[functionName] = callFunc;
+		
+		// indicate that the call was successful
+		dojo.flash.obj.get().SetVariable(&quot;_succeeded&quot;, true);
+	},
+	
+	/** Handles Flash calling a JavaScript function. Flash 6 communication. */
+	_fscommandCall: function(command, args){
+		var plugin = dojo.flash.obj.get();
+		var functionName = args;
+		
+		// get the number of arguments to this method call and build them up
+		var numArgs = parseInt(plugin.GetVariable(&quot;_numArgs&quot;));
+		var flashArgs = new Array();
+		for(var i = 0; i &lt; numArgs; i++){
+			var currentArg = plugin.GetVariable(&quot;_&quot; + i);
+			flashArgs.push(currentArg);
+		}
+		
+		// get the function instance; we technically support more capabilities
+		// than ExternalInterface, which can only call global functions; if
+		// the method name has a dot in it, such as &quot;dojo.flash.loaded&quot;, we
+		// eval it so that the method gets run against an instance
+		var runMe;
+		if(functionName.indexOf(&quot;.&quot;) == -1){ // global function
+			runMe = window[functionName];
+		}else{
+			// instance function
+			runMe = eval(functionName);
+		}
+		
+		// make the call and get the results
+		var results = null;
+		if(!dojo.lang.isUndefined(runMe) &amp;&amp; runMe != null){
+			results = runMe.apply(null, flashArgs);
+		}
+		
+		// return the results to flash
+		plugin.SetVariable(&quot;_returnResult&quot;, results);
+	},
+	
+	/** Reports that fscommands are ready to run if executed from Flash. */
+	_fscommandReady: function(){
+		var plugin = dojo.flash.obj.get();
+		plugin.SetVariable(&quot;fscommandReady&quot;, &quot;true&quot;);
+	},
+	
+	/** 
+			The actual function that will execute a JavaScript to Flash call; used
+			by the Flash 6 communication method. 
+	*/
+	_call: function(functionName, args){
+		// we do JavaScript to Flash method calls by setting a Flash variable
+		// &quot;_functionName&quot; with the function name; &quot;_numArgs&quot; with the number
+		// of arguments; and &quot;_0&quot;, &quot;_1&quot;, etc for each numbered argument. Flash
+		// reads these, executes the function call, and returns the result
+		// in &quot;_returnResult&quot;
+		var plugin = dojo.flash.obj.get();
+		plugin.SetVariable(&quot;_functionName&quot;, functionName);
+		plugin.SetVariable(&quot;_numArgs&quot;, args.length);
+		for(var i = 0; i &lt; args.length; i++){
+			// unlike Flash 8's ExternalInterface, Flash 6 has no problem with
+			// any special characters _except_ for the null character \0; double
+			// encode this so the Flash side never sees it, but we can get it 
+			// back if the value comes back to JavaScript
+			var value = args[i];
+			value = value.replace(/\0/g, &quot;\\0&quot;);
+			
+			plugin.SetVariable(&quot;_&quot; + i, value);
+		}
+		
+		// now tell Flash to execute this method using the Flash Runner
+		plugin.TCallLabel(&quot;/_flashRunner&quot;, &quot;execute&quot;);
+		
+		// get the results
+		var results = plugin.GetVariable(&quot;_returnResult&quot;);
+		
+		// we double encoded all null characters as //0 because Flash breaks
+		// if they are present; turn the //0 back into /0
+		results = results.replace(/\\0/g, &quot;\0&quot;);
+		
+		return results;
+	},
+	
+	/** Flash 8 communication. */
+	
+	/** 
+			Registers the existence of a Flash method that we can call with
+			JavaScript, using Flash 8's ExternalInterface. 
+	*/
+	_addExternalInterfaceCallback: function(methodName){
+		var wrapperCall = function(){
+			// some browsers don't like us changing values in the 'arguments' array, so
+			// make a fresh copy of it
+			var methodArgs = new Array(arguments.length);
+			for(var i = 0; i &lt; arguments.length; i++){
+				methodArgs[i] = arguments[i];
+			}
+			return dojo.flash.comm._execFlash(methodName, methodArgs);
+		};
+		
+		dojo.flash.comm[methodName] = wrapperCall;
+	},
+	
+	/** 
+			Encodes our data to get around ExternalInterface bugs.
+			Flash 8 communication.
+	*/
+	_encodeData: function(data){
+		// double encode all entity values, or they will be mis-decoded
+		// by Flash when returned
+		var entityRE = /\&amp;([^;]*)\;/g;
+		data = data.replace(entityRE, &quot;&amp;$1;&quot;);
+		
+		// entity encode XML-ish characters, or Flash's broken XML serializer
+		// breaks
+		data = data.replace(/&lt;/g, &quot;&lt;&quot;);
+		data = data.replace(/&gt;/g, &quot;&gt;&quot;);
+		
+		// transforming \ into \\ doesn't work; just use a custom encoding
+		data = data.replace(&quot;\\&quot;, &quot;&amp;custom_backslash;&amp;custom_backslash;&quot;);
+		
+		data = data.replace(/\n/g, &quot;\\n&quot;);
+		data = data.replace(/\r/g, &quot;\\r&quot;);
+		data = data.replace(/\f/g, &quot;\\f&quot;);
+		data = data.replace(/\0/g, &quot;\\0&quot;); // null character
+		data = data.replace(/\'/g, &quot;\\\'&quot;);
+		data = data.replace(/\&quot;/g, '\\\&quot;');
+		
+		return data;
+	},
+	
+	/** 
+			Decodes our data to get around ExternalInterface bugs.
+			Flash 8 communication.
+	*/
+	_decodeData: function(data){
+		if(data == null || typeof data == &quot;undefined&quot;){
+			return data;
+		}
+		
+		// certain XMLish characters break Flash's wire serialization for
+		// ExternalInterface; these are encoded on the 
+		// DojoExternalInterface side into a custom encoding, rather than
+		// the standard entity encoding, because otherwise we won't be able to
+		// differentiate between our own encoding and any entity characters
+		// that are being used in the string itself
+		data = data.replace(/\&amp;custom_lt\;/g, &quot;&lt;&quot;);
+		data = data.replace(/\&amp;custom_gt\;/g, &quot;&gt;&quot;);
+		
+		// Unfortunately, Flash returns us our String with special characters
+		// like newlines broken into seperate characters. So if \n represents
+		// a new line, Flash returns it as &quot;\&quot; and &quot;n&quot;. This means the character
+		// is _not_ a newline. This forces us to eval() the string to cause
+		// escaped characters to turn into their real special character values.
+		data = eval('&quot;' + data + '&quot;');
+		
+		return data;
+	},
+	
+	/** 
+			Sends our method arguments over to Flash in chunks in order to
+			have ExternalInterface's performance not be O(n^2).
+			Flash 8 communication.
+	*/
+	_chunkArgumentData: function(value, argIndex){
+		var plugin = dojo.flash.obj.get();
+		
+		// cut up the string into pieces, and push over each piece one
+		// at a time
+		var numSegments = Math.ceil(value.length / 1024);
+		for(var i = 0; i &lt; numSegments; i++){
+			var startCut = i * 1024;
+			var endCut = i * 1024 + 1024;
+			if(i == (numSegments - 1)){
+				endCut = i * 1024 + value.length;
+			}
+			
+			var piece = value.substring(startCut, endCut);
+			
+			// encode each piece seperately, rather than the entire
+			// argument data, because ocassionally a special 
+			// character, such as an entity like &foobar;, will fall between
+			// piece boundaries, and we _don't_ want to encode that value if
+			// it falls between boundaries, or else we will end up with incorrect
+			// data when we patch the pieces back together on the other side
+			piece = this._encodeData(piece);
+			
+			// directly use the underlying CallFunction method used by
+			// ExternalInterface, which is vastly faster for large strings
+			// and lets us bypass some Flash serialization bugs
+			plugin.CallFunction('&lt;invoke name=&quot;chunkArgumentData&quot; '
+														+ 'returntype=&quot;javascript&quot;&gt;'
+														+ '&lt;arguments&gt;'
+														+ '&lt;string&gt;' + piece + '&lt;/string&gt;'
+														+ '&lt;number&gt;' + argIndex + '&lt;/number&gt;'
+														+ '&lt;/arguments&gt;'
+														+ '&lt;/invoke&gt;');
+		}
+	},
+	
+	/** 
+			Gets our method return data in chunks for better performance.
+			Flash 8 communication.
+	*/
+	_chunkReturnData: function(){
+		var plugin = dojo.flash.obj.get();
+		
+		var numSegments = plugin.getReturnLength();
+		var resultsArray = new Array();
+		for(var i = 0; i &lt; numSegments; i++){
+			// directly use the underlying CallFunction method used by
+			// ExternalInterface, which is vastly faster for large strings
+			var piece = 
+					plugin.CallFunction('&lt;invoke name=&quot;chunkReturnData&quot; '
+															+ 'returntype=&quot;javascript&quot;&gt;'
+															+ '&lt;arguments&gt;'
+															+ '&lt;number&gt;' + i + '&lt;/number&gt;'
+															+ '&lt;/arguments&gt;'
+															+ '&lt;/invoke&gt;');
+															
+			// remove any leading or trailing JavaScript delimiters, which surround
+			// our String when it comes back from Flash since we bypass Flash's
+			// deserialization routines by directly calling CallFunction on the
+			// plugin
+			if(piece == '&quot;&quot;' || piece == &quot;''&quot;){
+				piece = &quot;&quot;;
+			}else{
+				piece = piece.substring(1, piece.length-1);
+			}
+		
+			resultsArray.push(piece);
+		}
+		var results = resultsArray.join(&quot;&quot;);
+		
+		return results;
+	},
+	
+	/** 
+			Executes a Flash method; called from the JavaScript wrapper proxy we
+			create on dojo.flash.comm.
+			Flash 8 communication.
+	*/
+	_execFlash: function(methodName, methodArgs){
+		var plugin = dojo.flash.obj.get();
+				
+		// begin Flash method execution
+		plugin.startExec();
+		
+		// set the number of arguments
+		plugin.setNumberArguments(methodArgs.length);
+		
+		// chunk and send over each argument
+		for(var i = 0; i &lt; methodArgs.length; i++){
+			this._chunkArgumentData(methodArgs[i], i);
+		}
+		
+		// execute the method
+		plugin.exec(methodName);
+														
+		// get the return result
+		var results = this._chunkReturnData();
+		
+		// decode the results
+		results = this._decodeData(results);
+		
+		// reset everything
+		plugin.endExec();
+		
+		return results;
+
+	}
+}
+
+/** 
+		Figures out the best way to automatically install the Flash plugin
+		for this browser and platform. Also determines if installation or
+		revving of the current plugin is needed on this platform.
+*/
+dojo.flash.Install = function(){
+}
+
+dojo.flash.Install.prototype = {
+	/** 
+			Determines if installation or revving of the current plugin is 
+			needed. 
+	*/
+	needed: function(){
+		// do we even have flash?
+		if(dojo.flash.info.capable == false){
+			return true;
+		}
+
+		// are we on the Mac? Safari needs Flash version 8 to do Flash 8
+		// communication, while Firefox/Mac needs Flash 8 to fix bugs it has
+		// with Flash 6 communication
+		if(dojo.render.os.mac == true &amp;&amp; !dojo.flash.info.isVersionOrAbove(8, 0, 0)){
+			return true;
+		}
+
+		// other platforms need at least Flash 6 or above
+		if(!dojo.flash.info.isVersionOrAbove(6, 0, 0)){
+			return true;
+		}
+
+		// otherwise we don't need installation
+		return false;
+	},
+
+	/** Performs installation or revving of the Flash plugin. */
+	install: function(){
+		//dojo.debug(&quot;install&quot;);
+		// indicate that we are installing
+		dojo.flash.info.installing = true;
+		dojo.flash.installing();
+		
+		if(dojo.flash.info.capable == false){ // we have no Flash at all
+			//dojo.debug(&quot;Completely new install&quot;);
+			// write out a simple Flash object to force the browser to prompt
+			// the user to install things
+			var installObj = new dojo.flash.Embed(false);
+			installObj.write(8); // write out HTML for Flash 8 version+
+		}else if(dojo.flash.info.isVersionOrAbove(6, 0, 65)){ // Express Install
+			//dojo.debug(&quot;Express install&quot;);
+			var installObj = new dojo.flash.Embed(false);
+			installObj.write(8, true); // write out HTML for Flash 8 version+
+			installObj.setVisible(true);
+			installObj.center();
+		}else{ // older Flash install than version 6r65
+			alert(&quot;This content requires a more recent version of the Macromedia &quot;
+						+&quot; Flash Player.&quot;);
+			window.location.href = &quot;<A HREF="http://www.macromedia.com/go/getflashplayer">http://www.macromedia.com/go/getflashplayer</A>&quot;;
+		}
+	},
+	
+	/** 
+			Called when the Express Install is either finished, failed, or was
+			rejected by the user.
+	*/
+	_onInstallStatus: function(msg){
+		if (msg == &quot;Download.Complete&quot;){
+			// Installation is complete.
+			dojo.flash._initialize();
+		}else if(msg == &quot;Download.Cancelled&quot;){
+			alert(&quot;This content requires a more recent version of the Macromedia &quot;
+						+&quot; Flash Player.&quot;);
+			window.location.href = &quot;<A HREF="http://www.macromedia.com/go/getflashplayer">http://www.macromedia.com/go/getflashplayer</A>&quot;;
+		}else if (msg == &quot;Download.Failed&quot;){
+			// The end user failed to download the installer due to a network failure
+			alert(&quot;There was an error downloading the Flash Player update. &quot;
+						+ &quot;Please try again later, or visit macromedia.com to download &quot;
+						+ &quot;the latest version of the Flash plugin.&quot;);
+		}	
+	}
+}
+
+// find out if Flash is installed
+dojo.flash.info = new dojo.flash.Info();
+
+// vim:ts=4:noet:tw=0:

Added: trunk/root/static/magic/src/fx/__package__.js
===================================================================
--- trunk/root/static/magic/src/fx/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/fx/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	browser: [&quot;dojo.fx.html&quot;],
+	dashboard: [&quot;dojo.fx.html&quot;]
+});
+dojo.provide(&quot;dojo.fx.*&quot;);

Added: trunk/root/static/magic/src/fx/html.js
===================================================================
--- trunk/root/static/magic/src/fx/html.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/fx/html.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,573 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.fx.html&quot;);
+
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.math.curves&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.animation&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+
+dojo.deprecated(&quot;dojo.fx.html&quot;, &quot;use dojo.lfx.html instead&quot;, &quot;0.4&quot;);
+
+dojo.fx.duration = 300;
+
+dojo.fx.html._makeFadeable = function(node){
+	if(dojo.render.html.ie){
+		// only set the zoom if the &quot;tickle&quot; value would be the same as the
+		// default
+		if( (node.style.zoom.length == 0) &amp;&amp;
+			(dojo.style.getStyle(node, &quot;zoom&quot;) == &quot;normal&quot;) ){
+			// make sure the node &quot;hasLayout&quot;
+			// NOTE: this has been tested with larger and smaller user-set text
+			// sizes and works fine
+			node.style.zoom = &quot;1&quot;;
+			// node.style.zoom = &quot;normal&quot;;
+		}
+		// don't set the width to auto if it didn't already cascade that way.
+		// We don't want to f anyones designs
+		if(	(node.style.width.length == 0) &amp;&amp;
+			(dojo.style.getStyle(node, &quot;width&quot;) == &quot;auto&quot;) ){
+			node.style.width = &quot;auto&quot;;
+		}
+	}
+}
+
+dojo.fx.html.fadeOut = function(node, duration, callback, dontPlay) {
+	return dojo.fx.html.fade(node, duration, dojo.style.getOpacity(node), 0, callback, dontPlay);
+};
+
+dojo.fx.html.fadeIn = function(node, duration, callback, dontPlay) {
+	return dojo.fx.html.fade(node, duration, dojo.style.getOpacity(node), 1, callback, dontPlay);
+};
+
+dojo.fx.html.fadeHide = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	if(!duration) { duration = 150; } // why not have a default?
+	return dojo.fx.html.fadeOut(node, duration, function(node) {
+		node.style.display = &quot;none&quot;;
+		if(typeof callback == &quot;function&quot;) { callback(node); }
+	});
+};
+
+dojo.fx.html.fadeShow = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	if(!duration) { duration = 150; } // why not have a default?
+	node.style.display = &quot;block&quot;;
+	return dojo.fx.html.fade(node, duration, 0, 1, callback, dontPlay);
+};
+
+dojo.fx.html.fade = function(node, duration, startOpac, endOpac, callback, dontPlay) {
+	node = dojo.byId(node);
+	dojo.fx.html._makeFadeable(node);
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line([startOpac],[endOpac]),
+		duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+		dojo.style.setOpacity(node, e.x);
+	});
+	if(callback) {
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(e) {
+			callback(node, anim);
+		});
+	}
+	if(!dontPlay) { anim.play(true); }
+	return anim;
+};
+
+dojo.fx.html.slideTo = function(node, duration, endCoords, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endCoords;
+		endCoords = tmp;
+	}
+	node = dojo.byId(node);
+
+	var top = node.offsetTop;
+	var left = node.offsetLeft;
+	var pos = dojo.style.getComputedStyle(node, 'position');
+
+	if (pos == 'relative' || pos == 'static') {
+		top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
+		left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
+	}
+
+	return dojo.fx.html.slide(node, duration, [left, top],
+		endCoords, callback, dontPlay);
+};
+
+dojo.fx.html.slideBy = function(node, duration, coords, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = coords;
+		coords = tmp;
+	}
+	node = dojo.byId(node);
+
+	var top = node.offsetTop;
+	var left = node.offsetLeft;
+	var pos = dojo.style.getComputedStyle(node, 'position');
+
+	if (pos == 'relative' || pos == 'static') {
+		top = parseInt(dojo.style.getComputedStyle(node, 'top')) || 0;
+		left = parseInt(dojo.style.getComputedStyle(node, 'left')) || 0;
+	}
+
+	return dojo.fx.html.slideTo(node, duration, [left+coords[0], top+coords[1]],
+		callback, dontPlay);
+};
+
+dojo.fx.html.slide = function(node, duration, startCoords, endCoords, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endCoords;
+		endCoords = startCoords;
+		startCoords = tmp;
+	}
+	node = dojo.byId(node);
+
+	if (dojo.style.getComputedStyle(node, 'position') == 'static') {
+		node.style.position = 'relative';
+	}
+
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startCoords, endCoords),
+		duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+		with( node.style ) {
+			left = e.x + &quot;px&quot;;
+			top = e.y + &quot;px&quot;;
+		}
+	});
+	if(callback) {
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(e) {
+			callback(node, anim);
+		});
+	}
+	if(!dontPlay) { anim.play(true); }
+	return anim;
+};
+
+// Fade from startColor to the node's background color
+dojo.fx.html.colorFadeIn = function(node, duration, startColor, delay, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = startColor;
+		startColor = tmp;
+	}
+	node = dojo.byId(node);
+	var color = dojo.style.getBackgroundColor(node);
+	var bg = dojo.style.getStyle(node, &quot;background-color&quot;).toLowerCase();
+	var wasTransparent = bg == &quot;transparent&quot; || bg == &quot;rgba(0, 0, 0, 0)&quot;;
+	while(color.length &gt; 3) { color.pop(); }
+
+	var rgb = new dojo.graphics.color.Color(startColor).toRgb();
+	var anim = dojo.fx.html.colorFade(node, duration||dojo.fx.duration, startColor, color, callback, true);
+	dojo.event.connect(anim, &quot;onEnd&quot;, function(e) {
+		if( wasTransparent ) {
+			node.style.backgroundColor = &quot;transparent&quot;;
+		}
+	});
+	if( delay &gt; 0 ) {
+		node.style.backgroundColor = &quot;rgb(&quot; + rgb.join(&quot;,&quot;) + &quot;)&quot;;
+		if(!dontPlay) { setTimeout(function(){anim.play(true)}, delay); }
+	} else {
+		if(!dontPlay) { anim.play(true); }
+	}
+	return anim;
+};
+// alias for (probably?) common use/terminology
+dojo.fx.html.highlight = dojo.fx.html.colorFadeIn;
+dojo.fx.html.colorFadeFrom = dojo.fx.html.colorFadeIn;
+
+// Fade from node's background color to endColor
+dojo.fx.html.colorFadeOut = function(node, duration, endColor, delay, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endColor;
+		endColor = tmp;
+	}
+	node = dojo.byId(node);
+	var color = new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node)).toRgb();
+
+	var rgb = new dojo.graphics.color.Color(endColor).toRgb();
+	var anim = dojo.fx.html.colorFade(node, duration||dojo.fx.duration, color, rgb, callback, delay &gt; 0 || dontPlay);
+	if( delay &gt; 0 ) {
+		node.style.backgroundColor = &quot;rgb(&quot; + color.join(&quot;,&quot;) + &quot;)&quot;;
+		if(!dontPlay) { setTimeout(function(){anim.play(true)}, delay); }
+	}
+	return anim;
+};
+// FIXME: not sure which name is better. an alias here may be bad.
+dojo.fx.html.unhighlight = dojo.fx.html.colorFadeOut;
+dojo.fx.html.colorFadeTo = dojo.fx.html.colorFadeOut;
+
+// Fade node background from startColor to endColor
+dojo.fx.html.colorFade = function(node, duration, startColor, endColor, callback, dontPlay) {
+	if(!dojo.lang.isNumber(duration)) {
+		var tmp = duration;
+		duration = endColor;
+		endColor = startColor;
+		startColor = tmp;
+	}
+	node = dojo.byId(node);
+	var startRgb = new dojo.graphics.color.Color(startColor).toRgb();
+	var endRgb = new dojo.graphics.color.Color(endColor).toRgb();
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startRgb, endRgb),
+		duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+		node.style.backgroundColor = &quot;rgb(&quot; + e.coordsAsInts().join(&quot;,&quot;) + &quot;)&quot;;
+	});
+	if(callback) {
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(e) {
+			callback(node, anim);
+		});
+	}
+	if( !dontPlay ) { anim.play(true); }
+	return anim;
+};
+
+dojo.fx.html.wipeIn = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	var overflow = dojo.style.getStyle(node, &quot;overflow&quot;);
+	if(overflow == &quot;visible&quot;) {
+		node.style.overflow = &quot;hidden&quot;;
+	}
+	node.style.height = 0;
+	dojo.style.show(node);
+	var anim = dojo.fx.html.wipe(node, duration, 0, node.scrollHeight, null, true);
+	dojo.event.connect(anim, &quot;onEnd&quot;, function() {
+		node.style.overflow = overflow;
+		node.style.visibility = &quot;&quot;;
+		node.style.height = &quot;auto&quot;;
+		if(callback) { callback(node, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+}
+
+dojo.fx.html.wipeOut = function(node, duration, callback, dontPlay) {
+	node = dojo.byId(node);
+	var overflow = dojo.style.getStyle(node, &quot;overflow&quot;);
+	if(overflow == &quot;visible&quot;) {
+		node.style.overflow = &quot;hidden&quot;;
+	}
+	var anim = dojo.fx.html.wipe(node, duration, node.offsetHeight, 0, null, true);
+	dojo.event.connect(anim, &quot;onEnd&quot;, function() {
+		dojo.style.hide(node);
+		node.style.visibility = &quot;hidden&quot;;
+		node.style.overflow = overflow;
+		if(callback) { callback(node, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+}
+
+dojo.fx.html.wipe = function(node, duration, startHeight, endHeight, callback, dontPlay) {
+	node = dojo.byId(node);
+	var anim = new dojo.animation.Animation([[startHeight], [endHeight]], duration||dojo.fx.duration, 0);
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+		node.style.height = e.x + &quot;px&quot;;
+	});
+	dojo.event.connect(anim, &quot;onEnd&quot;, function() {
+		if(callback) { callback(node, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+}
+
+dojo.fx.html.wiper = function(node, controlNode) {
+	this.node = dojo.byId(node);
+	if(controlNode) {
+		dojo.event.connect(dojo.byId(controlNode), &quot;onclick&quot;, this, &quot;toggle&quot;);
+	}
+}
+dojo.lang.extend(dojo.fx.html.wiper, {
+	duration: dojo.fx.duration,
+	_anim: null,
+
+	toggle: function() {
+		if(!this._anim) {
+			var type = &quot;wipe&quot; + (dojo.style.isVisible(this.node) ? &quot;Out&quot; : &quot;In&quot;);
+			this._anim = dojo.fx[type](this.node, this.duration, dojo.lang.hitch(this, &quot;_callback&quot;));
+		}
+	},
+
+	_callback: function() {
+		this._anim = null;
+	}
+});
+
+dojo.fx.html.explode = function(start, endNode, duration, callback, dontPlay) {
+	var startCoords = dojo.style.toCoordinateArray(start);
+
+	var outline = document.createElement(&quot;div&quot;);
+	with(outline.style) {
+		position = &quot;absolute&quot;;
+		border = &quot;1px solid black&quot;;
+		display = &quot;none&quot;;
+	}
+	document.body.appendChild(outline);
+
+	endNode = dojo.byId(endNode);
+	with(endNode.style) {
+		visibility = &quot;hidden&quot;;
+		display = &quot;block&quot;;
+	}
+	var endCoords = dojo.style.toCoordinateArray(endNode);
+
+	with(endNode.style) {
+		display = &quot;none&quot;;
+		visibility = &quot;visible&quot;;
+	}
+
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startCoords, endCoords),
+		duration||dojo.fx.duration, 0
+	);
+	dojo.event.connect(anim, &quot;onBegin&quot;, function(e) {
+		outline.style.display = &quot;block&quot;;
+	});
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+		with(outline.style) {
+			left = e.x + &quot;px&quot;;
+			top = e.y + &quot;px&quot;;
+			width = e.coords[2] + &quot;px&quot;;
+			height = e.coords[3] + &quot;px&quot;;
+		}
+	});
+
+	dojo.event.connect(anim, &quot;onEnd&quot;, function() {
+		endNode.style.display = &quot;block&quot;;
+		outline.parentNode.removeChild(outline);
+		if(callback) { callback(endNode, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+};
+
+dojo.fx.html.implode = function(startNode, end, duration, callback, dontPlay) {
+	var startCoords = dojo.style.toCoordinateArray(startNode);
+	var endCoords = dojo.style.toCoordinateArray(end);
+
+	startNode = dojo.byId(startNode);
+	var outline = document.createElement(&quot;div&quot;);
+	with(outline.style) {
+		position = &quot;absolute&quot;;
+		border = &quot;1px solid black&quot;;
+		display = &quot;none&quot;;
+	}
+	document.body.appendChild(outline);
+
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line(startCoords, endCoords),
+		duration||dojo.fx.duration, 0
+	);
+	dojo.event.connect(anim, &quot;onBegin&quot;, function(e) {
+		startNode.style.display = &quot;none&quot;;
+		outline.style.display = &quot;block&quot;;
+	});
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+		with(outline.style) {
+			left = e.x + &quot;px&quot;;
+			top = e.y + &quot;px&quot;;
+			width = e.coords[2] + &quot;px&quot;;
+			height = e.coords[3] + &quot;px&quot;;
+		}
+	});
+
+	dojo.event.connect(anim, &quot;onEnd&quot;, function() {
+		outline.parentNode.removeChild(outline);
+		if(callback) { callback(startNode, anim); }
+	});
+	if(!dontPlay) { anim.play(); }
+	return anim;
+};
+
+dojo.fx.html.Exploder = function(triggerNode, boxNode) {
+	triggerNode = dojo.byId(triggerNode);
+	boxNode = dojo.byId(boxNode);
+	var _this = this;
+
+	// custom options
+	this.waitToHide = 500;
+	this.timeToShow = 100;
+	this.waitToShow = 200;
+	this.timeToHide = 70;
+	this.autoShow = false;
+	this.autoHide = false;
+
+	var animShow = null;
+	var animHide = null;
+
+	var showTimer = null;
+	var hideTimer = null;
+
+	var startCoords = null;
+	var endCoords = null;
+
+	this.showing = false;
+
+	this.onBeforeExplode = null;
+	this.onAfterExplode = null;
+	this.onBeforeImplode = null;
+	this.onAfterImplode = null;
+	this.onExploding = null;
+	this.onImploding = null;
+
+	this.timeShow = function() {
+		clearTimeout(showTimer);
+		showTimer = setTimeout(_this.show, _this.waitToShow);
+	}
+
+	this.show = function() {
+		clearTimeout(showTimer);
+		clearTimeout(hideTimer);
+		//triggerNode.blur();
+
+		if( (animHide &amp;&amp; animHide.status() == &quot;playing&quot;)
+			|| (animShow &amp;&amp; animShow.status() == &quot;playing&quot;)
+			|| _this.showing ) { return; }
+
+		if(typeof _this.onBeforeExplode == &quot;function&quot;) { _this.onBeforeExplode(triggerNode, boxNode); }
+		animShow = dojo.fx.html.explode(triggerNode, boxNode, _this.timeToShow, function(e) {
+			_this.showing = true;
+			if(typeof _this.onAfterExplode == &quot;function&quot;) { _this.onAfterExplode(triggerNode, boxNode); }
+		});
+		if(typeof _this.onExploding == &quot;function&quot;) {
+			dojo.event.connect(animShow, &quot;onAnimate&quot;, this, &quot;onExploding&quot;);
+		}
+	}
+
+	this.timeHide = function() {
+		clearTimeout(showTimer);
+		clearTimeout(hideTimer);
+		if(_this.showing) {
+			hideTimer = setTimeout(_this.hide, _this.waitToHide);
+		}
+	}
+
+	this.hide = function() {
+		clearTimeout(showTimer);
+		clearTimeout(hideTimer);
+		if( animShow &amp;&amp; animShow.status() == &quot;playing&quot; ) {
+			return;
+		}
+
+		_this.showing = false;
+		if(typeof _this.onBeforeImplode == &quot;function&quot;) { _this.onBeforeImplode(triggerNode, boxNode); }
+		animHide = dojo.fx.html.implode(boxNode, triggerNode, _this.timeToHide, function(e){
+			if(typeof _this.onAfterImplode == &quot;function&quot;) { _this.onAfterImplode(triggerNode, boxNode); }
+		});
+		if(typeof _this.onImploding == &quot;function&quot;) {
+			dojo.event.connect(animHide, &quot;onAnimate&quot;, this, &quot;onImploding&quot;);
+		}
+	}
+
+	// trigger events
+	dojo.event.connect(triggerNode, &quot;onclick&quot;, function(e) {
+		if(_this.showing) {
+			_this.hide();
+		} else {
+			_this.show();
+		}
+	});
+	dojo.event.connect(triggerNode, &quot;onmouseover&quot;, function(e) {
+		if(_this.autoShow) {
+			_this.timeShow();
+		}
+	});
+	dojo.event.connect(triggerNode, &quot;onmouseout&quot;, function(e) {
+		if(_this.autoHide) {
+			_this.timeHide();
+		}
+	});
+
+	// box events
+	dojo.event.connect(boxNode, &quot;onmouseover&quot;, function(e) {
+		clearTimeout(hideTimer);
+	});
+	dojo.event.connect(boxNode, &quot;onmouseout&quot;, function(e) {
+		if(_this.autoHide) {
+			_this.timeHide();
+		}
+	});
+
+	// document events
+	dojo.event.connect(document.documentElement || document.body, &quot;onclick&quot;, function(e) {
+		function isDesc(node, ancestor) {
+			while(node) {
+				if(node == ancestor){ return true; }
+				node = node.parentNode;
+			}
+			return false;
+		}
+		if(_this.autoHide &amp;&amp; _this.showing
+			&amp;&amp; !isDesc(e.target, boxNode)
+			&amp;&amp; !isDesc(e.target, triggerNode) ) {
+			_this.hide();
+		}
+	});
+
+	return this;
+};
+
+/**** 
+	Strategies for displaying/hiding objects
+	This presents a standard interface for each of the effects
+*****/
+dojo.fx.html.toggle={}
+
+dojo.fx.html.toggle.plain = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.style.show(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.style.hide(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	}
+}
+
+dojo.fx.html.toggle.fade = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.fadeShow(node, duration, callback);
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.fadeHide(node, duration, callback);
+	}
+}
+
+dojo.fx.html.toggle.wipe = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.wipeIn(node, duration, callback);
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.wipeOut(node, duration, callback);
+	}
+}
+
+dojo.fx.html.toggle.explode = {
+	show: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.explode(explodeSrc||[0,0,0,0], node, duration, callback);
+	},
+
+	hide: function(node, duration, explodeSrc, callback){
+		dojo.fx.html.implode(node, explodeSrc||[0,0,0,0], duration, callback);
+	}
+}
+
+dojo.lang.mixin(dojo.fx, dojo.fx.html);

Added: trunk/root/static/magic/src/fx/svg.js
===================================================================
--- trunk/root/static/magic/src/fx/svg.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/fx/svg.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,99 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.fx.svg&quot;);
+
+dojo.require(&quot;dojo.svg&quot;);
+dojo.require(&quot;dojo.animation.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+dojo.fx.svg.fadeOut = function(node, duration, callback){
+	return dojo.fx.svg.fade(node, duration, dojo.svg.getOpacity(node), 0, callback);
+};
+dojo.fx.svg.fadeIn = function(node, duration, callback){
+	return dojo.fx.svg.fade(node, duration, dojo.svg.getOpacity(node), 1, callback);
+};
+dojo.fx.svg.fadeHide = function(node, duration, callback){
+	if(!duration) { duration = 150; } // why not have a default?
+	return dojo.fx.svg.fadeOut(node, duration, function(node) {
+		if(typeof callback == &quot;function&quot;) { callback(node); }
+	});
+};
+dojo.fx.svg.fadeShow = function(node, duration, callback){
+	if(!duration) { duration = 150; } // why not have a default?
+	return dojo.fx.svg.fade(node, duration, 0, 1, callback);
+};
+dojo.fx.svg.fade = function(node, duration, startOpac, endOpac, callback){
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line([startOpac],[endOpac]),
+		duration,
+		0
+	);
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e){
+		dojo.svg.setOpacity(node, e.x);
+	});
+	if (callback) {
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(e){
+			callback(node, anim);
+		});
+	};
+	anim.play(true);
+	return anim;
+};
+
+/////////////////////////////////////////////////////////////////////////////////////////
+//	TODO
+/////////////////////////////////////////////////////////////////////////////////////////
+
+//	SLIDES
+dojo.fx.svg.slideTo = function(node, endCoords, duration, callback) { };
+dojo.fx.svg.slideBy = function(node, coords, duration, callback) { };
+dojo.fx.svg.slide = function(node, startCoords, endCoords, duration, callback) { 
+	var anim = new dojo.animation.Animation(
+		new dojo.math.curves.Line([startCoords],[endCoords]),
+		duration,
+		0
+	);
+	dojo.event.connect(anim, &quot;onAnimate&quot;, function(e){
+		dojo.svg.setCoords(node, {x: e.x, y: e.y });
+	});
+	if (callback) {
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(e){
+			callback(node, anim);
+		});
+	};
+	anim.play(true);
+	return anim;
+};
+
+//	COLORS
+dojo.fx.svg.colorFadeIn = function(node, startRGB, duration, delay, callback) { };
+dojo.fx.svg.highlight = dojo.fx.svg.colorFadeIn;
+dojo.fx.svg.colorFadeFrom = dojo.fx.svg.colorFadeIn;
+
+dojo.fx.svg.colorFadeOut = function(node, endRGB, duration, delay, callback) { };
+dojo.fx.svg.unhighlight = dojo.fx.svg.colorFadeOut;
+dojo.fx.svg.colorFadeTo = dojo.fx.svg.colorFadeOut;
+
+dojo.fx.svg.colorFade = function(node, startRGB, endRGB, duration, callback, dontPlay) { };
+
+//	WIPES
+dojo.fx.svg.wipeIn = function(node, duration, callback, dontPlay) { };
+dojo.fx.svg.wipeInToHeight = function(node, duration, height, callback, dontPlay) { }
+dojo.fx.svg.wipeOut = function(node, duration, callback, dontPlay) { };
+
+//	Explode and Implode
+dojo.fx.svg.explode = function(startNode, endNode, duration, callback) { };
+dojo.fx.svg.explodeFromBox = function(startCoords, endNode, duration, callback) { };
+dojo.fx.svg.implode = function(startNode, endNode, duration, callback) { };
+dojo.fx.svg.implodeToBox = function(startNode, endCoords, duration, callback) { };
+dojo.fx.svg.Exploder = function(triggerNode, boxNode) { };
+
+//	html mixes in, we want SVG to remain separate

Added: trunk/root/static/magic/src/graphics/Colorspace.js
===================================================================
--- trunk/root/static/magic/src/graphics/Colorspace.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/graphics/Colorspace.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,944 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.graphics.Colorspace&quot;);
+
+dojo.require(&quot;dojo.lang&quot;);
+dojo.require(&quot;dojo.math.matrix&quot;);
+
+//
+// to convert to YUV:
+//   c.whitePoint = 'D65';
+//   c.RGBWorkingSpace = 'pal_secam_rgb';
+//   var out = c.convert([r,g,b], 'RGB', 'XYZ');
+//
+// to convert to YIQ:
+//   c.whitePoint = 'D65';
+//   c.RGBWorkingSpace = 'ntsc_rgb';
+//   var out = c.convert([r,g,b], 'RGB', 'XYZ');
+//
+
+dojo.graphics.Colorspace =function(){
+
+	this.whitePoint = 'D65';
+	this.stdObserver = '10';
+	this.chromaticAdaptationAlg = 'bradford';
+	this.RGBWorkingSpace = 's_rgb';
+	this.useApproxCIELabMapping = 1; // see <A HREF="http://www.brucelindbloom.com/LContinuity.html">http://www.brucelindbloom.com/LContinuity.html</A>
+
+	this.chainMaps = {
+		'RGB_to_xyY'  : ['XYZ'],
+		'xyY_to_RGB'  : ['XYZ'],
+		'RGB_to_Lab'  : ['XYZ'],
+		'Lab_to_RGB'  : ['XYZ'],
+		'RGB_to_LCHab': ['XYZ', 'Lab'],
+		'LCHab_to_RGB': ['Lab'],
+		'xyY_to_Lab'  : ['XYZ'],
+		'Lab_to_xyY'  : ['XYZ'],
+		'XYZ_to_LCHab': ['Lab'],
+		'LCHab_to_XYZ': ['Lab'],
+		'xyY_to_LCHab': ['XYZ', 'Lab'],
+		'LCHab_to_xyY': ['Lab', 'XYZ'],
+		'RGB_to_Luv'  : ['XYZ'],
+		'Luv_to_RGB'  : ['XYZ'],
+		'xyY_to_Luv'  : ['XYZ'],
+		'Luv_to_xyY'  : ['XYZ'],
+		'Lab_to_Luv'  : ['XYZ'],
+		'Luv_to_Lab'  : ['XYZ'],
+		'LCHab_to_Luv': ['Lab', 'XYZ'],
+		'Luv_to_LCHab': ['XYZ', 'Lab'],
+		'RGB_to_LCHuv'  : ['XYZ', 'Luv'],
+		'LCHuv_to_RGB'  : ['Luv', 'XYZ'],
+		'XYZ_to_LCHuv'  : ['Luv'],
+		'LCHuv_to_XYZ'  : ['Luv'],
+		'xyY_to_LCHuv'  : ['XYZ', 'Luv'],
+		'LCHuv_to_xyY'  : ['Luv', 'XYZ'],
+		'Lab_to_LCHuv'  : ['XYZ', 'Luv'],
+		'LCHuv_to_Lab'  : ['Luv', 'XYZ'],
+		'LCHab_to_LCHuv': ['Lab', 'XYZ', 'Luv'],
+		'LCHuv_to_LCHab': ['Luv', 'XYZ', 'Lab'],
+		'XYZ_to_CMY'    : ['RGB'],
+		'CMY_to_XYZ'    : ['RGB'],
+		'xyY_to_CMY'    : ['RGB'],
+		'CMY_to_xyY'    : ['RGB'],
+		'Lab_to_CMY'    : ['RGB'],
+		'CMY_to_Lab'    : ['RGB'],
+		'LCHab_to_CMY'  : ['RGB'],
+		'CMY_to_LCHab'  : ['RGB'],
+		'Luv_to_CMY'    : ['RGB'],
+		'CMY_to_Luv'    : ['RGB'],
+		'LCHuv_to_CMY'  : ['RGB'],
+		'CMY_to_LCHuv'  : ['RGB'],
+		'XYZ_to_HSL'    : ['RGB'],
+		'HSL_to_XYZ'    : ['RGB'],
+		'xyY_to_HSL'    : ['RGB'],
+		'HSL_to_xyY'    : ['RGB'],
+		'Lab_to_HSL'    : ['RGB'],
+		'HSL_to_Lab'    : ['RGB'],
+		'LCHab_to_HSL'  : ['RGB'],
+		'HSL_to_LCHab'  : ['RGB'],
+		'Luv_to_HSL'    : ['RGB'],
+		'HSL_to_Luv'    : ['RGB'],
+		'LCHuv_to_HSL'  : ['RGB'],
+		'HSL_to_LCHuv'  : ['RGB'],
+		'CMY_to_HSL'    : ['RGB'],
+		'HSL_to_CMY'    : ['RGB'],
+		'CMYK_to_HSL'   : ['RGB'],
+		'HSL_to_CMYK'   : ['RGB'],
+		'XYZ_to_HSV'    : ['RGB'],
+		'HSV_to_XYZ'    : ['RGB'],
+		'xyY_to_HSV'    : ['RGB'],
+		'HSV_to_xyY'    : ['RGB'],
+		'Lab_to_HSV'    : ['RGB'],
+		'HSV_to_Lab'    : ['RGB'],
+		'LCHab_to_HSV'  : ['RGB'],
+		'HSV_to_LCHab'  : ['RGB'],
+		'Luv_to_HSV'    : ['RGB'],
+		'HSV_to_Luv'    : ['RGB'],
+		'LCHuv_to_HSV'  : ['RGB'],
+		'HSV_to_LCHuv'  : ['RGB'],
+		'CMY_to_HSV'    : ['RGB'],
+		'HSV_to_CMY'    : ['RGB'],
+		'CMYK_to_HSV'   : ['RGB'],
+		'HSV_to_CMYK'   : ['RGB'],
+		'HSL_to_HSV'    : ['RGB'],
+		'HSV_to_HSL'    : ['RGB'],
+		'XYZ_to_CMYK'   : ['RGB'],
+		'CMYK_to_XYZ'   : ['RGB'],
+		'xyY_to_CMYK'   : ['RGB'],
+		'CMYK_to_xyY'   : ['RGB'],
+		'Lab_to_CMYK'   : ['RGB'],
+		'CMYK_to_Lab'   : ['RGB'],
+		'LCHab_to_CMYK' : ['RGB'],
+		'CMYK_to_LCHab' : ['RGB'],
+		'Luv_to_CMYK'   : ['RGB'],
+		'CMYK_to_Luv'   : ['RGB'],
+		'LCHuv_to_CMYK' : ['RGB'],
+		'CMYK_to_LCHuv' : ['RGB']
+	};
+
+
+	return this;
+}
+
+dojo.graphics.Colorspace.prototype.convert = function(col, model_from, model_to){
+
+	var k = model_from+'_to_'+model_to;
+
+	if (this[k]){
+		return this[k](col);
+	}else{
+		if (this.chainMaps[k]){
+
+			var cur = model_from;
+			var models = this.chainMaps[k].concat();
+			models.push(model_to);
+
+			for(var i=0; i&lt;models.length; i++){
+
+				col = this.convert(col, cur, models[i]);
+				cur = models[i];
+			}
+
+			return col;
+
+		}else{
+
+			dojo.debug(&quot;Can't convert from &quot;+model_from+' to '+model_to);
+		}
+	}
+}
+
+dojo.graphics.Colorspace.prototype.munge = function(keys, args){
+
+	if (dojo.lang.isArray(args[0])){
+		args = args[0];
+	}
+
+	var out = new Array();
+
+	for (var i=0; i&lt;keys.length; i++){
+		out[keys.charAt(i)] = args[i];
+	}
+
+	return out;
+}
+
+dojo.graphics.Colorspace.prototype.getWhitePoint = function(){
+
+	var x = 0;
+	var y = 0;
+	var t = 0;
+
+	// ref: <A HREF="http://en.wikipedia.org/wiki/White_point">http://en.wikipedia.org/wiki/White_point</A>
+	// TODO: i need some good/better white point values
+
+	switch(this.stdObserver){
+		case '2' :
+			switch(this.whitePoint){
+				case 'E'   : x=1/3    ; y=1/3    ; t=5400; break; //Equal energy
+				case 'D50' : x=0.34567; y=0.35850; t=5000; break;
+				case 'D55' : x=0.33242; y=0.34743; t=5500; break;
+				case 'D65' : x=0.31271; y=0.32902; t=6500; break;
+				case 'D75' : x=0.29902; y=0.31485; t=7500; break;
+				case 'A'   : x=0.44757; y=0.40745; t=2856; break; //Incandescent tungsten
+				case 'B'   : x=0.34842; y=0.35161; t=4874; break;
+				case 'C'   : x=0.31006; y=0.31616; t=6774; break;
+				case '9300': x=0.28480; y=0.29320; t=9300; break; //Blue phosphor monitors
+				case 'F2'  : x=0.37207; y=0.37512; t=4200; break; //Cool White Fluorescent
+				case 'F7'  : x=0.31285; y=0.32918; t=6500; break; //Narrow Band Daylight Fluorescent
+				case 'F11' : x=0.38054; y=0.37691; t=4000; break; //Narrow Band White Fluorescent
+				default: dojo.debug('White point '+this.whitePoint+&quot; isn't defined for Std. Observer &quot;+this.strObserver);
+			};
+			break;
+		case '10' :
+			switch(this.whitePoint){
+				case 'E'   : x=1/3    ; y=1/3    ; t=5400; break; //Equal energy
+				case 'D50' : x=0.34773; y=0.35952; t=5000; break;
+				case 'D55' : x=0.33411; y=0.34877; t=5500; break;
+				case 'D65' : x=0.31382; y=0.33100; t=6500; break;
+				case 'D75' : x=0.29968; y=0.31740; t=7500; break;
+				case 'A'   : x=0.45117; y=0.40594; t=2856; break; //Incandescent tungsten
+				case 'B'   : x=0.3498 ; y=0.3527 ; t=4874; break;
+				case 'C'   : x=0.31039; y=0.31905; t=6774; break;
+				case 'F2'  : x=0.37928; y=0.36723; t=4200; break; //Cool White Fluorescent
+				case 'F7'  : x=0.31565; y=0.32951; t=6500; break; //Narrow Band Daylight Fluorescent
+				case 'F11' : x=0.38543; y=0.37110; t=4000; break; //Narrow Band White Fluorescent
+				default: dojo.debug('White point '+this.whitePoint+&quot; isn't defined for Std. Observer &quot;+this.strObserver);
+			};
+			break;
+		default:
+			dojo.debug(&quot;Std. Observer &quot;+this.strObserver+&quot; isn't defined&quot;);
+	}
+
+	var z = 1 - x - y;
+
+	var wp = {'x':x, 'y':y, 'z':z, 't':t};
+
+	wp.Y = 1;
+
+	var XYZ = this.xyY_to_XYZ([wp.x, wp.y, wp.Y]);
+
+	wp.X = XYZ[0];
+	wp.Y = XYZ[1];
+	wp.Z = XYZ[2];
+
+	return wp
+}
+
+dojo.graphics.Colorspace.prototype.getPrimaries = function(){
+
+	// ref: <A HREF="http://www.fho-emden.de/~hoffmann/ciexyz29082000.pdf">http://www.fho-emden.de/~hoffmann/ciexyz29082000.pdf</A>
+	// ref: <A HREF="http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html">http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html</A>
+
+	var m = [];
+
+	switch(this.RGBWorkingSpace){
+
+		case 'adobe_rgb_1998'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.297361, 0.2100, 0.7100, 0.627355, 0.1500, 0.0600, 0.075285]; break;
+		case 'apple_rgb'	: m = [1.8, 'D65', 0.6250, 0.3400, 0.244634, 0.2800, 0.5950, 0.672034, 0.1550, 0.0700, 0.083332]; break;
+		case 'best_rgb'		: m = [2.2, 'D50', 0.7347, 0.2653, 0.228457, 0.2150, 0.7750, 0.737352, 0.1300, 0.0350, 0.034191]; break;
+		case 'beta_rgb'		: m = [2.2, 'D50', 0.6888, 0.3112, 0.303273, 0.1986, 0.7551, 0.663786, 0.1265, 0.0352, 0.032941]; break;
+		case 'bruce_rgb'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.240995, 0.2800, 0.6500, 0.683554, 0.1500, 0.0600, 0.075452]; break;
+		case 'cie_rgb'		: m = [2.2, 'E'  , 0.7350, 0.2650, 0.176204, 0.2740, 0.7170, 0.812985, 0.1670, 0.0090, 0.010811]; break;
+		case 'color_match_rgb'	: m = [1.8, 'D50', 0.6300, 0.3400, 0.274884, 0.2950, 0.6050, 0.658132, 0.1500, 0.0750, 0.066985]; break;
+		case 'don_rgb_4'	: m = [2.2, 'D50', 0.6960, 0.3000, 0.278350, 0.2150, 0.7650, 0.687970, 0.1300, 0.0350, 0.033680]; break;
+		case 'eci_rgb'		: m = [1.8, 'D50', 0.6700, 0.3300, 0.320250, 0.2100, 0.7100, 0.602071, 0.1400, 0.0800, 0.077679]; break;
+		case 'ekta_space_ps5'	: m = [2.2, 'D50', 0.6950, 0.3050, 0.260629, 0.2600, 0.7000, 0.734946, 0.1100, 0.0050, 0.004425]; break;
+		case 'ntsc_rgb'		: m = [2.2, 'C'  , 0.6700, 0.3300, 0.298839, 0.2100, 0.7100, 0.586811, 0.1400, 0.0800, 0.114350]; break;
+		case 'pal_secam_rgb'	: m = [2.2, 'D65', 0.6400, 0.3300, 0.222021, 0.2900, 0.6000, 0.706645, 0.1500, 0.0600, 0.071334]; break;
+		case 'pro_photo_rgb'	: m = [1.8, 'D50', 0.7347, 0.2653, 0.288040, 0.1596, 0.8404, 0.711874, 0.0366, 0.0001, 0.000086]; break;
+		case 'smpte-c_rgb'	: m = [2.2, 'D65', 0.6300, 0.3400, 0.212395, 0.3100, 0.5950, 0.701049, 0.1550, 0.0700, 0.086556]; break;
+		case 's_rgb'		: m = [2.2, 'D65', 0.6400, 0.3300, 0.212656, 0.3000, 0.6000, 0.715158, 0.1500, 0.0600, 0.072186]; break;
+		case 'wide_gamut_rgb'	: m = [2.2, 'D50', 0.7350, 0.2650, 0.258187, 0.1150, 0.8260, 0.724938, 0.1570, 0.0180, 0.016875]; break;
+
+		default: dojo.debug(&quot;RGB working space &quot;+this.RGBWorkingSpace+&quot; isn't defined&quot;);
+	}
+
+	var p = {};
+
+	p.name = this.RGBWorkingSpace;
+	p.gamma = m[0];
+	p.wp = m[1];
+
+	p.xr = m[2];
+	p.yr = m[3];
+	p.Yr = m[4];
+
+	p.xg = m[5];
+	p.yg = m[6];
+	p.Yg = m[7];
+
+	p.xb = m[8];
+	p.yb = m[9];
+	p.Yb = m[10];
+
+	// if WP doesn't match current WP, convert the primaries over
+
+	if (p.wp != this.whitePoint){
+
+		var r = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xr, p.yr, p.Yr]), p.wp, this.whitePoint ) );
+		var g = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xg, p.yg, p.Yg]), p.wp, this.whitePoint ) );
+		var b = this.XYZ_to_xyY( this.chromaticAdaptation( this.xyY_to_XYZ([p.xb, p.yb, p.Yb]), p.wp, this.whitePoint ) );
+
+		p.xr = r[0];
+		p.yr = r[1];
+		p.Yr = r[2];
+
+		p.xg = g[0];
+		p.yg = g[1];
+		p.Yg = g[2];
+
+		p.xb = b[0];
+		p.yb = b[1];
+		p.Yb = b[2];
+
+		p.wp = this.whitePoint;
+	}
+
+	p.zr = 1 - p.xr - p.yr;
+	p.zg = 1 - p.xg - p.yg;
+	p.zb = 1 - p.xb - p.yb;
+
+	return p;
+}
+
+dojo.graphics.Colorspace.prototype.epsilon = function(){
+
+	return this.useApproxCIELabMapping ? 0.008856 : 216 / 24289;
+}
+
+dojo.graphics.Colorspace.prototype.kappa = function(){
+
+	return this.useApproxCIELabMapping ? 903.3 : 24389 / 27;
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_xyY = function(){
+	var src = this.munge('XYZ', arguments);
+
+	var sum = src.X + src.Y + src.Z;
+
+	if (sum == 0){
+
+		var wp = this.getWhitePoint();
+		var x = wp.x;
+		var y = wp.y;
+	}else{
+		var x = src.X / sum;
+		var y = src.Y / sum;
+	}
+
+	var Y = src.Y;
+
+
+	return [x, y, Y];
+}
+
+dojo.graphics.Colorspace.prototype.xyY_to_XYZ = function(){
+	var src = this.munge('xyY', arguments);
+
+	if (src.y == 0){
+
+		var X = 0;
+		var Y = 0;
+		var Z = 0;
+	}else{
+		var X = (src.x * src.Y) / src.y;
+		var Y = src.Y;
+		var Z = ((1 - src.x - src.y) * src.Y) / src.y;
+	}
+
+	return [X, Y, Z];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_XYZ = function(){
+	var src = this.munge('RGB', arguments);
+
+	var m = this.getRGB_XYZ_Matrix();
+	var pr = this.getPrimaries();
+
+	if (this.RGBWorkingSpace == 's_rgb'){
+
+		var r = (src.R &gt; 0.04045) ? Math.pow(((src.R + 0.055) / 1.055), 2.4) : src.R / 12.92;
+		var g = (src.G &gt; 0.04045) ? Math.pow(((src.G + 0.055) / 1.055), 2.4) : src.G / 12.92;
+		var b = (src.B &gt; 0.04045) ? Math.pow(((src.B + 0.055) / 1.055), 2.4) : src.B / 12.92;
+
+	}else{
+
+		var r = Math.pow(src.R, pr.gamma);
+		var g = Math.pow(src.G, pr.gamma);
+		var b = Math.pow(src.B, pr.gamma);
+	}
+
+	var XYZ = dojo.math.matrix.multiply([[r, g, b]], m);
+
+	return [XYZ[0][0], XYZ[0][1], XYZ[0][2]];
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_RGB = function(){
+	var src = this.munge('XYZ', arguments);
+
+	var mi = this.getXYZ_RGB_Matrix();
+	var pr = this.getPrimaries();
+
+	var rgb = dojo.math.matrix.multiply([[src.X, src.Y, src.Z]], mi);
+	var r = rgb[0][0];
+	var g = rgb[0][1];
+	var b = rgb[0][2];
+
+	if (this.RGBWorkingSpace == 's_rgb'){
+
+		var R = (r &gt; 0.0031308) ? (1.055 * Math.pow(r, 1.0/2.4)) - 0.055 : 12.92 * r;
+		var G = (g &gt; 0.0031308) ? (1.055 * Math.pow(g, 1.0/2.4)) - 0.055 : 12.92 * g;
+		var B = (b &gt; 0.0031308) ? (1.055 * Math.pow(b, 1.0/2.4)) - 0.055 : 12.92 * b;
+	}else{
+		var R = Math.pow(r, 1/pr.gamma);
+		var G = Math.pow(g, 1/pr.gamma);
+		var B = Math.pow(b, 1/pr.gamma);
+	}
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_Lab = function(){
+	var src = this.munge('XYZ', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var xr = src.X / wp.X;
+	var yr = src.Y / wp.Y;
+	var zr = src.Z / wp.Z;
+
+	var fx = (xr &gt; this.epsilon()) ? Math.pow(xr, 1/3) : (this.kappa() * xr + 16) / 116;
+	var fy = (yr &gt; this.epsilon()) ? Math.pow(yr, 1/3) : (this.kappa() * yr + 16) / 116;
+	var fz = (zr &gt; this.epsilon()) ? Math.pow(zr, 1/3) : (this.kappa() * zr + 16) / 116;
+
+	var L = 116 * fy - 16;
+	var a = 500 * (fx - fy);
+	var b = 200 * (fy - fz);
+
+	return [L, a, b];
+}
+
+dojo.graphics.Colorspace.prototype.Lab_to_XYZ = function(){
+	var src = this.munge('Lab', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var yr = (src.L &gt; (this.kappa() * this.epsilon())) ? Math.pow((src.L + 16) / 116, 3) : src.L / this.kappa();
+
+	var fy = (yr &gt; this.epsilon()) ? (src.L + 16) / 116 : (this.kappa() * yr + 16) / 116;
+
+	var fx = (src.a / 500) + fy;
+	var fz = fy - (src.b / 200);
+
+	var fxcube = Math.pow(fx, 3);
+	var fzcube = Math.pow(fz, 3);
+
+	var xr = (fxcube &gt; this.epsilon()) ? fxcube : (116 * fx - 16) / this.kappa();
+	var zr = (fzcube &gt; this.epsilon()) ? fzcube : (116 * fz - 16) / this.kappa();
+
+	var X = xr * wp.X;
+	var Y = yr * wp.Y;
+	var Z = zr * wp.Z;
+
+	return [X, Y, Z];
+}
+
+dojo.graphics.Colorspace.prototype.Lab_to_LCHab = function(){
+	var src = this.munge('Lab', arguments);
+
+	var L = src.L;
+	var C = Math.pow(src.a * src.a + src.b * src.b, 0.5);
+	var H = Math.atan2(src.b, src.a) * (180 / Math.PI);
+
+	if (H &lt; 0){ H += 360; }
+	if (H &gt; 360){ H -= 360; }
+
+	return [L, C, H];
+}
+
+dojo.graphics.Colorspace.prototype.LCHab_to_Lab = function(){
+	var src = this.munge('LCH', arguments);
+
+	var H_rad = src.H * (Math.PI / 180);
+
+	var L = src.L;
+
+	var a = src.C / Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);
+	if ((90 &lt; src.H) &amp;&amp; (src.H &lt; 270)){ a= -a; }
+
+	var b = Math.pow(Math.pow(src.C, 2) - Math.pow(a, 2), 0.5);
+	if (src.H &gt; 180){ b = -b; }
+
+	return [L, a, b];
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+// this function converts an XYZ color array (col) from one whitepoint (src_w) to another (dst_w)
+//
+
+dojo.graphics.Colorspace.prototype.chromaticAdaptation = function(col, src_w, dst_w){
+
+	col = this.munge('XYZ', [col]);
+
+	//
+	// gather white point data for the source and dest
+	//
+
+	var old_wp = this.whitePoint;
+
+	this.whitePoint = src_w;
+	var wp_src = this.getWhitePoint();
+
+	this.whitePoint = dst_w;
+	var wp_dst = this.getWhitePoint();
+
+	this.whitePoint = old_wp;
+
+
+	//
+	// get a transformation matricies
+	//
+
+	switch(this.chromaticAdaptationAlg){
+		case 'xyz_scaling':
+			var ma = [[1,0,0],[0,1,0],[0,0,1]];
+			var mai = [[1,0,0],[0,1,0],[0,0,1]];
+			break;
+		case 'bradford':
+			var ma = [[0.8951, -0.7502, 0.0389],[0.2664, 1.7135, -0.0685],[-0.1614, 0.0367, 1.0296]];
+			var mai = [[0.986993, 0.432305, -0.008529],[-0.147054, 0.518360, 0.040043],[0.159963, 0.049291, 0.968487]];
+			break;
+		case 'von_kries':
+			var ma = [[0.40024, -0.22630, 0.00000],[0.70760, 1.16532, 0.00000],[-0.08081, 0.04570, 0.91822]]
+			var mai = [[1.859936, 0.361191, 0.000000],[-1.129382, 0.638812, 0.000000],[0.219897, -0.000006, 1.089064]]
+			break;
+		default:
+			dojo.debug(&quot;The &quot;+this.chromaticAdaptationAlg+&quot; chromatic adaptation algorithm matricies are not defined&quot;);
+	}
+
+
+	//
+	// calculate the cone response domains
+	//
+
+	var domain_src = dojo.math.matrix.multiply( [[wp_src.x, wp_src.y, wp_src.z]], ma);
+	var domain_dst = dojo.math.matrix.multiply( [[wp_dst.x, wp_dst.y, wp_dst.z]], ma);
+
+
+	//
+	// construct the centre matrix
+	//
+
+	var centre = [
+		[domain_dst[0][0]/domain_src[0][0], 0, 0],
+		[0, domain_dst[0][1]/domain_src[0][1], 0],
+		[0, 0, domain_dst[0][2]/domain_src[0][2]]
+	];
+
+
+	//
+	// caclulate 'm'
+	//
+
+	var m = dojo.math.matrix.multiply( dojo.math.matrix.multiply( ma, centre ), mai );
+
+
+	//
+	// construct source color matrix
+	//
+
+	var dst = dojo.math.matrix.multiply( [[ col.X, col.Y, col.Z ]], m );
+
+	return dst[0];
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////
+
+dojo.graphics.Colorspace.prototype.getRGB_XYZ_Matrix = function(){
+
+	var wp = this.getWhitePoint();
+	var pr = this.getPrimaries();
+
+	var Xr = pr.xr / pr.yr;
+	var Yr = 1;
+	var Zr = (1 - pr.xr - pr.yr) / pr.yr;
+
+	var Xg = pr.xg / pr.yg;
+	var Yg = 1;
+	var Zg = (1 - pr.xg - pr.yg) / pr.yg;
+
+	var Xb = pr.xb / pr.yb;
+	var Yb = 1;
+	var Zb = (1 - pr.xb - pr.yb) / pr.yb;
+
+	var m1 = [[Xr, Yr, Zr],[Xg, Yg, Zg],[Xb, Yb, Zb]];
+	var m2 = [[wp.X, wp.Y, wp.Z]];
+	var sm = dojo.math.matrix.multiply(m2, dojo.math.matrix.inverse(m1));
+
+	var Sr = sm[0][0];
+	var Sg = sm[0][1];
+	var Sb = sm[0][2];
+
+	var m4 = [[Sr*Xr, Sr*Yr, Sr*Zr],
+		  [Sg*Xg, Sg*Yg, Sg*Zg],
+		  [Sb*Xb, Sb*Yb, Sb*Zb]];
+
+	return m4;
+}
+
+dojo.graphics.Colorspace.prototype.getXYZ_RGB_Matrix = function(){
+
+	var m = this.getRGB_XYZ_Matrix();
+
+	return dojo.math.matrix.inverse(m);
+}
+
+dojo.graphics.Colorspace.prototype.XYZ_to_Luv = function(){
+
+	var src = this.munge('XYZ', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var ud = (4 * src.X) / (src.X + 15 * src.Y + 3 * src.Z);
+	var vd = (9 * src.Y) / (src.X + 15 * src.Y + 3 * src.Z);
+
+	var udr = (4 * wp.X) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+	var vdr = (9 * wp.Y) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+
+	var yr = src.Y / wp.Y;
+
+	var L = (yr &gt; this.epsilon()) ? 116 * Math.pow(yr, 1/3) - 16 : this.kappa() * yr;
+	var u = 13 * L * (ud-udr);
+	var v = 13 * L * (vd-vdr);
+
+	return [L, u, v];
+}
+
+dojo.graphics.Colorspace.prototype.Luv_to_XYZ = function(){
+
+	var src = this.munge('Luv', arguments);
+
+	var wp = this.getWhitePoint();
+
+	var uz = (4 * wp.X) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+	var vz = (9 * wp.Y) / (wp.X + 15 * wp.Y + 3 * wp.Z);
+
+	var Y = (src.L &gt; this.kappa() * this.epsilon()) ? Math.pow((src.L + 16) / 116, 3) : src.L / this.kappa();
+
+	var a = (1 / 3) * (((52 * src.L) / (src.u + 13 * src.L * uz)) - 1);
+	var b = -5 * Y;
+	var c = - (1 / 3);
+	var d = Y * (((39 * src.L) / (src.v + 13 * src.L * vz)) - 5);
+
+	var X = (d - b) / (a - c);
+	var Z = X * a + b;
+
+	return [X, Y, Z];
+}
+
+dojo.graphics.Colorspace.prototype.Luv_to_LCHuv = function(){
+
+	var src = this.munge('Luv', arguments);
+
+	var L = src.L;
+	var C = Math.pow(src.u * src.u + src.v * src.v, 0.5);
+	var H = Math.atan2(src.v, src.u) * (180 / Math.PI);
+
+	if (H &lt; 0){ H += 360; }
+	if (H &gt; 360){ H -= 360; }
+
+	return [L, C, H];
+}
+
+dojo.graphics.Colorspace.prototype.LCHuv_to_Luv = function(){
+
+	var src = this.munge('LCH', arguments);
+
+	var H_rad = src.H * (Math.PI / 180);
+
+	var L = src.L;
+	var u = src.C / Math.pow(Math.pow(Math.tan(H_rad), 2) + 1, 0.5);
+	var v = Math.pow(src.C * src.C - u * u, 0.5);
+
+	if ((90 &lt; src.H) &amp;&amp; (src.H &lt; 270)){ u *= -1; }
+	if (src.H &gt; 180){ v *= -1; }
+
+	return [L, u, v];
+}
+
+dojo.graphics.Colorspace.colorTemp_to_whitePoint = function(T){
+
+	if (T &lt; 4000){
+		dojo.debug(&quot;Can't find a white point for temperatures under 4000K&quot;);
+		return [0,0];
+	}
+
+	if (T &gt; 25000){
+		dojo.debug(&quot;Can't find a white point for temperatures over 25000K&quot;);
+		return [0,0];
+	}
+
+	var T1 = T;
+	var T2 = T * T;
+	var T3 = T2 * T;
+
+	var ten9 = Math.pow(10, 9);
+	var ten6 = Math.pow(10, 6);
+	var ten3 = Math.pow(10, 3);
+
+	if (T &lt;= 7000){
+
+		var x = (-4.6070 * ten9 / T3) + (2.9678 * ten6 / T2) + (0.09911 * ten3 / T) + 0.244063;
+	}else{
+		var x = (-2.0064 * ten9 / T3) + (1.9018 * ten6 / T2) + (0.24748 * ten3 / T) + 0.237040;
+	}
+
+	var y = -3.000 * x * x + 2.870 * x - 0.275;
+
+	return [x, y];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_CMY = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	var C = 1 - src.R;
+	var M = 1 - src.G;
+	var Y = 1 - src.B;
+
+	return [C, M, Y];
+}
+
+dojo.graphics.Colorspace.prototype.CMY_to_RGB = function(){
+
+	var src = this.munge('CMY', arguments);
+
+	var R = 1 - src.C;
+	var G = 1 - src.M;
+	var B = 1 - src.Y;
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_CMYK = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	var K = Math.min(1-src.R, 1-src.G, 1-src.B);
+	var C = (1 - src.R - K) / (1 - K);
+	var M = (1 - src.G - K) / (1 - K);
+	var Y = (1 - src.B - K) / (1 - K);
+
+	return [C, M, Y, K];
+}
+
+dojo.graphics.Colorspace.prototype.CMYK_to_RGB = function(){
+
+	var src = this.munge('CMYK', arguments);
+
+	var R = 1 - Math.min(1, src.C * (1-src.K) + src.K);
+	var G = 1 - Math.min(1, src.M * (1-src.K) + src.K);
+	var B = 1 - Math.min(1, src.Y * (1-src.K) + src.K);
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.CMY_to_CMYK = function(){
+
+	var src = this.munge('CMY', arguments);
+
+	var K = Math.min(src.C, src.M, src.Y);
+	var C = (src.C - K) / (1 - K);
+	var M = (src.M - K) / (1 - K);
+	var Y = (src.Y - K) / (1 - K);
+
+	return [C, M, Y, K];
+}
+
+dojo.graphics.Colorspace.prototype.CMYK_to_CMY = function(){
+
+	var src = this.munge('CMYK', arguments);
+
+	var C = Math.min(1, src.C * (1-src.K) + src.K);
+	var M = Math.min(1, src.M * (1-src.K) + src.K);
+	var Y = Math.min(1, src.Y * (1-src.K) + src.K);
+
+	return [C, M, Y];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_HSV = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	// Based on C Code in &quot;Computer Graphics -- Principles and Practice,&quot;
+	// Foley et al, 1996, p. 592. 
+
+	var min = Math.min(src.R, src.G, src.B);
+	var V = Math.max(src.R, src.G, src.B);
+
+	var delta = V - min;
+
+	var H = null;
+	var S = (V == 0) ? 0 : delta / V;
+
+	if (S == 0){
+		H = 0;
+	}else{
+		if (src.R == V){
+			H = 60 * (src.G - src.B) / delta;
+		}else{
+			if (src.G == V){
+				H = 120 + 60 * (src.B - src.R) / delta;
+			}else{
+				if (src.B == V){
+					// between magenta and cyan
+					H = 240 + 60 * (src.R - src.G) / delta;
+				}
+			}
+		}
+		if (H &lt; 0){
+			H += 360;
+		}
+	}
+
+	H = (H == 0) ? 360 : H;
+
+	return [H, S, V];
+}
+
+dojo.graphics.Colorspace.prototype.HSV_to_RGB = function(){
+ 
+	var src = this.munge('HSV', arguments);
+
+	if (src.H == 360){ src.H = 0;}
+
+	// Based on C Code in &quot;Computer Graphics -- Principles and Practice,&quot;
+	// Foley et al, 1996, p. 593.
+
+	var r = null;
+	var g = null;
+	var b = null;
+
+	if (src.S == 0){
+		// color is on black-and-white center line
+		// achromatic: shades of gray
+		var R = src.V;
+		var G = src.V;
+		var B = src.V;
+	}else{
+		// chromatic color
+		var hTemp = src.H / 60;		// h is now IN [0,6]
+		var i = Math.floor(hTemp);	// largest integer &lt;= h
+		var f = hTemp - i;		// fractional part of h
+
+		var p = src.V * (1 - src.S);
+		var q = src.V * (1 - (src.S * f));
+		var t = src.V * (1 - (src.S * (1 - f)));
+
+		switch(i){
+			case 0: R = src.V; G = t    ; B = p    ; break;
+			case 1: R = q    ; G = src.V; B = p    ; break;
+			case 2: R = p    ; G = src.V; B = t    ; break;
+			case 3: R = p    ; G = q    ; B = src.V; break;
+			case 4: R = t    ; G = p    ; B = src.V; break;
+			case 5: R = src.V; G = p    ; B = q    ; break;
+		}
+	}
+
+	return [R, G, B];
+}
+
+dojo.graphics.Colorspace.prototype.RGB_to_HSL = function(){
+
+	var src = this.munge('RGB', arguments);
+
+	//
+	// based on C code from <A HREF="http://astronomy.swin.edu.au/~pbourke/colour/hsl/">http://astronomy.swin.edu.au/~pbourke/colour/hsl/</A>
+	//
+
+
+	var min = Math.min(src.R, src.G, src.B);
+	var max = Math.max(src.R, src.G, src.B);
+	var delta = max - min;
+
+	var H = 0;
+	var S = 0;
+	var L = (min + max) / 2;
+
+	if ((L &gt; 0) &amp;&amp; (L &lt; 1)){
+		S = delta / ((L &lt; 0.5) ? (2 * L) : (2 - 2 * L));
+	}
+
+	if (delta &gt; 0) {
+		if ((max == src.R) &amp;&amp; (max != src.G)){
+			H += (src.G - src.B) / delta;
+		}
+		if ((max == src.G) &amp;&amp; (max != src.B)){
+			H += (2 + (src.B - src.R) / delta);
+		}
+		if ((max == src.B) &amp;&amp; (max != src.R)){
+			H += (4 + (src.R - src.G) / delta);
+		}
+		H *= 60;
+	}
+
+	H = (H == 0) ? 360 : H;
+
+	return [H, S, L];
+}
+
+dojo.graphics.Colorspace.prototype.HSL_to_RGB = function(){
+ 
+	var src = this.munge('HSL', arguments);
+
+	//
+	// based on C code from <A HREF="http://astronomy.swin.edu.au/~pbourke/colour/hsl/">http://astronomy.swin.edu.au/~pbourke/colour/hsl/</A>
+	//
+
+	while (src.H &lt; 0){ src.H += 360; }
+	while (src.H &gt;= 360){ src.H -= 360; }
+
+	var R = 0;
+	var G = 0;
+	var B = 0;
+
+	if (src.H &lt; 120){
+		R = (120 - src.H) / 60;
+		G = src.H / 60;
+		B = 0;
+	}else if (src.H &lt; 240){
+		R = 0;
+		G = (240 - src.H) / 60;
+		B = (src.H - 120) / 60;
+	}else{
+		R = (src.H - 240) / 60;
+		G = 0;
+		B = (360 - src.H) / 60;
+	}
+
+	R = 2 * src.S * Math.min(R, 1) + (1 - src.S);
+	G = 2 * src.S * Math.min(G, 1) + (1 - src.S);
+	B = 2 * src.S * Math.min(B, 1) + (1 - src.S);
+
+	if (src.L &lt; 0.5){
+		R = src.L * R;
+		G = src.L * G;
+		B = src.L * B;
+	}else{
+		R = (1 - src.L) * R + 2 * src.L - 1;
+		G = (1 - src.L) * G + 2 * src.L - 1;
+		B = (1 - src.L) * B + 2 * src.L - 1;
+	}
+
+	return [R, G, B];
+}

Added: trunk/root/static/magic/src/graphics/__package__.js
===================================================================
--- trunk/root/static/magic/src/graphics/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/graphics/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	browser:	[&quot;dojo.graphics.htmlEffects&quot;],
+	dashboard:	[&quot;dojo.graphics.htmlEffects&quot;]
+});
+dojo.provide(&quot;dojo.graphics.*&quot;);

Added: trunk/root/static/magic/src/graphics/color/hsl.js
===================================================================
--- trunk/root/static/magic/src/graphics/color/hsl.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/graphics/color/hsl.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,144 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.graphics.color.hsl&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+
+dojo.lang.extend(dojo.graphics.color.Color, {
+
+	toHsl: function() {
+		return dojo.graphics.color.rgb2hsl(this.toRgb());
+	}
+});
+
+dojo.graphics.color.rgb2hsl = function(r, g, b){
+
+	if (dojo.lang.isArray(r)) {
+		b = r[2] || 0;
+		g = r[1] || 0;
+		r = r[0] || 0;
+	}
+
+	r /= 255;
+	g /= 255;
+	b /= 255;
+
+	//
+	// based on C code from <A HREF="http://astronomy.swin.edu.au/~pbourke/colour/hsl/">http://astronomy.swin.edu.au/~pbourke/colour/hsl/</A>
+	//
+
+	var h = null;
+	var s = null;
+	var l = null;
+
+
+	var min = Math.min(r, g, b);
+	var max = Math.max(r, g, b);
+	var delta = max - min;
+
+	l = (min + max) / 2;
+
+	s = 0;
+
+	if ((l &gt; 0) &amp;&amp; (l &lt; 1)){
+		s = delta / ((l &lt; 0.5) ? (2 * l) : (2 - 2 * l));
+	}
+
+	h = 0;
+
+	if (delta &gt; 0) {
+		if ((max == r) &amp;&amp; (max != g)){
+			h += (g - b) / delta;
+		}
+		if ((max == g) &amp;&amp; (max != b)){
+			h += (2 + (b - r) / delta);
+		}
+		if ((max == b) &amp;&amp; (max != r)){
+			h += (4 + (r - g) / delta);
+		}
+		h *= 60;
+	}
+
+	h = (h == 0) ? 360 : Math.ceil((h / 360) * 255);
+	s = Math.ceil(s * 255);
+	l = Math.ceil(l * 255);
+
+	return [h, s, l];
+}
+
+dojo.graphics.color.hsl2rgb = function(h, s, l){
+ 
+	if (dojo.lang.isArray(h)) {
+		l = h[2] || 0;
+		s = h[1] || 0;
+		h = h[0] || 0;
+	}
+
+	h = (h / 255) * 360;
+	if (h == 360){ h = 0;}
+	s = s / 255;
+	l = l / 255;
+
+	//
+	// based on C code from <A HREF="http://astronomy.swin.edu.au/~pbourke/colour/hsl/">http://astronomy.swin.edu.au/~pbourke/colour/hsl/</A>
+	//
+
+
+	while (h &lt; 0){ h += 360; }
+	while (h &gt; 360){ h -= 360; }
+	var r, g, b;
+	if (h &lt; 120){
+		r = (120 - h) / 60;
+		g = h / 60;
+		b = 0;
+	}else if (h &lt; 240){
+		r = 0;
+		g = (240 - h) / 60;
+		b = (h - 120) / 60;
+	}else{
+		r = (h - 240) / 60;
+		g = 0;
+		b = (360 - h) / 60;
+	}
+
+	r = Math.min(r, 1);
+	g = Math.min(g, 1);
+	b = Math.min(b, 1);
+
+	r = 2 * s * r + (1 - s);
+	g = 2 * s * g + (1 - s);
+	b = 2 * s * b + (1 - s);
+
+	if (l &lt; 0.5){
+		r = l * r;
+		g = l * g;
+		b = l * b;
+	}else{
+		r = (1 - l) * r + 2 * l - 1;
+		g = (1 - l) * g + 2 * l - 1;
+		b = (1 - l) * b + 2 * l - 1;
+	}
+
+	r = Math.ceil(r * 255);
+	g = Math.ceil(g * 255);
+	b = Math.ceil(b * 255);
+
+	return [r, g, b];
+}
+
+dojo.graphics.color.hsl2hex = function(h, s, l){
+	var rgb = dojo.graphics.color.hsl2rgb(h, s, l);
+	return dojo.graphics.color.rgb2hex(rgb[0], rgb[1], rgb[2]);
+}
+
+dojo.graphics.color.hex2hsl = function(hex){
+	var rgb = dojo.graphics.color.hex2rgb(hex);
+	return dojo.graphics.color.rgb2hsl(rgb[0], rgb[1], rgb[2]);
+}

Added: trunk/root/static/magic/src/graphics/color/hsv.js
===================================================================
--- trunk/root/static/magic/src/graphics/color/hsv.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/graphics/color/hsv.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,141 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.graphics.color.hsv&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+
+dojo.lang.extend(dojo.graphics.color.Color, {
+
+	toHsv: function() {
+		return dojo.graphics.color.rgb2hsv(this.toRgb());
+	}
+
+});
+
+dojo.graphics.color.rgb2hsv = function(r, g, b){
+
+	if (dojo.lang.isArray(r)) {
+		b = r[2] || 0;
+		g = r[1] || 0;
+		r = r[0] || 0;
+	}
+
+	// r,g,b, each 0 to 255, to HSV.
+	// h = 0.0 to 360.0 (corresponding to 0..360.0 degrees around hexcone)
+	// s = 0.0 (shade of gray) to 1.0 (pure color)
+	// v = 0.0 (black) to 1.0 {white)
+	//
+	// Based on C Code in &quot;Computer Graphics -- Principles and Practice,&quot;
+	// Foley et al, 1996, p. 592. 
+	//
+	// our calculatuions are based on 'regular' values (0-360, 0-1, 0-1) 
+	// but we return bytes values (0-255, 0-255, 0-255)
+
+	var h = null;
+	var s = null;
+	var v = null;
+
+	var min = Math.min(r, g, b);
+	v = Math.max(r, g, b);
+
+	var delta = v - min;
+
+	// calculate saturation (0 if r, g and b are all 0)
+
+	s = (v == 0) ? 0 : delta/v;
+
+	if (s == 0){
+		// achromatic: when saturation is, hue is undefined
+		h = 0;
+	}else{
+		// chromatic
+		if (r == v){
+			// between yellow and magenta
+			h = 60 * (g - b) / delta;
+		}else{
+			if (g == v){
+				// between cyan and yellow
+				h = 120 + 60 * (b - r) / delta;
+			}else{
+				if (b == v){
+					// between magenta and cyan
+					h = 240 + 60 * (r - g) / delta;
+				}
+			}
+		}
+		if (h &lt; 0){
+			h += 360;
+		}
+	}
+
+
+	h = (h == 0) ? 360 : Math.ceil((h / 360) * 255);
+	s = Math.ceil(s * 255);
+
+	return [h, s, v];
+}
+
+dojo.graphics.color.hsv2rgb = function(h, s, v){
+ 
+	if (dojo.lang.isArray(h)) {
+		v = h[2] || 0;
+		s = h[1] || 0;
+		h = h[0] || 0;
+	}
+
+	h = (h / 255) * 360;
+	if (h == 360){ h = 0;}
+
+	s = s / 255;
+	v = v / 255;
+
+	// Based on C Code in &quot;Computer Graphics -- Principles and Practice,&quot;
+	// Foley et al, 1996, p. 593.
+	//
+	// H = 0.0 to 360.0 (corresponding to 0..360 degrees around hexcone) 0 for S = 0
+	// S = 0.0 (shade of gray) to 1.0 (pure color)
+	// V = 0.0 (black) to 1.0 (white)
+
+	var r = null;
+	var g = null;
+	var b = null;
+
+	if (s == 0){
+		// color is on black-and-white center line
+		// achromatic: shades of gray
+		r = v;
+		g = v;
+		b = v;
+	}else{
+		// chromatic color
+		var hTemp = h / 60;		// h is now IN [0,6]
+		var i = Math.floor(hTemp);	// largest integer &lt;= h
+		var f = hTemp - i;		// fractional part of h
+
+		var p = v * (1 - s);
+		var q = v * (1 - (s * f));
+		var t = v * (1 - (s * (1 - f)));
+
+		switch(i){
+			case 0: r = v; g = t; b = p; break;
+			case 1: r = q; g = v; b = p; break;
+			case 2: r = p; g = v; b = t; break;
+			case 3: r = p; g = q; b = v; break;
+			case 4: r = t; g = p; b = v; break;
+			case 5: r = v; g = p; b = q; break;
+		}
+	}
+
+	r = Math.ceil(r * 255);
+	g = Math.ceil(g * 255);
+	b = Math.ceil(b * 255);
+
+	return [r, g, b];
+}

Added: trunk/root/static/magic/src/graphics/color.js
===================================================================
--- trunk/root/static/magic/src/graphics/color.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/graphics/color.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,166 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+
+// TODO: rewrite the &quot;x2y&quot; methods to take advantage of the parsing
+//       abilities of the Color object. Also, beef up the Color
+//       object (as possible) to parse most common formats
+
+// takes an r, g, b, a(lpha) value, [r, g, b, a] array, &quot;rgb(...)&quot; string, hex string (#aaa, #aaaaaa, aaaaaaa)
+dojo.graphics.color.Color = function(r, g, b, a) {
+	// dojo.debug(&quot;r:&quot;, r[0], &quot;g:&quot;, r[1], &quot;b:&quot;, r[2]);
+	if(dojo.lang.isArray(r)) {
+		this.r = r[0];
+		this.g = r[1];
+		this.b = r[2];
+		this.a = r[3]||1.0;
+	} else if(dojo.lang.isString(r)) {
+		var rgb = dojo.graphics.color.extractRGB(r);
+		this.r = rgb[0];
+		this.g = rgb[1];
+		this.b = rgb[2];
+		this.a = g||1.0;
+	} else if(r instanceof dojo.graphics.color.Color) {
+		this.r = r.r;
+		this.b = r.b;
+		this.g = r.g;
+		this.a = r.a;
+	} else {
+		this.r = r;
+		this.g = g;
+		this.b = b;
+		this.a = a;
+	}
+}
+
+dojo.graphics.color.Color.fromArray = function(arr) {
+	return new dojo.graphics.color.Color(arr[0], arr[1], arr[2], arr[3]);
+}
+
+dojo.lang.extend(dojo.graphics.color.Color, {
+	toRgb: function(includeAlpha) {
+		if(includeAlpha) {
+			return this.toRgba();
+		} else {
+			return [this.r, this.g, this.b];
+		}
+	},
+
+	toRgba: function() {
+		return [this.r, this.g, this.b, this.a];
+	},
+
+	toHex: function() {
+		return dojo.graphics.color.rgb2hex(this.toRgb());
+	},
+
+	toCss: function() {
+		return &quot;rgb(&quot; + this.toRgb().join() + &quot;)&quot;;
+	},
+
+	toString: function() {
+		return this.toHex(); // decent default?
+	},
+
+	blend: function(color, weight) {
+		return dojo.graphics.color.blend(this.toRgb(), new dojo.graphics.color.Color(color).toRgb(), weight);
+	}
+});
+
+dojo.graphics.color.named = {
+	white:      [255,255,255],
+	black:      [0,0,0],
+	red:        [255,0,0],
+	green:	    [0,255,0],
+	blue:       [0,0,255],
+	navy:       [0,0,128],
+	gray:       [128,128,128],
+	silver:     [192,192,192]
+};
+
+// blend colors a and b (both as RGB array or hex strings) with weight from -1 to +1, 0 being a 50/50 blend
+dojo.graphics.color.blend = function(a, b, weight) {
+	if(typeof a == &quot;string&quot;) { return dojo.graphics.color.blendHex(a, b, weight); }
+	if(!weight) { weight = 0; }
+	else if(weight &gt; 1) { weight = 1; }
+	else if(weight &lt; -1) { weight = -1; }
+	var c = new Array(3);
+	for(var i = 0; i &lt; 3; i++) {
+		var half = Math.abs(a[i] - b[i])/2;
+		c[i] = Math.floor(Math.min(a[i], b[i]) + half + (half * weight));
+	}
+	return c;
+}
+
+// very convenient blend that takes and returns hex values
+// (will get called automatically by blend when blend gets strings)
+dojo.graphics.color.blendHex = function(a, b, weight) {
+	return dojo.graphics.color.rgb2hex(dojo.graphics.color.blend(dojo.graphics.color.hex2rgb(a), dojo.graphics.color.hex2rgb(b), weight));
+}
+
+// get RGB array from css-style color declarations
+dojo.graphics.color.extractRGB = function(color) {
+	var hex = &quot;0123456789abcdef&quot;;
+	color = color.toLowerCase();
+	if( color.indexOf(&quot;rgb&quot;) == 0 ) {
+		var matches = color.match(/rgba*\((\d+), *(\d+), *(\d+)/i);
+		var ret = matches.splice(1, 3);
+		return ret;
+	} else {
+		var colors = dojo.graphics.color.hex2rgb(color);
+		if(colors) {
+			return colors;
+		} else {
+			// named color (how many do we support?)
+			return dojo.graphics.color.named[color] || [255, 255, 255];
+		}
+	}
+}
+
+dojo.graphics.color.hex2rgb = function(hex) {
+	var hexNum = &quot;0123456789ABCDEF&quot;;
+	var rgb = new Array(3);
+	if( hex.indexOf(&quot;#&quot;) == 0 ) { hex = hex.substring(1); }
+	hex = hex.toUpperCase();
+	if(hex.replace(new RegExp(&quot;[&quot;+hexNum+&quot;]&quot;, &quot;g&quot;), &quot;&quot;) != &quot;&quot;) {
+		return null;
+	}
+	if( hex.length == 3 ) {
+		rgb[0] = hex.charAt(0) + hex.charAt(0)
+		rgb[1] = hex.charAt(1) + hex.charAt(1)
+		rgb[2] = hex.charAt(2) + hex.charAt(2);
+	} else {
+		rgb[0] = hex.substring(0, 2);
+		rgb[1] = hex.substring(2, 4);
+		rgb[2] = hex.substring(4);
+	}
+	for(var i = 0; i &lt; rgb.length; i++) {
+		rgb[i] = hexNum.indexOf(rgb[i].charAt(0)) * 16 + hexNum.indexOf(rgb[i].charAt(1));
+	}
+	return rgb;
+}
+
+dojo.graphics.color.rgb2hex = function(r, g, b) {
+	if(dojo.lang.isArray(r)) {
+		g = r[1] || 0;
+		b = r[2] || 0;
+		r = r[0] || 0;
+	}
+	var ret = dojo.lang.map([r, g, b], function(x) {
+		x = new Number(x);
+		var s = x.toString(16);
+		while(s.length &lt; 2) { s = &quot;0&quot; + s; }
+		return s;
+	});
+	ret.unshift(&quot;#&quot;);
+	return ret.join(&quot;&quot;);
+}

Added: trunk/root/static/magic/src/hostenv_adobesvg.js
===================================================================
--- trunk/root/static/magic/src/hostenv_adobesvg.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_adobesvg.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,571 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+ * Adobe SVG Viewer host environment
+ */
+if(typeof window == 'undefined'){
+	dojo.raise(&quot;attempt to use adobe svg hostenv when no window object&quot;);
+}
+
+with(dojo.render){
+	name = navigator.appName;
+	ver = parseFloat(navigator.appVersion, 10);
+	switch(navigator.platform){
+		case &quot;MacOS&quot;:
+			os.osx =  true;
+			break;
+		case &quot;Linux&quot;:
+			os.linux =  true;
+			break;
+		case &quot;Windows&quot;:
+			os.win =  true;
+			break;
+		default:
+			os.linux = true;
+			break;
+	};
+	svg.capable = true;
+	svg.support.builtin = true;
+	svg.adobe = true;
+};
+
+// browserEval(&quot;alert(window.location);&quot;);
+
+dojo.hostenv.println = function(s){
+	try{
+    // FIXME: this may not work with adobe's viewer, as we may first need a 
+		// reference to the svgDocument
+		// FIXME: need a way to determine where to position the text for this
+    var ti = document.createElement(&quot;text&quot;);
+    ti.setAttribute(&quot;x&quot;,&quot;50&quot;);
+		var yPos = 25 + 15*document.getElementsByTagName(&quot;text&quot;).length;
+    ti.setAttribute(&quot;y&quot;,yPos);
+		var tn = document.createTextNode(s);
+		ti.appendChild(tn);
+		document.documentElement.appendChild(ti);
+	}catch(e){
+
+	}
+}
+
+dojo.debug = function() {
+	if (!djConfig.isDebug) { return; }
+	var args = arguments;
+	if(typeof dojo.hostenv.println != 'function'){
+		dojo.raise(&quot;attempt to call dojo.debug when there is no dojo.hostenv println implementation (yet?)&quot;);
+	}
+	var isJUM = dj_global[&quot;jum&quot;];
+	var s = isJUM ? &quot;&quot;: &quot;DEBUG: &quot;;
+	for(var i=0;i&lt;args.length;++i){ s += args[i]; }
+	if(isJUM){ // this seems to be the only way to get JUM to &quot;play nice&quot;
+		jum.debug(s);
+	}else{
+		dojo.hostenv.println(s);
+	}
+}
+
+dojo.hostenv.startPackage(&quot;dojo.hostenv&quot;);
+
+dojo.hostenv.name_ = 'adobesvg';
+
+dojo.hostenv.anonCtr = 0;
+dojo.hostenv.anon = {};
+
+dojo.hostenv.nameAnonFunc = function(anonFuncPtr, namespaceObj){
+	var ret = &quot;_&quot;+this.anonCtr++;
+	var nso = (namespaceObj || this.anon);
+	while(typeof nso[ret] != &quot;undefined&quot;){
+		ret = &quot;_&quot;+this.anonCtr++;
+	}
+	nso[ret] = anonFuncPtr;
+	return ret;
+}
+
+dojo.hostenv.modulesLoadedFired = false;
+dojo.hostenv.modulesLoadedListeners = [];
+dojo.hostenv.getTextStack = [];
+dojo.hostenv.loadUriStack = [];
+dojo.hostenv.loadedUris = [];
+
+
+dojo.hostenv.modulesLoaded = function(){
+	if(this.modulesLoadedFired){ return; }
+	if((this.loadUriStack.length==0)&amp;&amp;(this.getTextStack.length==0)){
+		if(this.inFlightCount &gt; 0){ 
+			dojo.debug(&quot;couldn't initialize, there are files still in flight&quot;);
+			return;
+		}
+		this.modulesLoadedFired = true;
+		var mll = this.modulesLoadedListeners;
+		for(var x=0; x&lt;mll.length; x++){
+			mll[x]();
+		}
+	}
+}
+
+dojo.hostenv.getNewAnonFunc = function(){
+	var ret = &quot;_&quot;+this.anonCtr++;
+	while(typeof this.anon[ret] != &quot;undefined&quot;){
+		ret = &quot;_&quot;+this.anonCtr++;
+	}
+	// this.anon[ret] = function(){};
+	eval(&quot;dojo.nostenv.anon.&quot;+ret+&quot; = function(){};&quot;);
+	return [ret, this.anon[ret]];
+}
+
+dojo.hostenv.displayStack = function(){
+	var oa = [];
+	var stack = this.loadUriStack;
+	for(var x=0; x&lt;stack.length; x++){
+		oa.unshift([stack[x][0], (typeof stack[x][2])]);
+	}
+	dojo.debug(&quot;&lt;pre&gt;&quot;+oa.join(&quot;\n&quot;)+&quot;&lt;/pre&gt;&quot;);
+}
+
+dojo.hostenv.unwindUriStack = function(){
+	var stack = this.loadUriStack;
+	for(var x in dojo.hostenv.loadedUris){
+		for(var y=stack.length-1; y&gt;=0; y--){
+			if(stack[y][0]==x){
+				stack.splice(y, 1);
+			}
+		}
+	}
+	var next = stack.pop();
+	if((!next)&amp;&amp;(stack.length==0)){ 
+		return;
+	}
+	for(var x=0; x&lt;stack.length; x++){
+		if((stack[x][0]==next[0])&amp;&amp;(stack[x][2])){
+			next[2] == stack[x][2]
+		}
+	}
+	var last = next;
+	while(dojo.hostenv.loadedUris[next[0]]){
+		last = next;
+		next = stack.pop();
+	}
+	while(typeof next[2] == &quot;string&quot;){ // unwind as far as we can
+		try{
+			// dojo.debug(&quot;&lt;pre&gt;&lt;![CDATA[&quot;+next[2]+&quot;]]&gt;&lt;/pre&gt;&quot;);
+			dj_eval(next[2]);
+			next[1](true);
+		}catch(e){
+			dojo.debug(&quot;we got an error when loading &quot;+next[0]);
+			dojo.debug(&quot;error: &quot;+e);
+			// for(var x in e){ alert(x+&quot; &quot;+e[x]); }
+		}
+		dojo.hostenv.loadedUris[next[0]] = true;
+		dojo.hostenv.loadedUris.push(next[0]);
+		last = next;
+		next = stack.pop();
+		if((!next)&amp;&amp;(stack.length==0)){ break; }
+		while(dojo.hostenv.loadedUris[next[0]]){
+			last = next;
+			next = stack.pop();
+		}
+	}
+	if(next){
+		stack.push(next);
+		dojo.debug(&quot;### CHOKED ON: &quot;+next[0]);
+	}
+}
+
+/**
+ * Reads the contents of the URI, and evaluates the contents.
+ * Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.
+ * The result of the eval is not available to the caller.
+ */
+dojo.hostenv.loadUri = function(uri, cb){
+	if(dojo.hostenv.loadedUris[uri]){
+		return;
+	}
+	var stack = this.loadUriStack;
+	stack.push([uri, cb, null]);
+	var tcb = function(contents){
+		// gratuitous hack for Adobe SVG 3, what a fucking POS
+		if(contents.content){
+			contents = contents.content;
+		}
+
+		// stack management
+		var next = stack.pop();
+		if((!next)&amp;&amp;(stack.length==0)){ 
+			dojo.hostenv.modulesLoaded();
+			return;
+		}
+		if(typeof contents == &quot;string&quot;){
+			stack.push(next);
+			for(var x=0; x&lt;stack.length; x++){
+				if(stack[x][0]==uri){
+					stack[x][2] = contents;
+				}
+			}
+			next = stack.pop();
+		}
+		if(dojo.hostenv.loadedUris[next[0]]){ 
+			// dojo.debug(&quot;WE ALREADY HAD: &quot;+next[0]);
+			dojo.hostenv.unwindUriStack();
+			return;
+		}
+		// push back onto stack
+		stack.push(next);
+		if(next[0]!=uri){
+			//  and then unwind as far as we can
+			if(typeof next[2] == &quot;string&quot;){
+				dojo.hostenv.unwindUriStack();
+			}
+
+		}else{
+			if(!contents){ 
+				next[1](false);
+			}else{
+				var deps = dojo.hostenv.getDepsForEval(next[2]);
+				if(deps.length&gt;0){
+					eval(deps.join(&quot;;&quot;));
+				}else{
+					dojo.hostenv.unwindUriStack();
+				}
+			}
+		}
+	}
+	this.getText(uri, tcb, true);
+}
+
+/**
+ * Reads the contents of the URI, and evaluates the contents.
+ * Returns true if it succeeded. Returns false if the URI reading failed. Throws if the evaluation throws.
+ * The result of the eval is not available to the caller.
+ */
+dojo.hostenv.loadUri = function(uri, cb){
+	if(dojo.hostenv.loadedUris[uri]){
+		return;
+	}
+	var stack = this.loadUriStack;
+	stack.push([uri, cb, null]);
+	var tcb = function(contents){
+		// gratuitous hack for Adobe SVG 3, what a fucking POS
+		if(contents.content){
+			contents = contents.content;
+		}
+
+		// stack management
+		var next = stack.pop();
+		if((!next)&amp;&amp;(stack.length==0)){ 
+			dojo.hostenv.modulesLoaded();
+			return;
+		}
+		if(typeof contents == &quot;string&quot;){
+			stack.push(next);
+			for(var x=0; x&lt;stack.length; x++){
+				if(stack[x][0]==uri){
+					stack[x][2] = contents;
+				}
+			}
+			next = stack.pop();
+		}
+		if(dojo.hostenv.loadedUris[next[0]]){ 
+			// dojo.debug(&quot;WE ALREADY HAD: &quot;+next[0]);
+			dojo.hostenv.unwindUriStack();
+			return;
+		}
+		// push back onto stack
+		stack.push(next);
+		if(next[0]!=uri){
+			//  and then unwind as far as we can
+			if(typeof next[2] == &quot;string&quot;){
+				dojo.hostenv.unwindUriStack();
+			}
+
+		}else{
+			if(!contents){ 
+				next[1](false);
+			}else{
+				var deps = dojo.hostenv.getDepsForEval(next[2]);
+				if(deps.length&gt;0){
+					eval(deps.join(&quot;;&quot;));
+				}else{
+					dojo.hostenv.unwindUriStack();
+				}
+			}
+		}
+	}
+	this.getText(uri, tcb, true);
+}
+
+/**
+* loadModule(&quot;A.B&quot;) first checks to see if symbol A.B is defined. 
+* If it is, it is simply returned (nothing to do).
+* If it is not defined, it will look for &quot;A/B.js&quot; in the script root directory, followed
+* by &quot;A.js&quot;.
+* It throws if it cannot find a file to load, or if the symbol A.B is not defined after loading.
+* It returns the object A.B.
+*
+* This does nothing about importing symbols into the current package.
+* It is presumed that the caller will take care of that. For example, to import
+* all symbols:
+*
+*    with (dojo.hostenv.loadModule(&quot;A.B&quot;)) {
+*       ...
+*    }
+*
+* And to import just the leaf symbol:
+*
+*    var B = dojo.hostenv.loadModule(&quot;A.B&quot;);
+*    ...
+*
+* dj_load is an alias for dojo.hostenv.loadModule
+*/
+dojo.hostenv.loadModule = function(modulename, exact_only, omit_module_check){
+	// alert(&quot;dojo.hostenv.loadModule('&quot;+modulename+&quot;');&quot;);
+	var module = this.findModule(modulename, 0);
+	if(module){
+		return module;
+	}
+
+	// dojo.debug(&quot;dojo.hostenv.loadModule('&quot;+modulename+&quot;');&quot;);
+
+	// protect against infinite recursion from mutual dependencies
+	if (typeof this.loading_modules_[modulename] !== 'undefined'){
+		// NOTE: this should never throw an exception!! &quot;recursive&quot; includes
+		// are normal in the course of app and module building, so blow out of
+		// it gracefully, but log it in debug mode
+
+		// dojo.raise(&quot;recursive attempt to load module '&quot; + modulename + &quot;'&quot;);
+		dojo.debug(&quot;recursive attempt to load module '&quot; + modulename + &quot;'&quot;);
+	}else{
+		this.addedToLoadingCount.push(modulename);
+	}
+	this.loading_modules_[modulename] = 1;
+
+
+	// convert periods to slashes
+	var relpath = modulename.replace(/\./g, '/') + '.js';
+
+	var syms = modulename.split(&quot;.&quot;);
+	var nsyms = modulename.split(&quot;.&quot;);
+	if(syms[0]==&quot;dojo&quot;){ // FIXME: need a smarter way to do this!
+		syms[0] = &quot;src&quot;; 
+	}
+	var last = syms.pop();
+	syms.push(last);
+	// figure out if we're looking for a full package, if so, we want to do
+	// things slightly diffrently
+	var _this = this;
+	var pfn = this.pkgFileName;
+	if(last==&quot;*&quot;){
+		modulename = (nsyms.slice(0, -1)).join('.');
+
+		var module = this.findModule(modulename, 0);
+		// dojo.debug(&quot;found: &quot;+modulename+&quot;=&quot;+module);
+		if(module){
+			_this.removedFromLoadingCount.push(modulename);
+			return module;
+		}
+
+		var nextTry = function(lastStatus){
+			if(lastStatus){ 
+				module = _this.findModule(modulename, false); // pass in false so we can give better error
+				if((!module)&amp;&amp;(syms[syms.length-1]!=pfn)){
+					dojo.raise(&quot;Module symbol '&quot; + modulename + &quot;' is not defined after loading '&quot; + relpath + &quot;'&quot;); 
+				}
+				if(module){
+					_this.removedFromLoadingCount.push(modulename);
+					dojo.hostenv.modulesLoaded();
+					return;
+				}
+			}
+			syms.pop();
+			syms.push(pfn);
+			// dojo.debug(&quot;syms: &quot;+syms);
+			relpath = syms.join(&quot;/&quot;) + '.js';
+			if(relpath.charAt(0)==&quot;/&quot;){
+				relpath = relpath.slice(1);
+			}
+			// dojo.debug(&quot;relpath: &quot;+relpath);
+			_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
+		}
+
+		nextTry();
+	}else{
+		relpath = syms.join(&quot;/&quot;) + '.js';
+		modulename = nsyms.join('.');
+
+		var nextTry = function(lastStatus){
+			// dojo.debug(&quot;lastStatus: &quot;+lastStatus);
+			if(lastStatus){ 
+				// dojo.debug(&quot;inital relpath: &quot;+relpath);
+				module = _this.findModule(modulename, false); // pass in false so we can give better error
+				// if(!module){
+				if((!module)&amp;&amp;(syms[syms.length-1]!=pfn)){
+					dojo.raise(&quot;Module symbol '&quot; + modulename + &quot;' is not defined after loading '&quot; + relpath + &quot;'&quot;); 
+				}
+				if(module){
+					_this.removedFromLoadingCount.push(modulename);
+					dojo.hostenv.modulesLoaded();
+					return;
+				}
+			}
+			var setPKG = (syms[syms.length-1]==pfn) ? false : true;
+			syms.pop();
+			if(setPKG){
+				syms.push(pfn);
+			}
+			relpath = syms.join(&quot;/&quot;) + '.js';
+			if(relpath.charAt(0)==&quot;/&quot;){
+				relpath = relpath.slice(1);
+			}
+			// dojo.debug(&quot;relpath: &quot;+relpath);
+			_this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
+		}
+
+		this.loadPath(relpath, ((!omit_module_check) ? modulename : null), nextTry);
+	}
+	return;
+}
+
+/**
+ * Read the contents of the specified uri and return those contents.
+ *
+ * FIXME: Make sure this is consistent with other implementations of getText
+ * @param uri A relative or absolute uri. If absolute, it still must be in the same &quot;domain&quot; as we are.
+ * @param async_cb If not specified, returns false as synchronous is not
+ * supported. If specified, load asynchronously, and use async_cb as the handler which receives the result of the request.
+ * @param fail_ok Default false. If fail_ok and !async_cb and loading fails, return null instead of throwing.
+ */ 
+dojo.hostenv.async_cb = null;
+
+dojo.hostenv.unWindGetTextStack = function(){
+	if(dojo.hostenv.inFlightCount&gt;0){
+		setTimeout(&quot;dojo.hostenv.unWindGetTextStack()&quot;, 100);
+		return;
+	}
+	// we serialize because this goddamned environment is too fucked up
+	// to know how to do anything else
+	dojo.hostenv.inFlightCount++;
+	var next = dojo.hostenv.getTextStack.pop();
+	if((!next)&amp;&amp;(dojo.hostenv.getTextStack.length==0)){ 
+		dojo.hostenv.inFlightCount--;
+		dojo.hostenv.async_cb = function(){};
+		return;
+	}
+	dojo.hostenv.async_cb = next[1];
+	// http = window.getURL(uri, dojo.hostenv.anon[cbn]);
+	window.getURL(next[0], function(result){ 
+		dojo.hostenv.inFlightCount--;
+		dojo.hostenv.async_cb(result.content);
+		dojo.hostenv.unWindGetTextStack();
+	});
+}
+
+dojo.hostenv.getText = function(uri, async_cb, fail_ok){
+	// dojo.debug(&quot;Calling getText()&quot;);
+	try{
+		if(async_cb){
+			dojo.hostenv.getTextStack.push([uri, async_cb, fail_ok]);
+			dojo.hostenv.unWindGetTextStack();
+		}else{
+			return dojo.raise(&quot;No synchronous XMLHTTP implementation available, for uri &quot; + uri);
+		}
+	}catch(e){
+		return dojo.raise(&quot;No XMLHTTP implementation available, for uri &quot; + uri);
+	}
+}
+
+
+/**
+ * Makes an async post to the specified uri.
+ *
+ * FIXME: Not sure that we need this, but adding for completeness.
+ * More details about the implementation of this are available at 
+ * <A HREF="http://wiki.svg.org/index.php/PostUrl">http://wiki.svg.org/index.php/PostUrl</A>
+ * @param uri A relative or absolute uri. If absolute, it still must be in the same &quot;domain&quot; as we are.
+ * @param async_cb If not specified, returns false as synchronous is not
+ * supported. If specified, load asynchronously, and use async_cb as the progress handler which takes the xmlhttp object as its argument. If async_cb, this function returns null.
+ * @param text Data to post
+ * @param fail_ok Default false. If fail_ok and !async_cb and loading fails, return null instead of throwing.
+ * @param mime_type optional MIME type of the posted data (such as &quot;text/plain&quot;)
+ * @param encoding optional encoding for data. null, 'gzip' and 'deflate' are possible values. If browser does not support binary post this parameter is ignored.
+ */ 
+dojo.hostenv.postText = function(uri, async_cb, text, fail_ok, mime_type, encoding){
+	var http = null;
+	
+	var async_callback = function(httpResponse){
+		if (!httpResponse.success) {
+			dojo.raise(&quot;Request for uri '&quot; + uri + &quot;' resulted in &quot; + httpResponse.status);
+		}
+		
+		if(!httpResponse.content) {
+			if (!fail_ok) dojo.raise(&quot;Request for uri '&quot; + uri + &quot;' resulted in no content&quot;);
+			return null;
+		}
+		// FIXME: wtf, I'm losing a reference to async_cb
+		async_cb(httpResponse.content);
+	}
+	
+	try {
+		if(async_cb) {
+			http = window.postURL(uri, text, async_callback, mimeType, encoding);
+		} else {
+		return dojo.raise(&quot;No synchronous XMLHTTP post implementation available, for uri &quot; + uri);
+		}
+	} catch(e) {
+		return dojo.raise(&quot;No XMLHTTP post implementation available, for uri &quot; + uri);
+	}
+}
+
+/*
+ * It turns out that if we check *right now*, as this script file is being loaded,
+ * then the last script element in the window DOM is ourselves.
+ * That is because any subsequent script elements haven't shown up in the document
+ * object yet.
+ */
+function dj_last_script_src() {
+	var scripts = window.document.getElementsByTagName('script');
+	if(scripts.length &lt; 1){ 
+		dojo.raise(&quot;No script elements in window.document, so can't figure out my script src&quot;); 
+	}
+	var li = scripts.length-1;
+	var xlinkNS = &quot;<A HREF="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</A>&quot;;
+	var src = null;
+	var script = null;
+	while(!src){
+		script = scripts.item(li);
+		src = script.getAttributeNS(xlinkNS,&quot;href&quot;);
+		li--;
+		if(li&lt;0){ break; }
+		// break;
+	}
+	if(!src){
+		dojo.raise(&quot;Last script element (out of &quot; + scripts.length + &quot;) has no src&quot;);
+	}
+	return src;
+}
+
+if(!dojo.hostenv[&quot;library_script_uri_&quot;]){
+	dojo.hostenv.library_script_uri_ = dj_last_script_src();
+}
+
+// dojo.hostenv.loadUri = function(uri){
+	/* FIXME: adding a script element doesn't seem to be synchronous, and so
+	 * checking for namespace or object existance after loadUri using this
+	 * method will error out. Need to figure out some other way of handling
+	 * this!
+	 */
+	/*
+	var se = document.createElement(&quot;script&quot;);
+	se.src = uri;
+	var head = document.getElementsByTagName(&quot;head&quot;)[0];
+	head.appendChild(se);
+	// document.write(&quot;&lt;script type='text/javascript' src='&quot;+uri+&quot;' /&gt;&quot;);
+	return 1;
+}
+*/

Added: trunk/root/static/magic/src/hostenv_browser.js
===================================================================
--- trunk/root/static/magic/src/hostenv_browser.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_browser.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,360 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+if(typeof window == 'undefined'){
+	dojo.raise(&quot;no window object&quot;);
+}
+
+// attempt to figure out the path to dojo if it isn't set in the config
+(function() {
+	// before we get any further with the config options, try to pick them out
+	// of the URL. Most of this code is from NW
+	if(djConfig.allowQueryConfig){
+		var baseUrl = document.location.toString(); // FIXME: use location.query instead?
+		var params = baseUrl.split(&quot;?&quot;, 2);
+		if(params.length &gt; 1){
+			var paramStr = params[1];
+			var pairs = paramStr.split(&quot;&amp;&quot;);
+			for(var x in pairs){
+				var sp = pairs[x].split(&quot;=&quot;);
+				// FIXME: is this eval dangerous?
+				if((sp[0].length &gt; 9)&amp;&amp;(sp[0].substr(0, 9) == &quot;djConfig.&quot;)){
+					var opt = sp[0].substr(9);
+					try{
+						djConfig[opt]=eval(sp[1]);
+					}catch(e){
+						djConfig[opt]=sp[1];
+					}
+				}
+			}
+		}
+	}
+
+	if(((djConfig[&quot;baseScriptUri&quot;] == &quot;&quot;)||(djConfig[&quot;baseRelativePath&quot;] == &quot;&quot;)) &amp;&amp;(document &amp;&amp; document.getElementsByTagName)){
+		var scripts = document.getElementsByTagName(&quot;script&quot;);
+		var rePkg = /(__package__|dojo|bootstrap1)\.js([\?\.]|$)/i;
+		for(var i = 0; i &lt; scripts.length; i++) {
+			var src = scripts[i].getAttribute(&quot;src&quot;);
+			if(!src) { continue; }
+			var m = src.match(rePkg);
+			if(m) {
+				var root = src.substring(0, m.index);
+				if(src.indexOf(&quot;bootstrap1&quot;) &gt; -1) { root += &quot;../&quot;; }
+				if(!this[&quot;djConfig&quot;]) { djConfig = {}; }
+				if(djConfig[&quot;baseScriptUri&quot;] == &quot;&quot;) { djConfig[&quot;baseScriptUri&quot;] = root; }
+				if(djConfig[&quot;baseRelativePath&quot;] == &quot;&quot;) { djConfig[&quot;baseRelativePath&quot;] = root; }
+				break;
+			}
+		}
+	}
+
+	// fill in the rendering support information in dojo.render.*
+	var dr = dojo.render;
+	var drh = dojo.render.html;
+	var drs = dojo.render.svg;
+	var dua = drh.UA = navigator.userAgent;
+	var dav = drh.AV = navigator.appVersion;
+	var t = true;
+	var f = false;
+	drh.capable = t;
+	drh.support.builtin = t;
+
+	dr.ver = parseFloat(drh.AV);
+	dr.os.mac = dav.indexOf(&quot;Macintosh&quot;) &gt;= 0;
+	dr.os.win = dav.indexOf(&quot;Windows&quot;) &gt;= 0;
+	// could also be Solaris or something, but it's the same browser
+	dr.os.linux = dav.indexOf(&quot;X11&quot;) &gt;= 0;
+
+	drh.opera = dua.indexOf(&quot;Opera&quot;) &gt;= 0;
+	drh.khtml = (dav.indexOf(&quot;Konqueror&quot;) &gt;= 0)||(dav.indexOf(&quot;Safari&quot;) &gt;= 0);
+	drh.safari = dav.indexOf(&quot;Safari&quot;) &gt;= 0;
+	var geckoPos = dua.indexOf(&quot;Gecko&quot;);
+	drh.mozilla = drh.moz = (geckoPos &gt;= 0)&amp;&amp;(!drh.khtml);
+	if (drh.mozilla) {
+		// gecko version is YYYYMMDD
+		drh.geckoVersion = dua.substring(geckoPos + 6, geckoPos + 14);
+	}
+	drh.ie = (document.all)&amp;&amp;(!drh.opera);
+	drh.ie50 = drh.ie &amp;&amp; dav.indexOf(&quot;MSIE 5.0&quot;)&gt;=0;
+	drh.ie55 = drh.ie &amp;&amp; dav.indexOf(&quot;MSIE 5.5&quot;)&gt;=0;
+	drh.ie60 = drh.ie &amp;&amp; dav.indexOf(&quot;MSIE 6.0&quot;)&gt;=0;
+	drh.ie70 = drh.ie &amp;&amp; dav.indexOf(&quot;MSIE 7.0&quot;)&gt;=0;
+
+	// TODO: is the HTML LANG attribute relevant?
+	dojo.locale = (drh.ie ? navigator.userLanguage : navigator.language).toLowerCase();
+
+	dr.vml.capable=drh.ie;
+	drs.capable = f;
+	drs.support.plugin = f;
+	drs.support.builtin = f;
+	if (document.implementation
+		&amp;&amp; document.implementation.hasFeature
+		&amp;&amp; document.implementation.hasFeature(&quot;org.w3c.dom.svg&quot;, &quot;1.0&quot;)
+	){
+		drs.capable = t;
+		drs.support.builtin = t;
+		drs.support.plugin = f;
+	}
+})();
+
+dojo.hostenv.startPackage(&quot;dojo.hostenv&quot;);
+
+dojo.render.name = dojo.hostenv.name_ = 'browser';
+dojo.hostenv.searchIds = [];
+
+// These are in order of decreasing likelihood; this will change in time.
+dojo.hostenv._XMLHTTP_PROGIDS = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'];
+
+dojo.hostenv.getXmlhttpObject = function(){
+    var http = null;
+	var last_e = null;
+	try{ http = new XMLHttpRequest(); }catch(e){}
+    if(!http){
+		for(var i=0; i&lt;3; ++i){
+			var progid = dojo.hostenv._XMLHTTP_PROGIDS[i];
+			try{
+				http = new ActiveXObject(progid);
+			}catch(e){
+				last_e = e;
+			}
+
+			if(http){
+				dojo.hostenv._XMLHTTP_PROGIDS = [progid];  // so faster next time
+				break;
+			}
+		}
+
+		/*if(http &amp;&amp; !http.toString) {
+			http.toString = function() { &quot;[object XMLHttpRequest]&quot;; }
+		}*/
+	}
+
+	if(!http){
+		return dojo.raise(&quot;XMLHTTP not available&quot;, last_e);
+	}
+
+	return http;
+}
+
+/**
+ * Read the contents of the specified uri and return those contents.
+ *
+ * @param uri A relative or absolute uri. If absolute, it still must be in the
+ * same &quot;domain&quot; as we are.
+ *
+ * @param async_cb If not specified, load synchronously. If specified, load
+ * asynchronously, and use async_cb as the progress handler which takes the
+ * xmlhttp object as its argument. If async_cb, this function returns null.
+ *
+ * @param fail_ok Default false. If fail_ok and !async_cb and loading fails,
+ * return null instead of throwing.
+ */
+dojo.hostenv.getText = function(uri, async_cb, fail_ok){
+
+	var http = this.getXmlhttpObject();
+
+	if(async_cb){
+		http.onreadystatechange = function(){
+			if(4==http.readyState){
+				if((!http[&quot;status&quot;])||((200 &lt;= http.status)&amp;&amp;(300 &gt; http.status))){
+					// dojo.debug(&quot;LOADED URI: &quot;+uri);
+					async_cb(http.responseText);
+				}
+			}
+		}
+	}
+
+	http.open('GET', uri, async_cb ? true : false);
+	try{
+		http.send(null);
+		if(async_cb){
+			return null;
+		}
+		if((http[&quot;status&quot;])&amp;&amp;((200 &gt; http.status)||(300 &lt;= http.status))){
+			throw Error(&quot;Unable to load &quot;+uri+&quot; status:&quot;+ http.status);
+		}
+	}catch(e){
+		if((fail_ok)&amp;&amp;(!async_cb)){
+			return null;
+		}else{
+			throw e;
+		}
+	}
+
+	return http.responseText;
+}
+
+/*
+ * It turns out that if we check *right now*, as this script file is being loaded,
+ * then the last script element in the window DOM is ourselves.
+ * That is because any subsequent script elements haven't shown up in the document
+ * object yet.
+ */
+ /*
+function dj_last_script_src() {
+    var scripts = window.document.getElementsByTagName('script');
+    if(scripts.length &lt; 1){
+		dojo.raise(&quot;No script elements in window.document, so can't figure out my script src&quot;);
+	}
+    var script = scripts[scripts.length - 1];
+    var src = script.src;
+    if(!src){
+		dojo.raise(&quot;Last script element (out of &quot; + scripts.length + &quot;) has no src&quot;);
+	}
+    return src;
+}
+
+if(!dojo.hostenv[&quot;library_script_uri_&quot;]){
+	dojo.hostenv.library_script_uri_ = dj_last_script_src();
+}
+*/
+
+dojo.hostenv.defaultDebugContainerId = 'dojoDebug';
+dojo.hostenv._println_buffer = [];
+dojo.hostenv._println_safe = false;
+dojo.hostenv.println = function (line){
+	if(!dojo.hostenv._println_safe){
+		dojo.hostenv._println_buffer.push(line);
+	}else{
+		try {
+			var console = document.getElementById(djConfig.debugContainerId ?
+				djConfig.debugContainerId : dojo.hostenv.defaultDebugContainerId);
+			if(!console) { console = document.getElementsByTagName(&quot;body&quot;)[0] || document.body; }
+
+			var div = document.createElement(&quot;div&quot;);
+			div.appendChild(document.createTextNode(line));
+			console.appendChild(div);
+		} catch (e) {
+			try{
+				// safari needs the output wrapped in an element for some reason
+				document.write(&quot;&lt;div&gt;&quot; + line + &quot;&lt;/div&gt;&quot;);
+			}catch(e2){
+				window.status = line;
+			}
+		}
+	}
+}
+
+dojo.addOnLoad(function(){
+	dojo.hostenv._println_safe = true;
+	while(dojo.hostenv._println_buffer.length &gt; 0){
+		dojo.hostenv.println(dojo.hostenv._println_buffer.shift());
+	}
+});
+
+function dj_addNodeEvtHdlr(node, evtName, fp, capture){
+	var oldHandler = node[&quot;on&quot;+evtName] || function(){};
+	node[&quot;on&quot;+evtName] = function(){
+		fp.apply(node, arguments);
+		oldHandler.apply(node, arguments);
+	}
+	return true;
+}
+
+
+/* Uncomment this to allow init after DOMLoad, not after window.onload
+
+// Mozilla exposes the event we could use
+if (dojo.render.html.mozilla) {
+   document.addEventListener(&quot;DOMContentLoaded&quot;, dj_load_init, null);
+}
+// for Internet Explorer. readyState will not be achieved on init call, but dojo doesn't need it
+//Tighten up the comments below to allow init after DOMLoad, not after window.onload
+/ * @cc_on @ * /
+/ * @if (@_win32)
+    document.write(&quot;&lt;script defer&gt;dj_load_init()&lt;&quot;+&quot;/script&gt;&quot;);
+/ * @end @ * /
+*/
+
+// default for other browsers
+// potential TODO: apply setTimeout approach for other browsers
+// that will cause flickering though ( document is loaded and THEN is processed)
+// maybe show/hide required in this case..
+// TODO: other browsers may support DOMContentLoaded/defer attribute. Add them to above.
+dj_addNodeEvtHdlr(window, &quot;load&quot;, function(){
+	// allow multiple calls, only first one will take effect
+	if(arguments.callee.initialized){ return; }
+	arguments.callee.initialized = true;
+
+	var initFunc = function(){
+		//perform initialization
+		if(dojo.render.html.ie){
+			dojo.hostenv.makeWidgets();
+		}
+	};
+
+	if(dojo.hostenv.inFlightCount == 0){
+		initFunc();
+		dojo.hostenv.modulesLoaded();
+	}else{
+		dojo.addOnLoad(initFunc);
+	}
+});
+
+dj_addNodeEvtHdlr(window, &quot;unload&quot;, function(){
+	dojo.hostenv.unloaded();
+});
+
+dojo.hostenv.makeWidgets = function(){
+	// you can put searchIds in djConfig and dojo.hostenv at the moment
+	// we should probably eventually move to one or the other
+	var sids = [];
+	if(djConfig.searchIds &amp;&amp; djConfig.searchIds.length &gt; 0) {
+		sids = sids.concat(djConfig.searchIds);
+	}
+	if(dojo.hostenv.searchIds &amp;&amp; dojo.hostenv.searchIds.length &gt; 0) {
+		sids = sids.concat(dojo.hostenv.searchIds);
+	}
+
+	if((djConfig.parseWidgets)||(sids.length &gt; 0)){
+		if(dojo.evalObjPath(&quot;dojo.widget.Parse&quot;)){
+			// we must do this on a delay to avoid:
+			//	<A HREF="http://www.shaftek.org/blog/archives/000212.html">http://www.shaftek.org/blog/archives/000212.html</A>
+			// IE is such a tremendous peice of shit.
+				var parser = new dojo.xml.Parse();
+				if(sids.length &gt; 0){
+					for(var x=0; x&lt;sids.length; x++){
+						var tmpNode = document.getElementById(sids[x]);
+						if(!tmpNode){ continue; }
+						var frag = parser.parseElement(tmpNode, null, true);
+						dojo.widget.getParser().createComponents(frag);
+					}
+				}else if(djConfig.parseWidgets){
+					var frag  = parser.parseElement(document.getElementsByTagName(&quot;body&quot;)[0] || document.body, null, true);
+					dojo.widget.getParser().createComponents(frag);
+				}
+		}
+	}
+}
+
+dojo.addOnLoad(function(){
+	if(!dojo.render.html.ie) {
+		dojo.hostenv.makeWidgets();
+	}
+});
+
+try {
+	if (dojo.render.html.ie) {
+		document.write('&lt;style&gt;v\:*{ behavior:url(#default#VML); }&lt;/style&gt;');
+		document.write('&lt;xml:namespace ns=&quot;urn:schemas-microsoft-com:vml&quot; prefix=&quot;v&quot;/&gt;');
+	}
+} catch (e) { }
+
+// stub, over-ridden by debugging code. This will at least keep us from
+// breaking when it's not included
+dojo.hostenv.writeIncludes = function(){}
+
+dojo.byId = function(id, doc){
+	if(id &amp;&amp; (typeof id == &quot;string&quot; || id instanceof String)){
+		if(!doc){ doc = document; }
+		return doc.getElementById(id);
+	}
+	return id; // assume it's a node
+}

Added: trunk/root/static/magic/src/hostenv_dashboard.js
===================================================================
--- trunk/root/static/magic/src/hostenv_dashboard.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_dashboard.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,197 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.render.name = dojo.hostenv.name_ = &quot;dashboard&quot;;
+
+dojo.hostenv.println = function(/*String*/ message){
+	// summary: Prints a message to the OS X console
+	return alert(message); // null
+}
+
+dojo.hostenv.getXmlhttpObject = function(/*Object*/ kwArgs){
+	// summary: Returns the appropriate transfer object for the call type
+	if(widget.system &amp;&amp; kwArgs){
+		if((kwArgs.contentType &amp;&amp; kwArgs.contentType.indexOf(&quot;text/&quot;) != 0) || (kwArgs.headers &amp;&amp; kwArgs.headers[&quot;content-type&quot;] &amp;&amp; kwArgs.headers[&quot;content-type&quot;].indexOf(&quot;text/&quot;) != 0)){
+			var curl = new dojo.hostenv.CurlRequest;
+			curl._save = true;
+			return curl;
+		}else if(kwArgs.method &amp;&amp; kwArgs.method.toUpperCase() == &quot;HEAD&quot;){
+			return new dojo.hostenv.CurlRequest;
+		}else if(kwArgs.headers &amp;&amp; kwArgs.header.referer){
+			return new dojo.hostenv.CurlRequest; 
+		}
+	}
+	return new XMLHttpRequest; // XMLHttpRequest
+}
+
+dojo.hostenv.CurlRequest = function(){
+	// summary: Emulates the XMLHttpRequest Object
+	this.onreadystatechange = null;
+	this.readyState = 0;
+	this.responseText = &quot;&quot;;
+	this.responseXML = null;
+	this.status = 0;
+	this.statusText = &quot;&quot;;
+	this._method = &quot;&quot;;
+	this._url = &quot;&quot;;
+	this._async = true;
+	this._referrer = &quot;&quot;;
+	this._headers = [];
+	this._save = false;
+	this._responseHeader = &quot;&quot;;
+	this._responseHeaders = {};
+	this._fileName = &quot;&quot;;
+	this._username = &quot;&quot;;
+	this._password = &quot;&quot;;
+}
+
+dojo.hostenv.CurlRequest.prototype.open = function(/*String*/ method, /*URL*/ url, /*Boolean?*/ async, /*String?*/ username, /*String?*/ password){
+	this._method = method;
+	this._url = url;
+	if(async){
+		this._async = async;
+	}
+	if(username){
+		this._username = username;
+	}
+	if(password){
+		this._password = password;
+	}
+}
+
+dojo.hostenv.CurlRequest.prototype.setRequestHeader = function(/*String*/ label, /*String*/ value){
+	switch(label){
+		case &quot;Referer&quot;:
+			this._referrer = value;
+			break;
+		case &quot;content-type&quot;:
+			break;
+		default:
+			this._headers.push(label + &quot;=&quot; + value);
+			break;
+	}
+}
+
+dojo.hostenv.CurlRequest.prototype.getAllResponseHeaders = function(){
+	return this._responseHeader; // String
+}
+
+dojo.hostenv.CurlRequest.prototype.getResponseHeader = function(/*String*/ headerLabel){
+	return this._responseHeaders[headerLabel]; // String
+}
+
+// -sS = Show only errors in errorString
+// -i = Display headers with return
+// -e = Referrer URI
+// -H = Headers
+// -d = data to be sent (forces POST)
+// -G = forces GET
+// -o = Writes to file (in the cache directory)
+// -I = Only load headers
+// -u = user:password
+dojo.hostenv.CurlRequest.prototype.send = function(/*String*/ content){
+	this.readyState = 1;
+	if(this.onreadystatechange){
+		this.onreadystatechange.call(this);
+	}
+	var query = {sS: &quot;&quot;};
+	if(this._referrer){
+		query.e = this._referrer;
+	}
+	if(this._headers.length){
+		query.H = this._headers.join(&quot;&amp;&quot;);
+	}
+	if(this._username){
+		if(this._password){
+			query.u = this._username + &quot;:&quot; + this._password;
+		}else{
+			query.u = this._username;
+		}
+	}
+	if(content){
+		query.d = this.content;
+		if(this._method != &quot;POST&quot;){
+			query.G = &quot;&quot;;
+		}
+	}
+	if(this._method == &quot;HEAD&quot;){
+		query.I = &quot;&quot;;
+	}else{
+		if(this._save){
+			query.I = &quot;&quot;; // Get the headers in the initial query
+		}else{
+			query.i = &quot;&quot;;
+		}
+	}
+
+	var system = widget.system(dojo.hostenv.CurlRequest._formatCall(query, this._url), null);
+	this.readyState = 2;
+	if(this.onreadystatechange){
+		this.onreadystatechange.call(this);
+	}
+	if(system.errorString){
+		this.responseText = system.errorString;
+		this.status = 0;
+	}else{
+		if(this._save){
+			this._responseHeader = system.outputString;
+		}else{
+			var split = system.outputString.replace(/\r/g, &quot;&quot;).split(&quot;\n\n&quot;, 2);
+			this._responseHeader = split[0];
+			this.responseText = split[1];
+		}
+		split = this._responseHeader.split(&quot;\n&quot;);
+		this.statusText = split.shift();
+		this.status = this.statusText.split(&quot; &quot;)[1];
+		for(var i = 0, header; header = split[i]; i++){
+			var header_split = header.split(&quot;: &quot;, 2);
+			this._responseHeaders[header_split[0]] = header_split[1];
+		}
+		if(this._save){
+			widget.system(&quot;/bin/mkdir cache&quot;, null);
+			// First, make a file name
+			this._fileName = this._url.split(&quot;/&quot;).pop().replace(/\W/g, &quot;&quot;);
+			// Then, get its extension
+			this._fileName += &quot;.&quot; + this._responseHeaders[&quot;Content-Type&quot;].replace(/[\r\n]/g, &quot;&quot;).split(&quot;/&quot;).pop()
+			delete query.I;
+			query.o = &quot;cache/&quot; + this._fileName; // Tell it where to be saved.
+			system = widget.system(dojo.hostenv.CurlRequest._formatCall(query, this._url), null);
+			if(!system.errorString){
+				this.responseText = &quot;cache/&quot; + this._fileName;
+			}
+		}else if(this._method == &quot;HEAD&quot;){
+			this.responseText = this._responseHeader;
+		}
+	}
+
+	this.readyState = 4;
+	if(this.onreadystatechange){
+		this.onreadystatechange.call(this);
+	}
+}
+
+dojo.hostenv.CurlRequest._formatCall = function(query, url){
+	var call = [&quot;/usr/bin/curl&quot;];
+	for(var key in query){
+		if(query[key] != &quot;&quot;){
+			call.push(&quot;-&quot; + key + &quot; '&quot; + query[key].replace(/'/g, &quot;\'&quot;) + &quot;'&quot;);
+		}else{
+			call.push(&quot;-&quot; + key);
+		}
+	}
+	call.push(&quot;'&quot; + url.replace(/'/g, &quot;\'&quot;) + &quot;'&quot;);
+	return call.join(&quot; &quot;);
+}
+
+dojo.hostenv.exit = function(){
+	if(widget.system){
+		widget.system(&quot;/bin/rm -rf cache/*&quot;, null);
+	}
+}

Added: trunk/root/static/magic/src/hostenv_jsc.js
===================================================================
--- trunk/root/static/magic/src/hostenv_jsc.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_jsc.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,76 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+ * JScript .NET jsc
+ *
+ */
+
+dojo.hostenv.name_ = 'jsc';
+
+// Sanity check this is the right hostenv.
+// See the Rotor source code jscript/engine/globalobject.cs for what globals
+// are available.
+if((typeof ScriptEngineMajorVersion != 'function')||(ScriptEngineMajorVersion() &lt; 7)){
+	dojo.raise(&quot;attempt to use JScript .NET host environment with inappropriate ScriptEngine&quot;); 
+}
+
+// for more than you wanted to know about why this import is required even if
+// we fully qualify all symbols, see
+// <A HREF="http://groups.google.com/groups?th=f050c7aeefdcbde2&amp;rnum=12">http://groups.google.com/groups?th=f050c7aeefdcbde2&amp;rnum=12</A>
+import System;
+
+dojo.hostenv.getText = function(uri){
+	if(!System.IO.File.Exists(uri)){
+		// dojo.raise(&quot;No such file '&quot; + uri + &quot;'&quot;);
+		return 0;
+	}
+	var reader = new System.IO.StreamReader(uri);
+	var contents : String = reader.ReadToEnd();
+	return contents;
+}
+
+dojo.hostenv.loadUri = function(uri){
+	var contents = this.getText(uri);
+	if(!contents){
+		dojo.raise(&quot;got no back contents from uri '&quot; + uri + &quot;': &quot; + contents);
+	}
+	// TODO: in JScript .NET, eval will not affect the symbol table of the current code?
+	var value = dj_eval(contents);
+	dojo.debug(&quot;jsc eval of contents returned: &quot;, value);
+	return 1;
+
+	// for an example doing runtime code compilation, see:
+	// <A HREF="http://groups.google.com/groups?selm=eQ1aeciCBHA.1644%40tkmsftngp05&amp;rnum=6">http://groups.google.com/groups?selm=eQ1aeciCBHA.1644%40tkmsftngp05&amp;rnum=6</A>
+	// Microsoft.JScript or System.CodeDom.Compiler ?
+	// var engine = new Microsoft.JScript.Vsa.VsaEngine()
+	// what about loading a js file vs. a dll?
+	// GetObject(&quot;script:&quot; . uri);
+}
+
+/* The System.Environment object is useful:
+    print (&quot;CommandLine='&quot; + System.Environment.CommandLine + &quot;' &quot; +
+	   &quot;program name='&quot; + System.Environment.GetCommandLineArgs()[0] + &quot;' &quot; +
+	   &quot;CurrentDirectory='&quot; + System.Environment.CurrentDirectory + &quot;' &quot; +
+	   &quot;StackTrace='&quot; + System.Environment.StackTrace + &quot;'&quot;);
+*/
+
+// same as System.Console.WriteLine
+// sigh; Rotor treats symbol &quot;print&quot; at parse time without actually putting it
+// in the builtin symbol table.
+// Note that the print symbol is not available if jsc is run with the &quot;/print-&quot;
+// option.
+dojo.hostenv.println = function(s){
+	print(s); // = print
+}
+
+dojo.hostenv.getLibraryScriptUri = function(){
+	return System.Environment.GetCommandLineArgs()[0];
+}

Added: trunk/root/static/magic/src/hostenv_rhino.js
===================================================================
--- trunk/root/static/magic/src/hostenv_rhino.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_rhino.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,190 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+* Rhino host environment
+*/
+
+// make jsc shut up (so we can use jsc for sanity checking) 
+/*@cc_on
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at if</A> (@_jscript_version &gt;= 7)
+var loadClass; var print; var load; var quit; var version; var Packages; var java;
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at end</A>
+@*/
+
+// TODO: not sure what we gain from the next line, anyone?
+//if (typeof loadClass == 'undefined') { dojo.raise(&quot;attempt to use Rhino host environment when no 'loadClass' global&quot;); }
+
+dojo.render.name = dojo.hostenv.name_ = 'rhino';
+dojo.hostenv.getVersion = function() {return version()};
+
+// see comments in spidermonkey loadUri
+dojo.hostenv.loadUri = function(uri, cb){
+	dojo.debug(&quot;uri: &quot;+uri);
+	try{
+		// FIXME: what about remote URIs?
+		var found = true;
+		if(!(new java.io.File(uri)).exists()){
+			try{
+				// try it as a file first, URL second
+				(new java.io.URL(uri)).openStream();
+			}catch(e){
+				found = false;
+			}
+		}
+		if(!found){
+			dojo.debug(uri+&quot; does not exist&quot;);
+			if(cb){ cb(0); }
+			return 0;
+		}
+		var ok = load(uri);
+		// dojo.debug(typeof ok);
+		dojo.debug(&quot;rhino load('&quot;, uri, &quot;') returned. Ok: &quot;, ok);
+		if(cb){ cb(1); }
+		return 1;
+	}catch(e){
+		dojo.debug(&quot;rhino load('&quot;, uri, &quot;') failed&quot;);
+		if(cb){ cb(0); }
+		return 0;
+	}
+}
+
+dojo.hostenv.println = print;
+dojo.hostenv.exit = function(exitcode){ 
+	quit(exitcode);
+}
+
+// Hack to determine current script...
+//
+// These initial attempts failed:
+//   1. get an EcmaError and look at e.getSourceName(): try {eval (&quot;static in return&quot;)} catch(e) { ...
+//   Won't work because NativeGlobal.java only does a put of &quot;name&quot; and &quot;message&quot;, not a wrapped reflecting object.
+//   Even if the EcmaError object had the sourceName set.
+//  
+//   2. var e = Packages.org.mozilla.javascript.Context.getCurrentContext().reportError('');
+//   Won't work because it goes directly to the errorReporter, not the return value.
+//   We want context.interpreterSourceFile and context.interpreterLine, which are used in static Context.getSourcePositionFromStack
+//   (set by Interpreter.java at interpretation time, if in interpreter mode).
+//
+//   3. var e = Packages.org.mozilla.javascript.Context.getCurrentContext().reportRuntimeError('');
+//   This returns an object, but e.message still does not have source info.
+//   In compiler mode, perhaps not set; in interpreter mode, perhaps not used by errorReporter?
+//
+// What we found works is to do basically the same hack as is done in getSourcePositionFromStack,
+// making a new java.lang.Exception() and then calling printStackTrace on a string stream.
+// We have to parse the string for the .js files (different from the java files).
+// This only works however in compiled mode (-opt 0 or higher).
+// In interpreter mode, entire stack is java.
+// When compiled, printStackTrace is like:
+// java.lang.Exception
+//	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
+//	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
+//	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
+//	at java.lang.reflect.Constructor.newInstance(Constructor.java:274)
+//	at org.mozilla.javascript.NativeJavaClass.constructSpecific(NativeJavaClass.java:228)
+//	at org.mozilla.javascript.NativeJavaClass.construct(NativeJavaClass.java:185)
+//	at org.mozilla.javascript.ScriptRuntime.newObject(ScriptRuntime.java:1269)
+//	at org.mozilla.javascript.gen.c2.call(/Users/mda/Sites/burstproject/testrhino.js:27)
+//    ...
+//	at org.mozilla.javascript.tools.shell.Main.main(Main.java:76)
+//
+// Note may get different answers based on:
+//    Context.setOptimizationLevel(-1)
+//    Context.setGeneratingDebug(true)
+//    Context.setGeneratingSource(true) 
+//
+// Some somewhat helpful posts:
+//    <A HREF="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;safe=off&amp;selm=9v9n0g%246gr1%40ripley.netscape.com">http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;safe=off&amp;selm=9v9n0g%246gr1%40ripley.netscape.com</A>
+//    <A HREF="http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;safe=off&amp;selm=3BAA2DC4.6010702%40atg.com">http://groups.google.com/groups?hl=en&amp;lr=&amp;ie=UTF-8&amp;oe=UTF-8&amp;safe=off&amp;selm=3BAA2DC4.6010702%40atg.com</A>
+//
+// Note that Rhino1.5R5 added source name information in some exceptions.
+// But this seems not to help in command-line Rhino, because Context.java has an error reporter
+// so no EvaluationException is thrown.
+
+// do it by using java java.lang.Exception
+function dj_rhino_current_script_via_java(depth) {
+    var optLevel = Packages.org.mozilla.javascript.Context.getCurrentContext().getOptimizationLevel();  
+    if (optLevel == -1) dojo.unimplemented(&quot;getCurrentScriptURI (determine current script path for rhino when interpreter mode)&quot;, '');
+    var caw = new java.io.CharArrayWriter();
+    var pw = new java.io.PrintWriter(caw);
+    var exc = new java.lang.Exception();
+    var s = caw.toString();
+    // we have to exclude the ones with or without line numbers because they put double entries in:
+    //   at org.mozilla.javascript.gen.c3._c4(/Users/mda/Sites/burstproject/burst/Runtime.js:56)
+    //   at org.mozilla.javascript.gen.c3.call(/Users/mda/Sites/burstproject/burst/Runtime.js)
+    var matches = s.match(/[^\(]*\.js\)/gi);
+    if(!matches){
+		throw Error(&quot;cannot parse printStackTrace output: &quot; + s);
+	}
+
+    // matches[0] is entire string, matches[1] is this function, matches[2] is caller, ...
+    var fname = ((typeof depth != 'undefined')&amp;&amp;(depth)) ? matches[depth + 1] : matches[matches.length - 1];
+    var fname = matches[3];
+	if(!fname){ fname = matches[1]; }
+    // print(&quot;got fname '&quot; + fname + &quot;' from stack string '&quot; + s + &quot;'&quot;);
+    if (!fname) throw Error(&quot;could not find js file in printStackTrace output: &quot; + s);
+    //print(&quot;Rhino getCurrentScriptURI returning '&quot; + fname + &quot;' from: &quot; + s); 
+    return fname;
+}
+
+// UNUSED: leverage new support in native exception for getSourceName
+/*
+function dj_rhino_current_script_via_eval_exception() {
+    var exc;
+    // 'ReferenceError: &quot;undefinedsymbol&quot; is not defined.'
+    try {eval (&quot;undefinedsymbol()&quot;) } catch(e) {exc = e;}
+    // 'Error: whatever'
+    // try{throw Error(&quot;whatever&quot;);} catch(e) {exc = e;}
+    // 'SyntaxError: identifier is a reserved word'
+    // try {eval (&quot;static in return&quot;)} catch(e) { exc = e; }
+    print(&quot;got exception: '&quot; + exc + &quot;'&quot;);
+    print(&quot;exc.stack=&quot; + (typeof exc.stack));
+    var sn = exc.getSourceName();
+    print(&quot;SourceName=&quot; + sn);
+    return sn;
+} 
+*/
+
+// reading a file from disk in Java is a humiliating experience by any measure.
+// Lets avoid that and just get the freaking text
+function readText(uri){
+	// NOTE: we intentionally avoid handling exceptions, since the caller will
+	// want to know
+	var jf = new java.io.File(uri);
+	var sb = new java.lang.StringBuffer();
+	var input = new java.io.BufferedReader(new java.io.FileReader(jf));
+	var line = &quot;&quot;;
+	while((line = input.readLine()) != null){
+		sb.append(line);
+		sb.append(java.lang.System.getProperty(&quot;line.separator&quot;));
+	}
+	return sb.toString();
+}
+
+// call this now because later we may not be on the top of the stack
+if(!djConfig.libraryScriptUri.length){
+	try{
+		djConfig.libraryScriptUri = dj_rhino_current_script_via_java(1);
+	}catch(e){
+		// otherwise just fake it
+		if(djConfig[&quot;isDebug&quot;]){
+			print(&quot;\n&quot;);
+			print(&quot;we have no idea where Dojo is located from.&quot;);
+			print(&quot;Please try loading rhino in a non-interpreted mode or set a&quot;);
+			print(&quot;\n	djConfig.libraryScriptUri\n&quot;);
+			print(&quot;Setting the dojo path to './'&quot;);
+			print(&quot;This is probably wrong!&quot;);
+			print(&quot;\n&quot;);
+			print(&quot;Dojo will try to load anyway&quot;);
+		}
+		djConfig.libraryScriptUri = &quot;./&quot;;
+	}
+}
+

Added: trunk/root/static/magic/src/hostenv_spidermonkey.js
===================================================================
--- trunk/root/static/magic/src/hostenv_spidermonkey.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_spidermonkey.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,79 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+ * SpiderMonkey host environment
+ */
+
+dojo.hostenv.name_ = 'spidermonkey';
+
+dojo.hostenv.println = print;
+dojo.hostenv.exit = function(exitcode){ 
+	quit(exitcode); 
+}
+
+// version() returns 0, sigh. and build() returns nothing but just prints.
+dojo.hostenv.getVersion = function(){ return version(); }
+
+// make jsc shut up (so we can use jsc for sanity checking) 
+/*@cc_on
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at if</A> (@_jscript_version &gt;= 7)
+var line2pc; var print; var load; var quit;
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at end</A>
+@*/
+
+if(typeof line2pc == 'undefined'){
+	dojo.raise(&quot;attempt to use SpiderMonkey host environment when no 'line2pc' global&quot;);
+}
+
+/*
+ * This is a hack that determines the current script file by parsing a generated
+ * stack trace (relying on the non-standard &quot;stack&quot; member variable of the
+ * SpiderMonkey Error object).
+ * If param depth is passed in, it'll return the script file which is that far down
+ * the stack, but that does require that you know how deep your stack is when you are
+ * calling.
+ */
+function dj_spidermonkey_current_file(depth){
+    var s = '';
+    try{
+		throw Error(&quot;whatever&quot;);
+	}catch(e){
+		s = e.stack;
+	}
+    // lines are like: bu_getCurrentScriptURI_spidermonkey(&quot;ScriptLoader.js&quot;)@burst/Runtime.js:101
+    var matches = s.match(/[^@]*\.js/gi);
+    if(!matches){ 
+		dojo.raise(&quot;could not parse stack string: '&quot; + s + &quot;'&quot;);
+	}
+    var fname = (typeof depth != 'undefined' &amp;&amp; depth) ? matches[depth + 1] : matches[matches.length - 1];
+    if(!fname){ 
+		dojo.raise(&quot;could not find file name in stack string '&quot; + s + &quot;'&quot;);
+	}
+    //print(&quot;SpiderMonkeyRuntime got fname '&quot; + fname + &quot;' from stack string '&quot; + s + &quot;'&quot;);
+    return fname;
+}
+
+// call this now because later we may not be on the top of the stack
+if(!dojo.hostenv.library_script_uri_){ 
+	dojo.hostenv.library_script_uri_ = dj_spidermonkey_current_file(0); 
+}
+
+dojo.hostenv.loadUri = function(uri){
+	// spidermonkey load() evaluates the contents into the global scope (which
+	// is what we want).
+	// TODO: sigh, load() does not return a useful value. 
+	// Perhaps it is returning the value of the last thing evaluated?
+	var ok = load(uri);
+	// dojo.debug(&quot;spidermonkey load(&quot;, uri, &quot;) returned &quot;, ok);
+	return 1;
+}
+
+

Added: trunk/root/static/magic/src/hostenv_svg.js
===================================================================
--- trunk/root/static/magic/src/hostenv_svg.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_svg.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,223 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+//	hostenv_svg
+if(typeof window == 'undefined'){
+	dojo.raise(&quot;attempt to use adobe svg hostenv when no window object&quot;);
+}
+dojo.debug = function(){ 
+	if (!djConfig.isDebug) { return; }
+	var args = arguments;
+	var isJUM = dj_global[&quot;jum&quot;];
+	var s = isJUM ? &quot;&quot;: &quot;DEBUG: &quot;;
+	for (var i = 0; i &lt; args.length; ++i){ s += args[i]; }
+	if (isJUM){ // this seems to be the only way to get JUM to &quot;play nice&quot;
+		jum.debug(s);
+	} else{ 
+		dojo.hostenv.println(s);
+	}
+};
+
+//	set up dojo.render.
+dojo.render.name = navigator.appName;
+dojo.render.ver = parseFloat(navigator.appVersion, 10);
+switch(navigator.platform){
+	case &quot;MacOS&quot;:
+		dojo.render.os.osx =  true;
+		break;
+	case &quot;Linux&quot;:
+		dojo.render.os.linux =  true;
+		break;
+	case &quot;Windows&quot;:
+		dojo.render.os.win =  true;
+		break;
+	default:
+		dojo.render.os.linux = true;
+		break;
+};
+dojo.render.svg.capable = true;
+dojo.render.svg.support.builtin = true;
+//	FIXME the following two is a big-ass hack for now.
+dojo.render.svg.moz = ((navigator.userAgent.indexOf(&quot;Gecko&quot;) &gt;= 0) &amp;&amp; (!((navigator.appVersion.indexOf(&quot;Konqueror&quot;) &gt;= 0) || (navigator.appVersion.indexOf(&quot;Safari&quot;) &gt;= 0))));
+dojo.render.svg.adobe = (window.parseXML != null);
+
+//	agent-specific implementations.
+
+//	from old hostenv_adobesvg.
+dojo.hostenv.startPackage(&quot;dojo.hostenv&quot;);
+dojo.hostenv.println = function(s){ 
+	try {
+		var ti = document.createElement(&quot;text&quot;);
+		ti.setAttribute(&quot;x&quot;,&quot;50&quot;);
+		ti.setAttribute(&quot;y&quot;, (25 + 15 * document.getElementsByTagName(&quot;text&quot;).length));
+		ti.appendChild(document.createTextNode(s));
+		document.documentElement.appendChild(ti);
+	} catch(e){ }
+};
+dojo.hostenv.name_ = &quot;svg&quot;;
+
+//	expected/defined by bootstrap1.js
+dojo.hostenv.setModulePrefix = function(module, prefix){ };
+dojo.hostenv.getModulePrefix = function(module){ };
+dojo.hostenv.getTextStack = [];
+dojo.hostenv.loadUriStack = [];
+dojo.hostenv.loadedUris = [];
+dojo.hostenv.modules_ = {};
+dojo.hostenv.modulesLoadedFired = false;
+dojo.hostenv.modulesLoadedListeners = [];
+dojo.hostenv.getText = function(uri, cb, data){ 
+	if (!cb) var cb = function(result){ window.alert(result); };
+	if (!data) {
+		window.getUrl(uri, cb);
+	} else {
+		window.postUrl(uri, data, cb);
+	}
+};
+dojo.hostenv.getLibaryScriptUri = function(){ };
+
+dojo.hostenv.loadUri = function(uri){ };
+dojo.hostenv.loadUriAndCheck = function(uri, module){ };
+
+//	aliased in loader.js, don't ignore
+//	we are going to kill loadModule for the first round of SVG stuff, and include shit manually.
+dojo.hostenv.loadModule = function(moduleName){
+	//	just like startPackage, but this time we're just checking to make sure it exists already.
+	var a = moduleName.split(&quot;.&quot;);
+	var currentObj = window;
+	var s = [];
+	for (var i = 0; i &lt; a.length; i++){
+		if (a[i] == &quot;*&quot;) continue;
+		s.push(a[i]);
+		if (!currentObj[a[i]]){
+			dojo.raise(&quot;dojo.require('&quot; + moduleName + &quot;'): module does not exist.&quot;);
+		} else currentObj = currentObj[a[i]];
+	}
+	return; 
+};
+dojo.hostenv.startPackage = function(moduleName){
+	var a = moduleName.split(&quot;.&quot;);
+	var currentObj = window;
+	var s = [];
+	for (var i = 0; i &lt; a.length; i++){
+		if (a[i] == &quot;*&quot;) continue;
+		s.push(a[i]);
+		if (!currentObj[a[i]]) currentObj[a[i]] = {};
+		currentObj = currentObj[a[i]];
+	}
+	return; 
+};
+
+//	wrapper objects for ASVG
+if (window.parseXML){
+	window.XMLSerialzer = function(){
+		//	based on WebFX RichTextControl getXHTML() function.
+		function nodeToString(n, a) {
+			function fixText(s) { return String(s).replace(/\&amp;/g, &quot;&amp;&quot;).replace(/&gt;/g, &quot;&gt;&quot;).replace(/&lt;/g, &quot;&lt;&quot;); }
+			function fixAttribute(s) { return fixText(s).replace(/\&quot;/g, &quot;&quot;&quot;); }
+			switch (n.nodeType) {
+				case 1:	{	//	ELEMENT
+					var name = n.nodeName;
+					a.push(&quot;&lt;&quot; + name);
+					for (var i = 0; i &lt; n.attributes.length; i++) {
+						if (n.attributes.item(i).specified) {
+							a.push(&quot; &quot; + n.attributes.item(i).nodeName.toLowerCase() + &quot;=\&quot;&quot; + fixAttribute(n.attributes.item(i).nodeValue) + &quot;\&quot;&quot;);
+						}
+					}
+					if (n.canHaveChildren || n.hasChildNodes()) {
+						a.push(&quot;&gt;&quot;);
+						for (var i = 0; i &lt; n.childNodes.length; i++) nodeToString(n.childNodes.item(i), a);
+						a.push(&quot;&lt;/&quot; + name + &quot;&gt;\n&quot;);
+					} else a.push(&quot; /&gt;\n&quot;);
+					break;
+				}
+				case 3: {	//	TEXT
+					a.push(fixText(n.nodeValue));
+					break;
+				}
+				case 4: {	//	CDATA
+					a.push(&quot;&lt;![CDA&quot; + &quot;TA[\n&quot; + n.nodeValue + &quot;\n]&quot; + &quot;]&gt;&quot;);
+					break;
+				}
+				case 7:{	//	PROCESSING INSTRUCTION
+					a.push(n.nodeValue);
+					if (/(^&lt;\?xml)|(^&lt;\!DOCTYPE)/.test(n.nodeValue)) a.push(&quot;\n&quot;);
+					break;
+				}
+				case 8:{	//	COMMENT
+					a.push(&quot;&lt;!-- &quot; + n.nodeValue + &quot; --&gt;\n&quot;);
+					break;
+				}
+				case 9:		//	DOCUMENT
+				case 11:{	//	DOCUMENT FRAGMENT
+					for (var i = 0; i &lt; n.childNodes.length; i++) nodeToString(n.childNodes.item(i), a);
+					break;
+				}
+				default:{
+					a.push(&quot;&lt;!--\nNot Supported:\n\n&quot; + &quot;nodeType: &quot; + n.nodeType + &quot;\nnodeName: &quot; + n.nodeName + &quot;\n--&gt;&quot;);
+				}
+			}
+		}
+		this.serializeToString = function(node){
+			var a = [];
+			nodeToString(node, a);
+			return a.join(&quot;&quot;);
+		};
+	};
+
+	window.DOMParser = function(){
+		//	mimetype is basically ignored
+		this.parseFromString = function(s){
+			return parseXML(s, window.document);
+		}
+	};
+
+	window.XMLHttpRequest = function(){
+		//	we ignore the setting and getting of content-type.
+		var uri = null;
+		var method = &quot;POST&quot;;
+		var isAsync = true;	
+		var cb = function(d){
+			this.responseText = d.content;
+			try {
+				this.responseXML = parseXML(this.responseText, window.document);
+			} catch(e){}
+			this.status = &quot;200&quot;;
+			this.statusText = &quot;OK&quot;;
+			if (!d.success) {
+				this.status = &quot;500&quot;;
+				this.statusText = &quot;Internal Server Error&quot;;
+			}
+			this.onload();
+			this.onreadystatechange();
+		};
+		this.onload = function(){};
+		this.readyState = 4;
+		this.onreadystatechange = function(){};
+		this.status = 0;
+		this.statusText = &quot;&quot;;
+		this.responseBody = null;
+		this.responseStream = null;
+		this.responseXML = null;
+		this.responseText = null;
+		this.abort = function(){ return; };
+		this.getAllResponseHeaders = function(){ return []; };
+		this.getResponseHeader = function(n){ return null; };
+		this.setRequestHeader = function(nm, val){ };
+		this.open = function(meth, url, async){ 
+			method = meth;
+			uri = url;
+		};
+		this.send = function(data){
+			var d = data || null;
+			if (method == &quot;GET&quot;) getURL(uri, cb);
+			else postURL(uri, data, cb);
+		};
+	};
+}

Added: trunk/root/static/magic/src/hostenv_wsh.js
===================================================================
--- trunk/root/static/magic/src/hostenv_wsh.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/hostenv_wsh.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,46 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+ * WSH
+ */
+
+dojo.hostenv.name_ = 'wsh';
+
+// make jsc shut up (so can sanity check)
+/*@cc_on
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at if</A> (@_jscript_version &gt;= 7)
+var WScript;
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at end</A>
+@*/
+
+// make sure we are in right environment
+if(typeof WScript == 'undefined'){
+	dojo.raise(&quot;attempt to use WSH host environment when no WScript global&quot;);
+}
+
+dojo.hostenv.println = WScript.Echo;
+
+dojo.hostenv.getCurrentScriptUri = function(){
+	return WScript.ScriptFullName();
+}
+
+dojo.hostenv.getText = function(fpath){
+	var fso = new ActiveXObject(&quot;Scripting.FileSystemObject&quot;);
+	var istream = fso.OpenTextFile(fpath, 1); // iomode==1 means read only
+	if(!istream){
+		return null;
+	}
+	var contents = istream.ReadAll();
+	istream.Close();
+	return contents;
+}
+
+dojo.hostenv.exit = function(exitcode){ WScript.Quit(exitcode); }

Added: trunk/root/static/magic/src/html/__package__.js
===================================================================
--- trunk/root/static/magic/src/html/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/html/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.html&quot;, &quot;dojo.html.extras&quot;, &quot;dojo.html.shadow&quot;]
+});
+dojo.provide(&quot;dojo.html.*&quot;);

Added: trunk/root/static/magic/src/html/extras.js
===================================================================
--- trunk/root/static/magic/src/html/extras.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/html/extras.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,428 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.html&quot;);
+dojo.provide(&quot;dojo.html.extras&quot;);
+dojo.require(&quot;dojo.string.extras&quot;); 
+
+/**
+ * Calculates the mouse's direction of gravity relative to the centre
+ * of the given node.
+ * &lt;p&gt;
+ * If you wanted to insert a node into a DOM tree based on the mouse
+ * position you might use the following code:
+ * &lt;pre&gt;
+ * if (gravity(node, e) &amp; gravity.NORTH) { [insert before]; }
+ * else { [insert after]; }
+ * &lt;/pre&gt;
+ *
+ * @param node The node
+ * @param e		The event containing the mouse coordinates
+ * @return		 The directions, NORTH or SOUTH and EAST or WEST. These
+ *						 are properties of the function.
+ */
+dojo.html.gravity = function(node, e){
+	node = dojo.byId(node);
+	var mouse = dojo.html.getCursorPosition(e);
+
+	with (dojo.html) {
+		var nodecenterx = getAbsoluteX(node, true) + (getInnerWidth(node) / 2);
+		var nodecentery = getAbsoluteY(node, true) + (getInnerHeight(node) / 2);
+	}
+	
+	with (dojo.html.gravity) {
+		return ((mouse.x &lt; nodecenterx ? WEST : EAST) |
+			(mouse.y &lt; nodecentery ? NORTH : SOUTH));
+	}
+}
+
+dojo.html.gravity.NORTH = 1;
+dojo.html.gravity.SOUTH = 1 &lt;&lt; 1;
+dojo.html.gravity.EAST = 1 &lt;&lt; 2;
+dojo.html.gravity.WEST = 1 &lt;&lt; 3;
+
+
+/**
+ * Attempts to return the text as it would be rendered, with the line breaks
+ * sorted out nicely. Unfinished.
+ */
+dojo.html.renderedTextContent = function(node){
+	node = dojo.byId(node);
+	var result = &quot;&quot;;
+	if (node == null) { return result; }
+	for (var i = 0; i &lt; node.childNodes.length; i++) {
+		switch (node.childNodes[i].nodeType) {
+			case 1: // ELEMENT_NODE
+			case 5: // ENTITY_REFERENCE_NODE
+				var display = &quot;unknown&quot;;
+				try {
+					display = dojo.style.getStyle(node.childNodes[i], &quot;display&quot;);
+				} catch(E) {}
+				switch (display) {
+					case &quot;block&quot;: case &quot;list-item&quot;: case &quot;run-in&quot;:
+					case &quot;table&quot;: case &quot;table-row-group&quot;: case &quot;table-header-group&quot;:
+					case &quot;table-footer-group&quot;: case &quot;table-row&quot;: case &quot;table-column-group&quot;:
+					case &quot;table-column&quot;: case &quot;table-cell&quot;: case &quot;table-caption&quot;:
+						// TODO: this shouldn't insert double spaces on aligning blocks
+						result += &quot;\n&quot;;
+						result += dojo.html.renderedTextContent(node.childNodes[i]);
+						result += &quot;\n&quot;;
+						break;
+					
+					case &quot;none&quot;: break;
+					
+					default:
+						if(node.childNodes[i].tagName &amp;&amp; node.childNodes[i].tagName.toLowerCase() == &quot;br&quot;) {
+							result += &quot;\n&quot;;
+						} else {
+							result += dojo.html.renderedTextContent(node.childNodes[i]);
+						}
+						break;
+				}
+				break;
+			case 3: // TEXT_NODE
+			case 2: // ATTRIBUTE_NODE
+			case 4: // CDATA_SECTION_NODE
+				var text = node.childNodes[i].nodeValue;
+				var textTransform = &quot;unknown&quot;;
+				try {
+					textTransform = dojo.style.getStyle(node, &quot;text-transform&quot;);
+				} catch(E) {}
+				switch (textTransform){
+					case &quot;capitalize&quot;: text = dojo.string.capitalize(text); break;
+					case &quot;uppercase&quot;: text = text.toUpperCase(); break;
+					case &quot;lowercase&quot;: text = text.toLowerCase(); break;
+					default: break; // leave as is
+				}
+				// TODO: implement
+				switch (textTransform){
+					case &quot;nowrap&quot;: break;
+					case &quot;pre-wrap&quot;: break;
+					case &quot;pre-line&quot;: break;
+					case &quot;pre&quot;: break; // leave as is
+					default:
+						// remove whitespace and collapse first space
+						text = text.replace(/\s+/, &quot; &quot;);
+						if (/\s$/.test(result)) { text.replace(/^\s/, &quot;&quot;); }
+						break;
+				}
+				result += text;
+				break;
+			default:
+				break;
+		}
+	}
+	return result;
+}
+
+dojo.html.createNodesFromText = function(txt, trim){
+	if(trim) { txt = dojo.string.trim(txt); }
+
+	var tn = document.createElement(&quot;div&quot;);
+	// tn.style.display = &quot;none&quot;;
+	tn.style.visibility= &quot;hidden&quot;;
+	document.body.appendChild(tn);
+	var tableType = &quot;none&quot;;
+	if((/^&lt;t[dh][\s\r\n&gt;]/i).test(dojo.string.trimStart(txt))) {
+		txt = &quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot; + txt + &quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot;;
+		tableType = &quot;cell&quot;;
+	} else if((/^&lt;tr[\s\r\n&gt;]/i).test(dojo.string.trimStart(txt))) {
+		txt = &quot;&lt;table&gt;&lt;tbody&gt;&quot; + txt + &quot;&lt;/tbody&gt;&lt;/table&gt;&quot;;
+		tableType = &quot;row&quot;;
+	} else if((/^&lt;(thead|tbody|tfoot)[\s\r\n&gt;]/i).test(dojo.string.trimStart(txt))) {
+		txt = &quot;&lt;table&gt;&quot; + txt + &quot;&lt;/table&gt;&quot;;
+		tableType = &quot;section&quot;;
+	}
+	tn.innerHTML = txt;
+	if(tn[&quot;normalize&quot;]){
+		tn.normalize();
+	}
+
+	var parent = null;
+	switch(tableType) {
+		case &quot;cell&quot;:
+			parent = tn.getElementsByTagName(&quot;tr&quot;)[0];
+			break;
+		case &quot;row&quot;:
+			parent = tn.getElementsByTagName(&quot;tbody&quot;)[0];
+			break;
+		case &quot;section&quot;:
+			parent = tn.getElementsByTagName(&quot;table&quot;)[0];
+			break;
+		default:
+			parent = tn;
+			break;
+	}
+
+	/* this doesn't make much sense, I'm assuming it just meant trim() so wrap was replaced with trim
+	if(wrap){ 
+		var ret = [];
+		// start hack
+		var fc = tn.firstChild;
+		ret[0] = ((fc.nodeValue == &quot; &quot;)||(fc.nodeValue == &quot;\t&quot;)) ? fc.nextSibling : fc;
+		// end hack
+		// tn.style.display = &quot;none&quot;;
+		document.body.removeChild(tn);
+		return ret;
+	}
+	*/
+	var nodes = [];
+	for(var x=0; x&lt;parent.childNodes.length; x++){
+		nodes.push(parent.childNodes[x].cloneNode(true));
+	}
+	tn.style.display = &quot;none&quot;; // FIXME: why do we do this?
+	document.body.removeChild(tn);
+	return nodes;
+}
+
+/* TODO: merge placeOnScreen and placeOnScreenPoint to make 1 function that allows you
+ * to define which corner(s) you want to bind to. Something like so:
+ *
+ * kes(node, desiredX, desiredY, &quot;TR&quot;)
+ * kes(node, [desiredX, desiredY], [&quot;TR&quot;, &quot;BL&quot;])
+ *
+ * TODO: make this function have variable call sigs
+ *
+ * kes(node, ptArray, cornerArray, padding, hasScroll)
+ * kes(node, ptX, ptY, cornerA, cornerB, cornerC, paddingArray, hasScroll)
+ */
+
+/**
+ * Keeps 'node' in the visible area of the screen while trying to
+ * place closest to desiredX, desiredY. The input coordinates are
+ * expected to be the desired screen position, not accounting for
+ * scrolling. If you already accounted for scrolling, set 'hasScroll'
+ * to true. Set padding to either a number or array for [paddingX, paddingY]
+ * to put some buffer around the element you want to position.
+ * NOTE: node is assumed to be absolutely or relatively positioned.
+ *
+ * Alternate call sig:
+ *  placeOnScreen(node, [x, y], padding, hasScroll)
+ *
+ * Examples:
+ *  placeOnScreen(node, 100, 200)
+ *  placeOnScreen(&quot;myId&quot;, [800, 623], 5)
+ *  placeOnScreen(node, 234, 3284, [2, 5], true)
+ */
+dojo.html.placeOnScreen = function(node, desiredX, desiredY, padding, hasScroll) {
+	if(dojo.lang.isArray(desiredX)) {
+		hasScroll = padding;
+		padding = desiredY;
+		desiredY = desiredX[1];
+		desiredX = desiredX[0];
+	}
+
+	if(!isNaN(padding)) {
+		padding = [Number(padding), Number(padding)];
+	} else if(!dojo.lang.isArray(padding)) {
+		padding = [0, 0];
+	}
+
+	var scroll = dojo.html.getScrollOffset();
+	var view = dojo.html.getViewportSize();
+
+	node = dojo.byId(node);
+	var w = node.offsetWidth + padding[0];
+	var h = node.offsetHeight + padding[1];
+
+	if(hasScroll) {
+		desiredX -= scroll.x;
+		desiredY -= scroll.y;
+	}
+
+	var x = desiredX + w;
+	if(x &gt; view.w) {
+		x = view.w - w;
+	} else {
+		x = desiredX;
+	}
+	x = Math.max(padding[0], x) + scroll.x;
+
+	var y = desiredY + h;
+	if(y &gt; view.h) {
+		y = view.h - h;
+	} else {
+		y = desiredY;
+	}
+	y = Math.max(padding[1], y) + scroll.y;
+
+	node.style.left = x + &quot;px&quot;;
+	node.style.top = y + &quot;px&quot;;
+
+	var ret = [x, y];
+	ret.x = x;
+	ret.y = y;
+	return ret;
+}
+
+/**
+ * Like placeOnScreenPoint except that it attempts to keep one of the node's
+ * corners at desiredX, desiredY.  Favors the bottom right position
+ *
+ * Examples placing node at mouse position (where e = [Mouse event]):
+ *  placeOnScreenPoint(node, e.clientX, e.clientY);
+ */
+dojo.html.placeOnScreenPoint = function(node, desiredX, desiredY, padding, hasScroll) {
+	if(dojo.lang.isArray(desiredX)) {
+		hasScroll = padding;
+		padding = desiredY;
+		desiredY = desiredX[1];
+		desiredX = desiredX[0];
+	}
+
+	if(!isNaN(padding)) {
+		padding = [Number(padding), Number(padding)];
+	} else if(!dojo.lang.isArray(padding)) {
+		padding = [0, 0];
+	}
+
+	var scroll = dojo.html.getScrollOffset();
+	var view = dojo.html.getViewportSize();
+
+	node = dojo.byId(node);
+	var oldDisplay = node.style.display;
+	node.style.display=&quot;&quot;;
+	var w = dojo.style.getInnerWidth(node);
+	var h = dojo.style.getInnerHeight(node);
+	node.style.display=oldDisplay;
+
+	if(hasScroll) {
+		desiredX -= scroll.x;
+		desiredY -= scroll.y;
+	}
+
+	var x = -1, y = -1;
+	//dojo.debug((desiredX+padding[0]) + w, &quot;&lt;=&quot;, view.w, &quot;&amp;&amp;&quot;, (desiredY+padding[1]) + h, &quot;&lt;=&quot;, view.h);
+	if((desiredX+padding[0]) + w &lt;= view.w &amp;&amp; (desiredY+padding[1]) + h &lt;= view.h) { // TL
+		x = (desiredX+padding[0]);
+		y = (desiredY+padding[1]);
+		//dojo.debug(&quot;TL&quot;, x, y);
+	}
+
+	//dojo.debug((desiredX-padding[0]), &quot;&lt;=&quot;, view.w, &quot;&amp;&amp;&quot;, (desiredY+padding[1]) + h, &quot;&lt;=&quot;, view.h);
+	if((x &lt; 0 || y &lt; 0) &amp;&amp; (desiredX-padding[0]) &lt;= view.w &amp;&amp; (desiredY+padding[1]) + h &lt;= view.h) { // TR
+		x = (desiredX-padding[0]) - w;
+		y = (desiredY+padding[1]);
+		//dojo.debug(&quot;TR&quot;, x, y);
+	}
+
+	//dojo.debug((desiredX+padding[0]) + w, &quot;&lt;=&quot;, view.w, &quot;&amp;&amp;&quot;, (desiredY-padding[1]), &quot;&lt;=&quot;, view.h);
+	if((x &lt; 0 || y &lt; 0) &amp;&amp; (desiredX+padding[0]) + w &lt;= view.w &amp;&amp; (desiredY-padding[1]) &lt;= view.h) { // BL
+		x = (desiredX+padding[0]);
+		y = (desiredY-padding[1]) - h;
+		//dojo.debug(&quot;BL&quot;, x, y);
+	}
+
+	//dojo.debug((desiredX-padding[0]), &quot;&lt;=&quot;, view.w, &quot;&amp;&amp;&quot;, (desiredY-padding[1]), &quot;&lt;=&quot;, view.h);
+	if((x &lt; 0 || y &lt; 0) &amp;&amp; (desiredX-padding[0]) &lt;= view.w &amp;&amp; (desiredY-padding[1]) &lt;= view.h) { // BR
+		x = (desiredX-padding[0]) - w;
+		y = (desiredY-padding[1]) - h;
+		//dojo.debug(&quot;BR&quot;, x, y);
+	}
+
+	if(x &lt; 0 || y &lt; 0 || (x + w &gt; view.w) || (y + h &gt; view.h)) {
+		return dojo.html.placeOnScreen(node, desiredX, desiredY, padding, hasScroll);
+	}
+
+	x += scroll.x;
+	y += scroll.y;
+
+	node.style.left = x + &quot;px&quot;;
+	node.style.top = y + &quot;px&quot;;
+
+	var ret = [x, y];
+	ret.x = x;
+	ret.y = y;
+	return ret;
+}
+
+/**
+ * For IE z-index schenanigans
+ * Two possible uses:
+ *   1. new dojo.html.BackgroundIframe(node)
+ *        Makes a background iframe as a child of node, that fills area (and position) of node
+ *
+ *   2. new dojo.html.BackgroundIframe()
+ *        Attaches frame to document.body.  User must call size() to set size.
+ */
+dojo.html.BackgroundIframe = function(node) {
+	if(dojo.render.html.ie55 || dojo.render.html.ie60) {
+		var html=
+				 &quot;&lt;iframe &quot;
+				+&quot;style='position: absolute; left: 0px; top: 0px; width: 100%; height: 100%;&quot;
+				+        &quot;z-index: -1; filter:Alpha(Opacity=\&quot;0\&quot;);' &quot;
+				+&quot;&gt;&quot;;
+		this.iframe = document.createElement(html);
+		if(node){
+			node.appendChild(this.iframe);
+			this.domNode=node;
+		}else{
+			document.body.appendChild(this.iframe);
+			this.iframe.style.display=&quot;none&quot;;
+		}
+	}
+}
+dojo.lang.extend(dojo.html.BackgroundIframe, {
+	iframe: null,
+
+	// TODO: this function shouldn't be necessary but setting width=height=100% doesn't work!
+	onResized: function(){
+		if(this.iframe &amp;&amp; this.domNode &amp;&amp; this.domNode.parentElement){ // No parentElement if onResized() timeout event occurs on a removed domnode
+			var w = dojo.style.getOuterWidth(this.domNode);
+			var h = dojo.style.getOuterHeight(this.domNode);
+			if (w  == 0 || h == 0 ){
+				dojo.lang.setTimeout(this, this.onResized, 50);
+				return;
+			}
+			var s = this.iframe.style;
+			s.width = w + &quot;px&quot;;
+			s.height = h + &quot;px&quot;;
+		}
+	},
+
+	// Call this function if the iframe is connected to document.body rather
+	// than the node being shadowed (TODO: erase)
+	size: function(node) {
+		if(!this.iframe) { return; }
+
+		var coords = dojo.style.toCoordinateArray(node, true);
+
+		var s = this.iframe.style;
+		s.width = coords.w + &quot;px&quot;;
+		s.height = coords.h + &quot;px&quot;;
+		s.left = coords.x + &quot;px&quot;;
+		s.top = coords.y + &quot;px&quot;;
+	},
+
+	setZIndex: function(node /* or number */) {
+		if(!this.iframe) { return; }
+
+		if(dojo.dom.isNode(node)) {
+			this.iframe.style.zIndex = dojo.html.getStyle(node, &quot;z-index&quot;) - 1;
+		} else if(!isNaN(node)) {
+			this.iframe.style.zIndex = node;
+		}
+	},
+
+	show: function() {
+		if(!this.iframe) { return; }
+		this.iframe.style.display = &quot;block&quot;;
+	},
+
+	hide: function() {
+		if(!this.ie) { return; }
+		var s = this.iframe.style;
+		s.display = &quot;none&quot;;
+	},
+
+	remove: function() {
+		dojo.dom.removeNode(this.iframe);
+	}
+});

Added: trunk/root/static/magic/src/html/images/shadowB.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowB.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowBL.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowBL.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowBR.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowBR.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowL.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowL.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowR.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowR.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowT.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowT.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowTL.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowTL.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowTR..png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowTR..png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/images/shadowTR.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/html/images/shadowTR.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/html/layout.js
===================================================================
--- trunk/root/static/magic/src/html/layout.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/html/layout.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,121 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.html.layout&quot;);
+
+dojo.require(&quot;dojo.lang&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+/**
+ * Layout a bunch of child dom nodes within a parent dom node
+ * Input is an array of objects like:
+ * @ container - parent node
+ * @ layoutPriority - &quot;top-bottom&quot; or &quot;left-right&quot;
+ * @ children an array like [ {domNode: foo, layoutAlign: &quot;bottom&quot; }, {domNode: bar, layoutAlign: &quot;client&quot;} ]
+ */
+dojo.html.layout = function(container, children, layoutPriority) {
+	dojo.html.addClass(container, &quot;dojoLayoutContainer&quot;);
+
+	// Copy children array and remove elements w/out layout.
+	// Also record each child's position in the input array, for sorting purposes.
+	children = dojo.lang.filter(children, function(child, idx){
+		child.idx = idx;
+		return dojo.lang.inArray([&quot;top&quot;,&quot;bottom&quot;,&quot;left&quot;,&quot;right&quot;,&quot;client&quot;,&quot;flood&quot;], child.layoutAlign)
+	});
+
+	// Order the children according to layoutPriority.
+	// Multiple children w/the same layoutPriority will be sorted by their position in the input array.
+	if(layoutPriority &amp;&amp; layoutPriority!=&quot;none&quot;){
+		var rank = function(child){
+			switch(child.layoutAlign){
+				case &quot;flood&quot;:
+					return 1;
+				case &quot;left&quot;:
+				case &quot;right&quot;:
+					return (layoutPriority==&quot;left-right&quot;) ? 2 : 3;
+				case &quot;top&quot;:
+				case &quot;bottom&quot;:
+					return (layoutPriority==&quot;left-right&quot;) ? 3 : 2;
+				default:
+					return 4;
+			}
+		};
+		children.sort(function(a,b){
+			return (rank(a)-rank(b)) || (a.idx - b.idx);
+		});
+	}
+
+	// remaining space (blank area where nothing has been written)
+	var f={
+		top: dojo.style.getPixelValue(container, &quot;padding-top&quot;, true),
+		left: dojo.style.getPixelValue(container, &quot;padding-left&quot;, true),
+		height: dojo.style.getContentHeight(container),
+		width: dojo.style.getContentWidth(container)
+	};
+
+	// set positions/sizes
+	dojo.lang.forEach(children, function(child){
+		var elm=child.domNode;
+		var pos=child.layoutAlign;
+		// set elem to upper left corner of unused space; may move it later
+		with(elm.style){
+			left = f.left+&quot;px&quot;;
+			top = f.top+&quot;px&quot;;
+			bottom = &quot;auto&quot;;
+			right = &quot;auto&quot;;
+		}
+		dojo.html.addClass(elm, &quot;dojoAlign&quot; + dojo.string.capitalize(pos));
+
+		// set size &amp;&amp; adjust record of remaining space.
+		// note that setting the width of a &lt;div&gt; may affect it's height.
+		// TODO: same is true for widgets but need to implement API to support that
+		if ( (pos==&quot;top&quot;)||(pos==&quot;bottom&quot;) ) {
+			dojo.style.setOuterWidth(elm, f.width);
+			var h = dojo.style.getOuterHeight(elm);
+			f.height -= h;
+			if(pos==&quot;top&quot;){
+				f.top += h;
+			}else{
+				elm.style.top = f.top + f.height + &quot;px&quot;;
+			}
+		}else if(pos==&quot;left&quot; || pos==&quot;right&quot;){
+			dojo.style.setOuterHeight(elm, f.height);
+			var w = dojo.style.getOuterWidth(elm);
+			f.width -= w;
+			if(pos==&quot;left&quot;){
+				f.left += w;
+			}else{
+				elm.style.left = f.left + f.width + &quot;px&quot;;
+			}
+		} else if(pos==&quot;flood&quot; || pos==&quot;client&quot;){
+			dojo.style.setOuterWidth(elm, f.width);
+			dojo.style.setOuterHeight(elm, f.height);
+		}
+		
+		// TODO: for widgets I want to call resizeTo(), but for top/bottom
+		// alignment I only want to set the width, and have the size determined
+		// dynamically.  (The thinner you make a div, the more height it consumes.)
+		if(child.onResized){
+			child.onResized();
+		}
+	});
+};
+
+// This is essential CSS to make layout work (it isn't &quot;styling&quot; CSS)
+// make sure that the position:absolute in dojoAlign* overrides other classes
+dojo.style.insertCssText(
+	&quot;.dojoLayoutContainer{ position: relative; display: block; }\n&quot; +
+	&quot;body .dojoAlignTop, body .dojoAlignBottom, body .dojoAlignLeft, body .dojoAlignRight { position: absolute; overflow: hidden; }\n&quot; +
+	&quot;body .dojoAlignClient { position: absolute }\n&quot; +
+	&quot;.dojoAlignClient { overflow: auto; }\n&quot;
+);
+

Added: trunk/root/static/magic/src/html/shadow.js
===================================================================
--- trunk/root/static/magic/src/html/shadow.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/html/shadow.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,79 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.html.shadow&quot;);
+
+dojo.require(&quot;dojo.lang&quot;);
+dojo.require(&quot;dojo.uri&quot;);
+
+dojo.html.shadow = function(node) {
+	this.init(node);
+}
+
+dojo.lang.extend(dojo.html.shadow, {
+
+	shadowPng: dojo.uri.dojoUri(&quot;src/html/images/shadow&quot;),
+	shadowThickness: 8,
+	shadowOffset: 15,
+
+	init: function(node){
+		this.node=node;
+
+		// make all the pieces of the shadow, and position/size them as much
+		// as possible (but a lot of the coordinates are set in sizeShadow
+		this.pieces={};
+		var x1 = -1 * this.shadowThickness;
+		var y0 = this.shadowOffset;
+		var y1 = this.shadowOffset + this.shadowThickness;
+		this._makePiece(&quot;tl&quot;, &quot;top&quot;, y0, &quot;left&quot;, x1);
+		this._makePiece(&quot;l&quot;, &quot;top&quot;, y1, &quot;left&quot;, x1, &quot;scale&quot;);
+		this._makePiece(&quot;tr&quot;, &quot;top&quot;, y0, &quot;left&quot;, 0);
+		this._makePiece(&quot;r&quot;, &quot;top&quot;, y1, &quot;left&quot;, 0, &quot;scale&quot;);
+		this._makePiece(&quot;bl&quot;, &quot;top&quot;, 0, &quot;left&quot;, x1);
+		this._makePiece(&quot;b&quot;, &quot;top&quot;, 0, &quot;left&quot;, 0, &quot;crop&quot;);
+		this._makePiece(&quot;br&quot;, &quot;top&quot;, 0, &quot;left&quot;, 0);
+	},
+
+	_makePiece: function(name, vertAttach, vertCoord, horzAttach, horzCoord, sizing){
+		var img;
+		var url = this.shadowPng + name.toUpperCase() + &quot;.png&quot;;
+		if(dojo.render.html.ie){
+			img=document.createElement(&quot;div&quot;);
+			img.style.filter=&quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src='&quot;+url+&quot;'&quot;+
+			(sizing?&quot;, sizingMethod='&quot;+sizing+&quot;'&quot;:&quot;&quot;) + &quot;)&quot;;
+		}else{
+			img=document.createElement(&quot;img&quot;);
+			img.src=url;
+		}
+		img.style.position=&quot;absolute&quot;;
+		img.style[vertAttach]=vertCoord+&quot;px&quot;;
+		img.style[horzAttach]=horzCoord+&quot;px&quot;;
+		img.style.width=this.shadowThickness+&quot;px&quot;;
+		img.style.height=this.shadowThickness+&quot;px&quot;;
+		this.pieces[name]=img;
+		this.node.appendChild(img);
+	},
+
+	size: function(width, height){
+		var sideHeight = height - (this.shadowOffset+this.shadowThickness+1);
+		with(this.pieces){
+			l.style.height = sideHeight+&quot;px&quot;;
+			r.style.height = sideHeight+&quot;px&quot;;
+			b.style.width = (width-1)+&quot;px&quot;;
+			bl.style.top = (height-1)+&quot;px&quot;;
+			b.style.top = (height-1)+&quot;px&quot;;
+			br.style.top = (height-1)+&quot;px&quot;;
+			tr.style.left = (width-1)+&quot;px&quot;;
+			r.style.left = (width-1)+&quot;px&quot;;
+			br.style.left = (width-1)+&quot;px&quot;;
+		}
+	}
+});
+

Added: trunk/root/static/magic/src/html.js
===================================================================
--- trunk/root/static/magic/src/html.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/html.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,595 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.html&quot;);
+
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+dojo.lang.mixin(dojo.html, dojo.dom);
+dojo.lang.mixin(dojo.html, dojo.style);
+
+// FIXME: we are going to assume that we can throw any and every rendering
+// engine into the IE 5.x box model. In Mozilla, we do this w/ CSS.
+// Need to investigate for KHTML and Opera
+
+dojo.html.clearSelection = function(){
+	try{
+		if(window[&quot;getSelection&quot;]){ 
+			if(dojo.render.html.safari){
+				// pulled from WebCore/ecma/kjs_window.cpp, line 2536
+				window.getSelection().collapse();
+			}else{
+				window.getSelection().removeAllRanges();
+			}
+		}else if(document.selection){
+			if(document.selection.empty){
+				document.selection.empty();
+			}else if(document.selection.clear){
+				document.selection.clear();
+			}
+		}
+		return true;
+	}catch(e){
+		dojo.debug(e);
+		return false;
+	}
+}
+
+dojo.html.disableSelection = function(element){
+	element = dojo.byId(element)||document.body;
+	var h = dojo.render.html;
+	
+	if(h.mozilla){
+		element.style.MozUserSelect = &quot;none&quot;;
+	}else if(h.safari){
+		element.style.KhtmlUserSelect = &quot;none&quot;; 
+	}else if(h.ie){
+		element.unselectable = &quot;on&quot;;
+	}else{
+		return false;
+	}
+	return true;
+}
+
+dojo.html.enableSelection = function(element){
+	element = dojo.byId(element)||document.body;
+	
+	var h = dojo.render.html;
+	if(h.mozilla){ 
+		element.style.MozUserSelect = &quot;&quot;; 
+	}else if(h.safari){
+		element.style.KhtmlUserSelect = &quot;&quot;;
+	}else if(h.ie){
+		element.unselectable = &quot;off&quot;;
+	}else{
+		return false;
+	}
+	return true;
+}
+
+dojo.html.selectElement = function(element){
+	element = dojo.byId(element);
+	if(document.selection &amp;&amp; document.body.createTextRange){ // IE
+		var range = document.body.createTextRange();
+		range.moveToElementText(element);
+		range.select();
+	}else if(window[&quot;getSelection&quot;]){
+		var selection = window.getSelection();
+		// FIXME: does this work on Safari?
+		if(selection[&quot;selectAllChildren&quot;]){ // Mozilla
+			selection.selectAllChildren(element);
+		}
+	}
+}
+
+dojo.html.selectInputText = function(element){
+	element = dojo.byId(element);
+	if(document.selection &amp;&amp; document.body.createTextRange){ // IE
+		var range = element.createTextRange();
+		range.moveStart(&quot;character&quot;, 0);
+		range.moveEnd(&quot;character&quot;, element.value.length);
+		range.select();
+	}else if(window[&quot;getSelection&quot;]){
+		var selection = window.getSelection();
+		// FIXME: does this work on Safari?
+		element.setSelectionRange(0, element.value.length);
+	}
+	element.focus();
+}
+
+
+dojo.html.isSelectionCollapsed = function(){
+	if(document[&quot;selection&quot;]){ // IE
+		return document.selection.createRange().text == &quot;&quot;;
+	}else if(window[&quot;getSelection&quot;]){
+		var selection = window.getSelection();
+		if(dojo.lang.isString(selection)){ // Safari
+			return selection == &quot;&quot;;
+		}else{ // Mozilla/W3
+			return selection.isCollapsed;
+		}
+	}
+}
+
+dojo.html.getEventTarget = function(evt){
+	if(!evt) { evt = window.event || {} };
+	var t = (evt.srcElement ? evt.srcElement : (evt.target ? evt.target : null));
+	while((t)&amp;&amp;(t.nodeType!=1)){ t = t.parentNode; }
+	return t;
+}
+
+dojo.html.getDocumentWidth = function(){
+	dojo.deprecated(&quot;dojo.html.getDocument*&quot;, &quot;replaced by dojo.html.getViewport*&quot;, &quot;0.4&quot;);
+	return dojo.html.getViewportWidth();
+}
+
+dojo.html.getDocumentHeight = function(){
+	dojo.deprecated(&quot;dojo.html.getDocument*&quot;, &quot;replaced by dojo.html.getViewport*&quot;, &quot;0.4&quot;);
+	return dojo.html.getViewportHeight();
+}
+
+dojo.html.getDocumentSize = function(){
+	dojo.deprecated(&quot;dojo.html.getDocument*&quot;, &quot;replaced of dojo.html.getViewport*&quot;, &quot;0.4&quot;);
+	return dojo.html.getViewportSize();
+}
+
+dojo.html.getViewportWidth = function(){
+	var w = 0;
+
+	if(window.innerWidth){
+		w = window.innerWidth;
+	}
+
+	if(dojo.exists(document, &quot;documentElement.clientWidth&quot;)){
+		// IE6 Strict
+		var w2 = document.documentElement.clientWidth;
+		// this lets us account for scrollbars
+		if(!w || w2 &amp;&amp; w2 &lt; w) {
+			w = w2;
+		}
+		return w;
+	}
+
+	if(document.body){
+		// IE
+		return document.body.clientWidth;
+	}
+
+	return 0;
+}
+
+dojo.html.getViewportHeight = function(){
+	if (window.innerHeight){
+		return window.innerHeight;
+	}
+
+	if (dojo.exists(document, &quot;documentElement.clientHeight&quot;)){
+		// IE6 Strict
+		return document.documentElement.clientHeight;
+	}
+
+	if (document.body){
+		// IE
+		return document.body.clientHeight;
+	}
+
+	return 0;
+}
+
+dojo.html.getViewportSize = function(){
+	var ret = [dojo.html.getViewportWidth(), dojo.html.getViewportHeight()];
+	ret.w = ret[0];
+	ret.h = ret[1];
+	return ret;
+}
+
+dojo.html.getScrollTop = function(){
+	return window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
+}
+
+dojo.html.getScrollLeft = function(){
+	return window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;
+}
+
+dojo.html.getScrollOffset = function(){
+	var off = [dojo.html.getScrollLeft(), dojo.html.getScrollTop()];
+	off.x = off[0];
+	off.y = off[1];
+	return off;
+}
+
+dojo.html.getParentOfType = function(node, type){
+	dojo.deprecated(&quot;dojo.html.getParentOfType&quot;, &quot;replaced by dojo.html.getParentByType*&quot;, &quot;0.4&quot;);
+	return dojo.html.getParentByType(node, type);
+}
+
+dojo.html.getParentByType = function(node, type) {
+	var parent = dojo.byId(node);
+	type = type.toLowerCase();
+	while((parent)&amp;&amp;(parent.nodeName.toLowerCase()!=type)){
+		if(parent==(document[&quot;body&quot;]||document[&quot;documentElement&quot;])){
+			return null;
+		}
+		parent = parent.parentNode;
+	}
+	return parent;
+}
+
+// RAR: this function comes from nwidgets and is more-or-less unmodified.
+// We should probably look ant Burst and f(m)'s equivalents
+dojo.html.getAttribute = function(node, attr){
+	node = dojo.byId(node);
+	// FIXME: need to add support for attr-specific accessors
+	if((!node)||(!node.getAttribute)){
+		// if(attr !== 'nwType'){
+		//	alert(&quot;getAttr of '&quot; + attr + &quot;' with bad node&quot;); 
+		// }
+		return null;
+	}
+	var ta = typeof attr == 'string' ? attr : new String(attr);
+
+	// first try the approach most likely to succeed
+	var v = node.getAttribute(ta.toUpperCase());
+	if((v)&amp;&amp;(typeof v == 'string')&amp;&amp;(v!=&quot;&quot;)){ return v; }
+
+	// try returning the attributes value, if we couldn't get it as a string
+	if(v &amp;&amp; v.value){ return v.value; }
+
+	// this should work on Opera 7, but it's a little on the crashy side
+	if((node.getAttributeNode)&amp;&amp;(node.getAttributeNode(ta))){
+		return (node.getAttributeNode(ta)).value;
+	}else if(node.getAttribute(ta)){
+		return node.getAttribute(ta);
+	}else if(node.getAttribute(ta.toLowerCase())){
+		return node.getAttribute(ta.toLowerCase());
+	}
+	return null;
+}
+	
+/**
+ *	Determines whether or not the specified node carries a value for the
+ *	attribute in question.
+ */
+dojo.html.hasAttribute = function(node, attr){
+	node = dojo.byId(node);
+	return dojo.html.getAttribute(node, attr) ? true : false;
+}
+	
+/**
+ * Returns the string value of the list of CSS classes currently assigned
+ * directly to the node in question. Returns an empty string if no class attribute
+ * is found;
+ */
+dojo.html.getClass = function(node){
+	node = dojo.byId(node);
+	if(!node){ return &quot;&quot;; }
+	var cs = &quot;&quot;;
+	if(node.className){
+		cs = node.className;
+	}else if(dojo.html.hasAttribute(node, &quot;class&quot;)){
+		cs = dojo.html.getAttribute(node, &quot;class&quot;);
+	}
+	return dojo.string.trim(cs);
+}
+
+/**
+ * Returns an array of CSS classes currently assigned
+ * directly to the node in question. Returns an empty array if no classes
+ * are found;
+ */
+dojo.html.getClasses = function(node) {
+	var c = dojo.html.getClass(node);
+	return (c == &quot;&quot;) ? [] : c.split(/\s+/g);
+}
+
+/**
+ * Returns whether or not the specified classname is a portion of the
+ * class list currently applied to the node. Does not cover cascaded
+ * styles, only classes directly applied to the node.
+ */
+dojo.html.hasClass = function(node, classname){
+	return dojo.lang.inArray(dojo.html.getClasses(node), classname);
+}
+
+/**
+ * Adds the specified class to the beginning of the class list on the
+ * passed node. This gives the specified class the highest precidence
+ * when style cascading is calculated for the node. Returns true or
+ * false; indicating success or failure of the operation, respectively.
+ */
+dojo.html.prependClass = function(node, classStr){
+	classStr += &quot; &quot; + dojo.html.getClass(node);
+	return dojo.html.setClass(node, classStr);
+}
+
+/**
+ * Adds the specified class to the end of the class list on the
+ *	passed &node;. Returns &true; or &false; indicating success or failure.
+ */
+dojo.html.addClass = function(node, classStr){
+	if (dojo.html.hasClass(node, classStr)) {
+	  return false;
+	}
+	classStr = dojo.string.trim(dojo.html.getClass(node) + &quot; &quot; + classStr);
+	return dojo.html.setClass(node, classStr);
+}
+
+/**
+ *	Clobbers the existing list of classes for the node, replacing it with
+ *	the list given in the 2nd argument. Returns true or false
+ *	indicating success or failure.
+ */
+dojo.html.setClass = function(node, classStr){
+	node = dojo.byId(node);
+	var cs = new String(classStr);
+	try{
+		if(typeof node.className == &quot;string&quot;){
+			node.className = cs;
+		}else if(node.setAttribute){
+			node.setAttribute(&quot;class&quot;, classStr);
+			node.className = cs;
+		}else{
+			return false;
+		}
+	}catch(e){
+		dojo.debug(&quot;dojo.html.setClass() failed&quot;, e);
+	}
+	return true;
+}
+
+/**
+ * Removes the className from the node;. Returns
+ * true or false indicating success or failure.
+ */ 
+dojo.html.removeClass = function(node, classStr, allowPartialMatches){
+	var classStr = dojo.string.trim(new String(classStr));
+
+	try{
+		var cs = dojo.html.getClasses(node);
+		var nca	= [];
+		if(allowPartialMatches){
+			for(var i = 0; i&lt;cs.length; i++){
+				if(cs[i].indexOf(classStr) == -1){ 
+					nca.push(cs[i]);
+				}
+			}
+		}else{
+			for(var i=0; i&lt;cs.length; i++){
+				if(cs[i] != classStr){ 
+					nca.push(cs[i]);
+				}
+			}
+		}
+		dojo.html.setClass(node, nca.join(&quot; &quot;));
+	}catch(e){
+		dojo.debug(&quot;dojo.html.removeClass() failed&quot;, e);
+	}
+
+	return true;
+}
+
+/**
+ * Replaces 'oldClass' and adds 'newClass' to node
+ */
+dojo.html.replaceClass = function(node, newClass, oldClass) {
+	dojo.html.removeClass(node, oldClass);
+	dojo.html.addClass(node, newClass);
+}
+
+// Enum type for getElementsByClass classMatchType arg:
+dojo.html.classMatchType = {
+	ContainsAll : 0, // all of the classes are part of the node's class (default)
+	ContainsAny : 1, // any of the classes are part of the node's class
+	IsOnly : 2 // only all of the classes are part of the node's class
+}
+
+
+/**
+ * Returns an array of nodes for the given classStr, children of a
+ * parent, and optionally of a certain nodeType
+ */
+dojo.html.getElementsByClass = function(classStr, parent, nodeType, classMatchType, useNonXpath){
+	parent = dojo.byId(parent) || document;
+	var classes = classStr.split(/\s+/g);
+	var nodes = [];
+	if( classMatchType != 1 &amp;&amp; classMatchType != 2 ) classMatchType = 0; // make it enum
+	var reClass = new RegExp(&quot;(\\s|^)((&quot; + classes.join(&quot;)|(&quot;) + &quot;))(\\s|$)&quot;);
+	var candidateNodes = [];
+	
+	if(!useNonXpath &amp;&amp; document.evaluate) { // supports dom 3 xpath
+		var xpath = &quot;//&quot; + (nodeType || &quot;*&quot;) + &quot;[contains(&quot;;
+		if(classMatchType != dojo.html.classMatchType.ContainsAny){
+			xpath += &quot;concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot; +
+			classes.join(&quot; ') and contains(concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot;) +
+			&quot; ')]&quot;;
+		}else{
+			xpath += &quot;concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot; +
+			classes.join(&quot; ')) or contains(concat(' '<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">, at class</A>,' '), ' &quot;) +
+			&quot; ')]&quot;;
+		}
+		var xpathResult = document.evaluate(xpath, parent, null, XPathResult.ANY_TYPE, null);
+		var result = xpathResult.iterateNext();
+		while(result){
+			try{
+				candidateNodes.push(result);
+				result = xpathResult.iterateNext();
+			}catch(e){ break; }
+		}
+		return candidateNodes;
+	}else{
+		if(!nodeType){
+			nodeType = &quot;*&quot;;
+		}
+		candidateNodes = parent.getElementsByTagName(nodeType);
+
+		var node, i = 0;
+		outer:
+		while(node = candidateNodes[i++]){
+			var nodeClasses = dojo.html.getClasses(node);
+			if(nodeClasses.length == 0){ continue outer; }
+			var matches = 0;
+	
+			for(var j = 0; j &lt; nodeClasses.length; j++){
+				if(reClass.test(nodeClasses[j])){
+					if(classMatchType == dojo.html.classMatchType.ContainsAny){
+						nodes.push(node);
+						continue outer;
+					}else{
+						matches++;
+					}
+				}else{
+					if(classMatchType == dojo.html.classMatchType.IsOnly){
+						continue outer;
+					}
+				}
+			}
+	
+			if(matches == classes.length){
+				if(	(classMatchType == dojo.html.classMatchType.IsOnly)&amp;&amp;
+					(matches == nodeClasses.length)){
+					nodes.push(node);
+				}else if(classMatchType == dojo.html.classMatchType.ContainsAll){
+					nodes.push(node);
+				}
+			}
+		}
+		return nodes;
+	}
+}
+
+dojo.html.getElementsByClassName = dojo.html.getElementsByClass;
+
+/**
+ * Returns the mouse position relative to the document (not the viewport).
+ * For example, if you have a document that is 10000px tall,
+ * but your browser window is only 100px tall,
+ * if you scroll to the bottom of the document and call this function it
+ * will return {x: 0, y: 10000}
+ */
+dojo.html.getCursorPosition = function(e){
+	e = e || window.event;
+	var cursor = {x:0, y:0};
+	if(e.pageX || e.pageY){
+		cursor.x = e.pageX;
+		cursor.y = e.pageY;
+	}else{
+		var de = document.documentElement;
+		var db = document.body;
+		cursor.x = e.clientX + ((de||db)[&quot;scrollLeft&quot;]) - ((de||db)[&quot;clientLeft&quot;]);
+		cursor.y = e.clientY + ((de||db)[&quot;scrollTop&quot;]) - ((de||db)[&quot;clientTop&quot;]);
+	}
+	return cursor;
+}
+
+dojo.html.overElement = function(element, e){
+	element = dojo.byId(element);
+	var mouse = dojo.html.getCursorPosition(e);
+
+	with(dojo.html){
+		var top = getAbsoluteY(element, true);
+		var bottom = top + getInnerHeight(element);
+		var left = getAbsoluteX(element, true);
+		var right = left + getInnerWidth(element);
+	}
+	
+	return (mouse.x &gt;= left &amp;&amp; mouse.x &lt;= right &amp;&amp;
+		mouse.y &gt;= top &amp;&amp; mouse.y &lt;= bottom);
+}
+
+dojo.html.setActiveStyleSheet = function(title){
+	var i = 0, a, els = document.getElementsByTagName(&quot;link&quot;);
+	while (a = els[i++]) {
+		if(a.getAttribute(&quot;rel&quot;).indexOf(&quot;style&quot;) != -1 &amp;&amp; a.getAttribute(&quot;title&quot;)){
+			a.disabled = true;
+			if (a.getAttribute(&quot;title&quot;) == title) { a.disabled = false; }
+		}
+	}
+}
+
+dojo.html.getActiveStyleSheet = function(){
+	var i = 0, a, els = document.getElementsByTagName(&quot;link&quot;);
+	while (a = els[i++]) {
+		if (a.getAttribute(&quot;rel&quot;).indexOf(&quot;style&quot;) != -1 &amp;&amp;
+			a.getAttribute(&quot;title&quot;) &amp;&amp; !a.disabled) { return a.getAttribute(&quot;title&quot;); }
+	}
+	return null;
+}
+
+dojo.html.getPreferredStyleSheet = function(){
+	var i = 0, a, els = document.getElementsByTagName(&quot;link&quot;);
+	while (a = els[i++]) {
+		if(a.getAttribute(&quot;rel&quot;).indexOf(&quot;style&quot;) != -1
+			&amp;&amp; a.getAttribute(&quot;rel&quot;).indexOf(&quot;alt&quot;) == -1
+			&amp;&amp; a.getAttribute(&quot;title&quot;)) { return a.getAttribute(&quot;title&quot;); }
+	}
+	return null;
+}
+
+dojo.html.body = function(){
+	// Note: document.body is not defined for a strict xhtml document
+	return document.body || document.getElementsByTagName(&quot;body&quot;)[0];
+}
+
+/**
+ * Like dojo.dom.isTag, except case-insensitive
+**/
+dojo.html.isTag = function(node /* ... */) {
+	node = dojo.byId(node);
+	if(node &amp;&amp; node.tagName) {
+		var arr = dojo.lang.map(dojo.lang.toArray(arguments, 1),
+			function(a) { return String(a).toLowerCase(); });
+		return arr[ dojo.lang.find(node.tagName.toLowerCase(), arr) ] || &quot;&quot;;
+	}
+	return &quot;&quot;;
+}
+
+dojo.html.copyStyle = function(target, source){
+	// work around for opera which doesn't have cssText, and for IE which fails on setAttribute 
+	if(dojo.lang.isUndefined(source.style.cssText)){ 
+		target.setAttribute(&quot;style&quot;, source.getAttribute(&quot;style&quot;)); 
+	}else{
+		target.style.cssText = source.style.cssText; 
+	}
+	dojo.html.addClass(target, dojo.html.getClass(source));
+}
+
+dojo.html._callExtrasDeprecated = function(inFunc, args) {
+	var module = &quot;dojo.html.extras&quot;;
+	dojo.deprecated(&quot;dojo.html.&quot; + inFunc, &quot;moved to &quot; + module, &quot;0.4&quot;);
+	dojo[&quot;require&quot;](module); // weird syntax to fool list-profile-deps (build)
+	return dojo.html[inFunc].apply(dojo.html, args);
+}
+
+dojo.html.createNodesFromText = function() {
+	return dojo.html._callExtrasDeprecated('createNodesFromText', arguments);
+}
+
+dojo.html.gravity = function() {
+	return dojo.html._callExtrasDeprecated('gravity', arguments);
+}
+
+dojo.html.placeOnScreen = function() {
+	return dojo.html._callExtrasDeprecated('placeOnScreen', arguments);
+}
+
+dojo.html.placeOnScreenPoint = function() {
+	return dojo.html._callExtrasDeprecated('placeOnScreenPoint', arguments);
+}
+
+dojo.html.renderedTextContent = function() {
+	return dojo.html._callExtrasDeprecated('renderedTextContent', arguments);
+}
+
+dojo.html.BackgroundIframe = function() {
+	return dojo.html._callExtrasDeprecated('BackgroundIframe', arguments);
+}

Added: trunk/root/static/magic/src/i18n/common.js
===================================================================
--- trunk/root/static/magic/src/i18n/common.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/i18n/common.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,60 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.i18n.common&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+dojo.require(&quot;dojo.experimental&quot;);
+dojo.experimental(&quot;dojo.i18n.common&quot;);
+
+
+/**
+ * Gets a reference to a hash containing the localization for a given bundle in a package, matching the specified
+ * locale.  Bundle must have already been loaded by dojo.requireLocalization() or by a build optimization step.
+ *
+ * @param modulename package in which the bundle is found
+ * @param bundlename the filename in the directory structure without the &quot;.js&quot; suffix
+ * @param locale the variant to load (optional).  By default, the locale defined by the
+ *   host environment: dojo.locale
+ * @return a hash containing name/value pairs.  Throws an exception if the bundle is not found.
+ */
+dojo.i18n.getLocalization = function(modulename, bundlename, locale /*optional*/){
+	locale = dojo.normalizeLocale(locale);
+
+	// look for nearest locale match
+	var elements = locale.split('-');
+	var bundle = dojo.hostenv.findModule([modulename,&quot;_nls&quot;,bundlename].join('.'), true);
+
+	for(var i = elements.length; i &gt; 0; i--){
+		var loc = elements.slice(0, i).join('-');
+		if(bundle[loc]){
+			return bundle[loc];
+		}
+	}
+
+	if(bundle[dojo.fallback_locale]){
+		return bundle[dojo.fallback_locale];
+	}
+
+	dojo.raise(&quot;Bundle not found &quot; + [modulename,&quot;_nls&quot;,bundlename,locale].join('.'));
+};
+
+/**
+ * Is the language read left-to-right?  Most exceptions are for middle eastern languages.
+ *
+ * @param locale a string representing the locale.  By default, the locale defined by the
+ *   host environment: dojo.locale
+ * @return true if language is read left to right; false otherwise
+ */
+dojo.i18n.isLTR = function(locale /*optional*/){
+	var lang = dojo.normalizeLocale(locale).split('-')[0];
+	var RTL = {ar:true,fa:true,he:true,ur:true,yi:true};
+	return !RTL[lang];
+}

Added: trunk/root/static/magic/src/iCalendar.js
===================================================================
--- trunk/root/static/magic/src/iCalendar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/iCalendar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,814 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.iCalendar&quot;);
+dojo.require(&quot;dojo.text.textDirectory&quot;);
+dojo.require(&quot;dojo.date&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+
+dojo.iCalendar.fromText =  function (/* string */text) {
+	// summary
+	// Parse text of an iCalendar and return an array of iCalendar objects
+
+	var properties = dojo.textDirectoryTokeniser.tokenise(text);
+	var calendars = [];
+
+	//dojo.debug(&quot;Parsing iCal String&quot;);
+	for (var i = 0, begun = false; i &lt; properties.length; i++) {
+		var prop = properties[i];
+		if (!begun) {
+			if (prop.name == 'BEGIN' &amp;&amp; prop.value == 'VCALENDAR') {
+				begun = true;
+				var calbody = [];
+			}
+		} else if (prop.name == 'END' &amp;&amp; prop.value == 'VCALENDAR') {
+			calendars.push(new dojo.iCalendar.VCalendar(calbody));
+			begun = false;
+		} else {
+			calbody.push(prop);
+		}
+	}
+	return /* array */calendars;
+}
+
+
+dojo.iCalendar.Component = function (/* string */ body ) {
+	// summary
+	// A component is the basic container of all this stuff. 
+
+	if (!this.name) {
+		this.name = &quot;COMPONENT&quot;
+	}
+
+	this.properties = [];
+	this.components = [];
+
+	if (body) {
+		for (var i = 0, context = ''; i &lt; body.length; i++) {
+			if (context == '') {
+				if (body[i].name == 'BEGIN') {
+					context = body[i].value;
+					var childprops = [];
+				} else {
+					this.addProperty(new dojo.iCalendar.Property(body[i]));
+				}
+			} else if (body[i].name == 'END' &amp;&amp; body[i].value == context) {
+				if (context==&quot;VEVENT&quot;) {
+					this.addComponent(new dojo.iCalendar.VEvent(childprops));
+				} else if (context==&quot;VTIMEZONE&quot;) {
+					this.addComponent(new dojo.iCalendar.VTimeZone(childprops));
+				} else if (context==&quot;VTODO&quot;) {
+					this.addComponent(new dojo.iCalendar.VTodo(childprops));
+				} else if (context==&quot;VJOURNAL&quot;) {
+					this.addComponent(new dojo.iCalendar.VJournal(childprops));
+				} else if (context==&quot;VFREEBUSY&quot;) {
+					this.addComponent(new dojo.iCalendar.VFreeBusy(childprops));
+				} else if (context==&quot;STANDARD&quot;) {
+					this.addComponent(new dojo.iCalendar.Standard(childprops));
+				} else if (context==&quot;DAYLIGHT&quot;) {
+					this.addComponent(new dojo.iCalendar.Daylight(childprops));
+				} else if (context==&quot;VALARM&quot;) {
+					this.addComponent(new dojo.iCalendar.VAlarm(childprops));
+				}else {
+					dojo.unimplemented(&quot;dojo.iCalendar.&quot; + context);
+				}
+				context = '';
+			} else {
+				childprops.push(body[i]);
+			}
+		}
+
+		if (this._ValidProperties) {
+			this.postCreate();
+		}
+	}
+}
+
+dojo.lang.extend(dojo.iCalendar.Component, {
+
+	addProperty: function (prop) {
+		// summary
+		// push a new property onto a component.
+		this.properties.push(prop);
+		this[prop.name.toLowerCase()] = prop;
+	},
+
+	addComponent: function (prop) {
+		// summary
+		// add a component to this components list of children.
+		this.components.push(prop);
+	},
+
+	postCreate: function() {
+		for (var x=0; x&lt;this._ValidProperties.length; x++) {
+			var evtProperty = this._ValidProperties[x];
+			var found = false;
+	
+			for (var y=0; y&lt;this.properties.length; y++) {	
+				var prop = this.properties[y];
+				var propName = prop.name.toLowerCase();
+				if (dojo.lang.isArray(evtProperty)) {
+
+					var alreadySet = false;
+					for (var z=0; z&lt;evtProperty.length; z++) {
+						var evtPropertyName = evtProperty[z].name.toLowerCase();
+						if((this[evtPropertyName])  &amp;&amp; (evtPropertyName != propName )) {
+							alreadySet=true;
+						} 
+					}
+					if (!alreadySet) {
+						this[propName] = prop;
+					}
+				} else {
+					if (propName == evtProperty.name.toLowerCase()) {
+						found = true;
+						if (evtProperty.occurance == 1){
+							this[propName] = prop;
+						} else {
+							found = true;
+							if (!dojo.lang.isArray(this[propName])) {
+							 	this[propName] = [];
+							}
+							this[propName].push(prop);
+						}
+					}
+				}
+			}
+
+			if (evtProperty.required &amp;&amp; !found) {	
+				dojo.debug(&quot;iCalendar - &quot; + this.name + &quot;: Required Property not found: &quot; + evtProperty.name);
+			}
+		}
+
+		// parse any rrules		
+		if (dojo.lang.isArray(this.rrule)) {
+			for(var x=0; x&lt;this.rrule.length; x++) {
+				var rule = this.rrule[x].value;
+
+				//add a place to cache dates we have checked for recurrance
+				this.rrule[x].cache = function() {};
+				
+				var temp = rule.split(&quot;;&quot;);
+				for (var y=0; y&lt;temp.length; y++) {
+					var pair = temp[y].split(&quot;=&quot;);
+					var key = pair[0].toLowerCase();
+					var val = pair[1];
+
+					if ((key == &quot;freq&quot;) || (key==&quot;interval&quot;) || (key==&quot;until&quot;)) {
+						this.rrule[x][key]= val;
+					} else {
+						var valArray = val.split(&quot;,&quot;);
+						this.rrule[x][key] = valArray; 
+					}
+				}	
+			}
+			this.recurring = true;
+		}
+
+	}, 
+
+	toString: function () {
+		// summary
+		// output a string representation of this component.
+		return &quot;[iCalendar.Component; &quot; + this.name + &quot;, &quot; + this.properties.length +
+			&quot; properties, &quot; + this.components.length + &quot; components]&quot;;
+	}
+});
+
+dojo.iCalendar.Property = function (prop) {
+	// summary
+	// A single property of a component.
+
+	// unpack the values
+	this.name = prop.name;
+	this.group = prop.group;
+	this.params = prop.params;
+	this.value = prop.value;
+
+}
+
+dojo.lang.extend(dojo.iCalendar.Property, {
+	toString: function () {	
+		// summary
+		// output a string reprensentation of this component.
+		return &quot;[iCalenday.Property; &quot; + this.name + &quot;: &quot; + this.value + &quot;]&quot;;
+	}
+});
+
+// This is just a little helper function for the Component Properties
+var _P = function (n, oc, req) {
+	return {name: n, required: (req) ? true : false,
+		occurance: (oc == '*' || !oc) ? -1 : oc}
+}
+
+/*
+ * VCALENDAR
+ */
+
+dojo.iCalendar.VCalendar = function (/* string */ calbody) {
+	// summary
+	// VCALENDAR Component
+
+	this.name = &quot;VCALENDAR&quot;;
+	this.recurring = [];
+	this.nonRecurringEvents = function(){};
+	dojo.iCalendar.Component.call(this, calbody);
+}
+
+dojo.inherits(dojo.iCalendar.VCalendar, dojo.iCalendar.Component);
+
+dojo.lang.extend(dojo.iCalendar.VCalendar, {
+
+	addComponent: function (prop) {
+		// summary
+		// add component to the calenadar that makes it easy to pull them out again later.
+		this.components.push(prop);
+		if (prop.name.toLowerCase() == &quot;vevent&quot;) {
+			if (prop.rrule) {
+				this.recurring.push(prop);
+			} else {
+				var startDate = prop.getDate();
+				var month = startDate.getMonth() + 1;
+				var dateString= month + &quot;-&quot; + startDate.getDate() + &quot;-&quot; + startDate.getFullYear();
+				if (!dojo.lang.isArray(this[dateString])) {
+					this.nonRecurringEvents[dateString] = [];
+				}
+				this.nonRecurringEvents[dateString].push(prop);
+			}
+		}
+	},
+
+	preComputeRecurringEvents: function(until) {
+		var calculatedEvents = function(){};
+
+		for(var x=0; x&lt;this.recurring.length; x++) {
+			var dates = this.recurring[x].getDates(until);
+			for (var y=0; y&lt;dates.length;y++) {
+				var month = dates[y].getMonth() + 1;
+				var dateStr = month + &quot;-&quot; + dates[y].getDate() + &quot;-&quot; + dates[y].getFullYear();
+				if (!dojo.lang.isArray(calculatedEvents[dateStr])) {
+					calculatedEvents[dateStr] = [];
+				}
+
+				if (!dojo.lang.inArray(calculatedEvents[dateStr], this.recurring[x])) { 
+					calculatedEvents[dateStr].push(this.recurring[x]);
+				} 
+			}
+		}
+		this.recurringEvents = calculatedEvents;
+	
+	},
+
+	getEvents: function(/* Date */ date) {
+		// summary
+		// Gets all events occuring on a particular date
+		var events = [];
+		var recur = [];
+		var nonRecur = [];
+		var month = date.getMonth() + 1;
+		var dateStr= month + &quot;-&quot; + date.getDate() + &quot;-&quot; + date.getFullYear();
+		if (dojo.lang.isArray(this.nonRecurringEvents[dateStr])) {
+			nonRecur= this.nonRecurringEvents[dateStr];
+			dojo.debug(&quot;Number of nonRecurring Events: &quot; + nonRecur.length);
+		} 
+		
+
+		if (dojo.lang.isArray(this.recurringEvents[dateStr])) {
+			recur= this.recurringEvents[dateStr];
+		} 
+
+		events = recur.concat(nonRecur);
+
+		if (events.length &gt; 0) {
+			return events;
+		} 
+
+		return null;			
+	}
+});
+
+/*
+ * STANDARD
+ */
+
+var StandardProperties = [
+	_P(&quot;dtstart&quot;, 1, true), _P(&quot;tzoffsetto&quot;, 1, true), _P(&quot;tzoffsetfrom&quot;, 1, true),
+	_P(&quot;comment&quot;), _P(&quot;rdate&quot;), _P(&quot;rrule&quot;), _P(&quot;tzname&quot;)
+];
+
+
+dojo.iCalendar.Standard = function (/* string */ body) {
+	// summary
+	// STANDARD Component
+
+	this.name = &quot;STANDARD&quot;;
+	this._ValidProperties = StandardProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.Standard, dojo.iCalendar.Component);
+
+/*
+ * DAYLIGHT
+ */
+
+var DaylightProperties = [
+	_P(&quot;dtstart&quot;, 1, true), _P(&quot;tzoffsetto&quot;, 1, true), _P(&quot;tzoffsetfrom&quot;, 1, true),
+	_P(&quot;comment&quot;), _P(&quot;rdate&quot;), _P(&quot;rrule&quot;), _P(&quot;tzname&quot;)
+];
+
+dojo.iCalendar.Daylight = function (/* string */ body) {
+	// summary
+	// Daylight Component
+	this.name = &quot;DAYLIGHT&quot;;
+	this._ValidProperties = DaylightProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.Daylight, dojo.iCalendar.Component);
+
+/*
+ * VEVENT
+ */
+
+var VEventProperties = [
+	// these can occur once only
+	_P(&quot;class&quot;, 1), _P(&quot;created&quot;, 1), _P(&quot;description&quot;, 1), _P(&quot;dtstart&quot;, 1),
+	_P(&quot;geo&quot;, 1), _P(&quot;last-mod&quot;, 1), _P(&quot;location&quot;, 1), _P(&quot;organizer&quot;, 1),
+	_P(&quot;priority&quot;, 1), _P(&quot;dtstamp&quot;, 1), _P(&quot;seq&quot;, 1), _P(&quot;status&quot;, 1),
+	_P(&quot;summary&quot;, 1), _P(&quot;transp&quot;, 1), _P(&quot;uid&quot;, 1), _P(&quot;url&quot;, 1), _P(&quot;recurid&quot;, 1),
+	// these two are exclusive
+	[_P(&quot;dtend&quot;, 1), _P(&quot;duration&quot;, 1)],
+	// these can occur many times over
+	_P(&quot;attach&quot;), _P(&quot;attendee&quot;), _P(&quot;categories&quot;), _P(&quot;comment&quot;), _P(&quot;contact&quot;),
+	_P(&quot;exdate&quot;), _P(&quot;exrule&quot;), _P(&quot;rstatus&quot;), _P(&quot;related&quot;), _P(&quot;resources&quot;),
+	_P(&quot;rdate&quot;), _P(&quot;rrule&quot;)
+];
+
+dojo.iCalendar.VEvent = function (/* string */ body) {
+	// summary 
+	// VEVENT Component
+	this._ValidProperties = VEventProperties;
+	this.name = &quot;VEVENT&quot;;
+	dojo.iCalendar.Component.call(this, body);
+	this.recurring = false;
+	this.startDate = dojo.date.fromIso8601(this.dtstart.value);
+}
+
+dojo.inherits(dojo.iCalendar.VEvent, dojo.iCalendar.Component);
+
+dojo.lang.extend(dojo.iCalendar.VEvent, {
+		getDates: function(until) {
+			var dtstart = this.getDate();
+
+			var recurranceSet = [];
+			var weekdays=[&quot;su&quot;,&quot;mo&quot;,&quot;tu&quot;,&quot;we&quot;,&quot;th&quot;,&quot;fr&quot;,&quot;sa&quot;];
+			var order = { 
+				&quot;daily&quot;: 1, &quot;weekly&quot;: 2, &quot;monthly&quot;: 3, &quot;yearly&quot;: 4,
+				&quot;byday&quot;: 1, &quot;bymonthday&quot;: 1, &quot;byweekno&quot;: 2, &quot;bymonth&quot;: 3, &quot;byyearday&quot;: 4};
+
+			// expand rrules into the recurrance 
+			for (var x=0; x&lt;this.rrule.length; x++) {
+				var rrule = this.rrule[x];
+				var freq = rrule.freq.toLowerCase();
+				var interval = 1;
+
+				if (rrule.interval &gt; interval) {
+					interval = rrule.interval;
+				}
+
+				var set = [];
+				var freqInt = order[freq];
+
+				if (rrule.until) {
+					var tmpUntil = dojo.date.fromIso8601(rrule.until);
+				} else {
+					var tmpUntil = until
+				}
+
+				if (tmpUntil &gt; until) {
+					tmpUntil = until
+				}
+
+
+				if (dtstart&lt;tmpUntil) {
+
+					var expandingRules = function(){};
+					var cullingRules = function(){};
+					expandingRules.length=0;
+					cullingRules.length =0;
+
+					switch(freq) {
+						case &quot;yearly&quot;:
+							var nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate &lt; tmpUntil) {
+								nextDate.setYear(nextDate.getFullYear()+interval);
+								tmpDate = new Date(nextDate);
+								if(tmpDate &lt; tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;
+						case &quot;monthly&quot;:
+							nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate &lt; tmpUntil) {
+								nextDate.setMonth(nextDate.getMonth()+interval);
+								var tmpDate = new Date(nextDate);
+								if (tmpDate &lt; tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;
+						case &quot;weekly&quot;:
+							nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate &lt; tmpUntil) {
+								nextDate.setDate(nextDate.getDate()+(7*interval));
+								var tmpDate = new Date(nextDate);
+								if (tmpDate &lt; tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;	
+						case &quot;daily&quot;:
+							nextDate = new Date(dtstart);
+							set.push(nextDate);
+							while(nextDate &lt; tmpUntil) {
+								nextDate.setDate(nextDate.getDate()+interval);
+								var tmpDate = new Date(nextDate);
+								if (tmpDate &lt; tmpUntil) {
+									set.push(tmpDate);
+								}
+							}
+							break;
+	
+					}
+
+					if ((rrule[&quot;bymonth&quot;]) &amp;&amp; (order[&quot;bymonth&quot;]&lt;freqInt))	{
+						for (var z=0; z&lt;rrule[&quot;bymonth&quot;].length; z++) {
+							if (z==0) {
+								for (var zz=0; zz &lt; set.length; zz++) {
+									set[zz].setMonth(rrule[&quot;bymonth&quot;][z]-1);
+								}
+							} else {
+								var subset=[];
+								for (var zz=0; zz &lt; set.length; zz++) {
+									var newDate = new Date(set[zz]);
+									newDate.setMonth(rrule[z]);
+									subset.push(newDate);
+								}
+								tmp = set.concat(subset);
+								set = tmp;
+							}
+						}
+					}
+
+					
+					// while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time
+					// and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web
+					if (rrule[&quot;byweekno&quot;] &amp;&amp; !rrule[&quot;bymonth&quot;]) {	
+						dojo.debug(&quot;TODO: no support for byweekno yet&quot;);
+					}
+
+
+					// while the spec doesn't prohibit it, it makes no sense to have a bymonth and a byweekno at the same time
+					// and if i'm wrong then i don't know how to apply that rule.  This is also documented elsewhere on the web
+					if (rrule[&quot;byyearday&quot;] &amp;&amp; !rrule[&quot;bymonth&quot;] &amp;&amp; !rrule[&quot;byweekno&quot;] ) {	
+						if (rrule[&quot;byyearday&quot;].length &gt; 1) {
+							var regex = &quot;([+-]?)([0-9]{1,3})&quot;;
+							for (var z=1; x&lt;rrule[&quot;byyearday&quot;].length; z++) {
+								var regexResult = rrule[&quot;byyearday&quot;][z].match(regex);
+								if (z==1) {
+									for (var zz=0; zz &lt; set.length; zz++) {
+										if (regexResult[1] == &quot;-&quot;) {
+											dojo.date.setDayOfYear(set[zz],366-regexResult[2]);
+										} else {
+											dojo.date.setDayOfYear(set[zz],regexResult[2]);
+										}
+									}
+								}	else {
+									var subset=[];
+									for (var zz=0; zz &lt; set.length; zz++) {
+										var newDate = new Date(set[zz]);
+										if (regexResult[1] == &quot;-&quot;) {
+											dojo.date.setDayOfYear(newDate,366-regexResult[2]);
+										} else {
+											dojo.date.setDayOfYear(newDate,regexResult[2]);
+										}
+										subset.push(newDate);
+									}
+									tmp = set.concat(subset);
+									set = tmp;
+								}
+							}
+						}
+					}
+
+					if (rrule[&quot;bymonthday&quot;]  &amp;&amp; (order[&quot;bymonthday&quot;]&lt;freqInt)) {	
+						if (rrule[&quot;bymonthday&quot;].length &gt; 0) {
+							var regex = &quot;([+-]?)([0-9]{1,3})&quot;;
+							for (var z=0; z&lt;rrule[&quot;bymonthday&quot;].length; z++) {
+								var regexResult = rrule[&quot;bymonthday&quot;][z].match(regex);
+								if (z==0) {
+									for (var zz=0; zz &lt; set.length; zz++) {
+										if (regexResult[1] == &quot;-&quot;) {
+											if (regexResult[2] &lt; dojo.date.getDaysInMonth(set[zz])) {
+												set[zz].setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
+											}
+										} else {
+											if (regexResult[2] &lt; dojo.date.getDaysInMonth(set[zz])) {
+												set[zz].setDate(regexResult[2]);
+											}
+										}
+									}
+								}	else {
+									var subset=[];
+									for (var zz=0; zz &lt; set.length; zz++) {
+										var newDate = new Date(set[zz]);
+										if (regexResult[1] == &quot;-&quot;) {
+											if (regexResult[2] &lt; dojo.date.getDaysInMonth(set[zz])) {
+												newDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
+											}
+										} else {
+											if (regexResult[2] &lt; dojo.date.getDaysInMonth(set[zz])) {
+												newDate.setDate(regexResult[2]);
+											}
+										}
+										subset.push(newDate);
+									}
+									tmp = set.concat(subset);
+									set = tmp;
+								}
+							}
+						}
+					}
+
+					if (rrule[&quot;byday&quot;]  &amp;&amp; (order[&quot;byday&quot;]&lt;freqInt)) {	
+						if (rrule[&quot;bymonth&quot;]) {
+							if (rrule[&quot;byday&quot;].length &gt; 0) {
+								var regex = &quot;([+-]?)([0-9]{0,1}?)([A-Za-z]{1,2})&quot;;
+								for (var z=0; z&lt;rrule[&quot;byday&quot;].length; z++) {
+									var regexResult = rrule[&quot;byday&quot;][z].match(regex);
+									var occurance = regexResult[2];
+									var day = regexResult[3].toLowerCase();
+
+
+									if (z==0) {
+										for (var zz=0; zz &lt; set.length; zz++) {
+											if (regexResult[1] == &quot;-&quot;) {
+												//find the nth to last occurance of date 
+												var numDaysFound = 0;
+												var lastDayOfMonth = dojo.date.getDaysInMonth(set[zz]);
+												var daysToSubtract = 1;
+												set[zz].setDate(lastDayOfMonth); 
+												if (weekdays[set[zz].getDay()] == day) {
+													numDaysFound++;
+													daysToSubtract=7;
+												}
+												daysToSubtract = 1;
+												while (numDaysFound &lt; occurance) {
+													set[zz].setDate(set[zz].getDate()-daysToSubtract);	
+													if (weekdays[set[zz].getDay()] == day) {
+														numDaysFound++;
+														daysToSubtract=7;	
+													}
+												}
+											} else {
+												if (occurance) {
+													var numDaysFound=0;
+													set[zz].setDate(1);
+													var daysToAdd=1;
+
+													if(weekdays[set[zz].getDay()] == day) {
+														numDaysFound++;
+														daysToAdd=7;
+													}
+
+													while(numDaysFound &lt; occurance) {
+														set[zz].setDate(set[zz].getDate()+daysToAdd);
+														if(weekdays[set[zz].getDay()] == day) {
+															numDaysFound++;
+															daysToAdd=7;
+														}
+													}
+												} else {
+													//we're gonna expand here to add a date for each of the specified days for each month
+													var numDaysFound=0;
+													var subset = [];
+
+													lastDayOfMonth = new Date(set[zz]);
+													var daysInMonth = dojo.date.getDaysInMonth(set[zz]);
+													lastDayOfMonth.setDate(daysInMonth);
+
+													set[zz].setDate(1);
+												
+													if (weekdays[set[zz].getDay()] == day) {
+														numDaysFound++;
+													}
+													var tmpDate = new Date(set[zz]);
+													daysToAdd = 1;
+													while(tmpDate.getDate() &lt; lastDayOfMonth) {
+														if (weekdays[tmpDate.getDay()] == day) {
+															numDaysFound++;
+															if (numDaysFound==1) {
+																set[zz] = tmpDate;
+															} else {
+																subset.push(tmpDate);
+																tmpDate = new Date(tmpDate);
+																daysToAdd=7;	
+																tmpDate.setDate(tmpDate.getDate() + daysToAdd);
+															}
+														} else {
+															tmpDate.setDate(tmpDate.getDate() + daysToAdd);
+														}
+													}
+													var t = set.concat(subset);
+													set = t; 
+												}
+											}
+										}
+									}	else {
+										var subset=[];
+										for (var zz=0; zz &lt; set.length; zz++) {
+											var newDate = new Date(set[zz]);
+											if (regexResult[1] == &quot;-&quot;) {
+												if (regexResult[2] &lt; dojo.date.getDaysInMonth(set[zz])) {
+													newDate.setDate(dojo.date.getDaysInMonth(set[zz]) - regexResult[2]);
+												}
+											} else {
+												if (regexResult[2] &lt; dojo.date.getDaysInMonth(set[zz])) {
+													newDate.setDate(regexResult[2]);
+												}
+											}
+											subset.push(newDate);
+										}
+										tmp = set.concat(subset);
+										set = tmp;
+									}
+								}
+							}
+						} else {
+							dojo.debug(&quot;TODO: byday within a yearly rule without a bymonth&quot;);
+						}
+					}
+
+					dojo.debug(&quot;TODO: Process BYrules for units larger than frequency&quot;);
+			
+					//add this set of events to the complete recurranceSet	
+					var tmp = recurranceSet.concat(set);
+					recurranceSet = tmp;
+				}
+			}
+
+			// TODO: add rdates to the recurrance set here
+
+			// TODO: subtract exdates from the recurrance set here
+
+			//TODO:  subtract dates generated by exrules from recurranceSet here
+
+			recurranceSet.push(dtstart);
+			return recurranceSet;
+		},
+
+		getDate: function() {
+			return dojo.date.fromIso8601(this.dtstart.value);
+		}
+});
+
+/*
+ * VTIMEZONE
+ */
+
+var VTimeZoneProperties = [
+	_P(&quot;tzid&quot;, 1, true), _P(&quot;last-mod&quot;, 1), _P(&quot;tzurl&quot;, 1)
+
+	// one of 'standardc' or 'daylightc' must occur
+	// and each may occur more than once.
+];
+
+dojo.iCalendar.VTimeZone = function (/* string */ body) {
+	// summary
+	// VTIMEZONE Component
+	this.name = &quot;VTIMEZONE&quot;;
+	this._ValidProperties = VTimeZoneProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VTimeZone, dojo.iCalendar.Component);
+
+/*
+ * VTODO
+ */
+
+var VTodoProperties = [
+	// these can occur once only
+	_P(&quot;class&quot;, 1), _P(&quot;completed&quot;, 1), _P(&quot;created&quot;, 1), _P(&quot;description&quot;, 1),
+	_P(&quot;dtstart&quot;, 1), _P(&quot;geo&quot;, 1), _P(&quot;last-mod&quot;, 1), _P(&quot;location&quot;, 1),
+	_P(&quot;organizer&quot;, 1), _P(&quot;percent&quot;, 1), _P(&quot;priority&quot;, 1), _P(&quot;dtstamp&quot;, 1),
+	_P(&quot;seq&quot;, 1), _P(&quot;status&quot;, 1), _P(&quot;summary&quot;, 1), _P(&quot;uid&quot;, 1), _P(&quot;url&quot;, 1),
+	_P(&quot;recurid&quot;, 1),
+	// these two are exclusive
+	[_P(&quot;due&quot;, 1), _P(&quot;duration&quot;, 1)],
+	// these can occur many times over
+	_P(&quot;attach&quot;), _P(&quot;attendee&quot;), _P(&quot;categories&quot;), _P(&quot;comment&quot;), _P(&quot;contact&quot;),
+	_P(&quot;exdate&quot;), _P(&quot;exrule&quot;), _P(&quot;rstatus&quot;), _P(&quot;related&quot;), _P(&quot;resources&quot;),
+	_P(&quot;rdate&quot;), _P(&quot;rrule&quot;)
+];
+
+dojo.iCalendar.VTodo= function (/* string */ body) {
+	// summary
+	// VTODO Componenet
+	this.name = &quot;VTODO&quot;;
+	this._ValidProperties = VTodoProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VTodo, dojo.iCalendar.Component);
+
+/*
+ * VJOURNAL
+ */
+
+var VJournalProperties = [
+	// these can occur once only
+	_P(&quot;class&quot;, 1), _P(&quot;created&quot;, 1), _P(&quot;description&quot;, 1), _P(&quot;dtstart&quot;, 1),
+	_P(&quot;last-mod&quot;, 1), _P(&quot;organizer&quot;, 1), _P(&quot;dtstamp&quot;, 1), _P(&quot;seq&quot;, 1),
+	_P(&quot;status&quot;, 1), _P(&quot;summary&quot;, 1), _P(&quot;uid&quot;, 1), _P(&quot;url&quot;, 1), _P(&quot;recurid&quot;, 1),
+	// these can occur many times over
+	_P(&quot;attach&quot;), _P(&quot;attendee&quot;), _P(&quot;categories&quot;), _P(&quot;comment&quot;), _P(&quot;contact&quot;),
+	_P(&quot;exdate&quot;), _P(&quot;exrule&quot;), _P(&quot;related&quot;), _P(&quot;rstatus&quot;), _P(&quot;rdate&quot;), _P(&quot;rrule&quot;)
+];
+
+dojo.iCalendar.VJournal= function (/* string */ body) {
+	// summary
+	// VJOURNAL Component
+	this.name = &quot;VJOURNAL&quot;;
+	this._ValidProperties = VJournalProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VJournal, dojo.iCalendar.Component);
+
+/*
+ * VFREEBUSY
+ */
+
+var VFreeBusyProperties = [
+	// these can occur once only
+	_P(&quot;contact&quot;), _P(&quot;dtstart&quot;, 1), _P(&quot;dtend&quot;), _P(&quot;duration&quot;),
+	_P(&quot;organizer&quot;, 1), _P(&quot;dtstamp&quot;, 1), _P(&quot;uid&quot;, 1), _P(&quot;url&quot;, 1),
+	// these can occur many times over
+	_P(&quot;attendee&quot;), _P(&quot;comment&quot;), _P(&quot;freebusy&quot;), _P(&quot;rstatus&quot;)
+];
+
+dojo.iCalendar.VFreeBusy= function (/* string */ body) {
+	// summary
+	// VFREEBUSY Component
+	this.name = &quot;VFREEBUSY&quot;;
+	this._ValidProperties = VFreeBusyProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VFreeBusy, dojo.iCalendar.Component);
+
+/*
+ * VALARM
+ */
+
+var VAlarmProperties = [
+	[_P(&quot;action&quot;, 1, true), _P(&quot;trigger&quot;, 1, true), [_P(&quot;duration&quot;, 1), _P(&quot;repeat&quot;, 1)],
+	_P(&quot;attach&quot;, 1)],
+
+	[_P(&quot;action&quot;, 1, true), _P(&quot;description&quot;, 1, true), _P(&quot;trigger&quot;, 1, true),
+	[_P(&quot;duration&quot;, 1), _P(&quot;repeat&quot;, 1)]],
+
+	[_P(&quot;action&quot;, 1, true), _P(&quot;description&quot;, 1, true), _P(&quot;trigger&quot;, 1, true),
+	_P(&quot;summary&quot;, 1, true), _P(&quot;attendee&quot;, &quot;*&quot;, true),
+	[_P(&quot;duration&quot;, 1), _P(&quot;repeat&quot;, 1)],
+	_P(&quot;attach&quot;, 1)],
+
+	[_P(&quot;action&quot;, 1, true), _P(&quot;attach&quot;, 1, true), _P(&quot;trigger&quot;, 1, true),
+	[_P(&quot;duration&quot;, 1), _P(&quot;repeat&quot;, 1)],
+	_P(&quot;description&quot;, 1)],
+];
+
+dojo.iCalendar.VAlarm= function (/* string */ body) {
+	// summary
+	// VALARM Component
+	this.name = &quot;VALARM&quot;;
+	this._ValidProperties = VAlarmProperties;
+	dojo.iCalendar.Component.call(this, body);
+}
+
+dojo.inherits(dojo.iCalendar.VAlarm, dojo.iCalendar.Component);
+

Added: trunk/root/static/magic/src/io/BrowserIO.js
===================================================================
--- trunk/root/static/magic/src/io/BrowserIO.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/BrowserIO.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,557 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.BrowserIO&quot;);
+
+dojo.require(&quot;dojo.io&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.string.extras&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.undo.browser&quot;);
+
+dojo.io.checkChildrenForFile = function(node){
+	var hasFile = false;
+	var inputs = node.getElementsByTagName(&quot;input&quot;);
+	dojo.lang.forEach(inputs, function(input){
+		if(hasFile){ return; }
+		if(input.getAttribute(&quot;type&quot;)==&quot;file&quot;){
+			hasFile = true;
+		}
+	});
+	return hasFile;
+}
+
+dojo.io.formHasFile = function(formNode){
+	return dojo.io.checkChildrenForFile(formNode);
+}
+
+dojo.io.updateNode = function(node, urlOrArgs){
+	node = dojo.byId(node);
+	var args = urlOrArgs;
+	if(dojo.lang.isString(urlOrArgs)){
+		args = { url: urlOrArgs };
+	}
+	args.mimetype = &quot;text/html&quot;;
+	args.load = function(t, d, e){
+		while(node.firstChild){
+			if(dojo[&quot;event&quot;]){
+				try{
+					dojo.event.browser.clean(node.firstChild);
+				}catch(e){}
+			}
+			node.removeChild(node.firstChild);
+		}
+		node.innerHTML = d;
+	};
+	dojo.io.bind(args);
+}
+
+dojo.io.formFilter = function(node) {
+	var type = (node.type||&quot;&quot;).toLowerCase();
+	return !node.disabled &amp;&amp; node.name
+		&amp;&amp; !dojo.lang.inArray(type, [&quot;file&quot;, &quot;submit&quot;, &quot;image&quot;, &quot;reset&quot;, &quot;button&quot;]);
+}
+
+// TODO: Move to htmlUtils
+dojo.io.encodeForm = function(formNode, encoding, formFilter){
+	if((!formNode)||(!formNode.tagName)||(!formNode.tagName.toLowerCase() == &quot;form&quot;)){
+		dojo.raise(&quot;Attempted to encode a non-form element.&quot;);
+	}
+	if(!formFilter) { formFilter = dojo.io.formFilter; }
+	var enc = /utf/i.test(encoding||&quot;&quot;) ? encodeURIComponent : dojo.string.encodeAscii;
+	var values = [];
+
+	for(var i = 0; i &lt; formNode.elements.length; i++){
+		var elm = formNode.elements[i];
+		if(!elm || elm.tagName.toLowerCase() == &quot;fieldset&quot; || !formFilter(elm)) { continue; }
+		var name = enc(elm.name);
+		var type = elm.type.toLowerCase();
+
+		if(type == &quot;select-multiple&quot;){
+			for(var j = 0; j &lt; elm.options.length; j++){
+				if(elm.options[j].selected) {
+					values.push(name + &quot;=&quot; + enc(elm.options[j].value));
+				}
+			}
+		}else if(dojo.lang.inArray(type, [&quot;radio&quot;, &quot;checkbox&quot;])){
+			if(elm.checked){
+				values.push(name + &quot;=&quot; + enc(elm.value));
+			}
+		}else{
+			values.push(name + &quot;=&quot; + enc(elm.value));
+		}
+	}
+
+	// now collect input type=&quot;image&quot;, which doesn't show up in the elements array
+	var inputs = formNode.getElementsByTagName(&quot;input&quot;);
+	for(var i = 0; i &lt; inputs.length; i++) {
+		var input = inputs[i];
+		if(input.type.toLowerCase() == &quot;image&quot; &amp;&amp; input.form == formNode
+			&amp;&amp; formFilter(input)) {
+			var name = enc(input.name);
+			values.push(name + &quot;=&quot; + enc(input.value));
+			values.push(name + &quot;.x=0&quot;);
+			values.push(name + &quot;.y=0&quot;);
+		}
+	}
+	return values.join(&quot;&amp;&quot;) + &quot;&amp;&quot;;
+}
+
+dojo.io.FormBind = function(args) {
+	this.bindArgs = {};
+
+	if(args &amp;&amp; args.formNode) {
+		this.init(args);
+	} else if(args) {
+		this.init({formNode: args});
+	}
+}
+dojo.lang.extend(dojo.io.FormBind, {
+	form: null,
+
+	bindArgs: null,
+
+	clickedButton: null,
+
+	init: function(args) {
+		var form = dojo.byId(args.formNode);
+
+		if(!form || !form.tagName || form.tagName.toLowerCase() != &quot;form&quot;) {
+			throw new Error(&quot;FormBind: Couldn't apply, invalid form&quot;);
+		} else if(this.form == form) {
+			return;
+		} else if(this.form) {
+			throw new Error(&quot;FormBind: Already applied to a form&quot;);
+		}
+
+		dojo.lang.mixin(this.bindArgs, args);
+		this.form = form;
+
+		this.connect(form, &quot;onsubmit&quot;, &quot;submit&quot;);
+
+		for(var i = 0; i &lt; form.elements.length; i++) {
+			var node = form.elements[i];
+			if(node &amp;&amp; node.type &amp;&amp; dojo.lang.inArray(node.type.toLowerCase(), [&quot;submit&quot;, &quot;button&quot;])) {
+				this.connect(node, &quot;onclick&quot;, &quot;click&quot;);
+			}
+		}
+
+		var inputs = form.getElementsByTagName(&quot;input&quot;);
+		for(var i = 0; i &lt; inputs.length; i++) {
+			var input = inputs[i];
+			if(input.type.toLowerCase() == &quot;image&quot; &amp;&amp; input.form == form) {
+				this.connect(input, &quot;onclick&quot;, &quot;click&quot;);
+			}
+		}
+	},
+
+	onSubmit: function(form) {
+		return true;
+	},
+
+	submit: function(e) {
+		e.preventDefault();
+		if(this.onSubmit(this.form)) {
+			dojo.io.bind(dojo.lang.mixin(this.bindArgs, {
+				formFilter: dojo.lang.hitch(this, &quot;formFilter&quot;)
+			}));
+		}
+	},
+
+	click: function(e) {
+		var node = e.currentTarget;
+		if(node.disabled) { return; }
+		this.clickedButton = node;
+	},
+
+	formFilter: function(node) {
+		var type = (node.type||&quot;&quot;).toLowerCase();
+		var accept = false;
+		if(node.disabled || !node.name) {
+			accept = false;
+		} else if(dojo.lang.inArray(type, [&quot;submit&quot;, &quot;button&quot;, &quot;image&quot;])) {
+			if(!this.clickedButton) { this.clickedButton = node; }
+			accept = node == this.clickedButton;
+		} else {
+			accept = !dojo.lang.inArray(type, [&quot;file&quot;, &quot;submit&quot;, &quot;reset&quot;, &quot;button&quot;]);
+		}
+		return accept;
+	},
+
+	// in case you don't have dojo.event.* pulled in
+	connect: function(srcObj, srcFcn, targetFcn) {
+		if(dojo.evalObjPath(&quot;dojo.event.connect&quot;)) {
+			dojo.event.connect(srcObj, srcFcn, this, targetFcn);
+		} else {
+			var fcn = dojo.lang.hitch(this, targetFcn);
+			srcObj[srcFcn] = function(e) {
+				if(!e) { e = window.event; }
+				if(!e.currentTarget) { e.currentTarget = e.srcElement; }
+				if(!e.preventDefault) { e.preventDefault = function() { window.event.returnValue = false; } }
+				fcn(e);
+			}
+		}
+	}
+});
+
+dojo.io.XMLHTTPTransport = new function(){
+	var _this = this;
+
+	var _cache = {}; // FIXME: make this public? do we even need to?
+	this.useCache = false; // if this is true, we'll cache unless kwArgs.useCache = false
+	this.preventCache = false; // if this is true, we'll always force GET requests to cache
+
+	// FIXME: Should this even be a function? or do we just hard code it in the next 2 functions?
+	function getCacheKey(url, query, method) {
+		return url + &quot;|&quot; + query + &quot;|&quot; + method.toLowerCase();
+	}
+
+	function addToCache(url, query, method, http) {
+		_cache[getCacheKey(url, query, method)] = http;
+	}
+
+	function getFromCache(url, query, method) {
+		return _cache[getCacheKey(url, query, method)];
+	}
+
+	this.clearCache = function() {
+		_cache = {};
+	}
+
+	// moved successful load stuff here
+	function doLoad(kwArgs, http, url, query, useCache) {
+		if(	((http.status&gt;=200)&amp;&amp;(http.status&lt;300))|| 	// allow any 2XX response code
+			(http.status==304)|| 						// get it out of the cache
+			(location.protocol==&quot;file:&quot; &amp;&amp; (http.status==0 || http.status==undefined))||
+			(location.protocol==&quot;chrome:&quot; &amp;&amp; (http.status==0 || http.status==undefined))
+		){
+			var ret;
+			if(kwArgs.method.toLowerCase() == &quot;head&quot;){
+				var headers = http.getAllResponseHeaders();
+				ret = {};
+				ret.toString = function(){ return headers; }
+				var values = headers.split(/[\r\n]+/g);
+				for(var i = 0; i &lt; values.length; i++) {
+					var pair = values[i].match(/^([^:]+)\s*:\s*(.+)$/i);
+					if(pair) {
+						ret[pair[1]] = pair[2];
+					}
+				}
+			}else if(kwArgs.mimetype == &quot;text/javascript&quot;){
+				try{
+					ret = dj_eval(http.responseText);
+				}catch(e){
+					dojo.debug(e);
+					dojo.debug(http.responseText);
+					ret = null;
+				}
+			}else if(kwArgs.mimetype == &quot;text/json&quot;){
+				try{
+					ret = dj_eval(&quot;(&quot;+http.responseText+&quot;)&quot;);
+				}catch(e){
+					dojo.debug(e);
+					dojo.debug(http.responseText);
+					ret = false;
+				}
+			}else if((kwArgs.mimetype == &quot;application/xml&quot;)||
+						(kwArgs.mimetype == &quot;text/xml&quot;)){
+				ret = http.responseXML;
+				if(!ret || typeof ret == &quot;string&quot; || !http.getResponseHeader(&quot;Content-Type&quot;)) {
+					ret = dojo.dom.createDocumentFromText(http.responseText);
+				}
+			}else{
+				ret = http.responseText;
+			}
+
+			if(useCache){ // only cache successful responses
+				addToCache(url, query, kwArgs.method, http);
+			}
+			kwArgs[(typeof kwArgs.load == &quot;function&quot;) ? &quot;load&quot; : &quot;handle&quot;](&quot;load&quot;, ret, http, kwArgs);
+		}else{
+			var errObj = new dojo.io.Error(&quot;XMLHttpTransport Error: &quot;+http.status+&quot; &quot;+http.statusText);
+			kwArgs[(typeof kwArgs.error == &quot;function&quot;) ? &quot;error&quot; : &quot;handle&quot;](&quot;error&quot;, errObj, http, kwArgs);
+		}
+	}
+
+	// set headers (note: Content-Type will get overriden if kwArgs.contentType is set)
+	function setHeaders(http, kwArgs){
+		if(kwArgs[&quot;headers&quot;]) {
+			for(var header in kwArgs[&quot;headers&quot;]) {
+				if(header.toLowerCase() == &quot;content-type&quot; &amp;&amp; !kwArgs[&quot;contentType&quot;]) {
+					kwArgs[&quot;contentType&quot;] = kwArgs[&quot;headers&quot;][header];
+				} else {
+					http.setRequestHeader(header, kwArgs[&quot;headers&quot;][header]);
+				}
+			}
+		}
+	}
+
+	this.inFlight = [];
+	this.inFlightTimer = null;
+
+	this.startWatchingInFlight = function(){
+		if(!this.inFlightTimer){
+			this.inFlightTimer = setInterval(&quot;dojo.io.XMLHTTPTransport.watchInFlight();&quot;, 10);
+		}
+	}
+
+	this.watchInFlight = function(){
+		var now = null;
+		for(var x=this.inFlight.length-1; x&gt;=0; x--){
+			var tif = this.inFlight[x];
+			if(!tif){ this.inFlight.splice(x, 1); continue; }
+			if(4==tif.http.readyState){
+				// remove it so we can clean refs
+				this.inFlight.splice(x, 1);
+				doLoad(tif.req, tif.http, tif.url, tif.query, tif.useCache);
+			}else if (tif.startTime){
+				//See if this is a timeout case.
+				if(!now){
+					now = (new Date()).getTime();
+				}
+				if(tif.startTime + (tif.req.timeoutSeconds * 1000) &lt; now){
+					//Stop the request.
+					if(typeof tif.http.abort == &quot;function&quot;){
+						tif.http.abort();
+					}
+
+					// remove it so we can clean refs
+					this.inFlight.splice(x, 1);
+					tif.req[(typeof tif.req.timeout == &quot;function&quot;) ? &quot;timeout&quot; : &quot;handle&quot;](&quot;timeout&quot;, null, tif.http, tif.req);
+				}
+			}
+		}
+
+		if(this.inFlight.length == 0){
+			clearInterval(this.inFlightTimer);
+			this.inFlightTimer = null;
+		}
+	}
+
+	var hasXmlHttp = dojo.hostenv.getXmlhttpObject() ? true : false;
+	this.canHandle = function(kwArgs){
+		// canHandle just tells dojo.io.bind() if this is a good transport to
+		// use for the particular type of request.
+
+		// FIXME: we need to determine when form values need to be
+		// multi-part mime encoded and avoid using this transport for those
+		// requests.
+		return hasXmlHttp
+			&amp;&amp; dojo.lang.inArray((kwArgs[&quot;mimetype&quot;].toLowerCase()||&quot;&quot;), [&quot;text/plain&quot;, &quot;text/html&quot;, &quot;application/xml&quot;, &quot;text/xml&quot;, &quot;text/javascript&quot;, &quot;text/json&quot;])
+			&amp;&amp; !( kwArgs[&quot;formNode&quot;] &amp;&amp; dojo.io.formHasFile(kwArgs[&quot;formNode&quot;]) );
+	}
+
+	this.multipartBoundary = &quot;45309FFF-BD65-4d50-99C9-36986896A96F&quot;;	// unique guid as a boundary value for multipart posts
+
+	this.bind = function(kwArgs){
+		if(!kwArgs[&quot;url&quot;]){
+			// are we performing a history action?
+			if( !kwArgs[&quot;formNode&quot;]
+				&amp;&amp; (kwArgs[&quot;backButton&quot;] || kwArgs[&quot;back&quot;] || kwArgs[&quot;changeUrl&quot;] || kwArgs[&quot;watchForURL&quot;])
+				&amp;&amp; (!djConfig.preventBackButtonFix)) {
+        dojo.deprecated(&quot;Using dojo.io.XMLHTTPTransport.bind() to add to browser history without doing an IO request&quot;,
+        				&quot;Use dojo.undo.browser.addToHistory() instead.&quot;, &quot;0.4&quot;);
+				dojo.undo.browser.addToHistory(kwArgs);
+				return true;
+			}
+		}
+
+		// build this first for cache purposes
+		var url = kwArgs.url;
+		var query = &quot;&quot;;
+		if(kwArgs[&quot;formNode&quot;]){
+			var ta = kwArgs.formNode.getAttribute(&quot;action&quot;);
+			if((ta)&amp;&amp;(!kwArgs[&quot;url&quot;])){ url = ta; }
+			var tp = kwArgs.formNode.getAttribute(&quot;method&quot;);
+			if((tp)&amp;&amp;(!kwArgs[&quot;method&quot;])){ kwArgs.method = tp; }
+			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[&quot;formFilter&quot;]);
+		}
+
+		if(url.indexOf(&quot;#&quot;) &gt; -1) {
+			dojo.debug(&quot;Warning: dojo.io.bind: stripping hash values from url:&quot;, url);
+			url = url.split(&quot;#&quot;)[0];
+		}
+
+		if(kwArgs[&quot;file&quot;]){
+			// force post for file transfer
+			kwArgs.method = &quot;post&quot;;
+		}
+
+		if(!kwArgs[&quot;method&quot;]){
+			kwArgs.method = &quot;get&quot;;
+		}
+
+		// guess the multipart value		
+		if(kwArgs.method.toLowerCase() == &quot;get&quot;){
+			// GET cannot use multipart
+			kwArgs.multipart = false;
+		}else{
+			if(kwArgs[&quot;file&quot;]){
+				// enforce multipart when sending files
+				kwArgs.multipart = true;
+			}else if(!kwArgs[&quot;multipart&quot;]){
+				// default 
+				kwArgs.multipart = false;
+			}
+		}
+
+		if(kwArgs[&quot;backButton&quot;] || kwArgs[&quot;back&quot;] || kwArgs[&quot;changeUrl&quot;]){
+			dojo.undo.browser.addToHistory(kwArgs);
+		}
+
+		var content = kwArgs[&quot;content&quot;] || {};
+
+		if(kwArgs.sendTransport) {
+			content[&quot;dojo.transport&quot;] = &quot;xmlhttp&quot;;
+		}
+
+		do { // break-block
+			if(kwArgs.postContent){
+				query = kwArgs.postContent;
+				break;
+			}
+
+			if(content) {
+				query += dojo.io.argsFromMap(content, kwArgs.encoding);
+			}
+			
+			if(kwArgs.method.toLowerCase() == &quot;get&quot; || !kwArgs.multipart){
+				break;
+			}
+
+			var	t = [];
+			if(query.length){
+				var q = query.split(&quot;&amp;&quot;);
+				for(var i = 0; i &lt; q.length; ++i){
+					if(q[i].length){
+						var p = q[i].split(&quot;=&quot;);
+						t.push(	&quot;--&quot; + this.multipartBoundary,
+								&quot;Content-Disposition: form-data; name=\&quot;&quot; + p[0] + &quot;\&quot;&quot;, 
+								&quot;&quot;,
+								p[1]);
+					}
+				}
+			}
+
+			if(kwArgs.file){
+				if(dojo.lang.isArray(kwArgs.file)){
+					for(var i = 0; i &lt; kwArgs.file.length; ++i){
+						var o = kwArgs.file[i];
+						t.push(	&quot;--&quot; + this.multipartBoundary,
+								&quot;Content-Disposition: form-data; name=\&quot;&quot; + o.name + &quot;\&quot;; filename=\&quot;&quot; + (&quot;fileName&quot; in o ? o.fileName : o.name) + &quot;\&quot;&quot;,
+								&quot;Content-Type: &quot; + (&quot;contentType&quot; in o ? o.contentType : &quot;application/octet-stream&quot;),
+								&quot;&quot;,
+								o.content);
+					}
+				}else{
+					var o = kwArgs.file;
+					t.push(	&quot;--&quot; + this.multipartBoundary,
+							&quot;Content-Disposition: form-data; name=\&quot;&quot; + o.name + &quot;\&quot;; filename=\&quot;&quot; + (&quot;fileName&quot; in o ? o.fileName : o.name) + &quot;\&quot;&quot;,
+							&quot;Content-Type: &quot; + (&quot;contentType&quot; in o ? o.contentType : &quot;application/octet-stream&quot;),
+							&quot;&quot;,
+							o.content);
+				}
+			}
+
+			if(t.length){
+				t.push(&quot;--&quot;+this.multipartBoundary+&quot;--&quot;, &quot;&quot;);
+				query = t.join(&quot;\r\n&quot;);
+			}
+		}while(false);
+
+		// kwArgs.Connection = &quot;close&quot;;
+
+		var async = kwArgs[&quot;sync&quot;] ? false : true;
+
+		var preventCache = kwArgs[&quot;preventCache&quot;] ||
+			(this.preventCache == true &amp;&amp; kwArgs[&quot;preventCache&quot;] != false);
+		var useCache = kwArgs[&quot;useCache&quot;] == true ||
+			(this.useCache == true &amp;&amp; kwArgs[&quot;useCache&quot;] != false );
+
+		// preventCache is browser-level (add query string junk), useCache
+		// is for the local cache. If we say preventCache, then don't attempt
+		// to look in the cache, but if useCache is true, we still want to cache
+		// the response
+		if(!preventCache &amp;&amp; useCache){
+			var cachedHttp = getFromCache(url, query, kwArgs.method);
+			if(cachedHttp){
+				doLoad(kwArgs, cachedHttp, url, query, false);
+				return;
+			}
+		}
+
+		// much of this is from getText, but reproduced here because we need
+		// more flexibility
+		var http = dojo.hostenv.getXmlhttpObject(kwArgs);	
+		var received = false;
+
+		// build a handler function that calls back to the handler obj
+		if(async){
+			var startTime = 
+			// FIXME: setting up this callback handler leaks on IE!!!
+			this.inFlight.push({
+				&quot;req&quot;:		kwArgs,
+				&quot;http&quot;:		http,
+				&quot;url&quot;:	 	url,
+				&quot;query&quot;:	query,
+				&quot;useCache&quot;:	useCache,
+				&quot;startTime&quot;: kwArgs.timeoutSeconds ? (new Date()).getTime() : 0
+			});
+			this.startWatchingInFlight();
+		}
+
+		if(kwArgs.method.toLowerCase() == &quot;post&quot;){
+			// FIXME: need to hack in more flexible Content-Type setting here!
+			http.open(&quot;POST&quot;, url, async);
+			setHeaders(http, kwArgs);
+			http.setRequestHeader(&quot;Content-Type&quot;, kwArgs.multipart ? (&quot;multipart/form-data; boundary=&quot; + this.multipartBoundary) : 
+				(kwArgs.contentType || &quot;application/x-www-form-urlencoded&quot;));
+			try{
+				http.send(query);
+			}catch(e){
+				if(typeof http.abort == &quot;function&quot;){
+					http.abort();
+				}
+				doLoad(kwArgs, {status: 404}, url, query, useCache);
+			}
+		}else{
+			var tmpUrl = url;
+			if(query != &quot;&quot;) {
+				tmpUrl += (tmpUrl.indexOf(&quot;?&quot;) &gt; -1 ? &quot;&amp;&quot; : &quot;?&quot;) + query;
+			}
+			if(preventCache) {
+				tmpUrl += (dojo.string.endsWithAny(tmpUrl, &quot;?&quot;, &quot;&amp;&quot;)
+					? &quot;&quot; : (tmpUrl.indexOf(&quot;?&quot;) &gt; -1 ? &quot;&amp;&quot; : &quot;?&quot;)) + &quot;dojo.preventCache=&quot; + new Date().valueOf();
+			}
+			http.open(kwArgs.method.toUpperCase(), tmpUrl, async);
+			setHeaders(http, kwArgs);
+			try {
+				http.send(null);
+			}catch(e)	{
+				if(typeof http.abort == &quot;function&quot;){
+					http.abort();
+				}
+				doLoad(kwArgs, {status: 404}, url, query, useCache);
+			}
+		}
+
+		if( !async ) {
+			doLoad(kwArgs, http, url, query, useCache);
+		}
+
+		kwArgs.abort = function(){
+			return http.abort();
+		}
+
+		return;
+	}
+	dojo.io.transports.addTransport(&quot;XMLHTTPTransport&quot;);
+}

Added: trunk/root/static/magic/src/io/IframeIO.js
===================================================================
--- trunk/root/static/magic/src/io/IframeIO.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/IframeIO.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,253 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.IframeIO&quot;);
+dojo.require(&quot;dojo.io.BrowserIO&quot;);
+dojo.require(&quot;dojo.uri.*&quot;);
+
+// FIXME: is it possible to use the Google htmlfile hack to prevent the
+// background click with this transport?
+
+dojo.io.createIFrame = function(fname, onloadstr){
+	if(window[fname]){ return window[fname]; }
+	if(window.frames[fname]){ return window.frames[fname]; }
+	var r = dojo.render.html;
+	var cframe = null;
+	var turi = dojo.uri.dojoUri(&quot;iframe_history.html?noInit=true&quot;);
+	var ifrstr = ((r.ie)&amp;&amp;(dojo.render.os.win)) ? &quot;&lt;iframe name='&quot;+fname+&quot;' src='&quot;+turi+&quot;' onload='&quot;+onloadstr+&quot;'&gt;&quot; : &quot;iframe&quot;;
+	cframe = document.createElement(ifrstr);
+	with(cframe){
+		name = fname;
+		setAttribute(&quot;name&quot;, fname);
+		id = fname;
+	}
+	(document.body||document.getElementsByTagName(&quot;body&quot;)[0]).appendChild(cframe);
+	window[fname] = cframe;
+	with(cframe.style){
+		position = &quot;absolute&quot;;
+		left = top = &quot;0px&quot;;
+		height = width = &quot;1px&quot;;
+		visibility = &quot;hidden&quot;;
+		/*
+		if(djConfig.isDebug){
+			position = &quot;relative&quot;;
+			height = &quot;300px&quot;;
+			width = &quot;600px&quot;;
+			visibility = &quot;visible&quot;;
+		}
+		*/
+	}
+
+	if(!r.ie){
+		dojo.io.setIFrameSrc(cframe, turi, true);
+		cframe.onload = new Function(onloadstr);
+	}
+	return cframe;
+}
+
+// thanks burstlib!
+dojo.io.iframeContentWindow = function(iframe_el) {
+	var win = iframe_el.contentWindow || // IE
+		dojo.io.iframeContentDocument(iframe_el).defaultView || // Moz, opera
+		// Moz. TODO: is this available when defaultView isn't?
+		dojo.io.iframeContentDocument(iframe_el).__parent__ || 
+		(iframe_el.name &amp;&amp; document.frames[iframe_el.name]) || null;
+	return win;
+}
+
+dojo.io.iframeContentDocument = function(iframe_el){
+	var doc = iframe_el.contentDocument || // W3
+		(
+			(iframe_el.contentWindow)&amp;&amp;(iframe_el.contentWindow.document)
+		) ||  // IE
+		(
+			(iframe_el.name)&amp;&amp;(document.frames[iframe_el.name])&amp;&amp;
+			(document.frames[iframe_el.name].document)
+		) || null;
+	return doc;
+}
+
+dojo.io.IframeTransport = new function(){
+	var _this = this;
+	this.currentRequest = null;
+	this.requestQueue = [];
+	this.iframeName = &quot;dojoIoIframe&quot;;
+
+	this.fireNextRequest = function(){
+		if((this.currentRequest)||(this.requestQueue.length == 0)){ return; }
+		// dojo.debug(&quot;fireNextRequest&quot;);
+		var cr = this.currentRequest = this.requestQueue.shift();
+		cr._contentToClean = [];
+		var fn = cr[&quot;formNode&quot;];
+		var content = cr[&quot;content&quot;] || {};
+		if(cr.sendTransport) {
+			content[&quot;dojo.transport&quot;] = &quot;iframe&quot;;
+		}
+		if(fn){
+			if(content){
+				// if we have things in content, we need to add them to the form
+				// before submission
+				for(var x in content){
+					if(!fn[x]){
+						var tn;
+						if(dojo.render.html.ie){
+							tn = document.createElement(&quot;&lt;input type='hidden' name='&quot;+x+&quot;' value='&quot;+content[x]+&quot;'&gt;&quot;);
+							fn.appendChild(tn);
+						}else{
+							tn = document.createElement(&quot;input&quot;);
+							fn.appendChild(tn);
+							tn.type = &quot;hidden&quot;;
+							tn.name = x;
+							tn.value = content[x];
+						}
+						cr._contentToClean.push(x);
+					}else{
+						fn[x].value = content[x];
+					}
+				}
+			}
+			if(cr[&quot;url&quot;]){
+				cr._originalAction = fn.getAttribute(&quot;action&quot;);
+				fn.setAttribute(&quot;action&quot;, cr.url);
+			}
+			if(!fn.getAttribute(&quot;method&quot;)){
+				fn.setAttribute(&quot;method&quot;, (cr[&quot;method&quot;]) ? cr[&quot;method&quot;] : &quot;post&quot;);
+			}
+			cr._originalTarget = fn.getAttribute(&quot;target&quot;);
+			fn.setAttribute(&quot;target&quot;, this.iframeName);
+			fn.target = this.iframeName;
+			fn.submit();
+		}else{
+			// otherwise we post a GET string by changing URL location for the
+			// iframe
+			var query = dojo.io.argsFromMap(this.currentRequest.content);
+			var tmpUrl = (cr.url.indexOf(&quot;?&quot;) &gt; -1 ? &quot;&amp;&quot; : &quot;?&quot;) + query;
+			dojo.io.setIFrameSrc(this.iframe, tmpUrl, true);
+		}
+	}
+
+	this.canHandle = function(kwArgs){
+		return (
+			(
+				// FIXME: can we really handle text/plain and
+				// text/javascript requests?
+				dojo.lang.inArray(kwArgs[&quot;mimetype&quot;], 
+				[	&quot;text/plain&quot;, &quot;text/html&quot;, 
+					&quot;text/javascript&quot;, &quot;text/json&quot;])
+			)&amp;&amp;(
+				// make sur we really only get used in file upload cases	
+				(kwArgs[&quot;formNode&quot;])&amp;&amp;(dojo.io.checkChildrenForFile(kwArgs[&quot;formNode&quot;]))
+			)&amp;&amp;(
+				dojo.lang.inArray(kwArgs[&quot;method&quot;].toLowerCase(), [&quot;post&quot;, &quot;get&quot;])
+			)&amp;&amp;(
+				// never handle a sync request
+				!  ((kwArgs[&quot;sync&quot;])&amp;&amp;(kwArgs[&quot;sync&quot;] == true))
+			)
+		);
+	}
+
+	this.bind = function(kwArgs){
+		if(!this[&quot;iframe&quot;]){ this.setUpIframe(); }
+		this.requestQueue.push(kwArgs);
+		this.fireNextRequest();
+		return;
+	}
+
+	this.setUpIframe = function(){
+
+		// NOTE: IE 5.0 and earlier Mozilla's don't support an onload event for
+		//       iframes. OTOH, we don't care.
+		this.iframe = dojo.io.createIFrame(this.iframeName, &quot;dojo.io.IframeTransport.iframeOnload();&quot;);
+	}
+
+	this.iframeOnload = function(){
+		if(!_this.currentRequest){
+			_this.fireNextRequest();
+			return;
+		}
+
+		var req = _this.currentRequest;
+
+		// remove all the hidden content inputs
+		var toClean = req._contentToClean;
+		for(var i = 0; i &lt; toClean.length; i++) {
+			var key = toClean[i];
+			if(dojo.render.html.safari){
+				//In Safari (at least 2.0.3), can't use formNode[key] syntax to find the node,
+				//for nodes that were dynamically added.
+				var fNode = req.formNode;
+				for(var j = 0; j &lt; fNode.childNodes.length; j++){
+					var chNode = fNode.childNodes[j];
+					if(chNode.name == key){
+						var pNode = chNode.parentNode;
+						pNode.removeChild(chNode);
+						break;
+					}
+				}
+			}else{
+				var input = req.formNode[key];
+				req.formNode.removeChild(input);
+				req.formNode[key] = null;
+			}
+		}
+
+		// restore original action + target
+		if(req[&quot;_originalAction&quot;]){
+			req.formNode.setAttribute(&quot;action&quot;, req._originalAction);
+		}
+		req.formNode.setAttribute(&quot;target&quot;, req._originalTarget);
+		req.formNode.target = req._originalTarget;
+
+		var ifd = dojo.io.iframeContentDocument(_this.iframe);
+		// handle successful returns
+		// FIXME: how do we determine success for iframes? Is there an equiv of
+		// the &quot;status&quot; property?
+		var value;
+		var success = false;
+
+		try{
+			var cmt = req.mimetype;
+			if((cmt == &quot;text/javascript&quot;)||(cmt == &quot;text/json&quot;)){
+				// FIXME: not sure what to do here? try to pull some evalulable
+				// text from a textarea or cdata section? 
+				// how should we set up the contract for that?
+				var js = ifd.getElementsByTagName(&quot;textarea&quot;)[0].value;
+				if(cmt == &quot;text/json&quot;) { js = &quot;(&quot; + js + &quot;)&quot;; }
+				value = dj_eval(js);
+			}else if(cmt == &quot;text/html&quot;){
+				value = ifd;
+			}else{ // text/plain
+				value = ifd.getElementsByTagName(&quot;textarea&quot;)[0].value;
+			}
+			success = true;
+		}catch(e){ 
+			// looks like we didn't get what we wanted!
+			var errObj = new dojo.io.Error(&quot;IframeTransport Error&quot;);
+			if(dojo.lang.isFunction(req[&quot;error&quot;])){
+				req.error(&quot;error&quot;, errObj, req);
+			}
+		}
+
+		// don't want to mix load function errors with processing errors, thus
+		// a separate try..catch
+		try {
+			if(success &amp;&amp; dojo.lang.isFunction(req[&quot;load&quot;])){
+				req.load(&quot;load&quot;, value, req);
+			}
+		} catch(e) {
+			throw e;
+		} finally {
+			_this.currentRequest = null;
+			_this.fireNextRequest();
+		}
+	}
+
+	dojo.io.transports.addTransport(&quot;IframeTransport&quot;);
+}

Added: trunk/root/static/magic/src/io/RepubsubIO.js
===================================================================
--- trunk/root/static/magic/src/io/RepubsubIO.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/RepubsubIO.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,517 @@
+//	Copyright (c) 2004 Friendster Inc., Licensed under the Academic Free
+//	License version 2.0 or later 
+
+dojo.require(&quot;dojo.event.Event&quot;);
+dojo.require(&quot;dojo.event.BrowserEvent&quot;);
+dojo.require(&quot;dojo.io.BrowserIO&quot;);
+
+dojo.provide(&quot;dojo.io.RepubsubIO&quot;);
+dojo.provide(&quot;dojo.io.repubsub&quot;);
+dojo.provide(&quot;dojo.io.repubsubTransport&quot;);
+
+dojo.io.repubsubTranport = new function(){
+	var rps = dojo.io.repubsub;
+	this.canHandle = function(kwArgs){
+		if((kwArgs[&quot;mimetype&quot;] == &quot;text/javascript&quot;)&amp;&amp;(kwArgs[&quot;method&quot;] == &quot;repubsub&quot;)){
+			return true;
+		}
+		return false;
+	}
+
+	this.bind = function(kwArgs){
+		if(!rps.isInitialized){
+			// open up our tunnel, queue up requests anyway
+			rps.init();
+		}
+		// FIXME: we need to turn this into a topic subscription
+		// var tgtURL = kwArgs.url+&quot;?&quot;+dojo.io.argsFromMap(kwArgs.content);
+		// sampleTransport.sendRequest(tgtURL, hdlrFunc);
+
+		// a normal &quot;bind()&quot; call in a request-response transport layer is
+		// something that (usually) encodes most of it's payload with the
+		// request. Multi-event systems like repubsub are a bit more complex,
+		// and repubsub in particular distinguishes the publish and subscribe
+		// portions of thep rocess with different method calls to handle each.
+		// Therefore, a &quot;bind&quot; in the sense of repubsub must first determine if
+		// we have an open subscription to a channel provided by the server,
+		// and then &quot;publish&quot; the request payload if there is any. We therefore
+		// must take care not to incorrectly or too agressively register or
+		// file event handlers which are provided with the kwArgs method.
+
+		// NOTE: we ONLY pay attention to those event handlers that are
+		// registered with the bind request that subscribes to the channel. If
+		// event handlers are provided with subsequent requests, we might in
+		// the future support some additive or replacement syntax, but for now
+		// they get dropped on the floor.
+
+		// NOTE: in this case, url MUST be the &quot;topic&quot; to which we
+		// subscribe/publish for this channel
+		if(!rps.topics[kwArgs.url]){
+			kwArgs.rpsLoad = function(evt){
+				kwArgs.load(&quot;load&quot;, evt);
+			}
+			rps.subscribe(kwArgs.url, kwArgs, &quot;rpsLoad&quot;);
+		}
+
+		if(kwArgs[&quot;content&quot;]){
+			// what we wanted to send
+			var cEvt = dojo.io.repubsubEvent.initFromProperties(kwArgs.content);
+			rps.publish(kwArgs.url, cEvt);
+		}
+	}
+
+	dojo.io.transports.addTransport(&quot;repubsubTranport&quot;);
+}
+
+dojo.io.repubsub = new function(){
+	this.initDoc = &quot;init.html&quot;;
+	this.isInitialized = false;
+	this.subscriptionBacklog = [];
+	this.debug = true;
+	this.rcvNodeName = null;
+	this.sndNodeName = null;
+	this.rcvNode = null;
+	this.sndNode = null;
+	this.canRcv = false;
+	this.canSnd = false;
+	this.canLog = false;
+	this.sndTimer = null;
+	this.windowRef = window;
+	this.backlog = [];
+	this.tunnelInitCount = 0;
+	this.tunnelFrameKey = &quot;tunnel_frame&quot;;
+	this.serverBaseURL = location.protocol+&quot;//&quot;+location.host+location.pathname;
+	this.logBacklog = [];
+	this.getRandStr = function(){
+		return Math.random().toString().substring(2, 10);
+	}
+	this.userid = &quot;guest&quot;;
+	this.tunnelID = this.getRandStr();
+	this.attachPathList = [];
+	this.topics = []; // list of topics we have listeners to
+
+	// actually, now that I think about it a little bit more, it would sure be
+	// useful to parse out the &lt;script&gt; src attributes. We're looking for
+	// something with a &quot;do_method=lib&quot;, since that's what would have included
+	// us in the first place (in the common case).
+	this.parseGetStr = function(){
+		var baseUrl = document.location.toString();
+		var params = baseUrl.split(&quot;?&quot;, 2);
+		if(params.length &gt; 1){
+			var paramStr = params[1];
+			var pairs = paramStr.split(&quot;&amp;&quot;);
+			var opts = [];
+			for(var x in pairs){
+				var sp = pairs[x].split(&quot;=&quot;);
+				// FIXME: is this eval dangerous?
+				try{
+					opts[sp[0]]=eval(sp[1]);
+				}catch(e){
+					opts[sp[0]]=sp[1];
+				}
+			}
+			return opts;
+		}else{
+			return [];
+		}
+	}
+
+	// parse URL params and use them as default vals
+	var getOpts = this.parseGetStr();
+	for(var x in getOpts){
+		// FIXME: should I be checking for undefined here before setting? Does
+		//        that buy me anything?
+		this[x] = getOpts[x];
+	}
+
+	if(!this[&quot;tunnelURI&quot;]){
+		this.tunnelURI = [	&quot;/who/&quot;, escape(this.userid), &quot;/s/&quot;, 
+							this.getRandStr(), &quot;/kn_journal&quot;].join(&quot;&quot;);
+		// this.tunnelURI = this.absoluteTopicURI(this.tunnelURI);
+	}
+
+	/*
+	if (self.kn_tunnelID) kn.tunnelID = self.kn_tunnelID; // the server says
+	if (kn._argv.kn_tunnelID) kn.tunnelID = kn._argv.kn_tunnelID; // the url says
+	*/
+
+	// check the options object if it exists and use its properties as an
+	// over-ride
+	if(window[&quot;repubsubOpts&quot;]||window[&quot;rpsOpts&quot;]){
+		var optObj = window[&quot;repubsubOpts&quot;]||window[&quot;rpsOpts&quot;];
+		for(var x in optObj){
+			this[x] = optObj[x]; // copy the option object properties
+		}
+	}
+
+	// things that get called directly from our iframe to inform us of events
+	this.tunnelCloseCallback = function(){
+		// when we get this callback, we should immediately attempt to re-start
+		// our tunnel connection
+		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc+&quot;?callback=repubsub.rcvNodeReady&amp;domain=&quot;+document.domain);
+	}
+
+	this.receiveEventFromTunnel = function(evt, srcWindow){
+		// we should never be getting events from windows we didn't create
+		// NOTE: events sourced from the local window are also supported for
+		// 		 debugging purposes
+
+		// any event object MUST have a an &quot;elements&quot; property
+		if(!evt[&quot;elements&quot;]){
+			this.log(&quot;bailing! event received without elements!&quot;, &quot;error&quot;);
+			return;
+		}
+
+		// if the event passes some minimal sanity tests, we need to attempt to
+		// dispatch it!
+
+		// first, it seems we have to munge the event object a bit
+		var e = {};
+		for(var i=0; i&lt;evt.elements.length; i++){
+			var ee = evt.elements[i];
+			e[ee.name||ee.nameU] = (ee.value||ee.valueU);
+			// FIXME: need to enable this only in some extreme debugging mode!
+			this.log(&quot;[event]: &quot;+(ee.name||ee.nameU)+&quot;: &quot;+e[ee.name||ee.nameU]);
+		}
+
+		// NOTE: the previous version of this library put a bunch of code here
+		// to manage state that tried to make sure that we never, ever, lost
+		// any info about an event. If we unload RIGHT HERE, I don't think it's
+		// going to make a huge difference one way or another. Time will tell.
+
+		// and with THAT out of the way, dispatch it!
+		this.dispatch(e);
+
+		// TODO: remove the script block that created the event obj to save
+		// memory, etc.
+	}
+
+	this.widenDomain = function(domainStr){
+		// the purpose of this is to set the most liberal domain policy
+		// available
+		var cd = domainStr||document.domain;
+		if(cd.indexOf(&quot;.&quot;)==-1){ return; } // probably <A HREF="file:///">file:///</A> or localhost
+		var dps = cd.split(&quot;.&quot;);
+		if(dps.length&lt;=2){ return; } // probably <A HREF="file:///">file:///</A> or an RFC 1918 address
+		dps = dps.slice(dps.length-2);
+		document.domain = dps.join(&quot;.&quot;);
+	}
+
+	// FIXME: parseCookie and setCookie should be methods that are more broadly
+	// available. Perhaps in htmlUtils?
+
+	this.parseCookie = function(){
+		var cs = document.cookie;
+		var keypairs = cs.split(&quot;;&quot;);
+		for(var x=0; x&lt;keypairs.length; x++){
+			keypairs[x] = keypairs[x].split(&quot;=&quot;);
+			if(x!=keypairs.length-1){ cs+=&quot;;&quot;; }
+		}
+		return keypairs;
+	}
+
+	this.setCookie = function(keypairs, clobber){
+		// NOTE: we want to only ever set session cookies, so never provide an
+		// 		 expires date
+		if((clobber)&amp;&amp;(clobber==true)){ document.cookie = &quot;&quot;; }
+		var cs = &quot;&quot;;
+		for(var x=0; x&lt;keypairs.length; x++){
+			cs += keypairs[x][0]+&quot;=&quot;+keypairs[x][1];
+			if(x!=keypairs.length-1){ cs+=&quot;;&quot;; }
+		}
+		document.cookie = cs;
+	}
+
+	// FIXME: need to replace w/ dojo.log.*
+	this.log = function(str, lvl){
+		if(!this.debug){ return; } // we of course only care if we're in debug mode
+		while(this.logBacklog.length&gt;0){
+			if(!this.canLog){ break; }
+			var blo = this.logBacklog.shift();
+			this.writeLog(&quot;[&quot;+blo[0]+&quot;]: &quot;+blo[1], blo[2]);
+		}
+		this.writeLog(str, lvl);
+	}
+
+	this.writeLog = function(str, lvl){
+		dojo.debug(((new Date()).toLocaleTimeString())+&quot;: &quot;+str);
+	}
+
+	this.init = function(){
+		this.widenDomain();
+		// this.findPeers();
+		this.openTunnel();
+		this.isInitialized = true;
+		// FIXME: this seems like entirely the wrong place to replay the backlog
+		while(this.subscriptionBacklog.length){
+			this.subscribe.apply(this, this.subscriptionBacklog.shift());
+		}
+	}
+
+	this.clobber = function(){
+		if(this.rcvNode){
+			this.setCookie( [
+					[this.tunnelFrameKey,&quot;closed&quot;],
+					[&quot;path&quot;,&quot;/&quot;]
+				], false 
+			);
+		}
+	}
+
+	this.openTunnel = function(){
+		// We create two iframes here:
+
+		// one for getting data
+		this.rcvNodeName = &quot;rcvIFrame_&quot;+this.getRandStr();
+		// set cookie that can be used to find the receiving iframe
+		this.setCookie( [
+				[this.tunnelFrameKey,this.rcvNodeName],
+				[&quot;path&quot;,&quot;/&quot;]
+			], false
+		);
+
+		this.rcvNode = dojo.io.createIFrame(this.rcvNodeName);
+		// FIXME: set the src attribute here to the initialization URL
+		dojo.io.setIFrameSrc(this.rcvNode, this.initDoc+&quot;?callback=repubsub.rcvNodeReady&amp;domain=&quot;+document.domain);
+
+		// the other for posting data in reply
+
+		this.sndNodeName = &quot;sndIFrame_&quot;+this.getRandStr();
+		this.sndNode = dojo.io.createIFrame(this.sndNodeName);
+		// FIXME: set the src attribute here to the initialization URL
+		dojo.io.setIFrameSrc(this.sndNode, this.initDoc+&quot;?callback=repubsub.sndNodeReady&amp;domain=&quot;+document.domain);
+
+	}
+
+	this.rcvNodeReady = function(){
+		// FIXME: why is this sequence number needed? Why isn't the UID gen
+		// 		  function enough?
+        var statusURI = [this.tunnelURI, '/kn_status/', this.getRandStr(), '_', 
+						 String(this.tunnelInitCount++)].join(&quot;&quot;); 
+            // (kn._seqNum++); // FIXME: !!!!
+		// this.canRcv = true;
+		this.log(&quot;rcvNodeReady&quot;);
+		// FIXME: initialize receiver and request the base topic
+		// dojo.io.setIFrameSrc(this.rcvNode, this.serverBaseURL+&quot;/kn?do_method=blank&quot;);
+		var initURIArr = [	this.serverBaseURL, &quot;/kn?kn_from=&quot;, escape(this.tunnelURI),
+							&quot;&amp;kn_id=&quot;, escape(this.tunnelID), &quot;&amp;kn_status_from=&quot;, 
+							escape(statusURI)];
+		// FIXME: does the above really need a kn_response_flush? won't the
+		// 		  server already know? If not, what good is it anyway?
+		dojo.io.setIFrameSrc(this.rcvNode, initURIArr.join(&quot;&quot;));
+
+		// setup a status path listener, but don't tell the server about it,
+		// since it already knows we're itnerested in our own tunnel status
+		this.subscribe(statusURI, this, &quot;statusListener&quot;, true);
+
+		this.log(initURIArr.join(&quot;&quot;));
+	}
+
+	this.sndNodeReady = function(){
+		this.canSnd = true;
+		this.log(&quot;sndNodeReady&quot;);
+		this.log(this.backlog.length);
+		// FIXME: handle any pent-up send commands
+		if(this.backlog.length &gt; 0){
+			this.dequeueEvent();
+		}
+	}
+
+	this.statusListener = function(evt){
+		this.log(&quot;status listener called&quot;);
+		this.log(evt.status, &quot;info&quot;);
+	}
+
+	// this handles local event propigation
+	this.dispatch = function(evt){
+		// figure out what topic it came from
+		if(evt[&quot;to&quot;]||evt[&quot;kn_routed_from&quot;]){
+			var rf = evt[&quot;to&quot;]||evt[&quot;kn_routed_from&quot;];
+			// split off the base server URL
+			var topic = rf.split(this.serverBaseURL, 2)[1];
+			if(!topic){
+				// FIXME: how do we recover when we don't get a sane &quot;from&quot;? Do
+				// we try to route to it anyway?
+				topic = rf;
+			}
+			this.log(&quot;[topic] &quot;+topic);
+			if(topic.length&gt;3){
+				if(topic.slice(0, 3)==&quot;/kn&quot;){
+					topic = topic.slice(3);
+				}
+			}
+			if(this.attachPathList[topic]){
+				this.attachPathList[topic](evt);
+			}
+		}
+	}
+
+	this.subscribe = function(	topic /* kn_from in the old terminilogy */, 
+								toObj, toFunc, dontTellServer){
+		if(!this.isInitialized){
+			this.subscriptionBacklog.push([topic, toObj, toFunc, dontTellServer]);
+			return;
+		}
+		if(!this.attachPathList[topic]){
+			this.attachPathList[topic] = function(){ return true; }
+			this.log(&quot;subscribing to: &quot;+topic);
+			this.topics.push(topic);
+		}
+		var revt = new dojo.io.repubsubEvent(this.tunnelURI, topic, &quot;route&quot;);
+		var rstr = [this.serverBaseURL+&quot;/kn&quot;, revt.toGetString()].join(&quot;&quot;);
+		dojo.event.kwConnect({
+			once: true,
+			srcObj: this.attachPathList, 
+			srcFunc: topic, 
+			adviceObj: toObj, 
+			adviceFunc: toFunc
+		});
+		// NOTE: the above is a local mapping, if we're not the leader, we
+		// 		 should connect our mapping to the topic handler of the peer
+		// 		 leader, this ensures that not matter what happens to the
+		// 		 leader, we don't really loose our heads if/when the leader
+		// 		 goes away.
+		if(!this.rcvNode){ /* this should be an error! */ }
+		if(dontTellServer){
+			return;
+		}
+		this.log(&quot;sending subscription to: &quot;+topic);
+		// create a subscription event object and give it all the props we need
+		// to updates on the specified topic
+
+		// FIXME: we should only enqueue if this is our first subscription!
+		this.sendTopicSubToServer(topic, rstr);
+	}
+
+	this.sendTopicSubToServer = function(topic, str){
+		if(!this.attachPathList[topic][&quot;subscriptions&quot;]){
+			this.enqueueEventStr(str);
+			this.attachPathList[topic].subscriptions = 0;
+		}
+		this.attachPathList[topic].subscriptions++;
+	}
+
+	this.unSubscribe = function(topic, toObj, toFunc){
+		// first, locally disconnect
+		dojo.event.kwDisconnect({
+			srcObj: this.attachPathList, 
+			srcFunc: topic, 
+			adviceObj: toObj, 
+			adviceFunc: toFunc
+		});
+		
+		// FIXME: figure out if there are any remaining listeners to the topic,
+		// 		  and if not, inform the server of our desire not to be
+		// 		  notified of updates to the topic
+	}
+
+	// the &quot;publish&quot; method is really a misnomer, since it really means &quot;take
+	// this event and send it to the server&quot;. Note that the &quot;dispatch&quot; method
+	// handles local event promigulation, and therefore we emulate both sides
+	// of a real event router without having to swallow all of the complexity.
+	this.publish = function(topic, event){
+		var evt = dojo.io.repubsubEvent.initFromProperties(event);
+		// FIXME: need to make sure we have from and to set correctly
+		// 		  before we serialize and send off to the great blue
+		// 		  younder.
+		evt.to = topic;
+		// evt.from = this.tunnelURI;
+
+		var evtURLParts = [];
+		evtURLParts.push(this.serverBaseURL+&quot;/kn&quot;);
+
+		// serialize the event to a string and then post it to the correct
+		// topic
+		evtURLParts.push(evt.toGetString());
+		this.enqueueEventStr(evtURLParts.join(&quot;&quot;));
+	}
+
+	this.enqueueEventStr = function(evtStr){
+		this.log(&quot;enqueueEventStr&quot;);
+		this.backlog.push(evtStr);
+		this.dequeueEvent();
+	}
+
+	this.dequeueEvent = function(force){
+		this.log(&quot;dequeueEvent&quot;);
+		if(this.backlog.length &lt;= 0){ return; }
+		if((this.canSnd)||(force)){
+			dojo.io.setIFrameSrc(this.sndNode, this.backlog.shift()+&quot;&amp;callback=repubsub.sndNodeReady&quot;);
+			this.canSnd = false;
+		}else{
+			this.log(&quot;sndNode not available yet!&quot;, &quot;debug&quot;);
+		}
+	}
+}
+
+dojo.io.repubsubEvent = function(to, from, method, id, routeURI, payload, dispname, uid){
+	this.to = to;
+	this.from = from;
+	this.method = method||&quot;route&quot;;
+	this.id = id||repubsub.getRandStr();
+	this.uri = routeURI;
+	this.displayname = dispname||repubsub.displayname;
+	this.userid = uid||repubsub.userid;
+	this.payload = payload||&quot;&quot;;
+	this.flushChars = 4096;
+
+	this.initFromProperties = function(evt){
+		if(evt.constructor = dojo.io.repubsubEvent){ 
+			for(var x in evt){
+				this[x] = evt[x];
+			}
+		}else{
+			// we want to copy all the properties of the evt object, and transform
+			// those that are &quot;stock&quot; properties of dojo.io.repubsubEvent. All others should
+			// be copied as-is
+			for(var x in evt){
+				if(typeof this.forwardPropertiesMap[x] == &quot;string&quot;){
+					this[this.forwardPropertiesMap[x]] = evt[x];
+				}else{
+					this[x] = evt[x];
+				}
+			}
+		}
+	}
+
+	this.toGetString = function(noQmark){
+		var qs = [ ((noQmark) ? &quot;&quot; : &quot;?&quot;) ];
+		for(var x=0; x&lt;this.properties.length; x++){
+			var tp = this.properties[x];
+			if(this[tp[0]]){
+				qs.push(tp[1]+&quot;=&quot;+encodeURIComponent(String(this[tp[0]])));
+			}
+			// FIXME: we need to be able to serialize non-stock properties!!!
+		}
+		return qs.join(&quot;&amp;&quot;);
+	}
+
+}
+
+dojo.io.repubsubEvent.prototype.properties = [[&quot;from&quot;, &quot;kn_from&quot;], [&quot;to&quot;, &quot;kn_to&quot;], 
+									[&quot;method&quot;, &quot;do_method&quot;], [&quot;id&quot;, &quot;kn_id&quot;], 
+									[&quot;uri&quot;, &quot;kn_uri&quot;], 
+									[&quot;displayname&quot;, &quot;kn_displayname&quot;], 
+									[&quot;userid&quot;, &quot;kn_userid&quot;], 
+									[&quot;payload&quot;, &quot;kn_payload&quot;],
+									[&quot;flushChars&quot;, &quot;kn_response_flush&quot;],
+									[&quot;responseFormat&quot;, &quot;kn_response_format&quot;] ];
+
+// maps properties from their old names to their new names...
+dojo.io.repubsubEvent.prototype.forwardPropertiesMap = {};
+// ...and vice versa...
+dojo.io.repubsubEvent.prototype.reversePropertiesMap = {};
+
+// and we then populate them both from the properties list
+for(var x=0; x&lt;dojo.io.repubsubEvent.prototype.properties.length; x++){
+	var tp = dojo.io.repubsubEvent.prototype.properties[x];
+	dojo.io.repubsubEvent.prototype.reversePropertiesMap[tp[0]] = tp[1];
+	dojo.io.repubsubEvent.prototype.forwardPropertiesMap[tp[1]] = tp[0];
+}
+// static version of initFromProperties, creates new event and object and
+// returns it after init
+dojo.io.repubsubEvent.initFromProperties = function(evt){
+	var eventObj = new dojo.io.repubsubEvent();
+	eventObj.initFromProperties(evt);
+	return eventObj;
+}


Property changes on: trunk/root/static/magic/src/io/RepubsubIO.js
___________________________________________________________________
Name: svn:mime-type
   + text/cpp

Added: trunk/root/static/magic/src/io/RhinoIO.js
===================================================================
--- trunk/root/static/magic/src/io/RhinoIO.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/RhinoIO.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.RhinoIO&quot;);
+
+// TODO: this doesn't execute
+/*dojo.io.SyncHTTPRequest = function(){
+	dojo.io.SyncRequest.call(this);
+
+	this.send = function(URI){
+	}
+}
+
+dojo.inherits(dojo.io.SyncHTTPRequest, dojo.io.SyncRequest);
+*/

Added: trunk/root/static/magic/src/io/ScriptSrcIO.js
===================================================================
--- trunk/root/static/magic/src/io/ScriptSrcIO.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/ScriptSrcIO.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,452 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.ScriptSrcIO&quot;);
+dojo.require(&quot;dojo.io.BrowserIO&quot;);
+dojo.require(&quot;dojo.undo.browser&quot;);
+
+//FIXME: should constantParams be JS object?
+//FIXME: check dojo.io calls. Can we move the BrowserIO defined calls somewhere
+//       else so that we don't depend on BrowserIO at all? The dependent calls
+//       have to do with dealing with forms and making query params from JS object.
+/**
+ * See test_ScriptSrcIO.html for usage information.
+ * Notes:
+ * - The watchInFlight timer is set to 100 ms instead of 10ms (which is what BrowserIO.js uses).
+ */
+dojo.io.ScriptSrcTransport = new function(){
+	this.preventCache = false; // if this is true, we'll always force GET requests to not cache
+	this.maxUrlLength = 1000; //Used to calculate if script request should be multipart.
+	this.inFlightTimer = null;
+
+	this.DsrStatusCodes = {
+		Continue: 100,
+		Ok: 200,
+		Error: 500
+	};
+
+	this.startWatchingInFlight = function(){
+		if(!this.inFlightTimer){
+			this.inFlightTimer = setInterval(&quot;dojo.io.ScriptSrcTransport.watchInFlight();&quot;, 100);
+		}
+	}
+
+	this.watchInFlight = function(){
+		var totalCount = 0;
+		var doneCount = 0;
+		for(var param in this._state){
+			totalCount++;
+			var currentState = this._state[param];
+			if(currentState.isDone){
+				doneCount++;
+				delete this._state[param];
+			}else{
+				var listener = currentState.kwArgs;
+				try{
+					if(currentState.checkString &amp;&amp; eval(&quot;typeof(&quot; + currentState.checkString + &quot;) != 'undefined'&quot;)){
+						this._finish(currentState, &quot;load&quot;);
+						doneCount++;
+						delete this._state[param];
+					}else if(listener.timeoutSeconds &amp;&amp; listener.timeout){
+						if(currentState.startTime + (listener.timeoutSeconds * 1000) &lt; (new Date()).getTime()){
+							this._finish(currentState, &quot;timeout&quot;);
+							doneCount++;
+							delete this._state[param];
+						}
+					}else if(!listener.timeoutSeconds){
+						//Increment the done count if no timeout is specified, so
+						//that we turn off the timer if all that is left in the state
+						//list are things we can't clean up because they fail without
+						//getting a callback.
+						doneCount++;
+					}
+				}catch(e){
+					this._finish(currentState, &quot;error&quot;, {status: this.DsrStatusCodes.Error, response: e});
+				}
+			}
+		}
+	
+		if(doneCount == totalCount){
+			clearInterval(this.inFlightTimer);
+			this.inFlightTimer = null;
+		}
+	}
+
+	this.canHandle = function(kwArgs){
+		return dojo.lang.inArray((kwArgs[&quot;mimetype&quot;].toLowerCase()), [&quot;text/javascript&quot;, &quot;text/json&quot;])
+			&amp;&amp; (kwArgs[&quot;method&quot;].toLowerCase() == &quot;get&quot;)
+			&amp;&amp; !(kwArgs[&quot;formNode&quot;] &amp;&amp; dojo.io.formHasFile(kwArgs[&quot;formNode&quot;]))
+			&amp;&amp; (!kwArgs[&quot;sync&quot;] || kwArgs[&quot;sync&quot;] == false)
+			&amp;&amp; !kwArgs[&quot;file&quot;]
+			&amp;&amp; !kwArgs[&quot;multipart&quot;];
+	}
+
+	/**
+	 * Removes any script tags from the DOM that may have been added by ScriptSrcTransport.
+	 * Be careful though, by removing them from the script, you may invalidate some
+	 * script objects that were defined by the js file that was pulled in as the
+	 * src of the script tag. Test carefully if you decide to call this method.
+	 * 
+	 * In MSIE 6 (and probably 5.x), if you removed the script element while 
+	 * part of the script is still executing, the browser will crash.
+	 */
+	this.removeScripts = function(){
+		var scripts = document.getElementsByTagName(&quot;script&quot;);
+		for(var i = 0; scripts &amp;&amp; i &lt; scripts.length; i++){
+			var scriptTag = scripts[i];
+			if(scriptTag.className == &quot;ScriptSrcTransport&quot;){
+				var parent = scriptTag.parentNode;
+				parent.removeChild(scriptTag);
+				i--; //Set the index back one since we removed an item.
+			}
+		}
+	}
+
+	this.bind = function(kwArgs){
+		//START duplication from BrowserIO.js (some changes made)
+		var url = kwArgs.url;
+		var query = &quot;&quot;;
+		
+		if(kwArgs[&quot;formNode&quot;]){
+			var ta = kwArgs.formNode.getAttribute(&quot;action&quot;);
+			if((ta)&amp;&amp;(!kwArgs[&quot;url&quot;])){ url = ta; }
+			var tp = kwArgs.formNode.getAttribute(&quot;method&quot;);
+			if((tp)&amp;&amp;(!kwArgs[&quot;method&quot;])){ kwArgs.method = tp; }
+			query += dojo.io.encodeForm(kwArgs.formNode, kwArgs.encoding, kwArgs[&quot;formFilter&quot;]);
+		}
+
+		if(url.indexOf(&quot;#&quot;) &gt; -1) {
+			dojo.debug(&quot;Warning: dojo.io.bind: stripping hash values from url:&quot;, url);
+			url = url.split(&quot;#&quot;)[0];
+		}
+
+		//Break off the domain/path of the URL.
+		var urlParts = url.split(&quot;?&quot;);
+		if(urlParts &amp;&amp; urlParts.length == 2){
+			url = urlParts[0];
+			query += (query ? &quot;&amp;&quot; : &quot;&quot;) + urlParts[1];
+		}
+
+		if(kwArgs[&quot;backButton&quot;] || kwArgs[&quot;back&quot;] || kwArgs[&quot;changeUrl&quot;]){
+			dojo.undo.browser.addToHistory(kwArgs);
+		}
+
+		//Create an ID for the request.
+		var id = kwArgs[&quot;apiId&quot;] ? kwArgs[&quot;apiId&quot;] : &quot;id&quot; + this._counter++;
+
+		//Fill out any other content pieces.
+		var content = kwArgs[&quot;content&quot;];
+		var jsonpName = kwArgs.jsonParamName;
+		if(kwArgs.sendTransport || jsonpName) {
+			if (!content){
+				content = {};
+			}
+			if(kwArgs.sendTransport){
+				content[&quot;dojo.transport&quot;] = &quot;scriptsrc&quot;;
+			}
+
+			if(jsonpName){
+				content[jsonpName] = &quot;dojo.io.ScriptSrcTransport._state.&quot; + id + &quot;.jsonpCall&quot;;
+			}
+		}
+
+		if(kwArgs.postContent){
+			query = kwArgs.postContent;
+		}else if(content){
+			query += ((query) ? &quot;&amp;&quot; : &quot;&quot;) + dojo.io.argsFromMap(content, kwArgs.encoding, jsonpName);
+		}
+		//END duplication from BrowserIO.js
+
+		//START DSR
+
+		//If an apiId is specified, then we want to make sure useRequestId is true.
+		if(kwArgs[&quot;apiId&quot;]){
+			kwArgs[&quot;useRequestId&quot;] = true;
+		}
+
+		//Set up the state for this request.
+		var state = {
+			&quot;id&quot;: id,
+			&quot;idParam&quot;: &quot;_dsrid=&quot; + id,
+			&quot;url&quot;: url,
+			&quot;query&quot;: query,
+			&quot;kwArgs&quot;: kwArgs,
+			&quot;startTime&quot;: (new Date()).getTime()
+		};
+
+		if(!url){
+			//Error. An URL is needed.
+			this._finish(state, &quot;error&quot;, {status: this.DsrStatusCodes.Error, statusText: &quot;url.none&quot;});
+			return;
+		}
+
+		//If this is a jsonp request, intercept the jsonp callback
+		if(content &amp;&amp; content[jsonpName]){
+			state.jsonp = content[jsonpName];
+			state.jsonpCall = function(data){
+				if(data[&quot;Error&quot;]||data[&quot;error&quot;]){
+					dojo.debug(dojo.json.serialize(data));
+					dojo.io.ScriptSrcTransport._finish(this, &quot;error&quot;, data);
+				}else{
+					dojo.io.ScriptSrcTransport._finish(this, &quot;load&quot;, data);
+				}
+			};
+		}
+
+		//Only store the request state on the state tracking object if a callback
+		//is expected or if polling on a checkString will be done.
+		if(kwArgs[&quot;useRequestId&quot;] || kwArgs[&quot;checkString&quot;] || state[&quot;jsonp&quot;]){
+			this._state[id] = state;
+		}
+
+		//A checkstring is a string that if evaled will not be undefined once the
+		//script src loads. Used as an alternative to depending on a callback from
+		//the script file. If this is set, then multipart is not assumed to be used,
+		//since multipart requires a specific callback. With checkString we will be doing
+		//polling.
+		if(kwArgs[&quot;checkString&quot;]){
+			state.checkString = kwArgs[&quot;checkString&quot;];
+		}
+
+		//Constant params are parameters that should always be sent with each
+		//part of a multipart URL.
+		state.constantParams = (kwArgs[&quot;constantParams&quot;] == null ? &quot;&quot; : kwArgs[&quot;constantParams&quot;]);
+	
+		if(kwArgs[&quot;preventCache&quot;] ||
+			(this.preventCache == true &amp;&amp; kwArgs[&quot;preventCache&quot;] != false)){
+			state.nocacheParam = &quot;dojo.preventCache=&quot; + new Date().valueOf();
+		}else{
+			state.nocacheParam = &quot;&quot;;
+		}
+
+		//Get total length URL, if we were to do it as one URL.
+		//Add some padding, extra &amp; separators.
+		var urlLength = state.url.length + state.query.length + state.constantParams.length 
+				+ state.nocacheParam.length + this._extraPaddingLength;
+
+		if(kwArgs[&quot;useRequestId&quot;]){
+			urlLength += state.idParam.length;
+		}
+		
+		if(!kwArgs[&quot;checkString&quot;] &amp;&amp; kwArgs[&quot;useRequestId&quot;] 
+			&amp;&amp; !state[&quot;jsonp&quot;] &amp;&amp; !kwArgs[&quot;forceSingleRequest&quot;]
+			&amp;&amp; urlLength &gt; this.maxUrlLength){
+			if(url &gt; this.maxUrlLength){
+				//Error. The URL domain and path are too long. We can't
+				//segment that, so return an error.
+				this._finish(state, &quot;error&quot;, {status: this.DsrStatusCodes.Error, statusText: &quot;url.tooBig&quot;});
+				return;
+			}else{
+				//Start the multiple requests.
+				this._multiAttach(state, 1);
+			}
+		}else{
+			//Send one URL.
+			var queryParams = [state.constantParams, state.nocacheParam, state.query];
+			if(kwArgs[&quot;useRequestId&quot;] &amp;&amp; !state[&quot;jsonp&quot;]){
+				queryParams.unshift(state.idParam);
+			}
+			var finalUrl = this._buildUrl(state.url, queryParams);
+
+			//Track the final URL in case we need to use that instead of api ID when receiving
+			//the load callback.
+			state.finalUrl = finalUrl;
+			
+			this._attach(state.id, finalUrl);
+		}
+		//END DSR
+
+		this.startWatchingInFlight();
+	}
+	
+	//Private properties/methods
+	this._counter = 1;
+	this._state = {};
+	this._extraPaddingLength = 16;
+
+	//Is there a dojo function for this already?
+	this._buildUrl = function(url, nameValueArray){
+		var finalUrl = url;
+		var joiner = &quot;?&quot;;
+		for(var i = 0; i &lt; nameValueArray.length; i++){
+			if(nameValueArray[i]){
+				finalUrl += joiner + nameValueArray[i];
+				joiner = &quot;&amp;&quot;;
+			}
+		}
+
+		return finalUrl;
+	}
+
+	this._attach = function(id, url){
+		//Attach the script to the DOM.
+		var element = document.createElement(&quot;script&quot;);
+		element.type = &quot;text/javascript&quot;;
+		element.src = url;
+		element.id = id;
+		element.className = &quot;ScriptSrcTransport&quot;;
+		document.getElementsByTagName(&quot;head&quot;)[0].appendChild(element);
+	}
+
+	this._multiAttach = function(state, part){
+		//Check to make sure we still have a query to send up. This is mostly
+		//a protection from a goof on the server side when it sends a part OK
+		//response instead of a final response.
+		if(state.query == null){
+			this._finish(state, &quot;error&quot;, {status: this.DsrStatusCodes.Error, statusText: &quot;query.null&quot;});
+			return;
+		}
+
+		if(!state.constantParams){
+			state.constantParams = &quot;&quot;;
+		}
+
+		//How much of the query can we take?
+		//Add a padding constant to account for _part and a couple extra amperstands.
+		//Also add space for id since we'll need it now.
+		var queryMax = this.maxUrlLength - state.idParam.length
+					 - state.constantParams.length - state.url.length
+					 - state.nocacheParam.length - this._extraPaddingLength;
+		
+		//Figure out if this is the last part.
+		var isDone = state.query.length &lt; queryMax;
+	
+		//Break up the query string if necessary.
+		var currentQuery;
+		if(isDone){
+			currentQuery = state.query;
+			state.query = null;
+		}else{
+			//Find the &amp; or = nearest the max url length.
+			var ampEnd = state.query.lastIndexOf(&quot;&amp;&quot;, queryMax - 1);
+			var eqEnd = state.query.lastIndexOf(&quot;=&quot;, queryMax - 1);
+
+			//See if &amp; is closer, or if = is right at the edge,
+			//which means we should put it on the next URL.
+			if(ampEnd &gt; eqEnd || eqEnd == queryMax - 1){
+				//&amp; is nearer the end. So just chop off from there.
+				currentQuery = state.query.substring(0, ampEnd);
+				state.query = state.query.substring(ampEnd + 1, state.query.length) //strip off amperstand with the + 1.
+			}else{
+				//= is nearer the end. Take the max amount possible. 
+				currentQuery = state.query.substring(0, queryMax);
+			 
+				//Find the last query name in the currentQuery so we can prepend it to
+				//ampEnd. Could be -1 (not there), so account for that.
+				var queryName = currentQuery.substring((ampEnd == -1 ? 0 : ampEnd + 1), eqEnd);
+				state.query = queryName + &quot;=&quot; + state.query.substring(queryMax, state.query.length);
+			}
+		}
+		
+		//Now send a part of the script
+		var queryParams = [currentQuery, state.idParam, state.constantParams, state.nocacheParam];
+		if(!isDone){
+			queryParams.push(&quot;_part=&quot; + part);
+		}
+
+		var url = this._buildUrl(state.url, queryParams);
+
+		this._attach(state.id + &quot;_&quot; + part, url);
+	}
+
+	this._finish = function(state, callback, event){
+		if(callback != &quot;partOk&quot; &amp;&amp; !state.kwArgs[callback] &amp;&amp; !state.kwArgs[&quot;handle&quot;]){
+			//Ignore &quot;partOk&quot; because that is an internal callback.
+			if(callback == &quot;error&quot;){
+				state.isDone = true;
+				throw event;
+			}
+		}else{
+			switch(callback){
+				case &quot;load&quot;:
+					var response = event ? event.response : null;
+					if(!response){
+						response = event;
+					}
+					state.kwArgs[(typeof state.kwArgs.load == &quot;function&quot;) ? &quot;load&quot; : &quot;handle&quot;](&quot;load&quot;, response, event, state.kwArgs);
+					state.isDone = true;
+					break;
+				case &quot;partOk&quot;:
+					var part = parseInt(event.response.part, 10) + 1;
+					//Update the constant params, if any.
+					if(event.response.constantParams){
+						state.constantParams = event.response.constantParams;
+					}
+					this._multiAttach(state, part);
+					state.isDone = false;
+					break;
+				case &quot;error&quot;:
+					state.kwArgs[(typeof state.kwArgs.error == &quot;function&quot;) ? &quot;error&quot; : &quot;handle&quot;](&quot;error&quot;, event.response, event, state.kwArgs);
+					state.isDone = true;
+					break;
+				default:
+					state.kwArgs[(typeof state.kwArgs[callback] == &quot;function&quot;) ? callback : &quot;handle&quot;](callback, event, event, state.kwArgs);
+					state.isDone = true;
+			}
+		}
+	}
+
+	dojo.io.transports.addTransport(&quot;ScriptSrcTransport&quot;);
+}
+
+//Define callback handler.
+window.onscriptload = function(event){
+	var state = null;
+	var transport = dojo.io.ScriptSrcTransport;
+	
+	//Find the matching state object for event ID.
+	if(transport._state[event.id]){
+		state = transport._state[event.id];
+	}else{
+		//The ID did not match directly to an entry in the state list.
+		//Try searching the state objects for a matching original URL.
+		var tempState;
+		for(var param in transport._state){
+			tempState = transport._state[param];
+			if(tempState.finalUrl &amp;&amp; tempState.finalUrl == event.id){
+				state = tempState;
+				break;
+			}
+		}
+
+		//If no matching original URL is found, then use the URL that was actually used
+		//in the SCRIPT SRC attribute.
+		if(state == null){
+			var scripts = document.getElementsByTagName(&quot;script&quot;);
+			for(var i = 0; scripts &amp;&amp; i &lt; scripts.length; i++){
+				var scriptTag = scripts[i];
+				if(scriptTag.getAttribute(&quot;class&quot;) == &quot;ScriptSrcTransport&quot;
+					&amp;&amp; scriptTag.src == event.id){
+					state = transport._state[scriptTag.id];
+					break;
+				}
+			}
+		}
+		
+		//If state is still null, then throw an error.
+		if(state == null){
+			throw &quot;No matching state for onscriptload event.id: &quot; + event.id;
+		}
+	}
+
+	var callbackName = &quot;error&quot;;
+	switch(event.status){
+		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Continue:
+			//A part of a multipart request.
+			callbackName = &quot;partOk&quot;;
+			break;
+		case dojo.io.ScriptSrcTransport.DsrStatusCodes.Ok:
+			//Successful reponse.
+			callbackName = &quot;load&quot;;
+			break;
+	}
+
+	transport._finish(state, callbackName, event);
+};

Added: trunk/root/static/magic/src/io/ShortBusIO.js
===================================================================
--- trunk/root/static/magic/src/io/ShortBusIO.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/ShortBusIO.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,171 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.ShortBusIO&quot;);
+dojo.require(&quot;dojo.io&quot;); // io.js provides setIFrameSrc
+// FIXME: determine if we can use XMLHTTP to make x-domain posts despite not
+//        being able to hear back about the result
+dojo.require(&quot;dojo.io.IframeIO&quot;); // for posting across domains
+dojo.require(&quot;dojo.io.cookie&quot;); // for peering
+dojo.require(&quot;dojo.event.*&quot;);
+
+/*
+ * this file defines a &quot;forever-frame&quot; style Comet client. It passes opaque
+ * JSON data structures to/from the client. Both styles of request provide a
+ * topic for the event to be sent to and a payload object to be acted upon.
+ *
+ * All outbound events are sent via dojo.io.bind() and all inbound requests are
+ * processed by Dojo topic dispatch.
+ *
+ * ShortBusIO packets have the basic format:
+ *
+ *	{
+ *	 	topic: &quot;/destination/topic/name&quot;,
+ *		body: {
+ * 			// ...
+ *		}
+ * 	}
+ * 
+ * Packets bound for the event router (not one of it's clients) or generated
+ * from it are prefixed with the special &quot;/meta&quot; topic. Meta-topic events
+ * either inform the client to take an action or inform the server of a system
+ * event.
+ *
+ * Upon tunnel creation, the server might therefore send the following meta
+ * topic packet to the client to inform the client of it's assigned identity:
+ *
+ *	// client &lt;-- server
+ *	{
+ *	 	topic: &quot;/meta&quot;,
+ *		body: {
+ * 			action: &quot;setClientId&quot;,
+ *			clientId: &quot;fooBar23&quot;,
+ *			tunnelId: &quot;fooBarTunnel4&quot;,
+ *			tunnelExpiration: &quot;...&quot;, // some date in the future
+ *		}
+ * 	}
+ *
+ * The client may then respond with a confirmation:
+ * 
+ *	// client --&gt; server
+ *	{
+ *	 	topic: &quot;/meta&quot;,
+ *		body: {
+ * 			action: &quot;confirmClientId&quot;,
+ *			from: &quot;fooBar23&quot;
+ *		}
+ * 	}
+ *
+ * The client must implement a basic vocabulary of /meta topic verbs in order
+ * to participate as a ShortBus endpoint. These are TBD.
+ *
+ * NOTE: this example elides any authentication or authorization steps the
+ * client and server may have undertaken prior to tunnel setup.
+ */
+
+// TODO: unlike repubsubio we don't handle any sort of connection
+// subscription/publishing backlog. Should we?
+
+dojo.io.ShortBusTransport = new function(){
+
+	var initialized = false;
+	var connected = false;
+
+	// this class is similar to RepubsubIO save that we don't have the
+	// externalized protocol handler code. Our messages are simpler so our code
+	// can be as well.
+
+	this.rcvNode = null;
+	this.rcvNodeName = &quot;&quot;;
+	this.topicRoot = null;
+
+	this.getRandStr = function(){
+		return Math.random().toString().substring(2, 10);
+	}
+
+	this.widenDomain = function(domainStr){
+		// allow us to make reqests to the TLD
+		var cd = domainStr||document.domain;
+		if(cd.indexOf(&quot;.&quot;)==-1){ return; } // probably <A HREF="file:///">file:///</A> or localhost
+		var dps = cd.split(&quot;.&quot;);
+		if(dps.length&lt;=2){ return; } // probably <A HREF="file:///">file:///</A> or an RFC 1918 address
+		dps = dps.slice(dps.length-2);
+		document.domain = dps.join(&quot;.&quot;);
+	}
+
+	this.canHandle = function(kwArgs){
+		return (
+			(connected)			&amp;&amp;
+			(kwArgs[&quot;topic&quot;])	&amp;&amp;
+			(! // async only!
+				((kwArgs[&quot;sync&quot;])&amp;&amp;(kwArgs[&quot;sync&quot;] == true))
+			)
+		);
+	}
+
+	this.buildConnection = function(){
+		// NOTE: we require the server to cooperate by hosting
+		// ShortBusInit.html at the designated endpoint
+		this.rcvNodeName = &quot;ShortBusRcv_&quot;+this.getRandStr();
+		// the &quot;forever frame&quot; approach
+		if(dojo.render.html.ie){
+			// use the &quot;htmlfile hack&quot; to prevent the background click junk
+			this.rcvNode = new ActiveXObject(&quot;htmlfile&quot;);
+			this.rcvNode.open();
+			this.rcvNode.write(&quot;&lt;html&gt;&quot;);
+			this.rcvNode.write(&quot;&lt;script&gt;document.domain = '&quot;+document.domain+&quot;'&quot;);
+			this.rcvNode.write(&quot;&lt;/html&gt;&quot;);
+			this.rcvNode.close();
+
+			var ifrDiv = this.rcvNode.createElement(&quot;div&quot;);
+			this.rcvNode.appendChild(ifrDiv);
+			this.rcvNode.parentWindow.dojo = dojo;
+			ifrDiv.innerHTML = &quot;&lt;iframe src='&quot;+this.topicRoot+&quot;/?tunntelType=htmlfile'&gt;&lt;/iframe&gt;&quot;
+			// and we're ready to go!
+			connected = true;
+		}else{
+			this.rcvNode = dojo.io.createIFrame(this.rcvNodeName);
+			dojo.io.setIFrameSrc(this.rcvNode, this.topicRoot+&quot;/?tunnelType=iframe&quot;);
+			// we're still waiting on this one to call back up and advertise
+			// that it's been initialized
+		}
+	}
+
+	this.iframeConnectionInit = function(){
+		connected = true;
+	}
+
+	this.dispatchServerEvent = function(eObj){
+		// FIXME: implement basic /meta topic semantics here!
+	}
+
+	this.init = function(){
+		if(initialized){
+			return;
+		}
+		initialized = true;
+
+		this.widenDomain();
+
+		// we want to set up a connection to the designated server. Grab the
+		// server location out of djConfig.
+		this.topicRoot = djConfig[&quot;ShortBusRoot&quot;];
+		if(!this.topicRoot){
+			dojo.debug(&quot;no topic root specified in djConfig.ShortBusRoot&quot;);
+			return;
+		}
+	}
+
+	this.dispatch = function(evt){
+		// dipatch events along the specified path
+	}
+
+    dojo.io.transports.addTransport(&quot;ShortBusTransport&quot;);
+}

Added: trunk/root/static/magic/src/io/ShortBusInit.html
===================================================================
--- trunk/root/static/magic/src/io/ShortBusInit.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/ShortBusInit.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,75 @@
+&lt;html&gt;
+&lt;!--
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+	<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+--&gt;
+&lt;script type=&quot;text/javascript&quot;&gt;
+	if(window!=window.parent){
+		function callByDeRef(fname){
+			if(!fname){ return null; }
+			// if someone inadvertently passed in &quot;foo(...)&quot;, we make it &quot;foo&quot;
+			fname = String(fname).split(&quot;(&quot;)[0];
+			// get a real array of arguments
+			var aa = [];
+			for(var x=1; x&lt;arguments.length; x++){
+				aa.push(arguments[x]);
+			}
+
+			var parts = String(fname).split(&quot;.&quot;);
+			var obj = window;
+			for(var x=0; x&lt;parts.length-1; x++){
+				obj = obj[parts[x]];
+			}
+			var fn = parts.pop(); // the last element is the function name
+			// exec the function in the specified namespace
+			return obj[fn].apply(obj, aa);
+		}
+
+		function widenDomain(domainStr){
+			// the purpose of this is to set the most liberal domain policy
+			var cd = domainStr||document.domain;
+			if(cd.indexOf(&quot;.&quot;)==-1){ 
+				document.domain = cd;
+				return;
+			}
+			var dps = cd.split(&quot;.&quot;);
+			if(dps.length&gt;2){ 
+				dps = dps.slice(dps.length-2);
+			}
+			document.domain = dps.join(&quot;.&quot;);
+		}
+
+		function doInit(){
+
+			widenDomain();
+
+			var baseUrl = document.location.toString();
+			var params = baseUrl.split(&quot;?&quot;, 2);
+			if(params.length &gt; 1){
+				var paramStr = params[1];
+				var pairs = paramStr.split(&quot;&amp;&quot;);
+				var opts = [];
+				for(var x in pairs){
+					// alert(pairs[x]);
+					var sp = pairs[x].split(&quot;=&quot;);
+					opts[sp[0]]=sp[1];
+					if(sp[0]==&quot;true&quot;){
+						sp[0] = true;
+					}else if(sp[0]==&quot;false&quot;){
+						sp[0] = false;
+					}
+				}
+				if(opts[&quot;callback&quot;]){
+					callByDeRef(&quot;parent.&quot;+opts[&quot;callback&quot;]);
+				}
+			}
+		}
+		doInit();
+	}
+&lt;/script&gt;
+&lt;/html&gt;


Property changes on: trunk/root/static/magic/src/io/ShortBusInit.html
___________________________________________________________________
Name: svn:mime-type
   + text/html

Added: trunk/root/static/magic/src/io/__package__.js
===================================================================
--- trunk/root/static/magic/src/io/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,17 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.io&quot;],
+	rhino: [&quot;dojo.io.RhinoIO&quot;],
+	browser: [&quot;dojo.io.BrowserIO&quot;, &quot;dojo.io.cookie&quot;],
+	dashboard: [&quot;dojo.io.BrowserIO&quot;, &quot;dojo.io.cookie&quot;]
+});
+dojo.provide(&quot;dojo.io.*&quot;);

Added: trunk/root/static/magic/src/io/cookie.js
===================================================================
--- trunk/root/static/magic/src/io/cookie.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/cookie.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,108 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.cookie&quot;);
+
+dojo.io.cookie.setCookie = function(name, value, days, path, domain, secure) {
+	var expires = -1;
+	if(typeof days == &quot;number&quot; &amp;&amp; days &gt;= 0) {
+		var d = new Date();
+		d.setTime(d.getTime()+(days*24*60*60*1000));
+		expires = d.toGMTString();
+	}
+	value = escape(value);
+	document.cookie = name + &quot;=&quot; + value + &quot;;&quot;
+		+ (expires != -1 ? &quot; expires=&quot; + expires + &quot;;&quot; : &quot;&quot;)
+		+ (path ? &quot;path=&quot; + path : &quot;&quot;)
+		+ (domain ? &quot;; domain=&quot; + domain : &quot;&quot;)
+		+ (secure ? &quot;; secure&quot; : &quot;&quot;);
+}
+
+dojo.io.cookie.set = dojo.io.cookie.setCookie;
+
+dojo.io.cookie.getCookie = function(name) {
+	// FIXME: Which cookie should we return?
+	//        If there are cookies set for different sub domains in the current
+	//        scope there could be more than one cookie with the same name.
+	//        I think taking the last one in the list takes the one from the
+	//        deepest subdomain, which is what we're doing here.
+	var idx = document.cookie.lastIndexOf(name+'=');
+	if(idx == -1) { return null; }
+	var value = document.cookie.substring(idx+name.length+1);
+	var end = value.indexOf(';');
+	if(end == -1) { end = value.length; }
+	value = value.substring(0, end);
+	value = unescape(value);
+	return value;
+}
+
+dojo.io.cookie.get = dojo.io.cookie.getCookie;
+
+dojo.io.cookie.deleteCookie = function(name) {
+	dojo.io.cookie.setCookie(name, &quot;-&quot;, 0);
+}
+
+dojo.io.cookie.setObjectCookie = function(name, obj, days, path, domain, secure, clearCurrent) {
+	if(arguments.length == 5) { // for backwards compat
+		clearCurrent = domain;
+		domain = null;
+		secure = null;
+	}
+	var pairs = [], cookie, value = &quot;&quot;;
+	if(!clearCurrent) { cookie = dojo.io.cookie.getObjectCookie(name); }
+	if(days &gt;= 0) {
+		if(!cookie) { cookie = {}; }
+		for(var prop in obj) {
+			if(prop == null) {
+				delete cookie[prop];
+			} else if(typeof obj[prop] == &quot;string&quot; || typeof obj[prop] == &quot;number&quot;) {
+				cookie[prop] = obj[prop];
+			}
+		}
+		prop = null;
+		for(var prop in cookie) {
+			pairs.push(escape(prop) + &quot;=&quot; + escape(cookie[prop]));
+		}
+		value = pairs.join(&quot;&amp;&quot;);
+	}
+	dojo.io.cookie.setCookie(name, value, days, path, domain, secure);
+}
+
+dojo.io.cookie.getObjectCookie = function(name) {
+	var values = null, cookie = dojo.io.cookie.getCookie(name);
+	if(cookie) {
+		values = {};
+		var pairs = cookie.split(&quot;&amp;&quot;);
+		for(var i = 0; i &lt; pairs.length; i++) {
+			var pair = pairs[i].split(&quot;=&quot;);
+			var value = pair[1];
+			if( isNaN(value) ) { value = unescape(pair[1]); }
+			values[ unescape(pair[0]) ] = value;
+		}
+	}
+	return values;
+}
+
+dojo.io.cookie.isSupported = function() {
+	if(typeof navigator.cookieEnabled != &quot;boolean&quot;) {
+		dojo.io.cookie.setCookie(&quot;__TestingYourBrowserForCookieSupport__&quot;,
+			&quot;CookiesAllowed&quot;, 90, null);
+		var cookieVal = dojo.io.cookie.getCookie(&quot;__TestingYourBrowserForCookieSupport__&quot;);
+		navigator.cookieEnabled = (cookieVal == &quot;CookiesAllowed&quot;);
+		if(navigator.cookieEnabled) {
+			// FIXME: should we leave this around?
+			this.deleteCookie(&quot;__TestingYourBrowserForCookieSupport__&quot;);
+		}
+	}
+	return navigator.cookieEnabled;
+}
+
+// need to leave this in for backwards-compat from 0.1 for when it gets pulled in by dojo.io.*
+if(!dojo.io.cookies) { dojo.io.cookies = dojo.io.cookie; }

Added: trunk/root/static/magic/src/io/cookies.js
===================================================================
--- trunk/root/static/magic/src/io/cookies.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io/cookies.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.deprecated(&quot;dojo.io.cookies&quot;, &quot;replaced by dojo.io.cookie&quot;, &quot;0.4&quot;);
+dojo.require(&quot;dojo.io.cookie&quot;);
+if(!dojo.io.cookies) { dojo.io.cookies = dojo.io.cookie; }
+dojo.provide(&quot;dojo.io.cookies&quot;);

Added: trunk/root/static/magic/src/io.js
===================================================================
--- trunk/root/static/magic/src/io.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/io.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,376 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.io.IO&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+
+/******************************************************************************
+ *	Notes about dojo.io design:
+ *	
+ *	The dojo.io.* package has the unenviable task of making a lot of different
+ *	types of I/O feel natural, despite a universal lack of good (or even
+ *	reasonable!) I/O capability in the host environment. So lets pin this down
+ *	a little bit further.
+ *
+ *	Rhino:
+ *		perhaps the best situation anywhere. Access to Java classes allows you
+ *		to do anything one might want in terms of I/O, both synchronously and
+ *		async. Can open TCP sockets and perform low-latency client/server
+ *		interactions. HTTP transport is available through Java HTTP client and
+ *		server classes. Wish it were always this easy.
+ *
+ *	xpcshell:
+ *		XPCOM for I/O. A cluster-fuck to be sure.
+ *
+ *	spidermonkey:
+ *		S.O.L.
+ *
+ *	Browsers:
+ *		Browsers generally do not provide any useable filesystem access. We are
+ *		therefore limited to HTTP for moving information to and from Dojo
+ *		instances living in a browser.
+ *
+ *		XMLHTTP:
+ *			Sync or async, allows reading of arbitrary text files (including
+ *			JS, which can then be eval()'d), writing requires server
+ *			cooperation and is limited to HTTP mechanisms (POST and GET).
+ *
+ *		&lt;iframe&gt; hacks:
+ *			iframe document hacks allow browsers to communicate asynchronously
+ *			with a server via HTTP POST and GET operations. With significant
+ *			effort and server cooperation, low-latency data transit between
+ *			client and server can be acheived via iframe mechanisms (repubsub).
+ *
+ *		SVG:
+ *			Adobe's SVG viewer implements helpful primitives for XML-based
+ *			requests, but receipt of arbitrary text data seems unlikely w/o
+ *			&lt;![CDATA[]]&gt; sections.
+ *
+ *
+ *	A discussion between Dylan, Mark, Tom, and Alex helped to lay down a lot
+ *	the IO API interface. A transcript of it can be found at:
+ *		<A HREF="http://dojotoolkit.org/viewcvs/viewcvs.py/documents/irc/irc_io_api_log.txt?rev=307&amp;view=auto">http://dojotoolkit.org/viewcvs/viewcvs.py/documents/irc/irc_io_api_log.txt?rev=307&amp;view=auto</A>
+ *	
+ *	Also referenced in the design of the API was the DOM 3 L&amp;S spec:
+ *		<A HREF="http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html">http://www.w3.org/TR/2004/REC-DOM-Level-3-LS-20040407/load-save.html</A>
+ ******************************************************************************/
+
+// a map of the available transport options. Transports should add themselves
+// by calling add(name)
+dojo.io.transports = [];
+dojo.io.hdlrFuncNames = [ &quot;load&quot;, &quot;error&quot;, &quot;timeout&quot; ]; // we're omitting a progress() event for now
+
+dojo.io.Request = function(url, mimetype, transport, changeUrl){
+	if((arguments.length == 1)&amp;&amp;(arguments[0].constructor == Object)){
+		this.fromKwArgs(arguments[0]);
+	}else{
+		this.url = url;
+		if(mimetype){ this.mimetype = mimetype; }
+		if(transport){ this.transport = transport; }
+		if(arguments.length &gt;= 4){ this.changeUrl = changeUrl; }
+	}
+}
+
+dojo.lang.extend(dojo.io.Request, {
+
+	/** The URL to hit */
+	url: &quot;&quot;,
+	
+	/** The mime type used to interrpret the response body */
+	mimetype: &quot;text/plain&quot;,
+	
+	/** The HTTP method to use */
+	method: &quot;GET&quot;,
+	
+	/** An Object containing key-value pairs to be included with the request */
+	content: undefined, // Object
+	
+	/** The transport medium to use */
+	transport: undefined, // String
+	
+	/** If defined the URL of the page is physically changed */
+	changeUrl: undefined, // String
+	
+	/** A form node to use in the request */
+	formNode: undefined, // HTMLFormElement
+	
+	/** Whether the request should be made synchronously */
+	sync: false,
+	
+	bindSuccess: false,
+
+	/** Cache/look for the request in the cache before attempting to request?
+	 *  NOTE: this isn't a browser cache, this is internal and would only cache in-page
+	 */
+	useCache: false,
+
+	/** Prevent the browser from caching this by adding a query string argument to the URL */
+	preventCache: false,
+	
+	// events stuff
+	load: function(type, data, evt){ },
+	error: function(type, error){ },
+	timeout: function(type){ },
+	handle: function(){ },
+
+	//FIXME: change BrowserIO.js to use timeouts? IframeIO?
+	// The number of seconds to wait until firing a timeout callback.
+	// If it is zero, that means, don't do a timeout check.
+	timeoutSeconds: 0,
+	
+	// the abort method needs to be filled in by the transport that accepts the
+	// bind() request
+	abort: function(){ },
+	
+	// backButton: function(){ },
+	// forwardButton: function(){ },
+
+	fromKwArgs: function(kwArgs){
+		// normalize args
+		if(kwArgs[&quot;url&quot;]){ kwArgs.url = kwArgs.url.toString(); }
+		if(kwArgs[&quot;formNode&quot;]) { kwArgs.formNode = dojo.byId(kwArgs.formNode); }
+		if(!kwArgs[&quot;method&quot;] &amp;&amp; kwArgs[&quot;formNode&quot;] &amp;&amp; kwArgs[&quot;formNode&quot;].method) {
+			kwArgs.method = kwArgs[&quot;formNode&quot;].method;
+		}
+		
+		// backwards compatibility
+		if(!kwArgs[&quot;handle&quot;] &amp;&amp; kwArgs[&quot;handler&quot;]){ kwArgs.handle = kwArgs.handler; }
+		if(!kwArgs[&quot;load&quot;] &amp;&amp; kwArgs[&quot;loaded&quot;]){ kwArgs.load = kwArgs.loaded; }
+		if(!kwArgs[&quot;changeUrl&quot;] &amp;&amp; kwArgs[&quot;changeURL&quot;]) { kwArgs.changeUrl = kwArgs.changeURL; }
+
+		// encoding fun!
+		kwArgs.encoding = dojo.lang.firstValued(kwArgs[&quot;encoding&quot;], djConfig[&quot;bindEncoding&quot;], &quot;&quot;);
+
+		kwArgs.sendTransport = dojo.lang.firstValued(kwArgs[&quot;sendTransport&quot;], djConfig[&quot;ioSendTransport&quot;], false);
+
+		var isFunction = dojo.lang.isFunction;
+		for(var x=0; x&lt;dojo.io.hdlrFuncNames.length; x++){
+			var fn = dojo.io.hdlrFuncNames[x];
+			if(isFunction(kwArgs[fn])){ continue; }
+			if(isFunction(kwArgs[&quot;handle&quot;])){
+				kwArgs[fn] = kwArgs.handle;
+			}
+			// handler is aliased above, shouldn't need this check
+			/* else if(dojo.lang.isObject(kwArgs.handler)){
+				if(isFunction(kwArgs.handler[fn])){
+					kwArgs[fn] = kwArgs.handler[fn]||kwArgs.handler[&quot;handle&quot;]||function(){};
+				}
+			}*/
+		}
+		dojo.lang.mixin(this, kwArgs);
+	}
+
+});
+
+dojo.io.Error = function(msg, type, num){
+	this.message = msg;
+	this.type =  type || &quot;unknown&quot;; // must be one of &quot;io&quot;, &quot;parse&quot;, &quot;unknown&quot;
+	this.number = num || 0; // per-substrate error number, not normalized
+}
+
+dojo.io.transports.addTransport = function(name){
+	this.push(name);
+	// FIXME: do we need to handle things that aren't direct children of the
+	// dojo.io namespace? (say, dojo.io.foo.fooTransport?)
+	this[name] = dojo.io[name];
+}
+
+// binding interface, the various implementations register their capabilities
+// and the bind() method dispatches
+dojo.io.bind = function(request){
+	// if the request asks for a particular implementation, use it
+	if(!(request instanceof dojo.io.Request)){
+		try{
+			request = new dojo.io.Request(request);
+		}catch(e){ dojo.debug(e); }
+	}
+	var tsName = &quot;&quot;;
+	if(request[&quot;transport&quot;]){
+		tsName = request[&quot;transport&quot;];
+		// FIXME: it would be good to call the error handler, although we'd
+		// need to use setTimeout or similar to accomplish this and we can't
+		// garuntee that this facility is available.
+		if(!this[tsName]){ return request; }
+	}else{
+		// otherwise we do our best to auto-detect what available transports
+		// will handle 
+		for(var x=0; x&lt;dojo.io.transports.length; x++){
+			var tmp = dojo.io.transports[x];
+			if((this[tmp])&amp;&amp;(this[tmp].canHandle(request))){
+				tsName = tmp;
+			}
+		}
+		if(tsName == &quot;&quot;){ return request; }
+	}
+	this[tsName].bind(request);
+	request.bindSuccess = true;
+	return request;
+}
+
+dojo.io.queueBind = function(request){
+	if(!(request instanceof dojo.io.Request)){
+		try{
+			request = new dojo.io.Request(request);
+		}catch(e){ dojo.debug(e); }
+	}
+
+	// make sure we get called if/when we get a response
+	var oldLoad = request.load;
+	request.load = function(){
+		dojo.io._queueBindInFlight = false;
+		var ret = oldLoad.apply(this, arguments);
+		dojo.io._dispatchNextQueueBind();
+		return ret;
+	}
+
+	var oldErr = request.error;
+	request.error = function(){
+		dojo.io._queueBindInFlight = false;
+		var ret = oldErr.apply(this, arguments);
+		dojo.io._dispatchNextQueueBind();
+		return ret;
+	}
+
+	dojo.io._bindQueue.push(request);
+	dojo.io._dispatchNextQueueBind();
+	return request;
+}
+
+dojo.io._dispatchNextQueueBind = function(){
+	if(!dojo.io._queueBindInFlight){
+		dojo.io._queueBindInFlight = true;
+		if(dojo.io._bindQueue.length &gt; 0){
+			dojo.io.bind(dojo.io._bindQueue.shift());
+		}else{
+			dojo.io._queueBindInFlight = false;
+		}
+	}
+}
+dojo.io._bindQueue = [];
+dojo.io._queueBindInFlight = false;
+
+dojo.io.argsFromMap = function(map, encoding, last){
+	var enc = /utf/i.test(encoding||&quot;&quot;) ? encodeURIComponent : dojo.string.encodeAscii;
+	var mapped = [];
+	var control = new Object();
+	for(var name in map){
+		var domap = function(elt){
+			var val = enc(name)+&quot;=&quot;+enc(elt);
+			mapped[(last == name) ? &quot;push&quot; : &quot;unshift&quot;](val);
+		}
+		if(!control[name]){
+			var value = map[name];
+			// FIXME: should be isArrayLike?
+			if (dojo.lang.isArray(value)){
+				dojo.lang.forEach(value, domap);
+			}else{
+				domap(value);
+			}
+		}
+	}
+	return mapped.join(&quot;&amp;&quot;);
+}
+
+dojo.io.setIFrameSrc = function(iframe, src, replace){
+	try{
+		var r = dojo.render.html;
+		// dojo.debug(iframe);
+		if(!replace){
+			if(r.safari){
+				iframe.location = src;
+			}else{
+				frames[iframe.name].location = src;
+			}
+		}else{
+			// Fun with DOM 0 incompatibilities!
+			var idoc;
+			if(r.ie){
+				idoc = iframe.contentWindow.document;
+			}else if(r.safari){
+				idoc = iframe.document;
+			}else{ //  if(r.moz){
+				idoc = iframe.contentWindow;
+			}
+
+			//For Safari (at least 2.0.3) and Opera, if the iframe
+			//has just been created but it doesn't have content
+			//yet, then iframe.document may be null. In that case,
+			//use iframe.location and return.
+			if(!idoc){
+				iframe.location = src;
+				return;
+			}else{
+				idoc.location.replace(src);
+			}
+		}
+	}catch(e){ 
+		dojo.debug(e); 
+		dojo.debug(&quot;setIFrameSrc: &quot;+e); 
+	}
+}
+
+/*
+dojo.io.sampleTranport = new function(){
+	this.canHandle = function(kwArgs){
+		// canHandle just tells dojo.io.bind() if this is a good transport to
+		// use for the particular type of request.
+		if(	
+			(
+				(kwArgs[&quot;mimetype&quot;] == &quot;text/plain&quot;) ||
+				(kwArgs[&quot;mimetype&quot;] == &quot;text/html&quot;) ||
+				(kwArgs[&quot;mimetype&quot;] == &quot;text/javascript&quot;)
+			)&amp;&amp;(
+				(kwArgs[&quot;method&quot;] == &quot;get&quot;) ||
+				( (kwArgs[&quot;method&quot;] == &quot;post&quot;) &amp;&amp; (!kwArgs[&quot;formNode&quot;]) )
+			)
+		){
+			return true;
+		}
+
+		return false;
+	}
+
+	this.bind = function(kwArgs){
+		var hdlrObj = {};
+
+		// set up a handler object
+		for(var x=0; x&lt;dojo.io.hdlrFuncNames.length; x++){
+			var fn = dojo.io.hdlrFuncNames[x];
+			if(typeof kwArgs.handler == &quot;object&quot;){
+				if(typeof kwArgs.handler[fn] == &quot;function&quot;){
+					hdlrObj[fn] = kwArgs.handler[fn]||kwArgs.handler[&quot;handle&quot;];
+				}
+			}else if(typeof kwArgs[fn] == &quot;function&quot;){
+				hdlrObj[fn] = kwArgs[fn];
+			}else{
+				hdlrObj[fn] = kwArgs[&quot;handle&quot;]||function(){};
+			}
+		}
+
+		// build a handler function that calls back to the handler obj
+		var hdlrFunc = function(evt){
+			if(evt.type == &quot;onload&quot;){
+				hdlrObj.load(&quot;load&quot;, evt.data, evt);
+			}else if(evt.type == &quot;onerr&quot;){
+				var errObj = new dojo.io.Error(&quot;sampleTransport Error: &quot;+evt.msg);
+				hdlrObj.error(&quot;error&quot;, errObj);
+			}
+		}
+
+		// the sample transport would attach the hdlrFunc() when sending the
+		// request down the pipe at this point
+		var tgtURL = kwArgs.url+&quot;?&quot;+dojo.io.argsFromMap(kwArgs.content);
+		// sampleTransport.sendRequest(tgtURL, hdlrFunc);
+	}
+
+	dojo.io.transports.addTransport(&quot;sampleTranport&quot;);
+}
+*/

Added: trunk/root/static/magic/src/json.js
===================================================================
--- trunk/root/static/magic/src/json.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/json.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,135 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.json&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.string.extras&quot;);
+dojo.require(&quot;dojo.AdapterRegistry&quot;);
+
+dojo.json = {
+	jsonRegistry: new dojo.AdapterRegistry(),
+
+	register: function(name, check, wrap, /*optional*/ override){
+		/***
+
+			Register a JSON serialization function.	 JSON serialization 
+			functions should take one argument and return an object
+			suitable for JSON serialization:
+
+			- string
+			- number
+			- boolean
+			- undefined
+			- object
+				- null
+				- Array-like (length property that is a number)
+				- Objects with a &quot;json&quot; method will have this method called
+				- Any other object will be used as {key:value, ...} pairs
+			
+			If override is given, it is used as the highest priority
+			JSON serialization, otherwise it will be used as the lowest.
+		***/
+
+		dojo.json.jsonRegistry.register(name, check, wrap, override);
+	},
+
+	evalJson: function(/* jsonString */ json){
+		// FIXME: should this accept mozilla's optional second arg?
+		try {
+			return eval(&quot;(&quot; + json + &quot;)&quot;);
+		}catch(e){
+			dojo.debug(e);
+			return json;
+		}
+	},
+
+	evalJSON: function (json) {
+		dojo.deprecated(&quot;dojo.json.evalJSON&quot;, &quot;use dojo.json.evalJson&quot;, &quot;0.4&quot;);
+		return this.evalJson(json);
+	},
+
+	serialize: function(o){
+		/***
+			Create a JSON serialization of an object, note that this doesn't
+			check for infinite recursion, so don't do that!
+		***/
+
+		var objtype = typeof(o);
+		if(objtype == &quot;undefined&quot;){
+			return &quot;undefined&quot;;
+		}else if((objtype == &quot;number&quot;)||(objtype == &quot;boolean&quot;)){
+			return o + &quot;&quot;;
+		}else if(o === null){
+			return &quot;null&quot;;
+		}
+		if (objtype == &quot;string&quot;) { return dojo.string.escapeString(o); }
+		// recurse
+		var me = arguments.callee;
+		// short-circuit for objects that support &quot;json&quot; serialization
+		// if they return &quot;self&quot; then just pass-through...
+		var newObj;
+		if(typeof(o.__json__) == &quot;function&quot;){
+			newObj = o.__json__();
+			if(o !== newObj){
+				return me(newObj);
+			}
+		}
+		if(typeof(o.json) == &quot;function&quot;){
+			newObj = o.json();
+			if (o !== newObj) {
+				return me(newObj);
+			}
+		}
+		// array
+		if(objtype != &quot;function&quot; &amp;&amp; typeof(o.length) == &quot;number&quot;){
+			var res = [];
+			for(var i = 0; i &lt; o.length; i++){
+				var val = me(o[i]);
+				if(typeof(val) != &quot;string&quot;){
+					val = &quot;undefined&quot;;
+				}
+				res.push(val);
+			}
+			return &quot;[&quot; + res.join(&quot;,&quot;) + &quot;]&quot;;
+		}
+		// look in the registry
+		try {
+			window.o = o;
+			newObj = dojo.json.jsonRegistry.match(o);
+			return me(newObj);
+		}catch(e){
+			// dojo.debug(e);
+		}
+		// it's a function with no adapter, bad
+		if(objtype == &quot;function&quot;){
+			return null;
+		}
+		// generic object code path
+		res = [];
+		for (var k in o){
+			var useKey;
+			if (typeof(k) == &quot;number&quot;){
+				useKey = '&quot;' + k + '&quot;';
+			}else if (typeof(k) == &quot;string&quot;){
+				useKey = dojo.string.escapeString(k);
+			}else{
+				// skip non-string or number keys
+				continue;
+			}
+			val = me(o[k]);
+			if(typeof(val) != &quot;string&quot;){
+				// skip non-serializable values
+				continue;
+			}
+			res.push(useKey + &quot;:&quot; + val);
+		}
+		return &quot;{&quot; + res.join(&quot;,&quot;) + &quot;}&quot;;
+	}
+};

Added: trunk/root/static/magic/src/lang/Lang.js
===================================================================
--- trunk/root/static/magic/src/lang/Lang.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/Lang.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.lang&quot;);
+dojo.deprecated(&quot;dojo.lang.Lang&quot;, &quot;use dojo.lang instead&quot;, &quot;0.4&quot;);

Added: trunk/root/static/magic/src/lang/__package__.js
===================================================================
--- trunk/root/static/magic/src/lang/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,24 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.lang&quot;,
+		&quot;dojo.lang.common&quot;,
+		&quot;dojo.lang.assert&quot;,
+		&quot;dojo.lang.array&quot;,
+		&quot;dojo.lang.type&quot;,
+		&quot;dojo.lang.func&quot;,
+		&quot;dojo.lang.extras&quot;,
+		&quot;dojo.lang.repr&quot;,
+		&quot;dojo.lang.declare&quot;
+	]
+});
+dojo.provide(&quot;dojo.lang.*&quot;);

Added: trunk/root/static/magic/src/lang/array.js
===================================================================
--- trunk/root/static/magic/src/lang/array.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/array.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,172 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.array&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+
+// FIXME: Is this worthless since you can do: if(name in obj)
+// is this the right place for this?
+dojo.lang.has = function(obj, name){
+	try{
+		return (typeof obj[name] != &quot;undefined&quot;);
+	}catch(e){ return false; }
+}
+
+dojo.lang.isEmpty = function(obj) {
+	if(dojo.lang.isObject(obj)) {
+		var tmp = {};
+		var count = 0;
+		for(var x in obj){
+			if(obj[x] &amp;&amp; (!tmp[x])){
+				count++;
+				break;
+			} 
+		}
+		return (count == 0);
+	} else if(dojo.lang.isArrayLike(obj) || dojo.lang.isString(obj)) {
+		return obj.length == 0;
+	}
+}
+
+dojo.lang.map = function(arr, obj, unary_func){
+	var isString = dojo.lang.isString(arr);
+	if(isString){
+		arr = arr.split(&quot;&quot;);
+	}
+	if(dojo.lang.isFunction(obj)&amp;&amp;(!unary_func)){
+		unary_func = obj;
+		obj = dj_global;
+	}else if(dojo.lang.isFunction(obj) &amp;&amp; unary_func){
+		// ff 1.5 compat
+		var tmpObj = obj;
+		obj = unary_func;
+		unary_func = tmpObj;
+	}
+	if(Array.map){
+	 	var outArr = Array.map(arr, unary_func, obj);
+	}else{
+		var outArr = [];
+		for(var i=0;i&lt;arr.length;++i){
+			outArr.push(unary_func.call(obj, arr[i]));
+		}
+	}
+	if(isString) {
+		return outArr.join(&quot;&quot;);
+	} else {
+		return outArr;
+	}
+}
+
+// <A HREF="http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach">http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:forEach</A>
+dojo.lang.forEach = function(anArray /* Array */, callback /* Function */, thisObject /* Object */){
+	if(dojo.lang.isString(anArray)){ 
+		anArray = anArray.split(&quot;&quot;); 
+	}
+	if(Array.forEach){
+		Array.forEach(anArray, callback, thisObject);
+	}else{
+		// FIXME: there are several ways of handilng thisObject. Is dj_global always the default context?
+		if(!thisObject){
+			thisObject=dj_global;
+		}
+		for(var i=0,l=anArray.length; i&lt;l; i++){ 
+			callback.call(thisObject, anArray[i], i, anArray);
+		}
+	}
+}
+
+dojo.lang._everyOrSome = function(every, arr, callback, thisObject){
+	if(dojo.lang.isString(arr)){ 
+		arr = arr.split(&quot;&quot;); 
+	}
+	if(Array.every){
+		return Array[ (every) ? &quot;every&quot; : &quot;some&quot; ](arr, callback, thisObject);
+	}else{
+		if(!thisObject){
+			thisObject = dj_global;
+		}
+		for(var i=0,l=arr.length; i&lt;l; i++){
+			var result = callback.call(thisObject, arr[i], i, arr);
+			if((every)&amp;&amp;(!result)){
+				return false;
+			}else if((!every)&amp;&amp;(result)){
+				return true;
+			}
+		}
+		return (every) ? true : false;
+	}
+}
+
+dojo.lang.every = function(arr, callback, thisObject){
+	return this._everyOrSome(true, arr, callback, thisObject);
+}
+
+dojo.lang.some = function(arr, callback, thisObject){
+	return this._everyOrSome(false, arr, callback, thisObject);
+}
+
+dojo.lang.filter = function(arr, callback, thisObject) {
+	var isString = dojo.lang.isString(arr);
+	if(isString) { arr = arr.split(&quot;&quot;); }
+	if(Array.filter) {
+		var outArr = Array.filter(arr, callback, thisObject);
+	} else {
+		if(!thisObject) {
+			if(arguments.length &gt;= 3) { dojo.raise(&quot;thisObject doesn't exist!&quot;); }
+			thisObject = dj_global;
+		}
+
+		var outArr = [];
+		for(var i = 0; i &lt; arr.length; i++) {
+			if(callback.call(thisObject, arr[i], i, arr)) {
+				outArr.push(arr[i]);
+			}
+		}
+	}
+	if(isString) {
+		return outArr.join(&quot;&quot;);
+	} else {
+		return outArr;
+	}
+}
+
+/**
+ * Creates a 1-D array out of all the arguments passed,
+ * unravelling any array-like objects in the process
+ *
+ * Ex:
+ * unnest(1, 2, 3) ==&gt; [1, 2, 3]
+ * unnest(1, [2, [3], [[[4]]]]) ==&gt; [1, 2, 3, 4]
+ */
+dojo.lang.unnest = function(/* ... */) {
+	var out = [];
+	for(var i = 0; i &lt; arguments.length; i++) {
+		if(dojo.lang.isArrayLike(arguments[i])) {
+			var add = dojo.lang.unnest.apply(this, arguments[i]);
+			out = out.concat(add);
+		} else {
+			out.push(arguments[i]);
+		}
+	}
+	return out;
+}
+
+/**
+ * Converts an array-like object (i.e. arguments, DOMCollection)
+ * to an array
+**/
+dojo.lang.toArray = function(arrayLike, startOffset) {
+	var array = [];
+	for(var i = startOffset||0; i &lt; arrayLike.length; i++) {
+		array.push(arrayLike[i]);
+	}
+	return array;
+}

Added: trunk/root/static/magic/src/lang/assert.js
===================================================================
--- trunk/root/static/magic/src/lang/assert.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/assert.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,121 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.assert&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.type&quot;);
+
+// -------------------------------------------------------------------
+// Assertion methods
+// -------------------------------------------------------------------
+
+/**
+ * Throws an exception if the assertion fails.
+ *
+ * If the asserted condition is true, this method does nothing. If the
+ * condition is false, we throw an error with a error message.  
+ *
+ * @param	booleanValue	A boolean value, which needs to be true for the assertion to succeed.
+ * @param	message	Optional. A string describing the assertion.
+ * @throws	Throws an Error if 'booleanValue' is false.
+ */
+dojo.lang.assert = function(booleanValue, message){
+	if(!booleanValue){
+		var errorMessage = &quot;An assert statement failed.\n&quot; +
+			&quot;The method dojo.lang.assert() was called with a 'false' value.\n&quot;;
+		if(message){
+			errorMessage += &quot;Here's the assert message:\n&quot; + message + &quot;\n&quot;;
+		}
+		// Use throw instead of dojo.raise, until bug #264 is fixed:
+		// dojo.raise(errorMessage);
+		throw new Error(errorMessage);
+	}
+}
+
+/**
+ * Given a value and a data type, this method checks the type of the value
+ * to make sure it matches the data type, and throws an exception if there
+ * is a mismatch.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   dojo.lang.assertType(&quot;foo&quot;, String);
+ *   dojo.lang.assertType(12345, Number);
+ *   dojo.lang.assertType(false, Boolean);
+ *   dojo.lang.assertType([6, 8], Array);
+ *   dojo.lang.assertType(dojo.lang.assertType, Function);
+ *   dojo.lang.assertType({foo: &quot;bar&quot;}, Object);
+ *   dojo.lang.assertType(new Date(), Date);
+ * &lt;/pre&gt;
+ *
+ * @scope	public function
+ * @param	value	Any literal value or object instance.
+ * @param	type	A class of object, or a literal type, or the string name of a type, or an array with a list of types.
+ * @param	message	Optional. A string describing the assertion.
+ * @throws	Throws an Error if 'value' is not of type 'type'.
+ */
+dojo.lang.assertType = function(value, type, message){
+	if(!dojo.lang.isOfType(value, type)){
+		if(!message){
+			if(!dojo.lang.assertType._errorMessage){
+				dojo.lang.assertType._errorMessage = &quot;Type mismatch: dojo.lang.assertType() failed.&quot;;
+			}
+			message = dojo.lang.assertType._errorMessage;
+		}
+		dojo.lang.assert(false, message);
+	}
+}
+
+/**
+ * Given an anonymous object and a list of expected property names, this
+ * method check to make sure the object does not have any properties
+ * that aren't on the list of expected properties, and throws an Error
+ * if there are unexpected properties. This is useful for doing error
+ * checking on keyword arguments, to make sure there aren't typos.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   dojo.lang.assertValidKeywords({a: 1, b: 2}, [&quot;a&quot;, &quot;b&quot;]);
+ *   dojo.lang.assertValidKeywords({a: 1, b: 2}, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]);
+ *   dojo.lang.assertValidKeywords({foo: &quot;iggy&quot;}, [&quot;foo&quot;]);
+ *   dojo.lang.assertValidKeywords({foo: &quot;iggy&quot;}, [&quot;foo&quot;, &quot;bar&quot;]);
+ *   dojo.lang.assertValidKeywords({foo: &quot;iggy&quot;}, {foo: null, bar: null});
+ * &lt;/pre&gt;
+ *
+ * @scope	public function
+ * @param	object	An anonymous object.
+ * @param	expectedProperties	An array of strings (or an object with all the expected properties).
+ * @param	message	Optional. A string describing the assertion.
+ * @throws	Throws an Error if 'value' is not of type 'type'.
+ */
+dojo.lang.assertValidKeywords = function(object, expectedProperties, message){
+	var key;
+	if(!message){
+		if(!dojo.lang.assertValidKeywords._errorMessage){
+			dojo.lang.assertValidKeywords._errorMessage = &quot;In dojo.lang.assertValidKeywords(), found invalid keyword:&quot;;
+		}
+		message = dojo.lang.assertValidKeywords._errorMessage;
+	}
+	if(dojo.lang.isArray(expectedProperties)){
+		for(key in object){
+			if(!dojo.lang.inArray(expectedProperties, key)){
+				dojo.lang.assert(false, message + &quot; &quot; + key);
+			}
+		}
+	}else{
+		for(key in object){
+			if(!(key in expectedProperties)){
+				dojo.lang.assert(false, message + &quot; &quot; + key);
+			}
+		}
+	}
+}

Added: trunk/root/static/magic/src/lang/common.js
===================================================================
--- trunk/root/static/magic/src/lang/common.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/common.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,190 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+/*
+ * Adds the given properties/methods to the specified object
+ */
+dojo.lang._mixin = function(obj, props){
+	var tobj = {};
+	for(var x in props){
+		// the &quot;tobj&quot; condition avoid copying properties in &quot;props&quot;
+		// inherited from Object.prototype.  For example, if obj has a custom
+		// toString() method, don't overwrite it with the toString() method
+		// that props inherited from Object.protoype
+		if(typeof tobj[x] == &quot;undefined&quot; || tobj[x] != props[x]) {
+			obj[x] = props[x];
+		}
+	}
+	// IE doesn't recognize custom toStrings in for..in
+	if(dojo.render.html.ie &amp;&amp; dojo.lang.isFunction(props[&quot;toString&quot;]) &amp;&amp; props[&quot;toString&quot;] != obj[&quot;toString&quot;]) {
+		obj.toString = props.toString;
+	}
+	return obj;
+}
+
+/*
+ * Adds the properties/methods of argument Objects to obj
+ */
+dojo.lang.mixin = function(obj, props /*, props, ..., props */){
+	for(var i=1, l=arguments.length; i&lt;l; i++){
+		dojo.lang._mixin(obj, arguments[i]);
+	}
+	return obj;
+}
+
+/*
+ * Adds the properties/methods of argument Objects to ctor's prototype
+ */
+dojo.lang.extend = function(ctor /*function*/, props /*, props, ..., props */){
+	for(var i=1, l=arguments.length; i&lt;l; i++){
+		dojo.lang._mixin(ctor.prototype, arguments[i]);
+	}
+	return ctor;
+}
+
+/**
+ * See if val is in arr. Call signatures:
+ *  find(array, value, identity) // recommended
+ *  find(value, array, identity)
+**/
+dojo.lang.find = function(	/*Array*/	arr, 
+							/*Object*/	val,
+							/*boolean*/	identity,
+							/*boolean*/	findLast){
+	// support both (arr, val) and (val, arr)
+	if(!dojo.lang.isArrayLike(arr) &amp;&amp; dojo.lang.isArrayLike(val)) {
+		var a = arr;
+		arr = val;
+		val = a;
+	}
+	var isString = dojo.lang.isString(arr);
+	if(isString) { arr = arr.split(&quot;&quot;); }
+
+	if(findLast) {
+		var step = -1;
+		var i = arr.length - 1;
+		var end = -1;
+	} else {
+		var step = 1;
+		var i = 0;
+		var end = arr.length;
+	}
+	if(identity){
+		while(i != end) {
+			if(arr[i] === val){ return i; }
+			i += step;
+		}
+	}else{
+		while(i != end) {
+			if(arr[i] == val){ return i; }
+			i += step;
+		}
+	}
+	return -1;
+}
+
+dojo.lang.indexOf = dojo.lang.find;
+
+dojo.lang.findLast = function(/*Array*/ arr, /*Object*/ val, /*boolean*/ identity){
+	return dojo.lang.find(arr, val, identity, true);
+}
+
+dojo.lang.lastIndexOf = dojo.lang.findLast;
+
+dojo.lang.inArray = function(arr /*Array*/, val /*Object*/){
+	return dojo.lang.find(arr, val) &gt; -1; // return: boolean
+}
+
+/**
+ * Partial implmentation of is* functions from
+ * <A HREF="http://www.crockford.com/javascript/recommend.html">http://www.crockford.com/javascript/recommend.html</A>
+ * NOTE: some of these may not be the best thing to use in all situations
+ * as they aren't part of core JS and therefore can't work in every case.
+ * See WARNING messages inline for tips.
+ *
+ * The following is* functions are fairly &quot;safe&quot;
+ */
+
+dojo.lang.isObject = function(wh){
+	if(typeof wh == &quot;undefined&quot;){ return false; }
+	return (typeof wh == &quot;object&quot; || wh === null || dojo.lang.isArray(wh) || dojo.lang.isFunction(wh));
+}
+
+dojo.lang.isArray = function(wh){
+	return (wh instanceof Array || typeof wh == &quot;array&quot;);
+}
+
+dojo.lang.isArrayLike = function(wh){
+	if(dojo.lang.isString(wh)){ return false; }
+	if(dojo.lang.isFunction(wh)){ return false; } // keeps out built-in ctors (Number, String, ...) which have length properties
+	if(dojo.lang.isArray(wh)){ return true; }
+	if(typeof wh != &quot;undefined&quot; &amp;&amp; wh
+		&amp;&amp; dojo.lang.isNumber(wh.length) &amp;&amp; isFinite(wh.length)){ return true; }
+	return false;
+}
+
+dojo.lang.isFunction = function(wh){
+	if(!wh){ return false; }
+	return (wh instanceof Function || typeof wh == &quot;function&quot;);
+}
+
+dojo.lang.isString = function(wh){
+	return (wh instanceof String || typeof wh == &quot;string&quot;);
+}
+
+dojo.lang.isAlien = function(wh){
+	if(!wh){ return false; }
+	return !dojo.lang.isFunction() &amp;&amp; /\{\s*\[native code\]\s*\}/.test(String(wh));
+}
+
+dojo.lang.isBoolean = function(wh){
+	return (wh instanceof Boolean || typeof wh == &quot;boolean&quot;);
+}
+
+/**
+ * The following is***() functions are somewhat &quot;unsafe&quot;. Fortunately,
+ * there are workarounds the the language provides and are mentioned
+ * in the WARNING messages.
+ *
+ * WARNING: In most cases, isNaN(wh) is sufficient to determine whether or not
+ * something is a number or can be used as such. For example, a number or string
+ * can be used interchangably when accessing array items (arr[&quot;1&quot;] is the same as
+ * arr[1]) and isNaN will return false for both values (&quot;1&quot; and 1). Should you
+ * use isNumber(&quot;1&quot;), that will return false, which is generally not too useful.
+ * Also, isNumber(NaN) returns true, again, this isn't generally useful, but there
+ * are corner cases (like when you want to make sure that two things are really
+ * the same type of thing). That is really where isNumber &quot;shines&quot;.
+ *
+ * RECOMMENDATION: Use isNaN(wh) when possible
+ */
+dojo.lang.isNumber = function(wh){
+	return (wh instanceof Number || typeof wh == &quot;number&quot;);
+}
+
+/**
+ * WARNING: In some cases, isUndefined will not behave as you
+ * might expect. If you do isUndefined(foo) and there is no earlier
+ * reference to foo, an error will be thrown before isUndefined is
+ * called. It behaves correctly if you scope yor object first, i.e.
+ * isUndefined(foo.bar) where foo is an object and bar isn't a
+ * property of the object.
+ *
+ * RECOMMENDATION: Use `typeof foo == &quot;undefined&quot;` when possible
+ *
+ * FIXME: Should isUndefined go away since it is error prone?
+ */
+dojo.lang.isUndefined = function(wh){
+	return ((wh == undefined)&amp;&amp;(typeof wh == &quot;undefined&quot;));
+}
+
+// end Crockford functions

Added: trunk/root/static/magic/src/lang/declare.js
===================================================================
--- trunk/root/static/magic/src/lang/declare.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/declare.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,156 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.declare&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+
+/*
+ * Creates a constructor: inherit and extend
+ *
+ * - inherits from &quot;superclass(es)&quot; 
+ *
+ *   &quot;superclass&quot; argument may be a Function, or an array of 
+ *   Functions. 
+ *
+ *   If &quot;superclass&quot; is an array, the first element is used 
+ *   as the prototypical ancestor and any following Functions 
+ *   become mixin ancestors. 
+ * 
+ *   All &quot;superclass(es)&quot; must be Functions (not mere Objects).
+ *
+ *   Using mixin ancestors provides a type of multiple
+ *   inheritance. Mixin ancestors prototypical 
+ *   properties are copied to the subclass, and any 
+ *   inializater/constructor is invoked. 
+ *
+ * - &quot;props&quot; are copied to the constructor prototype
+ *
+ * - name of the class (&quot;className&quot; argument) is stored in 
+ *   &quot;declaredClass&quot; property
+ * 
+ * - An initializer function can be specified in the &quot;init&quot; 
+ *   argument, or by including a function called &quot;initializer&quot; 
+ *   in &quot;props&quot;.
+ * 
+ * - Superclass methods (inherited methods) can be invoked using &quot;inherited&quot; method:
+ *
+ * this.inherited(&lt;method name&gt;[, &lt;argument array&gt;]);
+ * 
+ * - inherited will continue up the prototype chain until it finds an implementation of method
+ * - nested calls to inherited are supported (i.e. inherited method &quot;A&quot; can succesfully call inherited(&quot;A&quot;), and so on)
+ *
+ * Aliased as &quot;dojo.declare&quot;
+ *
+ * Usage:
+ *
+ * dojo.declare(&quot;my.classes.bar&quot;, my.classes.foo, {
+ *	initializer: function() {
+ *		this.myComplicatedObject = new ReallyComplicatedObject(); 
+ *	},
+ *	someValue: 2,
+ *	aMethod: function() { doStuff(); }
+ * });
+ *
+ */
+dojo.lang.declare = function(className /*string*/, superclass /*function || array*/, init /*function*/, props /*object*/){
+	// FIXME: parameter juggling for backward compat ... deprecate and remove after 0.3.*
+	// new sig: (className (string)[, superclass (function || array)[, init (function)][, props (object)]])
+	// old sig: (className (string)[, superclass (function || array), props (object), init (function)])
+	if ((dojo.lang.isFunction(props))||((!props)&amp;&amp;(!dojo.lang.isFunction(init)))){ 
+		var temp = props;
+		props = init;
+		init = temp;
+	}	
+	var mixins = [ ];
+	if (dojo.lang.isArray(superclass)) {
+		mixins = superclass;
+		superclass = mixins.shift();
+	}
+	if(!init){
+		init = dojo.evalObjPath(className, false);
+		if ((init)&amp;&amp;(!dojo.lang.isFunction(init))){ init = null };
+	}
+	var ctor = dojo.lang.declare._makeConstructor();
+	var scp = (superclass ? superclass.prototype : null);
+	if(scp){
+		scp.prototyping = true;
+		ctor.prototype = new superclass();
+		scp.prototyping = false; 
+	}
+	ctor.superclass = scp;
+	ctor.mixins = mixins;
+	for(var i=0,l=mixins.length; i&lt;l; i++){
+		dojo.lang.extend(ctor, mixins[i].prototype);
+	}
+	ctor.prototype.initializer = null;
+	ctor.prototype.declaredClass = className;
+	if(dojo.lang.isArray(props)){
+		dojo.lang.extend.apply(dojo.lang, [ctor].concat(props));
+	}else{
+		dojo.lang.extend(ctor, (props)||{});
+	}
+	dojo.lang.extend(ctor, dojo.lang.declare.base);
+	ctor.prototype.constructor = ctor;
+	ctor.prototype.initializer=(ctor.prototype.initializer)||(init)||(function(){});
+	dojo.lang.setObjPathValue(className, ctor, null, true);
+}
+
+dojo.lang.declare._makeConstructor = function() {
+	return function(){ 
+		// get the generational context (which object [or prototype] should be constructed)
+		var self = this._getPropContext();
+		var s = self.constructor.superclass;
+		if((s)&amp;&amp;(s.constructor)){
+			if(s.constructor==arguments.callee){
+				// if this constructor is invoked directly (my.ancestor.call(this))
+				this.inherited(&quot;constructor&quot;, arguments);
+			}else{
+				this._inherited(s, &quot;constructor&quot;, arguments);
+			}
+		}
+		var m = (self.constructor.mixins)||([]);
+		for(var i=0,l=m.length; i&lt;l; i++) {
+			(((m[i].prototype)&amp;&amp;(m[i].prototype.initializer))||(m[i])).apply(this, arguments);
+		}
+		if((!this.prototyping)&amp;&amp;(self.initializer)){
+			self.initializer.apply(this, arguments);
+		}
+	}
+}
+
+dojo.lang.declare.base = {
+	_getPropContext: function() { return (this.___proto||this); },
+	// caches ptype context and calls method on it
+	_inherited: function(ptype, method, args){
+		var stack = this.___proto;
+		this.___proto = ptype;
+		var result = ptype[method].apply(this,(args||[]));
+		this.___proto = stack;
+		return result;
+	},
+	// invokes ctor.prototype.method, with args, in our context 
+	inheritedFrom: function(ctor, prop, args){
+		var p = ((ctor)&amp;&amp;(ctor.prototype)&amp;&amp;(ctor.prototype[prop]));
+		return (dojo.lang.isFunction(p) ? p.apply(this, (args||[])) : p);
+	},
+	// searches backward thru prototype chain to find nearest ancestral instance of prop
+	inherited: function(prop, args){
+		var p = this._getPropContext();
+		do{
+			if((!p.constructor)||(!p.constructor.superclass)){return;}
+			p = p.constructor.superclass;
+		}while(!(prop in p));
+		return (dojo.lang.isFunction(p[prop]) ? this._inherited(p, prop, args) : p[prop]);
+	}
+}
+
+dojo.declare = dojo.lang.declare;
\ No newline at end of file

Added: trunk/root/static/magic/src/lang/extras.js
===================================================================
--- trunk/root/static/magic/src/lang/extras.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/extras.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,108 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.extras&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+
+/**
+ * Sets a timeout in milliseconds to execute a function in a given context
+ * with optional arguments.
+ *
+ * setTimeout (Object context, function func, number delay[, arg1[, ...]]);
+ * setTimeout (function func, number delay[, arg1[, ...]]);
+ */
+dojo.lang.setTimeout = function(func, delay){
+	var context = window, argsStart = 2;
+	if(!dojo.lang.isFunction(func)){
+		context = func;
+		func = delay;
+		delay = arguments[2];
+		argsStart++;
+	}
+
+	if(dojo.lang.isString(func)){
+		func = context[func];
+	}
+	
+	var args = [];
+	for (var i = argsStart; i &lt; arguments.length; i++) {
+		args.push(arguments[i]);
+	}
+	return setTimeout(function () { func.apply(context, args); }, delay);
+}
+
+dojo.lang.getNameInObj = function(ns, item){
+	if(!ns){ ns = dj_global; }
+
+	for(var x in ns){
+		if(ns[x] === item){
+			return new String(x);
+		}
+	}
+	return null;
+}
+
+dojo.lang.shallowCopy = function(obj) {
+	var ret = {}, key;
+	for(key in obj) {
+		if(dojo.lang.isUndefined(ret[key])) {
+			ret[key] = obj[key];
+		}
+	}
+	return ret;
+}
+
+/**
+ * Return the first argument that isn't undefined
+ */
+dojo.lang.firstValued = function(/* ... */) {
+	for(var i = 0; i &lt; arguments.length; i++) {
+		if(typeof arguments[i] != &quot;undefined&quot;) {
+			return arguments[i];
+		}
+	}
+	return undefined;
+}
+
+/**
+ * Get a value from a reference specified as a string descriptor,
+ * (e.g. &quot;A.B&quot;) in the given context.
+ * 
+ * getObjPathValue(String objpath [, Object context, Boolean create])
+ *
+ * If context is not specified, dj_global is used
+ * If create is true, undefined objects in the path are created.
+ */
+dojo.lang.getObjPathValue = function(objpath, context, create){
+	with(dojo.parseObjPath(objpath, context, create)){
+		return dojo.evalProp(prop, obj, create);
+	}
+}
+
+/**
+ * Set a value on a reference specified as a string descriptor. 
+ * (e.g. &quot;A.B&quot;) in the given context.
+ * 
+ * setObjPathValue(String objpath, value [, Object context, Boolean create])
+ *
+ * If context is not specified, dj_global is used
+ * If create is true, undefined objects in the path are created.
+ */
+dojo.lang.setObjPathValue = function(objpath, value, context, create){
+	if(arguments.length &lt; 4){
+		create = true;
+	}
+	with(dojo.parseObjPath(objpath, context, create)){
+		if(obj &amp;&amp; (create || (prop in obj))){
+			obj[prop] = value;
+		}
+	}
+}

Added: trunk/root/static/magic/src/lang/func.js
===================================================================
--- trunk/root/static/magic/src/lang/func.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/func.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,150 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.func&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+
+/**
+ * Runs a function in a given scope (thisObject), can
+ * also be used to preserve scope.
+ *
+ * hitch(foo, &quot;bar&quot;); // runs foo.bar() in the scope of foo
+ * hitch(foo, myFunction); // runs myFunction in the scope of foo
+ */
+dojo.lang.hitch = function(thisObject, method) {
+	if(dojo.lang.isString(method)) {
+		var fcn = thisObject[method];
+	} else {
+		var fcn = method;
+	}
+
+	return function() {
+		return fcn.apply(thisObject, arguments);
+	}
+}
+
+dojo.lang.anonCtr = 0;
+dojo.lang.anon = {};
+dojo.lang.nameAnonFunc = function(anonFuncPtr, namespaceObj, searchForNames){
+	var nso = (namespaceObj || dojo.lang.anon);
+	if( (searchForNames) ||
+		((dj_global[&quot;djConfig&quot;])&amp;&amp;(djConfig[&quot;slowAnonFuncLookups&quot;] == true)) ){
+		for(var x in nso){
+			if(nso[x] === anonFuncPtr){
+				return x;
+			}
+		}
+	}
+	var ret = &quot;__&quot;+dojo.lang.anonCtr++;
+	while(typeof nso[ret] != &quot;undefined&quot;){
+		ret = &quot;__&quot;+dojo.lang.anonCtr++;
+	}
+	nso[ret] = anonFuncPtr;
+	return ret;
+}
+
+dojo.lang.forward = function(funcName){
+	// Returns a function that forwards a method call to this.func(...)
+	return function(){
+		return this[funcName].apply(this, arguments);
+	};
+}
+
+dojo.lang.curry = function(ns, func /* args ... */){
+	var outerArgs = [];
+	ns = ns||dj_global;
+	if(dojo.lang.isString(func)){
+		func = ns[func];
+	}
+	for(var x=2; x&lt;arguments.length; x++){
+		outerArgs.push(arguments[x]);
+	}
+	// since the event system replaces the original function with a new
+	// join-point runner with an arity of 0, we check to see if it's left us
+	// any clues about the original arity in lieu of the function's actual
+	// length property
+	var ecount = (func[&quot;__preJoinArity&quot;]||func.length) - outerArgs.length;
+	// borrowed from svend tofte
+	function gather(nextArgs, innerArgs, expected){
+		var texpected = expected;
+		var totalArgs = innerArgs.slice(0); // copy
+		for(var x=0; x&lt;nextArgs.length; x++){
+			totalArgs.push(nextArgs[x]);
+		}
+		// check the list of provided nextArgs to see if it, plus the
+		// number of innerArgs already supplied, meets the total
+		// expected.
+		expected = expected-nextArgs.length;
+		if(expected&lt;=0){
+			var res = func.apply(ns, totalArgs);
+			expected = texpected;
+			return res;
+		}else{
+			return function(){
+				return gather(arguments,// check to see if we've been run
+										// with enough args
+							totalArgs,	// a copy
+							expected);	// how many more do we need to run?;
+			}
+		}
+	}
+	return gather([], outerArgs, ecount);
+}
+
+dojo.lang.curryArguments = function(ns, func, args, offset){
+	var targs = [];
+	var x = offset||0;
+	for(x=offset; x&lt;args.length; x++){
+		targs.push(args[x]); // ensure that it's an arr
+	}
+	return dojo.lang.curry.apply(dojo.lang, [ns, func].concat(targs));
+}
+
+dojo.lang.tryThese = function(){
+	for(var x=0; x&lt;arguments.length; x++){
+		try{
+			if(typeof arguments[x] == &quot;function&quot;){
+				var ret = (arguments[x]());
+				if(ret){
+					return ret;
+				}
+			}
+		}catch(e){
+			dojo.debug(e);
+		}
+	}
+}
+
+dojo.lang.delayThese = function(farr, cb, delay, onend){
+	/**
+	 * alternate: (array funcArray, function callback, function onend)
+	 * alternate: (array funcArray, function callback)
+	 * alternate: (array funcArray)
+	 */
+	if(!farr.length){ 
+		if(typeof onend == &quot;function&quot;){
+			onend();
+		}
+		return;
+	}
+	if((typeof delay == &quot;undefined&quot;)&amp;&amp;(typeof cb == &quot;number&quot;)){
+		delay = cb;
+		cb = function(){};
+	}else if(!cb){
+		cb = function(){};
+		if(!delay){ delay = 0; }
+	}
+	setTimeout(function(){
+		(farr.shift())();
+		cb();
+		dojo.lang.delayThese(farr, cb, delay, onend);
+	}, delay);
+}

Added: trunk/root/static/magic/src/lang/repr.js
===================================================================
--- trunk/root/static/magic/src/lang/repr.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/repr.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,90 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.repr&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.AdapterRegistry&quot;);
+dojo.require(&quot;dojo.string.extras&quot;);
+
+dojo.lang.reprRegistry = new dojo.AdapterRegistry();
+dojo.lang.registerRepr = function(name, check, wrap, /*optional*/ override){
+        /***
+			Register a repr function.  repr functions should take
+			one argument and return a string representation of it
+			suitable for developers, primarily used when debugging.
+
+			If override is given, it is used as the highest priority
+			repr, otherwise it will be used as the lowest.
+        ***/
+        dojo.lang.reprRegistry.register(name, check, wrap, override);
+    };
+
+dojo.lang.repr = function(obj){
+	/***
+		Return a &quot;programmer representation&quot; for an object
+	***/
+	if(typeof(obj) == &quot;undefined&quot;){
+		return &quot;undefined&quot;;
+	}else if(obj === null){
+		return &quot;null&quot;;
+	}
+
+	try{
+		if(typeof(obj[&quot;__repr__&quot;]) == 'function'){
+			return obj[&quot;__repr__&quot;]();
+		}else if((typeof(obj[&quot;repr&quot;]) == 'function')&amp;&amp;(obj.repr != arguments.callee)){
+			return obj[&quot;repr&quot;]();
+		}
+		return dojo.lang.reprRegistry.match(obj);
+	}catch(e){
+		if(typeof(obj.NAME) == 'string' &amp;&amp; (
+				obj.toString == Function.prototype.toString ||
+				obj.toString == Object.prototype.toString
+			)){
+			return o.NAME;
+		}
+	}
+
+	if(typeof(obj) == &quot;function&quot;){
+		obj = (obj + &quot;&quot;).replace(/^\s+/, &quot;&quot;);
+		var idx = obj.indexOf(&quot;{&quot;);
+		if(idx != -1){
+			obj = obj.substr(0, idx) + &quot;{...}&quot;;
+		}
+	}
+	return obj + &quot;&quot;;
+}
+
+dojo.lang.reprArrayLike = function(arr){
+	try{
+		var na = dojo.lang.map(arr, dojo.lang.repr);
+		return &quot;[&quot; + na.join(&quot;, &quot;) + &quot;]&quot;;
+	}catch(e){ }
+};
+
+dojo.lang.reprString = function(str){ 
+	dojo.deprecated(&quot;dojo.lang.reprNumber&quot;, &quot;use `String(num)` instead&quot;, &quot;0.4&quot;);
+	return dojo.string.escapeString(str);
+};
+
+dojo.lang.reprNumber = function(num){
+	dojo.deprecated(&quot;dojo.lang.reprNumber&quot;, &quot;use `String(num)` instead&quot;, &quot;0.4&quot;);
+	return num + &quot;&quot;;
+};
+
+(function(){
+	var m = dojo.lang;
+	m.registerRepr(&quot;arrayLike&quot;, m.isArrayLike, m.reprArrayLike);
+	m.registerRepr(&quot;string&quot;, m.isString, m.reprString);
+	m.registerRepr(&quot;numbers&quot;, m.isNumber, m.reprNumber);
+	m.registerRepr(&quot;boolean&quot;, m.isBoolean, m.reprNumber);
+	// m.registerRepr(&quot;numbers&quot;, m.typeMatcher(&quot;number&quot;, &quot;boolean&quot;), m.reprNumber);
+})();

Added: trunk/root/static/magic/src/lang/type.js
===================================================================
--- trunk/root/static/magic/src/lang/type.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang/type.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,226 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang.type&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);
+
+dojo.lang.whatAmI = function(wh) {
+	try {
+		if(dojo.lang.isArray(wh)) { return &quot;array&quot;; }
+		if(dojo.lang.isFunction(wh)) { return &quot;function&quot;; }
+		if(dojo.lang.isString(wh)) { return &quot;string&quot;; }
+		if(dojo.lang.isNumber(wh)) { return &quot;number&quot;; }
+		if(dojo.lang.isBoolean(wh)) { return &quot;boolean&quot;; }
+		if(dojo.lang.isAlien(wh)) { return &quot;alien&quot;; }
+		if(dojo.lang.isUndefined(wh)) { return &quot;undefined&quot;; }
+		// FIXME: should this go first?
+		for(var name in dojo.lang.whatAmI.custom) {
+			if(dojo.lang.whatAmI.custom[name](wh)) {
+				return name;
+			}
+		}
+		if(dojo.lang.isObject(wh)) { return &quot;object&quot;; }
+	} catch(E) {}
+	return &quot;unknown&quot;;
+}
+/*
+ * dojo.lang.whatAmI.custom[typeName] = someFunction
+ * will return typeName is someFunction(wh) returns true
+ */
+dojo.lang.whatAmI.custom = {};
+
+/**
+ * Returns true for values that commonly represent numbers.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   dojo.lang.isNumeric(3);                 // returns true
+ *   dojo.lang.isNumeric(&quot;3&quot;);               // returns true
+ *   dojo.lang.isNumeric(new Number(3));     // returns true
+ *   dojo.lang.isNumeric(new String(&quot;3&quot;));   // returns true
+ *
+ *   dojo.lang.isNumeric(3/0);               // returns false
+ *   dojo.lang.isNumeric(&quot;foo&quot;);             // returns false
+ *   dojo.lang.isNumeric(new Number(&quot;foo&quot;)); // returns false
+ *   dojo.lang.isNumeric(false);             // returns false
+ *   dojo.lang.isNumeric(true);              // returns false
+ * &lt;/pre&gt;
+ */
+dojo.lang.isNumeric = function(wh){
+	return (!isNaN(wh) &amp;&amp; isFinite(wh) &amp;&amp; (wh != null) &amp;&amp;
+			!dojo.lang.isBoolean(wh) &amp;&amp; !dojo.lang.isArray(wh));
+}
+
+/**
+ * Returns true for any literal, and for any object that is an 
+ * instance of a built-in type like String, Number, Boolean, 
+ * Array, Function, or Error.
+ */
+dojo.lang.isBuiltIn = function(wh){
+	return (dojo.lang.isArray(wh)		|| 
+			dojo.lang.isFunction(wh)	|| 
+			dojo.lang.isString(wh)		|| 
+			dojo.lang.isNumber(wh)		|| 
+			dojo.lang.isBoolean(wh)		|| 
+			(wh == null)				|| 
+			(wh instanceof Error)		|| 
+			(typeof wh == &quot;error&quot;) );
+}
+
+/**
+ * Returns true for any object where the value of the 
+ * property 'constructor' is 'Object'.  
+ * 
+ * Examples:
+ * &lt;pre&gt;
+ *   dojo.lang.isPureObject(new Object()); // returns true
+ *   dojo.lang.isPureObject({a: 1, b: 2}); // returns true
+ * 
+ *   dojo.lang.isPureObject(new Date());   // returns false
+ *   dojo.lang.isPureObject([11, 2, 3]);   // returns false
+ * &lt;/pre&gt;
+ */
+dojo.lang.isPureObject = function(wh){
+	return ((wh != null) &amp;&amp; dojo.lang.isObject(wh) &amp;&amp; wh.constructor == Object);
+}
+
+/**
+ * Given a value and a datatype, this method returns true if the
+ * type of the value matches the datatype. The datatype parameter
+ * can be an array of datatypes, in which case the method returns
+ * true if the type of the value matches any of the datatypes.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   dojo.lang.isOfType(&quot;foo&quot;, String);                // returns true
+ *   dojo.lang.isOfType(12345, Number);                // returns true
+ *   dojo.lang.isOfType(false, Boolean);               // returns true
+ *   dojo.lang.isOfType([6, 8], Array);                // returns true
+ *   dojo.lang.isOfType(dojo.lang.isOfType, Function); // returns true
+ *   dojo.lang.isOfType({foo: &quot;bar&quot;}, Object);         // returns true
+ *   dojo.lang.isOfType(new Date(), Date);             // returns true
+ *   dojo.lang.isOfType(xxxxx, Date);                  // returns true
+ *
+ *   dojo.lang.isOfType(&quot;foo&quot;, &quot;string&quot;);                // returns true
+ *   dojo.lang.isOfType(12345, &quot;number&quot;);                // returns true
+ *   dojo.lang.isOfType(false, &quot;boolean&quot;);               // returns true
+ *   dojo.lang.isOfType([6, 8], &quot;array&quot;);                // returns true
+ *   dojo.lang.isOfType(dojo.lang.isOfType, &quot;function&quot;); // returns true
+ *   dojo.lang.isOfType({foo: &quot;bar&quot;}, &quot;object&quot;);         // returns true
+ *   dojo.lang.isOfType(xxxxx, &quot;undefined&quot;);             // returns true
+ *   dojo.lang.isOfType(null, &quot;null&quot;);                   // returns true
+
+ *   dojo.lang.isOfType(&quot;foo&quot;, [Number, String, Boolean]); // returns true
+ *   dojo.lang.isOfType(12345, [Number, String, Boolean]); // returns true
+ *   dojo.lang.isOfType(false, [Number, String, Boolean]); // returns true
+ *   dojo.lang.isOfType(xxxxx, &quot;undefined&quot;);               // returns true
+ * &lt;/pre&gt;
+ *
+ * @param	value	Any literal value or object instance.
+ * @param	type	A class of object, or a literal type, or the string name of a type, or an array with a list of types.
+ * @return	Returns a boolean
+ */
+dojo.lang.isOfType = function(value, type) {
+	if(dojo.lang.isArray(type)){
+		var arrayOfTypes = type;
+		for(var i in arrayOfTypes){
+			var aType = arrayOfTypes[i];
+			if(dojo.lang.isOfType(value, aType)) {
+				return true;
+			}
+		}
+		return false;
+	}else{
+		if(dojo.lang.isString(type)){
+			type = type.toLowerCase();
+		}
+		switch (type) {
+			case Array:
+			case &quot;array&quot;:
+				return dojo.lang.isArray(value);
+				break;
+			case Function:
+			case &quot;function&quot;:
+				return dojo.lang.isFunction(value);
+				break;
+			case String:
+			case &quot;string&quot;:
+				return dojo.lang.isString(value);
+				break;
+			case Number:
+			case &quot;number&quot;:
+				return dojo.lang.isNumber(value);
+				break;
+			case &quot;numeric&quot;:
+				return dojo.lang.isNumeric(value);
+				break;
+			case Boolean:
+			case &quot;boolean&quot;:
+				return dojo.lang.isBoolean(value);
+				break;
+			case Object:
+			case &quot;object&quot;:
+				return dojo.lang.isObject(value);
+				break;
+			case &quot;pureobject&quot;:
+				return dojo.lang.isPureObject(value);
+				break;
+			case &quot;builtin&quot;:
+				return dojo.lang.isBuiltIn(value);
+				break;
+			case &quot;alien&quot;:
+				return dojo.lang.isAlien(value);
+				break;
+			case &quot;undefined&quot;:
+				return dojo.lang.isUndefined(value);
+				break;
+			case null:
+			case &quot;null&quot;:
+				return (value === null);
+				break;
+			case &quot;optional&quot;:
+				return ((value === null) || dojo.lang.isUndefined(value));
+				break;
+			default:
+				if (dojo.lang.isFunction(type)) {
+					return (value instanceof type);
+				} else {
+					dojo.raise(&quot;dojo.lang.isOfType() was passed an invalid type&quot;);
+				}
+				break;
+		}
+	}
+	dojo.raise(&quot;If we get here, it means a bug was introduced above.&quot;);
+}
+
+/*
+ * 	From reflection code, part of merge.
+ *	TRT 2006-02-01
+ */
+dojo.lang.getObject=function(/* String */ str){
+	//	summary
+	//	Will return an object, if it exists, based on the name in the passed string.
+	var parts=str.split(&quot;.&quot;), i=0, obj=dj_global; 
+	do{ 
+		obj=obj[parts[i++]]; 
+	}while(i&lt;parts.length&amp;&amp;obj); 
+	return (obj!=dj_global)?obj:null;	//	Object
+}
+
+dojo.lang.doesObjectExist=function(/* String */ str){
+	//	summary
+	//	Check to see if object [str] exists, based on the passed string.
+	var parts=str.split(&quot;.&quot;), i=0, obj=dj_global; 
+	do{ 
+		obj=obj[parts[i++]]; 
+	}while(i&lt;parts.length&amp;&amp;obj); 
+	return (obj&amp;&amp;obj!=dj_global);	//	boolean
+}

Added: trunk/root/static/magic/src/lang.js
===================================================================
--- trunk/root/static/magic/src/lang.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lang.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lang&quot;);
+dojo.provide(&quot;dojo.lang.Lang&quot;);
+
+dojo.require(&quot;dojo.lang.common&quot;);

Added: trunk/root/static/magic/src/lfx/Animation.js
===================================================================
--- trunk/root/static/magic/src/lfx/Animation.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lfx/Animation.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,476 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lfx.Animation&quot;);
+dojo.provide(&quot;dojo.lfx.Line&quot;);
+
+dojo.require(&quot;dojo.lang.func&quot;);
+
+/*
+	Animation package based on Dan Pupius' work: <A HREF="http://pupius.co.uk/js/Toolkit.Drawing.js">http://pupius.co.uk/js/Toolkit.Drawing.js</A>
+*/
+dojo.lfx.Line = function(start, end){
+	this.start = start;
+	this.end = end;
+	if(dojo.lang.isArray(start)){
+		var diff = [];
+		dojo.lang.forEach(this.start, function(s,i){
+			diff[i] = this.end[i] - s;
+		}, this);
+		
+		this.getValue = function(/*float*/ n){
+			var res = [];
+			dojo.lang.forEach(this.start, function(s, i){
+				res[i] = (diff[i] * n) + s;
+			}, this);
+			return res;
+		}
+	}else{
+		var diff = end - start;
+			
+		this.getValue = function(/*float*/ n){
+			//	summary: returns the point on the line
+			//	n: a floating point number greater than 0 and less than 1
+			return (diff * n) + this.start;
+		}
+	}
+}
+
+dojo.lfx.easeIn = function(n){
+	//	summary: returns the point on an easing curve
+	//	n: a floating point number greater than 0 and less than 1
+	return Math.pow(n, 3);
+}
+
+dojo.lfx.easeOut = function(n){
+	//	summary: returns the point on the line
+	//	n: a floating point number greater than 0 and less than 1
+	return ( 1 - Math.pow(1 - n, 3) );
+}
+
+dojo.lfx.easeInOut = function(n){
+	//	summary: returns the point on the line
+	//	n: a floating point number greater than 0 and less than 1
+	return ( (3 * Math.pow(n, 2)) - (2 * Math.pow(n, 3)) );
+}
+
+dojo.lfx.IAnimation = function(){}
+dojo.lang.extend(dojo.lfx.IAnimation, {
+	// public properties
+	curve: null,
+	duration: 1000,
+	easing: null,
+	repeatCount: 0,
+	rate: 25,
+	
+	// events
+	handler: null,
+	beforeBegin: null,
+	onBegin: null,
+	onAnimate: null,
+	onEnd: null,
+	onPlay: null,
+	onPause: null,
+	onStop: null,
+	
+	// public methods
+	play: null,
+	pause: null,
+	stop: null,
+	
+	fire: function(evt, args){
+		if(this[evt]){
+			this[evt].apply(this, (args||[]));
+		}
+	},
+	
+	// private properties
+	_active: false,
+	_paused: false
+});
+
+dojo.lfx.Animation = function(/*Object*/ handlers, /*int*/ duration, /*Array*/ curve, /*function*/ easing, /*int*/ repeatCount, /*int*/ rate){
+	//	summary
+	//		a generic animation object that fires callbacks into it's handlers
+	//		object at various states
+	//	handlers
+	//		object { 
+	//			handler: function(){}, 
+	//			onstart: function(){}, 
+	//			onstop: function(){}, 
+	//			onanimate: function(){}
+	//		}
+	dojo.lfx.IAnimation.call(this);
+	if(dojo.lang.isNumber(handlers)||(!handlers &amp;&amp; duration.getValue)){
+		// no handlers argument:
+		rate = repeatCount;
+		repeatCount = easing;
+		easing = curve;
+		curve = duration;
+		duration = handlers;
+		handlers = null;
+	}else if(handlers.getValue||dojo.lang.isArray(handlers)){
+		// no handlers or duration:
+		rate = easing;
+		repeatCount = curve;
+		easing = duration;
+		curve = handlers;
+		duration = null;
+		handlers = null;
+	}
+	if(dojo.lang.isArray(curve)){
+		this.curve = new dojo.lfx.Line(curve[0], curve[1]);
+	}else{
+		this.curve = curve;
+	}
+	if(duration != null &amp;&amp; duration &gt; 0){ this.duration = duration; }
+	if(repeatCount){ this.repeatCount = repeatCount; }
+	if(rate){ this.rate = rate; }
+	if(handlers){
+		this.handler = handlers.handler;
+		this.beforeBegin = handlers.beforeBegin;
+		this.onBegin = handlers.onBegin;
+		this.onEnd = handlers.onEnd;
+		this.onPlay = handlers.onPlay;
+		this.onPause = handlers.onPause;
+		this.onStop = handlers.onStop;
+		this.onAnimate = handlers.onAnimate;
+	}
+	if(easing &amp;&amp; dojo.lang.isFunction(easing)){
+		this.easing=easing;
+	}
+}
+dojo.inherits(dojo.lfx.Animation, dojo.lfx.IAnimation);
+dojo.lang.extend(dojo.lfx.Animation, {
+	// &quot;private&quot; properties
+	_startTime: null,
+	_endTime: null,
+	_timer: null,
+	_percent: 0,
+	_startRepeatCount: 0,
+
+	// public methods
+	play: function(delay, gotoStart){
+		if(gotoStart){
+			clearTimeout(this._timer);
+			this._active = false;
+			this._paused = false;
+			this._percent = 0;
+		}else if(this._active &amp;&amp; !this._paused){
+			return this;
+		}
+		
+		this.fire(&quot;handler&quot;, [&quot;beforeBegin&quot;]);
+		this.fire(&quot;beforeBegin&quot;);
+
+		if(delay &gt; 0){
+			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
+			return this;
+		}
+		
+		this._startTime = new Date().valueOf();
+		if(this._paused){
+			this._startTime -= (this.duration * this._percent / 100);
+		}
+		this._endTime = this._startTime + this.duration;
+
+		this._active = true;
+		this._paused = false;
+		
+		var step = this._percent / 100;
+		var value = this.curve.getValue(step);
+		if( this._percent == 0 ) {
+			if(!this._startRepeatCount) {
+				this._startRepeatCount = this.repeatCount;
+			}
+			this.fire(&quot;handler&quot;, [&quot;begin&quot;, value]);
+			this.fire(&quot;onBegin&quot;, [value]);
+		}
+
+		this.fire(&quot;handler&quot;, [&quot;play&quot;, value]);
+		this.fire(&quot;onPlay&quot;, [value]);
+
+		this._cycle();
+		return this;
+	},
+
+	pause: function() {
+		clearTimeout(this._timer);
+		if(!this._active){ return this; }
+		this._paused = true;
+		var value = this.curve.getValue(this._percent / 100);
+		this.fire(&quot;handler&quot;, [&quot;pause&quot;, value]);
+		this.fire(&quot;onPause&quot;, [value]);
+		return this;
+	},
+
+	gotoPercent: function(pct, andPlay) {
+		clearTimeout(this._timer);
+		this._active = true;
+		this._paused = true;
+		this._percent = pct;
+		if( andPlay ) { this.play(); }
+	},
+
+	stop: function(gotoEnd) {
+		clearTimeout(this._timer);
+		var step = this._percent / 100;
+		if( gotoEnd ) {
+			step = 1;
+		}
+		var value = this.curve.getValue(step);
+		this.fire(&quot;handler&quot;, [&quot;stop&quot;, value]);
+		this.fire(&quot;onStop&quot;, [value]);
+		this._active = false;
+		this._paused = false;
+		return this;
+	},
+
+	status: function() {
+		if( this._active ) {
+			return this._paused ? &quot;paused&quot; : &quot;playing&quot;;
+		} else {
+			return &quot;stopped&quot;;
+		}
+	},
+
+	// &quot;private&quot; methods
+	_cycle: function() {
+		clearTimeout(this._timer);
+		if(this._active){
+			var curr = new Date().valueOf();
+			var step = (curr - this._startTime) / (this._endTime - this._startTime);
+
+			if(step &gt;= 1){
+				step = 1;
+				this._percent = 100;
+			}else{
+				this._percent = step * 100;
+			}
+			
+			// Perform easing
+			if((this.easing)&amp;&amp;(dojo.lang.isFunction(this.easing))){
+				step = this.easing(step);
+			}
+
+			var value = this.curve.getValue(step);
+			this.fire(&quot;handler&quot;, [&quot;animate&quot;, value]);
+			this.fire(&quot;onAnimate&quot;, [value]);
+
+			if( step &lt; 1 ) {
+				this._timer = setTimeout(dojo.lang.hitch(this, &quot;_cycle&quot;), this.rate);
+			} else {
+				this._active = false;
+				this.fire(&quot;handler&quot;, [&quot;end&quot;]);
+				this.fire(&quot;onEnd&quot;);
+
+				if( this.repeatCount &gt; 0 ) {
+					this.repeatCount--;
+					this.play(null, true);
+				} else if( this.repeatCount == -1 ) {
+					this.play(null, true);
+				} else {
+					if(this._startRepeatCount) {
+						this.repeatCount = this._startRepeatCount;
+						this._startRepeatCount = 0;
+					}
+				}
+			}
+		}
+		return this;
+	}
+});
+
+dojo.lfx.Combine = function(){
+	dojo.lfx.IAnimation.call(this);
+	this._anims = [];
+	this._animsEnded = 0;
+	
+	var anims = arguments;
+	if(anims.length == 1 &amp;&amp; (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
+		anims = anims[0];
+	}
+	
+	var _this = this;
+	dojo.lang.forEach(anims, function(anim){
+		_this._anims.push(anim);
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ oldOnEnd(); _this._onAnimsEnded(); };
+	});
+}
+dojo.inherits(dojo.lfx.Combine, dojo.lfx.IAnimation);
+dojo.lang.extend(dojo.lfx.Combine, {
+	// private members
+	_animsEnded: 0,
+	
+	// public methods
+	play: function(delay, gotoStart){
+		if( !this._anims.length ){ return this; }
+
+		this.fire(&quot;beforeBegin&quot;);
+
+		if(delay &gt; 0){
+			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
+			return this;
+		}
+		
+		if(gotoStart || this._anims[0].percent == 0){
+			this.fire(&quot;onBegin&quot;);
+		}
+		this.fire(&quot;onPlay&quot;);
+		this._animsCall(&quot;play&quot;, null, gotoStart);
+		return this;
+	},
+	
+	pause: function(){
+		this.fire(&quot;onPause&quot;);
+		this._animsCall(&quot;pause&quot;); 
+		return this;
+	},
+	
+	stop: function(gotoEnd){
+		this.fire(&quot;onStop&quot;);
+		this._animsCall(&quot;stop&quot;, gotoEnd);
+		return this;
+	},
+	
+	// private methods
+	_onAnimsEnded: function(){
+		this._animsEnded++;
+		if(this._animsEnded &gt;= this._anims.length){
+			this.fire(&quot;onEnd&quot;);
+		}
+		return this;
+	},
+	
+	_animsCall: function(funcName){
+		var args = [];
+		if(arguments.length &gt; 1){
+			for(var i = 1 ; i &lt; arguments.length ; i++){
+				args.push(arguments[i]);
+			}
+		}
+		var _this = this;
+		dojo.lang.forEach(this._anims, function(anim){
+			anim[funcName](args);
+		}, _this);
+		return this;
+	}
+});
+
+dojo.lfx.Chain = function() {
+	dojo.lfx.IAnimation.call(this);
+	this._anims = [];
+	this._currAnim = -1;
+	
+	var anims = arguments;
+	if(anims.length == 1 &amp;&amp; (dojo.lang.isArray(anims[0]) || dojo.lang.isArrayLike(anims[0]))){
+		anims = anims[0];
+	}
+	
+	var _this = this;
+	dojo.lang.forEach(anims, function(anim, i, anims_arr){
+		_this._anims.push(anim);
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		if(i &lt; anims_arr.length - 1){
+			anim.onEnd = function(){ oldOnEnd(); _this._playNext(); };
+		}else{
+			anim.onEnd = function(){ oldOnEnd(); _this.fire(&quot;onEnd&quot;); };
+		}
+	}, _this);
+}
+dojo.inherits(dojo.lfx.Chain, dojo.lfx.IAnimation);
+dojo.lang.extend(dojo.lfx.Chain, {
+	// private members
+	_currAnim: -1,
+	
+	// public methods
+	play: function(delay, gotoStart){
+		if( !this._anims.length ) { return this; }
+		if( gotoStart || !this._anims[this._currAnim] ) {
+			this._currAnim = 0;
+		}
+
+		var currentAnimation = this._anims[this._currAnim];
+
+		this.fire(&quot;beforeBegin&quot;);
+		if(delay &gt; 0){
+			setTimeout(dojo.lang.hitch(this, function(){ this.play(null, gotoStart); }), delay);
+			return this;
+		}
+		
+		if(currentAnimation){
+			if(this._currAnim == 0){
+				this.fire(&quot;handler&quot;, [&quot;begin&quot;, this._currAnim]);
+				this.fire(&quot;onBegin&quot;, [this._currAnim]);
+			}
+			this.fire(&quot;onPlay&quot;, [this._currAnim]);
+			currentAnimation.play(null, gotoStart);
+		}
+		return this;
+	},
+	
+	pause: function(){
+		if( this._anims[this._currAnim] ) {
+			this._anims[this._currAnim].pause();
+			this.fire(&quot;onPause&quot;, [this._currAnim]);
+		}
+		return this;
+	},
+	
+	playPause: function(){
+		if(this._anims.length == 0){ return this; }
+		if(this._currAnim == -1){ this._currAnim = 0; }
+		var currAnim = this._anims[this._currAnim];
+		if( currAnim ) {
+			if( !currAnim._active || currAnim._paused ) {
+				this.play();
+			} else {
+				this.pause();
+			}
+		}
+		return this;
+	},
+	
+	stop: function(){
+		var currAnim = this._anims[this._currAnim];
+		if(currAnim){
+			currAnim.stop();
+			this.fire(&quot;onStop&quot;, [this._currAnim]);
+		}
+		return currAnim;
+	},
+	
+	// private methods
+	_playNext: function(){
+		if( this._currAnim == -1 || this._anims.length == 0 ) { return this; }
+		this._currAnim++;
+		if( this._anims[this._currAnim] ){
+			this._anims[this._currAnim].play(null, true);
+		}
+		return this;
+	}
+});
+
+dojo.lfx.combine = function(){
+	var anims = arguments;
+	if(dojo.lang.isArray(arguments[0])){
+		anims = arguments[0];
+	}
+	return new dojo.lfx.Combine(anims);
+}
+
+dojo.lfx.chain = function(){
+	var anims = arguments;
+	if(dojo.lang.isArray(arguments[0])){
+		anims = arguments[0];
+	}
+	return new dojo.lfx.Chain(anims);
+}

Added: trunk/root/static/magic/src/lfx/__package__.js
===================================================================
--- trunk/root/static/magic/src/lfx/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lfx/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	browser: [&quot;dojo.lfx.html&quot;],
+	dashboard: [&quot;dojo.lfx.html&quot;]
+});
+dojo.provide(&quot;dojo.lfx.*&quot;);
\ No newline at end of file

Added: trunk/root/static/magic/src/lfx/extras.js
===================================================================
--- trunk/root/static/magic/src/lfx/extras.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lfx/extras.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,119 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lfx.extras&quot;);
+
+dojo.require(&quot;dojo.lfx.html&quot;);
+dojo.require(&quot;dojo.lfx.Animation&quot;);
+
+dojo.lfx.html.fadeWipeIn = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anim = dojo.lfx.combine(
+		dojo.lfx.wipeIn(nodes, duration, easing),
+		dojo.lfx.fadeIn(nodes, duration, easing));
+	
+	if(callback){
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(){
+			callback(nodes, anim);
+		});
+	}
+	
+	return anim;
+}
+
+dojo.lfx.html.fadeWipeOut = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anim = dojo.lfx.combine(
+		dojo.lfx.wipeOut(nodes, duration, easing),
+		dojo.lfx.fadeOut(nodes, duration, easing));
+	
+	if(callback){
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(){
+			callback(nodes, anim);
+		});
+	}
+
+	return anim;
+}
+
+dojo.lfx.html.scale = function(nodes, percentage, scaleContent, fromCenter, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+
+	dojo.lang.forEach(nodes, function(node){
+		var origWidth = dojo.style.getOuterWidth(node);
+		var origHeight = dojo.style.getOuterHeight(node);
+
+		var actualPct = percentage/100.0;
+		var props = [
+			{	property: &quot;width&quot;,
+				start: origWidth,
+				end: origWidth * actualPct
+			},
+			{	property: &quot;height&quot;,
+				start: origHeight,
+				end: origHeight * actualPct
+			}];
+		
+		if(scaleContent){
+			var fontSize = dojo.style.getStyle(node, 'font-size');
+			var fontSizeType = null;
+			if(!fontSize){
+				fontSize = parseFloat('100%');
+				fontSizeType = '%';
+			}else{
+				dojo.lang.some(['em','px','%'], function(item, index, arr){
+					if(fontSize.indexOf(item)&gt;0){
+						fontSize = parseFloat(fontSize);
+						fontSizeType = item;
+						return true;
+					}
+				});
+			}
+			props.push({
+				property: &quot;font-size&quot;,
+				start: fontSize,
+				end: fontSize * actualPct,
+				units: fontSizeType });
+		}
+		
+		if(fromCenter){
+			var positioning = dojo.style.getStyle(node, &quot;position&quot;);
+			var originalTop = node.offsetTop;
+			var originalLeft = node.offsetLeft;
+			var endTop = ((origHeight * actualPct) - origHeight)/2;
+			var endLeft = ((origWidth * actualPct) - origWidth)/2;
+			props.push({
+				property: &quot;top&quot;,
+				start: originalTop,
+				end: (positioning == &quot;absolute&quot; ? originalTop - endTop : (-1*endTop))
+			});
+			props.push({
+				property: &quot;left&quot;,
+				start: originalLeft,
+				end: (positioning == &quot;absolute&quot; ? originalLeft - endLeft : (-1*endLeft))
+			});
+		}
+		
+		var anim = dojo.lfx.propertyAnimation(node, props, duration, easing);
+		if(callback){
+			dojo.event.connect(anim, &quot;onEnd&quot;, function(){
+				callback(node, anim);
+			});
+		}
+
+		anims.push(anim);
+	});
+	
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lang.mixin(dojo.lfx, dojo.lfx.html);

Added: trunk/root/static/magic/src/lfx/html.js
===================================================================
--- trunk/root/static/magic/src/lfx/html.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lfx/html.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,535 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lfx.html&quot;);
+dojo.require(&quot;dojo.lfx.Animation&quot;);
+
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.lfx.html._byId = function(nodes){
+	if(!nodes){ return []; }
+	if(dojo.lang.isArray(nodes)){
+		if(!nodes.alreadyChecked){
+			var n = [];
+			dojo.lang.forEach(nodes, function(node){
+				n.push(dojo.byId(node));
+			});
+			n.alreadyChecked = true;
+			return n;
+		}else{
+			return nodes;
+		}
+	}else{
+		var n = [];
+		n.push(dojo.byId(nodes));
+		n.alreadyChecked = true;
+		return n;
+	}
+}
+
+dojo.lfx.html.propertyAnimation = function(	/*DOMNode*/ nodes, 
+											/*Array*/ propertyMap, 
+											/*int*/ duration,
+											/*function*/ easing){
+	nodes = dojo.lfx.html._byId(nodes);
+	
+	if(nodes.length==1){
+		// FIXME: we're only supporting start-value filling when one node is
+		// passed
+		
+		dojo.lang.forEach(propertyMap, function(prop){
+			if(typeof prop[&quot;start&quot;] == &quot;undefined&quot;){
+				if(prop.property != &quot;opacity&quot;){
+					prop.start = parseInt(dojo.style.getComputedStyle(nodes[0], prop.property));
+				}else{
+					prop.start = dojo.style.getOpacity(nodes[0]);
+				}
+			}
+		});
+	}
+
+	var coordsAsInts = function(coords){
+		var cints = new Array(coords.length);
+		for(var i = 0; i &lt; coords.length; i++){
+			cints[i] = Math.round(coords[i]);
+		}
+		return cints;
+	}
+	var setStyle = function(n, style){
+		n = dojo.byId(n);
+		if(!n || !n.style){ return; }
+		for(var s in style){
+			if(s == &quot;opacity&quot;){
+				dojo.style.setOpacity(n, style[s]);
+			}else{
+				n.style[s] = style[s];
+			}
+		}
+	}
+	var propLine = function(properties){
+		this._properties = properties;
+		this.diffs = new Array(properties.length);
+		dojo.lang.forEach(properties, function(prop, i){
+			// calculate the end - start to optimize a bit
+			if(dojo.lang.isArray(prop.start)){
+				// don't loop through the arrays
+				this.diffs[i] = null;
+			}else if(prop.start instanceof dojo.graphics.color.Color){
+				// save these so we don't have to call toRgb() every getValue() call
+				prop.startRgb = prop.start.toRgb();
+				prop.endRgb = prop.end.toRgb();
+			}else{
+				this.diffs[i] = prop.end - prop.start;
+			}
+		}, this);
+		this.getValue = function(n){
+			var ret = {};
+			dojo.lang.forEach(this._properties, function(prop, i){
+				var value = null;
+				if(dojo.lang.isArray(prop.start)){
+					// FIXME: what to do here?
+				}else if(prop.start instanceof dojo.graphics.color.Color){
+					value = (prop.units||&quot;rgb&quot;) + &quot;(&quot;;
+					for(var j = 0 ; j &lt; prop.startRgb.length ; j++){
+						value += Math.round(((prop.endRgb[j] - prop.startRgb[j]) * n) + prop.startRgb[j]) + (j &lt; prop.startRgb.length - 1 ? &quot;,&quot; : &quot;&quot;);
+					}
+					value += &quot;)&quot;;
+				}else{
+					value = ((this.diffs[i]) * n) + prop.start + (prop.property != &quot;opacity&quot; ? prop.units||&quot;px&quot; : &quot;&quot;);
+				}
+				ret[dojo.style.toCamelCase(prop.property)] = value;
+			}, this);
+			return ret;
+		}
+	}
+	
+	var anim = new dojo.lfx.Animation({
+		onAnimate: function(propValues){
+			dojo.lang.forEach(nodes, function(node){
+				setStyle(node, propValues);
+			});
+		} }, duration, new propLine(propertyMap), easing);
+	
+	return anim;
+}
+
+dojo.lfx.html._makeFadeable = function(nodes){
+	var makeFade = function(node){
+		if(dojo.render.html.ie){
+			// only set the zoom if the &quot;tickle&quot; value would be the same as the
+			// default
+			if( (node.style.zoom.length == 0) &amp;&amp;
+				(dojo.style.getStyle(node, &quot;zoom&quot;) == &quot;normal&quot;) ){
+				// make sure the node &quot;hasLayout&quot;
+				// NOTE: this has been tested with larger and smaller user-set text
+				// sizes and works fine
+				node.style.zoom = &quot;1&quot;;
+				// node.style.zoom = &quot;normal&quot;;
+			}
+			// don't set the width to auto if it didn't already cascade that way.
+			// We don't want to f anyones designs
+			if(	(node.style.width.length == 0) &amp;&amp;
+				(dojo.style.getStyle(node, &quot;width&quot;) == &quot;auto&quot;) ){
+				node.style.width = &quot;auto&quot;;
+			}
+		}
+	}
+	if(dojo.lang.isArrayLike(nodes)){
+		dojo.lang.forEach(nodes, makeFade);
+	}else{
+		makeFade(nodes);
+	}
+}
+
+dojo.lfx.html.fadeIn = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	dojo.lfx.html._makeFadeable(nodes);
+	var anim = dojo.lfx.propertyAnimation(nodes, [
+		{	property: &quot;opacity&quot;,
+			start: dojo.style.getOpacity(nodes[0]),
+			end: 1 } ], duration, easing);
+	if(callback){
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
+	}
+
+	return anim;
+}
+
+dojo.lfx.html.fadeOut = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	dojo.lfx.html._makeFadeable(nodes);
+	var anim = dojo.lfx.propertyAnimation(nodes, [
+		{	property: &quot;opacity&quot;,
+			start: dojo.style.getOpacity(nodes[0]),
+			end: 0 } ], duration, easing);
+	if(callback){
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
+	}
+
+	return anim;
+}
+
+dojo.lfx.html.fadeShow = function(nodes, duration, easing, callback){
+	var anim = dojo.lfx.html.fadeIn(nodes, duration, easing, callback);
+	var oldBb = (anim[&quot;beforeBegin&quot;]) ? dojo.lang.hitch(anim, &quot;beforeBegin&quot;) : function(){};
+	anim.beforeBegin = function(){ 
+		oldBb();
+		if(dojo.lang.isArrayLike(nodes)){
+			dojo.lang.forEach(nodes, dojo.style.show);
+		}else{
+			dojo.style.show(nodes);
+		}
+	};
+	
+	return anim;
+}
+
+dojo.lfx.html.fadeHide = function(nodes, duration, easing, callback){
+	var anim = dojo.lfx.html.fadeOut(nodes, duration, easing, function(){
+		if(dojo.lang.isArrayLike(nodes)){
+			dojo.lang.forEach(nodes, dojo.style.hide);
+		}else{
+			dojo.style.hide(nodes);
+		}
+		if(callback){ callback(nodes, anim); }
+	});
+	
+	return anim;
+}
+
+dojo.lfx.html.wipeIn = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+
+	dojo.lang.forEach(nodes, function(node){
+		var overflow = dojo.style.getStyle(node, &quot;overflow&quot;);
+		if(overflow == &quot;visible&quot;) {
+			node.style.overflow = &quot;hidden&quot;;
+		}
+		node.style.height = &quot;0px&quot;;
+		dojo.style.show(node);
+		
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: &quot;height&quot;,
+				start: 0,
+				end: node.scrollHeight }], duration, easing);
+		
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd(); 
+			node.style.overflow = overflow;
+			node.style.height = &quot;auto&quot;;
+			if(callback){ callback(node, anim); }
+		};
+		anims.push(anim);
+	});
+	
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.wipeOut = function(nodes, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+	
+	dojo.lang.forEach(nodes, function(node){
+		var overflow = dojo.style.getStyle(node, &quot;overflow&quot;);
+		if(overflow == &quot;visible&quot;) {
+			node.style.overflow = &quot;hidden&quot;;
+		}
+		dojo.style.show(node);
+
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: &quot;height&quot;,
+				start: dojo.style.getContentBoxHeight(node),
+				end: 0 } ], duration, easing);
+		
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd(); 
+			dojo.style.hide(node);
+			node.style.overflow = overflow;
+			if(callback){ callback(node, anim); }
+		};
+		anims.push(anim);
+	});
+
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else { return anims[0]; }
+}
+
+dojo.lfx.html.slideTo = function(nodes, coords, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+
+	dojo.lang.forEach(nodes, function(node){
+		var top = null;
+		var left = null;
+		
+		var init = (function(){
+			var innerNode = node;
+			return function(){
+				top = innerNode.offsetTop;
+				left = innerNode.offsetLeft;
+
+				if (!dojo.style.isPositionAbsolute(innerNode)) {
+					var ret = dojo.style.abs(innerNode, true);
+					dojo.style.setStyleAttributes(innerNode, &quot;position:absolute;top:&quot;+ret.y+&quot;px;left:&quot;+ret.x+&quot;px;&quot;);
+					top = ret.y;
+					left = ret.x;
+				}
+			}
+		})();
+		init();
+		
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: &quot;top&quot;,
+				start: top,
+				end: coords[0] },
+			{	property: &quot;left&quot;,
+				start: left,
+				end: coords[1] }], duration, easing);
+		
+		var oldBb = (anim[&quot;beforeBegin&quot;]) ? dojo.lang.hitch(anim, &quot;beforeBegin&quot;) : function(){};
+		anim.beforeBegin = function(){ oldBb(); init(); };
+
+		if(callback){
+			var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+			anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
+		}
+
+		anims.push(anim);
+	});
+	
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.slideBy = function(nodes, coords, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+
+	dojo.lang.forEach(nodes, function(node){
+		var top = null;
+		var left = null;
+		
+		var init = (function(){
+			var innerNode = node;
+			return function(){
+				top = node.offsetTop;
+				left = node.offsetLeft;
+
+				if (!dojo.style.isPositionAbsolute(innerNode)) {
+					var ret = dojo.style.abs(innerNode);
+					dojo.style.setStyleAttributes(innerNode, &quot;position:absolute;top:&quot;+ret.y+&quot;px;left:&quot;+ret.x+&quot;px;&quot;);
+					top = ret.y;
+					left = ret.x;
+				}
+			}
+		})();
+		init();
+		
+		var anim = dojo.lfx.propertyAnimation(node,
+			[{	property: &quot;top&quot;,
+				start: top,
+				end: top+coords[0] },
+			{	property: &quot;left&quot;,
+				start: left,
+				end: left+coords[1] }], duration, easing);
+
+		var oldBb = (anim[&quot;beforeBegin&quot;]) ? dojo.lang.hitch(anim, &quot;beforeBegin&quot;) : function(){};
+		anim.beforeBegin = function(){ oldBb(); init(); };
+
+		if(callback){
+			var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+			anim.onEnd = function(){ oldOnEnd(); callback(nodes, anim); };
+		}
+
+		anims.push(anim);
+	});
+
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.explode = function(start, endNode, duration, easing, callback){
+	start = dojo.byId(start);
+	endNode = dojo.byId(endNode);
+	var startCoords = dojo.style.toCoordinateArray(start, true);
+	var outline = document.createElement(&quot;div&quot;);
+	dojo.html.copyStyle(outline, endNode);
+	with(outline.style){
+		position = &quot;absolute&quot;;
+		display = &quot;none&quot;;
+	}
+	document.body.appendChild(outline);
+
+	with(endNode.style){
+		visibility = &quot;hidden&quot;;
+		display = &quot;block&quot;;
+	}
+	var endCoords = dojo.style.toCoordinateArray(endNode, true);
+	with(endNode.style){
+		display = &quot;none&quot;;
+		visibility = &quot;visible&quot;;
+	}
+
+	var anim = new dojo.lfx.propertyAnimation(outline, [
+		{ property: &quot;height&quot;, start: startCoords[3], end: endCoords[3] },
+		{ property: &quot;width&quot;, start: startCoords[2], end: endCoords[2] },
+		{ property: &quot;top&quot;, start: startCoords[1], end: endCoords[1] },
+		{ property: &quot;left&quot;, start: startCoords[0], end: endCoords[0] },
+		{ property: &quot;opacity&quot;, start: 0.3, end: 1.0 }
+	], duration, easing);
+	
+	anim.beforeBegin = function(){
+		dojo.style.setDisplay(outline, &quot;block&quot;);
+	};
+	anim.onEnd = function(){
+		dojo.style.setDisplay(endNode, &quot;block&quot;);
+		outline.parentNode.removeChild(outline);
+	};
+	if(callback){
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(endNode, anim); };
+	}
+	return anim;
+}
+
+dojo.lfx.html.implode = function(startNode, end, duration, easing, callback){
+	startNode = dojo.byId(startNode);
+	end = dojo.byId(end);
+	var startCoords = dojo.style.toCoordinateArray(startNode, true);
+	var endCoords = dojo.style.toCoordinateArray(end, true);
+
+	var outline = document.createElement(&quot;div&quot;);
+	dojo.html.copyStyle(outline, startNode);
+	dojo.style.setOpacity(outline, 0.3);
+	with(outline.style){
+		position = &quot;absolute&quot;;
+		display = &quot;none&quot;;
+	}
+	document.body.appendChild(outline);
+
+	var anim = new dojo.lfx.propertyAnimation(outline, [
+		{ property: &quot;height&quot;, start: startCoords[3], end: endCoords[3] },
+		{ property: &quot;width&quot;, start: startCoords[2], end: endCoords[2] },
+		{ property: &quot;top&quot;, start: startCoords[1], end: endCoords[1] },
+		{ property: &quot;left&quot;, start: startCoords[0], end: endCoords[0] },
+		{ property: &quot;opacity&quot;, start: 1.0, end: 0.3 }
+	], duration, easing);
+	
+	anim.beforeBegin = function(){
+		dojo.style.hide(startNode);
+		dojo.style.show(outline);
+	};
+	anim.onEnd = function(){
+		outline.parentNode.removeChild(outline);
+	};
+	if(callback){
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ oldOnEnd(); callback(startNode, anim); };
+	}
+	return anim;
+}
+
+dojo.lfx.html.highlight = function(nodes, startColor, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+
+	dojo.lang.forEach(nodes, function(node){
+		var color = dojo.style.getBackgroundColor(node);
+		var bg = dojo.style.getStyle(node, &quot;background-color&quot;).toLowerCase();
+		var bgImage = dojo.style.getStyle(node, &quot;background-image&quot;);
+		var wasTransparent = (bg == &quot;transparent&quot; || bg == &quot;rgba(0, 0, 0, 0)&quot;);
+		while(color.length &gt; 3) { color.pop(); }
+
+		var rgb = new dojo.graphics.color.Color(startColor);
+		var endRgb = new dojo.graphics.color.Color(color);
+
+		var anim = dojo.lfx.propertyAnimation(node, [{
+			property: &quot;background-color&quot;,
+			start: rgb,
+			end: endRgb
+		}], duration, easing);
+
+		var oldbb = (anim[&quot;beforeBegin&quot;]) ? dojo.lang.hitch(anim, &quot;beforeBegin&quot;) : function(){};
+		anim.beforeBegin = function(){ 
+			oldbb();
+			if(bgImage){
+				node.style.backgroundImage = &quot;none&quot;;
+			}
+			node.style.backgroundColor = &quot;rgb(&quot; + rgb.toRgb().join(&quot;,&quot;) + &quot;)&quot;;
+		};
+
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd();
+			if(bgImage){
+				node.style.backgroundImage = bgImage;
+			}
+			if(wasTransparent){
+				node.style.backgroundColor = &quot;transparent&quot;;
+			}
+			if(callback){
+				callback(node, anim);
+			}
+		};
+
+		anims.push(anim);
+	});
+
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lfx.html.unhighlight = function(nodes, endColor, duration, easing, callback){
+	nodes = dojo.lfx.html._byId(nodes);
+	var anims = [];
+
+	dojo.lang.forEach(nodes, function(node){
+		var color = new dojo.graphics.color.Color(dojo.style.getBackgroundColor(node));
+		var rgb = new dojo.graphics.color.Color(endColor);
+
+		var bgImage = dojo.style.getStyle(node, &quot;background-image&quot;);
+		
+		var anim = dojo.lfx.propertyAnimation(node, [{
+			property: &quot;background-color&quot;,
+			start: color,
+			end: rgb
+		}], duration, easing);
+
+		var oldbb = (anim[&quot;beforeBegin&quot;]) ? dojo.lang.hitch(anim, &quot;beforeBegin&quot;) : function(){};
+		anim.beforeBegin = function(){ 
+			oldbb();
+			if(bgImage){
+				node.style.backgroundImage = &quot;none&quot;;
+			}
+			node.style.backgroundColor = &quot;rgb(&quot; + color.toRgb().join(&quot;,&quot;) + &quot;)&quot;;
+		};
+
+		var oldOnEnd = (anim[&quot;onEnd&quot;]) ? dojo.lang.hitch(anim, &quot;onEnd&quot;) : function(){};
+		anim.onEnd = function(){ 
+			oldOnEnd();
+			if(callback){
+				callback(node, anim);
+			}
+		};
+
+		anims.push(anim);
+	});
+
+	if(nodes.length &gt; 1){ return dojo.lfx.combine(anims); }
+	else{ return anims[0]; }
+}
+
+dojo.lang.mixin(dojo.lfx, dojo.lfx.html);

Added: trunk/root/static/magic/src/lfx/toggle.js
===================================================================
--- trunk/root/static/magic/src/lfx/toggle.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/lfx/toggle.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,54 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.lfx.toggle&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+
+dojo.lfx.toggle.plain = {
+	show: function(node, duration, easing, callback){
+		dojo.style.show(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	},
+	
+	hide: function(node, duration, easing, callback){
+		dojo.style.hide(node);
+		if(dojo.lang.isFunction(callback)){ callback(); }
+	}
+}
+
+dojo.lfx.toggle.fade = {
+	show: function(node, duration, easing, callback){
+		dojo.lfx.fadeShow(node, duration, easing, callback).play();
+	},
+
+	hide: function(node, duration, easing, callback){
+		dojo.lfx.fadeHide(node, duration, easing, callback).play();
+	}
+}
+
+dojo.lfx.toggle.wipe = {
+	show: function(node, duration, easing, callback){
+		dojo.lfx.wipeIn(node, duration, easing, callback).play();
+	},
+
+	hide: function(node, duration, easing, callback){
+		dojo.lfx.wipeOut(node, duration, easing, callback).play();
+	}
+}
+
+dojo.lfx.toggle.explode = {
+	show: function(node, duration, easing, callback, explodeSrc){
+		dojo.lfx.explode(explodeSrc||[0,0,0,0], node, duration, easing, callback).play();
+	},
+
+	hide: function(node, duration, easing, callback, explodeSrc){
+		dojo.lfx.implode(node, explodeSrc||[0,0,0,0], duration, easing, callback).play();
+	}
+}

Added: trunk/root/static/magic/src/loader.js
===================================================================
--- trunk/root/static/magic/src/loader.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/loader.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,450 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*
+ * loader.js - runs before the hostenv_*.js file. Contains all of the package loading methods.
+ */
+
+//A semi-colon is at the start of the line because after doing a build, this function definition
+//get compressed onto the same line as the last line in bootstrap1.js. That list line is just a
+//curly bracket, and the browser complains about that syntax. The semicolon fixes it. Putting it
+//here instead of at the end of bootstrap1.js, since it is more of an issue for this file, (using
+//the closure), and bootstrap1.js could change in the future.
+;(function(){
+	//Additional properties for dojo.hostenv
+	var _addHostEnv = {
+		pkgFileName: &quot;__package__&quot;,
+	
+		// for recursion protection
+		loading_modules_: {},
+		loaded_modules_: {},
+		addedToLoadingCount: [],
+		removedFromLoadingCount: [],
+	
+		inFlightCount: 0,
+	
+		// FIXME: it should be possible to pull module prefixes in from djConfig
+		modulePrefixes_: {
+			dojo: {name: &quot;dojo&quot;, value: &quot;src&quot;}
+		},
+	
+	
+		setModulePrefix: function(module, prefix){
+			this.modulePrefixes_[module] = {name: module, value: prefix};
+		},
+	
+		getModulePrefix: function(module){
+			var mp = this.modulePrefixes_;
+			if((mp[module])&amp;&amp;(mp[module][&quot;name&quot;])){
+				return mp[module].value;
+			}
+			return module;
+		},
+
+		getTextStack: [],
+		loadUriStack: [],
+		loadedUris: [],
+	
+		//WARNING: This variable is referenced by packages outside of bootstrap: FloatingPane.js and undo/browser.js
+		post_load_: false,
+		
+		//Egad! Lots of test files push on this directly instead of using dojo.addOnLoad.
+		modulesLoadedListeners: [],
+		unloadListeners: [],
+		loadNotifying: false
+	};
+	
+	//Add all of these properties to dojo.hostenv
+	for(var param in _addHostEnv){
+		dojo.hostenv[param] = _addHostEnv[param];
+	}
+})();
+
+/**
+ * Loads and interprets the script located at relpath, which is relative to the
+ * script root directory.  If the script is found but its interpretation causes
+ * a runtime exception, that exception is not caught by us, so the caller will
+ * see it.  We return a true value if and only if the script is found.
+ *
+ * For now, we do not have an implementation of a true search path.  We
+ * consider only the single base script uri, as returned by getBaseScriptUri().
+ *
+ * @param relpath A relative path to a script (no leading '/', and typically
+ * ending in '.js').
+ * @param module A module whose existance to check for after loading a path.
+ * Can be used to determine success or failure of the load.
+ * @param cb a function to pass the result of evaluating the script (optional)
+ */
+dojo.hostenv.loadPath = function(relpath, module /*optional*/, cb /*optional*/){
+	var uri;
+	if((relpath.charAt(0) == '/')||(relpath.match(/^\w+:/))){
+		// dojo.raise(&quot;relpath '&quot; + relpath + &quot;'; must be relative&quot;);
+		uri = relpath;
+	}else{
+		uri = this.getBaseScriptUri() + relpath;
+	}
+	if(djConfig.cacheBust &amp;&amp; dojo.render.html.capable){
+		uri += &quot;?&quot; + String(djConfig.cacheBust).replace(/\W+/g,&quot;&quot;);
+	}
+	try{
+		return ((!module) ? this.loadUri(uri, cb) : this.loadUriAndCheck(uri, module, cb));
+	}catch(e){
+		dojo.debug(e);
+		return false;
+	}
+}
+
+/**
+ * Reads the contents of the URI, and evaluates the contents.
+ * Returns true if it succeeded. Returns false if the URI reading failed.
+ * Throws if the evaluation throws.
+ * The result of the eval is not available to the caller TODO: now it is; was this a deliberate restriction?
+ *
+ * @param uri a uri which points at the script to be loaded
+ * @param cb a function to process the result of evaluating the script as an expression (optional)
+ */
+dojo.hostenv.loadUri = function(uri, cb /*optional*/){
+	if(this.loadedUris[uri]){
+		return 1;
+	}
+	var contents = this.getText(uri, null, true);
+	if(contents == null){ return 0; }
+	this.loadedUris[uri] = true;
+	if(cb){ contents = '('+contents+')'; }
+	var value = dj_eval(contents);
+	if(cb){
+		cb(value);
+	}
+	return 1;
+}
+
+// FIXME: probably need to add logging to this method
+dojo.hostenv.loadUriAndCheck = function(uri, module, cb){
+	var ok = true;
+	try{
+		ok = this.loadUri(uri, cb);
+	}catch(e){
+		dojo.debug(&quot;failed loading &quot;, uri, &quot; with error: &quot;, e);
+	}
+	return ((ok)&amp;&amp;(this.findModule(module, false))) ? true : false;
+}
+
+dojo.loaded = function(){ }
+dojo.unloaded = function(){ }
+
+dojo.hostenv.loaded = function(){
+	this.loadNotifying = true;
+	this.post_load_ = true;
+	var mll = this.modulesLoadedListeners;
+	for(var x=0; x&lt;mll.length; x++){
+		mll[x]();
+	}
+
+	//Clear listeners so new ones can be added
+	//For other xdomain package loads after the initial load.
+	this.modulesLoadedListeners = [];
+	this.loadNotifying = false;
+
+	dojo.loaded();
+}
+
+dojo.hostenv.unloaded = function(){
+	var mll = this.unloadListeners;
+	while(mll.length){
+		(mll.pop())();
+	}
+	dojo.unloaded();
+}
+
+/*
+Call styles:
+	dojo.addOnLoad(functionPointer)
+	dojo.addOnLoad(object, &quot;functionName&quot;)
+*/
+dojo.addOnLoad = function(obj, fcnName) {
+	var dh = dojo.hostenv;
+	if(arguments.length == 1) {
+		dh.modulesLoadedListeners.push(obj);
+	} else if(arguments.length &gt; 1) {
+		dh.modulesLoadedListeners.push(function() {
+			obj[fcnName]();
+		});
+	}
+
+	//Added for xdomain loading. dojo.addOnLoad is used to
+	//indicate callbacks after doing some dojo.require() statements.
+	//In the xdomain case, if all the requires are loaded (after initial
+	//page load), then immediately call any listeners.
+	if(dh.post_load_ &amp;&amp; dh.inFlightCount == 0 &amp;&amp; !dh.loadNotifying){
+		dh.callLoaded();
+	}
+}
+
+dojo.addOnUnload = function(obj, fcnName){
+	var dh = dojo.hostenv;
+	if(arguments.length == 1){
+		dh.unloadListeners.push(obj);
+	} else if(arguments.length &gt; 1) {
+		dh.unloadListeners.push(function() {
+			obj[fcnName]();
+		});
+	}
+}
+
+dojo.hostenv.modulesLoaded = function(){
+	if(this.post_load_){ return; }
+	if((this.loadUriStack.length==0)&amp;&amp;(this.getTextStack.length==0)){
+		if(this.inFlightCount &gt; 0){ 
+			dojo.debug(&quot;files still in flight!&quot;);
+			return;
+		}
+		dojo.hostenv.callLoaded();
+	}
+}
+
+dojo.hostenv.callLoaded = function(){
+	if(typeof setTimeout == &quot;object&quot;){
+		setTimeout(&quot;dojo.hostenv.loaded();&quot;, 0);
+	}else{
+		dojo.hostenv.loaded();
+	}
+}
+
+dojo.hostenv.getModuleSymbols = function(modulename) {
+	var syms = modulename.split(&quot;.&quot;);
+	for(var i = syms.length - 1; i &gt; 0; i--){
+		var parentModule = syms.slice(0, i).join(&quot;.&quot;);
+		var parentModulePath = this.getModulePrefix(parentModule);
+		if(parentModulePath != parentModule){
+			syms.splice(0, i, parentModulePath);
+			break;
+		}
+	}
+	return syms;
+}
+
+/**
+* loadModule(&quot;A.B&quot;) first checks to see if symbol A.B is defined. 
+* If it is, it is simply returned (nothing to do).
+*
+* If it is not defined, it will look for &quot;A/B.js&quot; in the script root directory,
+* followed by &quot;A.js&quot;.
+*
+* It throws if it cannot find a file to load, or if the symbol A.B is not
+* defined after loading.
+*
+* It returns the object A.B.
+*
+* This does nothing about importing symbols into the current package.
+* It is presumed that the caller will take care of that. For example, to import
+* all symbols:
+*
+*    with (dojo.hostenv.loadModule(&quot;A.B&quot;)) {
+*       ...
+*    }
+*
+* And to import just the leaf symbol:
+*
+*    var B = dojo.hostenv.loadModule(&quot;A.B&quot;);
+*    ...
+*
+* dj_load is an alias for dojo.hostenv.loadModule
+*/
+dojo.hostenv._global_omit_module_check = false;
+dojo.hostenv.loadModule = function(modulename, exact_only, omit_module_check){
+	if(!modulename){ return; }
+	omit_module_check = this._global_omit_module_check || omit_module_check;
+	var module = this.findModule(modulename, false);
+	if(module){
+		return module;
+	}
+
+	// protect against infinite recursion from mutual dependencies
+	if(dj_undef(modulename, this.loading_modules_)){
+		this.addedToLoadingCount.push(modulename);
+	}
+	this.loading_modules_[modulename] = 1;
+
+	// convert periods to slashes
+	var relpath = modulename.replace(/\./g, '/') + '.js';
+
+	var syms = this.getModuleSymbols(modulename);
+	var startedRelative = ((syms[0].charAt(0) != '/')&amp;&amp;(!syms[0].match(/^\w+:/)));
+	var last = syms[syms.length - 1];
+	// figure out if we're looking for a full package, if so, we want to do
+	// things slightly diffrently
+	var nsyms = modulename.split(&quot;.&quot;);
+	if(last==&quot;*&quot;){
+		modulename = (nsyms.slice(0, -1)).join('.');
+
+		while(syms.length){
+			syms.pop();
+			syms.push(this.pkgFileName);
+			relpath = syms.join(&quot;/&quot;) + '.js';
+			if(startedRelative &amp;&amp; (relpath.charAt(0)==&quot;/&quot;)){
+				relpath = relpath.slice(1);
+			}
+			ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+			if(ok){ break; }
+			syms.pop();
+		}
+	}else{
+		relpath = syms.join(&quot;/&quot;) + '.js';
+		modulename = nsyms.join('.');
+		var ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+		if((!ok)&amp;&amp;(!exact_only)){
+			syms.pop();
+			while(syms.length){
+				relpath = syms.join('/') + '.js';
+				ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+				if(ok){ break; }
+				syms.pop();
+				relpath = syms.join('/') + '/'+this.pkgFileName+'.js';
+				if(startedRelative &amp;&amp; (relpath.charAt(0)==&quot;/&quot;)){
+					relpath = relpath.slice(1);
+				}
+				ok = this.loadPath(relpath, ((!omit_module_check) ? modulename : null));
+				if(ok){ break; }
+			}
+		}
+
+		if((!ok)&amp;&amp;(!omit_module_check)){
+			dojo.raise(&quot;Could not load '&quot; + modulename + &quot;'; last tried '&quot; + relpath + &quot;'&quot;);
+		}
+	}
+
+	// check that the symbol was defined
+	//Don't bother if we're doing xdomain (asynchronous) loading.
+	if(!omit_module_check &amp;&amp; !this[&quot;isXDomain&quot;]){
+		// pass in false so we can give better error
+		module = this.findModule(modulename, false);
+		if(!module){
+			dojo.raise(&quot;symbol '&quot; + modulename + &quot;' is not defined after loading '&quot; + relpath + &quot;'&quot;); 
+		}
+	}
+
+	return module;
+}
+
+/**
+* startPackage(&quot;A.B&quot;) follows the path, and at each level creates a new empty
+* object or uses what already exists. It returns the result.
+*/
+dojo.hostenv.startPackage = function(packname){
+	var modref = dojo.evalObjPath((packname.split(&quot;.&quot;).slice(0, -1)).join('.'));
+	this.loaded_modules_[(new String(packname)).toLowerCase()] = modref;
+
+	var syms = packname.split(/\./);
+	if(syms[syms.length-1]==&quot;*&quot;){
+		syms.pop();
+	}
+	return dojo.evalObjPath(syms.join(&quot;.&quot;), true);
+}
+
+/**
+ * findModule(&quot;A.B&quot;) returns the object A.B if it exists, otherwise null.
+ * @param modulename A string like 'A.B'.
+ * @param must_exist Optional, defualt false. throw instead of returning null
+ * if the module does not currently exist.
+ */
+dojo.hostenv.findModule = function(modulename, must_exist){
+	// check cache
+	/*
+	if(!dj_undef(modulename, this.modules_)){
+		return this.modules_[modulename];
+	}
+	*/
+
+	var lmn = (new String(modulename)).toLowerCase();
+
+	if(this.loaded_modules_[lmn]){
+		return this.loaded_modules_[lmn];
+	}
+
+	// see if symbol is defined anyway
+	var module = dojo.evalObjPath(modulename);
+	if((modulename)&amp;&amp;(typeof module != 'undefined')&amp;&amp;(module)){
+		this.loaded_modules_[lmn] = module;
+		return module;
+	}
+
+	if(must_exist){
+		dojo.raise(&quot;no loaded module named '&quot; + modulename + &quot;'&quot;);
+	}
+	return null;
+}
+
+//Start of old bootstrap2:
+
+/*
+ * This method taks a &quot;map&quot; of arrays which one can use to optionally load dojo
+ * modules. The map is indexed by the possible dojo.hostenv.name_ values, with
+ * two additional values: &quot;default&quot; and &quot;common&quot;. The items in the &quot;default&quot;
+ * array will be loaded if none of the other items have been choosen based on
+ * the hostenv.name_ item. The items in the &quot;common&quot; array will _always_ be
+ * loaded, regardless of which list is chosen.  Here's how it's normally
+ * called:
+ *
+ *	dojo.kwCompoundRequire({
+ *		browser: [
+ *			[&quot;foo.bar.baz&quot;, true, true], // an example that passes multiple args to loadModule()
+ *			&quot;foo.sample.*&quot;,
+ *			&quot;foo.test,
+ *		],
+ *		default: [ &quot;foo.sample.*&quot; ],
+ *		common: [ &quot;really.important.module.*&quot; ]
+ *	});
+ */
+dojo.kwCompoundRequire = function(modMap){
+	var common = modMap[&quot;common&quot;]||[];
+	var result = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap[&quot;default&quot;]||[]);
+
+	for(var x=0; x&lt;result.length; x++){
+		var curr = result[x];
+		if(curr.constructor == Array){
+			dojo.hostenv.loadModule.apply(dojo.hostenv, curr);
+		}else{
+			dojo.hostenv.loadModule(curr);
+		}
+	}
+}
+
+dojo.require = function(){
+	dojo.hostenv.loadModule.apply(dojo.hostenv, arguments);
+}
+
+dojo.requireIf = function(){
+	if((arguments[0] === true)||(arguments[0]==&quot;common&quot;)||(arguments[0] &amp;&amp; dojo.render[arguments[0]].capable)){
+		var args = [];
+		for (var i = 1; i &lt; arguments.length; i++) { args.push(arguments[i]); }
+		dojo.require.apply(dojo, args);
+	}
+}
+
+dojo.requireAfterIf = dojo.requireIf;
+
+dojo.provide = function(){
+	return dojo.hostenv.startPackage.apply(dojo.hostenv, arguments);
+}
+
+dojo.setModulePrefix = function(module, prefix){
+	return dojo.hostenv.setModulePrefix(module, prefix);
+}
+
+// determine if an object supports a given method
+// useful for longer api chains where you have to test each object in the chain
+dojo.exists = function(obj, name){
+	var p = name.split(&quot;.&quot;);
+	for(var i = 0; i &lt; p.length; i++){
+	if(!(obj[p[i]])) return false;
+		obj = obj[p[i]];
+	}
+	return true;
+}

Added: trunk/root/static/magic/src/loader_xd.js
===================================================================
--- trunk/root/static/magic/src/loader_xd.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/loader_xd.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,414 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+//Cross-domain package loader.
+
+//FIXME: How will xd loading work with debugAtAllCosts? Any bad interactions?
+//FIXME: widgets won't work fully (HTML/CSS) and also because of the requireIf() thing.
+
+dojo.hostenv.resetXd = function(){
+	//This flag indicates where or not we have crossed into xdomain territory. Once any package says
+	//it is cross domain, then the rest of the packages have to be treated as xdomain because we need
+	//to evaluate packages in order. If there is a xdomain package followed by a xhr package, we can't load
+	//the xhr package until the one before it finishes loading. The text of the xhr package will be converted
+	//to match the format for a xd package and put in the xd load queue.
+	//You can force all packages to be treated as xd by setting the djConfig.forceXDomain.
+	this.isXDomain = djConfig.forceXDomain || false;
+
+	this.xdTimer = 0;
+	this.xdInFlight = {};
+	this.xdOrderedReqs = [];
+	this.xdDepMap = {};
+	this.xdContents = [];
+}
+
+//Call reset immediately to set the state.
+dojo.hostenv.resetXd();
+
+dojo.hostenv.createXdPackage = function(contents){
+	//Find dependencies.
+	var deps = [];
+    var depRegExp = /dojo.(require|requireIf|requireAll|provide|requireAfterIf|requireAfter|kwCompoundRequire|conditionalRequire|hostenv\.conditionalLoadModule|.hostenv\.loadModule|hostenv\.moduleLoaded)\(([\w\W]*?)\)/mg;
+    var match;
+	while((match = depRegExp.exec(contents)) != null){
+		deps.push(&quot;\&quot;&quot; + match[1] + &quot;\&quot;, &quot; + match[2]);
+	}
+
+	//Create package object and the call to packageLoaded.
+	var output = [];
+	output.push(&quot;dojo.hostenv.packageLoaded({\n&quot;);
+
+	//Add dependencies
+	if(deps.length &gt; 0){
+		output.push(&quot;depends: [&quot;);
+		for(var i = 0; i &lt; deps.length; i++){
+			if(i &gt; 0){
+				output.push(&quot;,\n&quot;);
+			}
+			output.push(&quot;[&quot; + deps[i] + &quot;]&quot;);
+		}
+		output.push(&quot;],&quot;);
+	}
+
+	//Add the contents of the file inside a function.
+	//Pass in dojo as an argument to the function to help with
+	//allowing multiple versions of dojo in a page.
+	output.push(&quot;\ndefinePackage: function(dojo){&quot;);
+	output.push(contents);
+	output.push(&quot;\n}});&quot;);
+	
+	return output.join(&quot;&quot;);
+}
+
+dojo.hostenv.loadPath = function(relpath, module /*optional*/, cb /*optional*/){
+	//Only do getBaseScriptUri if path does not start with a URL with a protocol.
+	//If there is a colon before the first / then, we have a URL with a protocol.
+	var colonIndex = relpath.indexOf(&quot;:&quot;);
+	var slashIndex = relpath.indexOf(&quot;/&quot;);
+	var uri;
+	var currentIsXDomain = false;
+	if(colonIndex &gt; 0 &amp;&amp; colonIndex &lt; slashIndex){
+		uri = relpath;
+		this.isXDomain = currentIsXDomain = true;
+	}else{
+		uri = this.getBaseScriptUri() + relpath;
+
+		//Is ithe base script URI-based URL a cross domain URL?
+		colonIndex = uri.indexOf(&quot;:&quot;);
+		slashIndex = uri.indexOf(&quot;/&quot;);
+		if(colonIndex &gt; 0 &amp;&amp; colonIndex &lt; slashIndex &amp;&amp; (!location.host || uri.indexOf(&quot;<A HREF="http://">http://</A>&quot; + location.host) != 0)){
+			this.isXDomain = currentIsXDomain = true;
+		}
+	}
+
+	if(djConfig.cacheBust &amp;&amp; dojo.render.html.capable) { uri += &quot;?&quot; + String(djConfig.cacheBust).replace(/\W+/g,&quot;&quot;); }
+	try{
+		return ((!module || this.isXDomain) ? this.loadUri(uri, cb, currentIsXDomain, module) : this.loadUriAndCheck(uri, module, cb));
+	}catch(e){
+		dojo.debug(e);
+		return false;
+	}
+}
+
+//Overriding loadUri for now. Wanted to override getText(), but it is used by
+//the widget code in too many, synchronous ways right now. This means the xd stuff
+//is not suitable for widgets yet.
+dojo.hostenv.loadUri = function(uri, cb, currentIsXDomain, module){
+	if(this.loadedUris[uri]){
+		return 1;
+	}
+
+	//Add the module (package) to the list of modules.
+	if(this.isXDomain){
+		//Curious: is this array going to get whacked with multiple access since scripts
+		//load asynchronously and may be accessing the array at the same time?
+		//JS is single-threaded supposedly, so it should be ok. And we don't need
+		//a precise ordering.
+		this.xdOrderedReqs.push(module);
+
+		//Add to waiting packages.
+		//If this is a __package__.js file, then this must be
+		//a package.* request (since xdomain can only work with the first
+		//path in a package search list. However, .* module names are not
+		//passed to this function, so do an adjustment here.
+		if(uri.indexOf(&quot;__package__&quot;) != -1){
+			module += &quot;.*&quot;;
+		}
+
+		this.xdInFlight[module] = true;
+
+		//Increment inFlightCount
+		//This will stop the modulesLoaded from firing all the way.
+		this.inFlightCount++;
+				
+		//Start timer
+		if(!this.xdTimer){
+			this.xdTimer = setInterval(&quot;dojo.hostenv.watchInFlightXDomain();&quot;, 100);
+		}
+		this.xdStartTime = (new Date()).getTime();
+	}
+
+	if (currentIsXDomain){
+		//Fix name to be a .xd.fileextension name.
+		var lastIndex = uri.lastIndexOf('.');
+		if(lastIndex &lt;= 0){
+			lastIndex = uri.length - 1;
+		}
+
+		var xdUri = uri.substring(0, lastIndex) + &quot;.xd&quot;;
+		if(lastIndex != uri.length - 1){
+			xdUri += uri.substring(lastIndex, uri.length);
+		}
+
+		//Add to script src
+		var element = document.createElement(&quot;script&quot;);
+		element.type = &quot;text/javascript&quot;;
+		element.src = xdUri;
+		if(!this.headElement){
+			this.headElement = document.getElementsByTagName(&quot;head&quot;)[0];
+		}
+		this.headElement.appendChild(element);
+	}else{
+		var contents = this.getText(uri, null, true);
+		if(contents == null){ return 0; }
+		
+		if(this.isXDomain){
+			var pkg = this.createXdPackage(contents);
+			dj_eval(pkg);
+		}else{
+			if(cb){ contents = '('+contents+')'; }
+			var value = dj_eval(contents);
+			if(cb){
+				cb(value);
+			}
+		}
+	}
+
+	//These steps are done in the non-xd loader version of this function.
+	//Maintain these steps to fit in with the existing system.
+	this.loadedUris[uri] = true;
+	return 1;
+}
+
+dojo.hostenv.packageLoaded = function(pkg){
+	var deps = pkg.depends;
+	var requireList = null;
+	var requireAfterList = null;
+	var provideList = [];
+	if(deps &amp;&amp; deps.length &gt; 0){
+		var dep = null;
+		var insertHint = 0;
+		var attachedPackage = false;
+		for(var i = 0; i &lt; deps.length; i++){
+			dep = deps[i];
+
+			//Look for specific dependency indicators.
+			if (dep[0] == &quot;provide&quot; || dep[0] == &quot;hostenv.moduleLoaded&quot;){
+				provideList.push(dep[1]);
+			}else{
+				if(!requireList){
+					requireList = [];
+				}
+				if(!requireAfterList){
+					requireAfterList = [];
+				}
+
+				var unpackedDeps = this.unpackXdDependency(dep);
+				if(unpackedDeps.requires){
+					requireList = requireList.concat(unpackedDeps.requires);
+				}
+				if(unpackedDeps.requiresAfter){
+					requireAfterList = requireAfterList.concat(unpackedDeps.requiresAfter);
+				}
+			}
+
+			//Call the dependency indicator to allow for the normal dojo setup.
+			//Only allow for one dot reference, for the hostenv.* type calls.
+			var depType = dep[0];
+			var objPath = depType.split(&quot;.&quot;);
+			if(objPath.length == 2){
+				dojo[objPath[0]][objPath[1]].apply(dojo[objPath[0]], dep.slice(1));
+			}else{
+				dojo[depType].apply(dojo, dep.slice(1));
+			}
+		}
+
+		//Save off the package contents for definition later.
+		var contentIndex = this.xdContents.push({content: pkg.definePackage, isDefined: false}) - 1;
+
+		//Add provide/requires to dependency map.
+		for(var i = 0; i &lt; provideList.length; i++){
+			this.xdDepMap[provideList[i]] = { requires: requireList, requiresAfter: requireAfterList, contentIndex: contentIndex };
+		}
+
+		//Now update the inflight status for any provided packages in this loaded package.
+		//Do this at the very end (in a *separate* for loop) to avoid shutting down the 
+		//inflight timer check too soon.
+		for(var i = 0; i &lt; provideList.length; i++){
+			this.xdInFlight[provideList[i]] = false;
+		}
+	}
+}
+
+//This is a bit brittle: it has to know about the dojo methods that deal with dependencies
+//It would be ideal to intercept the actual methods and do something fancy at that point,
+//but I have concern about knowing which provide to match to the dependency in that case,
+//since scripts can load whenever they want, and trigger new calls to dojo.hostenv.packageLoaded().
+dojo.hostenv.unpackXdDependency = function(dep){
+	//Extract the dependency(ies).
+	var newDeps = null;
+	var newAfterDeps = null;
+	switch(dep[0]){
+		case &quot;requireIf&quot;:
+		case &quot;requireAfterIf&quot;:
+		case &quot;conditionalRequire&quot;:
+			//First arg (dep[1]) is the test. Depedency is dep[2].
+			if((dep[1] === true)||(dep[1]==&quot;common&quot;)||(dep[1] &amp;&amp; dojo.render[dep[1]].capable)){
+				newDeps = [{name: dep[2], content: null}];
+			}
+			break;
+		case &quot;requireAll&quot;:
+			//the arguments are an array, each element a call to require.
+			//Get rid of first item, which is &quot;requireAll&quot;.
+			dep.shift();
+			newDeps = dep;
+			dojo.hostenv.flattenRequireArray(newDeps);
+			break;
+		case &quot;kwCompoundRequire&quot;:
+		case &quot;hostenv.conditionalLoadModule&quot;:
+			var modMap = dep[1];
+			var common = modMap[&quot;common&quot;]||[];
+			var newDeps = (modMap[dojo.hostenv.name_]) ? common.concat(modMap[dojo.hostenv.name_]||[]) : common.concat(modMap[&quot;default&quot;]||[]);	
+			dojo.hostenv.flattenRequireArray(newDeps);
+			break;
+		case &quot;require&quot;:
+		case &quot;requireAfter&quot;:
+		case &quot;hostenv.loadModule&quot;:
+			//Just worry about dep[1]
+			newDeps = [{name: dep[1], content: null}];
+			break;
+	}
+
+	//The requireAfterIf or requireAfter needs to be evaluated after the current package is evaluated.
+	if(dep[0] == &quot;requireAfterIf&quot;){
+		newAfterDeps = newDeps;
+		newDeps = null;
+	}
+	return {requires: newDeps, requiresAfter: newAfterDeps};
+}
+
+//Walks the requires and evaluates package contents in
+//the right order.
+dojo.hostenv.xdWalkReqs = function(){
+	var reqChain = null;
+	var req;
+	for(var i = 0; i &lt; this.xdOrderedReqs.length; i++){
+		req = this.xdOrderedReqs[i];
+		if(this.xdDepMap[req]){
+			reqChain = [req];
+			reqChain[req] = true; //Allow for fast lookup of the req in the array
+			this.xdEvalReqs(reqChain);
+		}
+	}
+}
+
+//Trace down any requires.
+dojo.hostenv.xdTraceReqs = function(reqs, reqChain){
+	if(reqs &amp;&amp; reqs.length &gt; 0){
+		var nextReq;
+		for(var i = 0; i &lt; reqs.length; i++){
+			nextReq = reqs[i].name;
+			if(nextReq &amp;&amp; !reqChain[nextReq]){
+				//New req depedency. Follow it down.
+				reqChain.push(nextReq);
+				reqChain[nextReq] = true;
+				this.xdEvalReqs(reqChain);
+			}
+		}
+	}
+}
+
+//Do a depth first, breadth second search and eval or reqs.
+dojo.hostenv.xdEvalReqs = function(reqChain){
+	if(reqChain.length &gt; 0){
+		var req = reqChain[reqChain.length - 1];
+		var pkg = this.xdDepMap[req];
+		if(pkg){
+			//Trace down any requires for this package.
+			this.xdTraceReqs(pkg.requires, reqChain);
+
+			//Evaluate the package.
+			var contents = this.xdContents[pkg.contentIndex];
+			if(!contents.isDefined){
+				//Evaluate the package to bring it into being.
+				//Pass dojo in so that later, to support multiple versions of dojo
+				//in a page, we can pass which version of dojo to use.
+				contents.content(dojo);
+				contents.isDefined = true;
+			}
+			this.xdDepMap[req] = null;
+
+			//Trace down any requireAfters for this package..
+			this.xdTraceReqs(pkg.requiresAfter, reqChain);
+		}
+
+		//Done with that require. Remove it and go to the next one.
+		reqChain.pop();
+		this.xdEvalReqs(reqChain);
+	}
+}
+
+dojo.hostenv.clearXdInterval = function(){
+	clearInterval(this.xdTimer);
+	this.xdTimer = 0;
+}
+
+dojo.hostenv.watchInFlightXDomain = function(){
+	//Make sure we haven't waited timed out.
+	var waitInterval = (djConfig.xdWaitSeconds || 30) * 1000;
+
+	if(this.xdStartTime + waitInterval &lt; (new Date()).getTime()){
+		this.clearXdInterval();
+		var noLoads = &quot;&quot;;
+		for(var param in this.xdInFlight){
+			if(this.xdInFlight[param]){
+				noLoads += param + &quot; &quot;;
+			}
+		}
+		dojo.raise(&quot;Could not load cross-domain packages: &quot; + noLoads);
+	}
+
+	//If any are true, then still waiting.
+	//Come back later.	
+	for(var param in this.xdInFlight){
+		if(this.xdInFlight[param]){
+			return;
+		}
+	}
+
+	//All done loading. Clean up and notify that we are loaded.
+	this.clearXdInterval();
+
+	this.xdWalkReqs();
+
+	//Evaluate any packages that were not evaled before.
+	//This normally shouldn't happen with proper dojo.provide and dojo.require
+	//usage, but providing it just in case. Note that these may not be executed
+	//in the original order that the developer intended.
+	//Pass dojo in so that later, to support multiple versions of dojo
+	//in a page, we can pass which version of dojo to use.
+	for(var i = 0; i &lt; this.xdContents.length; i++){
+		var current = this.xdContents[i];
+		if(current.content &amp;&amp; !current.isDefined){
+			current.content(dojo);
+		}
+	}
+
+	//Clean up for the next round of xd loading.
+	this.resetXd();
+
+	//Clear inflight count so we will finally do finish work.
+	this.inFlightCount = 0; 
+	this.callLoaded();
+}
+
+dojo.hostenv.flattenRequireArray = function(target){
+	//Each result could be an array of 3 elements  (the 3 arguments to dojo.require).
+	//We only need the first one.
+	if(target){
+		for(var i = 0; i &lt; target.length; i++){
+			if(target[i] instanceof Array){
+				target[i] = {name: target[i][0], content: null};
+			}else{
+				target[i] = {name: target[i], content: null};
+			}
+		}
+	}
+}

Added: trunk/root/static/magic/src/logging/Logger.js
===================================================================
--- trunk/root/static/magic/src/logging/Logger.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/logging/Logger.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,408 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/*		This is the dojo logging facility, which is imported from nWidgets
+		(written by Alex Russell, CLA on file), which is patterned on the
+		Python logging module, which in turn has been heavily influenced by
+		log4j (execpt with some more pythonic choices, which we adopt as well).
+
+		While the dojo logging facilities do provide a set of familiar
+		interfaces, many of the details are changed to reflect the constraints
+		of the browser environment. Mainly, file and syslog-style logging
+		facilites are not provided, with HTTP POST and GET requests being the
+		only ways of getting data from the browser back to a server. Minimal
+		support for this (and XML serialization of logs) is provided, but may
+		not be of practical use in a deployment environment.
+
+		The Dojo logging classes are agnostic of any environment, and while
+		default loggers are provided for browser-based interpreter
+		environments, this file and the classes it define are explicitly
+		designed to be portable to command-line interpreters and other
+		ECMA-262v3 envrionments.
+
+	the logger needs to accomidate:
+		log &quot;levels&quot;
+		type identifiers
+		file?
+		message
+		tic/toc?
+
+	The logger should ALWAYS record:
+		time/date logged
+		message
+		type
+		level
+*/
+// TODO: conver documentation to javadoc style once we confirm that is our choice
+// TODO: define DTD for XML-formatted log messages
+// TODO: write XML Formatter class
+// TODO: write HTTP Handler which uses POST to send log lines/sections
+
+// Filename:	LogCore.js
+// Purpose:		a common logging infrastructure for dojo
+// Classes:		dojo.logging, dojo.logging.Logger, dojo.logging.Record, dojo.logging.LogFilter
+// Global Objects:	dojo.logging
+// Dependencies:	none
+
+dojo.provide(&quot;dojo.logging.Logger&quot;);
+dojo.provide(&quot;dojo.log&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+/*
+	A simple data structure class that stores information for and about
+	a logged event. Objects of this type are created automatically when
+	an event is logged and are the internal format in which information
+	about log events is kept.
+*/
+
+dojo.logging.Record = function(lvl, msg){
+	this.level = lvl;
+	this.message = msg;
+	this.time = new Date();
+	// FIXME: what other information can we receive/discover here?
+}
+
+// an empty parent (abstract) class which concrete filters should inherit from.
+dojo.logging.LogFilter = function(loggerChain){
+	this.passChain = loggerChain || &quot;&quot;;
+	this.filter = function(record){
+		// FIXME: need to figure out a way to enforce the loggerChain
+		// restriction
+		return true; // pass all records
+	}
+}
+
+dojo.logging.Logger = function(){
+	this.cutOffLevel = 0;
+	this.propagate = true;
+	this.parent = null;
+	// storage for dojo.logging.Record objects seen and accepted by this logger
+	this.data = [];
+	this.filters = [];
+	this.handlers = [];
+}
+
+dojo.lang.extend(dojo.logging.Logger, {
+	argsToArr: function(args){
+		// utility function, reproduced from __util__ here to remove dependency
+		var ret = [];
+		for(var x=0; x&lt;args.length; x++){
+			ret.push(args[x]);
+		}
+		return ret;
+	},
+
+	setLevel: function(lvl){
+		this.cutOffLevel = parseInt(lvl);
+	},
+
+	isEnabledFor: function(lvl){
+		return parseInt(lvl) &gt;= this.cutOffLevel;
+	},
+
+	getEffectiveLevel: function(){
+		if((this.cutOffLevel==0)&amp;&amp;(this.parent)){
+			return this.parent.getEffectiveLevel();
+		}
+		return this.cutOffLevel;
+	},
+
+	addFilter: function(flt){
+		this.filters.push(flt);
+		return this.filters.length-1;
+	},
+
+	removeFilterByIndex: function(fltIndex){
+		if(this.filters[fltIndex]){
+			delete this.filters[fltIndex];
+			return true;
+		}
+		return false;
+	},
+
+	removeFilter: function(fltRef){
+		for(var x=0; x&lt;this.filters.length; x++){
+			if(this.filters[x]===fltRef){
+				delete this.filters[x];
+				return true;
+			}
+		}
+		return false;
+	},
+
+	removeAllFilters: function(){
+		this.filters = []; // clobber all of them
+	},
+
+	filter: function(rec){
+		for(var x=0; x&lt;this.filters.length; x++){
+			if((this.filters[x][&quot;filter&quot;])&amp;&amp;
+			   (!this.filters[x].filter(rec))||
+			   (rec.level&lt;this.cutOffLevel)){
+				return false;
+			}
+		}
+		return true;
+	},
+
+	addHandler: function(hdlr){
+		this.handlers.push(hdlr);
+		return this.handlers.length-1;
+	},
+
+	handle: function(rec){
+		if((!this.filter(rec))||(rec.level&lt;this.cutOffLevel)){ return false; }
+		for(var x=0; x&lt;this.handlers.length; x++){
+			if(this.handlers[x][&quot;handle&quot;]){
+			   this.handlers[x].handle(rec);
+			}
+		}
+		// FIXME: not sure what to do about records to be propagated that may have
+		// been modified by the handlers or the filters at this logger. Should
+		// parents always have pristine copies? or is passing the modified record
+		// OK?
+		// if((this.propagate)&amp;&amp;(this.parent)){ this.parent.handle(rec); }
+		return true;
+	},
+
+	// the heart and soul of the logging system
+	log: function(lvl, msg){
+		if(	(this.propagate)&amp;&amp;(this.parent)&amp;&amp;
+			(this.parent.rec.level&gt;=this.cutOffLevel)){
+			this.parent.log(lvl, msg);
+			return false;
+		}
+		// FIXME: need to call logging providers here!
+		this.handle(new dojo.logging.Record(lvl, msg));
+		return true;
+	},
+
+	// logger helpers
+	debug:function(msg){
+		return this.logType(&quot;DEBUG&quot;, this.argsToArr(arguments));
+	},
+
+	info: function(msg){
+		return this.logType(&quot;INFO&quot;, this.argsToArr(arguments));
+	},
+
+	warning: function(msg){
+		return this.logType(&quot;WARNING&quot;, this.argsToArr(arguments));
+	},
+
+	error: function(msg){
+		return this.logType(&quot;ERROR&quot;, this.argsToArr(arguments));
+	},
+
+	critical: function(msg){
+		return this.logType(&quot;CRITICAL&quot;, this.argsToArr(arguments));
+	},
+
+	exception: function(msg, e, squelch){
+		// FIXME: this needs to be modified to put the exception in the msg
+		// if we're on Moz, we can get the following from the exception object:
+		//		lineNumber
+		//		message
+		//		fileName
+		//		stack
+		//		name
+		// on IE, we get:
+		//		name
+		//		message (from MDA?)
+		//		number
+		//		description (same as message!)
+		if(e){
+			var eparts = [e.name, (e.description||e.message)];
+			if(e.fileName){
+				eparts.push(e.fileName);
+				eparts.push(&quot;line &quot;+e.lineNumber);
+				// eparts.push(e.stack);
+			}
+			msg += &quot; &quot;+eparts.join(&quot; : &quot;);
+		}
+
+		this.logType(&quot;ERROR&quot;, msg);
+		if(!squelch){
+			throw e;
+		}
+	},
+
+	logType: function(type, args){
+		var na = [dojo.logging.log.getLevel(type)];
+		if(typeof args == &quot;array&quot;){
+			na = na.concat(args);
+		}else if((typeof args == &quot;object&quot;)&amp;&amp;(args[&quot;length&quot;])){
+			na = na.concat(this.argsToArr(args));
+			/* for(var x=0; x&lt;args.length; x++){
+				na.push(args[x]);
+			} */
+		}else{
+			na = na.concat(this.argsToArr(arguments).slice(1));
+			/* for(var x=1; x&lt;arguments.length; x++){
+				na.push(arguments[x]);
+			} */
+		}
+		return this.log.apply(this, na);
+	}
+});
+
+void(function(){
+	var ptype = dojo.logging.Logger.prototype;
+	ptype.warn = ptype.warning;
+	ptype.err = ptype.error;
+	ptype.crit = ptype.critical;
+})();
+
+// the Handler class
+dojo.logging.LogHandler = function(level){
+	this.cutOffLevel = (level) ? level : 0;
+	this.formatter = null; // FIXME: default formatter?
+	this.data = [];
+	this.filters = [];
+}
+
+dojo.logging.LogHandler.prototype.setFormatter = function(fmtr){
+	// FIXME: need to vet that it is indeed a formatter object
+	dojo.unimplemented(&quot;setFormatter&quot;);
+}
+
+dojo.logging.LogHandler.prototype.flush = function(){
+	dojo.unimplemented(&quot;flush&quot;);
+}
+
+dojo.logging.LogHandler.prototype.close = function(){
+	dojo.unimplemented(&quot;close&quot;);
+}
+
+dojo.logging.LogHandler.prototype.handleError = function(){
+	dojo.unimplemented(&quot;handleError&quot;);
+}
+
+dojo.logging.LogHandler.prototype.handle = function(record){
+	// emits the passed record if it passes this object's filters
+	if((this.filter(record))&amp;&amp;(record.level&gt;=this.cutOffLevel)){
+		this.emit(record);
+	}
+}
+
+dojo.logging.LogHandler.prototype.emit = function(record){
+	// do whatever is necessaray to actually log the record
+	dojo.unimplemented(&quot;emit&quot;);
+}
+
+// set aliases since we don't want to inherit from dojo.logging.Logger
+void(function(){ // begin globals protection closure
+	var names = [
+		&quot;setLevel&quot;, &quot;addFilter&quot;, &quot;removeFilterByIndex&quot;, &quot;removeFilter&quot;,
+		&quot;removeAllFilters&quot;, &quot;filter&quot;
+	];
+	var tgt = dojo.logging.LogHandler.prototype;
+	var src = dojo.logging.Logger.prototype;
+	for(var x=0; x&lt;names.length; x++){
+		tgt[names[x]] = src[names[x]];
+	}
+})(); // end globals protection closure
+
+dojo.logging.log = new dojo.logging.Logger();
+
+// an associative array of logger objects. This object inherits from
+// a list of level names with their associated numeric levels
+dojo.logging.log.levels = [ {&quot;name&quot;: &quot;DEBUG&quot;, &quot;level&quot;: 1},
+						   {&quot;name&quot;: &quot;INFO&quot;, &quot;level&quot;: 2},
+						   {&quot;name&quot;: &quot;WARNING&quot;, &quot;level&quot;: 3},
+						   {&quot;name&quot;: &quot;ERROR&quot;, &quot;level&quot;: 4},
+						   {&quot;name&quot;: &quot;CRITICAL&quot;, &quot;level&quot;: 5} ];
+
+dojo.logging.log.loggers = {};
+
+dojo.logging.log.getLogger = function(name){
+	if(!this.loggers[name]){
+		this.loggers[name] = new dojo.logging.Logger();
+		this.loggers[name].parent = this;
+	}
+	return this.loggers[name];
+}
+
+dojo.logging.log.getLevelName = function(lvl){
+	for(var x=0; x&lt;this.levels.length; x++){
+		if(this.levels[x].level == lvl){
+			return this.levels[x].name;
+		}
+	}
+	return null;
+}
+
+dojo.logging.log.addLevelName = function(name, lvl){
+	if(this.getLevelName(name)){
+		this.err(&quot;could not add log level &quot;+name+&quot; because a level with that name already exists&quot;);
+		return false;
+	}
+	this.levels.append({&quot;name&quot;: name, &quot;level&quot;: parseInt(lvl)});
+	return true;
+}
+
+dojo.logging.log.getLevel = function(name){
+	for(var x=0; x&lt;this.levels.length; x++){
+		if(this.levels[x].name.toUpperCase() == name.toUpperCase()){
+			return this.levels[x].level;
+		}
+	}
+	return null;
+}
+
+// a default handler class, it simply saves all of the handle()'d records in
+// memory. Useful for attaching to with dojo.event.connect()
+dojo.logging.MemoryLogHandler = function(level, recordsToKeep, postType, postInterval){
+	// mixin style inheritance
+	dojo.logging.LogHandler.call(this, level);
+	// default is unlimited
+	this.numRecords = (typeof djConfig['loggingNumRecords'] != 'undefined') ? djConfig['loggingNumRecords'] : ((recordsToKeep) ? recordsToKeep : -1);
+	// 0=count, 1=time, -1=don't post TODO: move this to a better location for prefs
+	this.postType = (typeof djConfig['loggingPostType'] != 'undefined') ? djConfig['loggingPostType'] : ( postType || -1);
+	// milliseconds for time, interger for number of records, -1 for non-posting,
+	this.postInterval = (typeof djConfig['loggingPostInterval'] != 'undefined') ? djConfig['loggingPostInterval'] : ( postType || -1);
+	
+}
+// prototype inheritance
+dojo.logging.MemoryLogHandler.prototype = new dojo.logging.LogHandler();
+
+// FIXME
+// dojo.inherits(dojo.logging.MemoryLogHandler, 
+
+// over-ride base-class
+dojo.logging.MemoryLogHandler.prototype.emit = function(record){
+	this.data.push(record);
+	if(this.numRecords != -1){
+		while(this.data.length&gt;this.numRecords){
+			this.data.shift();
+		}
+	}
+}
+
+dojo.logging.logQueueHandler = new dojo.logging.MemoryLogHandler(0,50,0,10000);
+// actual logging event handler
+dojo.logging.logQueueHandler.emit = function(record){
+	// we should probably abstract this in the future
+	var logStr = String(dojo.log.getLevelName(record.level)+&quot;: &quot;+record.time.toLocaleTimeString())+&quot;: &quot;+record.message;
+	if(!dj_undef(&quot;debug&quot;, dj_global)){
+		dojo.debug(logStr);
+	}else if((typeof dj_global[&quot;print&quot;] == &quot;function&quot;)&amp;&amp;(!dojo.render.html.capable)){
+		print(logStr);
+	}
+	this.data.push(record);
+	if(this.numRecords != -1){
+		while(this.data.length&gt;this.numRecords){
+			this.data.shift();
+		}
+	}
+}
+
+dojo.logging.log.addHandler(dojo.logging.logQueueHandler);
+dojo.log = dojo.logging.log;

Added: trunk/root/static/magic/src/logging/__package__.js
===================================================================
--- trunk/root/static/magic/src/logging/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/logging/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.logging.Logger&quot;, false, false],
+	rhino: [&quot;dojo.logging.RhinoLogger&quot;]
+});
+dojo.provide(&quot;dojo.logging.*&quot;);

Added: trunk/root/static/magic/src/math/Math.js
===================================================================
--- trunk/root/static/magic/src/math/Math.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/math/Math.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.deprecated(&quot;dojo.math.Math&quot;, &quot;include dojo.math instead&quot;, &quot;0.4&quot;);
+dojo.require(&quot;dojo.math&quot;);

Added: trunk/root/static/magic/src/math/__package__.js
===================================================================
--- trunk/root/static/magic/src/math/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/math/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,18 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		[&quot;dojo.math&quot;, false, false],
+		[&quot;dojo.math.curves&quot;, false, false],
+		[&quot;dojo.math.points&quot;, false, false]
+	]
+});
+dojo.provide(&quot;dojo.math.*&quot;);

Added: trunk/root/static/magic/src/math/curves.js
===================================================================
--- trunk/root/static/magic/src/math/curves.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/math/curves.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,222 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.math.curves&quot;);
+
+dojo.require(&quot;dojo.math&quot;);
+
+/* Curves from Dan's 13th lib stuff.
+ * See: <A HREF="http://pupius.co.uk/js/Toolkit.Drawing.js">http://pupius.co.uk/js/Toolkit.Drawing.js</A>
+ *      <A HREF="http://pupius.co.uk/dump/dojo/Dojo.Math.js">http://pupius.co.uk/dump/dojo/Dojo.Math.js</A>
+ */
+
+dojo.math.curves = {
+	//Creates a straight line object
+	Line: function(start, end) {
+		this.start = start;
+		this.end = end;
+		this.dimensions = start.length;
+
+		for(var i = 0; i &lt; start.length; i++) {
+			start[i] = Number(start[i]);
+		}
+
+		for(var i = 0; i &lt; end.length; i++) {
+			end[i] = Number(end[i]);
+		}
+
+		//simple function to find point on an n-dimensional, straight line
+		this.getValue = function(n) {
+			var retVal = new Array(this.dimensions);
+			for(var i=0;i&lt;this.dimensions;i++)
+				retVal[i] = ((this.end[i] - this.start[i]) * n) + this.start[i];
+			return retVal;
+		}
+
+		return this;
+	},
+
+
+	//Takes an array of points, the first is the start point, the last is end point and the ones in
+	//between are the Bezier control points.
+	Bezier: function(pnts) {
+		this.getValue = function(step) {
+			if(step &gt;= 1) return this.p[this.p.length-1];	// if step&gt;=1 we must be at the end of the curve
+			if(step &lt;= 0) return this.p[0];					// if step&lt;=0 we must be at the start of the curve
+			var retVal = new Array(this.p[0].length);
+			for(var k=0;j&lt;this.p[0].length;k++) { retVal[k]=0; }
+			for(var j=0;j&lt;this.p[0].length;j++) {
+				var C=0; var D=0;
+				for(var i=0;i&lt;this.p.length;i++) {
+					C += this.p[i][j] * this.p[this.p.length-1][0]
+						* dojo.math.bernstein(step,this.p.length,i);
+				}
+				for(var l=0;l&lt;this.p.length;l++) {
+					D += this.p[this.p.length-1][0] * dojo.math.bernstein(step,this.p.length,l);
+				}
+				retVal[j] = C/D;
+			}
+			return retVal;
+		}
+		this.p = pnts;
+		return this;
+	},
+
+
+	//Catmull-Rom Spline - allows you to interpolate a smooth curve through a set of points in n-dimensional space
+	CatmullRom : function(pnts,c) {
+		this.getValue = function(step) {
+			var percent = step * (this.p.length-1);
+			var node = Math.floor(percent);
+			var progress = percent - node;
+
+			var i0 = node-1; if(i0 &lt; 0) i0 = 0;
+			var i = node;
+			var i1 = node+1; if(i1 &gt;= this.p.length) i1 = this.p.length-1;
+			var i2 = node+2; if(i2 &gt;= this.p.length) i2 = this.p.length-1;
+
+			var u = progress;
+			var u2 = progress*progress;
+			var u3 = progress*progress*progress;
+
+			var retVal = new Array(this.p[0].length);
+			for(var k=0;k&lt;this.p[0].length;k++) {
+				var x1 = ( -this.c * this.p[i0][k] ) + ( (2 - this.c) * this.p[i][k] ) + ( (this.c-2) * this.p[i1][k] ) + ( this.c * this.p[i2][k] );
+				var x2 = ( 2 * this.c * this.p[i0][k] ) + ( (this.c-3) * this.p[i][k] ) + ( (3 - 2 * this.c) * this.p[i1][k] ) + ( -this.c * this.p[i2][k] );
+				var x3 = ( -this.c * this.p[i0][k] ) + ( this.c * this.p[i1][k] );
+				var x4 = this.p[i][k];
+
+				retVal[k] = x1*u3 + x2*u2 + x3*u + x4;
+			}
+			return retVal;
+
+		}
+
+
+		if(!c) this.c = 0.7;
+		else this.c = c;
+		this.p = pnts;
+
+		return this;
+	},
+
+	// FIXME: This is the bad way to do a partial-arc with 2 points. We need to have the user
+	// supply the radius, otherwise we always get a half-circle between the two points.
+	Arc : function(start, end, ccw) {
+		var center = dojo.math.points.midpoint(start, end);
+		var sides = dojo.math.points.translate(dojo.math.points.invert(center), start);
+		var rad = Math.sqrt(Math.pow(sides[0], 2) + Math.pow(sides[1], 2));
+		var theta = dojo.math.radToDeg(Math.atan(sides[1]/sides[0]));
+		if( sides[0] &lt; 0 ) {
+			theta -= 90;
+		} else {
+			theta += 90;
+		}
+		dojo.math.curves.CenteredArc.call(this, center, rad, theta, theta+(ccw?-180:180));
+	},
+
+	// Creates an arc object, with center and radius (Top of arc = 0 degrees, increments clockwise)
+	//  center =&gt; 2D point for center of arc
+	//  radius =&gt; scalar quantity for radius of arc
+	//  start  =&gt; to define an arc specify start angle (default: 0)
+	//  end    =&gt; to define an arc specify start angle
+	CenteredArc : function(center, radius, start, end) {
+		this.center = center;
+		this.radius = radius;
+		this.start = start || 0;
+		this.end = end;
+
+		this.getValue = function(n) {
+			var retVal = new Array(2);
+			var theta = dojo.math.degToRad(this.start+((this.end-this.start)*n));
+
+			retVal[0] = this.center[0] + this.radius*Math.sin(theta);
+			retVal[1] = this.center[1] - this.radius*Math.cos(theta);
+
+			return retVal;
+		}
+
+		return this;
+	},
+
+	// Special case of Arc (start = 0, end = 360)
+	Circle : function(center, radius) {
+		dojo.math.curves.CenteredArc.call(this, center, radius, 0, 360);
+		return this;
+	},
+
+	Path : function() {
+		var curves = [];
+		var weights = [];
+		var ranges = [];
+		var totalWeight = 0;
+
+		this.add = function(curve, weight) {
+			if( weight &lt; 0 ) { dojo.raise(&quot;dojo.math.curves.Path.add: weight cannot be less than 0&quot;); }
+			curves.push(curve);
+			weights.push(weight);
+			totalWeight += weight;
+			computeRanges();
+		}
+
+		this.remove = function(curve) {
+			for(var i = 0; i &lt; curves.length; i++) {
+				if( curves[i] == curve ) {
+					curves.splice(i, 1);
+					totalWeight -= weights.splice(i, 1)[0];
+					break;
+				}
+			}
+			computeRanges();
+		}
+
+		this.removeAll = function() {
+			curves = [];
+			weights = [];
+			totalWeight = 0;
+		}
+
+		this.getValue = function(n) {
+			var found = false, value = 0;
+			for(var i = 0; i &lt; ranges.length; i++) {
+				var r = ranges[i];
+				//w(r.join(&quot; ... &quot;));
+				if( n &gt;= r[0] &amp;&amp; n &lt; r[1] ) {
+					var subN = (n - r[0]) / r[2];
+					value = curves[i].getValue(subN);
+					found = true;
+					break;
+				}
+			}
+
+			// FIXME: Do we want to assume we're at the end?
+			if( !found ) {
+				value = curves[curves.length-1].getValue(1);
+			}
+
+			for(var j = 0; j &lt; i; j++) {
+				value = dojo.math.points.translate(value, curves[j].getValue(1));
+			}
+			return value;
+		}
+
+		function computeRanges() {
+			var start = 0;
+			for(var i = 0; i &lt; weights.length; i++) {
+				var end = start + weights[i] / totalWeight;
+				var len = end - start;
+				ranges[i] = [start, end, len];
+				start = end;
+			}
+		}
+
+		return this;
+	}
+};

Added: trunk/root/static/magic/src/math/matrix.js
===================================================================
--- trunk/root/static/magic/src/math/matrix.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/math/matrix.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,305 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.math.matrix&quot;);
+
+//
+// some of this code is based on
+// <A HREF="http://www.mkaz.com/math/MatrixCalculator.java">http://www.mkaz.com/math/MatrixCalculator.java</A>
+// (published under a BSD Open Source License)
+//
+// the rest is from my vague memory of matricies in school [cal]
+//
+// the copying of arguments is a little excessive, and could be trimmed back in
+// the case where a function doesn't modify them at all (but some do!)
+//
+
+dojo.math.matrix.iDF = 0;
+
+dojo.math.matrix.multiply = function(a, b){
+
+	a = dojo.math.matrix.copy(a);
+	b = dojo.math.matrix.copy(b);
+
+	var ax = a[0].length;
+	var ay = a.length;
+	var bx = b[0].length;
+	var by = b.length;
+
+	if (ax != by){
+		dojo.debug(&quot;Can't multiply matricies of sizes &quot;+ax+','+ay+' and '+bx+','+by);
+		return [[0]];
+	}
+
+	var c = [];
+
+	for(var k=0; k&lt;ay; k++){
+		c[k] = [];
+		for(var i=0; i&lt;bx; i++){
+
+			c[k][i] = 0;
+
+			for(var m=0; m&lt;ax; m++){
+
+				c[k][i] += a[k][m]*b[m][i];
+			}
+		}
+	}
+
+	return c;
+}
+
+dojo.math.matrix.inverse = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
+	// Formula used to Calculate Inverse:
+	// inv(A) = 1/det(A) * adj(A)
+
+	var tms = a.length;
+
+	var m = dojo.math.matrix.create(tms, tms);
+	var mm = dojo.math.matrix.adjoint(a);
+
+	var det = dojo.math.matrix.determinant(a);
+	var dd = 0;
+
+	if (det == 0){
+		dojo.debug(&quot;Determinant Equals 0, Not Invertible.&quot;);
+		return [[0]];
+	}else{
+		dd = 1 / det;
+	}
+
+	for (var i = 0; i &lt; tms; i++)
+		for (var j = 0; j &lt; tms; j++) {
+			m[i][j] = dd * mm[i][j];
+		}
+
+	return m;
+}
+
+dojo.math.matrix.determinant = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
+	if (a.length != a[0].length){
+		dojo.debug(&quot;Can't calculate the determiant of a non-squre matrix!&quot;);
+		return 0;
+	}
+
+	var tms = a.length;
+	var det = 1;
+
+	var b = dojo.math.matrix.upperTriangle(a);
+
+	for (var i=0; i &lt; tms; i++){
+		det *= b[i][i];
+	}
+
+	det = det * dojo.math.matrix.iDF;
+
+	return det;
+}
+
+dojo.math.matrix.upperTriangle = function(m){
+
+	m = dojo.math.matrix.copy(m);
+
+	var f1 = 0;
+	var temp = 0;
+	var tms = m.length;
+	var v = 1;
+
+	dojo.math.matrix.iDF = 1;
+
+	for (var col = 0; col &lt; tms - 1; col++) {
+		for (var row = col + 1; row &lt; tms; row++) {
+			v = 1;
+
+			var stop_loop = 0;
+
+			// check if 0 in diagonal
+ 			while ((m[col][col] == 0) &amp;&amp; !stop_loop){
+
+				// if so switch until not
+				if (col + v &gt;= tms){
+
+					// check if switched all rows
+					dojo.math.matrix.iDF = 0;
+					stop_loop = 1;
+				}else{
+					for (var c = 0; c &lt; tms; c++) {
+						temp = m[col][c];
+						m[col][c] = m[col + v][c]; // switch rows
+						m[col + v][c] = temp;
+					}
+					v++; // count row switchs
+					dojo.math.matrix.iDF *= -1; // each switch changes determinant factor
+				}
+			}
+
+			if (m[col][col] != 0) {
+				f1 = (-1) * m[row][col] / m[col][col];
+				for (var i = col; i &lt; tms; i++) {
+					m[row][i] = f1 * m[col][i] + m[row][i];
+				}
+			}
+		}
+	}
+
+	return m;
+}
+
+dojo.math.matrix.create = function(a, b){
+	var m = [];
+	for(var i=0; i&lt;b; i++){
+		m[i] = [];
+		for(var j=0; j&lt;a; j++){
+			m[i][j] = 0;
+		}
+	}
+	return m;
+}
+
+dojo.math.matrix.adjoint = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
+	var tms = a.length;
+
+	if (a.length != a[0].length){
+		dojo.debug(&quot;Can't find the adjoint of a non-square matrix&quot;);
+		return [[0]];
+	}
+
+	if (tms == 1){
+		dojo.debug(&quot;Can't find the adjoint of a 1x1 matrix&quot;);
+		return [[0]];
+	}
+
+	var m = dojo.math.matrix.create(tms, tms);
+
+	var ii = 0;
+	var jj = 0;
+	var ia = 0;
+	var ja = 0;
+	var det = 0;
+
+	for (var i = 0; i &lt; tms; i++){
+		for (var j = 0; j &lt; tms; j++){
+
+			ia = 0;
+			ja = 0;
+
+			var ap = dojo.math.matrix.create(tms-1, tms-1);
+
+			for (ii = 0; ii &lt; tms; ii++) {
+				for (jj = 0; jj &lt; tms; jj++) {
+
+					if ((ii != i) &amp;&amp; (jj != j)) {
+						ap[ia][ja] = a[ii][jj];
+						ja++;
+					}
+
+				}
+
+				if ((ii != i) &amp;&amp; (jj != j)) {
+					ia++;
+				}
+				ja = 0;
+			}
+
+			det = dojo.math.matrix.determinant(ap);
+			m[i][j] = Math.pow(-1 , (i + j)) * det;
+		}
+	}
+
+	m = dojo.math.matrix.transpose(m);
+
+	return m;
+}
+
+dojo.math.matrix.transpose = function(a){
+
+	a = dojo.math.matrix.copy(a);
+
+	var m = dojo.math.matrix.create(a.length, a[0].length);
+
+	for (var i = 0; i &lt; a.length; i++)
+		for (var j = 0; j &lt; a[i].length; j++)
+			m[j][i] = a[i][j];
+	return m;
+}
+
+dojo.math.matrix.format = function(a){
+
+	function format_int(x){
+		var dp = 5;
+		var fac = Math.pow(10 , dp);
+		var a = Math.round(x*fac)/fac;
+		var b = a.toString();
+		if (b.charAt(0) != '-'){ b = ' ' + b;}
+		var has_dp = 0;
+		for(var i=1; i&lt;b.length; i++){
+			if (b.charAt(i) == '.'){ has_dp = 1; }
+		}
+		if (!has_dp){ b += '.'; }
+		while(b.length &lt; dp+3){ b += '0'; }
+		return b;
+	}
+
+	var ya = a.length;
+	var xa = a[0].length;
+
+	var buffer = '';
+
+	for (var y=0; y&lt;ya; y++){
+		buffer += '| ';
+		for (var x=0; x&lt;xa; x++){
+			buffer += format_int(a[y][x]) + ' ';
+		}
+		buffer += '|\n';
+	}
+
+	return buffer;
+}
+
+dojo.math.matrix.copy = function(a){
+
+	var ya = a.length;
+	var xa = a[0].length;
+
+	var m = dojo.math.matrix.create(xa, ya);
+
+	for (var y=0; y&lt;ya; y++){
+		for (var x=0; x&lt;xa; x++){
+			m[y][x] = a[y][x];
+		}
+	}
+
+	return m;
+}
+
+dojo.math.matrix.scale = function(k, a){
+
+	a = dojo.math.matrix.copy(a);
+
+	var ya = a.length;
+	var xa = a[0].length;
+
+	for (var y=0; y&lt;ya; y++){
+		for (var x=0; x&lt;xa; x++){
+			a[y][x] *= k;
+		}
+	}
+
+	return a;
+}

Added: trunk/root/static/magic/src/math/points.js
===================================================================
--- trunk/root/static/magic/src/math/points.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/math/points.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,47 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.math.points&quot;);
+dojo.require(&quot;dojo.math&quot;);
+
+// TODO: add a Point class?
+dojo.math.points = {
+	translate: function(a, b) {
+		if( a.length != b.length ) {
+			dojo.raise(&quot;dojo.math.translate: points not same size (a:[&quot; + a + &quot;], b:[&quot; + b + &quot;])&quot;);
+		}
+		var c = new Array(a.length);
+		for(var i = 0; i &lt; a.length; i++) {
+			c[i] = a[i] + b[i];
+		}
+		return c;
+	},
+
+	midpoint: function(a, b) {
+		if( a.length != b.length ) {
+			dojo.raise(&quot;dojo.math.midpoint: points not same size (a:[&quot; + a + &quot;], b:[&quot; + b + &quot;])&quot;);
+		}
+		var c = new Array(a.length);
+		for(var i = 0; i &lt; a.length; i++) {
+			c[i] = (a[i] + b[i]) / 2;
+		}
+		return c;
+	},
+
+	invert: function(a) {
+		var b = new Array(a.length);
+		for(var i = 0; i &lt; a.length; i++) { b[i] = -a[i]; }
+		return b;
+	},
+
+	distance: function(a, b) {
+		return Math.sqrt(Math.pow(b[0]-a[0], 2) + Math.pow(b[1]-a[1], 2));
+	}
+};

Added: trunk/root/static/magic/src/math.js
===================================================================
--- trunk/root/static/magic/src/math.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/math.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,134 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.math&quot;);
+
+dojo.math.degToRad = function (x) { return (x*Math.PI) / 180; }
+dojo.math.radToDeg = function (x) { return (x*180) / Math.PI; }
+
+dojo.math.factorial = function (n) {
+	if(n&lt;1){ return 0; }
+	var retVal = 1;
+	for(var i=1;i&lt;=n;i++){ retVal *= i; }
+	return retVal;
+}
+
+//The number of ways of obtaining an ordered subset of k elements from a set of n elements
+dojo.math.permutations = function (n,k) {
+	if(n==0 || k==0) return 1;
+	return (dojo.math.factorial(n) / dojo.math.factorial(n-k));
+}
+
+//The number of ways of picking n unordered outcomes from r possibilities
+dojo.math.combinations = function (n,r) {
+	if(n==0 || r==0) return 1;
+	return (dojo.math.factorial(n) / (dojo.math.factorial(n-r) * dojo.math.factorial(r)));
+}
+
+dojo.math.bernstein = function (t,n,i) {
+	return (dojo.math.combinations(n,i) * Math.pow(t,i) * Math.pow(1-t,n-i));
+}
+
+/**
+ * Returns random numbers with a Gaussian distribution, with the mean set at
+ * 0 and the variance set at 1.
+ *
+ * @return A random number from a Gaussian distribution
+ */
+dojo.math.gaussianRandom = function () {
+	var k = 2;
+	do {
+		var i = 2 * Math.random() - 1;
+		var j = 2 * Math.random() - 1;
+		k = i * i + j * j;
+	} while (k &gt;= 1);
+	k = Math.sqrt((-2 * Math.log(k)) / k);
+	return i * k;
+}
+
+/**
+ * Calculates the mean of an Array of numbers.
+ *
+ * @return The mean of the numbers in the Array
+ */
+dojo.math.mean = function () {
+	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
+	var mean = 0;
+	for (var i = 0; i &lt; array.length; i++) { mean += array[i]; }
+	return mean / array.length;
+}
+
+/**
+ * Extends Math.round by adding a second argument specifying the number of
+ * decimal places to round to.
+ *
+ * @param number The number to round
+ * @param places The number of decimal places to round to
+ * @return The rounded number
+ */
+// TODO: add support for significant figures
+dojo.math.round = function (number, places) {
+	if (!places) { var shift = 1; }
+	else { var shift = Math.pow(10, places); }
+	return Math.round(number * shift) / shift;
+}
+
+/**
+ * Calculates the standard deviation of an Array of numbers
+ *
+ * @return The standard deviation of the numbers
+ */
+dojo.math.sd = function () {
+	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
+	return Math.sqrt(dojo.math.variance(array));
+}
+
+/**
+ * Calculates the variance of an Array of numbers
+ *
+ * @return The variance of the numbers
+ */
+dojo.math.variance = function () {
+	var array = dojo.lang.isArray(arguments[0]) ? arguments[0] : arguments;
+	var mean = 0, squares = 0;
+	for (var i = 0; i &lt; array.length; i++) {
+		mean += array[i];
+		squares += Math.pow(array[i], 2);
+	}
+	return (squares / array.length)
+		- Math.pow(mean / array.length, 2);
+}
+
+/**
+ * Like range() in python
+**/
+dojo.math.range = function(a, b, step) {
+    if(arguments.length &lt; 2) {
+        b = a;
+        a = 0;
+    }
+    if(arguments.length &lt; 3) {
+        step = 1;
+    }
+
+    var range = [];
+    if(step &gt; 0) {
+        for(var i = a; i &lt; b; i += step) {
+            range.push(i);
+        }
+    } else if(step &lt; 0) {
+        for(var i = a; i &gt; b; i += step) {
+            range.push(i);
+        }
+    } else {
+        throw new Error(&quot;dojo.math.range: step must be non-zero&quot;);
+    }
+    return range;
+}

Added: trunk/root/static/magic/src/profile.js
===================================================================
--- trunk/root/static/magic/src/profile.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/profile.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,117 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.profile&quot;);
+
+dojo.profile = new function(){
+	var profiles = {};
+	var pns = [];
+
+	this.start = function(name){
+		if(!profiles[name]){
+			profiles[name] = {iters: 0, total: 0};
+			pns[pns.length] = name;
+		}else{
+			if(profiles[name][&quot;start&quot;]){
+				this.end(name);
+			}
+		}
+		profiles[name].end = null;
+		profiles[name].start = new Date();
+	}
+
+	this.end = function(name){
+		var ed = new Date();
+		if((profiles[name])&amp;&amp;(profiles[name][&quot;start&quot;])){
+			with(profiles[name]){
+				end = ed;
+				total += (end - start);
+				start = null;
+				iters++;
+			}
+		}else{
+			// oops! bad call to end(), what should we do here?
+			return true;
+		}
+	}
+
+	this.stop = this.end;
+
+	this.dump = function(appendToDoc){
+		var tbl = document.createElement(&quot;table&quot;);
+		with(tbl.style){
+			border = &quot;1px solid black&quot;;
+			borderCollapse = &quot;collapse&quot;;
+		}
+		var hdr = tbl.createTHead();
+		var hdrtr = hdr.insertRow(0);
+		// document.createElement(&quot;tr&quot;);
+		var cols = [&quot;Identifier&quot;,&quot;Calls&quot;,&quot;Total&quot;,&quot;Avg&quot;];
+		for(var x=0; x&lt;cols.length; x++){
+			var ntd = hdrtr.insertCell(x);
+			with(ntd.style){
+				backgroundColor = &quot;#225d94&quot;;
+				color = &quot;white&quot;;
+				borderBottom = &quot;1px solid black&quot;;
+				borderRight = &quot;1px solid black&quot;;
+				fontFamily = &quot;tahoma&quot;;
+				fontWeight = &quot;bolder&quot;;
+				paddingLeft = paddingRight = &quot;5px&quot;;
+			}
+			ntd.appendChild(document.createTextNode(cols[x]));
+		}
+
+		for(var x=0; x &lt; pns.length; x++){
+			var prf = profiles[pns[x]];
+			this.end(pns[x]);
+			if(prf.iters&gt;0){
+				var bdytr = tbl.insertRow(true);
+				var vals = [pns[x], prf.iters, prf.total, parseInt(prf.total/prf.iters)];
+				for(var y=0; y&lt;vals.length; y++){
+					var cc = bdytr.insertCell(y);
+					cc.appendChild(document.createTextNode(vals[y]));
+					with(cc.style){
+						borderBottom = &quot;1px solid gray&quot;;
+						paddingLeft = paddingRight = &quot;5px&quot;;
+						if(x%2){
+							backgroundColor = &quot;#e1f1ff&quot;;
+						}
+						if(y&gt;0){
+							textAlign = &quot;right&quot;;
+							borderRight = &quot;1px solid gray&quot;;
+						}else{
+							borderRight = &quot;1px solid black&quot;;
+						}
+					}
+				}
+			}
+		}
+
+		if(appendToDoc){
+			var ne = document.createElement(&quot;div&quot;);
+			ne.id = &quot;profileOutputTable&quot;;
+			with(ne.style){
+				fontFamily = &quot;Courier New, monospace&quot;;
+				fontSize = &quot;12px&quot;;
+				lineHeight = &quot;16px&quot;;
+				borderTop = &quot;1px solid black&quot;;
+				padding = &quot;10px&quot;;
+			}
+			if(document.getElementById(&quot;profileOutputTable&quot;)){
+				document.body.replaceChild(ne, document.getElementById(&quot;profileOutputTable&quot;));
+			}else{
+				document.body.appendChild(ne);
+			}
+			ne.appendChild(tbl);
+		}
+
+		return tbl;
+	}
+}

Added: trunk/root/static/magic/src/reflect/__package__.js
===================================================================
--- trunk/root/static/magic/src/reflect/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/reflect/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.deprecated(&quot;dojo.reflect&quot;, &quot;merged into dojo.lang (dojo.lang[type]).&quot;, &quot;0.4&quot;);
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.reflect.reflection&quot;]
+});
+dojo.provide(&quot;dojo.reflect.*&quot;);

Added: trunk/root/static/magic/src/reflect/reflection.js
===================================================================
--- trunk/root/static/magic/src/reflect/reflection.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/reflect/reflection.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,198 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.deprecated(&quot;dojo.reflect&quot;, &quot;merged into dojo.lang (dojo.lang[type])&quot;, &quot;0.4&quot;);
+dojo.provide(&quot;dojo.reflect&quot;);
+
+/*****************************************************************
+	reflect.js
+	v.1.5.0
+	(c) 2003-2004 Thomas R. Trenka, Ph.D.
+
+	Derived from the reflection functions of f(m).
+	<A HREF="http://dojotoolkit.org">http://dojotoolkit.org</A>
+	<A HREF="http://fm.dept-z.com">http://fm.dept-z.com</A>
+
+	There is a dependency on the variable dJ_global, which
+	should always refer to the global object.
+******************************************************************/
+if(!dj_global){ var dj_global = this; }
+
+dojo.reflect = {} ;
+dojo.reflect.$unknownType = function(){ } ;
+dojo.reflect.ParameterInfo = function(name, type){ 
+	this.name = name ;
+	this.type = (type) ? type : dojo.reflect.$unknownType ;
+} ;
+dojo.reflect.PropertyInfo = function(name, type) { 
+	this.name = name ;
+	this.type = (type) ? type : dojo.reflect.$unknownType ;
+} ;
+dojo.reflect.MethodInfo = function(name, fn){
+	var parse = function(f) {
+		var o = {} ; 
+		var s = f.toString() ;
+		var param = ((s.substring(s.indexOf('(')+1, s.indexOf(')'))).replace(/\s+/g, &quot;&quot;)).split(&quot;,&quot;) ;
+		o.parameters = [] ;
+		for (var i = 0; i &lt; param.length; i++) {
+			o.parameters.push(new dojo.reflect.ParameterInfo(param[i])) ;
+		}
+		o.body = (s.substring(s.indexOf('{')+1, s.lastIndexOf('}'))).replace(/(^\s*)|(\s*$)/g, &quot;&quot;) ;
+		return o ;
+	} ;
+
+	var tmp = parse(fn) ;
+	var p = tmp.parameters ;
+	var body = tmp.body ;
+	
+	this.name = (name) ? name : &quot;anonymous&quot; ;
+	this.getParameters = function(){ return p ; } ;
+	this.getNullArgumentsObject = function() {
+		var a = [] ;
+		for (var i = 0; i &lt; p.length; i++){
+			a.push(null);
+		}
+		return a ;
+	} ;
+	this.getBody = function() { return body ; } ;
+	this.type = Function ;
+	this.invoke = function(src, args){ return fn.apply(src, args) ; } ;
+} ;
+
+//	Static object that can activate instances of the passed type.
+dojo.reflect.Activator = new (function(){
+	this.createInstance = function(type, args) {
+		switch (typeof(type)) {
+			case &quot;function&quot; : { 
+				var o = {} ;
+				type.apply(o, args) ;
+				return o ;
+			} ;
+			case &quot;string&quot; : {
+				var o = {} ;
+				(dojo.reflect.Reflector.getTypeFromString(type)).apply(o, args) ;
+				return o ;
+			} ;
+		}
+		throw new Error(&quot;dojo.reflect.Activator.createInstance(): no such type exists.&quot;);
+	}
+})() ;
+
+dojo.reflect.Reflector = new (function(){
+	this.getTypeFromString = function(s) {
+		var parts = s.split(&quot;.&quot;), i = 0, obj = dj_global ; 
+		do { obj = obj[parts[i++]] ; } while (i &lt; parts.length &amp;&amp; obj) ; 
+		return (obj != dj_global) ? obj : null ;
+	}; 
+
+	this.typeExists = function(s) {
+		var parts = s.split(&quot;.&quot;), i = 0, obj = dj_global ; 
+		do { obj = obj[parts[i++]] ; } while (i &lt; parts.length &amp;&amp; obj) ; 
+		return (obj &amp;&amp; obj != dj_global) ;
+	}; 
+
+	this.getFieldsFromType = function(s) { 
+		var type = s ;
+		if (typeof(s) == &quot;string&quot;) {
+			type = this.getTypeFromString(s) ;
+		}
+		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
+		return this.getFields(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
+	};
+
+	this.getPropertiesFromType = function(s) { 
+		var type = s ;
+		if (typeof(s) == &quot;string&quot;) {
+			type = this.getTypeFromString(s);
+		}
+		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
+		return this.getProperties(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
+	};
+
+	this.getMethodsFromType = function(s) { 
+		var type = s ;
+		if (typeof(s) == &quot;string&quot;) {
+			type = this.getTypeFromString(s) ;
+		}
+		var nullArgs = (new dojo.reflect.MethodInfo(type)).getNullArgumentsObject() ;
+		return this.getMethods(dojo.reflect.Activator.createInstance(s, nullArgs)) ;
+	};
+
+	this.getType = function(o) { return o.constructor ; } ;
+
+	this.getFields = function(obj) {
+		var arr = [] ;
+		for (var p in obj) { 
+			if(this.getType(obj[p]) != Function){
+				arr.push(new dojo.reflect.PropertyInfo(p, this.getType(obj[p]))) ;
+			}else{
+				arr.push(new dojo.reflect.MethodInfo(p, obj[p]));
+			}
+		}
+		return arr ;
+	};
+
+	this.getProperties = function(obj) {
+		var arr = [] ;
+		var fi = this.getFields(obj) ;
+		for (var i = 0; i &lt; fi.length; i++){
+			if (this.isInstanceOf(fi[i], dojo.reflect.PropertyInfo)){
+				arr.push(fi[i]) ;
+			}
+		}
+		return arr ;
+	};
+
+	this.getMethods = function(obj) {
+		var arr = [] ;
+		var fi = this.getFields(obj) ;
+		for (var i = 0; i &lt; fi.length; i++){
+			if (this.isInstanceOf(fi[i], dojo.reflect.MethodInfo)){
+				arr.push(fi[i]) ;
+			}
+		}
+		return arr ;
+	};
+
+	/*
+	this.implements = function(o, type) {
+		if (this.isSubTypeOf(o, type)) return false ;
+		var f = this.getFieldsFromType(type) ;
+		for (var i = 0; i &lt; f.length; i++) {
+			if (typeof(o[(f[i].name)]) == &quot;undefined&quot;){
+				return false;
+			}
+		}
+		return true ;
+	};
+	*/
+
+	this.getBaseClass = function(o) {
+		if (o.getType().prototype.prototype.constructor){
+			return (o.getType()).prototype.prototype.constructor ;
+		}
+		return Object ;
+	} ;
+
+	this.isInstanceOf = function(o, type) { 
+		return (this.getType(o) == type) ; 
+	};
+
+	this.isSubTypeOf = function(o, type) { 
+		return (o instanceof type) ; 
+	};
+
+	this.isBaseTypeOf = function(o, type) { 
+		return (type instanceof o); 
+	};
+})();
+
+// back-compat
+dojo.provide(&quot;dojo.reflect.reflection&quot;);

Added: trunk/root/static/magic/src/regexp.js
===================================================================
--- trunk/root/static/magic/src/regexp.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/regexp.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,566 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.regexp&quot;);
+dojo.provide(&quot;dojo.regexp.us&quot;);
+
+// *** Regular Expression Generators ***
+
+/**
+  Builds a RE that matches a top-level domain.
+
+  @param flags  An object.
+    flags.allowCC  Include 2 letter country code domains.  Default is true.
+    flags.allowGeneric  Include the generic domains.  Default is true.
+    flags.allowInfra  Include infrastructure domains.  Default is true.
+
+  @return  A string for a regular expression for a top-level domain.
+*/
+dojo.regexp.tld = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.allowCC != &quot;boolean&quot;) { flags.allowCC = true; }
+	if (typeof flags.allowInfra != &quot;boolean&quot;) { flags.allowInfra = true; }
+	if (typeof flags.allowGeneric != &quot;boolean&quot;) { flags.allowGeneric = true; }
+
+	// Infrastructure top-level domain - only one at present
+	var infraRE = &quot;arpa&quot;;
+
+	// Generic top-level domains RE.
+	var genericRE = 
+		&quot;aero|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|xxx|jobs|mobi|post&quot;;
+	
+	// Country Code top-level domains RE
+	var ccRE = 
+		&quot;ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|&quot; +
+		&quot;bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|&quot; +
+		&quot;ec|ee|eg|er|es|et|fi|fj|fk|fm|fo|fr|ga|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|&quot; +
+		&quot;hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kr|kw|ky|kz|la|&quot; +
+		&quot;lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|&quot; +
+		&quot;mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|&quot; +
+		&quot;ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sk|sl|sm|sn|sr|st|su|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|&quot; +
+		&quot;to|tr|tt|tv|tw|tz|ua|ug|uk|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw&quot;;
+
+	// Build top-level domain RE
+	var a = [];
+	if (flags.allowInfra) { a.push(infraRE); }
+	if (flags.allowGeneric) { a.push(genericRE); }
+	if (flags.allowCC) { a.push(ccRE); }
+
+	var tldRE = &quot;&quot;;
+	if (a.length &gt; 0) {
+		tldRE = &quot;(&quot; + a.join(&quot;|&quot;) + &quot;)&quot;;
+	}
+
+	return tldRE;
+}
+
+/**
+  Builds a RE that matches an IP Address.
+  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
+  Supports 2 formats for Ipv6.
+
+  @param flags  An object.  All flags are boolean with default = true.
+    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
+    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
+    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
+    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
+    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
+      Case insensitive.  Zero padding allowed.
+    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
+    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
+      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d
+
+  @return  A string for a regular expression for an IP address.
+*/
+dojo.regexp.ipAddress = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.allowDottedDecimal != &quot;boolean&quot;) { flags.allowDottedDecimal = true; }
+	if (typeof flags.allowDottedHex != &quot;boolean&quot;) { flags.allowDottedHex = true; }
+	if (typeof flags.allowDottedOctal != &quot;boolean&quot;) { flags.allowDottedOctal = true; }
+	if (typeof flags.allowDecimal != &quot;boolean&quot;) { flags.allowDecimal = true; }
+	if (typeof flags.allowHex != &quot;boolean&quot;) { flags.allowHex = true; }
+	if (typeof flags.allowIPv6 != &quot;boolean&quot;) { flags.allowIPv6 = true; }
+	if (typeof flags.allowHybrid != &quot;boolean&quot;) { flags.allowHybrid = true; }
+
+	// decimal-dotted IP address RE.
+	var dottedDecimalRE = 
+		// Each number is between 0-255.  Zero padding is not allowed.
+		&quot;((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])&quot;;
+
+	// dotted hex IP address RE.  Each number is between 0x0-0xff.  Zero padding is allowed, e.g. 0x00.
+	var dottedHexRE = &quot;(0[xX]0*[\\da-fA-F]?[\\da-fA-F]\\.){3}0[xX]0*[\\da-fA-F]?[\\da-fA-F]&quot;;
+
+	// dotted octal IP address RE.  Each number is between 0000-0377.  
+	// Zero padding is allowed, but each number must have at least 4 characters.
+	var dottedOctalRE = &quot;(0+[0-3][0-7][0-7]\\.){3}0+[0-3][0-7][0-7]&quot;;
+
+	// decimal IP address RE.  A decimal number between 0-4294967295.  
+	var decimalRE =  &quot;(0|[1-9]\\d{0,8}|[1-3]\\d{9}|4[01]\\d{8}|42[0-8]\\d{7}|429[0-3]\\d{6}|&quot; +
+		&quot;4294[0-8]\\d{5}|42949[0-5]\\d{4}|429496[0-6]\\d{3}|4294967[01]\\d{2}|42949672[0-8]\\d|429496729[0-5])&quot;;
+
+	// hexadecimal IP address RE. 
+	// A hexadecimal number between 0x0-0xFFFFFFFF. Case insensitive.  Zero padding is allowed.
+	var hexRE = &quot;0[xX]0*[\\da-fA-F]{1,8}&quot;;
+
+	// IPv6 address RE. 
+	// The format is written as eight groups of four hexadecimal digits, x:x:x:x:x:x:x:x,
+	// where x is between 0000-ffff. Zero padding is optional. Case insensitive. 
+	var ipv6RE = &quot;([\\da-fA-F]{1,4}\\:){7}[\\da-fA-F]{1,4}&quot;;
+
+	// IPv6/IPv4 Hybrid address RE. 
+	// The format is written as six groups of four hexadecimal digits, 
+	// followed by the 4 dotted decimal IPv4 format. x:x:x:x:x:x:d.d.d.d
+	var hybridRE = &quot;([\\da-fA-F]{1,4}\\:){6}&quot; + 
+		&quot;((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.){3}(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])&quot;;
+
+	// Build IP Address RE
+	var a = [];
+	if (flags.allowDottedDecimal) { a.push(dottedDecimalRE); }
+	if (flags.allowDottedHex) { a.push(dottedHexRE); }
+	if (flags.allowDottedOctal) { a.push(dottedOctalRE); }
+	if (flags.allowDecimal) { a.push(decimalRE); }
+	if (flags.allowHex) { a.push(hexRE); }
+	if (flags.allowIPv6) { a.push(ipv6RE); }
+	if (flags.allowHybrid) { a.push(hybridRE); }
+
+	var ipAddressRE = &quot;&quot;;
+	if (a.length &gt; 0) {
+		ipAddressRE = &quot;(&quot; + a.join(&quot;|&quot;) + &quot;)&quot;;
+	}
+
+	return ipAddressRE;
+}
+
+/**
+  Builds a RE that matches a host.
+	A host is a domain name or an IP address, possibly followed by a port number.
+
+  @param flags  An object.
+    flags.allowIP  Allow an IP address for hostname.  Default is true.
+    flags.allowLocal  Allow the host to be &quot;localhost&quot;.  Default is false.
+    flags.allowPort  Allow a port number to be present.  Default is true.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for a host.
+*/
+dojo.regexp.host = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.allowIP != &quot;boolean&quot;) { flags.allowIP = true; }
+	if (typeof flags.allowLocal != &quot;boolean&quot;) { flags.allowLocal = false; }
+	if (typeof flags.allowPort != &quot;boolean&quot;) { flags.allowPort = true; }
+
+	// Domain names can not end with a dash.
+	var domainNameRE = &quot;([0-9a-zA-Z]([-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?\\.)+&quot; + dojo.regexp.tld(flags);
+
+	// port number RE
+	var portRE = ( flags.allowPort ) ? &quot;(\\:&quot; + dojo.regexp.integer({signed: false}) + &quot;)?&quot; : &quot;&quot;;
+
+	// build host RE
+	var hostNameRE = domainNameRE;
+	if (flags.allowIP) { hostNameRE += &quot;|&quot; +  dojo.regexp.ipAddress(flags); }
+	if (flags.allowLocal) { hostNameRE += &quot;|localhost&quot;; }
+
+	return &quot;(&quot; + hostNameRE + &quot;)&quot; + portRE;
+}
+
+/**
+  Builds a regular expression that matches a URL.
+
+  @param flags  An object.
+    flags.scheme  Can be true, false, or [true, false]. 
+      This means: required, not allowed, or match either one.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for a URL.
+*/
+dojo.regexp.url = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.scheme == &quot;undefined&quot;) { flags.scheme = [true, false]; }
+
+	// Scheme RE
+	var protocalRE = dojo.regexp.buildGroupRE(flags.scheme,
+		function(q) { if (q) { return &quot;(https?|ftps?)\\://&quot;; }  return &quot;&quot;; }
+	);
+
+	// Path and query and anchor RE
+	var pathRE = &quot;(/([^?#\\s/]+/)*)?([^?#\\s/]+(\\?[^?#\\s/]*)?(#[A-Za-z][\\w.:-]*)?)?&quot;;
+
+	return (protocalRE + dojo.regexp.host(flags) + pathRE);
+}
+
+/**
+  Builds a regular expression that matches an email address.
+
+  @param flags  An object.
+    flags.allowCruft  Allow address like &lt;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">foo at yahoo.com</A>&gt;.  Default is false.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for an email address.
+*/
+dojo.regexp.emailAddress = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.allowCruft != &quot;boolean&quot;) { flags.allowCruft = false; }
+	flags.allowPort = false; // invalid in email addresses
+
+	// user name RE - apostrophes are valid if there's not 2 in a row
+	var usernameRE = &quot;([\\da-z]+[-._+&amp;'])*[\\da-z]+&quot;;
+
+	// build emailAddress RE
+	var emailAddressRE = usernameRE + &quot;@&quot; + dojo.regexp.host(flags);
+
+	// Allow email addresses with cruft
+	if ( flags.allowCruft ) {
+		emailAddressRE = &quot;&lt;?(mailto\\:)?&quot; + emailAddressRE + &quot;&gt;?&quot;;
+	}
+
+	return emailAddressRE;
+}
+
+/**
+  Builds a regular expression that matches a list of email addresses.
+
+  @param flags  An object.
+    flags.listSeparator  The character used to separate email addresses.  Default is &quot;;&quot;, &quot;,&quot;, &quot;\n&quot; or &quot; &quot;.
+    flags in regexp.emailAddress can be applied.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+
+  @return  A string for a regular expression for an email address list.
+*/
+dojo.regexp.emailAddressList = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.listSeparator != &quot;string&quot;) { flags.listSeparator = &quot;\\s;,&quot;; }
+
+	// build a RE for an Email Address List
+	var emailAddressRE = dojo.regexp.emailAddress(flags);
+	var emailAddressListRE = &quot;(&quot; + emailAddressRE + &quot;\\s*[&quot; + flags.listSeparator + &quot;]\\s*)*&quot; + 
+		emailAddressRE + &quot;\\s*[&quot; + flags.listSeparator + &quot;]?\\s*&quot;;
+
+	return emailAddressListRE;
+}
+
+/**
+  Builds a regular expression that matches an integer.
+
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if it is signed or unsigned).
+    flags.separator  The character used as the thousands separator.  Default is no separator.
+      For more than one symbol use an array, e.g. [&quot;,&quot;, &quot;&quot;], makes ',' optional.
+
+  @return  A string for a regular expression for an integer.
+*/
+dojo.regexp.integer = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.signed == &quot;undefined&quot;) { flags.signed = [true, false]; }
+	if (typeof flags.separator == &quot;undefined&quot;) { flags.separator = &quot;&quot;; }
+
+	// build sign RE
+	var signRE = dojo.regexp.buildGroupRE(flags.signed,
+		function(q) { if (q) { return &quot;[-+]&quot;; }  return &quot;&quot;; }
+	);
+
+	// number RE
+	var numberRE = dojo.regexp.buildGroupRE(flags.separator,
+		function(sep) { 
+			if ( sep == &quot;&quot; ) { 
+				return &quot;(0|[1-9]\\d*)&quot;; 
+			}
+			return &quot;(0|[1-9]\\d{0,2}([&quot; + sep + &quot;]\\d{3})*)&quot;; 
+		}
+	);
+	var numberRE;
+
+	// integer RE
+	return (signRE + numberRE);
+}
+
+/**
+  Builds a regular expression to match a real number in exponential notation.
+
+  @param flags  An object.
+    flags.places  The integer number of decimal places.
+      If not given, the decimal part is optional and the number of places is unlimited.
+    flags.decimal  A string for the character used as the decimal point.  Default is &quot;.&quot;.
+    flags.exponent  Express in exponential notation.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if the exponential part is present are not).
+    flags.eSigned  The leading plus-or-minus sign on the exponent.  Can be true, false, 
+      or [true, false].  Default is [true, false], (i.e. will match if it is signed or unsigned).
+    flags in regexp.integer can be applied.
+
+  @return  A string for a regular expression for a real number.
+*/
+dojo.regexp.realNumber = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.places != &quot;number&quot;) { flags.places = Infinity; }
+	if (typeof flags.decimal != &quot;string&quot;) { flags.decimal = &quot;.&quot;; }
+	if (typeof flags.exponent == &quot;undefined&quot;) { flags.exponent = [true, false]; }
+	if (typeof flags.eSigned == &quot;undefined&quot;) { flags.eSigned = [true, false]; }
+
+	// integer RE
+	var integerRE = dojo.regexp.integer(flags);
+
+	// decimal RE
+	var decimalRE = &quot;&quot;;
+	if ( flags.places == Infinity) { 
+		decimalRE = &quot;(\\&quot; + flags.decimal + &quot;\\d+)?&quot;; 
+	}
+	else if ( flags.places &gt; 0) { 
+		decimalRE = &quot;\\&quot; + flags.decimal + &quot;\\d{&quot; + flags.places + &quot;}&quot;; 
+	}
+
+	// exponent RE
+	var exponentRE = dojo.regexp.buildGroupRE(flags.exponent,
+		function(q) { 
+			if (q) { return &quot;([eE]&quot; + dojo.regexp.integer({signed: flags.eSigned}) + &quot;)&quot;; }
+			return &quot;&quot;; 
+		}
+	);
+
+	// real number RE
+	return (integerRE + decimalRE + exponentRE);
+}
+
+/**
+  Builds a regular expression to match a monetary value.
+
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if it is signed or unsigned).
+    flags.symbol  A currency symbol such as Yen &quot;&#65533;&quot;, Pound &quot;&#65533;&quot;, or the Euro sign &quot;&#65533;&quot;.  
+      Default is &quot;$&quot;.  For more than one symbol use an array, e.g. [&quot;$&quot;, &quot;&quot;], makes $ optional.
+    flags.placement  The symbol can come &quot;before&quot; the number or &quot;after&quot;.  Default is &quot;before&quot;.
+    flags.separator  The character used as the thousands separator. The default is &quot;,&quot;.
+    flags.cents  The two decimal places for cents.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. will match if cents are present are not).
+    flags.decimal  A string for the character used as the decimal point.  Default is &quot;.&quot;.
+
+  @return  A string for a regular expression for a monetary value.
+*/
+dojo.regexp.currency = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.signed == &quot;undefined&quot;) { flags.signed = [true, false]; }
+	if (typeof flags.symbol == &quot;undefined&quot;) { flags.symbol = &quot;$&quot;; }
+	if (typeof flags.placement != &quot;string&quot;) { flags.placement = &quot;before&quot;; }
+	if (typeof flags.separator != &quot;string&quot;) { flags.separator = &quot;,&quot;; }
+	if (typeof flags.cents == &quot;undefined&quot;) { flags.cents = [true, false]; }
+	if (typeof flags.decimal != &quot;string&quot;) { flags.decimal = &quot;.&quot;; }
+
+	// build sign RE
+	var signRE = dojo.regexp.buildGroupRE(flags.signed,
+		function(q) { if (q) { return &quot;[-+]&quot;; }  return &quot;&quot;; }
+	);
+
+	// build symbol RE
+	var symbolRE = dojo.regexp.buildGroupRE(flags.symbol,
+		function(symbol) { 
+			// escape all special characters
+			return &quot;\\s?&quot; + symbol.replace( /([.$?*!=:|\\\/^])/g, &quot;\\$1&quot;) + &quot;\\s?&quot;;
+		}
+	);
+
+	// number RE
+	var numberRE = dojo.regexp.integer( {signed: false, separator: flags.separator} );
+
+	// build cents RE
+	var centsRE = dojo.regexp.buildGroupRE(flags.cents,
+		function(q) { if (q) { return &quot;(\\&quot; + flags.decimal + &quot;\\d\\d)&quot;; }  return &quot;&quot;; }
+	);
+
+	// build currency RE
+	var currencyRE;
+	if (flags.placement == &quot;before&quot;) {
+		currencyRE = signRE + symbolRE + numberRE + centsRE;
+	}
+	else {
+		currencyRE = signRE + numberRE + centsRE + symbolRE;
+	}
+
+	return currencyRE;
+}
+
+/**
+  A regular expression to match US state and territory abbreviations.
+
+  @param flags  An object.
+    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
+    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.
+
+  @return  A string for a regular expression for a US state.
+*/
+dojo.regexp.us.state = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.allowTerritories != &quot;boolean&quot;) { flags.allowTerritories = true; }
+	if (typeof flags.allowMilitary != &quot;boolean&quot;) { flags.allowMilitary = true; }
+
+	// state RE
+	var statesRE = 
+		&quot;AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|&quot; + 
+		&quot;NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY&quot;;
+
+	// territories RE
+	var territoriesRE = &quot;AS|FM|GU|MH|MP|PW|PR|VI&quot;;
+
+	// military states RE
+	var militaryRE = &quot;AA|AE|AP&quot;;
+
+	// Build states and territories RE
+	if (flags.allowTerritories) { statesRE += &quot;|&quot; + territoriesRE; }
+	if (flags.allowMilitary) { statesRE += &quot;|&quot; + militaryRE; }
+
+	return &quot;(&quot; + statesRE + &quot;)&quot;;
+}
+
+/**
+  Builds a regular expression to match any International format for time.
+  The RE can match one format or one of multiple formats.
+
+  Format
+  h        12 hour, no zero padding.
+  hh       12 hour, has leading zero.
+  H        24 hour, no zero padding.
+  HH       24 hour, has leading zero.
+  m        minutes, no zero padding.
+  mm       minutes, has leading zero.
+  s        seconds, no zero padding.
+  ss       seconds, has leading zero.
+  t        am or pm, case insensitive.
+  All other characters must appear literally in the expression.
+
+  Example
+    &quot;h:m:s t&quot;  -&gt;   2:5:33 PM
+    &quot;HH:mm:ss&quot; -&gt;  14:05:33
+
+  @param flags  An object.
+    flags.format  A string or an array of strings.  Default is &quot;h:mm:ss t&quot;.
+    flags.amSymbol  The symbol used for AM.  Default is &quot;AM&quot;.
+    flags.pmSymbol  The symbol used for PM.  Default is &quot;PM&quot;.
+
+  @return  A string for a regular expression for a time value.
+*/
+dojo.regexp.time = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.format == &quot;undefined&quot;) { flags.format = &quot;h:mm:ss t&quot;; }
+	if (typeof flags.amSymbol != &quot;string&quot;) { flags.amSymbol = &quot;AM&quot;; }
+	if (typeof flags.pmSymbol != &quot;string&quot;) { flags.pmSymbol = &quot;PM&quot;; }
+
+	// Converts a time format to a RE
+	var timeRE = function(format) {
+		// escape all special characters
+		format = format.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, &quot;\\$1&quot;);
+		var amRE = flags.amSymbol.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, &quot;\\$1&quot;);
+		var pmRE = flags.pmSymbol.replace( /([.$?*!=:|{}\(\)\[\]\\\/^])/g, &quot;\\$1&quot;);
+
+		// replace tokens with Regular Expressions
+		format = format.replace(&quot;hh&quot;, &quot;(0[1-9]|1[0-2])&quot;);
+		format = format.replace(&quot;h&quot;, &quot;([1-9]|1[0-2])&quot;);
+		format = format.replace(&quot;HH&quot;, &quot;([01][0-9]|2[0-3])&quot;);
+		format = format.replace(&quot;H&quot;, &quot;([0-9]|1[0-9]|2[0-3])&quot;);
+		format = format.replace(&quot;mm&quot;, &quot;([0-5][0-9])&quot;);
+		format = format.replace(&quot;m&quot;, &quot;([1-5][0-9]|[0-9])&quot;);
+		format = format.replace(&quot;ss&quot;, &quot;([0-5][0-9])&quot;);
+		format = format.replace(&quot;s&quot;, &quot;([1-5][0-9]|[0-9])&quot;);
+		format = format.replace(&quot;t&quot;, &quot;\\s?(&quot; + amRE + &quot;|&quot; + pmRE + &quot;)\\s?&quot; );
+
+		return format;
+	};
+
+	// build RE for multiple time formats
+	return dojo.regexp.buildGroupRE(flags.format, timeRE);
+}
+
+/**
+  Builds a regular expression to match any sort of number based format.
+  Use it for phone numbers, social security numbers, zip-codes, etc.
+  The RE can match one format or one of multiple formats.
+
+  Format
+    #        Stands for a digit, 0-9.
+    ?        Stands for an optional digit, 0-9 or nothing.
+    All other characters must appear literally in the expression.
+
+  Example   
+    &quot;(###) ###-####&quot;       -&gt;   (510) 542-9742
+    &quot;(###) ###-#### x#???&quot; -&gt;   (510) 542-9742 x153
+    &quot;###-##-####&quot;          -&gt;   506-82-1089       i.e. social security number
+    &quot;#####-####&quot;           -&gt;   98225-1649        i.e. zip code
+
+  @param flags  An object.
+    flags.format  A string or an Array of strings for multiple formats.
+  @return  A string for a regular expression for the number format(s).
+*/
+dojo.regexp.numberFormat = function(flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	if (typeof flags.format == &quot;undefined&quot;) { flags.format = &quot;###-###-####&quot;; }
+
+	// Converts a number format to RE.
+	var digitRE = function(format) {
+		// escape all special characters, except '?'
+		format = format.replace( /([.$*!=:|{}\(\)\[\]\\\/^])/g, &quot;\\$1&quot;);
+
+		// Now replace '?' with Regular Expression
+		format = format.replace(/\?/g, &quot;\\d?&quot;);
+
+		// replace # with Regular Expression
+		format = format.replace(/#/g, &quot;\\d&quot;);
+
+		return format;
+	};
+
+	// build RE for multiple number formats
+	return dojo.regexp.buildGroupRE(flags.format, digitRE);
+}
+
+
+/**
+  This is basically a utility function used by some of the RE generators.
+  Builds a regular expression that groups subexpressions.
+  The subexpressions are constructed by the function, re, in the second parameter.
+  re builds one subexpression for each elem in the array a, in the first parameter.
+
+  @param a  A single value or an array of values.
+  @param re  A function.  Takes one parameter and converts it to a regular expression. 
+  @return  A string for a regular expression that groups all the subexpressions.
+*/
+dojo.regexp.buildGroupRE = function(a, re) {
+
+	// case 1: a is a single value.
+	if ( !( a instanceof Array ) ) { 
+		return re(a);
+	}
+
+	// case 2: a is an array
+	var b = [];
+	for (var i = 0; i &lt; a.length; i++) {
+		// convert each elem to a RE
+		b.push(re(a[i]));
+	}
+
+	 // join the REs as alternatives in a RE group.
+	return &quot;(&quot; + b.join(&quot;|&quot;) + &quot;)&quot;;
+}

Added: trunk/root/static/magic/src/rpc/Deferred.js
===================================================================
--- trunk/root/static/magic/src/rpc/Deferred.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/Deferred.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.rpc.Deferred&quot;);
+dojo.require(&quot;dojo.Deferred&quot;);
+
+dojo.rpc.Deferred = dojo.Deferred;
+dojo.rpc.Deferred.prototype = dojo.Deferred.prototype;

Added: trunk/root/static/magic/src/rpc/JotService.js
===================================================================
--- trunk/root/static/magic/src/rpc/JotService.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/JotService.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,41 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.rpc.JotService&quot;);
+dojo.require(&quot;dojo.rpc.RpcService&quot;);
+dojo.require(&quot;dojo.rpc.JsonService&quot;);
+dojo.require(&quot;dojo.json&quot;);
+
+dojo.rpc.JotService = function(){
+	this.serviceUrl = &quot;/_/jsonrpc&quot;;
+}
+
+dojo.inherits(dojo.rpc.JotService, dojo.rpc.JsonService);
+
+dojo.lang.extend(dojo.rpc.JotService, {
+	bind: function(method, parameters, deferredRequestHandler, url){
+		dojo.io.bind({
+			url: url||this.serviceUrl,
+			content: {
+				json: this.createRequest(method, parameters)
+			},
+			method: &quot;POST&quot;,
+			mimetype: &quot;text/json&quot;,
+			load: this.resultCallback(deferredRequestHandler),
+			error: this.errorCallback(deferredRequestHandler),
+			preventCache: true
+		});
+	},
+
+	createRequest: function(method, params){
+		var req = { &quot;params&quot;: params, &quot;method&quot;: method, &quot;id&quot;: this.lastSubmissionId++ };
+		return dojo.json.serialize(req);
+	}
+});

Added: trunk/root/static/magic/src/rpc/JsonService.js
===================================================================
--- trunk/root/static/magic/src/rpc/JsonService.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/JsonService.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,103 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.rpc.JsonService&quot;);
+dojo.require(&quot;dojo.rpc.RpcService&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.json&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+dojo.rpc.JsonService = function(args){
+	// passing just the URL isn't terribly useful. It's expected that at
+	// various times folks will want to specify:
+	//	- just the serviceUrl (for use w/ remoteCall())
+	//	- the text of the SMD to evaluate
+	// 	- a raw SMD object
+	//	- the SMD URL
+	if(args){
+		if(dojo.lang.isString(args)){
+			// we assume it's an SMD file to be processed, since this was the
+			// earlier function signature
+
+			// FIXME: also accept dojo.uri.Uri objects?
+			this.connect(args);
+		}else{
+			// otherwise we assume it's an arguments object with the following
+			// (optional) properties:
+			//	- serviceUrl
+			//	- strictArgChecks
+			//	- smdUrl
+			//	- smdStr
+			//	- smdObj
+			if(args[&quot;smdUrl&quot;]){
+				this.connect(args.smdUrl);
+			}
+			if(args[&quot;smdStr&quot;]){
+				this.processSmd(dj_eval(&quot;(&quot;+args.smdStr+&quot;)&quot;));
+			}
+			if(args[&quot;smdObj&quot;]){
+				this.processSmd(args.smdObj);
+			}
+			if(args[&quot;serviceUrl&quot;]){
+				this.serviceUrl = args.serviceUrl;
+			}
+			if(typeof args[&quot;strictArgChecks&quot;] != &quot;undefined&quot;){
+				this.strictArgChecks = args.strictArgChecks;
+			}
+		}
+	}
+}
+
+dojo.inherits(dojo.rpc.JsonService, dojo.rpc.RpcService);
+
+dojo.lang.extend(dojo.rpc.JsonService, {
+
+	bustCache: false,
+	
+	contentType: &quot;application/json-rpc&quot;,
+
+	lastSubmissionId: 0,
+
+	callRemote: function(method, params){
+		var deferred = new dojo.rpc.Deferred();
+		this.bind(method, params, deferred);
+		return deferred;
+	},
+
+	bind: function(method, parameters, deferredRequestHandler, url){
+		dojo.io.bind({
+			url: url||this.serviceUrl,
+			postContent: this.createRequest(method, parameters),
+			method: &quot;POST&quot;,
+			contentType: this.contentType,
+			mimetype: &quot;text/json&quot;,
+			load: this.resultCallback(deferredRequestHandler),
+			preventCache:this.bustCache 
+		});
+	},
+
+	createRequest: function(method, params){
+		var req = { &quot;params&quot;: params, &quot;method&quot;: method, &quot;id&quot;: ++this.lastSubmissionId };
+		var data = dojo.json.serialize(req);
+		dojo.debug(&quot;JsonService: JSON-RPC Request: &quot; + data);
+		return data;
+	},
+
+	parseResults: function(obj){
+		if(!obj){ return; }
+		if(obj[&quot;Result&quot;]||obj[&quot;result&quot;]){
+			return obj[&quot;result&quot;]||obj[&quot;Result&quot;];
+		}else if(obj[&quot;ResultSet&quot;]){
+			return obj[&quot;ResultSet&quot;];
+		}else{
+			return obj;
+		}
+	}
+});

Added: trunk/root/static/magic/src/rpc/RpcService.js
===================================================================
--- trunk/root/static/magic/src/rpc/RpcService.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/RpcService.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,116 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.rpc.RpcService&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.json&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.rpc.Deferred&quot;);
+
+dojo.rpc.RpcService = function(url){
+	// summary
+	// constructor for rpc base class
+	if(url){
+		this.connect(url);
+	}
+}
+
+dojo.lang.extend(dojo.rpc.RpcService, {
+
+	strictArgChecks: true,
+	serviceUrl: &quot;&quot;,
+
+	parseResults: function(obj){
+		// summary
+		// parse the results coming back from an rpc request.  
+   		// this base implementation, just returns the full object
+		// subclasses should parse and only return the actual results
+		return obj;
+	},
+
+	errorCallback: function(/* dojo.rpc.Deferred */ deferredRequestHandler){
+		// summary
+		// create callback that calls the Deferres errback method
+		return function(type, obj, e){
+			deferredRequestHandler.errback(e);
+		}
+	},
+
+	resultCallback: function(/* dojo.rpc.Deferred */ deferredRequestHandler){
+		// summary
+		// create callback that calls the Deferred's callback method
+		var tf = dojo.lang.hitch(this, 
+			function(type, obj, e){
+				var results = this.parseResults(obj||e);
+				deferredRequestHandler.callback(results); 
+			}
+		);
+		return tf;
+	},
+
+
+	generateMethod: function(/*string*/ method, /*array*/ parameters, /*string*/ url){
+		// summary
+		// generate the local bind methods for the remote object
+		return dojo.lang.hitch(this, function(){
+			var deferredRequestHandler = new dojo.rpc.Deferred();
+
+			// if params weren't specified, then we can assume it's varargs
+			if( (this.strictArgChecks) &amp;&amp;
+				(parameters != null) &amp;&amp;
+				(arguments.length != parameters.length)
+			){
+				// put error stuff here, no enough params
+				dojo.raise(&quot;Invalid number of parameters for remote method.&quot;);
+			} else {
+				this.bind(method, arguments, deferredRequestHandler, url);
+			}
+
+			return deferredRequestHandler;
+		});
+	},
+
+	processSmd: function(/*json*/ object){
+		// summary
+		// callback method for reciept of a smd object.  Parse the smd and
+		// generate functions based on the description
+		dojo.debug(&quot;RpcService: Processing returned SMD.&quot;);
+		if(object.methods){
+			dojo.lang.forEach(object.methods, function(m){
+				if(m &amp;&amp; m[&quot;name&quot;]){
+					dojo.debug(&quot;RpcService: Creating Method: this.&quot;, m.name, &quot;()&quot;);
+					this[m.name] = this.generateMethod(	m.name,
+														m.parameters, 
+														m[&quot;url&quot;]||m[&quot;serviceUrl&quot;]||m[&quot;serviceURL&quot;]);
+					if(dojo.lang.isFunction(this[m.name])){
+						dojo.debug(&quot;RpcService: Successfully created&quot;, m.name, &quot;()&quot;);
+					}else{
+						dojo.debug(&quot;RpcService: Failed to create&quot;, m.name, &quot;()&quot;);
+					}
+				}
+			}, this);
+		}
+
+		this.serviceUrl = object.serviceUrl||object.serviceURL;
+		dojo.debug(&quot;RpcService: Dojo RpcService is ready for use.&quot;);
+	},
+
+	connect: function(/*String*/ smdUrl){
+		// summary
+		// connect to a remote url and retrieve a smd object
+		dojo.debug(&quot;RpcService: Attempting to load SMD document from:&quot;, smdUrl);
+		dojo.io.bind({
+			url: smdUrl,
+			mimetype: &quot;text/json&quot;,
+			load: dojo.lang.hitch(this, function(type, object, e){ return this.processSmd(object); }),
+			sync: true
+		});		
+	}
+});

Added: trunk/root/static/magic/src/rpc/YahooService.js
===================================================================
--- trunk/root/static/magic/src/rpc/YahooService.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/YahooService.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,55 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.rpc.YahooService&quot;);
+dojo.require(&quot;dojo.rpc.RpcService&quot;);
+dojo.require(&quot;dojo.rpc.JsonService&quot;);
+dojo.require(&quot;dojo.json&quot;);
+dojo.require(&quot;dojo.uri.*&quot;);
+dojo.require(&quot;dojo.io.ScriptSrcIO&quot;);
+
+dojo.rpc.YahooService = function(appId){
+	this.appId = appId;
+	if(!appId){
+		this.appId = &quot;dojotoolkit&quot;;
+		dojo.debug(	&quot;please initializae the YahooService class with your own&quot;,
+					&quot;application ID. Using the default may cause problems during&quot;,
+					&quot;deployment of your application&quot;);
+	}
+	this.connect(dojo.uri.dojoUri(&quot;src/rpc/yahoo.smd&quot;));
+	this.scrictArgChecks = false;
+}
+
+dojo.inherits(dojo.rpc.YahooService, dojo.rpc.JsonService);
+
+dojo.lang.extend(dojo.rpc.YahooService, {
+	strictArgChecks: false,
+
+	bind: function(method, parameters, deferredRequestHandler, url){
+		var params = parameters;
+		if(	(dojo.lang.isArrayLike(parameters))&amp;&amp;
+			(parameters.length == 1)){
+			params = parameters[0];
+		}
+		params.output = &quot;json&quot;;
+		params.appid= this.appId;
+		dojo.io.bind({
+			url: url||this.serviceUrl,
+			transport: &quot;ScriptSrcTransport&quot;,
+			// FIXME: need to get content interpolation fixed
+			content: params,
+			jsonParamName: &quot;callback&quot;,
+			mimetype: &quot;text/json&quot;,
+			load: this.resultCallback(deferredRequestHandler),
+			error: this.errorCallback(deferredRequestHandler),
+			preventCache: true
+		});
+	}
+});

Added: trunk/root/static/magic/src/rpc/__package__.js
===================================================================
--- trunk/root/static/magic/src/rpc/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.rpc.JsonService&quot;, false, false]
+});
+dojo.provide(&quot;dojo.rpc.*&quot;);

Added: trunk/root/static/magic/src/rpc/yahoo.smd
===================================================================
--- trunk/root/static/magic/src/rpc/yahoo.smd	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/rpc/yahoo.smd	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,263 @@
+{
+	&quot;SMDVersion&quot;:&quot;.1&quot;,
+	&quot;objectName&quot;:&quot;yahoo&quot;,
+	&quot;serviceType&quot;:&quot;JSON-P&quot;,
+	&quot;methods&quot;:[
+		//
+		// MAPS 
+		//
+		{
+			// <A HREF="http://developer.yahoo.com/maps/rest/V1/mapImage.html">http://developer.yahoo.com/maps/rest/V1/mapImage.html</A>
+			&quot;name&quot;:&quot;mapImage&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.local.yahoo.com/MapsService/V1/mapImage">http://api.local.yahoo.com/MapsService/V1/mapImage</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;street&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;city&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;zip&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;location&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;longitude&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;latitude&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;image_type&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;image_width&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;image_height&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;zoom&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;radius&quot;, &quot;type&quot;:&quot;INTEGER&quot; }
+			]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/traffic/rest/V1/index.html">http://developer.yahoo.com/traffic/rest/V1/index.html</A>
+			&quot;name&quot;:&quot;trafficData&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.local.yahoo.com/MapsService/V1/trafficData">http://api.local.yahoo.com/MapsService/V1/trafficData</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;street&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;city&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;zip&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;location&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;longitude&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;latitude&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;severity&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;include_map&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;image_type&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;image_width&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;image_height&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;zoom&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;radius&quot;, &quot;type&quot;:&quot;INTEGER&quot; }
+			]
+		},
+		/*
+			// Yahoo's geocoding service is f'd for JSON and Y! advises that it
+			// may not be returning
+		{
+			// <A HREF="http://developer.yahoo.com/maps/rest/V1/geocode.html">http://developer.yahoo.com/maps/rest/V1/geocode.html</A>
+			&quot;name&quot;:&quot;geocode&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.local.yahoo.com/MapsService/V1/geocode">http://api.local.yahoo.com/MapsService/V1/geocode</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;street&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;city&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;zip&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;location&quot;, &quot;type&quot;:&quot;STRING&quot; }
+			]
+		},
+		*/
+		//
+		// LOCAL SEARCH
+		//
+		{
+			// <A HREF="http://developer.yahoo.com/search/local/V3/localSearch.html">http://developer.yahoo.com/search/local/V3/localSearch.html</A>
+			&quot;name&quot;:&quot;localSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.local.yahoo.com/LocalSearchService/V3/localSearch">http://api.local.yahoo.com/LocalSearchService/V3/localSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;street&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;city&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;zip&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;location&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;listing_id&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;sort&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;relevence&quot;, &quot;title&quot;, &quot;distance&quot;, or &quot;rating&quot;
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;radius&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // 1-50, defaults to 10
+				{ &quot;name&quot;:&quot;longitude&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;latitude&quot;, &quot;type&quot;:&quot;FLOAT&quot; },
+				{ &quot;name&quot;:&quot;category&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;omit_category&quot;, &quot;type&quot;:&quot;INTEGER&quot; },
+				{ &quot;name&quot;:&quot;minimum_rating&quot;, &quot;type&quot;:&quot;INTEGER&quot; }
+			]
+		},
+		//
+		// WEB SEARCH
+		//
+
+		// NOTE: contextual search and term extraction are not stubbed out
+		// becaues I'm not sure if we can POST via script src inclusion method
+		{
+			// <A HREF="http://developer.yahoo.com/search/web/V1/webSearch.html">http://developer.yahoo.com/search/web/V1/webSearch.html</A> 
+			&quot;name&quot;:&quot;webSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/WebSearchService/V1/webSearch">http://api.search.yahoo.com/WebSearchService/V1/webSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;all&quot;
+				{ &quot;name&quot;:&quot;region&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;us&quot;
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 1
+				{ &quot;name&quot;:&quot;format&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;any&quot;, can be &quot;html&quot;, &quot;msword&quot;, &quot;pdf&quot;, &quot;ppt&quot;, &quot;rst&quot;, &quot;txt&quot;, or &quot;xls&quot;
+				{ &quot;name&quot;:&quot;adult_ok&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;similar_ok&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;language&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;country&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;site&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;subscription&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;license&quot;, &quot;type&quot;:&quot;STRING&quot; } // defaults to &quot;any&quot;
+			]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/search/web/V1/spellingSuggestion.html">http://developer.yahoo.com/search/web/V1/spellingSuggestion.html</A>
+			&quot;name&quot;:&quot;spellingSuggestion&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/WebSearchService/V1/spellingSuggestion">http://api.search.yahoo.com/WebSearchService/V1/spellingSuggestion</A>&quot;,
+			&quot;parameters&quot;:[ { &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; } ]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/search/web/V1/relatedSuggestion.html">http://developer.yahoo.com/search/web/V1/relatedSuggestion.html</A>
+			&quot;name&quot;:&quot;spellingSuggestion&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/WebSearchService/V1/relatedSuggestion">http://api.search.yahoo.com/WebSearchService/V1/relatedSuggestion</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; } // 1-50, defaults to 10
+			]
+		},
+		//
+		// IMAGE SEARCH
+		//
+		{
+			// <A HREF="http://developer.yahoo.com/search/image/V1/imageSearch.html">http://developer.yahoo.com/search/image/V1/imageSearch.html</A>
+			&quot;name&quot;:&quot;imageSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/ImageSearchService/V1/imageSearch">http://api.search.yahoo.com/ImageSearchService/V1/imageSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;all&quot;, can by &quot;any&quot; or &quot;phrase&quot;
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 1
+				{ &quot;name&quot;:&quot;format&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;any&quot;, can be &quot;bmp&quot;, &quot;gif&quot;, &quot;jpeg&quot;, or &quot;png&quot;
+				{ &quot;name&quot;:&quot;adult_ok&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;coloration&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;any&quot;, &quot;color&quot;, or &quot;bw&quot;
+				{ &quot;name&quot;:&quot;site&quot;, &quot;type&quot;:&quot;STRING&quot; } // defaults to null
+			]
+		},
+		//
+		// SITE EXPLORER
+		//
+		{
+			// <A HREF="http://developer.yahoo.com/search/siteexplorer/V1/inlinkData.html">http://developer.yahoo.com/search/siteexplorer/V1/inlinkData.html</A> 
+			&quot;name&quot;:&quot;inlinkData&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/SiteExplorerService/V1/inlinkData">http://api.search.yahoo.com/SiteExplorerService/V1/inlinkData</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;all&quot;, can by &quot;any&quot; or &quot;phrase&quot;
+				{ &quot;name&quot;:&quot;entire_site&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;omit_inlinks&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;domain&quot; or &quot;subdomain&quot;, defaults to null
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 50
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 1
+				{ &quot;name&quot;:&quot;site&quot;, &quot;type&quot;:&quot;STRING&quot; } // defaults to null
+			]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/search/siteexplorer/V1/pageData.html">http://developer.yahoo.com/search/siteexplorer/V1/pageData.html</A>
+			&quot;name&quot;:&quot;pageData&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/SiteExplorerService/V1/pageData">http://api.search.yahoo.com/SiteExplorerService/V1/pageData</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;all&quot;, can by &quot;any&quot; or &quot;phrase&quot;
+				{ &quot;name&quot;:&quot;domain_only&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 50
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 1
+				{ &quot;name&quot;:&quot;site&quot;, &quot;type&quot;:&quot;STRING&quot; } // defaults to null
+			]
+		},
+		//
+		// MUSIC SEARCH
+		//
+		{
+			// <A HREF="http://developer.yahoo.com/search/audio/V1/artistSearch.html">http://developer.yahoo.com/search/audio/V1/artistSearch.html</A>
+			&quot;name&quot;:&quot;artistSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/AudioSearchService/V1/artistSearch">http://api.search.yahoo.com/AudioSearchService/V1/artistSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;artist&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;artistid&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;all&quot;, &quot;any&quot;, or &quot;phrase&quot;
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // 1-50, defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; } // defaults to 1
+			]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/search/audio/V1/albumSearch.html">http://developer.yahoo.com/search/audio/V1/albumSearch.html</A>
+			&quot;name&quot;:&quot;albumSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/AudioSearchService/V1/albumSearch">http://api.search.yahoo.com/AudioSearchService/V1/albumSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;artist&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;artistid&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;album&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;all&quot;, &quot;any&quot;, or &quot;phrase&quot;
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // 1-50, defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; } // defaults to 1
+			]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/search/audio/V1/songSearch.html">http://developer.yahoo.com/search/audio/V1/songSearch.html</A>
+			&quot;name&quot;:&quot;songSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/AudioSearchService/V1/songSearch">http://api.search.yahoo.com/AudioSearchService/V1/songSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;artist&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;artistid&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;album&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;albumid&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;song&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;songid&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;all&quot;, &quot;any&quot;, or &quot;phrase&quot;
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // 1-50, defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; } // defaults to 1
+			]
+		},
+		{
+			// <A HREF="http://developer.yahoo.com/search/audio/V1/songDownloadLocation.html">http://developer.yahoo.com/search/audio/V1/songDownloadLocation.html</A>
+			&quot;name&quot;:&quot;songDownloadLocation&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/AudioSearchService/V1/songDownloadLocation">http://api.search.yahoo.com/AudioSearchService/V1/songDownloadLocation</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;songid&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				// &quot;source&quot; can contain:
+				//	audiolunchbox artistdirect buymusic dmusic
+				//	emusic epitonic garageband itunes yahoo
+				//	livedownloads mp34u msn musicmatch mapster passalong
+				//	rhapsody soundclick theweb
+				{ &quot;name&quot;:&quot;source&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // 1-50, defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; } // defaults to 1
+			]
+		},
+		//
+		// NEWS SEARCH
+		//
+		{
+			// <A HREF="http://developer.yahoo.com/search/news/V1/newsSearch.html">http://developer.yahoo.com/search/news/V1/newsSearch.html</A>
+			&quot;name&quot;:&quot;newsSearch&quot;,
+			&quot;serviceURL&quot;: &quot;<A HREF="http://api.search.yahoo.com/NewsSearchService/V1/newsSearch">http://api.search.yahoo.com/NewsSearchService/V1/newsSearch</A>&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;query&quot;, &quot;type&quot;:&quot;STRING&quot; },
+				{ &quot;name&quot;:&quot;type&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to &quot;all&quot;
+				{ &quot;name&quot;:&quot;results&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 10
+				{ &quot;name&quot;:&quot;start&quot;, &quot;type&quot;:&quot;INTEGER&quot; }, // defaults to 1
+				{ &quot;name&quot;:&quot;sort&quot;, &quot;type&quot;:&quot;STRING&quot; }, // &quot;rank&quot; or &quot;date&quot;
+				{ &quot;name&quot;:&quot;language&quot;, &quot;type&quot;:&quot;STRING&quot; }, // defaults to null
+				{ &quot;name&quot;:&quot;site&quot;, &quot;type&quot;:&quot;STRING&quot; } // defaults to null
+			]
+		}
+		/*
+		{
+			// 
+			&quot;name&quot;:&quot;&quot;,
+			&quot;serviceURL&quot;: &quot;&quot;,
+			&quot;parameters&quot;:[
+				{ &quot;name&quot;:&quot;street&quot;, &quot;type&quot;:&quot;STRING&quot; },
+			]
+		}
+		*/
+	]
+}

Added: trunk/root/static/magic/src/selection/Selection.js
===================================================================
--- trunk/root/static/magic/src/selection/Selection.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/selection/Selection.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,425 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.selection.Selection&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.math&quot;);
+
+dojo.selection.Selection = function(items, isCollection) {
+	this.items = [];
+	this.selection = [];
+	this._pivotItems = [];
+	this.clearItems();
+
+	if(items) {
+		if(isCollection) {
+			this.setItemsCollection(items);
+		} else {
+			this.setItems(items);
+		}
+	}
+}
+dojo.lang.extend(dojo.selection.Selection, {
+	items: null, // items to select from, order matters for growable selections
+
+	selection: null, // items selected, aren't stored in order (see sorted())
+	lastSelected: null, // last item selected
+
+	allowImplicit: true, // if true, grow selection will start from 0th item when nothing is selected
+	length: 0, // number of *selected* items
+
+	// if true, the selection is treated as an in-order and can grow by ranges, not just by single item
+	isGrowable: true,
+
+	_pivotItems: null, // stack of pivot items
+	_pivotItem: null, // item we grow selections from, top of stack
+
+	// event handlers
+	onSelect: function(item) {},
+	onDeselect: function(item) {},
+	onSelectChange: function(item, selected) {},
+
+	_find: function(item, inSelection) {
+		if(inSelection) {
+			return dojo.lang.find(item, this.selection);
+		} else {
+			return dojo.lang.find(item, this.items);
+		}
+	},
+
+	isSelectable: function(item) {
+		// user-customizable, will filter items through this
+		return true;
+	},
+
+	setItems: function(/* ... */) {
+		this.clearItems();
+		this.addItems.call(this, arguments);
+	},
+
+	// this is in case you have an active collection array-like object
+	// (i.e. getElementsByTagName collection) that manages its own order
+	// and item list
+	setItemsCollection: function(collection) {
+		this.items = collection;
+	},
+
+	addItems: function(/* ... */) {
+		var args = dojo.lang.unnest(arguments);
+		for(var i = 0; i &lt; args.length; i++) {
+			this.items.push(args[i]);
+		}
+	},
+
+	addItemsAt: function(item, before /* ... */) {
+		if(this.items.length == 0) { // work for empy case
+			return this.addItems(dojo.lang.toArray(arguments, 2));
+		}
+
+		if(!this.isItem(item)) {
+			item = this.items[item];
+		}
+		if(!item) { throw new Error(&quot;addItemsAt: item doesn't exist&quot;); }
+		var idx = this._find(item);
+		if(idx &gt; 0 &amp;&amp; before) { idx--; }
+		for(var i = 2; i &lt; arguments.length; i++) {
+			if(!this.isItem(arguments[i])) {
+				this.items.splice(idx++, 0, arguments[i]);
+			}
+		}
+	},
+
+	removeItem: function(item) {
+		// remove item
+		var idx = this._find(item);
+		if(idx &gt; -1) {
+			this.items.splice(idx, 1);
+		}
+		// remove from selection
+		// FIXME: do we call deselect? I don't think so because this isn't how
+		// you usually want to deselect an item. For example, if you deleted an
+		// item, you don't really want to deselect it -- you want it gone. -DS
+		idx = this._find(item, true);
+		if(idx &gt; -1) {
+			this.selection.splice(idx, 1);
+		}
+	},
+
+	clearItems: function() {
+		this.items = [];
+		this.deselectAll();
+	},
+
+	isItem: function(item) {
+		return this._find(item) &gt; -1;
+	},
+
+	isSelected: function(item) {
+		return this._find(item, true) &gt; -1;
+	},
+
+	/**
+	 * allows you to filter item in or out of the selection
+	 * depending on the current selection and action to be taken
+	**/
+	selectFilter: function(item, selection, add, grow) {
+		return true;
+	},
+
+	/**
+	 * update -- manages selections, most selecting should be done here
+	 *  item =&gt; item which may be added/grown to/only selected/deselected
+	 *  add =&gt; behaves like ctrl in windows selection world
+	 *  grow =&gt; behaves like shift
+	 *  noToggle =&gt; if true, don't toggle selection on item
+	**/
+	update: function(item, add, grow, noToggle) {
+		if(!this.isItem(item)) { return false; }
+
+		if(this.isGrowable &amp;&amp; grow) {
+			if(!this.isSelected(item)
+				&amp;&amp; this.selectFilter(item, this.selection, false, true)) {
+				this.grow(item);
+				this.lastSelected = item;
+			}
+		} else if(add) {
+			if(this.selectFilter(item, this.selection, true, false)) {
+				if(noToggle) {
+					if(this.select(item)) {
+						this.lastSelected = item;
+					}
+				} else if(this.toggleSelected(item)) {
+					this.lastSelected = item;
+				}
+			}
+		} else {
+			this.deselectAll();
+			this.select(item);
+		}
+
+		this.length = this.selection.length;
+	},
+
+	/**
+	 * Grow a selection.
+	 *  toItem =&gt; which item to grow selection to
+	 *  fromItem =&gt; which item to start the growth from (it won't be selected)
+	 *
+	 * Any items in (fromItem, lastSelected] that aren't part of
+	 * (fromItem, toItem] will be deselected
+	**/
+	grow: function(toItem, fromItem) {
+		if(!this.isGrowable) { return; }
+
+		if(arguments.length == 1) {
+			fromItem = this._pivotItem;
+			if(!fromItem &amp;&amp; this.allowImplicit) {
+				fromItem = this.items[0];
+			}
+		}
+		if(!toItem || !fromItem) { return false; }
+
+		var fromIdx = this._find(fromItem);
+
+		// get items to deselect (fromItem, lastSelected]
+		var toDeselect = {};
+		var lastIdx = -1;
+		if(this.lastSelected) {
+			lastIdx = this._find(this.lastSelected);
+			var step = fromIdx &lt; lastIdx ? -1 : 1;
+			var range = dojo.math.range(lastIdx, fromIdx, step);
+			for(var i = 0; i &lt; range.length; i++) {
+				toDeselect[range[i]] = true;
+			}
+		}
+
+		// add selection (fromItem, toItem]
+		var toIdx = this._find(toItem);
+		var step = fromIdx &lt; toIdx ? -1 : 1;
+		var shrink = lastIdx &gt;= 0 &amp;&amp; step == 1 ? lastIdx &lt; toIdx : lastIdx &gt; toIdx;
+		var range = dojo.math.range(toIdx, fromIdx, step);
+		if(range.length) {
+			for(var i = range.length-1; i &gt;= 0; i--) {
+				var item = this.items[range[i]];
+				if(this.selectFilter(item, this.selection, false, true)) {
+					if(this.select(item, true) || shrink) {
+						this.lastSelected = item;
+					}
+					if(range[i] in toDeselect) {
+						delete toDeselect[range[i]];
+					}
+				}
+			}
+		} else {
+			this.lastSelected = fromItem;
+		}
+
+		// now deselect...
+		for(var i in toDeselect) {
+			if(this.items[i] == this.lastSelected) {
+				//dojo.debug(&quot;oops!&quot;);
+			}
+			this.deselect(this.items[i]);
+		}
+
+		// make sure everything is all kosher after selections+deselections
+		this._updatePivot();
+	},
+
+	/**
+	 * Grow selection upwards one item from lastSelected
+	**/
+	growUp: function() {
+		if(!this.isGrowable) { return; }
+
+		var idx = this._find(this.lastSelected) - 1;
+		while(idx &gt;= 0) {
+			if(this.selectFilter(this.items[idx], this.selection, false, true)) {
+				this.grow(this.items[idx]);
+				break;
+			}
+			idx--;
+		}
+	},
+
+	/**
+	 * Grow selection downwards one item from lastSelected
+	**/
+	growDown: function() {
+		if(!this.isGrowable) { return; }
+
+		var idx = this._find(this.lastSelected);
+		if(idx &lt; 0 &amp;&amp; this.allowImplicit) {
+			this.select(this.items[0]);
+			idx = 0;
+		}
+		idx++;
+		while(idx &gt; 0 &amp;&amp; idx &lt; this.items.length) {
+			if(this.selectFilter(this.items[idx], this.selection, false, true)) {
+				this.grow(this.items[idx]);
+				break;
+			}
+			idx++;
+		}
+	},
+
+	toggleSelected: function(item, noPivot) {
+		if(this.isItem(item)) {
+			if(this.select(item, noPivot)) { return 1; }
+			if(this.deselect(item)) { return -1; }
+		}
+		return 0;
+	},
+
+	select: function(item, noPivot) {
+		if(this.isItem(item) &amp;&amp; !this.isSelected(item)
+			&amp;&amp; this.isSelectable(item)) {
+			this.selection.push(item);
+			this.lastSelected = item;
+			this.onSelect(item);
+			this.onSelectChange(item, true);
+			if(!noPivot) {
+				this._addPivot(item);
+			}
+			return true;
+		}
+		return false;
+	},
+
+	deselect: function(item) {
+		var idx = this._find(item, true);
+		if(idx &gt; -1) {
+			this.selection.splice(idx, 1);
+			this.onDeselect(item);
+			this.onSelectChange(item, false);
+			if(item == this.lastSelected) {
+				this.lastSelected = null;
+			}
+
+			this._removePivot(item);
+
+			return true;
+		}
+		return false;
+	},
+
+	selectAll: function() {
+		for(var i = 0; i &lt; this.items.length; i++) {
+			this.select(this.items[i]);
+		}
+	},
+
+	deselectAll: function() {
+		while(this.selection &amp;&amp; this.selection.length) {
+			this.deselect(this.selection[0]);
+		}
+	},
+
+	selectNext: function() {
+		var idx = this._find(this.lastSelected);
+		while(idx &gt; -1 &amp;&amp; ++idx &lt; this.items.length) {
+			if(this.isSelectable(this.items[idx])) {
+				this.deselectAll();
+				this.select(this.items[idx]);
+				return true;
+			}
+		}
+		return false;
+	},
+
+	selectPrevious: function() {
+		//debugger;
+		var idx = this._find(this.lastSelected);
+		while(idx-- &gt; 0) {
+			if(this.isSelectable(this.items[idx])) {
+				this.deselectAll();
+				this.select(this.items[idx]);
+				return true;
+			}
+		}
+		return false;
+	},
+
+	// select first selectable item
+	selectFirst: function() {
+		this.deselectAll();
+		var idx = 0;
+		while(this.items[idx] &amp;&amp; !this.select(this.items[idx])) {
+			idx++;
+		}
+		return this.items[idx] ? true : false;
+	},
+
+	// select last selectable item
+	selectLast: function() {
+		this.deselectAll();
+		var idx = this.items.length-1;
+		while(this.items[idx] &amp;&amp; !this.select(this.items[idx])) {
+			idx--;
+		}
+		return this.items[idx] ? true : false;
+	},
+
+	_addPivot: function(item, andClear) {
+		this._pivotItem = item;
+		if(andClear) {
+			this._pivotItems = [item];
+		} else {
+			this._pivotItems.push(item);
+		}
+	},
+
+	_removePivot: function(item) {
+		var i = dojo.lang.find(item, this._pivotItems);
+		if(i &gt; -1) {
+			this._pivotItems.splice(i, 1);
+			this._pivotItem = this._pivotItems[this._pivotItems.length-1];
+		}
+
+		this._updatePivot();
+	},
+
+	_updatePivot: function() {
+		if(this._pivotItems.length == 0) {
+			if(this.lastSelected) {
+				this._addPivot(this.lastSelected);
+			}
+		}
+	},
+
+	sorted: function() {
+		return dojo.lang.toArray(this.selection).sort(
+			dojo.lang.hitch(this, function(a, b) {
+				var A = this._find(a), B = this._find(b);
+				if(A &gt; B) {
+					return 1;
+				} else if(A &lt; B) {
+					return -1;
+				} else {
+					return 0;
+				}
+			})
+		);
+	},
+
+	// remove any items from the selection that are no longer in this.items
+	updateSelected: function() {
+		for(var i = 0; i &lt; this.selection.length; i++) {
+			if(this._find(this.selection[i]) &lt; 0) {
+				var removed = this.selection.splice(i, 1);
+
+				this._removePivot(removed[0]);
+			}
+		}
+
+		this.length = this.selection.length;
+	}
+});

Added: trunk/root/static/magic/src/storage/Storage.as
===================================================================
--- trunk/root/static/magic/src/storage/Storage.as	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/storage/Storage.as	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,145 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+import DojoExternalInterface;
+
+class Storage {
+	public static var SUCCESS = &quot;success&quot;;
+	public static var FAILED = &quot;failed&quot;;
+	public static var PENDING = &quot;pending&quot;;
+	
+	public var so;
+	
+	public function Storage(){
+		//getURL(&quot;javascript:dojo.debug('FLASH:Storage constructor')&quot;);
+		DojoExternalInterface.initialize();
+		DojoExternalInterface.addCallback(&quot;put&quot;, this, put);
+		DojoExternalInterface.addCallback(&quot;get&quot;, this, get);
+		DojoExternalInterface.addCallback(&quot;showSettings&quot;, this, showSettings);
+		DojoExternalInterface.addCallback(&quot;clear&quot;, this, clear);
+		DojoExternalInterface.addCallback(&quot;getKeys&quot;, this, getKeys);
+		DojoExternalInterface.addCallback(&quot;remove&quot;, this, remove);
+		DojoExternalInterface.loaded();
+		
+		// preload the System Settings finished button movie for offline
+		// access so it is in the cache
+		_root.createEmptyMovieClip(&quot;_settingsBackground&quot;, 1);
+		_root._settingsBackground.loadMovie(DojoExternalInterface.dojoPath + &quot;storage_dialog.swf&quot;);
+	}
+
+	public function put(keyName, keyValue, namespace){
+		// Get the SharedObject for these values and save it
+		so = SharedObject.getLocal(namespace);
+		
+		// prepare a storage status handler
+		var self = this;
+		so.onStatus = function(infoObject:Object){
+			//getURL(&quot;javascript:dojo.debug('FLASH: onStatus, infoObject=&quot;+infoObject.code+&quot;')&quot;);
+			
+			// delete the data value if the request was denied
+			if (infoObject.code == &quot;SharedObject.Flush.Failed&quot;){
+				delete self.so.data[keyName];
+			}
+			
+			var statusResults;
+			if(infoObject.code == &quot;SharedObject.Flush.Failed&quot;){
+				statusResults = Storage.FAILED;
+			}else if(infoObject.code == &quot;SharedObject.Flush.Pending&quot;){
+				statusResults = Storage.PENDING;
+			}else if(infoObject.code == &quot;SharedObject.Flush.Success&quot;){
+				statusResults = Storage.SUCCESS;
+			}
+			//getURL(&quot;javascript:dojo.debug('FLASH: onStatus, statusResults=&quot;+statusResults+&quot;')&quot;);
+			
+			// give the status results to JavaScript
+			DojoExternalInterface.call(&quot;dojo.storage._onStatus&quot;, null, statusResults, 
+																 keyName);
+		}
+		
+		// save the key and value
+		so.data[keyName] = keyValue;
+		var flushResults = so.flush();
+		
+		// return results of this command to JavaScript
+		var statusResults;
+		if(flushResults == true){
+			statusResults = Storage.SUCCESS;
+		}else if(flushResults == &quot;pending&quot;){
+			statusResults = Storage.PENDING;
+		}else{
+			statusResults = Storage.FAILED;
+		}
+		
+		DojoExternalInterface.call(&quot;dojo.storage._onStatus&quot;, null, statusResults, 
+															 keyName);
+	}
+
+	public function get(keyName, namespace){
+		// Get the SharedObject for these values and save it
+		so = SharedObject.getLocal(namespace);
+		var results = so.data[keyName];
+		
+		return results;
+	}
+	
+	public function showSettings(){
+		// Show the configuration options for the Flash player, opened to the
+		// section for local storage controls (pane 1)
+		System.showSettings(1);
+		
+		// there is no way we can intercept when the Close button is pressed, allowing us
+		// to hide the Flash dialog. Instead, we need to load a movie in the
+		// background that we can show a close button on.
+		_root.createEmptyMovieClip(&quot;_settingsBackground&quot;, 1);
+		_root._settingsBackground.loadMovie(DojoExternalInterface.dojoPath + &quot;storage_dialog.swf&quot;);
+	}
+	
+	public function clear(namespace){
+		so = SharedObject.getLocal(namespace);
+		so.clear();
+		so.flush();
+	}
+	
+	public function getKeys(namespace){
+		// Returns a list of the available keys in this namespace
+		
+		// get the storage object
+		so = SharedObject.getLocal(namespace);
+		
+		// get all of the keys
+		var results = new Array();
+		for(var i in so.data)
+			results.push(i);	
+		
+		// join the keys together in a comma seperated string
+		results = results.join(&quot;,&quot;);
+		
+		return results;
+	}
+	
+	public function remove(keyName, namespace){
+		// Removes a key
+
+		// get the storage object
+		so = SharedObject.getLocal(namespace);
+		
+		// delete this value
+		delete so.data[keyName];
+		
+		// save the changes
+		so.flush();
+	}
+
+	static function main(mc){
+		//getURL(&quot;javascript:dojo.debug('FLASH: storage loaded')&quot;);
+		_root.app = new Storage(); 
+	}
+}
+

Added: trunk/root/static/magic/src/storage/__package__.js
===================================================================
--- trunk/root/static/magic/src/storage/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/storage/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,17 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.storage&quot;],
+	browser: [&quot;dojo.storage.browser&quot;],
+	dashboard: [&quot;dojo.storage.dashboard&quot;]
+});
+dojo.provide(&quot;dojo.storage.*&quot;);
+

Added: trunk/root/static/magic/src/storage/browser.js
===================================================================
--- trunk/root/static/magic/src/storage/browser.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/storage/browser.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,199 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.storage.browser&quot;);
+dojo.provide(&quot;dojo.storage.browser.FlashStorageProvider&quot;);
+
+dojo.require(&quot;dojo.storage&quot;);
+dojo.require(&quot;dojo.flash&quot;);
+dojo.require(&quot;dojo.json&quot;);
+dojo.require(&quot;dojo.uri.*&quot;);
+
+/** 
+		Storage provider that uses features in Flash to achieve permanent storage.
+		
+		@author Alex Russel, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">alex at dojotoolkit.org</A>
+		@author Brad Neuberg, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">bkn3 at columbia.edu</A> 
+*/
+dojo.storage.browser.FlashStorageProvider = function(){
+}
+
+dojo.inherits(dojo.storage.browser.FlashStorageProvider, dojo.storage);
+
+// instance methods and properties
+dojo.lang.extend(dojo.storage.browser.FlashStorageProvider, {
+	namespace: &quot;default&quot;,
+	initialized: false,
+	_available: null,
+	_statusHandler: null,
+	
+	initialize: function(){
+		if(djConfig[&quot;disableFlashStorage&quot;] == true){
+			return;
+		}
+		
+		// initialize our Flash
+		var loadedListener = function(){
+			dojo.storage._flashLoaded();
+		}
+		dojo.flash.addLoadedListener(loadedListener);
+		var swfloc6 = dojo.uri.dojoUri(&quot;Storage_version6.swf&quot;).toString();
+		var swfloc8 = dojo.uri.dojoUri(&quot;Storage_version8.swf&quot;).toString();
+		dojo.flash.setSwf({flash6: swfloc6, flash8: swfloc8, visible: false});
+	},
+	
+	isAvailable: function(){
+		if(djConfig[&quot;disableFlashStorage&quot;] == true){
+			this._available = false;
+		}
+		
+		return this._available;
+	},
+	
+	setNamespace: function(namespace){
+		this.namespace = namespace;
+	},
+
+	put: function(key, value, resultsHandler){
+		if(this.isValidKey(key) == false){
+			dojo.raise(&quot;Invalid key given: &quot; + key);
+		}
+			
+		this._statusHandler = resultsHandler;
+		
+		// serialize the value
+		// Handle strings differently so they have better performance
+		if(dojo.lang.isString(value)){
+			value = &quot;string:&quot; + value;
+		}else{
+			value = dojo.json.serialize(value);
+		}
+		
+		dojo.flash.comm.put(key, value, this.namespace);
+	},
+
+	get: function(key){
+		if(this.isValidKey(key) == false){
+			dojo.raise(&quot;Invalid key given: &quot; + key);
+		}
+		
+		var results = dojo.flash.comm.get(key, this.namespace);
+
+		if(results == &quot;&quot;){
+			return null;
+		}
+    
+		// destringify the content back into a 
+		// real JavaScript object
+		// Handle strings differently so they have better performance
+		if(!dojo.lang.isUndefined(results) &amp;&amp; results != null 
+			 &amp;&amp; /^string:/.test(results)){
+			results = results.substring(&quot;string:&quot;.length);
+		}else{
+			results = dojo.json.evalJson(results);
+		}
+    
+		return results;
+	},
+
+	getKeys: function(){
+		var results = dojo.flash.comm.getKeys(this.namespace);
+		
+		if(results == &quot;&quot;){
+			return new Array();
+		}
+
+		// the results are returned comma seperated; split them
+		results = results.split(&quot;,&quot;);
+		
+		return results;
+	},
+
+	clear: function(){
+		dojo.flash.comm.clear(this.namespace);
+	},
+	
+	remove: function(key){
+	},
+	
+	isPermanent: function(){
+		return true;
+	},
+
+	getMaximumSize: function(){
+		return dojo.storage.SIZE_NO_LIMIT;
+	},
+
+	hasSettingsUI: function(){
+		return true;
+	},
+
+	showSettingsUI: function(){
+		dojo.flash.comm.showSettings();
+		dojo.flash.obj.setVisible(true);
+		dojo.flash.obj.center();
+	},
+
+	hideSettingsUI: function(){
+		// hide the dialog
+		dojo.flash.obj.setVisible(false);
+		
+		// call anyone who wants to know the dialog is
+		// now hidden
+		if(dojo.storage.onHideSettingsUI != null &amp;&amp;
+			!dojo.lang.isUndefined(dojo.storage.onHideSettingsUI)){
+			dojo.storage.onHideSettingsUI.call(null);	
+		}
+	},
+	
+	/** 
+			The provider name as a string, such as 
+			&quot;dojo.storage.FlashStorageProvider&quot;. 
+	*/
+	getType: function(){
+		return &quot;dojo.storage.FlashStorageProvider&quot;;
+	},
+	
+	/** Called when the Flash is finished loading. */
+	_flashLoaded: function(){
+		this.initialized = true;
+
+		// indicate that this storage provider is now loaded
+		dojo.storage.manager.loaded();
+	},
+	
+	/** 
+			Called if the storage system needs to tell us about the status
+			of a put() request. 
+	*/
+	_onStatus: function(statusResult, key){
+		//dojo.debug(&quot;_onStatus, statusResult=&quot;+statusResult+&quot;, key=&quot;+key);
+		if(statusResult == dojo.storage.PENDING){
+			dojo.flash.obj.center();
+			dojo.flash.obj.setVisible(true);
+		}else{
+			dojo.flash.obj.setVisible(false);
+		}
+		
+		if(!dojo.lang.isUndefined(dojo.storage._statusHandler) 
+				&amp;&amp; dojo.storage._statusHandler != null){
+			dojo.storage._statusHandler.call(null, statusResult, key);		
+		}
+	}
+});
+
+// register the existence of our storage providers
+dojo.storage.manager.register(&quot;dojo.storage.browser.FlashStorageProvider&quot;,
+                              new dojo.storage.browser.FlashStorageProvider());
+
+// now that we are loaded and registered tell the storage manager to initialize
+// itself
+dojo.storage.manager.initialize();
+															

Added: trunk/root/static/magic/src/storage/dashboard.js
===================================================================
--- trunk/root/static/magic/src/storage/dashboard.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/storage/dashboard.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,52 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.storage&quot;);
+dojo.require(&quot;dojo.json&quot;);
+dojo.provide(&quot;dojo.storage.dashboard&quot;);
+
+dojo.storage.dashboard.StorageProvider = function(){
+	this.initialized = false;
+}
+
+dojo.inherits(dojo.storage.dashboard.StorageProvider, dojo.storage.StorageProvider);
+
+dojo.lang.extend(dojo.storage.dashboard.StorageProvider, {
+	storageOnLoad: function(){
+		this.initialized = true;
+	},
+
+	set: function(key, value, ns){
+		if (ns &amp;&amp; widget.system){
+			widget.system(&quot;/bin/mkdir &quot; + ns);
+			var system = widget.system(&quot;/bin/echo &quot; + value + &quot; &gt;&quot; + ns + &quot;/&quot; + key);
+			if(system.errorString){
+				return false;
+			}
+			return true;
+		}
+
+		return widget.setPreferenceForKey(dojo.json.serialize(value), key);
+	},
+
+	get: function(key, ns){
+		if (ns &amp;&amp; widget.system) {
+			var system = widget.system(&quot;/bin/cat &quot; + ns + &quot;/&quot; + key);
+			if(system.errorString){
+				return &quot;&quot;;
+			}
+			return system.outputString;
+		}
+
+		return dojo.json.evalJson(widget.preferenceForKey(key));
+	}
+});
+
+dojo.storage.setProvider(new dojo.storage.dashboard.StorageProvider());

Added: trunk/root/static/magic/src/storage/storage_dialog.fla
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/storage/storage_dialog.fla
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/root/static/magic/src/storage.js
===================================================================
--- trunk/root/static/magic/src/storage.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/storage.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,418 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/** 
+		FIXME: Write better docs.
+
+		@author Alex Russel, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">alex at dojotoolkit.org</A>
+		@author Brad Neuberg, <A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">bkn3 at columbia.edu</A> 
+*/
+dojo.provide(&quot;dojo.storage&quot;);
+dojo.provide(&quot;dojo.storage.StorageProvider&quot;);
+
+dojo.require(&quot;dojo.lang.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+
+/** The base class for all storage providers. */
+
+/** 
+	 The constructor for a storage provider. You should avoid initialization
+	 in the constructor; instead, define initialization in your initialize()
+	 method. 
+*/
+dojo.storage = function(){
+}
+
+dojo.lang.extend(dojo.storage, {
+	/** A put() call to a storage provider was succesful. */
+	SUCCESS: &quot;success&quot;,
+	
+	/** A put() call to a storage provider failed. */
+	FAILED: &quot;failed&quot;,
+	
+	/** A put() call to a storage provider is pending user approval. */
+	PENDING: &quot;pending&quot;,
+	
+	/** 
+	  Returned by getMaximumSize() if this storage provider can not determine
+	  the maximum amount of data it can support. 
+	*/
+	SIZE_NOT_AVAILABLE: &quot;Size not available&quot;,
+	
+	/**
+	  Returned by getMaximumSize() if this storage provider has no theoretical
+	  limit on the amount of data it can store. 
+	*/
+	SIZE_NO_LIMIT: &quot;No size limit&quot;,
+	
+	/** 
+	  The namespace for all storage operations. This is useful if
+	  several applications want access to the storage system from the same
+	  domain but want different storage silos. 
+	*/
+	namespace: &quot;dojoStorage&quot;,
+	
+	/**  
+	  If a function is assigned to this property, then 
+	  when the settings provider's UI is closed this
+	  function is called. Useful, for example, if the
+	  user has just cleared out all storage for this
+	  provider using the settings UI, and you want to 
+	  update your UI.
+	*/
+	onHideSettingsUI: null,
+
+	/** 
+	  Allows this storage provider to initialize itself. This is called
+	  after the page has finished loading, so you can not do document.writes(). 
+	*/
+	initialize: function(){
+	 dojo.unimplemented(&quot;dojo.storage.initialize&quot;);
+	},
+	
+	/** 
+	  Returns whether this storage provider is 
+	  available on this platform. 
+	
+	  @returns True or false if this storage 
+	  provider is supported.
+	*/
+	isAvailable: function(){
+		dojo.unimplemented(&quot;dojo.storage.isAvailable&quot;);
+	},
+	
+	/**
+	  Puts a key and value into this storage system.
+
+	  @param key A string key to use when retrieving 
+	         this value in the future.
+	  @param value A value to store; this can be 
+	         any JavaScript type.
+	  @param resultsHandler A callback function 
+	         that will receive three arguments.
+	         The first argument is one of three 
+	         values: dojo.storage.SUCCESS,
+	         dojo.storage.FAILED, or 
+	         dojo.storage.PENDING; these values 
+	         determine how the put request went. 
+	         In some storage systems users can deny
+	         a storage request, resulting in a 
+	         dojo.storage.FAILED, while in 
+	         other storage systems a storage 
+	         request must wait for user approval,
+	         resulting in a dojo.storage.PENDING 
+	         status until the request
+	         is either approved or denied, 
+	         resulting in another call back
+	         with dojo.storage.SUCCESS. 
+  
+	  The second argument in the call back is the key name
+	  that was being stored.
+	  
+	  The third argument in the call back is an 
+	  optional message that details possible error 
+	  messages that might have occurred during
+	  the storage process.
+
+	  Example:
+	    var resultsHandler = function(status, key, message){
+	      alert(&quot;status=&quot;+status+&quot;, key=&quot;+key+&quot;, message=&quot;+message);
+	    };
+	    dojo.storage.put(&quot;test&quot;, &quot;hello world&quot;, 
+	                     resultsHandler);	
+	*/
+	put: function(key, value, resultsHandler){ 
+    dojo.unimplemented(&quot;dojo.storage.put&quot;);
+  },
+
+	/**
+	  Gets the value with the given key. Returns null
+	  if this key is not in the storage system.
+	
+	  @param key A string key to get the value of.
+	  @returns Returns any JavaScript object type; 
+	  null if the key is not
+	  present. 
+	*/
+	get: function(key){
+    dojo.unimplemented(&quot;dojo.storage.get&quot;);
+  },
+
+	/**
+	  Determines whether the storage has the given 
+	  key. 
+	
+	    @returns Whether this key is 
+	             present or not. 
+	*/
+	hasKey: function(key){
+		if (this.get(key) != null)
+			return true;
+		else
+			return false;
+	},
+
+	/**
+	  Enumerates all of the available keys in 
+	  this storage system.
+	
+	  @returns Array of string keys in this 
+	           storage system.
+	*/
+	getKeys: function(){
+    dojo.unimplemented(&quot;dojo.storage.getKeys&quot;);
+  },
+
+	/**
+	  Completely clears this storage system of all 
+	  of it's values and keys. 
+	*/
+	clear: function(){
+    dojo.unimplemented(&quot;dojo.storage.clear&quot;);
+  },
+  
+  /** Removes the given key from the storage system. */
+  remove: function(key){
+  	dojo.unimplemented(&quot;dojo.storage.remove&quot;);
+  },
+
+	/**
+	  Returns whether this storage provider's 
+	  values are persisted when this platform 
+	  is shutdown. 
+	
+	  @returns True or false whether this 
+	  storage is permanent. 
+	*/
+	isPermanent: function(){
+		dojo.unimplemented(&quot;dojo.storage.isPermanent&quot;);
+	},
+
+	/**
+	  The maximum storage allowed by this provider.
+	
+	  @returns Returns the maximum storage size 
+	           supported by this provider, in 
+	           thousands of bytes (i.e., if it 
+	           returns 60 then this means that 60K 
+	           of storage is supported).
+	    
+	           If this provider can not determine 
+	           it's maximum size, then 
+	           dojo.storage.SIZE_NOT_AVAILABLE is 
+	           returned; if there is no theoretical
+	           limit on the amount of storage 
+	           this provider can return, then
+	           dojo.storage.SIZE_NO_LIMIT is 
+	           returned
+	*/
+	getMaximumSize: function(){
+    dojo.unimplemented(&quot;dojo.storage.getMaximumSize&quot;);
+  },
+
+	/**
+	  Determines whether this provider has a 
+	  settings UI.
+	
+	  @returns True or false if this provider has 
+	           the ability to show a
+	           a settings UI to change it's 
+	           values, change the amount of storage
+	           available, etc. 
+	*/
+	hasSettingsUI: function(){
+		return false;
+	},
+
+	/**
+	  If this provider has a settings UI, it is 
+	  shown. 
+	*/
+	showSettingsUI: function(){
+	 dojo.unimplemented(&quot;dojo.storage.showSettingsUI&quot;);
+	},
+
+	/**
+	  If this provider has a settings UI, hides
+	  it.
+	*/
+	hideSettingsUI: function(){
+	 dojo.unimplemented(&quot;dojo.storage.hideSettingsUI&quot;);
+	},
+	
+	/** 
+	  The provider name as a string, such as 
+	  &quot;dojo.storage.FlashStorageProvider&quot;. 
+	*/
+	getType: function(){
+		dojo.unimplemented(&quot;dojo.storage.getType&quot;);
+	},
+	
+	/**
+	  Subclasses can call this to ensure that the key given is valid in a
+	  consistent way across different storage providers. We use the lowest
+	  common denominator for key values allowed: only letters, numbers, and
+	  underscores are allowed. No spaces. 
+	*/
+	isValidKey: function(keyName){
+		if (keyName == null || typeof keyName == &quot;undefined&quot;)
+			return false;
+			
+		return /^[0-9A-Za-z_]*$/.test(keyName);
+  }
+});
+
+
+
+
+/**
+	Initializes the storage systems and figures out the best available 
+	storage options on this platform.
+*/
+dojo.storage.manager = new function(){
+	this.currentProvider = null;
+	this.available = false;
+	this.initialized = false;
+	this.providers = new Array();
+	
+	// TODO: Provide a way for applications to override the default namespace
+	this.namespace = &quot;dojo.storage&quot;;
+	
+	/** Initializes the storage system. */
+	this.initialize = function(){
+		// autodetect the best storage provider we can provide on this platform
+		this.autodetect();
+	}
+	
+	/**
+	  Registers the existence of a new storage provider; used by subclasses
+	  to inform the manager of their existence. 
+	
+	  @param name The full class name of this provider, such as 
+	  &quot;dojo.storage.browser.Flash6StorageProvider&quot;.
+	  @param instance An instance of this provider, which we will use to
+	  call isAvailable() on. 
+	*/
+	this.register = function(name, instance) {
+		this.providers[this.providers.length] = instance;
+		this.providers[name] = instance;
+	}
+	
+	/**
+	  Instructs the storageManager to use 
+	  the given storage class for all storage requests.
+	    
+	  Example:
+	    
+	  dojo.storage.setProvider(
+	         dojo.storage.browser.IEStorageProvider)
+	*/
+	this.setProvider = function(storageClass){
+	
+	}
+	
+	/** 
+	  Autodetects the best possible persistent
+	  storage provider available on this platform. 
+	*/
+	this.autodetect = function(){
+		if(this.initialized == true) // already finished
+			return;
+			
+		// go through each provider, seeing if it can be used
+		var providerToUse = null;
+		for(var i = 0; i &lt; this.providers.length; i++) {
+			providerToUse = this.providers[i];
+			if(providerToUse.isAvailable()){
+				break;
+			}
+		}	
+		
+		if(providerToUse == null){ // no provider available
+			this.initialized = true;
+			this.available = false;
+			this.currentProvider = null;
+			dojo.raise(&quot;No storage provider found for this platform&quot;);
+		}
+			
+		// create this provider and copy over it's properties
+		this.currentProvider = providerToUse;
+	  	for(var i in providerToUse){
+	  		dojo.storage[i] = providerToUse[i];
+		}
+		dojo.storage.manager = this;
+		
+		// have the provider initialize itself
+		dojo.storage.initialize();
+		
+		this.initialized = true;
+		this.available = true;
+	}
+	
+	/** Returns whether any storage options are available. */
+	this.isAvailable = function(){
+		return this.available;
+	}
+	
+	/** 
+	 	Returns whether the storage system is initialized and
+	 	ready to be used. 
+	*/
+	this.isInitialized = function(){
+		// FIXME: This should _really_ not be in here, but it fixes a bug
+		if(dojo.flash.ready == false){
+			return false;
+		}else{
+			return this.initialized;
+		}
+	}
+
+	/**
+	  Determines if this platform supports
+	  the given storage provider.
+	
+	  Example:
+			
+	  dojo.storage.manager.supportsProvider(
+	    &quot;dojo.storage.browser.InternetExplorerStorageProvider&quot;);
+	*/
+	this.supportsProvider = function(storageClass){
+		// construct this class dynamically
+		try{
+			// dynamically call the given providers class level isAvailable()
+			// method
+			var provider = eval(&quot;new &quot; + storageClass + &quot;()&quot;);
+			var results = provider.isAvailable();
+			if(results == null || typeof results == &quot;undefined&quot;)
+				return false;
+			return results;
+		}catch (exception){
+			dojo.debug(&quot;exception=&quot;+exception);
+			return false;
+		}
+	}
+
+	/** Gets the current provider. */
+	this.getProvider = function(){
+		return this.currentProvider;
+	}
+	
+	/** 
+	  The storage provider should call this method when it is loaded and
+	  ready to be used. Clients who will use the provider will connect
+	  to this method to know when they can use the storage system:
+	
+	  dojo.connect(dojo.storage.manager, &quot;loaded&quot;, someInstance, 
+	               someInstance.someMethod);
+	*/
+	this.loaded = function(){
+	}
+}

Added: trunk/root/static/magic/src/string/Builder.js
===================================================================
--- trunk/root/static/magic/src/string/Builder.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/string/Builder.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,105 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.string.Builder&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+// NOTE: testing shows that direct &quot;+=&quot; concatenation is *much* faster on
+// Spidermoneky and Rhino, while arr.push()/arr.join() style concatenation is
+// significantly quicker on IE (Jscript/wsh/etc.).
+
+dojo.string.Builder = function(str){
+	this.arrConcat = (dojo.render.html.capable &amp;&amp; dojo.render.html[&quot;ie&quot;]);
+
+	var a = [];
+	var b = str || &quot;&quot;;
+	var length = this.length = b.length;
+
+	if(this.arrConcat){
+		if(b.length &gt; 0){
+			a.push(b);
+		}
+		b = &quot;&quot;;
+	}
+
+	this.toString = this.valueOf = function(){ 
+		return (this.arrConcat) ? a.join(&quot;&quot;) : b;
+	};
+
+	this.append = function(s){
+		if(this.arrConcat){
+			a.push(s);
+		}else{
+			b+=s;
+		}
+		length += s.length;
+		this.length = length;
+		return this;
+	};
+
+	this.clear = function(){
+		a = [];
+		b = &quot;&quot;;
+		length = this.length = 0;
+		return this;
+	};
+
+	this.remove = function(f,l){
+		var s = &quot;&quot;; 
+		if(this.arrConcat){
+			b = a.join(&quot;&quot;); 
+		}
+		a=[];
+		if(f&gt;0){
+			s = b.substring(0, (f-1));
+		}
+		b = s + b.substring(f + l); 
+		length = this.length = b.length; 
+		if(this.arrConcat){
+			a.push(b);
+			b=&quot;&quot;;
+		}
+		return this;
+	};
+
+	this.replace = function(o,n){
+		if(this.arrConcat){
+			b = a.join(&quot;&quot;); 
+		}
+		a = []; 
+		b = b.replace(o,n); 
+		length = this.length = b.length; 
+		if(this.arrConcat){
+			a.push(b);
+			b=&quot;&quot;;
+		}
+		return this;
+	};
+
+	this.insert = function(idx,s){
+		if(this.arrConcat){
+			b = a.join(&quot;&quot;); 
+		}
+		a=[];
+		if(idx == 0){
+			b = s + b;
+		}else{
+			var t = b.split(&quot;&quot;);
+			t.splice(idx,0,s);
+			b = t.join(&quot;&quot;)
+		}
+		length = this.length = b.length; 
+		if(this.arrConcat){
+			a.push(b); 
+			b=&quot;&quot;;
+		}
+		return this;
+	};
+};

Added: trunk/root/static/magic/src/string/__package__.js
===================================================================
--- trunk/root/static/magic/src/string/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/string/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,19 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.string&quot;,
+		&quot;dojo.string.common&quot;,
+		&quot;dojo.string.extras&quot;,
+		&quot;dojo.string.Builder&quot;
+	]
+});
+dojo.provide(&quot;dojo.string.*&quot;);

Added: trunk/root/static/magic/src/string/common.js
===================================================================
--- trunk/root/static/magic/src/string/common.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/string/common.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,87 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.string.common&quot;);
+
+dojo.require(&quot;dojo.string&quot;);
+
+/**
+ * Trim whitespace from 'str'. If 'wh' &gt; 0,
+ * only trim from start, if 'wh' &lt; 0, only trim
+ * from end, otherwise trim both ends
+ */
+dojo.string.trim = function(str, wh){
+	if(!str.replace){ return str; }
+	if(!str.length){ return str; }
+	var re = (wh &gt; 0) ? (/^\s+/) : (wh &lt; 0) ? (/\s+$/) : (/^\s+|\s+$/g);
+	return str.replace(re, &quot;&quot;);
+}
+
+/**
+ * Trim whitespace at the beginning of 'str'
+ */
+dojo.string.trimStart = function(str) {
+	return dojo.string.trim(str, 1);
+}
+
+/**
+ * Trim whitespace at the end of 'str'
+ */
+dojo.string.trimEnd = function(str) {
+	return dojo.string.trim(str, -1);
+}
+
+/**
+ * Return 'str' repeated 'count' times, optionally
+ * placing 'separator' between each rep
+ */
+dojo.string.repeat = function(str, count, separator) {
+	var out = &quot;&quot;;
+	for(var i = 0; i &lt; count; i++) {
+		out += str;
+		if(separator &amp;&amp; i &lt; count - 1) {
+			out += separator;
+		}
+	}
+	return out;
+}
+
+/**
+ * Pad 'str' to guarantee that it is at least 'len' length
+ * with the character 'c' at either the start (dir=1) or
+ * end (dir=-1) of the string
+ */
+dojo.string.pad = function(str, len/*=2*/, c/*='0'*/, dir/*=1*/) {
+	var out = String(str);
+	if(!c) {
+		c = '0';
+	}
+	if(!dir) {
+		dir = 1;
+	}
+	while(out.length &lt; len) {
+		if(dir &gt; 0) {
+			out = c + out;
+		} else {
+			out += c;
+		}
+	}
+	return out;
+}
+
+/** same as dojo.string.pad(str, len, c, 1) */
+dojo.string.padLeft = function(str, len, c) {
+	return dojo.string.pad(str, len, c, 1);
+}
+
+/** same as dojo.string.pad(str, len, c, -1) */
+dojo.string.padRight = function(str, len, c) {
+	return dojo.string.pad(str, len, c, -1);
+}

Added: trunk/root/static/magic/src/string/extras.js
===================================================================
--- trunk/root/static/magic/src/string/extras.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/string/extras.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,237 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.string.extras&quot;);
+
+dojo.require(&quot;dojo.string.common&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+/**
+ * Performs parameterized substitutions on a string.  For example,
+ *   dojo.string.substituteParams(&quot;File '%{0}' is not found in directory '%{1}'.&quot;,&quot;foo.html&quot;,&quot;/temp&quot;);
+ * returns
+ *   &quot;File 'foo.html' is not found in directory '/temp'.&quot;
+ * 
+ * @param template the original string template with %{values} to be replaced
+ * @param hash name/value pairs (type object) to provide substitutions.  Alternatively, substitutions may be
+ *  included as arguments 1..n to this function, corresponding to template parameters 0..n-1
+ * @return the completed string. Throws an exception if any parameter is unmatched
+ */
+//TODO: use ${} substitution syntax instead, like widgets do?
+dojo.string.substituteParams = function(template /*string */, hash /* object - optional or ... */) {
+	var map = (typeof hash == 'object') ? hash : dojo.lang.toArray(arguments, 1);
+
+	return template.replace(/\%\{(\w+)\}/g, function(match, key){
+		return map[key] || dojo.raise(&quot;Substitution not found: &quot; + key);
+	});
+};
+
+/**
+ * Parameterized string function
+ * str - formatted string with %{values} to be replaces
+ * pairs - object of name: &quot;value&quot; value pairs
+ * killExtra - remove all remaining %{values} after pairs are inserted
+ */
+dojo.string.paramString = function(str, pairs, killExtra) {
+	dojo.deprecated(&quot;dojo.string.paramString&quot;,
+		&quot;use dojo.string.substituteParams instead&quot;, &quot;0.4&quot;);
+
+	for(var name in pairs) {
+		var re = new RegExp(&quot;\\%\\{&quot; + name + &quot;\\}&quot;, &quot;g&quot;);
+		str = str.replace(re, pairs[name]);
+	}
+
+	if(killExtra) { str = str.replace(/%\{([^\}\s]+)\}/g, &quot;&quot;); }
+	return str;
+}
+
+/** Uppercases the first letter of each word */
+dojo.string.capitalize = function (str) {
+	if (!dojo.lang.isString(str)) { return &quot;&quot;; }
+	if (arguments.length == 0) { str = this; }
+
+	var words = str.split(' ');
+	for(var i=0; i&lt;words.length; i++){
+		words[i] = words[i].charAt(0).toUpperCase() + words[i].substring(1);
+	}
+	return words.join(&quot; &quot;);
+}
+
+/**
+ * Return true if the entire string is whitespace characters
+ */
+dojo.string.isBlank = function (str) {
+	if(!dojo.lang.isString(str)) { return true; }
+	return (dojo.string.trim(str).length == 0);
+}
+
+dojo.string.encodeAscii = function(str) {
+	if(!dojo.lang.isString(str)) { return str; }
+	var ret = &quot;&quot;;
+	var value = escape(str);
+	var match, re = /%u([0-9A-F]{4})/i;
+	while((match = value.match(re))) {
+		var num = Number(&quot;0x&quot;+match[1]);
+		var newVal = escape(&quot;&amp;#&quot; + num + &quot;;&quot;);
+		ret += value.substring(0, match.index) + newVal;
+		value = value.substring(match.index+match[0].length);
+	}
+	ret += value.replace(/\+/g, &quot;%2B&quot;);
+	return ret;
+}
+
+dojo.string.escape = function(type, str) {
+	var args = dojo.lang.toArray(arguments, 1);
+	switch(type.toLowerCase()) {
+		case &quot;xml&quot;:
+		case &quot;html&quot;:
+		case &quot;xhtml&quot;:
+			return dojo.string.escapeXml.apply(this, args);
+		case &quot;sql&quot;:
+			return dojo.string.escapeSql.apply(this, args);
+		case &quot;regexp&quot;:
+		case &quot;regex&quot;:
+			return dojo.string.escapeRegExp.apply(this, args);
+		case &quot;javascript&quot;:
+		case &quot;jscript&quot;:
+		case &quot;js&quot;:
+			return dojo.string.escapeJavaScript.apply(this, args);
+		case &quot;ascii&quot;:
+			// so it's encode, but it seems useful
+			return dojo.string.encodeAscii.apply(this, args);
+		default:
+			return str;
+	}
+}
+
+dojo.string.escapeXml = function(str, noSingleQuotes) {
+	str = str.replace(/&amp;/gm, &quot;&amp;&quot;).replace(/&lt;/gm, &quot;&lt;&quot;)
+		.replace(/&gt;/gm, &quot;&gt;&quot;).replace(/&quot;/gm, &quot;&quot;&quot;);
+	if(!noSingleQuotes) { str = str.replace(/'/gm, &quot;&#39;&quot;); }
+	return str;
+}
+
+dojo.string.escapeSql = function(str) {
+	return str.replace(/'/gm, &quot;''&quot;);
+}
+
+dojo.string.escapeRegExp = function(str) {
+	return str.replace(/\\/gm, &quot;\\\\&quot;).replace(/([\f\b\n\t\r[\^$|?*+(){}])/gm, &quot;\\$1&quot;);
+}
+
+dojo.string.escapeJavaScript = function(str) {
+	return str.replace(/([&quot;'\f\b\n\t\r])/gm, &quot;\\$1&quot;);
+}
+
+dojo.string.escapeString = function(str){ 
+	return ('&quot;' + str.replace(/([&quot;\\])/g, '\\$1') + '&quot;'
+		).replace(/[\f]/g, &quot;\\f&quot;
+		).replace(/[\b]/g, &quot;\\b&quot;
+		).replace(/[\n]/g, &quot;\\n&quot;
+		).replace(/[\t]/g, &quot;\\t&quot;
+		).replace(/[\r]/g, &quot;\\r&quot;);
+}
+
+// TODO: make an HTML version
+dojo.string.summary = function(str, len) {
+	if(!len || str.length &lt;= len) {
+		return str;
+	} else {
+		return str.substring(0, len).replace(/\.+$/, &quot;&quot;) + &quot;...&quot;;
+	}
+}
+
+/**
+ * Returns true if 'str' ends with 'end'
+ */
+dojo.string.endsWith = function(str, end, ignoreCase) {
+	if(ignoreCase) {
+		str = str.toLowerCase();
+		end = end.toLowerCase();
+	}
+	if((str.length - end.length) &lt; 0){
+		return false;
+	}
+	return str.lastIndexOf(end) == str.length - end.length;
+}
+
+/**
+ * Returns true if 'str' ends with any of the arguments[2 -&gt; n]
+ */
+dojo.string.endsWithAny = function(str /* , ... */) {
+	for(var i = 1; i &lt; arguments.length; i++) {
+		if(dojo.string.endsWith(str, arguments[i])) {
+			return true;
+		}
+	}
+	return false;
+}
+
+/**
+ * Returns true if 'str' starts with 'start'
+ */
+dojo.string.startsWith = function(str, start, ignoreCase) {
+	if(ignoreCase) {
+		str = str.toLowerCase();
+		start = start.toLowerCase();
+	}
+	return str.indexOf(start) == 0;
+}
+
+/**
+ * Returns true if 'str' starts with any of the arguments[2 -&gt; n]
+ */
+dojo.string.startsWithAny = function(str /* , ... */) {
+	for(var i = 1; i &lt; arguments.length; i++) {
+		if(dojo.string.startsWith(str, arguments[i])) {
+			return true;
+		}
+	}
+	return false;
+}
+
+/**
+ * Returns true if 'str' contains any of the arguments 2 -&gt; n
+ */
+dojo.string.has = function(str /* , ... */) {
+	for(var i = 1; i &lt; arguments.length; i++) {
+		if(str.indexOf(arguments[i]) &gt; -1){
+			return true;
+		}
+	}
+	return false;
+}
+
+dojo.string.normalizeNewlines = function (text,newlineChar) {
+	if (newlineChar == &quot;\n&quot;) {
+		text = text.replace(/\r\n/g, &quot;\n&quot;);
+		text = text.replace(/\r/g, &quot;\n&quot;);
+	} else if (newlineChar == &quot;\r&quot;) {
+		text = text.replace(/\r\n/g, &quot;\r&quot;);
+		text = text.replace(/\n/g, &quot;\r&quot;);
+	} else {
+		text = text.replace(/([^\r])\n/g, &quot;$1\r\n&quot;);
+		text = text.replace(/\r([^\n])/g, &quot;\r\n$1&quot;);
+	}
+	return text;
+}
+
+dojo.string.splitEscaped = function (str,charac) {
+	var components = [];
+	for (var i = 0, prevcomma = 0; i &lt; str.length; i++) {
+		if (str.charAt(i) == '\\') { i++; continue; }
+		if (str.charAt(i) == charac) {
+			components.push(str.substring(prevcomma, i));
+			prevcomma = i + 1;
+		}
+	}
+	components.push(str.substr(prevcomma));
+	return components;
+}

Added: trunk/root/static/magic/src/string.js
===================================================================
--- trunk/root/static/magic/src/string.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/string.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.string.common&quot;);

Added: trunk/root/static/magic/src/style.js
===================================================================
--- trunk/root/static/magic/src/style.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/style.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,826 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.uri.Uri&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+
+(function(){
+	var h = dojo.render.html;
+	var ds = dojo.style;
+	var db = document[&quot;body&quot;]||document[&quot;documentElement&quot;];
+
+	ds.boxSizing = {
+		MARGIN_BOX: &quot;margin-box&quot;,
+		BORDER_BOX: &quot;border-box&quot;,
+		PADDING_BOX: &quot;padding-box&quot;,
+		CONTENT_BOX: &quot;content-box&quot;
+	};
+	var bs = ds.boxSizing;
+	
+	ds.getBoxSizing = function(node){
+		if((h.ie)||(h.opera)){ 
+			var cm = document[&quot;compatMode&quot;];
+			if((cm == &quot;BackCompat&quot;)||(cm == &quot;QuirksMode&quot;)){ 
+				return bs.BORDER_BOX; 
+			}else{
+				return bs.CONTENT_BOX; 
+			}
+		}else{
+			if(arguments.length == 0){ node = document.documentElement; }
+			var sizing = ds.getStyle(node, &quot;-moz-box-sizing&quot;);
+			if(!sizing){ sizing = ds.getStyle(node, &quot;box-sizing&quot;); }
+			return (sizing ? sizing : bs.CONTENT_BOX);
+		}
+	}
+
+	/*
+
+	The following several function use the dimensions shown below
+
+		+-------------------------+
+		|  margin                 |
+		| +---------------------+ |
+		| |  border             | |
+		| | +-----------------+ | |
+		| | |  padding        | | |
+		| | | +-------------+ | | |
+		| | | |   content   | | | |
+		| | | +-------------+ | | |
+		| | +-|-------------|-+ | |
+		| +-|-|-------------|-|-+ |
+		+-|-|-|-------------|-|-|-+
+		| | | |             | | | |
+		| | | |&lt;- content -&gt;| | | |
+		| |&lt;------ inner ------&gt;| |
+		|&lt;-------- outer --------&gt;|
+		+-------------------------+
+
+		* content-box
+
+		|m|b|p|             |p|b|m|
+		| |&lt;------ offset -----&gt;| |
+		| | |&lt;---- client ---&gt;| | |
+		| | | |&lt;-- width --&gt;| | | |
+
+		* border-box
+
+		|m|b|p|             |p|b|m|
+		| |&lt;------ offset -----&gt;| |
+		| | |&lt;---- client ---&gt;| | |
+		| |&lt;------ width ------&gt;| |
+	*/
+
+	/*
+		Notes:
+
+		General:
+			- Uncomputable values are returned as NaN.
+			- setOuterWidth/Height return *false* if the outer size could not
+			  be computed, otherwise *true*.
+			- (sjmiles) knows no way to find the calculated values for auto-margins. 
+			- All returned values are floating point in 'px' units. If a
+			  non-zero computed style value is not specified in 'px', NaN is
+			  returned.
+
+		FF:
+			- styles specified as '0' (unitless 0) show computed as '0pt'.
+
+		IE:
+			- clientWidth/Height are unreliable (0 unless the object has 'layout').
+			- margins must be specified in px, or 0 (in any unit) for any
+			  sizing function to work. Otherwise margins detect as 'auto'.
+			- padding can be empty or, if specified, must be in px, or 0 (in
+			  any unit) for any sizing function to work.
+
+		Safari:
+			- Safari defaults padding values to 'auto'.
+
+		See the unit tests for examples of (un)computable values in a given browser.
+
+	*/
+
+	// FIXME: these work for some elements (e.g. DIV) but not others (e.g. TABLE, TEXTAREA)
+
+	ds.isBorderBox = function(node){
+		return (ds.getBoxSizing(node) == bs.BORDER_BOX);
+	}
+
+	ds.getUnitValue = function(node, cssSelector, autoIsZero){
+		var s = ds.getComputedStyle(node, cssSelector);
+		if((!s)||((s == 'auto')&amp;&amp;(autoIsZero))){ return { value: 0, units: 'px' }; }
+		if(dojo.lang.isUndefined(s)){return ds.getUnitValue.bad;}
+		// FIXME: is regex inefficient vs. parseInt or some manual test? 
+		var match = s.match(/(\-?[\d.]+)([a-z%]*)/i);
+		if (!match){return ds.getUnitValue.bad;}
+		return { value: Number(match[1]), units: match[2].toLowerCase() };
+	}
+	// FIXME: 'bad' value should be 0?
+	ds.getUnitValue.bad = { value: NaN, units: '' };
+	
+	ds.getPixelValue = function(node, cssSelector, autoIsZero){
+		var result = ds.getUnitValue(node, cssSelector, autoIsZero);
+		// FIXME: there is serious debate as to whether or not this is the right solution
+		if(isNaN(result.value)){ return 0; }
+		// FIXME: code exists for converting other units to px (see Dean Edward's IE7) 
+		// but there are cross-browser complexities
+		if((result.value)&amp;&amp;(result.units != 'px')){ return NaN; }
+		return result.value;
+	}
+	
+	// FIXME: deprecated
+	ds.getNumericStyle = function() {
+		dojo.deprecated('dojo.(style|html).getNumericStyle', 'in favor of dojo.(style|html).getPixelValue', '0.4');
+		return ds.getPixelValue.apply(this, arguments); 
+	}
+
+	ds.setPositivePixelValue = function(node, selector, value){
+		if(isNaN(value)){return false;}
+		node.style[selector] = Math.max(0, value) + 'px'; 
+		return true;
+	}
+	
+	ds._sumPixelValues = function(node, selectors, autoIsZero){
+		var total = 0;
+		for(var x=0; x&lt;selectors.length; x++){
+			total += ds.getPixelValue(node, selectors[x], autoIsZero);
+		}
+		return total;
+	}
+
+	ds.isPositionAbsolute = function(node){
+		return (ds.getComputedStyle(node, 'position') == 'absolute');
+	}
+
+	ds.getBorderExtent = function(node, side){
+		return (ds.getStyle(node, 'border-' + side + '-style') == 'none' ? 0 : ds.getPixelValue(node, 'border-' + side + '-width'));
+	}
+
+	ds.getMarginWidth = function(node){
+		return ds._sumPixelValues(node, [&quot;margin-left&quot;, &quot;margin-right&quot;], ds.isPositionAbsolute(node));
+	}
+
+	ds.getBorderWidth = function(node){
+		return ds.getBorderExtent(node, 'left') + ds.getBorderExtent(node, 'right');
+	}
+
+	ds.getPaddingWidth = function(node){
+		return ds._sumPixelValues(node, [&quot;padding-left&quot;, &quot;padding-right&quot;], true);
+	}
+
+	ds.getPadBorderWidth = function(node) {
+		return ds.getPaddingWidth(node) + ds.getBorderWidth(node);
+	}
+	
+	ds.getContentBoxWidth = function(node){
+		node = dojo.byId(node);
+		return node.offsetWidth - ds.getPadBorderWidth(node);
+	}
+
+	ds.getBorderBoxWidth = function(node){
+		node = dojo.byId(node);
+		return node.offsetWidth;
+	}
+
+	ds.getMarginBoxWidth = function(node){
+		return ds.getInnerWidth(node) + ds.getMarginWidth(node);
+	}
+
+	ds.setContentBoxWidth = function(node, pxWidth){
+		node = dojo.byId(node);
+		if (ds.isBorderBox(node)){
+			pxWidth += ds.getPadBorderWidth(node);
+		}
+		return ds.setPositivePixelValue(node, &quot;width&quot;, pxWidth);
+	}
+
+	ds.setMarginBoxWidth = function(node, pxWidth){
+		node = dojo.byId(node);
+		if (!ds.isBorderBox(node)){
+			pxWidth -= ds.getPadBorderWidth(node);
+		}
+		pxWidth -= ds.getMarginWidth(node);
+		return ds.setPositivePixelValue(node, &quot;width&quot;, pxWidth);
+	}
+
+	// FIXME: deprecate and remove
+	ds.getContentWidth = ds.getContentBoxWidth;
+	ds.getInnerWidth = ds.getBorderBoxWidth;
+	ds.getOuterWidth = ds.getMarginBoxWidth;
+	ds.setContentWidth = ds.setContentBoxWidth;
+	ds.setOuterWidth = ds.setMarginBoxWidth;
+
+	ds.getMarginHeight = function(node){
+		return ds._sumPixelValues(node, [&quot;margin-top&quot;, &quot;margin-bottom&quot;], ds.isPositionAbsolute(node));
+	}
+
+	ds.getBorderHeight = function(node){
+		return ds.getBorderExtent(node, 'top') + ds.getBorderExtent(node, 'bottom');
+	}
+
+	ds.getPaddingHeight = function(node){
+		return ds._sumPixelValues(node, [&quot;padding-top&quot;, &quot;padding-bottom&quot;], true);
+	}
+
+	ds.getPadBorderHeight = function(node) {
+		return ds.getPaddingHeight(node) + ds.getBorderHeight(node);
+	}
+	
+	ds.getContentBoxHeight = function(node){
+		node = dojo.byId(node);
+		return node.offsetHeight - ds.getPadBorderHeight(node);
+	}
+
+	ds.getBorderBoxHeight = function(node){
+		node = dojo.byId(node);
+		return node.offsetHeight; // FIXME: does this work?
+	}
+
+	ds.getMarginBoxHeight = function(node){
+		return ds.getInnerHeight(node) + ds.getMarginHeight(node);
+	}
+
+	ds.setContentBoxHeight = function(node, pxHeight){
+		node = dojo.byId(node);
+		if (ds.isBorderBox(node)){
+			pxHeight += ds.getPadBorderHeight(node);
+		}
+		return ds.setPositivePixelValue(node, &quot;height&quot;, pxHeight);
+	}
+
+	ds.setMarginBoxHeight = function(node, pxHeight){
+		node = dojo.byId(node);
+		if (!ds.isBorderBox(node)){
+			pxHeight -= ds.getPadBorderHeight(node);
+		}
+		pxHeight -= ds.getMarginHeight(node);
+		return ds.setPositivePixelValue(node, &quot;height&quot;, pxHeight);
+	}
+
+	// FIXME: deprecate and remove
+	ds.getContentHeight = ds.getContentBoxHeight;
+	ds.getInnerHeight = ds.getBorderBoxHeight;
+	ds.getOuterHeight = ds.getMarginBoxHeight;
+	ds.setContentHeight = ds.setContentBoxHeight;
+	ds.setOuterHeight = ds.setMarginBoxHeight;
+
+	/**
+	 * dojo.style.getAbsolutePosition(xyz, true) returns xyz's position relative to the document.
+	 * Itells you where you would position a node
+	 * inside document.body such that it was on top of xyz.  Most people set the flag to true when calling
+	 * getAbsolutePosition().
+	 *
+	 * dojo.style.getAbsolutePosition(xyz, false) returns xyz's position relative to the viewport.
+	 * It returns the position that would be returned
+	 * by event.clientX/Y if the mouse were directly over the top/left of this node.
+	 */
+	ds.getAbsolutePosition = ds.abs = function(node, includeScroll){
+		node = dojo.byId(node);
+		var ret = [];
+		ret.x = ret.y = 0;
+		var st = dojo.html.getScrollTop();
+		var sl = dojo.html.getScrollLeft();
+
+		if(h.ie){
+			with(node.getBoundingClientRect()){
+				ret.x = left-2;
+				ret.y = top-2;
+			}
+		}else if(document.getBoxObjectFor){
+			// mozilla
+			var bo = document.getBoxObjectFor(node);
+			ret.x = bo.x - ds.sumAncestorProperties(node, &quot;scrollLeft&quot;);
+			ret.y = bo.y - ds.sumAncestorProperties(node, &quot;scrollTop&quot;);
+		}else{
+			if(node[&quot;offsetParent&quot;]){
+				var endNode;		
+				// in Safari, if the node is an absolutely positioned child of
+				// the body and the body has a margin the offset of the child
+				// and the body contain the body's margins, so we need to end
+				// at the body
+				if(	(h.safari)&amp;&amp;
+					(node.style.getPropertyValue(&quot;position&quot;) == &quot;absolute&quot;)&amp;&amp;
+					(node.parentNode == db)){
+					endNode = db;
+				}else{
+					endNode = db.parentNode;
+				}
+
+				if(node.parentNode != db){
+					var nd = node;
+					if(window.opera){ nd = db; }
+					ret.x -= ds.sumAncestorProperties(nd, &quot;scrollLeft&quot;);
+					ret.y -= ds.sumAncestorProperties(nd, &quot;scrollTop&quot;);
+				}
+				do{
+					var n = node[&quot;offsetLeft&quot;];
+					ret.x += isNaN(n) ? 0 : n;
+					var m = node[&quot;offsetTop&quot;];
+					ret.y += isNaN(m) ? 0 : m;
+					node = node.offsetParent;
+				}while((node != endNode)&amp;&amp;(node != null));
+			}else if(node[&quot;x&quot;]&amp;&amp;node[&quot;y&quot;]){
+				ret.x += isNaN(node.x) ? 0 : node.x;
+				ret.y += isNaN(node.y) ? 0 : node.y;
+			}
+		}
+
+		// account for document scrolling!
+		if(includeScroll){
+			ret.y += st;
+			ret.x += sl;
+		}
+
+		ret[0] = ret.x;
+		ret[1] = ret.y;
+		return ret;
+	}
+
+	ds.sumAncestorProperties = function(node, prop){
+		node = dojo.byId(node);
+		if(!node){ return 0; } // FIXME: throw an error?
+		
+		var retVal = 0;
+		while(node){
+			var val = node[prop];
+			if(val){
+				retVal += val - 0;
+				if(node==document.body){ break; }// opera and khtml #body &amp; #html has the same values, we only need one value
+			}
+			node = node.parentNode;
+		}
+		return retVal;
+	}
+
+	ds.getTotalOffset = function(node, type, includeScroll){
+		return ds.abs(node, includeScroll)[(type == &quot;top&quot;) ? &quot;y&quot; : &quot;x&quot;];
+	}
+
+	ds.getAbsoluteX = ds.totalOffsetLeft = function(node, includeScroll){
+		return ds.getTotalOffset(node, &quot;left&quot;, includeScroll);
+	}
+
+	ds.getAbsoluteY = ds.totalOffsetTop = function(node, includeScroll){
+		return ds.getTotalOffset(node, &quot;top&quot;, includeScroll);
+	}
+
+	ds.styleSheet = null;
+
+	// FIXME: this is a really basic stub for adding and removing cssRules, but
+	// it assumes that you know the index of the cssRule that you want to add 
+	// or remove, making it less than useful.  So we need something that can 
+	// search for the selector that you you want to remove.
+	ds.insertCssRule = function(selector, declaration, index) {
+		if (!ds.styleSheet) {
+			if (document.createStyleSheet) { // IE
+				ds.styleSheet = document.createStyleSheet();
+			} else if (document.styleSheets[0]) { // rest
+				// FIXME: should create a new style sheet here
+				// fall back on an exsiting style sheet
+				ds.styleSheet = document.styleSheets[0];
+			} else { return null; } // fail
+		}
+
+		if (arguments.length &lt; 3) { // index may == 0
+			if (ds.styleSheet.cssRules) { // W3
+				index = ds.styleSheet.cssRules.length;
+			} else if (ds.styleSheet.rules) { // IE
+				index = ds.styleSheet.rules.length;
+			} else { return null; } // fail
+		}
+
+		if (ds.styleSheet.insertRule) { // W3
+			var rule = selector + &quot; { &quot; + declaration + &quot; }&quot;;
+			return ds.styleSheet.insertRule(rule, index);
+		} else if (ds.styleSheet.addRule) { // IE
+			return ds.styleSheet.addRule(selector, declaration, index);
+		} else { return null; } // fail
+	}
+
+	ds.removeCssRule = function(index){
+		if(!ds.styleSheet){
+			dojo.debug(&quot;no stylesheet defined for removing rules&quot;);
+			return false;
+		}
+		if(h.ie){
+			if(!index){
+				index = ds.styleSheet.rules.length;
+				ds.styleSheet.removeRule(index);
+			}
+		}else if(document.styleSheets[0]){
+			if(!index){
+				index = ds.styleSheet.cssRules.length;
+			}
+			ds.styleSheet.deleteRule(index);
+		}
+		return true;
+	}
+
+	// calls css by XmlHTTP and inserts it into DOM as &lt;style [widgetType=&quot;widgetType&quot;]&gt; *downloaded cssText*&lt;/style&gt;
+	ds.insertCssFile = function(URI, doc, checkDuplicates){
+		if(!URI){ return; }
+		if(!doc){ doc = document; }
+		var cssStr = dojo.hostenv.getText(URI);
+		cssStr = ds.fixPathsInCssText(cssStr, URI);
+
+		if(checkDuplicates){
+			var styles = doc.getElementsByTagName(&quot;style&quot;);
+			var cssText = &quot;&quot;;
+			for(var i = 0; i&lt;styles.length; i++){
+				cssText = (styles[i].styleSheet &amp;&amp; styles[i].styleSheet.cssText) ? styles[i].styleSheet.cssText : styles[i].innerHTML;
+				if(cssStr == cssText){ return; }
+			}
+		}
+
+		var style = ds.insertCssText(cssStr);
+		// insert custom attribute ex dbgHref=&quot;../foo.css&quot; usefull when debugging in DOM inspectors, no?
+		if(style &amp;&amp; djConfig.isDebug){
+			style.setAttribute(&quot;dbgHref&quot;, URI);
+		}
+		return style
+	}
+
+	// DomNode Style  = insertCssText(String &quot;.dojoMenu {color: green;}&quot;[, DomDoc document, dojo.uri.Uri Url ])
+	ds.insertCssText = function(cssStr, doc, URI){
+		if(!cssStr){ return; }
+		if(!doc){ doc = document; }
+		if(URI){// fix paths in cssStr
+			cssStr = ds.fixPathsInCssText(cssStr, URI);
+		}
+		var style = doc.createElement(&quot;style&quot;);
+		style.setAttribute(&quot;type&quot;, &quot;text/css&quot;);
+		// IE is b0rken enough to require that we add the element to the doc
+		// before changing it's properties
+		var head = doc.getElementsByTagName(&quot;head&quot;)[0];
+		if(!head){ // must have a head tag 
+			dojo.debug(&quot;No head tag in document, aborting styles&quot;);
+			return;
+		}else{
+			head.appendChild(style);
+		}
+		if(style.styleSheet){// IE
+			style.styleSheet.cssText = cssStr;
+		}else{ // w3c
+			var cssText = doc.createTextNode(cssStr);
+			style.appendChild(cssText);
+		}
+		return style;
+	}
+
+	// String cssText = fixPathsInCssText(String cssStr, dojo.uri.Uri URI)
+	// usage: cssText comes from dojoroot/src/widget/templates/HtmlFoobar.css
+	// 	it has .dojoFoo { background-image: url(images/bar.png);} 
+	//	then uri should point to dojoroot/src/widget/templates/
+	ds.fixPathsInCssText = function(cssStr, URI){
+		if(!cssStr || !URI){ return; }
+		var pos = 0; var str = &quot;&quot;; var url = &quot;&quot;;
+		while(pos!=-1){
+			pos = 0;url = &quot;&quot;;
+			pos = cssStr.indexOf(&quot;url(&quot;, pos);
+			if(pos&lt;0){ break; }
+			str += cssStr.slice(0,pos+4);
+			cssStr = cssStr.substring(pos+4, cssStr.length);
+			url += cssStr.match(/^[\t\s\w()\/.\\'&quot;-:#=&amp;?]*\)/)[0]; // url string
+			cssStr = cssStr.substring(url.length-1, cssStr.length); // remove url from css string til next loop
+			url = url.replace(/^[\s\t]*(['&quot;]?)([\w()\/.\\'&quot;-:#=&amp;?]*)\1[\s\t]*?\)/,&quot;$2&quot;); // clean string
+			if(url.search(/(file|https?|ftps?):\/\//)==-1){
+				url = (new dojo.uri.Uri(URI,url).toString());
+			}
+			str += url;
+		};
+		return str+cssStr;
+	}
+
+	ds.getBackgroundColor = function(node) {
+		node = dojo.byId(node);
+		var color;
+		do{
+			color = ds.getStyle(node, &quot;background-color&quot;);
+			// Safari doesn't say &quot;transparent&quot;
+			if(color.toLowerCase() == &quot;rgba(0, 0, 0, 0)&quot;) { color = &quot;transparent&quot;; }
+			if(node == document.getElementsByTagName(&quot;body&quot;)[0]) { node = null; break; }
+			node = node.parentNode;
+		}while(node &amp;&amp; dojo.lang.inArray(color, [&quot;transparent&quot;, &quot;&quot;]));
+		if(color == &quot;transparent&quot;){
+			color = [255, 255, 255, 0];
+		}else{
+			color = dojo.graphics.color.extractRGB(color);
+		}
+		return color;
+	}
+
+	ds.getComputedStyle = function(node, cssSelector, inValue){
+		node = dojo.byId(node);
+		// cssSelector may actually be in camel case, so force selector version
+		var cssSelector = ds.toSelectorCase(cssSelector);
+		var property = ds.toCamelCase(cssSelector);
+		if(!node || !node.style){
+			return inValue;
+		}else if(document.defaultView){ // W3, gecko, KHTML
+			try{			
+				var cs = document.defaultView.getComputedStyle(node, &quot;&quot;);
+				if (cs){ 
+					return cs.getPropertyValue(cssSelector);
+				} 
+			}catch(e){ // reports are that Safari can throw an exception above
+				if (node.style.getPropertyValue){ // W3
+					return node.style.getPropertyValue(cssSelector);
+				}else return inValue;
+			}
+		}else if(node.currentStyle){ // IE
+			return node.currentStyle[property];
+		}if(node.style.getPropertyValue){ // W3
+			return node.style.getPropertyValue(cssSelector);
+		}else{
+			return inValue;
+		}
+	}
+
+	/** 
+	 * Retrieve a property value from a node's style object.
+	 */
+	ds.getStyleProperty = function(node, cssSelector){
+		node = dojo.byId(node);
+		// FIXME: should we use node.style.getPropertyValue over style[property]?
+		// style[property] works in all (modern) browsers, getPropertyValue is W3 but not supported in IE
+		// FIXME: what about runtimeStyle?
+		return (node &amp;&amp; node.style ? node.style[ds.toCamelCase(cssSelector)] : undefined);
+	}
+
+	/** 
+	 * Retrieve a property value from a node's style object.
+	 */
+	ds.getStyle = function(node, cssSelector){
+		var value = ds.getStyleProperty(node, cssSelector);
+		return (value ? value : ds.getComputedStyle(node, cssSelector));
+	}
+
+	ds.setStyle = function(node, cssSelector, value){
+		node = dojo.byId(node);
+		if(node &amp;&amp; node.style){
+			var camelCased = ds.toCamelCase(cssSelector);
+			node.style[camelCased] = value;
+		}
+	}
+
+	ds.toCamelCase = function(selector) {
+		var arr = selector.split('-'), cc = arr[0];
+		for(var i = 1; i &lt; arr.length; i++) {
+			cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
+		}
+		return cc;		
+	}
+
+	ds.toSelectorCase = function(selector) {
+		return selector.replace(/([A-Z])/g, &quot;-$1&quot; ).toLowerCase() ;
+	}
+
+	/* float between 0.0 (transparent) and 1.0 (opaque) */
+	ds.setOpacity = function setOpacity(node, opacity, dontFixOpacity) {
+		node = dojo.byId(node);
+		if(!dontFixOpacity){
+			if( opacity &gt;= 1.0){
+				if(h.ie){
+					ds.clearOpacity(node);
+					return;
+				}else{
+					opacity = 0.999999;
+				}
+			}else if( opacity &lt; 0.0){ opacity = 0; }
+		}
+		if(h.ie){
+			if(node.nodeName.toLowerCase() == &quot;tr&quot;){
+				// FIXME: is this too naive? will we get more than we want?
+				var tds = node.getElementsByTagName(&quot;td&quot;);
+				for(var x=0; x&lt;tds.length; x++){
+					tds[x].style.filter = &quot;Alpha(Opacity=&quot;+opacity*100+&quot;)&quot;;
+				}
+			}
+			node.style.filter = &quot;Alpha(Opacity=&quot;+opacity*100+&quot;)&quot;;
+		}else if(h.moz){
+			node.style.opacity = opacity; // ffox 1.0 directly supports &quot;opacity&quot;
+			node.style.MozOpacity = opacity;
+		}else if(h.safari){
+			node.style.opacity = opacity; // 1.3 directly supports &quot;opacity&quot;
+			node.style.KhtmlOpacity = opacity;
+		}else{
+			node.style.opacity = opacity;
+		}
+	}
+		
+	ds.getOpacity = function getOpacity (node){
+		node = dojo.byId(node);
+		if(h.ie){
+			var opac = (node.filters &amp;&amp; node.filters.alpha &amp;&amp;
+				typeof node.filters.alpha.opacity == &quot;number&quot;
+				? node.filters.alpha.opacity : 100) / 100;
+		}else{
+			var opac = node.style.opacity || node.style.MozOpacity ||
+				node.style.KhtmlOpacity || 1;
+		}
+		return opac &gt;= 0.999999 ? 1.0 : Number(opac);
+	}
+
+	ds.clearOpacity = function clearOpacity(node){
+		node = dojo.byId(node);
+		var ns = node.style;
+		if(h.ie){
+			try {
+				if( node.filters &amp;&amp; node.filters.alpha ){
+					ns.filter = &quot;&quot;; // FIXME: may get rid of other filter effects
+				}
+			} catch(e) {
+				/*
+				 * IE7 gives error if node.filters not set;
+				 * don't know why or how to workaround (other than this)
+				 */
+			}
+		}else if(h.moz){
+			ns.opacity = 1;
+			ns.MozOpacity = 1;
+		}else if(h.safari){
+			ns.opacity = 1;
+			ns.KhtmlOpacity = 1;
+		}else{
+			ns.opacity = 1;
+		}
+	}
+
+	/** 
+	* Set the given style attributes for the node. 
+	* Patch submitted by Wolfram Kriesing, 22/03/2006.
+	*
+	* Ie. dojo.style.setStyleAttributes(myNode, &quot;position:absolute; left:10px; top:10px;&quot;) 
+	* This just makes it easier to set a style directly without the need to  
+	* override it completely (as node.setAttribute() would). 
+	* If there is a dojo-method for an attribute, like for &quot;opacity&quot; there 
+	* is setOpacity, the dojo method is called instead. 
+	* For example: dojo.style.setStyleAttributes(myNode, &quot;opacity: .4&quot;); 
+	*  
+	* Additionally all the dojo.style.set* methods can also be used. 
+	* Ie. when attributes contains &quot;outer-height: 10;&quot; it will call dojo.style.setOuterHeight(&quot;10&quot;); 
+	* 
+	* @param object The node to set the style attributes for. 
+	* @param string Ie. &quot;position:absolute; left:10px; top:10px;&quot; 
+	*/ 
+	ds.setStyleAttributes = function(node, attributes) { 
+		var methodMap={ 
+			&quot;opacity&quot;:dojo.style.setOpacity,
+			&quot;content-height&quot;:dojo.style.setContentHeight,
+			&quot;content-width&quot;:dojo.style.setContentWidth,
+			&quot;outer-height&quot;:dojo.style.setOuterHeight,
+			&quot;outer-width&quot;:dojo.style.setOuterWidth 
+		} 
+
+		var splittedAttribs=attributes.replace(/(;)?\s*$/, &quot;&quot;).split(&quot;;&quot;); 
+		for(var i=0; i&lt;splittedAttribs.length; i++){ 
+			var nameValue=splittedAttribs[i].split(&quot;:&quot;); 
+			var name=nameValue[0].replace(/\s*$/, &quot;&quot;).replace(/^\s*/, &quot;&quot;).toLowerCase();
+			var value=nameValue[1].replace(/\s*$/, &quot;&quot;).replace(/^\s*/, &quot;&quot;);
+			if(dojo.lang.has(methodMap,name)) { 
+				methodMap[name](node,value); 
+			} else { 
+				node.style[dojo.style.toCamelCase(name)]=value; 
+			} 
+		} 
+	} 
+
+	ds._toggle = function(node, tester, setter){
+		node = dojo.byId(node);
+		setter(node, !tester(node));
+		return tester(node);
+	}
+
+	// show/hide are library constructs
+
+	// show() 
+	// if the node.style.display == 'none' then 
+	// set style.display to '' or the value cached by hide()
+	ds.show = function(node){
+		node = dojo.byId(node);
+		if(ds.getStyleProperty(node, 'display')=='none'){
+			ds.setStyle(node, 'display', (node.dojoDisplayCache||''));
+			node.dojoDisplayCache = undefined;	// cannot use delete on a node in IE6
+		}
+	}
+
+	// if the node.style.display == 'none' then 
+	// set style.display to '' or the value cached by hide()
+	ds.hide = function(node){
+		node = dojo.byId(node);
+		if(typeof node[&quot;dojoDisplayCache&quot;] == &quot;undefined&quot;){ // it could == '', so we cannot say !node.dojoDisplayCount
+			var d = ds.getStyleProperty(node, 'display')
+			if(d!='none'){
+				node.dojoDisplayCache = d;
+			}
+		}
+		ds.setStyle(node, 'display', 'none');
+	}
+
+	// setShowing() calls show() if showing is true, hide() otherwise
+	ds.setShowing = function(node, showing){
+		ds[(showing ? 'show' : 'hide')](node);
+	}
+
+	// isShowing() is true if the node.style.display is not 'none'
+	// FIXME: returns true if node is bad, isHidden would be easier to make correct
+	ds.isShowing = function(node){
+		return (ds.getStyleProperty(node, 'display') != 'none');
+	}
+
+	// Call setShowing() on node with the complement of isShowing(), then return the new value of isShowing()
+	ds.toggleShowing = function(node){
+		return ds._toggle(node, ds.isShowing, ds.setShowing);
+	}
+
+	// display is a CSS concept
+
+	// Simple mapping of tag names to display values
+	// FIXME: simplistic 
+	ds.displayMap = { tr: '', td: '', th: '', img: 'inline', span: 'inline', input: 'inline', button: 'inline' };
+
+	// Suggest a value for the display property that will show 'node' based on it's tag
+	ds.suggestDisplayByTagName = function(node)
+	{
+		node = dojo.byId(node);
+		if(node &amp;&amp; node.tagName){
+			var tag = node.tagName.toLowerCase();
+			return (tag in ds.displayMap ? ds.displayMap[tag] : 'block');
+		}
+	}
+
+	// setDisplay() sets the value of style.display to value of 'display' parameter if it is a string.
+	// Otherwise, if 'display' is false, set style.display to 'none'.
+	// Finally, set 'display' to a suggested display value based on the node's tag
+	ds.setDisplay = function(node, display){
+		ds.setStyle(node, 'display', (dojo.lang.isString(display) ? display : (display ? ds.suggestDisplayByTagName(node) : 'none')));
+	}
+
+	// isDisplayed() is true if the the computed display style for node is not 'none'
+	// FIXME: returns true if node is bad, isNotDisplayed would be easier to make correct
+	ds.isDisplayed = function(node){
+		return (ds.getComputedStyle(node, 'display') != 'none');
+	}
+
+	// Call setDisplay() on node with the complement of isDisplayed(), then
+	// return the new value of isDisplayed()
+	ds.toggleDisplay = function(node){
+		return ds._toggle(node, ds.isDisplayed, ds.setDisplay);
+	}
+
+	// visibility is a CSS concept
+
+	// setVisibility() sets the value of style.visibility to value of
+	// 'visibility' parameter if it is a string.
+	// Otherwise, if 'visibility' is false, set style.visibility to 'hidden'.
+	// Finally, set style.visibility to 'visible'.
+	ds.setVisibility = function(node, visibility){
+		ds.setStyle(node, 'visibility', (dojo.lang.isString(visibility) ? visibility : (visibility ? 'visible' : 'hidden')));
+	}
+
+	// isVisible() is true if the the computed visibility style for node is not 'hidden'
+	// FIXME: returns true if node is bad, isInvisible would be easier to make correct
+	ds.isVisible = function(node){
+		return (ds.getComputedStyle(node, 'visibility') != 'hidden');
+	}
+
+	// Call setVisibility() on node with the complement of isVisible(), then
+	// return the new value of isVisible()
+	ds.toggleVisibility = function(node){
+		return ds._toggle(node, ds.isVisible, ds.setVisibility);
+	}
+
+	// in: coordinate array [x,y,w,h] or dom node
+	// return: coordinate array
+	ds.toCoordinateArray = function(coords, includeScroll) {
+		if(dojo.lang.isArray(coords)){
+			// coords is already an array (of format [x,y,w,h]), just return it
+			while ( coords.length &lt; 4 ) { coords.push(0); }
+			while ( coords.length &gt; 4 ) { coords.pop(); }
+			var ret = coords;
+		} else {
+			// coords is an dom object (or dom object id); return it's coordinates
+			var node = dojo.byId(coords);
+			var pos = ds.getAbsolutePosition(node, includeScroll);
+			var ret = [
+				pos.x,
+				pos.y,
+				ds.getBorderBoxWidth(node),
+				ds.getBorderBoxHeight(node)
+			];
+		}
+		ret.x = ret[0];
+		ret.y = ret[1];
+		ret.w = ret[2];
+		ret.h = ret[3];
+		return ret;
+	};
+})();

Added: trunk/root/static/magic/src/svg.js
===================================================================
--- trunk/root/static/magic/src/svg.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/svg.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,279 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.svg&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+
+dojo.lang.mixin(dojo.svg, dojo.dom);
+
+dojo.svg.graphics=dojo.svg.g=new function(/* DomDocument */ d){
+	//	summary
+	//	Singleton to encapsulate SVG rendering functions.
+	this.suspend=function(){
+		//	summary
+		//	Suspend the rendering engine
+		try { d.documentElement.suspendRedraw(0); } catch(e){ }
+	};
+	this.resume=function(){
+		//	summary
+		//	Resume the rendering engine
+		try { d.documentElement.unsuspendRedraw(0); } catch(e){ }
+	};
+	this.force=function(){
+		//	summary
+		//	Force the render engine to redraw
+		try { d.documentElement.forceRedraw(); } catch(e){ }
+	};
+}(document);
+
+dojo.svg.animations=dojo.svg.anim=new function(/* DOMDocument */ d){
+	//	summary
+	//	Singleton to encapsulate SVG animation functionality.
+	this.arePaused=function(){
+		//	summary
+		//	check to see if all animations are paused
+		try {
+			return d.documentElement.animationsPaused();	//	bool
+		} catch(e){
+			return false;	//	bool
+		}
+	} ;
+	this.pause=function(){
+		//	summary
+		//	pause all animations
+		try { d.documentElement.pauseAnimations(); } catch(e){ }
+	};
+	this.resume=function(){
+		//	summary
+		//	resume all animations
+		try { d.documentElement.unpauseAnimations(); } catch(e){ }
+	};
+}(document);
+
+//	fixme: these functions should be mixed in from dojo.style, but dojo.style is HTML-centric and needs to change.
+dojo.svg.toCamelCase=function(/* string */ selector){
+	//	summary
+	//	converts a CSS-style selector to a camelCased one
+	var arr=selector.split('-'), cc=arr[0];
+	for(var i=1; i &lt; arr.length; i++) {
+		cc += arr[i].charAt(0).toUpperCase() + arr[i].substring(1);
+	}
+	return cc;	// string
+};
+dojo.svg.toSelectorCase=function(/* string */ selector) {
+	//	summary
+	//	converts a camelCased selector to a CSS style one
+	return selector.replace(/([A-Z])/g, &quot;-$1&quot; ).toLowerCase();	//	string
+};
+dojo.svg.getStyle=function(/* SVGElement */ node, /* string */ cssSelector){
+	//	summary
+	//	get the computed style of selector for node.
+	return document.defaultView.getComputedStyle(node, cssSelector);	//	object
+};
+dojo.svg.getNumericStyle=function(/* SVGElement */ node, /* string */ cssSelector){
+	//	summary
+	//	return the numeric version of the computed style of selector on node.
+	return parseFloat(dojo.svg.getStyle(node, cssSelector));
+};
+
+//	fixme: there are different ways of doing the following, need to take into account
+dojo.svg.getOpacity=function(/* SVGElement */node){
+	//	summary
+	//	Return the opacity of the passed element
+	return Math.min(1.0, dojo.svg.getNumericStyle(node, &quot;fill-opacity&quot;));	//	float
+};
+dojo.svg.setOpacity=function(/* SVGElement */ node, /* float */ opacity){
+	//	summary
+	//	set the opacity of node using attributes.
+	node.setAttributeNS(this.xmlns.svg, &quot;fill-opacity&quot;, opacity);
+	node.setAttributeNS(this.xmlns.svg, &quot;stroke-opacity&quot;, opacity);
+};
+dojo.svg.clearOpacity=function(/* SVGElement */ node){
+	//	summary
+	//	Set any attributes setting opacity to opaque (1.0)
+	node.setAttributeNS(this.xmlns.svg, &quot;fill-opacity&quot;, &quot;1.0&quot;);
+	node.setAttributeNS(this.xmlns.svg, &quot;stroke-opacity&quot;, &quot;1.0&quot;);
+};
+
+/**
+ *	Coordinates and dimensions.
+ */
+
+// TODO ////////////////////////////////////////////////////////// TODO
+dojo.svg.getCoords=function(/* SVGElement */ node){
+	if (node.getBBox) {
+		var box=node.getBBox();
+		return { x: box.x, y: box.y };
+	}
+	return null;
+};
+dojo.svg.setCoords=function(node, coords){
+	var p=dojo.svg.getCoords();
+	if (!p) return;
+	var dx=p.x - coords.x;
+	var dy=p.y - coords.y;
+	dojo.svg.translate(node, dx, dy);
+};
+dojo.svg.getDimensions=function(node){
+	if (node.getBBox){
+		var box=node.getBBox();
+		return { width: box.width, height : box.height };
+	}
+	return null;
+};
+dojo.svg.setDimensions=function(node, dim){
+	//	will only support shape-based and container elements; path-based elements are ignored.
+	if (node.width){
+		node.width.baseVal.value=dim.width;
+		node.height.baseVal.value=dim.height;
+	}
+	else if (node.r){
+		node.r.baseVal.value=Math.min(dim.width, dim.height)/2;
+	}
+	else if (node.rx){
+		node.rx.baseVal.value=dim.width/2;
+		node.ry.baseVal.value=dim.height/2;
+	}
+};
+
+/**
+ *	Transformations.
+ */
+dojo.svg.translate=function(node, dx, dy){
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		t.setTranslate(dx, dy);
+		node.transform.baseVal.appendItem(t);
+	}
+};
+dojo.svg.scale=function(node, scaleX, scaleY){
+	if (!scaleY) var scaleY=scaleX;
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		t.setScale(scaleX, scaleY);
+		node.transform.baseVal.appendItem(t);
+	}
+};
+dojo.svg.rotate=function(node, ang, cx, cy){
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		if (!cx) t.setMatrix(t.matrix.rotate(ang));
+		else t.setRotate(ang, cx, cy);
+		node.transform.baseVal.appendItem(t);
+	}
+};
+dojo.svg.skew=function(node, ang, axis){
+	var dir=axis || &quot;x&quot;;
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		if (dir != &quot;x&quot;) t.setSkewY(ang);
+		else t.setSkewX(ang);
+		node.transform.baseVal.appendItem(t);
+	}
+};
+dojo.svg.flip=function(node, axis){
+	var dir=axis || &quot;x&quot;;
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		t.setMatrix((dir != &quot;x&quot;) ? t.matrix.flipY() : t.matrix.flipX());
+		node.transform.baseVal.appendItem(t);
+	}
+};
+dojo.svg.invert=function(node){
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var t=node.ownerSVGElement.createSVGTransform();
+		t.setMatrix(t.matrix.inverse());
+		node.transform.baseVal.appendItem(t);
+	}
+};
+dojo.svg.applyMatrix=function(node, a, b, c, d, e, f){
+	if (node.transform &amp;&amp; node.ownerSVGElement &amp;&amp; node.ownerSVGElement.createSVGTransform){
+		var m;
+		if (b){
+			var m=node.ownerSVGElement.createSVGMatrix();
+			m.a=a;
+			m.b=b;
+			m.c=c;
+			m.d=d;
+			m.e=e;
+			m.f=f;
+		} else m=a;
+		var t=node.ownerSVGElement.createSVGTransform();
+		t.setMatrix(m);
+		node.transform.baseVal.appendItem(t);
+	}
+};
+
+/**
+ *	Grouping and z-index operations.
+ */
+dojo.svg.group=function(nodes){
+	//	expect an array of nodes, attaches the group to the parent of the first node.
+	var p=nodes.item(0).parentNode;
+	var g=document.createElementNS(this.xmlns.svg, &quot;g&quot;);
+	for (var i=0; i &lt; nodes.length; i++) g.appendChild(nodes.item(i));
+	p.appendChild(g);
+	return g;
+};
+dojo.svg.ungroup=function(g){
+	//	puts the children of the group on the same level as group was.
+	var p=g.parentNode;
+	while (g.childNodes.length &gt; 0) p.appendChild(g.childNodes.item(0));
+	p.removeChild(g);
+};
+//	if the node is part of a group, return the group, else return null.
+dojo.svg.getGroup=function(node){
+	//	if the node is part of a group, return the group, else return null.
+	var a=this.getAncestors(node);
+	for (var i=0; i &lt; a.length; i++){
+		if (a[i].nodeType == this.ELEMENT_NODE &amp;&amp; a[i].nodeName.toLowerCase() == &quot;g&quot;)
+			return a[i];
+	}
+	return null;
+};
+dojo.svg.bringToFront=function(node){
+	var n=this.getGroup(node) || node;
+	n.ownerSVGElement.appendChild(n);
+};
+dojo.svg.sendToBack=function(node){
+	var n=this.getGroup(node) || node;
+	n.ownerSVGElement.insertBefore(n, n.ownerSVGElement.firstChild);
+};
+
+//	TODO: possibly push node up a level in the DOM if it's at the beginning or end of the childNodes list.
+dojo.svg.bringForward=function(node){
+	var n=this.getGroup(node) || node;
+	if (this.getLastChildElement(n.parentNode) != n){
+		this.insertAfter(n, this.getNextSiblingElement(n), true);
+	}
+};
+dojo.svg.sendBackward=function(node){
+	var n=this.getGroup(node) || node;
+	if (this.getFirstChildElement(n.parentNode) != n){
+		this.insertBefore(n, this.getPreviousSiblingElement(n), true);
+	}
+};
+// END TODO ////////////////////////////////////////////////////// TODO
+
+dojo.svg.createNodesFromText=function(/* string */ txt, /* bool? */ wrap){
+	//	summary
+	//	Create a list of nodes from text
+	var docFrag=(new DOMParser()).parseFromString(txt, &quot;text/xml&quot;).normalize();
+	if(wrap){ 
+		return [docFrag.firstChild.cloneNode(true)];	//	array
+	}
+	var nodes=[];
+	for(var x=0; x&lt;docFrag.childNodes.length; x++){
+		nodes.push(docFrag.childNodes.item(x).cloneNode(true));
+	}
+	return nodes;	// array
+}
+// vim:ts=4:noet:tw=0:

Added: trunk/root/static/magic/src/text/Builder.js
===================================================================
--- trunk/root/static/magic/src/text/Builder.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/text/Builder.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,16 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.text.Builder&quot;);
+dojo.require(&quot;dojo.string.Builder&quot;);
+
+dojo.deprecated(&quot;dojo.text.Builder&quot;, &quot;use dojo.string.Builder instead&quot;, &quot;0.4&quot;);
+
+dojo.text.Builder = dojo.string.Builder;

Added: trunk/root/static/magic/src/text/String.js
===================================================================
--- trunk/root/static/magic/src/text/String.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/text/String.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.deprecated(&quot;dojo.text.String&quot;, &quot;replaced by dojo.string&quot;, &quot;0.4&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+dojo.text = dojo.string;
+dojo.provide(&quot;dojo.text.String&quot;);

Added: trunk/root/static/magic/src/text/Text.js
===================================================================
--- trunk/root/static/magic/src/text/Text.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/text/Text.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.deprecated(&quot;dojo.text.Text&quot;, &quot;replaced by dojo.string&quot;, &quot;0.4&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+dojo.text = dojo.string;
+dojo.provide(&quot;dojo.text.Text&quot;);

Added: trunk/root/static/magic/src/text/__package__.js
===================================================================
--- trunk/root/static/magic/src/text/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/text/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,17 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.text.String&quot;,
+		&quot;dojo.text.Builder&quot;
+	]
+});
+dojo.provide(&quot;dojo.text.*&quot;);

Added: trunk/root/static/magic/src/text/textDirectory.js
===================================================================
--- trunk/root/static/magic/src/text/textDirectory.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/text/textDirectory.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,81 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.text.textDirectory&quot;);
+dojo.provide(&quot;dojo.text.textDirectory.Property&quot;);
+dojo.provide(&quot;dojo.text.textDirectory.tokenise&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+/* adapted from Paul Sowden's iCalendar work */
+
+dojo.textDirectoryTokeniser = function () {}
+
+/*
+ * This class parses a single line from a text/directory file
+ * and returns an object with four named values; name, group, params
+ * and value. name, group and value are strings containing the original
+ * tokens unaltered and values is an array containing name/value pairs
+ * or a single name token packed into arrays.
+ */
+dojo.textDirectoryTokeniser.Property = function (line) {
+	// split into name/value pair
+	var left = dojo.string.trim(line.substring(0, line.indexOf(':')));
+	var right = dojo.string.trim(line.substr(line.indexOf(':') + 1));
+
+	// seperate name and paramters	
+	var parameters = dojo.string.splitEscaped(left,';');
+	this.name = parameters[0]
+	parameters.splice(0, 1);
+
+	// parse paramters
+	this.params = [];
+	for (var i = 0; i &lt; parameters.length; i++) {
+		var arr = parameters[i].split(&quot;=&quot;);
+		var key = dojo.string.trim(arr[0].toUpperCase());
+		
+		if (arr.length == 1) { this.params.push([key]); continue; }
+		
+		var values = dojo.string.splitEscaped(arr[1],',');
+		for (var j = 0; j &lt; values.length; j++) {
+			if (dojo.string.trim(values[j]) != '') {
+				this.params.push([key, dojo.string.trim(values[j])]);
+			}
+		}
+	}
+
+	// seperate group
+	if (this.name.indexOf('.') &gt; 0) {
+		var arr = this.name.split('.');
+		this.group = arr[0];
+		this.name = arr[1];
+	}
+	
+	// don't do any parsing, leave to implementation
+	this.value = right;
+}
+
+
+// tokeniser, parses into an array of properties.
+dojo.textDirectoryTokeniser.tokenise = function (text) {
+	// normlize to one propterty per line and parse
+	var nText = dojo.string.normalizeNewlines(text,&quot;\n&quot;);
+	nText = nText.replace(/\n[ \t]/g, '');
+	nText = nText.replace(/\x00/g, '');
+		
+	var lines = nText.split(&quot;\n&quot;);
+	var properties = []
+
+	for (var i = 0; i &lt; lines.length; i++) {
+		if (dojo.string.trim(lines[i]) == '') { continue; }
+		var prop = new dojo.textDirectoryTokeniser.Property(lines[i]);
+		properties.push(prop);
+	}
+	return properties;
+}

Added: trunk/root/static/magic/src/undo/Manager.js
===================================================================
--- trunk/root/static/magic/src/undo/Manager.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/undo/Manager.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,198 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.undo.Manager&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+dojo.undo.Manager = function(parent) {
+	this.clear();
+	this._parent = parent;
+};
+dojo.lang.extend(dojo.undo.Manager, {
+	_parent: null,
+	_undoStack: null,
+	_redoStack: null,
+	_currentManager: null,
+
+	canUndo: false,
+	canRedo: false,
+
+	isUndoing: false,
+	isRedoing: false,
+
+	// these events allow you to hook in and update your code (UI?) as necessary
+	onUndo: function(manager, item) {},
+	onRedo: function(manager, item) {},
+
+	// fired when you do *any* undo action, which means you'll have one for every item
+	// in a transaction. this is usually only useful for debugging
+	onUndoAny: function(manager, item) {},
+	onRedoAny: function(manager, item) {},
+
+	_updateStatus: function() {
+		this.canUndo = this._undoStack.length &gt; 0;
+		this.canRedo = this._redoStack.length &gt; 0;
+	},
+
+	clear: function() {
+		this._undoStack = [];
+		this._redoStack = [];
+		this._currentManager = this;
+
+		this.isUndoing = false;
+		this.isRedoing = false;
+
+		this._updateStatus();
+	},
+
+	undo: function() {
+		if(!this.canUndo) { return false; }
+
+		this.endAllTransactions();
+
+		this.isUndoing = true;
+		var top = this._undoStack.pop();
+		if(top instanceof dojo.undo.Manager){
+			top.undoAll();
+		}else{
+			top.undo();
+		}
+		if(top.redo){
+			this._redoStack.push(top);
+		}
+		this.isUndoing = false;
+
+		this._updateStatus();
+		this.onUndo(this, top);
+		if(!(top instanceof dojo.undo.Manager)){
+			this.getTop().onUndoAny(this, top);
+		}
+		return true;
+	},
+
+	redo: function() {
+		if(!this.canRedo){ return false; }
+
+		this.isRedoing = true;
+		var top = this._redoStack.pop();
+		if(top instanceof dojo.undo.Manager){
+			top.redoAll();
+		}else{
+			top.redo();
+		}
+		this._undoStack.push(top);
+		this.isRedoing = false;
+
+		this._updateStatus();
+		this.onRedo(this, top);
+		if(!(top instanceof dojo.undo.Manager)){
+			this.getTop().onRedoAny(this, top);
+		}
+		return true;
+	},
+
+	undoAll: function() {
+		while(this._undoStack.length &gt; 0) {
+			this.undo();
+		}
+	},
+
+	redoAll: function() {
+		while(this._redoStack.length &gt; 0) {
+			this.redo();
+		}
+	},
+
+	push: function(undo, redo /* optional */, description /* optional */) {
+		if(!undo) { return; }
+
+		if(this._currentManager == this) {
+			this._undoStack.push({
+				undo: undo,
+				redo: redo,
+				description: description
+			});
+		} else {
+			this._currentManager.push.apply(this._currentManager, arguments);
+		}
+		// adding a new undo-able item clears out the redo stack
+		this._redoStack = [];
+		this._updateStatus();
+	},
+
+	concat: function(manager) {
+		if ( !manager ) { return; }
+
+		if (this._currentManager == this ) {
+			for(var x=0; x &lt; manager._undoStack.length; x++) {
+				this._undoStack.push(manager._undoStack[x]);
+			}
+			// adding a new undo-able item clears out the redo stack
+			this._redoStack = [];
+			this._updateStatus();
+		} else {
+			this._currentManager.concat.apply(this._currentManager, arguments);
+		}
+	},
+
+	beginTransaction: function(description /* optional */) {
+		if(this._currentManager == this) {
+			var mgr = new dojo.undo.Manager(this);
+			mgr.description = description ? description : &quot;&quot;;
+			this._undoStack.push(mgr);
+			this._currentManager = mgr;
+			return mgr;
+		} else {
+			//for nested transactions need to make sure the top level _currentManager is set
+			this._currentManager = this._currentManager.beginTransaction.apply(this._currentManager, arguments);
+		}
+	},
+
+	endTransaction: function(flatten /* optional */) {
+		if(this._currentManager == this) {
+			if(this._parent) {
+				this._parent._currentManager = this._parent;
+				// don't leave empty transactions hangin' around
+				if(this._undoStack.length == 0 || flatten) {
+					var idx = dojo.lang.find(this._parent._undoStack, this);
+					if (idx &gt;= 0) {
+						this._parent._undoStack.splice(idx, 1);
+						//add the current transaction to parents undo stack
+						if (flatten) {
+							for(var x=0; x &lt; this._undoStack.length; x++){
+								this._parent._undoStack.splice(idx++, 0, this._undoStack[x]);
+							}
+							this._updateStatus();
+						}
+					}
+				}
+				return this._parent;
+			}
+		} else {
+			//for nested transactions need to make sure the top level _currentManager is set
+			this._currentManager = this._currentManager.endTransaction.apply(this._currentManager, arguments);
+		}
+	},
+
+	endAllTransactions: function() {
+		while(this._currentManager != this) {
+			this.endTransaction();
+		}
+	},
+
+	// find the top parent of an undo manager
+	getTop: function() {
+		if(this._parent) {
+			return this._parent.getTop();
+		} else {
+			return this;
+		}
+	}
+});

Added: trunk/root/static/magic/src/undo/__package__.js
===================================================================
--- trunk/root/static/magic/src/undo/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/undo/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.undo.Manager&quot;);
+dojo.provide(&quot;dojo.undo.*&quot;);

Added: trunk/root/static/magic/src/undo/browser.js
===================================================================
--- trunk/root/static/magic/src/undo/browser.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/undo/browser.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,279 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.undo.browser&quot;);
+dojo.require(&quot;dojo.io&quot;);
+
+try{
+	if((!djConfig[&quot;preventBackButtonFix&quot;])&amp;&amp;(!dojo.hostenv.post_load_)){
+		document.write(&quot;&lt;iframe style='border: 0px; width: 1px; height: 1px; position: absolute; bottom: 0px; right: 0px; visibility: visible;' name='djhistory' id='djhistory' src='&quot;+(dojo.hostenv.getBaseScriptUri()+'iframe_history.html')+&quot;'&gt;&lt;/iframe&gt;&quot;);
+	}
+}catch(e){/* squelch */}
+
+if(dojo.render.html.opera){
+	dojo.debug(&quot;Opera is not supported with dojo.undo.browser, so back/forward detection will not work.&quot;);
+}
+
+/* NOTES:
+ *  Safari 1.2: 
+ *	back button &quot;works&quot; fine, however it's not possible to actually
+ *	DETECT that you've moved backwards by inspecting window.location.
+ *	Unless there is some other means of locating.
+ *	FIXME: perhaps we can poll on history.length?
+ *  Safari 2.0.3+ (and probably 1.3.2+):
+ *	works fine, except when changeUrl is used. When changeUrl is used,
+ *	Safari jumps all the way back to whatever page was shown before
+ *	the page that uses dojo.undo.browser support.
+ *  IE 5.5 SP2:
+ *	back button behavior is macro. It does not move back to the
+ *	previous hash value, but to the last full page load. This suggests
+ *	that the iframe is the correct way to capture the back button in
+ *	these cases.
+ *	Don't test this page using local disk for MSIE. MSIE will not create 
+ *	a history list for iframe_history.html if served from a file: URL. 
+ *	The XML served back from the XHR tests will also not be properly 
+ *	created if served from local disk. Serve the test pages from a web 
+ *	server to test in that browser.
+ *  IE 6.0:
+ *	same behavior as IE 5.5 SP2
+ * Firefox 1.0:
+ *	the back button will return us to the previous hash on the same
+ *	page, thereby not requiring an iframe hack, although we do then
+ *	need to run a timer to detect inter-page movement.
+ */
+dojo.undo.browser = {
+	initialHref: window.location.href,
+	initialHash: window.location.hash,
+
+	moveForward: false,
+	historyStack: [],
+	forwardStack: [],
+	historyIframe: null,
+	bookmarkAnchor: null,
+	locationTimer: null,
+
+	/**
+	 * setInitialState sets the state object and back callback for the very first page that is loaded.
+	 * It is recommended that you call this method as part of an event listener that is registered via
+	 * dojo.addOnLoad().
+	 */
+	setInitialState: function(args){
+		this.initialState = {&quot;url&quot;: this.initialHref, &quot;kwArgs&quot;: args, &quot;urlHash&quot;: this.initialHash};
+	},
+
+	//FIXME: Would like to support arbitrary back/forward jumps. Have to rework iframeLoaded among other things.
+	//FIXME: is there a slight race condition in moz using change URL with the timer check and when
+	//       the hash gets set? I think I have seen a back/forward call in quick succession, but not consistent.
+	/**
+	 * addToHistory takes one argument, and it is an object that defines the following functions:
+	 * - To support getting back button notifications, the object argument should implement a
+	 *   function called either &quot;back&quot;, &quot;backButton&quot;, or &quot;handle&quot;. The string &quot;back&quot; will be
+	 *   passed as the first and only argument to this callback.
+	 * - To support getting forward button notifications, the object argument should implement a
+	 *   function called either &quot;forward&quot;, &quot;forwardButton&quot;, or &quot;handle&quot;. The string &quot;forward&quot; will be
+	 *   passed as the first and only argument to this callback.
+	 * - If you want the browser location string to change, define &quot;changeUrl&quot; on the object. If the
+	 *   value of &quot;changeUrl&quot; is true, then a unique number will be appended to the URL as a fragment
+	 *   identifier (<A HREF="http://some.domain.com/path#uniquenumber">http://some.domain.com/path#uniquenumber</A>). If it is any other value that does
+	 *   not evaluate to false, that value will be used as the fragment identifier. For example,
+	 *   if changeUrl: 'page1', then the URL will look like: <A HREF="http://some.domain.com/path#page1">http://some.domain.com/path#page1</A>
+	 *   
+	 * Full example:
+	 * 
+	 * dojo.undo.browser.addToHistory({
+	 *   back: function() { alert('back pressed'); },
+	 *   forward: function() { alert('forward pressed'); },
+	 *   changeUrl: true
+	 * });
+	 */
+	addToHistory: function(args){
+		var hash = null;
+		if(!this.historyIframe){
+			this.historyIframe = window.frames[&quot;djhistory&quot;];
+		}
+		if(!this.bookmarkAnchor){
+			this.bookmarkAnchor = document.createElement(&quot;a&quot;);
+			(document.body||document.getElementsByTagName(&quot;body&quot;)[0]).appendChild(this.bookmarkAnchor);
+			this.bookmarkAnchor.style.display = &quot;none&quot;;
+		}
+		if((!args[&quot;changeUrl&quot;])||(dojo.render.html.ie)){
+			var url = dojo.hostenv.getBaseScriptUri()+&quot;iframe_history.html?&quot;+(new Date()).getTime();
+			this.moveForward = true;
+			dojo.io.setIFrameSrc(this.historyIframe, url, false);
+		}
+		if(args[&quot;changeUrl&quot;]){
+			this.changingUrl = true;
+			hash = &quot;#&quot;+ ((args[&quot;changeUrl&quot;]!==true) ? args[&quot;changeUrl&quot;] : (new Date()).getTime());
+			setTimeout(&quot;window.location.href = '&quot;+hash+&quot;'; dojo.undo.browser.changingUrl = false;&quot;, 1);
+			this.bookmarkAnchor.href = hash;
+			
+			if(dojo.render.html.ie){
+				var oldCB = args[&quot;back&quot;]||args[&quot;backButton&quot;]||args[&quot;handle&quot;];
+
+				//The function takes handleName as a parameter, in case the
+				//callback we are overriding was &quot;handle&quot;. In that case,
+				//we will need to pass the handle name to handle.
+				var tcb = function(handleName){
+					if(window.location.hash != &quot;&quot;){
+						setTimeout(&quot;window.location.href = '&quot;+hash+&quot;';&quot;, 1);
+					}
+					//Use apply to set &quot;this&quot; to args, and to try to avoid memory leaks.
+					oldCB.apply(this, [handleName]);
+				}
+		
+				//Set interceptor function in the right place.
+				if(args[&quot;back&quot;]){
+					args.back = tcb;
+				}else if(args[&quot;backButton&quot;]){
+					args.backButton = tcb;
+				}else if(args[&quot;handle&quot;]){
+					args.handle = tcb;
+				}
+		
+				//If addToHistory is called, then that means we prune the
+				//forward stack -- the user went back, then wanted to
+				//start a new forward path.
+				this.forwardStack = []; 
+				var oldFW = args[&quot;forward&quot;]||args[&quot;forwardButton&quot;]||args[&quot;handle&quot;];
+		
+				//The function takes handleName as a parameter, in case the
+				//callback we are overriding was &quot;handle&quot;. In that case,
+				//we will need to pass the handle name to handle.
+				var tfw = function(handleName){
+					if(window.location.hash != &quot;&quot;){
+						window.location.href = hash;
+					}
+					if(oldFW){ // we might not actually have one
+						//Use apply to set &quot;this&quot; to args, and to try to avoid memory leaks.
+						oldFW.apply(this, [handleName]);
+					}
+				}
+
+				//Set interceptor function in the right place.
+				if(args[&quot;forward&quot;]){
+					args.forward = tfw;
+				}else if(args[&quot;forwardButton&quot;]){
+					args.forwardButton = tfw;
+				}else if(args[&quot;handle&quot;]){
+					args.handle = tfw;
+				}
+
+			}else if(dojo.render.html.moz){
+				// start the timer
+				if(!this.locationTimer){
+					this.locationTimer = setInterval(&quot;dojo.undo.browser.checkLocation();&quot;, 200);
+				}
+			}
+		}
+
+		this.historyStack.push({&quot;url&quot;: url, &quot;kwArgs&quot;: args, &quot;urlHash&quot;: hash});
+	},
+
+	checkLocation: function(){
+		if (!this.changingUrl){
+			var hsl = this.historyStack.length;
+
+			if((window.location.hash == this.initialHash||window.location.href == this.initialHref)&amp;&amp;(hsl == 1)){
+				// FIXME: could this ever be a forward button?
+				// we can't clear it because we still need to check for forwards. Ugg.
+				// clearInterval(this.locationTimer);
+				this.handleBackButton();
+				return;
+			}
+			// first check to see if we could have gone forward. We always halt on
+			// a no-hash item.
+			if(this.forwardStack.length &gt; 0){
+				if(this.forwardStack[this.forwardStack.length-1].urlHash == window.location.hash){
+					this.handleForwardButton();
+					return;
+				}
+			}
+	
+			// ok, that didn't work, try someplace back in the history stack
+			if((hsl &gt;= 2)&amp;&amp;(this.historyStack[hsl-2])){
+				if(this.historyStack[hsl-2].urlHash==window.location.hash){
+					this.handleBackButton();
+					return;
+				}
+			}
+		}
+	},
+
+	iframeLoaded: function(evt, ifrLoc){
+		if(!dojo.render.html.opera){
+			var query = this._getUrlQuery(ifrLoc.href);
+			if(query == null){ 
+				// alert(&quot;iframeLoaded&quot;);
+				// we hit the end of the history, so we should go back
+				if(this.historyStack.length == 1){
+					this.handleBackButton();
+				}
+				return;
+			}
+			if(this.moveForward){
+				// we were expecting it, so it's not either a forward or backward movement
+				this.moveForward = false;
+				return;
+			}
+	
+			//Check the back stack first, since it is more likely.
+			//Note that only one step back or forward is supported.
+			if(this.historyStack.length &gt;= 2 &amp;&amp; query == this._getUrlQuery(this.historyStack[this.historyStack.length-2].url)){
+				this.handleBackButton();
+			}
+			else if(this.forwardStack.length &gt; 0 &amp;&amp; query == this._getUrlQuery(this.forwardStack[this.forwardStack.length-1].url)){
+				this.handleForwardButton();
+			}
+		}
+	},
+
+	handleBackButton: function(){
+		//The &quot;current&quot; page is always at the top of the history stack.
+		var current = this.historyStack.pop();
+		if(!current){ return; }
+		var last = this.historyStack[this.historyStack.length-1];
+		if(!last &amp;&amp; this.historyStack.length == 0){
+			last = this.initialState;
+		}
+		if (last){
+			if(last.kwArgs[&quot;back&quot;]){
+				last.kwArgs[&quot;back&quot;]();
+			}else if(last.kwArgs[&quot;backButton&quot;]){
+				last.kwArgs[&quot;backButton&quot;]();
+			}else if(last.kwArgs[&quot;handle&quot;]){
+				last.kwArgs.handle(&quot;back&quot;);
+			}
+		}
+		this.forwardStack.push(current);
+	},
+
+	handleForwardButton: function(){
+		var last = this.forwardStack.pop();
+		if(!last){ return; }
+		if(last.kwArgs[&quot;forward&quot;]){
+			last.kwArgs.forward();
+		}else if(last.kwArgs[&quot;forwardButton&quot;]){
+			last.kwArgs.forwardButton();
+		}else if(last.kwArgs[&quot;handle&quot;]){
+			last.kwArgs.handle(&quot;forward&quot;);
+		}
+		this.historyStack.push(last);
+	},
+
+	_getUrlQuery: function(url){
+		var segments = url.split(&quot;?&quot;);
+		if (segments.length &lt; 2){
+			return null;
+		}
+		else{
+			return segments[1];
+		}
+	}
+}

Added: trunk/root/static/magic/src/uri/Uri.js
===================================================================
--- trunk/root/static/magic/src/uri/Uri.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uri/Uri.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,108 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uri.Uri&quot;);
+
+dojo.uri = new function() {
+	this.joinPath = function() {
+		// DEPRECATED: use the dojo.uri.Uri object instead
+		var arr = [];
+		for(var i = 0; i &lt; arguments.length; i++) { arr.push(arguments[i]); }
+		return arr.join(&quot;/&quot;).replace(/\/{2,}/g, &quot;/&quot;).replace(/((https*|ftps*):)/i, &quot;$1/&quot;);
+	}
+	
+	this.dojoUri = function (uri) {
+		// returns a Uri object resolved relative to the dojo root
+		return new dojo.uri.Uri(dojo.hostenv.getBaseScriptUri(), uri);
+	}
+		
+	this.Uri = function (/*uri1, uri2, [...]*/) {
+		// An object representing a Uri.
+		// Each argument is evaluated in order relative to the next until
+		// a conanical uri is producued. To get an absolute Uri relative
+		// to the current document use
+		//      new dojo.uri.Uri(document.baseURI, uri)
+
+		// TODO: support for IPv6, see RFC 2732
+
+		// resolve uri components relative to each other
+		var uri = arguments[0];
+		for (var i = 1; i &lt; arguments.length; i++) {
+			if(!arguments[i]) { continue; }
+
+			// Safari doesn't support this.constructor so we have to be explicit
+			var relobj = new dojo.uri.Uri(arguments[i].toString());
+			var uriobj = new dojo.uri.Uri(uri.toString());
+
+			if (relobj.path == &quot;&quot; &amp;&amp; relobj.scheme == null &amp;&amp;
+				relobj.authority == null &amp;&amp; relobj.query == null) {
+				if (relobj.fragment != null) { uriobj.fragment = relobj.fragment; }
+				relobj = uriobj;
+			} else if (relobj.scheme == null) {
+				relobj.scheme = uriobj.scheme;
+			
+				if (relobj.authority == null) {
+					relobj.authority = uriobj.authority;
+					
+					if (relobj.path.charAt(0) != &quot;/&quot;) {
+						var path = uriobj.path.substring(0,
+							uriobj.path.lastIndexOf(&quot;/&quot;) + 1) + relobj.path;
+
+						var segs = path.split(&quot;/&quot;);
+						for (var j = 0; j &lt; segs.length; j++) {
+							if (segs[j] == &quot;.&quot;) {
+								if (j == segs.length - 1) { segs[j] = &quot;&quot;; }
+								else { segs.splice(j, 1); j--; }
+							} else if (j &gt; 0 &amp;&amp; !(j == 1 &amp;&amp; segs[0] == &quot;&quot;) &amp;&amp;
+								segs[j] == &quot;..&quot; &amp;&amp; segs[j-1] != &quot;..&quot;) {
+
+								if (j == segs.length - 1) { segs.splice(j, 1); segs[j - 1] = &quot;&quot;; }
+								else { segs.splice(j - 1, 2); j -= 2; }
+							}
+						}
+						relobj.path = segs.join(&quot;/&quot;);
+					}
+				}
+			}
+
+			uri = &quot;&quot;;
+			if (relobj.scheme != null) { uri += relobj.scheme + &quot;:&quot;; }
+			if (relobj.authority != null) { uri += &quot;//&quot; + relobj.authority; }
+			uri += relobj.path;
+			if (relobj.query != null) { uri += &quot;?&quot; + relobj.query; }
+			if (relobj.fragment != null) { uri += &quot;#&quot; + relobj.fragment; }
+		}
+
+		this.uri = uri.toString();
+
+		// break the uri into its main components
+		var regexp = &quot;^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?$&quot;;
+	    var r = this.uri.match(new RegExp(regexp));
+
+		this.scheme = r[2] || (r[1] ? &quot;&quot; : null);
+		this.authority = r[4] || (r[3] ? &quot;&quot; : null);
+		this.path = r[5]; // can never be undefined
+		this.query = r[7] || (r[6] ? &quot;&quot; : null);
+		this.fragment  = r[9] || (r[8] ? &quot;&quot; : null);
+		
+		if (this.authority != null) {
+			// server based naming authority
+			regexp = &quot;^((([^:]+:)?([^@]+))@)?([^:]*)(:([0-9]+))?$&quot;;
+			r = this.authority.match(new RegExp(regexp));
+			
+			this.user = r[3] || null;
+			this.password = r[4] || null;
+			this.host = r[5];
+			this.port = r[7] || null;
+		}
+	
+		this.toString = function(){ return this.uri; }
+	}
+};

Added: trunk/root/static/magic/src/uri/__package__.js
===================================================================
--- trunk/root/static/magic/src/uri/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uri/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.uri.Uri&quot;, false, false]
+});
+dojo.provide(&quot;dojo.uri.*&quot;);

Added: trunk/root/static/magic/src/uuid/LightweightGenerator.js
===================================================================
--- trunk/root/static/magic/src/uuid/LightweightGenerator.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/LightweightGenerator.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,82 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uuid.LightweightGenerator&quot;);
+
+/**
+ * The LightweightGenerator is intended to be small and fast,
+ * but not necessarily good.
+ * 
+ * Small: The LightweightGenerator has a small footprint. 
+ * Once comments are stripped, it's only about 25 lines of 
+ * code, and it doesn't dojo.require() any other packages.
+ *
+ * Fast: The LightweightGenerator can generate lots of new 
+ * UUIDs fairly quickly (at least, more quickly than the other 
+ * dojo UUID generators).
+ *
+ * Not necessarily good: We use Math.random() as our source
+ * of randomness, which may or may not provide much randomness. 
+ */
+dojo.uuid.LightweightGenerator = new function() {
+
+	var HEX_RADIX = 16;
+
+// --------------------------------------------------
+// Private functions
+// --------------------------------------------------
+	function _generateRandomEightCharacterHexString() {
+		// Make random32bitNumber be a randomly generated floating point number
+		// between 0 and (4,294,967,296 - 1), inclusive.
+		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
+		var eightCharacterHexString = random32bitNumber.toString(HEX_RADIX);
+		while (eightCharacterHexString.length &lt; 8) {
+			eightCharacterHexString = &quot;0&quot; + eightCharacterHexString;
+		}
+		return eightCharacterHexString; // for example: &quot;3B12F1DF&quot;
+	}
+
+// --------------------------------------------------
+// Public functions
+// --------------------------------------------------
+
+/**
+ * This function generates random UUIDs, meaning &quot;version 4&quot; UUIDs.
+ * For example, a typical generated value would be something like
+ * &quot;3b12f1df-5232-4804-897e-917bf397618a&quot;.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var string = dojo.uuid.LightweightGenerator.generate();
+ *   var string = dojo.uuid.LightweightGenerator.generate(String);
+ *   var uuid   = dojo.uuid.LightweightGenerator.generate(dojo.uuid.Uuid);
+ * &lt;/pre&gt;
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	A newly generated version 4 UUID.
+ */
+	this.generate = function(returnType) {
+		var hyphen = &quot;-&quot;;
+		var versionCodeForRandomlyGeneratedUuids = &quot;4&quot;; // 8 == binary2hex(&quot;0100&quot;)
+		var variantCodeForDCEUuids = &quot;8&quot;; // 8 == binary2hex(&quot;1000&quot;)
+		var a = _generateRandomEightCharacterHexString();
+		var b = _generateRandomEightCharacterHexString();
+		b = b.substring(0, 4) + hyphen + versionCodeForRandomlyGeneratedUuids + b.substring(5, 8);
+		var c = _generateRandomEightCharacterHexString();
+		c = variantCodeForDCEUuids + c.substring(1, 4) + hyphen + c.substring(4, 8);
+		var d = _generateRandomEightCharacterHexString();
+		var returnValue = a + hyphen + b + hyphen + c + d;
+		returnValue = returnValue.toLowerCase();
+		if (returnType &amp;&amp; (returnType != String)) {
+			returnValue = new returnType(returnValue);
+		}
+		return returnValue;
+	};
+}();

Added: trunk/root/static/magic/src/uuid/NameBasedGenerator.js
===================================================================
--- trunk/root/static/magic/src/uuid/NameBasedGenerator.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/NameBasedGenerator.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,43 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uuid.NameBasedGenerator&quot;);
+
+dojo.uuid.NameBasedGenerator = new function() {
+
+/**
+ * This function generates name-based UUIDs, meaning &quot;version 3&quot; 
+ * and &quot;version 5&quot; UUIDs.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var string = dojo.uuid.NameBasedGenerator.generate();
+ *   var string = dojo.uuid.NameBasedGenerator.generate(String);
+ *   var uuid   = dojo.uuid.NameBasedGenerator.generate(dojo.uuid.Uuid);
+ * &lt;/pre&gt;
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	A newly generated version 3 or version 5 UUID.
+ */
+	this.generate = function(returnType) {
+		dojo.unimplemented('dojo.uuid.NameBasedGenerator.generate');
+		
+		// FIXME:
+		// For an algorithm to generate name-based UUIDs, 
+		// see sections 4.3 of RFC 4122:
+		//  <A HREF="http://www.ietf.org/rfc/rfc4122.txt">http://www.ietf.org/rfc/rfc4122.txt</A>
+		
+		var returnValue = &quot;00000000-0000-0000-0000-000000000000&quot;; // FIXME
+		if (returnType &amp;&amp; (returnType != String)) {
+			returnValue = new returnType(returnValue);
+		}
+		return returnValue;
+	};
+}();
\ No newline at end of file

Added: trunk/root/static/magic/src/uuid/NilGenerator.js
===================================================================
--- trunk/root/static/magic/src/uuid/NilGenerator.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/NilGenerator.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,38 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uuid.NilGenerator&quot;);
+
+dojo.uuid.NilGenerator = new function() {
+
+/**
+ * This function returns the Nil UUID: 
+ * &quot;00000000-0000-0000-0000-000000000000&quot;.
+ * The Nil UUID is described in section 4.1.7 of
+ * RFC 4122: <A HREF="http://www.ietf.org/rfc/rfc4122.txt">http://www.ietf.org/rfc/rfc4122.txt</A>
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var string = dojo.uuid.NilGenerator.generate();
+ *   var string = dojo.uuid.NilGenerator.generate(String);
+ *   var uuid   = dojo.uuid.NilGenerator.generate(dojo.uuid.Uuid);
+ * &lt;/pre&gt;
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	The nil UUID.
+ */
+	this.generate = function(returnType) {
+		var returnValue = &quot;00000000-0000-0000-0000-000000000000&quot;;
+		if (returnType &amp;&amp; (returnType != String)) {
+			returnValue = new returnType(returnValue);
+		}
+		return returnValue;
+	};
+}();
\ No newline at end of file

Added: trunk/root/static/magic/src/uuid/RandomGenerator.js
===================================================================
--- trunk/root/static/magic/src/uuid/RandomGenerator.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/RandomGenerator.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,44 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uuid.RandomGenerator&quot;);
+
+dojo.uuid.RandomGenerator = new function() {
+
+/**
+ * This function generates random UUIDs, meaning &quot;version 4&quot; UUIDs.
+ * For example, a typical generated value would be something like
+ * &quot;3b12f1df-5232-4804-897e-917bf397618a&quot;.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var string = dojo.uuid.RandomGenerator.generate();
+ *   var string = dojo.uuid.RandomGenerator.generate(String);
+ *   var uuid   = dojo.uuid.RandomGenerator.generate(dojo.uuid.Uuid);
+ * &lt;/pre&gt;
+ *
+ * @param	returnType	Optional. The type of instance to return.
+ * @return	A newly generated version 4 UUID.
+ */
+	this.generate = function(returnType) {
+		dojo.unimplemented('dojo.uuid.RandomGenerator.generate');
+		
+		// FIXME:
+		// For an algorithm to generate a random UUID, see
+		// sections 4.4 and 4.5 of RFC 4122:
+		//  <A HREF="http://www.ietf.org/rfc/rfc4122.txt">http://www.ietf.org/rfc/rfc4122.txt</A>
+		
+		var returnValue = &quot;00000000-0000-0000-0000-000000000000&quot;; // FIXME
+		if (returnType &amp;&amp; (returnType != String)) {
+			returnValue = new returnType(returnValue);
+		}
+		return returnValue;
+	};
+}();

Added: trunk/root/static/magic/src/uuid/TimeBasedGenerator.js
===================================================================
--- trunk/root/static/magic/src/uuid/TimeBasedGenerator.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/TimeBasedGenerator.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,391 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uuid.TimeBasedGenerator&quot;);
+dojo.require(&quot;dojo.lang.*&quot;);
+
+dojo.uuid.TimeBasedGenerator = new function() {
+
+// --------------------------------------------------
+// Public constants
+// --------------------------------------------------
+	// Number of hours between October 15, 1582 and January 1, 1970:
+	this.GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
+	
+	// Number of seconds between October 15, 1582 and January 1, 1970:
+	//   this.GREGORIAN_CHANGE_OFFSET_IN_SECONDS = 12219292800;	
+	
+// --------------------------------------------------
+// Private variables
+// --------------------------------------------------
+	var _uuidPseudoNodeString = null;
+	var _uuidClockSeqString = null;
+	var _dateValueOfPreviousUuid = null;
+	var _nextIntraMillisecondIncrement = 0;
+	var _cachedMillisecondsBetween1582and1970 = null;
+	var _cachedHundredNanosecondIntervalsPerMillisecond = null;
+	var _uniformNode = null;
+	var HEX_RADIX = 16;
+
+// --------------------------------------------------
+// Private functions
+// --------------------------------------------------
+
+/**
+ * Given an array which holds a 64-bit number broken into 4 16-bit elements,
+ * this method carries any excess bits (greater than 16-bits) from each array
+ * element into the next.
+ *
+ * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
+ */
+	function _carry(arrayA) {
+		arrayA[2] += arrayA[3] &gt;&gt;&gt; 16;
+		arrayA[3] &amp;= 0xFFFF;
+		arrayA[1] += arrayA[2] &gt;&gt;&gt; 16;
+		arrayA[2] &amp;= 0xFFFF;
+		arrayA[0] += arrayA[1] &gt;&gt;&gt; 16;
+		arrayA[1] &amp;= 0xFFFF;
+		dojo.lang.assert((arrayA[0] &gt;&gt;&gt; 16) === 0);
+	}
+
+/**
+ * Given a floating point number, this method returns an array which holds a
+ * 64-bit number broken into 4 16-bit elements.
+ *
+ * @param	x	A floating point number.
+ * @return   An array with 4 elements, each of which is a 16-bit number.
+ */
+	function _get64bitArrayFromFloat(x) {
+		var result = new Array(0, 0, 0, 0);
+		result[3] = x % 0x10000;
+		x -= result[3];
+		x /= 0x10000;
+		result[2] = x % 0x10000;
+		x -= result[2];
+		x /= 0x10000;
+		result[1] = x % 0x10000;
+		x -= result[1];
+		x /= 0x10000;
+		result[0] = x;
+		return result;
+	}
+
+/**
+ * Takes two arrays, each of which holds a 64-bit number broken into 4
+ * 16-bit elements, and returns a new array that holds a 64-bit number
+ * that is the sum of the two original numbers.
+ *
+ * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
+ * @param	arrayB	An array with 4 elements, each of which is a 16-bit number.
+ * @return   An array with 4 elements, each of which is a 16-bit number.
+ */
+	function _addTwo64bitArrays(arrayA, arrayB) {
+		dojo.lang.assertType(arrayA, Array);
+		dojo.lang.assertType(arrayB, Array);
+		dojo.lang.assert(arrayA.length == 4);
+		dojo.lang.assert(arrayB.length == 4);
+	
+		var result = new Array(0, 0, 0, 0);
+		result[3] = arrayA[3] + arrayB[3];
+		result[2] = arrayA[2] + arrayB[2];
+		result[1] = arrayA[1] + arrayB[1];
+		result[0] = arrayA[0] + arrayB[0];
+		_carry(result);
+		return result;
+	}
+
+/**
+ * Takes two arrays, each of which holds a 64-bit number broken into 4
+ * 16-bit elements, and returns a new array that holds a 64-bit number
+ * that is the product of the two original numbers.
+ *
+ * @param	arrayA	An array with 4 elements, each of which is a 16-bit number.
+ * @param	arrayB	An array with 4 elements, each of which is a 16-bit number.
+ * @return   An array with 4 elements, each of which is a 16-bit number.
+ */
+	function _multiplyTwo64bitArrays(arrayA, arrayB) {
+		dojo.lang.assertType(arrayA, Array);
+		dojo.lang.assertType(arrayB, Array);
+		dojo.lang.assert(arrayA.length == 4);
+		dojo.lang.assert(arrayB.length == 4);
+	
+		var overflow = false;
+		if (arrayA[0] * arrayB[0] !== 0) { overflow = true; }
+		if (arrayA[0] * arrayB[1] !== 0) { overflow = true; }
+		if (arrayA[0] * arrayB[2] !== 0) { overflow = true; }
+		if (arrayA[1] * arrayB[0] !== 0) { overflow = true; }
+		if (arrayA[1] * arrayB[1] !== 0) { overflow = true; }
+		if (arrayA[2] * arrayB[0] !== 0) { overflow = true; }
+		dojo.lang.assert(!overflow);
+	
+		var result = new Array(0, 0, 0, 0);
+		result[0] += arrayA[0] * arrayB[3];
+		_carry(result);
+		result[0] += arrayA[1] * arrayB[2];
+		_carry(result);
+		result[0] += arrayA[2] * arrayB[1];
+		_carry(result);
+		result[0] += arrayA[3] * arrayB[0];
+		_carry(result);
+		result[1] += arrayA[1] * arrayB[3];
+		_carry(result);
+		result[1] += arrayA[2] * arrayB[2];
+		_carry(result);
+		result[1] += arrayA[3] * arrayB[1];
+		_carry(result);
+		result[2] += arrayA[2] * arrayB[3];
+		_carry(result);
+		result[2] += arrayA[3] * arrayB[2];
+		_carry(result);
+		result[3] += arrayA[3] * arrayB[3];
+		_carry(result);
+		return result;
+	}
+
+/**
+ * Pads a string with leading zeros and returns the result.
+ * For example:
+ * &lt;pre&gt;
+ *   result = _padWithLeadingZeros(&quot;abc&quot;, 6);
+ *   dojo.lang.assert(result == &quot;000abc&quot;);
+ * &lt;/pre&gt;
+ *
+ * @param	string	A string to add padding to.
+ * @param	desiredLength	The number of characters the return string should have.
+ * @return   A string.
+ */
+	function _padWithLeadingZeros(string, desiredLength) {
+		while (string.length &lt; desiredLength) {
+			string = &quot;0&quot; + string;
+		}
+		return string;
+	}
+
+/**
+ * Returns a randomly generated 8-character string of hex digits.
+ *
+ * @return   An 8-character hex string.
+ */
+	function _generateRandomEightCharacterHexString() {
+		// FIXME: This probably isn't a very high quality random number.
+	
+		// Make random32bitNumber be a randomly generated floating point number
+		// between 0 and (4,294,967,296 - 1), inclusive.
+		var random32bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 32) );
+	
+		var eightCharacterString = random32bitNumber.toString(HEX_RADIX);
+		while (eightCharacterString.length &lt; 8) {
+			eightCharacterString = &quot;0&quot; + eightCharacterString;
+		}
+		return eightCharacterString;
+	}
+
+/**
+ * Generates a time-based UUID, meaning a version 1 UUID.  JavaScript
+ * code running in a browser doesn't have access to the IEEE 802.3 address
+ * of the computer, so if a node value isn't supplied, we generate a random 
+ * pseudonode value instead.
+ *
+ * @param	node	Optional. A 12-character string to use as the node in the new UUID.
+ * @return   Returns a 36 character string, which will look something like &quot;b4308fb0-86cd-11da-a72b-0800200c9a66&quot;.
+ */
+	function _generateUuidString(node) {
+		dojo.lang.assertType(node, [String, &quot;optional&quot;]);
+		if (node) {
+			dojo.lang.assert(node.length == 12);
+		} else {
+			if (_uniformNode) {
+				node = _uniformNode;
+			} else {
+				if (!_uuidPseudoNodeString) {
+					var pseudoNodeIndicatorBit = 0x8000;
+					var random15bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 15) );
+					var leftmost4HexCharacters = (pseudoNodeIndicatorBit | random15bitNumber).toString(HEX_RADIX);
+					_uuidPseudoNodeString = leftmost4HexCharacters + _generateRandomEightCharacterHexString();
+				}
+				node = _uuidPseudoNodeString;
+			}
+		}
+		if (!_uuidClockSeqString) {
+			var variantCodeForDCEUuids = 0x8000; // 10--------------, i.e. uses only first two of 16 bits.
+			var random14bitNumber = Math.floor( (Math.random() % 1) * Math.pow(2, 14) );
+			_uuidClockSeqString = (variantCodeForDCEUuids | random14bitNumber).toString(HEX_RADIX);
+		}
+	
+		// Maybe we should think about trying to make the code more readable to
+		// newcomers by creating a class called &quot;WholeNumber&quot; that encapsulates
+		// the methods and data structures for working with these arrays that
+		// hold 4 16-bit numbers?  And then these variables below have names
+		// like &quot;wholeSecondsPerHour&quot; rather than &quot;arraySecondsPerHour&quot;?
+		var now = new Date();
+		var millisecondsSince1970 = now.valueOf(); // milliseconds since midnight 01 January, 1970 UTC.
+		var nowArray = _get64bitArrayFromFloat(millisecondsSince1970);
+		if (!_cachedMillisecondsBetween1582and1970) {
+			var arraySecondsPerHour = _get64bitArrayFromFloat(60 * 60);
+			var arrayHoursBetween1582and1970 = _get64bitArrayFromFloat(dojo.uuid.TimeBasedGenerator.GREGORIAN_CHANGE_OFFSET_IN_HOURS);
+			var arraySecondsBetween1582and1970 = _multiplyTwo64bitArrays(arrayHoursBetween1582and1970, arraySecondsPerHour);
+			var arrayMillisecondsPerSecond = _get64bitArrayFromFloat(1000);
+			_cachedMillisecondsBetween1582and1970 = _multiplyTwo64bitArrays(arraySecondsBetween1582and1970, arrayMillisecondsPerSecond);
+			_cachedHundredNanosecondIntervalsPerMillisecond = _get64bitArrayFromFloat(10000);
+		}
+		var arrayMillisecondsSince1970 = nowArray;
+		var arrayMillisecondsSince1582 = _addTwo64bitArrays(_cachedMillisecondsBetween1582and1970, arrayMillisecondsSince1970);
+		var arrayHundredNanosecondIntervalsSince1582 = _multiplyTwo64bitArrays(arrayMillisecondsSince1582, _cachedHundredNanosecondIntervalsPerMillisecond);
+	
+		if (now.valueOf() == _dateValueOfPreviousUuid) {
+			arrayHundredNanosecondIntervalsSince1582[3] += _nextIntraMillisecondIncrement;
+			_carry(arrayHundredNanosecondIntervalsSince1582);
+			_nextIntraMillisecondIncrement += 1;
+			if (_nextIntraMillisecondIncrement == 10000) {
+				// If we've gotten to here, it means we've already generated 10,000
+				// UUIDs in this single millisecond, which is the most that the UUID
+				// timestamp field allows for.  So now we'll just sit here and wait
+				// for a fraction of a millisecond, so as to ensure that the next
+				// time this method is called there will be a different millisecond
+				// value in the timestamp field.
+				while (now.valueOf() == _dateValueOfPreviousUuid) {
+					now = new Date();
+				}
+			}
+		} else {
+			_dateValueOfPreviousUuid = now.valueOf();
+			_nextIntraMillisecondIncrement = 1;
+		}
+	
+		var hexTimeLowLeftHalf  = arrayHundredNanosecondIntervalsSince1582[2].toString(HEX_RADIX);
+		var hexTimeLowRightHalf = arrayHundredNanosecondIntervalsSince1582[3].toString(HEX_RADIX);
+		var hexTimeLow = _padWithLeadingZeros(hexTimeLowLeftHalf, 4) + _padWithLeadingZeros(hexTimeLowRightHalf, 4);
+		var hexTimeMid = arrayHundredNanosecondIntervalsSince1582[1].toString(HEX_RADIX);
+		hexTimeMid = _padWithLeadingZeros(hexTimeMid, 4);
+		var hexTimeHigh = arrayHundredNanosecondIntervalsSince1582[0].toString(HEX_RADIX);
+		hexTimeHigh = _padWithLeadingZeros(hexTimeHigh, 3);
+		var hyphen = &quot;-&quot;;
+		var versionCodeForTimeBasedUuids = &quot;1&quot;; // binary2hex(&quot;0001&quot;)
+		var resultUuid = hexTimeLow + hyphen + hexTimeMid + hyphen +
+					versionCodeForTimeBasedUuids + hexTimeHigh + hyphen +
+					_uuidClockSeqString + hyphen + node;
+		resultUuid = resultUuid.toLowerCase();
+		return resultUuid;
+	}
+
+// --------------------------------------------------
+// Public functions
+// --------------------------------------------------
+
+/**
+ * Sets the 'node' value that will be included in generated UUIDs.
+ *
+ * @param	node	A 12-character hex string representing a pseudoNode or hardwareNode.
+ */
+	this.setNode = function(node) {
+		dojo.lang.assert((node === null) || (node.length == 12));
+		_uniformNode = node;
+	};
+
+/**
+ * Returns the 'node' value that will be included in generated UUIDs.
+ *
+ * @return	A 12-character hex string representing a pseudoNode or hardwareNode.
+ */
+	this.getNode = function() {
+		return _uniformNode;
+	};
+
+/**
+ * This function generates time-based UUIDs, meaning &quot;version 1&quot; UUIDs.
+ *
+ * For more info, see
+ *   <A HREF="http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt">http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt</A>
+ *   <A HREF="http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm">http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm</A>
+ *   <A HREF="http://kruithof.xs4all.nl/uuid/uuidgen">http://kruithof.xs4all.nl/uuid/uuidgen</A>
+ *   <A HREF="http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20">http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20</A>
+ *   <A HREF="http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html">http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html</A>
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var generate = dojo.uuid.TimeBasedGenerator.generate;
+ *   var uuid;   // an instance of dojo.uuid.Uuid
+ *   var string; // a simple string literal
+ *   string = generate();
+ *   string = generate(String);
+ *   uuid   = generate(dojo.uuid.Uuid);
+ *   string = generate(&quot;017bf397618a&quot;);
+ *   string = generate({node: &quot;017bf397618a&quot;});         // hardwareNode
+ *   string = generate({node: &quot;f17bf397618a&quot;});         // pseudoNode
+ *   string = generate({hardwareNode: &quot;017bf397618a&quot;});
+ *   string = generate({pseudoNode:   &quot;f17bf397618a&quot;});
+ *   string = generate({node: &quot;017bf397618a&quot;, returnType: String});
+ *   uuid   = generate({node: &quot;017bf397618a&quot;, returnType: dojo.uuid.Uuid});
+ *   dojo.uuid.TimeBasedGenerator.setNode(&quot;017bf397618a&quot;);
+ *   string = generate(); // the generated UUID has node == &quot;017bf397618a&quot;
+ *   uuid   = generate(dojo.uuid.Uuid); // the generated UUID has node == &quot;017bf397618a&quot;
+ * &lt;/pre&gt;
+ *
+ * @param	class	The type of instance to return.
+ * @param	node	A 12-character hex string representing a pseudoNode or hardwareNode.
+ * @namedParam	node	A 12-character hex string representing a pseudoNode or hardwareNode.
+ * @namedParam	hardwareNode	A 12-character hex string containing an IEEE 802.3 network node identificator.
+ * @namedParam	pseudoNode	A 12-character hex string representing a pseudoNode.
+ * @namedParam	returnType	The type of instance to return.
+ * @return	A newly generated version 1 UUID.
+ */
+	this.generate = function(input) {
+		var nodeString = null;
+		var returnType = null;
+		
+		if (input) {
+			if (dojo.lang.isObject(input) &amp;&amp; !dojo.lang.isBuiltIn(input)) {
+				var namedParameters = input;
+				dojo.lang.assertValidKeywords(namedParameters, [&quot;node&quot;, &quot;hardwareNode&quot;, &quot;pseudoNode&quot;, &quot;returnType&quot;]);
+				var node = namedParameters[&quot;node&quot;];
+				var hardwareNode = namedParameters[&quot;hardwareNode&quot;];
+				var pseudoNode = namedParameters[&quot;pseudoNode&quot;];
+				nodeString = (node || pseudoNode || hardwareNode);
+				if (nodeString) {
+					var firstCharacter = nodeString.charAt(0);
+					var firstDigit = parseInt(firstCharacter, HEX_RADIX);
+					if (hardwareNode) {
+						dojo.lang.assert((firstDigit &gt;= 0x0) &amp;&amp; (firstDigit &lt;= 0x7));
+					}
+					if (pseudoNode) {
+						dojo.lang.assert((firstDigit &gt;= 0x8) &amp;&amp; (firstDigit &lt;= 0xF));
+					}
+				}
+				returnType = namedParameters[&quot;returnType&quot;];
+				dojo.lang.assertType(returnType, [Function, &quot;optional&quot;]);
+			} else {
+				if (dojo.lang.isString(input)) {
+					nodeString = input;
+					returnType = null;
+				} else {
+					if (dojo.lang.isFunction(input)) {
+						nodeString = null;
+						returnType = input;
+					}
+				}
+			}
+			if (nodeString) {
+				dojo.lang.assert(nodeString.length == 12);
+				var integer = parseInt(nodeString, HEX_RADIX);
+				dojo.lang.assert(isFinite(integer));
+			}
+			dojo.lang.assertType(returnType, [Function, &quot;optional&quot;]);
+		}
+		
+		var uuidString = _generateUuidString(nodeString);
+		var returnValue;
+		if (returnType &amp;&amp; (returnType != String)) {
+			returnValue = new returnType(uuidString);
+		} else {
+			returnValue = uuidString;
+		}
+		return returnValue;
+	};
+}();

Added: trunk/root/static/magic/src/uuid/Uuid.js
===================================================================
--- trunk/root/static/magic/src/uuid/Uuid.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/Uuid.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,423 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.uuid.Uuid&quot;);
+dojo.require(&quot;dojo.lang.*&quot;);
+
+// -------------------------------------------------------------------
+// Constructor
+// -------------------------------------------------------------------
+/**
+ * The Uuid class offers methods for inspecting existing UUIDs.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var uuid;
+ *   uuid = new dojo.uuid.Uuid(&quot;3b12f1df-5232-4804-897e-917bf397618a&quot;);
+ *   uuid = new dojo.uuid.Uuid(); // &quot;00000000-0000-0000-0000-000000000000&quot;
+ *   uuid = new dojo.uuid.Uuid(dojo.uuid.RandomGenerator);
+ *   uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);
+ *
+ *   dojo.uuid.Uuid.setGenerator(dojo.uuid.RandomGenerator);
+ *   uuid = new dojo.uuid.Uuid();
+ *   dojo.lang.assert(!uuid.isEqual(dojo.uuid.Uuid.NIL_UUID));
+ * &lt;/pre&gt;
+ *
+ * @scope	public instance constructor
+ * @param	uuidString	A 36-character string that conforms to the UUID spec.
+ * @param	generator	A UUID generator, such as dojo.uuid.TimeBasedGenerator.
+ */
+dojo.uuid.Uuid = function(input) {
+	this._uuidString = dojo.uuid.Uuid.NIL_UUID;
+	if (input) {
+		if (dojo.lang.isString(input)) {
+			this._uuidString = input.toLowerCase();
+			dojo.lang.assert(this.isValid());
+		} else {
+			if (dojo.lang.isObject(input) &amp;&amp; input.generate) {
+				var generator = input;
+				this._uuidString = generator.generate();
+				dojo.lang.assert(this.isValid());
+			} else {
+				// we got passed something other than a string
+				dojo.lang.assert(false, &quot;The dojo.uuid.Uuid() constructor must be initializated with a UUID string.&quot;);
+			}
+		}
+	} else {
+		var ourGenerator = dojo.uuid.Uuid.getGenerator();
+		if (ourGenerator) {
+			this._uuidString = ourGenerator.generate();
+			dojo.lang.assert(this.isValid());
+		}
+	}
+};
+
+// -------------------------------------------------------------------
+// Public constants
+// -------------------------------------------------------------------
+dojo.uuid.Uuid.NIL_UUID = &quot;00000000-0000-0000-0000-000000000000&quot;;
+dojo.uuid.Uuid.Version = {
+	UNKNOWN: 0,
+	TIME_BASED: 1,
+	DCE_SECURITY: 2,
+	NAME_BASED_MD5: 3,
+	RANDOM: 4,
+	NAME_BASED_SHA1: 5 };
+dojo.uuid.Uuid.Variant = {
+	NCS: &quot;0&quot;,
+	DCE: &quot;10&quot;,
+	MICROSOFT: &quot;110&quot;,
+	UNKNOWN: &quot;111&quot; };
+dojo.uuid.Uuid.HEX_RADIX = 16;
+
+// -------------------------------------------------------------------
+// Public class methods
+// -------------------------------------------------------------------
+/**
+ * Given two UUIDs to compare, this method returns 0, 1, or -1.
+ * This method is designed to be used by sorting routines, like
+ * the JavaScript built-in Array sort() method.
+ * This implementation is intended to match the sample 
+ * implementation in IETF RFC 4122: 
+ * <A HREF="http://www.ietf.org/rfc/rfc4122.txt">http://www.ietf.org/rfc/rfc4122.txt</A>
+ * 
+ * Example:
+ * &lt;pre&gt;
+ *   var generator = dojo.uuid.TimeBasedGenerator;
+ *   var a = new dojo.uuid.Uuid(generator);
+ *   var b = new dojo.uuid.Uuid(generator);
+ *   var c = new dojo.uuid.Uuid(generator);
+ *   var array = new Array(a, b, c);
+ *   array.sort(dojo.uuid.Uuid.compare);
+ * &lt;/pre&gt;
+ *
+ * @param	uuidOne	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @param	uuidTwo	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns either 0, 1, or -1.
+ */
+dojo.uuid.Uuid.compare = function(uuidOne, uuidTwo) {
+	var uuidStringOne = uuidOne.toString();
+	var uuidStringTwo = uuidTwo.toString();
+	if (uuidStringOne &gt; uuidStringTwo) return 1;
+	if (uuidStringOne &lt; uuidStringTwo) return -1;
+	return 0;
+};
+
+/**
+ * Sets the default generator, which will be used by the 
+ * &quot;new dojo.uuid.Uuid()&quot; constructor if no parameters
+ * are passed in.
+ *
+ * @param	generator	A UUID generator, such as dojo.uuid.TimeBasedGenerator.
+ * @return   Returns true or false. True if this UUID is equal to the otherUuid.
+ */
+dojo.uuid.Uuid.setGenerator = function(generator) {
+	dojo.lang.assert(!generator || (dojo.lang.isObject(generator) &amp;&amp; generator.generate));
+	dojo.uuid.Uuid._ourGenerator = generator;
+};
+
+/**
+ * Returns the default generator.  See setGenerator().
+ *
+ * @return   A UUID generator, such as dojo.uuid.TimeBasedGenerator.
+ */
+dojo.uuid.Uuid.getGenerator = function(generator) {
+	return dojo.uuid.Uuid._ourGenerator;
+};
+
+// -------------------------------------------------------------------
+// Public instance methods
+// -------------------------------------------------------------------
+/**
+ * Returns a 36-character string representing the UUID, such 
+ * as &quot;3b12f1df-5232-4804-897e-917bf397618a&quot;.
+ * 
+ * Examples:
+ * &lt;pre&gt;
+ *   var uuid = new dojo.uuid.Uuid(dojo.uuid.TimeBasedGenerator);
+ *   var s;
+ *   s = uuid.toString();       //  eb529fec-6498-11d7-b236-000629ba5445
+ *   s = uuid.toString('{}');   // {eb529fec-6498-11d7-b236-000629ba5445}
+ *   s = uuid.toString('()');   // (eb529fec-6498-11d7-b236-000629ba5445)
+ *   s = uuid.toString('&quot;&quot;');   // &quot;eb529fec-6498-11d7-b236-000629ba5445&quot;
+ *   s = uuid.toString(&quot;''&quot;);   // 'eb529fec-6498-11d7-b236-000629ba5445'
+ *   s = uuid.toString('!-');   //  eb529fec649811d7b236000629ba5445
+ *   s = uuid.toString('urn');  //  urn:uuid:eb529fec-6498-11d7-b236-000629ba5445
+ * &lt;/pre&gt;
+ *
+ * @param	uuidOne	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns a standard 36-character UUID string, or something similar. 
+ */
+dojo.uuid.Uuid.prototype.toString = function(format) {
+	if (format) {
+		switch (format) {
+			case '{}':
+				return '{' + this._uuidString + '}';
+				break;
+			case '()':
+				return '(' + this._uuidString + ')';
+				break;
+			case '&quot;&quot;':
+				return '&quot;' + this._uuidString + '&quot;';
+				break;
+			case &quot;''&quot;:
+				return &quot;'&quot; + this._uuidString + &quot;'&quot;;
+				break;
+			case 'urn':
+				return 'urn:uuid:' + this._uuidString;
+				break;
+			case '!-':
+				return this._uuidString.split('-').join('');
+				break;
+			default:
+				// we got passed something other than what we expected
+				dojo.lang.assert(false, &quot;The toString() method of dojo.uuid.Uuid was passed a bogus format.&quot;);
+		}
+	} else {
+		return this._uuidString;
+	}
+};
+
+/**
+ * Compares this UUID to another UUID, and returns 0, 1, or -1.
+ * This implementation is intended to match the sample 
+ * implementation in IETF RFC 4122: 
+ * <A HREF="http://www.ietf.org/rfc/rfc4122.txt">http://www.ietf.org/rfc/rfc4122.txt</A>
+ *
+ * @param	otherUuid	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns either 0, 1, or -1.
+ */
+dojo.uuid.Uuid.prototype.compare = function(otherUuid) {
+	return dojo.uuid.Uuid.compare(this, otherUuid);
+};
+
+/**
+ * Returns true if this UUID is equal to the otherUuid, or
+ * false otherwise.
+ *
+ * @param	otherUuid	A dojo.uuid.Uuid instance, or a string representing a UUID.
+ * @return   Returns true or false. True if this UUID is equal to the otherUuid.
+ */
+dojo.uuid.Uuid.prototype.isEqual = function(otherUuid) {
+	return (this.compare(otherUuid) == 0);
+};
+
+/**
+ * Returns true if the UUID was initialized with a valid value.
+ *
+ * @return   True if the UUID is valid, or false if it is not.
+ */
+dojo.uuid.Uuid.prototype.isValid = function() {
+	try {
+		dojo.lang.assertType(this._uuidString, String);
+		dojo.lang.assert(this._uuidString.length == 36);
+		dojo.lang.assert(this._uuidString == this._uuidString.toLowerCase());
+		var arrayOfParts = this._uuidString.split(&quot;-&quot;);
+		dojo.lang.assert(arrayOfParts.length == 5);
+		dojo.lang.assert(arrayOfParts[0].length == 8);
+		dojo.lang.assert(arrayOfParts[1].length == 4);
+		dojo.lang.assert(arrayOfParts[2].length == 4);
+		dojo.lang.assert(arrayOfParts[3].length == 4);
+		dojo.lang.assert(arrayOfParts[4].length == 12);
+		for (var i in arrayOfParts) {
+			var part = arrayOfParts[i];
+			var integer = parseInt(part, dojo.uuid.Uuid.HEX_RADIX);
+			dojo.lang.assert(isFinite(integer));
+		}
+		return true;
+	} catch (e) {
+		return false;
+	}
+};
+
+/**
+ * Returns a variant code that indicates what type of UUID this is.
+ * For example:
+ * &lt;pre&gt;
+ *   var uuid = new dojo.uuid.Uuid(&quot;3b12f1df-5232-4804-897e-917bf397618a&quot;);
+ *   var variant = uuid.getVariant();
+ *   dojo.lang.assert(variant == dojo.uuid.Uuid.Variant.DCE);
+ * &lt;/pre&gt;
+ *
+ * @return   Returns one of the enumarted dojo.uuid.Uuid.Variant values.
+ */
+dojo.uuid.Uuid.prototype.getVariant = function() {
+	// &quot;3b12f1df-5232-4804-897e-917bf397618a&quot;
+	//                     ^
+	//                     |
+	//         (variant &quot;10__&quot; == DCE)
+	var variantCharacter = this._uuidString.charAt(19);
+	var variantNumber = parseInt(variantCharacter, dojo.uuid.Uuid.HEX_RADIX);
+	dojo.lang.assert((variantNumber &gt;= 0) &amp;&amp; (variantNumber &lt;= 16));
+
+	if (!dojo.uuid.Uuid._ourVariantLookupTable) {
+		var Variant = dojo.uuid.Uuid.Variant;
+		var lookupTable = [];
+
+		lookupTable[0x0] = Variant.NCS;       // 0000
+		lookupTable[0x1] = Variant.NCS;       // 0001
+		lookupTable[0x2] = Variant.NCS;       // 0010
+		lookupTable[0x3] = Variant.NCS;       // 0011
+
+		lookupTable[0x4] = Variant.NCS;       // 0100
+		lookupTable[0x5] = Variant.NCS;       // 0101
+		lookupTable[0x6] = Variant.NCS;       // 0110
+		lookupTable[0x7] = Variant.NCS;       // 0111
+
+		lookupTable[0x8] = Variant.DCE;       // 1000
+		lookupTable[0x9] = Variant.DCE;       // 1001
+		lookupTable[0xA] = Variant.DCE;       // 1010
+		lookupTable[0xB] = Variant.DCE;       // 1011
+
+		lookupTable[0xC] = Variant.MICROSOFT; // 1100
+		lookupTable[0xD] = Variant.MICROSOFT; // 1101
+		lookupTable[0xE] = Variant.UNKNOWN;   // 1110
+		lookupTable[0xF] = Variant.UNKNOWN;   // 1111
+		
+		dojo.uuid.Uuid._ourVariantLookupTable = lookupTable;
+	}
+
+	return dojo.uuid.Uuid._ourVariantLookupTable[variantNumber];
+};
+
+/**
+ * Returns a version number that indicates what type of UUID this is.
+ * For example:
+ * &lt;pre&gt;
+ *   var uuid = new dojo.uuid.Uuid(&quot;b4308fb0-86cd-11da-a72b-0800200c9a66&quot;);
+ *   var version = uuid.getVersion();
+ *   dojo.lang.assert(version == dojo.uuid.Uuid.Version.TIME_BASED);
+ * &lt;/pre&gt;
+ *
+ * @return   Returns one of the enumerated dojo.uuid.Uuid.Version values.
+ * @throws   Throws an Error if this is not a DCE Variant UUID.
+ */
+dojo.uuid.Uuid.prototype.getVersion = function() {
+	if (!this._versionNumber) {
+		var errorMessage = &quot;Called getVersion() on a dojo.uuid.Uuid that was not a DCE Variant UUID.&quot;;
+		dojo.lang.assert(this.getVariant() == dojo.uuid.Uuid.Variant.DCE, errorMessage);
+	
+		// &quot;b4308fb0-86cd-11da-a72b-0800200c9a66&quot;
+		//                ^
+		//                |
+		//       (version 1 == TIME_BASED)
+		var versionCharacter = this._uuidString.charAt(14);
+		this._versionNumber = parseInt(versionCharacter, dojo.uuid.Uuid.HEX_RADIX);
+	}
+	return this._versionNumber;
+};
+
+/**
+ * If this is a version 1 UUID (a time-based UUID), this method returns a 
+ * 12-character string with the &quot;node&quot; or &quot;pseudonode&quot; portion of the UUID, 
+ * which is the rightmost 12 characters.  
+ * Throws an Error if this is not a version 1 UUID.
+ *
+ * @return   Returns a 12-character string, which will look something like &quot;917bf397618a&quot;.
+ * @throws   Throws an Error if this is not a version 1 UUID.
+ */
+dojo.uuid.Uuid.prototype.getNode = function() {
+	if (!this._nodeString) {
+		var errorMessage = &quot;Called getNode() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.&quot;;
+		dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);
+
+		var arrayOfStrings = this._uuidString.split('-');
+		this._nodeString = arrayOfStrings[4];
+	}
+	return this._nodeString;
+};
+
+/**
+ * If this is a version 1 UUID (a time-based UUID), this method returns 
+ * the timestamp value encoded in the UUID.  The caller can ask for the
+ * timestamp to be returned either as a JavaScript Date object or as a 
+ * 15-character string of hex digits.
+ * Throws an Error if this is not a version 1 UUID.
+ *
+ * Examples:
+ * &lt;pre&gt;
+ *   var uuid = new dojo.uuid.Uuid(&quot;b4308fb0-86cd-11da-a72b-0800200c9a66&quot;);
+ *   var date, string, hexString;
+ *   date   = uuid.getTimestamp();         // returns a JavaScript Date
+ *   date   = uuid.getTimestamp(Date);     // 
+ *   string = uuid.getTimestamp(String);   // &quot;Mon, 16 Jan 2006 20:21:41 GMT&quot;
+ *   hexString = uuid.getTimestamp(&quot;hex&quot;); // &quot;1da86cdb4308fb0&quot;
+ * &lt;/pre&gt;
+ *
+ * @return   Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
+ * @throws   Throws an Error if this is not a version 1 UUID.
+ */
+dojo.uuid.Uuid.prototype.getTimestamp = function(returnType) {
+	var errorMessage = &quot;Called getTimestamp() on a dojo.uuid.Uuid that was not a TIME_BASED UUID.&quot;;
+	dojo.lang.assert(this.getVersion() == dojo.uuid.Uuid.Version.TIME_BASED, errorMessage);
+	
+	if (!returnType) {returnType = null};
+	switch (returnType) {
+		case &quot;string&quot;:
+		case String:
+			return this.getTimestamp(Date).toUTCString();
+			break;
+		case &quot;hex&quot;:
+			// Return a 15-character string of hex digits containing the 
+			// timestamp for this UUID, with the high-order bits first.
+			if (!this._timestampAsHexString) {
+				var arrayOfStrings = this._uuidString.split('-');
+				var hexTimeLow = arrayOfStrings[0];
+				var hexTimeMid = arrayOfStrings[1];
+				var hexTimeHigh = arrayOfStrings[2];
+			
+				// Chop off the leading &quot;1&quot; character, which is the UUID 
+				// version number for time-based UUIDs.
+				hexTimeHigh = hexTimeHigh.slice(1);
+			
+				this._timestampAsHexString = hexTimeHigh + hexTimeMid + hexTimeLow;
+				dojo.lang.assert(this._timestampAsHexString.length == 15);
+			}
+			return this._timestampAsHexString;
+			break;
+		case null: // no returnType was specified, so default to Date
+		case &quot;date&quot;:
+		case Date:
+			// Return a JavaScript Date object. 
+			if (!this._timestampAsDate) {
+				var GREGORIAN_CHANGE_OFFSET_IN_HOURS = 3394248;
+			
+				var arrayOfParts = this._uuidString.split('-');
+				var timeLow = parseInt(arrayOfParts[0], dojo.uuid.Uuid.HEX_RADIX);
+				var timeMid = parseInt(arrayOfParts[1], dojo.uuid.Uuid.HEX_RADIX);
+				var timeHigh = parseInt(arrayOfParts[2], dojo.uuid.Uuid.HEX_RADIX);
+				var hundredNanosecondIntervalsSince1582 = timeHigh &amp; 0x0FFF;
+				hundredNanosecondIntervalsSince1582 &lt;&lt;= 16;
+				hundredNanosecondIntervalsSince1582 += timeMid;
+				// What we really want to do next is shift left 32 bits, but the 
+				// result will be too big to fit in an int, so we'll multiply by 2^32,
+				// and the result will be a floating point approximation.
+				hundredNanosecondIntervalsSince1582 *= 0x100000000;
+				hundredNanosecondIntervalsSince1582 += timeLow;
+				var millisecondsSince1582 = hundredNanosecondIntervalsSince1582 / 10000;
+			
+				// Again, this will be a floating point approximation.
+				// We can make things exact later if we need to.
+				var secondsPerHour = 60 * 60;
+				var hoursBetween1582and1970 = GREGORIAN_CHANGE_OFFSET_IN_HOURS;
+				var secondsBetween1582and1970 = hoursBetween1582and1970 * secondsPerHour;
+				var millisecondsBetween1582and1970 = secondsBetween1582and1970 * 1000;
+				var millisecondsSince1970 = millisecondsSince1582 - millisecondsBetween1582and1970;
+			
+				this._timestampAsDate = new Date(millisecondsSince1970);
+			}
+			return this._timestampAsDate;
+			break;
+		default:
+			// we got passed something other than a valid returnType
+			dojo.lang.assert(false, &quot;The getTimestamp() method dojo.uuid.Uuid was passed a bogus returnType: &quot; + returnType);
+			break;
+	}
+};

Added: trunk/root/static/magic/src/uuid/__package__.js
===================================================================
--- trunk/root/static/magic/src/uuid/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/uuid/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [
+		&quot;dojo.uuid.Uuid&quot;,
+		&quot;dojo.uuid.LightweightGenerator&quot;,
+		&quot;dojo.uuid.RandomGenerator&quot;,
+		&quot;dojo.uuid.TimeBasedGenerator&quot;,
+		&quot;dojo.uuid.NameBasedGenerator&quot;,
+		&quot;dojo.uuid.NilGenerator&quot;
+	]
+});
+dojo.provide(&quot;dojo.uuid.*&quot;);
+

Added: trunk/root/static/magic/src/validate/__package__.js
===================================================================
--- trunk/root/static/magic/src/validate/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,21 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.validate&quot;);
+dojo.kwCompoundRequire({
+	common:		[&quot;dojo.validate.check&quot;, 
+						&quot;dojo.validate.datetime&quot;, 
+						&quot;dojo.validate.de&quot;, 
+						&quot;dojo.validate.jp&quot;, 
+						&quot;dojo.validate.us&quot;, 
+						&quot;dojo.validate.web&quot; 
+	],
+});
+dojo.provide(&quot;dojo.validate.*&quot;);

Added: trunk/root/static/magic/src/validate/check.js
===================================================================
--- trunk/root/static/magic/src/validate/check.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/check.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,221 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.check&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+
+/**
+  Validates user input of an HTML form based on input profile.
+
+	@param form  The form object to be validated.
+	@param profile  The input profile that specifies how the form fields are to be validated.
+	@return results  An object that contains several methods summarizing the results of the validation.
+*/
+dojo.validate.check = function(form, profile) {
+	// Essentially private properties of results object
+	var missing = [];
+	var invalid = [];
+
+	// results object summarizes the validation
+	var results = {
+		isSuccessful: function() {return ( !this.hasInvalid() &amp;&amp; !this.hasMissing() );},
+		hasMissing: function() {return ( missing.length &gt; 0 );},
+		getMissing: function() {return missing;},
+		isMissing: function(elemname) {
+			for (var i = 0; i &lt; missing.length; i++) {
+				if ( elemname == missing[i] ) { return true; }
+			}
+			return false;
+		},
+		hasInvalid: function() {return ( invalid.length &gt; 0 );},
+		getInvalid: function() {return invalid;},
+		isInvalid: function(elemname) {
+			for (var i = 0; i &lt; invalid.length; i++) {
+				if ( elemname == invalid[i] ) { return true; }
+			}
+			return false;
+		}
+	};
+
+	// Filters are applied before fields are validated.
+	// Trim removes white space at the front and end of the fields.
+	if ( profile.trim instanceof Array ) {
+		for (var i = 0; i &lt; profile.trim.length; i++) {
+			var elem = form[profile.trim[i]];
+			if ( elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot; ) { continue; }
+			elem.value = elem.value.replace(/(^\s*|\s*$)/g, &quot;&quot;);
+		}
+	}
+	// Convert to uppercase
+	if ( profile.uppercase instanceof Array ) {
+		for (var i = 0; i &lt; profile.uppercase.length; i++) {
+			var elem = form[profile.uppercase[i]];
+			if ( elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot; ) { continue; }
+			elem.value = elem.value.toUpperCase();
+		}
+	}
+	// Convert to lowercase
+	if ( profile.lowercase instanceof Array ) {
+		for (var i = 0; i &lt; profile.lowercase.length; i++) {
+			var elem = form[profile.lowercase[i]];
+			if ( elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot; ) { continue; }
+			elem.value = elem.value.toLowerCase();
+		}
+	}
+	// Uppercase first letter
+	if ( profile.ucfirst instanceof Array ) {
+		for (var i = 0; i &lt; profile.ucfirst.length; i++) {
+			var elem = form[profile.ucfirst[i]];
+			if ( elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot; ) { continue; }
+			elem.value = elem.value.replace(/\b\w+\b/g, function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });
+		}
+	}
+	// Remove non digits characters from the input.
+	if ( profile.digit instanceof Array ) {
+		for (var i = 0; i &lt; profile.digit.length; i++) {
+			var elem = form[profile.digit[i]];
+			if ( elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot; ) { continue; }
+			elem.value = elem.value.replace(/\D/g, &quot;&quot;);
+		}
+	}
+
+	// See if required input fields have values missing.
+	if ( profile.required instanceof Array ) {
+		for (var i = 0; i &lt; profile.required.length; i++) { 
+			if(!dojo.lang.isString(profile.required[i])){ continue; }
+			var elem = form[profile.required[i]];
+			// Are textbox, textarea, or password fields blank.
+			if ( (elem.type == &quot;text&quot; || elem.type == &quot;textarea&quot; || elem.type == &quot;password&quot;) &amp;&amp; /^\s*$/.test(elem.value) ) {	
+				missing[missing.length] = elem.name;
+			}
+			// Does drop-down box have option selected.
+			else if ( (elem.type == &quot;select-one&quot; || elem.type == &quot;select-multiple&quot;) &amp;&amp; elem.selectedIndex == -1 ) {
+				missing[missing.length] = elem.name;
+			}
+			// Does radio button group (or check box group) have option checked.
+			else if ( elem instanceof Array )  {
+				var checked = false;
+				for (var j = 0; j &lt; elem.length; j++) {
+					if (elem[j].checked) { checked = true; }
+				}
+				if ( !checked ) {	
+					missing[missing.length] = elem[0].name;
+				}
+			}
+		}
+	}
+
+	// See if checkbox groups and select boxes have x number of required values.
+	if ( profile.required instanceof Array ) {
+		for (var i = 0; i &lt; profile.required.length; i++) { 
+			if(!dojo.lang.isObject(profile.required[i])){ continue; }
+			var elem, numRequired;
+			for (var name in profile.required[i]) { 
+				elem = form[name]; 
+				numRequired = profile.required[i][name];
+			}
+			// case 1: elem is a check box group
+			if ( elem instanceof Array )  {
+				var checked = 0;
+				for (var j = 0; j &lt; elem.length; j++) {
+					if (elem[j].checked) { checked++; }
+				}
+				if ( checked &lt; numRequired ) {	
+					missing[missing.length] = elem[0].name;
+				}
+			}
+			// case 2: elem is a select box
+			else if ( elem.type == &quot;select-multiple&quot; ) {
+				var selected = 0;
+				for (var j = 0; j &lt; elem.options.length; j++) {
+					if (elem.options[j].selected) { selected++; }
+				}
+				if ( selected &lt; numRequired ) {	
+					missing[missing.length] = elem.name;
+				}
+			}
+		}
+	}
+
+	// Dependant fields are required when the target field is present (not blank).
+	// Todo: Support dependant and target fields that are radio button groups, or select drop-down lists.
+	// Todo: Make the dependancy based on a specific value of the target field.
+	// Todo: allow dependant fields to have several required values, like {checkboxgroup: 3}.
+	if(dojo.lang.isObject(profile.dependancies)){
+		// properties of dependancies object are the names of dependant fields to be checked
+		for (name in profile.dependancies) {
+			var elem = form[name];	// the dependant element
+			if ( elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot; ) { continue; } // limited support
+			if ( /\S+/.test(elem.value) ) { continue; }	// has a value already
+			if ( results.isMissing(elem.name) ) { continue; }	// already listed as missing
+			var target = form[profile.dependancies[name]];
+			if ( target.type != &quot;text&quot; &amp;&amp; target.type != &quot;textarea&quot; &amp;&amp; target.type != &quot;password&quot; ) { continue; }	// limited support
+			if ( /^\s*$/.test(target.value) ) { continue; }	// skip if blank
+			missing[missing.length] = elem.name;	// ok the dependant field is missing
+		}
+	}
+
+	// Find invalid input fields.
+	if(dojo.lang.isObject(profile.constraints)){
+		// constraint properties are the names of fields to be validated
+		for(name in profile.constraints){
+			var elem = form[name];
+			if(	(elem.type != &quot;text&quot;)&amp;&amp;
+				(elem.type != &quot;textarea&quot;)&amp;&amp;
+				(elem.type != &quot;password&quot;)){
+				continue;
+			}
+			// skip if blank - its optional unless required, in which case it
+			// is already listed as missing.
+			if( /^\s*$/.test(elem.value)){ continue; }
+
+			var isValid = true;
+			// case 1: constraint value is validation function
+			if(dojo.lang.isFunction(profile.constraints[name])){
+				isValid = profile.constraints[name](elem.value);
+			}else if(dojo.lang.isArray(profile.constraints[name])){
+				// case 2: constraint value is array, first elem is function,
+				// tail is parameters
+				var isValidSomething = profile.constraints[name][0];
+				var params = profile.constraints[name].slice(1);
+				params.unshift(elem.value);
+				if(typeof isValidSomething != &quot;undefined&quot;){
+					isValid = isValidSomething.apply(null, params);
+				}else{
+					isValid = false; 
+				}
+			}
+
+			if(!isValid){	
+				invalid[invalid.length] = elem.name;
+			}
+		}
+	}
+
+	// Find unequal confirm fields and report them as Invalid.
+	if(dojo.lang.isObject(profile.confirm)){
+		for(name in profile.confirm){
+			var elem = form[name];	// the confirm element
+			var target = form[profile.confirm[name]];
+			if ( (elem.type != &quot;text&quot; &amp;&amp; elem.type != &quot;textarea&quot; &amp;&amp; elem.type != &quot;password&quot;) 
+				||(target.type != elem.type)
+				||(target.value == elem.value)	// it's valid
+				||(results.isInvalid(elem.name))// already listed as invalid
+				||(/^\s*$/.test(target.value))	)	// skip if blank - only confirm if target has a value
+			{
+				continue; 
+			}	
+			invalid[invalid.length] = elem.name;
+		}
+	}
+
+	return results;
+}

Added: trunk/root/static/magic/src/validate/common.js
===================================================================
--- trunk/root/static/magic/src/validate/common.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/common.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,226 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.common&quot;);
+dojo.require(&quot;dojo.validate&quot;);
+dojo.require(&quot;dojo.regexp&quot;);
+
+// *** Validation Functions ****
+
+/**
+  Checks if a string has non whitespace characters. 
+  Parameters allow you to constrain the length.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.length  If set, checks if there are exactly flags.length number of characters.
+    flags.minlength  If set, checks if there are at least flags.minlength number of characters.
+    flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.
+  @return  true or false.
+*/
+dojo.validate.isText = function(value, flags) {
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+
+	// test for text
+	if ( /^\s*$/.test(value) ) { return false; }
+
+	// length tests
+	if ( typeof flags.length == &quot;number&quot; &amp;&amp; flags.length != value.length ) { return false; }
+	if ( typeof flags.minlength == &quot;number&quot; &amp;&amp; flags.minlength &gt; value.length ) { return false; }
+	if ( typeof flags.maxlength == &quot;number&quot; &amp;&amp; flags.maxlength &lt; value.length ) { return false; }
+
+	return true;
+}
+
+/**
+  Validates whether a string is in an integer format. 
+
+  @param value  A string.
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. sign is optional).
+    flags.separator  The character used as the thousands separator.  Default is no separator.
+      For more than one symbol use an array, e.g. [&quot;,&quot;, &quot;&quot;], makes ',' optional.
+  @return  true or false.
+*/
+dojo.validate.isInteger = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.integer(flags) + &quot;$&quot;);
+	return re.test(value);
+}
+
+/**
+  Validates whether a string is a real valued number. 
+  Format is the usual exponential notation.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.places  The integer number of decimal places.
+      If not given, the decimal part is optional and the number of places is unlimited.
+    flags.decimal  The character used for the decimal point.  Default is &quot;.&quot;.
+    flags.exponent  Express in exponential notation.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. the exponential part is optional).
+    flags.eSigned  The leading plus-or-minus sign on the exponent.  Can be true, false, 
+      or [true, false].  Default is [true, false], (i.e. sign is optional).
+    flags in regexp.integer can be applied.
+  @return  true or false.
+*/
+dojo.validate.isRealNumber = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.realNumber(flags) + &quot;$&quot;);
+	return re.test(value);
+}
+
+/**
+  Validates whether a string denotes a monetary value. 
+
+  @param value  A string.
+  @param flags  An object.
+    flags.signed  The leading plus-or-minus sign.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. sign is optional).
+    flags.symbol  A currency symbol such as Yen &quot;&#65533;&quot;, Pound &quot;&#65533;&quot;, or the Euro sign &quot;&#65533;&quot;.  
+      Default is &quot;$&quot;.  For more than one symbol use an array, e.g. [&quot;$&quot;, &quot;&quot;], makes $ optional.
+    flags.placement  The symbol can come &quot;before&quot; the number or &quot;after&quot;.  Default is &quot;before&quot;.
+    flags.separator  The character used as the thousands separator. The default is &quot;,&quot;.
+    flags.cents  The two decimal places for cents.  Can be true, false, or [true, false].
+      Default is [true, false], (i.e. cents are optional).
+    flags.decimal  The character used for the decimal point.  Default is &quot;.&quot;.
+  @return  true or false.
+*/
+dojo.validate.isCurrency = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.currency(flags) + &quot;$&quot;);
+	return re.test(value);
+}
+
+/**
+  Validates whether a string denoting an integer, 
+  real number, or monetary value is between a max and min. 
+
+  @param value  A string.
+  @param flags  An object.
+    flags.max  A number, which the value must be less than or equal to for the validation to be true.
+    flags.min  A number, which the value must be greater than or equal to for the validation to be true.
+    flags.decimal  The character used for the decimal point.  Default is &quot;.&quot;.
+  @return  true or false.
+*/
+dojo.validate.isInRange = function(value, flags) {
+	// assign default values to missing paramters
+	flags = (typeof flags == &quot;object&quot;) ? flags : {};
+	var max = (typeof flags.max == &quot;number&quot;) ? flags.max : Infinity;
+	var min = (typeof flags.min == &quot;number&quot;) ? flags.min : -Infinity;
+	var dec = (typeof flags.decimal == &quot;string&quot;) ? flags.decimal : &quot;.&quot;;
+	
+	// splice out anything not part of a number
+	var pattern = &quot;[^&quot; + dec + &quot;\\deE+-]&quot;;
+	value = value.replace(RegExp(pattern, &quot;g&quot;), &quot;&quot;);
+
+	// trim ends of things like e, E, or the decimal character
+	value = value.replace(/^([+-]?)(\D*)/, &quot;$1&quot;);
+	value = value.replace(/(\D*)$/, &quot;&quot;);
+
+	// replace decimal with &quot;.&quot;. The minus sign '-' could be the decimal!
+	pattern = &quot;(\\d)[&quot; + dec + &quot;](\\d)&quot;;
+	value = value.replace(RegExp(pattern, &quot;g&quot;), &quot;$1.$2&quot;);
+
+	value = Number(value);
+	if ( value &lt; min || value &gt; max ) { return false; }
+
+	return true;
+}
+
+
+/**
+  Validates any sort of number based format.
+  Use it for phone numbers, social security numbers, zip-codes, etc.
+  The value can be validated against one format or one of multiple formats.
+
+  Format
+    #        Stands for a digit, 0-9.
+    ?        Stands for an optional digit, 0-9 or nothing.
+    All other characters must appear literally in the expression.
+
+  Example   
+    &quot;(###) ###-####&quot;       -&gt;   (510) 542-9742
+    &quot;(###) ###-#### x#???&quot; -&gt;   (510) 542-9742 x153
+    &quot;###-##-####&quot;          -&gt;   506-82-1089       i.e. social security number
+    &quot;#####-####&quot;           -&gt;   98225-1649        i.e. zip code
+
+  @param value  A string.
+  @param flags  An object.
+    flags.format  A string or an Array of strings for multiple formats.
+  @return  true or false
+*/
+dojo.validate.isNumberFormat = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.numberFormat(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+	Procedural API Description
+
+		The main aim is to make input validation expressible in a simple format.
+		You define profiles which declare the required and optional fields and any constraints they might have.
+		The results are provided as an object that makes it easy to handle missing and invalid input.
+
+	Usage
+
+		var results = dojo.validate.check(form, profile);
+
+	Profile Object
+
+		var profile = {
+			// filters change the field value and are applied before validation.
+			trim: [&quot;tx1&quot;, &quot;tx2&quot;],
+			uppercase: [&quot;tx9&quot;],
+			lowercase: [&quot;tx5&quot;, &quot;tx6&quot;, &quot;tx7&quot;],
+			ucfirst: [&quot;tx10&quot;],
+			digit: [&quot;tx11&quot;],
+
+			// required input fields that are blank will be reported missing.
+			// required radio button groups and drop-down lists with no selection will be reported missing.
+			// checkbox groups and selectboxes can be required to have more than one value selected.
+			// List required fields by name and use this notation to require more than one value: {checkboxgroup: 2}, {selectboxname: 3}.
+			required: [&quot;tx7&quot;, &quot;tx8&quot;, &quot;pw1&quot;, &quot;ta1&quot;, &quot;rb1&quot;, &quot;rb2&quot;, &quot;cb3&quot;, &quot;s1&quot;, {&quot;doubledip&quot;:2}, {&quot;tripledip&quot;:3}],
+
+			// dependant/conditional fields are required if the target field is present and not blank.
+			// At present only textbox, password, and textarea fields are supported.
+			dependancies:	{
+				cc_exp: &quot;cc_no&quot;,	
+				cc_type: &quot;cc_no&quot;,	
+			},
+
+			// Fields can be validated using any boolean valued function.  
+			// Use arrays to specify parameters in addition to the field value.
+			constraints: {
+				field_name1: myValidationFunction,
+				field_name2: dojo.validate.isInteger,
+				field_name3: [myValidationFunction, additional parameters],
+				field_name4: [dojo.validate.isValidDate, &quot;YYYY.MM.DD&quot;],
+				field_name5: [dojo.validate.isEmailAddress, false, true],
+			},
+
+			// Confirm is a sort of conditional validation.
+			// It associates each field in its property list with another field whose value should be equal.
+			// If the values are not equal, the field in the property list is reported as Invalid. Unless the target field is blank.
+			confirm: {
+				email_confirm: &quot;email&quot;,	
+				pw2: &quot;pw1&quot;,	
+			}
+		};
+
+	Results Object
+
+		isSuccessful(): Returns true if there were no invalid or missing fields, else it returns false.
+		hasMissing():  Returns true if the results contain any missing fields.
+		getMissing():  Returns a list of required fields that have values missing.
+		isMissing(field):  Returns true if the field is required and the value is missing.
+		hasInvalid():  Returns true if the results contain fields with invalid data.
+		getInvalid():  Returns a list of fields that have invalid values.
+		isInvalid(field):  Returns true if the field has an invalid value.
+
+*/

Added: trunk/root/static/magic/src/validate/datetime.js
===================================================================
--- trunk/root/static/magic/src/validate/datetime.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/datetime.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,168 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.datetime&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);
+
+/**
+  Validates a time value in any International format.
+  The value can be validated against one format or one of multiple formats.
+
+  Format
+  h        12 hour, no zero padding.
+  hh       12 hour, has leading zero.
+  H        24 hour, no zero padding.
+  HH       24 hour, has leading zero.
+  m        minutes, no zero padding.
+  mm       minutes, has leading zero.
+  s        seconds, no zero padding.
+  ss       seconds, has leading zero.
+  All other characters must appear literally in the expression.
+
+  Example
+    &quot;h:m:s t&quot;  -&gt;   2:5:33 PM
+    &quot;HH:mm:ss&quot; -&gt;  14:05:33
+
+  @param value  A string.
+  @param flags  An object.
+    flags.format  A string or an array of strings.  Default is &quot;h:mm:ss t&quot;.
+    flags.amSymbol  The symbol used for AM.  Default is &quot;AM&quot;.
+    flags.pmSymbol  The symbol used for PM.  Default is &quot;PM&quot;.
+  @return  true or false
+*/
+dojo.validate.isValidTime = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.time(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+  Validates 12-hour time format.
+  Zero-padding is not allowed for hours, required for minutes and seconds.
+  Seconds are optional.
+
+  @param value  A string.
+  @return  true or false
+*/
+dojo.validate.is12HourTime = function(value) {
+	return dojo.validate.isValidTime(value, {format: [&quot;h:mm:ss t&quot;, &quot;h:mm t&quot;]});
+}
+
+/**
+  Validates 24-hour military time format.
+  Zero-padding is required for hours, minutes, and seconds.
+  Seconds are optional.
+
+  @param value  A string.
+  @return  true or false
+*/
+dojo.validate.is24HourTime = function(value) {
+	return dojo.validate.isValidTime(value, {format: [&quot;HH:mm:ss&quot;, &quot;HH:mm&quot;]} );
+}
+
+/**
+  Returns true if the date conforms to the format given and is a valid date. Otherwise returns false.
+
+  @param dateValue  A string for the date.
+  @param format  A string, default is  &quot;MM/DD/YYYY&quot;.
+  @return  true or false
+
+  Accepts any type of format, including ISO8601.
+  All characters in the format string are treated literally except the following tokens:
+
+  YYYY - matches a 4 digit year
+  M - matches a non zero-padded month
+  MM - matches a zero-padded month
+  D -  matches a non zero-padded date
+  DD -  matches a zero-padded date
+  DDD -  matches an ordinal date, 001-365, and 366 on leapyear
+  ww - matches week of year, 01-53
+  d - matches day of week, 1-7
+
+  Examples: These are all today's date.
+
+  Date          Format
+  2005-W42-3    YYYY-Www-d
+  2005-292      YYYY-DDD
+  20051019      YYYYMMDD
+  10/19/2005    M/D/YYYY
+  19.10.2005    D.M.YYYY
+*/
+dojo.validate.isValidDate = function(dateValue, format) {
+	// Default is the American format
+	if (typeof format == &quot;object&quot; &amp;&amp; typeof format.format == &quot;string&quot;){ format = format.format; }
+	if (typeof format != &quot;string&quot;) { format = &quot;MM/DD/YYYY&quot;; }
+
+	// Create a literal regular expression based on format
+	var reLiteral = format.replace(/([$^.*+?=!:|\/\\\(\)\[\]\{\}])/g, &quot;\\$1&quot;);
+
+	// Convert all the tokens to RE elements
+	reLiteral = reLiteral.replace( &quot;YYYY&quot;, &quot;([0-9]{4})&quot; );
+	reLiteral = reLiteral.replace( &quot;MM&quot;, &quot;(0[1-9]|10|11|12)&quot; );
+	reLiteral = reLiteral.replace( &quot;M&quot;, &quot;([1-9]|10|11|12)&quot; );
+	reLiteral = reLiteral.replace( &quot;DDD&quot;, &quot;(00[1-9]|0[1-9][0-9]|[12][0-9][0-9]|3[0-5][0-9]|36[0-6])&quot; );
+	reLiteral = reLiteral.replace( &quot;DD&quot;, &quot;(0[1-9]|[12][0-9]|30|31)&quot; );
+	reLiteral = reLiteral.replace( &quot;D&quot;, &quot;([1-9]|[12][0-9]|30|31)&quot; );
+	reLiteral = reLiteral.replace( &quot;ww&quot;, &quot;(0[1-9]|[1-4][0-9]|5[0-3])&quot; );
+	reLiteral = reLiteral.replace( &quot;d&quot;, &quot;([1-7])&quot; );
+
+	// Anchor pattern to begining and end of string
+	reLiteral = &quot;^&quot; + reLiteral + &quot;$&quot;;
+
+	// Dynamic RE that parses the original format given
+	var re = new RegExp(reLiteral);
+	
+	// Test if date is in a valid format
+	if (!re.test(dateValue))  return false;
+
+	// Parse date to get elements and check if date is valid
+	// Assume valid values for date elements not given.
+	var year = 0, month = 1, date = 1, dayofyear = 1, week = 1, day = 1;
+
+	// Capture tokens
+	var tokens = format.match( /(YYYY|MM|M|DDD|DD|D|ww|d)/g );
+
+	// Capture date values
+	var values = re.exec(dateValue);
+
+	// Match up tokens with date values
+	for (var i = 0; i &lt; tokens.length; i++) {
+		switch (tokens[i]) {
+		case &quot;YYYY&quot;:
+			year = Number(values[i+1]); break;
+		case &quot;M&quot;:
+		case &quot;MM&quot;:
+			month = Number(values[i+1]); break;
+		case &quot;D&quot;:
+		case &quot;DD&quot;:
+			date = Number(values[i+1]); break;
+		case &quot;DDD&quot;:
+			dayofyear = Number(values[i+1]); break;
+		case &quot;ww&quot;:
+			week = Number(values[i+1]); break;
+		case &quot;d&quot;:
+			day = Number(values[i+1]); break;
+		}
+	}
+
+	// Leap years are divisible by 4, but not by 100, unless by 400
+	var leapyear = (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0));
+
+	// 31st of a month with 30 days
+	if (date == 31 &amp;&amp; (month == 4 || month == 6 || month == 9 || month == 11)) return false; 
+
+	// February 30th or 31st
+	if (date &gt;= 30 &amp;&amp; month == 2) return false; 
+
+	// February 29th outside a leap year
+	if (date == 29 &amp;&amp; month == 2 &amp;&amp; !leapyear) return false; 
+	if (dayofyear == 366 &amp;&amp; !leapyear)  return false;
+
+	return true;
+}

Added: trunk/root/static/magic/src/validate/de.js
===================================================================
--- trunk/root/static/magic/src/validate/de.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/de.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,30 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.de&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);
+
+/**
+  Validates German currency.
+
+  @param value  A string.
+  @return  true or false.
+*/
+dojo.validate.isGermanCurrency = function(value) {
+	var flags = {
+		symbol: &quot;&#65533;&quot;,
+		placement: &quot;after&quot;,
+		decimal: &quot;,&quot;,
+		separator: &quot;.&quot;
+	};
+	return dojo.validate.isCurrency(value, flags);
+}
+
+

Added: trunk/root/static/magic/src/validate/jp.js
===================================================================
--- trunk/root/static/magic/src/validate/jp.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/jp.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,28 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.jp&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);
+
+/**
+  Validates Japanese currency.
+
+  @param value  A string.
+  @return  true or false.
+*/
+dojo.validate.isJapaneseCurrency = function(value) {
+	var flags = {
+		symbol: &quot;&#65533;&quot;,
+		cents: false
+	};
+	return dojo.validate.isCurrency(value, flags);
+}
+
+

Added: trunk/root/static/magic/src/validate/us.js
===================================================================
--- trunk/root/static/magic/src/validate/us.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/us.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,94 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.us&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);
+
+/**
+  Validates U.S. currency.
+
+  @param value  A string.
+  @param flags  An object.
+    flags in validate.isCurrency can be applied.
+  @return  true or false.
+*/
+dojo.validate.us.isCurrency = function(value, flags) {
+	return dojo.validate.isCurrency(value, flags);
+}
+
+
+/**
+  Validates US state and territory abbreviations.
+
+	@param value  A two character string.
+  @param flags  An object.
+    flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
+    flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.
+  @return  true or false
+*/
+dojo.validate.us.isState = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.us.state(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+  Validates 10 US digit phone number for several common formats:
+
+  @param value The telephone number string
+  @return true or false
+*/
+dojo.validate.us.isPhoneNumber = function(value) {
+	var flags = {
+		format: [
+			&quot;###-###-####&quot;,
+			&quot;(###) ###-####&quot;,
+			&quot;(###) ### ####&quot;,
+			&quot;###.###.####&quot;,
+			&quot;###/###-####&quot;,
+			&quot;### ### ####&quot;,
+			&quot;###-###-#### x#???&quot;,
+			&quot;(###) ###-#### x#???&quot;,
+			&quot;(###) ### #### x#???&quot;,
+			&quot;###.###.#### x#???&quot;,
+			&quot;###/###-#### x#???&quot;,
+			&quot;### ### #### x#???&quot;,
+			&quot;##########&quot;
+		]
+	};
+
+	return dojo.validate.isNumberFormat(value, flags);
+}
+
+// Validates social security number
+dojo.validate.us.isSocialSecurityNumber = function(value) {
+	var flags = {
+		format: [
+			&quot;###-##-####&quot;,
+			&quot;### ## ####&quot;,
+			&quot;#########&quot;
+		]
+	};
+
+	return dojo.validate.isNumberFormat(value, flags);
+}
+
+// Validates U.S. zip-code
+dojo.validate.us.isZipCode = function(value) {
+	var flags = {
+		format: [
+			&quot;#####-####&quot;,
+			&quot;##### ####&quot;,
+			&quot;#########&quot;,
+			&quot;#####&quot;
+		]
+	};
+
+	return dojo.validate.isNumberFormat(value, flags);
+}

Added: trunk/root/static/magic/src/validate/web.js
===================================================================
--- trunk/root/static/magic/src/validate/web.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate/web.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,105 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate.web&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);
+
+/**
+  Validates an IP address.
+  Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
+  Supports 2 formats for Ipv6.
+
+  @param value  A string.
+  @param flags  An object.  All flags are boolean with default = true.
+    flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
+    flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
+    flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
+    flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
+    flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
+      Case insensitive.  Zero padding allowed.
+    flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
+    flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
+      followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d
+  @return  true or false
+*/
+dojo.validate.isIpAddress = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.ipAddress(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+  Checks if a string could be a valid URL.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.scheme  Can be true, false, or [true, false]. 
+      This means: required, not allowed, or either.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+  @return  true or false
+*/
+dojo.validate.isUrl = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.url(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+  Checks if a string could be a valid email address.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.allowCruft  Allow address like &lt;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">foo at yahoo.com</A>&gt;.  Default is false.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+  @return  true or false.
+*/
+dojo.validate.isEmailAddress = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.emailAddress(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+  Checks if a string could be a valid email address list.
+
+  @param value  A string.
+  @param flags  An object.
+    flags.listSeparator  The character used to separate email addresses.  Default is &quot;;&quot;, &quot;,&quot;, &quot;\n&quot; or &quot; &quot;.
+    flags in regexp.emailAddress can be applied.
+    flags in regexp.host can be applied.
+    flags in regexp.ipAddress can be applied.
+    flags in regexp.tld can be applied.
+  @return  true or false.
+*/
+dojo.validate.isEmailAddressList = function(value, flags) {
+	var re = new RegExp(&quot;^&quot; + dojo.regexp.emailAddressList(flags) + &quot;$&quot;, &quot;i&quot;);
+	return re.test(value);
+}
+
+/**
+  Check if value is an email address list. If an empty list
+  is returned, the value didn't pass the test or it was empty.
+
+  @param value	A string
+  @param flags	An object (same as isEmailAddressList)
+  @return array of emails
+*/
+dojo.validate.getEmailAddressList = function(value, flags) {
+	if(!flags) { flags = {}; }
+	if(!flags.listSeparator) { flags.listSeparator = &quot;\\s;,&quot;; }
+
+	if ( dojo.validate.isEmailAddressList(value, flags) ) {
+		return value.split(new RegExp(&quot;\\s*[&quot; + flags.listSeparator + &quot;]\\s*&quot;));
+	}
+	return [];
+}
+
+

Added: trunk/root/static/magic/src/validate.js
===================================================================
--- trunk/root/static/magic/src/validate.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/validate.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.validate&quot;);
+dojo.require(&quot;dojo.validate.common&quot;);

Added: trunk/root/static/magic/src/widget/AccordionContainer.js
===================================================================
--- trunk/root/static/magic/src/widget/AccordionContainer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/AccordionContainer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,71 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.AccordionContainer&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.AccordionPane&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.AccordionContainer&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		widgetType: &quot;AccordionContainer&quot;,
+		isContainer: true,
+		labelNodeClass: &quot;&quot;,
+		containerNodeClass: &quot;&quot;,
+		allowCollapse: false,
+
+		addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+			if (widget.widgetType != &quot;AccordionPane&quot;) {
+				var wrapper=dojo.widget.createWidget(&quot;AccordionPane&quot;,{label: widget.label, open: widget.open, labelNodeClass: this.labelNodeClass, containerNodeClass: this.containerNodeClass, allowCollapse: this.allowCollapse });
+				wrapper.addChild(widget);
+				this.addWidgetAsDirectChild(wrapper);
+				this.registerChild(wrapper);
+				wrapper.setSizes();
+				return wrapper;
+			} else {
+				dojo.html.addClass(widget.containerNode, this.containerNodeClass);
+				dojo.html.addClass(widget.labelNode, this.labelNodeClass);
+				this.addWidgetAsDirectChild(widget);
+				this.registerChild(widget);	
+				widget.setSizes();
+				return widget;
+			}
+	        },
+	
+		postCreate: function() {
+			var tmpChildren = this.children;
+			this.children=[];
+			dojo.html.removeChildren(this.domNode);
+			dojo.lang.forEach(tmpChildren, dojo.lang.hitch(this,&quot;addChild&quot;));
+		},
+	
+		removeChild: function(widget) {
+			dojo.widget.AccordionContainer.superclass.removeChild.call(this, widget);
+			if(this.children[0]){
+				this.children[0].setSizes();
+			}
+		},
+		
+		onResized: function(){
+			this.children[0].setSizes();
+		}
+	}
+);
+
+// These arguments can be specified for the children of a Accordion
+// Since any widget can be specified as a child, mix them
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	label: &quot;&quot;,
+	open: false
+});
+

Added: trunk/root/static/magic/src/widget/AccordionPane.js
===================================================================
--- trunk/root/static/magic/src/widget/AccordionPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/AccordionPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.AccordionPane&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.AccordionPane&quot;);

Added: trunk/root/static/magic/src/widget/AnimatedPng.js
===================================================================
--- trunk/root/static/magic/src/widget/AnimatedPng.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/AnimatedPng.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,83 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.AnimatedPng&quot;);
+dojo.provide(&quot;dojo.widget.html.AnimatedPng&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.AnimatedPng&quot;,
+	dojo.widget.HtmlWidget,
+	{
+
+		widgetType: &quot;AnimatedPng&quot;,
+		isContainer: false,
+
+		domNode: null,
+		width: 0,
+		height: 0,
+		aniSrc: '',
+		interval: 100,
+
+		cellWidth: 0,
+		cellHeight: 0,
+		aniCols: 1,
+		aniRows: 1,
+		aniCells: 1,
+
+		blankSrc: dojo.uri.dojoUri(&quot;src/widget/templates/images/blank.gif&quot;),
+
+		templateString: '&lt;img class=&quot;dojoAnimatedPng&quot; /&gt;',
+
+		postCreate: function(){
+			this.cellWidth = this.width;
+			this.cellHeight = this.height;
+
+			var img = new Image();
+			var self = this;
+
+			img.onload = function(){ self.initAni(img.width, img.height); };
+			img.src = this.aniSrc;
+		},
+
+		initAni: function(w, h){
+
+			this.domNode.src = this.blankSrc;
+			this.domNode.width = this.cellWidth;
+			this.domNode.height = this.cellHeight;
+			this.domNode.style.backgroundImage = 'url('+this.aniSrc+')';
+			this.domNode.style.backgroundRepeat = 'no-repeat';
+
+			this.aniCols = Math.floor(w/this.cellWidth);
+			this.aniRows = Math.floor(h/this.cellHeight);
+			this.aniCells = this.aniCols * this.aniRows;
+			this.aniFrame = 0;
+
+			window.setInterval(dojo.lang.hitch(this, 'tick'), this.interval);
+		},
+
+		tick: function(){
+
+			this.aniFrame++;
+			if (this.aniFrame == this.aniCells) this.aniFrame = 0;
+
+			var col = this.aniFrame % this.aniCols;
+			var row = Math.floor(this.aniFrame / this.aniCols);
+
+			var bx = -1 * col * this.cellWidth;
+			var by = -1 * row * this.cellHeight;
+
+			this.domNode.style.backgroundPosition = bx+'px '+by+'px';
+		}
+	}
+);

Added: trunk/root/static/magic/src/widget/Button.js
===================================================================
--- trunk/root/static/magic/src/widget/Button.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Button.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,315 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Button&quot;);
+dojo.provide(&quot;dojo.widget.html.Button&quot;);
+
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Button&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		widgetType: &quot;Button&quot;,
+		isContainer: true,
+	
+		// Constructor arguments
+		caption: &quot;&quot;,
+		disabled: false,
+	
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlButtonTemplate.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlButtonTemplate.css&quot;),
+		
+		// button images
+		inactiveImg: &quot;src/widget/templates/images/soriaButton-&quot;,
+		activeImg: &quot;src/widget/templates/images/soriaActive-&quot;,
+		pressedImg: &quot;src/widget/templates/images/soriaPressed-&quot;,
+		disabledImg: &quot;src/widget/templates/images/soriaDisabled-&quot;,
+		width2height: 1.0/3.0,
+	
+		// attach points
+		containerNode: null,
+		leftImage: null,
+		centerImage: null,
+		rightImage: null,
+	
+		fillInTemplate: function(args, frag){
+			if(this.caption != &quot;&quot;){
+				this.containerNode.appendChild(document.createTextNode(this.caption));
+			}
+			dojo.html.disableSelection(this.containerNode);
+		},
+
+		postCreate: function(args, frag){
+			this.sizeMyself();
+		},
+	
+		sizeMyself: function(){
+			// we cannot size correctly if any of our ancestors are hidden (display:none),
+			// so temporarily attach to document.body
+			if(this.domNode.parentNode){
+				var placeHolder = document.createElement(&quot;span&quot;);
+				dojo.dom.insertBefore(placeHolder, this.domNode);
+			}
+			dojo.html.body().appendChild(this.domNode);
+			
+			this.sizeMyselfHelper();
+			
+			// Put this.domNode back where it was originally
+			if(placeHolder){
+				dojo.dom.insertBefore(this.domNode, placeHolder);
+				dojo.dom.removeNode(placeHolder);
+			}
+		},
+
+		sizeMyselfHelper: function(){
+			this.height = dojo.style.getOuterHeight(this.containerNode);
+			this.containerWidth = dojo.style.getOuterWidth(this.containerNode);
+			var endWidth= this.height * this.width2height;
+	
+			this.containerNode.style.left=endWidth+&quot;px&quot;;
+	
+			this.leftImage.height = this.rightImage.height = this.centerImage.height = this.height;
+			this.leftImage.width = this.rightImage.width = endWidth+1;
+			this.centerImage.width = this.containerWidth;
+			this.centerImage.style.left=endWidth+&quot;px&quot;;
+			this._setImage(this.disabled ? this.disabledImg : this.inactiveImg);
+
+			if ( this.disabled ) {
+				dojo.html.prependClass(this.domNode, &quot;dojoButtonDisabled&quot;);
+			} else {
+				dojo.html.removeClass(this.domNode, &quot;dojoButtonDisabled&quot;);
+			}
+				
+			this.domNode.style.height=this.height + &quot;px&quot;;
+			this.domNode.style.width= (this.containerWidth+2*endWidth) + &quot;px&quot;;
+		},
+	
+		onMouseOver: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.domNode, &quot;dojoButtonHover&quot;);
+			this._setImage(this.activeImg);
+		},
+	
+		onMouseDown: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.domNode, &quot;dojoButtonDepressed&quot;);
+			dojo.html.removeClass(this.domNode, &quot;dojoButtonHover&quot;);
+			this._setImage(this.pressedImg);
+		},
+		onMouseUp: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.domNode, &quot;dojoButtonHover&quot;);
+			dojo.html.removeClass(this.domNode, &quot;dojoButtonDepressed&quot;);
+			this._setImage(this.activeImg);
+		},
+	
+		onMouseOut: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.removeClass(this.domNode, &quot;dojoButtonHover&quot;);
+			this._setImage(this.inactiveImg);
+		},
+	
+		buttonClick: function(e){
+			if( !this.disabled ) { this.onClick(e); }
+		},
+
+		onClick: function(e) { },
+
+		_setImage: function(prefix){
+			this.leftImage.src=dojo.uri.dojoUri(prefix + &quot;l.gif&quot;);
+			this.centerImage.src=dojo.uri.dojoUri(prefix + &quot;c.gif&quot;);
+			this.rightImage.src=dojo.uri.dojoUri(prefix + &quot;r.gif&quot;);
+		},
+		
+		_toggleMenu: function(menuId){
+			var menu = dojo.widget.getWidgetById(menuId);
+			if ( !menu ) { return; }
+	
+			if ( menu.open &amp;&amp; !menu.isShowingNow) {
+				var pos = dojo.style.getAbsolutePosition(this.domNode, false);
+				menu.open(pos.x, pos.y+this.height, this);
+			} else if ( menu.close &amp;&amp; menu.isShowingNow ){
+				menu.close();
+			} else {
+				menu.toggle();
+			}
+		},
+		
+		setCaption: function(content){
+			this.caption=content;
+			this.containerNode.innerHTML=content;
+			this.sizeMyself();
+		},
+		
+		setDisabled: function(disabled){
+			this.disabled=disabled;
+			this.sizeMyself();
+		}
+	});
+
+/**** DropDownButton - push the button and a menu shows up *****/
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.DropDownButton&quot;,
+	dojo.widget.html.Button,
+	{
+		widgetType: &quot;DropDownButton&quot;,
+	
+		menuId: &quot;&quot;,
+
+		arrow: null,
+	
+		downArrow: &quot;src/widget/templates/images/whiteDownArrow.gif&quot;,
+		disabledDownArrow: &quot;src/widget/templates/images/whiteDownArrow.gif&quot;,
+	
+		fillInTemplate: function(args, frag){
+			dojo.widget.html.DropDownButton.superclass.fillInTemplate.call(this, args, frag);
+	
+			this.arrow = document.createElement(&quot;img&quot;);
+			dojo.html.setClass(this.arrow, &quot;downArrow&quot;);
+		},
+
+		sizeMyselfHelper: function(){
+			// draw the arrow (todo: why is the arror in containerNode rather than outside it?)
+			this.arrow.src = dojo.uri.dojoUri(this.disabled ? this.disabledDownArrow : this.downArrow);
+			this.containerNode.appendChild(this.arrow);
+
+			dojo.widget.html.DropDownButton.superclass.sizeMyselfHelper.call(this);
+		},
+
+		onClick: function (e){
+			this._toggleMenu(this.menuId);
+		}
+	});
+
+/**** ComboButton - left side is normal button, right side shows menu *****/
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.ComboButton&quot;,
+	dojo.widget.html.Button,
+	{
+		widgetType: &quot;ComboButton&quot;,
+	
+		menuId: &quot;&quot;,
+	
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlComboButtonTemplate.html&quot;),
+	
+		// attach points
+		leftPart: null,
+		rightPart: null,
+		arrowBackgroundImage: null,
+	
+		// constants
+		splitWidth: 2,		// pixels between left&amp;right part of button
+		arrowWidth: 5,		// width of segment holding down arrow
+	
+		sizeMyselfHelper: function(e){
+			this.height = dojo.style.getOuterHeight(this.containerNode);
+			this.containerWidth = dojo.style.getOuterWidth(this.containerNode);
+			var endWidth= this.height/3;
+	
+			// left part
+			this.leftImage.height = this.rightImage.height = this.centerImage.height = 
+				this.arrowBackgroundImage.height = this.height;
+			this.leftImage.width = endWidth+1;
+			this.centerImage.width = this.containerWidth;
+			this.leftPart.style.height = this.height + &quot;px&quot;;
+			this.leftPart.style.width = endWidth + this.containerWidth + &quot;px&quot;;
+			this._setImageL(this.disabled ? this.disabledImg : this.inactiveImg);
+	
+			// right part
+			this.arrowBackgroundImage.width=this.arrowWidth;
+			this.rightImage.width = endWidth+1;
+			this.rightPart.style.height = this.height + &quot;px&quot;;
+			this.rightPart.style.width = this.arrowWidth + endWidth + &quot;px&quot;;
+			this._setImageR(this.disabled ? this.disabledImg : this.inactiveImg);
+	
+			// outer container
+			this.domNode.style.height=this.height + &quot;px&quot;;
+			var totalWidth = this.containerWidth+this.splitWidth+this.arrowWidth+2*endWidth;
+			this.domNode.style.width= totalWidth + &quot;px&quot;;
+		},
+	
+		/** functions on left part of button**/
+		leftOver: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.leftPart, &quot;dojoButtonHover&quot;);
+			this._setImageL(this.activeImg);
+		},
+	
+		leftDown: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.leftPart, &quot;dojoButtonDepressed&quot;);
+			dojo.html.removeClass(this.leftPart, &quot;dojoButtonHover&quot;);
+			this._setImageL(this.pressedImg);
+		},
+		leftUp: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.leftPart, &quot;dojoButtonHover&quot;);
+			dojo.html.removeClass(this.leftPart, &quot;dojoButtonDepressed&quot;);
+			this._setImageL(this.activeImg);
+		},
+	
+		leftOut: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.removeClass(this.leftPart, &quot;dojoButtonHover&quot;);
+			this._setImageL(this.inactiveImg);
+		},
+	
+		leftClick: function(e){
+			if ( !this.disabled ) {
+				this.onClick(e);
+			}
+		},
+	
+		_setImageL: function(prefix){
+			this.leftImage.src=dojo.uri.dojoUri(prefix + &quot;l.gif&quot;);
+			this.centerImage.src=dojo.uri.dojoUri(prefix + &quot;c.gif&quot;);
+		},
+	
+		/*** functions on right part of button ***/
+		rightOver: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.rightPart, &quot;dojoButtonHover&quot;);
+			this._setImageR(this.activeImg);
+		},
+	
+		rightDown: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.rightPart, &quot;dojoButtonDepressed&quot;);
+			dojo.html.removeClass(this.rightPart, &quot;dojoButtonHover&quot;);
+			this._setImageR(this.pressedImg);
+		},
+		rightUp: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.prependClass(this.rightPart, &quot;dojoButtonHover&quot;);
+			dojo.html.removeClass(this.rightPart, &quot;dojoButtonDepressed&quot;);
+			this._setImageR(this.activeImg);
+		},
+	
+		rightOut: function(e){
+			if( this.disabled ){ return; }
+			dojo.html.removeClass(this.rightPart, &quot;dojoButtonHover&quot;);
+			this._setImageR(this.inactiveImg);
+		},
+	
+		rightClick: function(e){
+			if( this.disabled ){ return; }
+			this._toggleMenu(this.menuId);
+		},
+	
+		_setImageR: function(prefix){
+			this.arrowBackgroundImage.src=dojo.uri.dojoUri(prefix + &quot;c.gif&quot;);
+			this.rightImage.src=dojo.uri.dojoUri(prefix + &quot;r.gif&quot;);
+		}
+	});
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/Button2.js
===================================================================
--- trunk/root/static/magic/src/widget/Button2.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Button2.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,33 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Button2&quot;);
+dojo.require(&quot;dojo.widget.Button&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:button2&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:dropdownbutton2&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:combobutton2&quot;);
+
+dojo.deprecated(&quot;dojo.widget.Button2&quot;, &quot;Use dojo.widget.Button instead&quot;, &quot;0.4&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.Button2&quot;);
+
+dojo.widget.Button2 = function(){}
+dojo.inherits(dojo.widget.Button2, dojo.widget.Button);
+dojo.lang.extend(dojo.widget.Button2, { widgetType: &quot;Button2&quot; });
+
+dojo.widget.DropDownButton2 = function(){}
+dojo.inherits(dojo.widget.DropDownButton2, dojo.widget.DropDownButton);
+dojo.lang.extend(dojo.widget.DropDownButton2, { widgetType: &quot;DropDownButton2&quot; });
+
+dojo.widget.ComboButton2 = function(){}
+dojo.inherits(dojo.widget.ComboButton2, dojo.widget.ComboButton);
+dojo.lang.extend(dojo.widget.ComboButton2, { widgetType: &quot;ComboButton2&quot; });

Added: trunk/root/static/magic/src/widget/Chart.js
===================================================================
--- trunk/root/static/magic/src/widget/Chart.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Chart.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,199 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Chart&quot;);
+dojo.provide(&quot;dojo.widget.Chart.PlotTypes&quot;);
+dojo.provide(&quot;dojo.widget.Chart.DataSeries&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.graphics.color.hsl&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:chart&quot;);
+
+dojo.widget.Chart = function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = &quot;Chart&quot;;
+	this.isContainer = false;
+	this.series = [];
+	// FIXME: why is this a mixin method?
+	this.assignColors = function(){
+		var hue=30;
+		var sat=120;
+		var lum=120;
+		var steps = Math.round(330/this.series.length);
+
+		for(var i=0; i&lt;this.series.length; i++){
+			var c=dojo.graphics.color.hsl2rgb(hue,sat,lum);
+			if(!this.series[i].color){
+				this.series[i].color = dojo.graphics.color.rgb2hex(c[0],c[1],c[2]);
+			}
+			hue += steps;
+		}
+	};
+}
+dojo.inherits(dojo.widget.Chart, dojo.widget.Widget);
+
+dojo.widget.Chart.PlotTypes = {
+	Bar:&quot;bar&quot;,
+	Line:&quot;line&quot;,
+	Scatter:&quot;scatter&quot;,
+	Bubble:&quot;bubble&quot;
+};
+
+/*
+ *	Every chart has a set of data series; this is the series.  Note that each
+ *	member of value is an object and in the minimum has 2 properties: .x and
+ *	.value.
+ */
+dojo.widget.Chart.DataSeries = function(key, label, plotType, color){
+	// FIXME: why the hell are plot types specified neumerically? What is this? C?
+	this.id = &quot;DataSeries&quot;+dojo.widget.Chart.DataSeries.count++;
+	this.key = key;
+	this.label = label||this.id;
+	this.plotType = plotType||0;
+	this.color = color;
+	this.values = [];
+};
+
+dojo.lang.extend(dojo.widget.Chart.DataSeries, {
+	add: function(v){
+		if(v.x==null||v.value==null){
+			dojo.raise(&quot;dojo.widget.Chart.DataSeries.add: v must have both an 'x' and 'value' property.&quot;);
+		}
+		this.values.push(v);
+	},
+
+	clear: function(){
+		this.values=[];
+	},
+
+	createRange: function(len){
+		var idx = this.values.length-1;
+		var length = (len||this.values.length);
+		return { &quot;index&quot;: idx, &quot;length&quot;: length, &quot;start&quot;:Math.max(idx-length,0) };
+	},
+
+	//	trend values
+	getMean: function(len){
+		var range = this.createRange(len);
+		if(range.index&lt;0){ return 0; }
+		var t = 0;
+		var c = 0;
+		for(var i=range.index; i&gt;=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){ t += n; c++; }
+		}
+		t /= Math.max(c,1);
+		return t;
+	},
+
+	getMovingAverage: function(len){
+		var range = this.createRange(len);
+		if(range.index&lt;0){ return 0; }
+		var t = 0;
+		var c = 0;
+		for(var i=range.index; i&gt;=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){ t += n; c++; }
+		}
+		t /= Math.max(c,1);
+		return t;
+	},
+
+	getVariance: function(len){
+		var range = this.createRange(len);
+		if(range.index &lt; 0){ return 0; }
+		var t = 0; // FIXME: for tom: wtf are t, c, and s?
+		var s = 0;
+		var c = 0;
+		for(var i=range.index; i&gt;=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){
+				t += n;
+				s += Math.pow(n,2);
+				c++;
+			}
+		}
+		return (s/c)-Math.pow(t/c,2);
+	},
+
+	getStandardDeviation: function(len){
+		return Math.sqrt(this.getVariance(len));
+	},
+
+	getMax: function(len){
+		var range = this.createRange(len);
+		if(range.index &lt; 0){ return 0; }
+		var t = 0;
+		for (var i=range.index; i&gt;=range.start; i--){
+			var n=parseFloat(this.values[i].value);
+			if (!isNaN(n)){
+				t=Math.max(n,t);
+			}
+		}
+		return t;
+	},
+
+	getMin: function(len){
+		var range=this.createRange(len);
+		if(range.index &lt; 0){ return 0; }
+		var t = 0;
+		for(var i=range.index; i&gt;=range.start; i--){
+			var n = parseFloat(this.values[i].value);
+			if(!isNaN(n)){
+				t=Math.min(n,t);
+			}
+		}
+		return t;
+	},
+
+	getMedian: function(len){
+		var range = this.createRange(len);
+
+		if(range.index&lt;0){ return 0; }
+
+		var a = [];
+		for (var i=range.index; i&gt;=range.start; i--){
+			var n=parseFloat(this.values[i].value);
+			if (!isNaN(n)){
+				var b=false;
+				for(var j=0; j&lt;a.length&amp;&amp;!b; j++){
+					if (n==a[j]) b=true; 
+				}
+				if(!b){ a.push(n); }
+			}
+		}
+		a.sort();
+		if(a.length&gt;0){ return a[Math.ceil(a.length/2)]; }
+		return 0;
+	},
+
+	getMode: function(len){
+		var range=this.createRange(len);
+		if(range.index&lt;0){ return 0; }
+		var o = {};
+		var ret = 0
+		var m = 0;
+		for(var i=range.index; i&gt;=range.start; i--){
+			var n=parseFloat(this.values[i].value);
+			if(!isNaN(n)){
+				if (!o[this.values[i].value]) o[this.values[i].value] = 1;
+				else o[this.values[i].value]++;
+			}
+		}
+		for(var p in o){
+			if(m&lt;o[p]){ m=o[p]; ret=p; }
+		}
+		return parseFloat(ret);
+	}
+});
+
+dojo.requireIf(dojo.render.svg.support.builtin, &quot;dojo.widget.svg.Chart&quot;);
+dojo.requireIf(dojo.render.html.ie, &quot;dojo.widget.vml.Chart&quot;);

Added: trunk/root/static/magic/src/widget/Checkbox.js
===================================================================
--- trunk/root/static/magic/src/widget/Checkbox.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Checkbox.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,13 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Checkbox&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.Checkbox&quot;);

Added: trunk/root/static/magic/src/widget/CiviCrmDatePicker.js
===================================================================
--- trunk/root/static/magic/src/widget/CiviCrmDatePicker.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/CiviCrmDatePicker.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,118 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.CiviCrmDatePicker&quot;);
+dojo.provide(&quot;dojo.widget.HtmlCiviCrmDatePicker&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.DatePicker&quot;);
+dojo.require(&quot;dojo.widget.html.DatePicker&quot;);
+dojo.require(&quot;dojo.widget.html.TimePicker&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.HtmlCiviCrmDatePicker = function(){
+	this.widgetType = &quot;CiviCrmDatePicker&quot;;
+	this.idPrefix = &quot;scheduled_date_time&quot;;
+	this.mode = &quot;datetime&quot;; // can also be date or time
+
+	this.datePicker = null;
+	this.timePicker = null;
+
+	// html nodes
+	this.dateHolderTd = null;
+	this.timeHolderTd = null;
+	this.formItemsTd = null;
+	this.formItemsTr = null;
+
+	this.monthSelect = null;
+	this.daySelect = null;
+	this.yearSelect = null;
+	this.hourSelect = null;
+	this.minSelect = null;
+	this.apSelect = null;
+
+	this.templatePath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlCiviCrmDatePicker.html&quot;);
+
+	this.modeFormats = {
+		date: &quot;MdY&quot;,
+		time: &quot;hiA&quot;
+	};
+
+	this.formatMappings = {
+		&quot;M&quot;: &quot;monthSelect&quot;,
+		&quot;d&quot;: &quot;daySelect&quot;,
+		&quot;Y&quot;: &quot;yearSelect&quot;,
+		&quot;h&quot;: &quot;hourSelect&quot;,
+		&quot;i&quot;: &quot;minSelect&quot;,
+		&quot;A&quot;: &quot;apSelect&quot;
+	};
+
+	this.setDateSelects = function(){
+		var dateObj = this.datePicker.date;
+		this.monthSelect.value = new String(dateObj.getMonth()+1);
+		this.daySelect.value = new String(dateObj.getDate());
+		this.yearSelect.value = new String(dateObj.getFullYear());
+	}
+
+	this.setTimeSelects = function(){
+		var st = this.timePicker.selectedTime;
+		this.hourSelect.value = new String(st.hour);
+		this.minSelect.value = new String(st.minute);
+		this.apSelect.value = st.amPm.toUpperCase();
+	}
+
+	this.fillInTemplate = function(args, frag){
+		var nr = frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()][&quot;nodeRef&quot;];
+		var sref = {};
+		while(nr.firstChild){
+			if(nr.firstChild.name){
+				sref[nr.firstChild.name] = nr.firstChild;
+			}
+			this.formItemsTd.appendChild(nr.firstChild);
+		}
+
+		if(this.mode.indexOf(&quot;date&quot;) != -1){
+			this.datePicker = dojo.widget.createWidget(&quot;DatePicker&quot;, {}, this.dateHolderTd);
+			dojo.event.connect(	this.datePicker, &quot;onSetDate&quot;, 
+								this, &quot;setDateSelects&quot;);
+
+			var mfd = this.modeFormats.date;
+			for(var x=0; x&lt;mfd.length; x++){
+				this[this.formatMappings[mfd[x]]] = sref[this.idPrefix+&quot;[&quot;+mfd[x]+&quot;]&quot;];
+			}
+		}
+		if(this.mode.indexOf(&quot;time&quot;) != -1){
+			this.timePicker = dojo.widget.createWidget(&quot;TimePicker&quot;, {}, this.timeHolderTd);
+			dojo.event.connect(	this.timePicker, &quot;onSetTime&quot;, 
+								this, &quot;setTimeSelects&quot;);
+			var mfd = this.modeFormats.time;
+			for(var x=0; x&lt;mfd.length; x++){
+				this[this.formatMappings[mfd[x]]] = sref[this.idPrefix+&quot;[&quot;+mfd[x]+&quot;]&quot;];
+			}
+		}
+	}
+
+	this.unhide = function(){
+		this.formItemsTr.style.display = &quot;&quot;;
+	}
+
+	this.postCreate = function(){
+		dojo.event.kwConnect({
+			type: &quot;before&quot;, 
+			srcObj: dojo.html.getParentByType(this.domNode, &quot;form&quot;),
+			srcFunc: &quot;onsubmit&quot;, 
+			targetObj: this,
+			targetFunc: &quot;unhide&quot;
+		});
+	}
+}
+dojo.inherits(dojo.widget.HtmlCiviCrmDatePicker, dojo.widget.HtmlWidget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:civicrmdatepicker&quot;);
+

Added: trunk/root/static/magic/src/widget/ColorPalette.js
===================================================================
--- trunk/root/static/magic/src/widget/ColorPalette.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ColorPalette.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,186 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ColorPalette&quot;);
+dojo.provide(&quot;dojo.widget.html.ColorPalette&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.Toolbar&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:ToolbarColorDialog&quot;);
+
+dojo.widget.html.ToolbarColorDialog = function(){
+	dojo.widget.html.ToolbarDialog.call(this);
+	
+	/*
+	FIXME: 	why the fuck did anyone ever think this kind of expensive iteration
+			was a good idea?
+
+	for (var method in this.constructor.prototype) {
+		this[method] = this.constructor.prototype[method];
+	}
+	*/
+}
+
+dojo.inherits(dojo.widget.html.ToolbarColorDialog, dojo.widget.html.ToolbarDialog);
+
+dojo.lang.extend(dojo.widget.html.ToolbarColorDialog, {
+
+	widgetType: &quot;ToolbarColorDialog&quot;,
+
+	palette: &quot;7x10&quot;,
+
+	fillInTemplate: function (args, frag) {
+		dojo.widget.html.ToolbarColorDialog.superclass.fillInTemplate.call(this, args, frag);
+		this.dialog = dojo.widget.createWidget(&quot;ColorPalette&quot;, {palette: this.palette});
+		this.dialog.domNode.style.position = &quot;absolute&quot;;
+
+		dojo.event.connect(this.dialog, &quot;onColorSelect&quot;, this, &quot;_setValue&quot;);
+	},
+
+	_setValue: function(color) {
+		this._value = color;
+		this._fireEvent(&quot;onSetValue&quot;, color);
+	},
+	
+	showDialog: function (e) {
+		dojo.widget.html.ToolbarColorDialog.superclass.showDialog.call(this, e);
+		var x = dojo.html.getAbsoluteX(this.domNode);
+		var y = dojo.html.getAbsoluteY(this.domNode) + dojo.html.getInnerHeight(this.domNode);
+		this.dialog.showAt(x, y);
+	},
+	
+	hideDialog: function (e) {
+		dojo.widget.html.ToolbarColorDialog.superclass.hideDialog.call(this, e);
+		this.dialog.hide();
+	}
+});
+
+
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:colorpalette&quot;);
+
+dojo.widget.html.ColorPalette = function () {
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.ColorPalette, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.ColorPalette, {
+
+	widgetType: &quot;colorpalette&quot;,
+	
+	palette: &quot;7x10&quot;,
+
+	bgIframe: null,
+	
+	palettes: {
+		&quot;7x10&quot;: [[&quot;fff&quot;, &quot;fcc&quot;, &quot;fc9&quot;, &quot;ff9&quot;, &quot;ffc&quot;, &quot;9f9&quot;, &quot;9ff&quot;, &quot;cff&quot;, &quot;ccf&quot;, &quot;fcf&quot;],
+			[&quot;ccc&quot;, &quot;f66&quot;, &quot;f96&quot;, &quot;ff6&quot;, &quot;ff3&quot;, &quot;6f9&quot;, &quot;3ff&quot;, &quot;6ff&quot;, &quot;99f&quot;, &quot;f9f&quot;],
+			[&quot;c0c0c0&quot;, &quot;f00&quot;, &quot;f90&quot;, &quot;fc6&quot;, &quot;ff0&quot;, &quot;3f3&quot;, &quot;6cc&quot;, &quot;3cf&quot;, &quot;66c&quot;, &quot;c6c&quot;],
+			[&quot;999&quot;, &quot;c00&quot;, &quot;f60&quot;, &quot;fc3&quot;, &quot;fc0&quot;, &quot;3c0&quot;, &quot;0cc&quot;, &quot;36f&quot;, &quot;63f&quot;, &quot;c3c&quot;],
+			[&quot;666&quot;, &quot;900&quot;, &quot;c60&quot;, &quot;c93&quot;, &quot;990&quot;, &quot;090&quot;, &quot;399&quot;, &quot;33f&quot;, &quot;60c&quot;, &quot;939&quot;],
+			[&quot;333&quot;, &quot;600&quot;, &quot;930&quot;, &quot;963&quot;, &quot;660&quot;, &quot;060&quot;, &quot;366&quot;, &quot;009&quot;, &quot;339&quot;, &quot;636&quot;],
+			[&quot;000&quot;, &quot;300&quot;, &quot;630&quot;, &quot;633&quot;, &quot;330&quot;, &quot;030&quot;, &quot;033&quot;, &quot;006&quot;, &quot;309&quot;, &quot;303&quot;]],
+	
+		&quot;3x4&quot;: [[&quot;ffffff&quot;/*white*/, &quot;00ff00&quot;/*lime*/, &quot;008000&quot;/*green*/, &quot;0000ff&quot;/*blue*/],
+			[&quot;c0c0c0&quot;/*silver*/, &quot;ffff00&quot;/*yellow*/, &quot;ff00ff&quot;/*fuchsia*/, &quot;000080&quot;/*navy*/],
+			[&quot;808080&quot;/*gray*/, &quot;ff0000&quot;/*red*/, &quot;800080&quot;/*purple*/, &quot;000000&quot;/*black*/]]
+			//[&quot;00ffff&quot;/*aqua*/, &quot;808000&quot;/*olive*/, &quot;800000&quot;/*maroon*/, &quot;008080&quot;/*teal*/]];
+	},
+
+	buildRendering: function () {
+		
+		this.domNode = document.createElement(&quot;table&quot;);
+		dojo.html.disableSelection(this.domNode);
+		dojo.event.connect(this.domNode, &quot;onmousedown&quot;, function (e) {
+			e.preventDefault();
+		});
+		with (this.domNode) { // set the table's properties
+			cellPadding = &quot;0&quot;; cellSpacing = &quot;1&quot;; border = &quot;1&quot;;
+			style.backgroundColor = &quot;white&quot;; //style.position = &quot;absolute&quot;;
+		}
+		var tbody = document.createElement(&quot;tbody&quot;);
+		this.domNode.appendChild(tbody);
+		var colors = this.palettes[this.palette];
+		for (var i = 0; i &lt; colors.length; i++) {
+			var tr = document.createElement(&quot;tr&quot;);
+			for (var j = 0; j &lt; colors[i].length; j++) {
+				if (colors[i][j].length == 3) {
+					colors[i][j] = colors[i][j].replace(/(.)(.)(.)/, &quot;$1$1$2$2$3$3&quot;);
+				}
+	
+				var td = document.createElement(&quot;td&quot;);
+				with (td.style) {
+					backgroundColor = &quot;#&quot; + colors[i][j];
+					border = &quot;1px solid gray&quot;;
+					width = height = &quot;15px&quot;;
+					fontSize = &quot;1px&quot;;
+				}
+	
+				td.color = &quot;#&quot; + colors[i][j];
+	
+				td.onmouseover = function (e) { this.style.borderColor = &quot;white&quot;; }
+				td.onmouseout = function (e) { this.style.borderColor = &quot;gray&quot;; }
+				dojo.event.connect(td, &quot;onmousedown&quot;, this, &quot;click&quot;);
+	
+				td.innerHTML = &quot;&nbsp;&quot;;
+				tr.appendChild(td);
+			}
+			tbody.appendChild(tr);
+		}
+
+		if(dojo.render.html.ie){
+			this.bgIframe = document.createElement(&quot;&lt;iframe frameborder='0' src='javascript:void(0);'&gt;&quot;);
+			with(this.bgIframe.style){
+				position = &quot;absolute&quot;;
+				left = top = &quot;0px&quot;;
+				display = &quot;none&quot;;
+			}
+			document.body.appendChild(this.bgIframe);
+			dojo.style.setOpacity(this.bgIframe, 0);
+		}
+	},
+
+	click: function (e) {
+		this.onColorSelect(e.currentTarget.color);
+		e.currentTarget.style.borderColor = &quot;gray&quot;;
+	},
+
+	onColorSelect: function (color) { },
+
+	hide: function (){
+		this.domNode.parentNode.removeChild(this.domNode);
+		if(this.bgIframe){
+			this.bgIframe.style.display = &quot;none&quot;;
+		}
+	},
+	
+	showAt: function (x, y) {
+		with(this.domNode.style){
+			top = y + &quot;px&quot;;
+			left = x + &quot;px&quot;;
+			zIndex = 999;
+		}
+		document.body.appendChild(this.domNode);
+		if(this.bgIframe){
+			with(this.bgIframe.style){
+				display = &quot;block&quot;;
+				top = y + &quot;px&quot;;
+				left = x + &quot;px&quot;;
+				zIndex = 998;
+				width = dojo.html.getOuterWidth(this.domNode) + &quot;px&quot;;
+				height = dojo.html.getOuterHeight(this.domNode) + &quot;px&quot;;
+			}
+
+		}
+	}
+
+});

Added: trunk/root/static/magic/src/widget/ComboBox.js
===================================================================
--- trunk/root/static/magic/src/widget/ComboBox.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ComboBox.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,236 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ComboBox&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+dojo.widget.incrementalComboBoxDataProvider = function(url, limit, timeout){
+	this.searchUrl = url;
+	this.inFlight = false;
+	this.activeRequest = null;
+	this.allowCache = false;
+
+	this.cache = {};
+
+	this.init = function(cbox){
+		this.searchUrl = cbox.dataUrl;
+	}
+
+	this.addToCache = function(keyword, data){
+		if(this.allowCache){
+			this.cache[keyword] = data;
+		}
+	}
+
+	this.startSearch = function(searchStr, type, ignoreLimit){
+		if(this.inFlight){
+			// FIXME: implement backoff!
+		}
+		var tss = encodeURIComponent(searchStr);
+		var realUrl = dojo.string.paramString(this.searchUrl, {&quot;searchString&quot;: tss});
+		var _this = this;
+		var request = dojo.io.bind({
+			url: realUrl,
+			method: &quot;get&quot;,
+			mimetype: &quot;text/json&quot;,
+			load: function(type, data, evt){
+				_this.inFlight = false;
+				if(!dojo.lang.isArray(data)){
+					var arrData = [];
+					for(var key in data){
+						arrData.push([data[key], key]);
+					}
+					data = arrData;
+				}
+				_this.addToCache(searchStr, data);
+				_this.provideSearchResults(data);
+			}
+		});
+		this.inFlight = true;
+	}
+}
+
+dojo.widget.ComboBoxDataProvider = function(dataPairs, limit, timeout){
+	// NOTE: this data provider is designed as a naive reference
+	// implementation, and as such it is written more for readability than
+	// speed. A deployable data provider would implement lookups, search
+	// caching (and invalidation), and a significantly less naive data
+	// structure for storage of items.
+
+	this.data = [];
+	this.searchTimeout = 500;
+	this.searchLimit = 30;
+	this.searchType = &quot;STARTSTRING&quot;; // may also be &quot;STARTWORD&quot; or &quot;SUBSTRING&quot;
+	this.caseSensitive = false;
+	// for caching optimizations
+	this._lastSearch = &quot;&quot;;
+	this._lastSearchResults = null;
+
+	this.init = function(cbox, node){
+		if(!dojo.string.isBlank(cbox.dataUrl)){
+			this.getData(cbox.dataUrl);
+		}else{
+			// check to see if we can populate the list from &lt;option&gt; elements
+			if((node)&amp;&amp;(node.nodeName.toLowerCase() == &quot;select&quot;)){
+				// NOTE: we're not handling &lt;optgroup&gt; here yet
+				var opts = node.getElementsByTagName(&quot;option&quot;);
+				var ol = opts.length;
+				var data = [];
+				for(var x=0; x&lt;ol; x++){
+					var keyValArr = [new String(opts[x].innerHTML), new String(opts[x].value)];
+					data.push(keyValArr);
+					if(opts[x].selected){ 
+						cbox.setAllValues(keyValArr[0], keyValArr[1]);
+					}
+				}
+				this.setData(data);
+			}
+		}
+	}
+
+	this.getData = function(url){
+		dojo.io.bind({
+			url: url,
+			load: dojo.lang.hitch(this, function(type, data, evt){ 
+				if(!dojo.lang.isArray(data)){
+					var arrData = [];
+					for(var key in data){
+						arrData.push([data[key], key]);
+					}
+					data = arrData;
+				}
+				this.setData(data);
+			}),
+			mimetype: &quot;text/json&quot;
+		});
+	}
+
+	this.startSearch = function(searchStr, type, ignoreLimit){
+		// FIXME: need to add timeout handling here!!
+		this._preformSearch(searchStr, type, ignoreLimit);
+	}
+
+	this._preformSearch = function(searchStr, type, ignoreLimit){
+		//
+		//	NOTE: this search is LINEAR, which means that it exhibits perhaps
+		//	the worst possible speed characteristics of any search type. It's
+		//	written this way to outline the responsibilities and interfaces for
+		//	a search.
+		//
+		var st = type||this.searchType;
+		// FIXME: this is just an example search, which means that we implement
+		// only a linear search without any of the attendant (useful!) optimizations
+		var ret = [];
+		if(!this.caseSensitive){
+			searchStr = searchStr.toLowerCase();
+		}
+		for(var x=0; x&lt;this.data.length; x++){
+			if((!ignoreLimit)&amp;&amp;(ret.length &gt;= this.searchLimit)){
+				break;
+			}
+			// FIXME: we should avoid copies if possible!
+			var dataLabel = new String((!this.caseSensitive) ? this.data[x][0].toLowerCase() : this.data[x][0]);
+			if(dataLabel.length &lt; searchStr.length){
+				// this won't ever be a good search, will it? What if we start
+				// to support regex search?
+				continue;
+			}
+
+			if(st == &quot;STARTSTRING&quot;){
+				// jum.debug(dataLabel.substr(0, searchStr.length))
+				// jum.debug(searchStr);
+				if(searchStr == dataLabel.substr(0, searchStr.length)){
+					ret.push(this.data[x]);
+				}
+			}else if(st == &quot;SUBSTRING&quot;){
+				// this one is a gimmie
+				if(dataLabel.indexOf(searchStr) &gt;= 0){
+					ret.push(this.data[x]);
+				}
+			}else if(st == &quot;STARTWORD&quot;){
+				// do a substring search and then attempt to determine if the
+				// preceeding char was the beginning of the string or a
+				// whitespace char.
+				var idx = dataLabel.indexOf(searchStr);
+				if(idx == 0){
+					// implicit match
+					ret.push(this.data[x]);
+				}
+				if(idx &lt;= 0){
+					// if we didn't match or implicily matched, march onward
+					continue;
+				}
+				// otherwise, we have to go figure out if the match was at the
+				// start of a word...
+				// this code is taken almost directy from nWidgets
+				var matches = false;
+				while(idx!=-1){
+					// make sure the match either starts whole string, or
+					// follows a space, or follows some punctuation
+					if(&quot; ,/(&quot;.indexOf(dataLabel.charAt(idx-1)) != -1){
+						// FIXME: what about tab chars?
+						matches = true; break;
+					}
+					idx = dataLabel.indexOf(searchStr, idx+1);
+				}
+				if(!matches){
+					continue;
+				}else{
+					ret.push(this.data[x]);
+				}
+			}
+		}
+		this.provideSearchResults(ret);
+	}
+
+	this.provideSearchResults = function(resultsDataPairs){
+	}
+
+	this.addData = function(pairs){
+		// FIXME: incredibly naive and slow!
+		this.data = this.data.concat(pairs);
+	}
+
+	this.setData = function(pdata){
+		// populate this.data and initialize lookup structures
+		this.data = pdata;
+	}
+	
+	if(dataPairs){
+		this.setData(dataPairs);
+	}
+}
+
+dojo.declare(
+	&quot;dojo.widget.ComboBox&quot;,
+	null,
+	{
+		widgetType: &quot;ComboBox&quot;,
+		isContainer: false,
+	
+		forceValidOption: false,
+		searchType: &quot;stringstart&quot;,
+		dataProvider: null,
+	
+		startSearch: function(searchString){},
+		openResultList: function(results){},
+		clearResultList: function(){},
+		hideResultList: function(){},
+		selectNextResult: function(){},
+		selectPrevResult: function(){},
+		setSelectedResult: function(){}
+	}
+);
+
+// render-specific includes
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.ComboBox&quot;);
+

Added: trunk/root/static/magic/src/widget/ContentPane.js
===================================================================
--- trunk/root/static/magic/src/widget/ContentPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ContentPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,16 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+// This widget doesn't do anything; is basically the same as &lt;div&gt;.
+// It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
+// But note that those classes can contain any widget as a child.
+
+dojo.provide(&quot;dojo.widget.ContentPane&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.ContentPane&quot;);

Added: trunk/root/static/magic/src/widget/ContextMenu.js
===================================================================
--- trunk/root/static/magic/src/widget/ContextMenu.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ContextMenu.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,33 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ContextMenu&quot;);
+
+dojo.deprecated(&quot;dojo.widget.ContextMenu&quot;,  &quot;use dojo.widget.Menu2&quot;, &quot;0.4&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.DomWidget&quot;);
+
+dojo.widget.ContextMenu = function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = &quot;ContextMenu&quot;;
+	this.isContainer = true;
+	this.isOpened = false;
+	
+	// copy children widgets output directly to parent (this node), to avoid
+	// errors trying to insert an &lt;li&gt; under a &lt;div&gt;
+	this.snarfChildDomOutput = true;
+
+}
+
+dojo.inherits(dojo.widget.ContextMenu, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:contextmenu&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.ContextMenu&quot;);

Added: trunk/root/static/magic/src/widget/DatePicker.js
===================================================================
--- trunk/root/static/magic/src/widget/DatePicker.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DatePicker.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,61 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DatePicker&quot;);
+dojo.provide(&quot;dojo.widget.DatePicker.util&quot;);
+dojo.require(&quot;dojo.widget.DomWidget&quot;);
+dojo.require(&quot;dojo.date&quot;);
+
+// NOTE: this function is only used as mixin (never as a constructor)
+dojo.widget.DatePicker = function() {
+	// the following aliases prevent breaking people using 0.2.x
+	this.months = dojo.date.months,
+	this.weekdays = dojo.date.days,
+	this.toRfcDate = dojo.widget.DatePicker.util.toRfcDate,
+	this.fromRfcDate = dojo.widget.DatePicker.util.fromRfcDate,
+	this.initFirstSaturday = dojo.widget.DatePicker.util.initFirstSaturday
+};
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.DatePicker&quot;);
+
+dojo.widget.DatePicker.util = new function() {
+	this.months = dojo.date.months;
+	this.weekdays = dojo.date.days;
+	
+	this.toRfcDate = function(jsDate) {
+		if(!jsDate) {
+			var jsDate = new Date();
+		}
+		// because this is a date picker and not a time picker, we don't return a time
+		return dojo.date.format(jsDate, &quot;%Y-%m-%d&quot;);
+	}
+	
+	this.fromRfcDate = function(rfcDate) {
+		// backwards compatible support for use of &quot;any&quot; instead of just not 
+		// including the time
+		if(rfcDate.indexOf(&quot;Tany&quot;)!=-1) {
+			rfcDate = rfcDate.replace(&quot;Tany&quot;,&quot;&quot;);
+		}
+		var jsDate = new Date();
+		dojo.date.setIso8601(jsDate, rfcDate);
+		return jsDate;
+	}
+	
+	this.initFirstSaturday = function(month, year) {
+		if(!month) {
+			month = this.date.getMonth();
+		}
+		if(!year) {
+			year = this.date.getFullYear();
+		}
+		var firstOfMonth = new Date(year, month, 1);
+		return {year: year, month: month, date: 7 - firstOfMonth.getDay()};
+	}
+}

Added: trunk/root/static/magic/src/widget/DebugConsole.js
===================================================================
--- trunk/root/static/magic/src/widget/DebugConsole.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DebugConsole.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,22 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DebugConsole&quot;);
+dojo.require(&quot;dojo.widget.Widget&quot;);
+
+dojo.widget.DebugConsole= function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = &quot;DebugConsole&quot;;
+	this.isContainer = true;
+}
+dojo.inherits(dojo.widget.DebugConsole, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:debugconsole&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.DebugConsole&quot;);

Added: trunk/root/static/magic/src/widget/Dialog.js
===================================================================
--- trunk/root/static/magic/src/widget/Dialog.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Dialog.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,269 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Dialog&quot;);
+dojo.provide(&quot;dojo.widget.html.Dialog&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.ContentPane&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Dialog&quot;,
+	dojo.widget.html.ContentPane,
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlDialog.html&quot;),
+		isContainer: true,
+		_scrollConnected: false,
+		
+		// provide a focusable element or element id if you need to
+		// work around FF's tendency to send focus into outer space on hide
+		focusElement: &quot;&quot;,
+
+		bg: null,
+		bgColor: &quot;black&quot;,
+		bgOpacity: 0.4,
+		followScroll: true,
+		_fromTrap: false,
+		anim: null,
+		blockDuration: 0,
+		lifetime: 0,
+
+		trapTabs: function(e){
+			if(e.target == this.tabStart) {
+				if(this._fromTrap) {
+					this._fromTrap = false;
+				} else {
+					this._fromTrap = true;
+					this.tabEnd.focus();
+				}
+			} else if(e.target == this.tabEnd) {
+				if(this._fromTrap) {
+					this._fromTrap = false;
+				} else {
+					this._fromTrap = true;
+					this.tabStart.focus();
+				}
+			}
+		},
+
+		clearTrap: function(e) {
+			var _this = this;
+			setTimeout(function() {
+				_this._fromTrap = false;
+			}, 100);
+		},
+
+		postCreate: function(args, frag, parentComp) {
+			with(this.domNode.style) {
+				position = &quot;absolute&quot;;
+				zIndex = 999;
+				display = &quot;none&quot;;
+				overflow = &quot;visible&quot;;
+			}
+			var b = document.body;
+			b.appendChild(this.domNode);
+
+			this.bg = document.createElement(&quot;div&quot;);
+			this.bg.className = &quot;dialogUnderlay&quot;;
+			with(this.bg.style) {
+				position = &quot;absolute&quot;;
+				left = top = &quot;0px&quot;;
+				zIndex = 998;
+				display = &quot;none&quot;;
+			}
+			this.setBackgroundColor(this.bgColor);
+			b.appendChild(this.bg);
+
+			this.bgIframe = new dojo.html.BackgroundIframe(this.bg);
+		},
+
+		setBackgroundColor: function(color) {
+			if(arguments.length &gt;= 3) {
+				color = new dojo.graphics.color.Color(arguments[0], arguments[1], arguments[2]);
+			} else {
+				color = new dojo.graphics.color.Color(color);
+			}
+			this.bg.style.backgroundColor = color.toString();
+			return this.bgColor = color;
+		},
+		
+		setBackgroundOpacity: function(op) {
+			if(arguments.length == 0) { op = this.bgOpacity; }
+			dojo.style.setOpacity(this.bg, op);
+			try {
+				this.bgOpacity = dojo.style.getOpacity(this.bg);
+			} catch (e) {
+				this.bgOpacity = op;
+			}
+			return this.bgOpacity;
+		},
+
+		sizeBackground: function() {
+			if(this.bgOpacity &gt; 0) {
+				var h = Math.max(
+					document.documentElement.scrollHeight || document.body.scrollHeight,
+					dojo.html.getViewportHeight());
+				var w = dojo.html.getViewportWidth();
+				this.bg.style.width = w + &quot;px&quot;;
+				this.bg.style.height = h + &quot;px&quot;;
+			}
+			this.bgIframe.onResized();
+		},
+
+		showBackground: function() {
+			this.sizeBackground();
+			if(this.bgOpacity &gt; 0) {
+				this.bg.style.display = &quot;block&quot;;
+			}
+		},
+
+		placeDialog: function() {
+			var scroll_offset = dojo.html.getScrollOffset();
+			var viewport_size = dojo.html.getViewportSize();
+
+			// find the size of the dialog
+			var w = dojo.style.getOuterWidth(this.containerNode);
+			var h = dojo.style.getOuterHeight(this.containerNode);
+
+			var x = scroll_offset[0] + (viewport_size[0] - w)/2;
+			var y = scroll_offset[1] + (viewport_size[1] - h)/2;
+
+			with(this.domNode.style) {
+				left = x + &quot;px&quot;;
+				top = y + &quot;px&quot;;
+			}
+		},
+
+		show: function() {
+			this.setBackgroundOpacity();
+			this.showBackground();
+
+			dojo.widget.html.Dialog.superclass.show.call(this);
+
+			// FIXME: moz doesn't generate onscroll events for mouse or key scrolling (wtf)
+			// we should create a fake event by polling the scrolltop/scrollleft every X ms.
+			// this smells like it should be a dojo feature rather than just for this widget.
+
+			if (this.followScroll &amp;&amp; !this._scrollConnected){
+				this._scrollConnected = true;
+				dojo.event.connect(window, &quot;onscroll&quot;, this, &quot;onScroll&quot;);
+			}
+			
+			if(this.lifetime){
+				this.timeRemaining = this.lifetime;
+				if(!this.blockDuration){
+					dojo.event.connect(this.bg, &quot;onclick&quot;, this, &quot;hide&quot;);
+				}else{
+					dojo.event.disconnect(this.bg, &quot;onclick&quot;, this, &quot;hide&quot;);
+				}
+				if(this.timerNode){
+					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
+				}
+				if(this.blockDuration &amp;&amp; this.closeNode){
+					if(this.lifetime &gt; this.blockDuration){
+						this.closeNode.style.visibility = &quot;hidden&quot;;
+					}else{
+						this.closeNode.style.display = &quot;none&quot;;
+					}
+				}
+				this.timer = setInterval(dojo.lang.hitch(this, &quot;onTick&quot;), 100);
+			}
+
+			this.checkSize();
+		},
+
+		onLoad: function(){
+			// when href is specified we need to reposition
+			// the dialog after the data is loaded
+			this.placeDialog();
+		},
+		
+		fillInTemplate: function(){
+			// dojo.event.connect(this.domNode, &quot;onclick&quot;, this, &quot;killEvent&quot;);
+		},
+
+		hide: function(){
+			// workaround for FF focus going into outer space
+			if (this.focusElement) { 
+				dojo.byId(this.focusElement).focus(); 
+				dojo.byId(this.focusElement).blur();
+			}
+			
+			if(this.timer){
+				clearInterval(this.timer);
+			}
+
+			this.bg.style.display = &quot;none&quot;;
+			this.bg.style.width = this.bg.style.height = &quot;1px&quot;;
+
+			dojo.widget.html.Dialog.superclass.hide.call(this);
+
+			if (this._scrollConnected){
+				this._scrollConnected = false;
+				dojo.event.disconnect(window, &quot;onscroll&quot;, this, &quot;onScroll&quot;);
+			}
+		},
+		
+		setTimerNode: function(node){
+			this.timerNode = node;
+		},
+
+		setCloseControl: function(node) {
+			this.closeNode = node;
+			dojo.event.connect(node, &quot;onclick&quot;, this, &quot;hide&quot;);
+		},
+
+		setShowControl: function(node) {
+			dojo.event.connect(node, &quot;onclick&quot;, this, &quot;show&quot;);
+		},
+		
+		onTick: function(){
+			if(this.timer){
+				this.timeRemaining -= 100;
+				if(this.lifetime - this.timeRemaining &gt;= this.blockDuration){
+					dojo.event.connect(this.bg, &quot;onclick&quot;, this, &quot;hide&quot;);
+					if(this.closeNode){
+						this.closeNode.style.visibility = &quot;visible&quot;;
+					}
+				}
+				if(!this.timeRemaining){
+					clearInterval(this.timer);
+					this.hide();
+				}else if(this.timerNode){
+					this.timerNode.innerHTML = Math.ceil(this.timeRemaining/1000);
+				}
+			}
+		},
+
+		onScroll: function(){
+			this.placeDialog();
+			this.domNode.style.display = &quot;block&quot;;
+		},
+
+		// Called when the browser window's size is changed
+		checkSize: function() {
+			if(this.isShowing()){
+				this.sizeBackground();
+				this.placeDialog();
+				this.domNode.style.display=&quot;block&quot;;
+				this.onResized();
+			}
+		},
+		
+		killEvent: function(evt){
+			evt.preventDefault();
+			evt.stopPropagation();
+		}
+
+	}
+);

Added: trunk/root/static/magic/src/widget/DocPane.js
===================================================================
--- trunk/root/static/magic/src/widget/DocPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DocPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DocPane&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.DocPane&quot;);

Added: trunk/root/static/magic/src/widget/DomWidget.js
===================================================================
--- trunk/root/static/magic/src/widget/DomWidget.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DomWidget.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,593 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DomWidget&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.Widget&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.xml.Parse&quot;);
+dojo.require(&quot;dojo.uri.*&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+
+dojo.widget._cssFiles = {};
+dojo.widget._cssStrings = {};
+dojo.widget._templateCache = {};
+
+dojo.widget.defaultStrings = {
+	dojoRoot: dojo.hostenv.getBaseScriptUri(),
+	baseScriptUri: dojo.hostenv.getBaseScriptUri()
+};
+
+dojo.widget.buildFromTemplate = function() {
+	dojo.lang.forward(&quot;fillFromTemplateCache&quot;);
+}
+
+// static method to build from a template w/ or w/o a real widget in place
+dojo.widget.fillFromTemplateCache = function(obj, templatePath, templateCssPath, templateString, avoidCache){
+	// dojo.debug(&quot;avoidCache:&quot;, avoidCache);
+	var tpath = templatePath || obj.templatePath;
+	var cpath = templateCssPath || obj.templateCssPath;
+
+	// DEPRECATED: use Uri objects, not strings
+	if (tpath &amp;&amp; !(tpath instanceof dojo.uri.Uri)) {
+		tpath = dojo.uri.dojoUri(tpath);
+		dojo.deprecated(&quot;templatePath should be of type dojo.uri.Uri&quot;, null, &quot;0.4&quot;);
+	}
+	if (cpath &amp;&amp; !(cpath instanceof dojo.uri.Uri)) {
+		cpath = dojo.uri.dojoUri(cpath);
+		dojo.deprecated(&quot;templateCssPath should be of type dojo.uri.Uri&quot;, null, &quot;0.4&quot;);
+	}
+	
+	var tmplts = dojo.widget._templateCache;
+	if(!obj[&quot;widgetType&quot;]) { // don't have a real template here
+		do {
+			var dummyName = &quot;__dummyTemplate__&quot; + dojo.widget._templateCache.dummyCount++;
+		} while(tmplts[dummyName]);
+		obj.widgetType = dummyName;
+	}
+	var wt = obj.widgetType;
+
+	if(cpath &amp;&amp; !dojo.widget._cssFiles[cpath.toString()]){
+		if((!obj.templateCssString)&amp;&amp;(cpath)){
+			obj.templateCssString = dojo.hostenv.getText(cpath);
+			obj.templateCssPath = null;
+		}
+		if((obj[&quot;templateCssString&quot;])&amp;&amp;(!obj.templateCssString[&quot;loaded&quot;])){
+			dojo.style.insertCssText(obj.templateCssString, null, cpath);
+			if(!obj.templateCssString){ obj.templateCssString = &quot;&quot;; }
+			obj.templateCssString.loaded = true;
+		}
+		dojo.widget._cssFiles[cpath.toString()] = true;
+	}
+
+	var ts = tmplts[wt];
+	if(!ts){
+		tmplts[wt] = { &quot;string&quot;: null, &quot;node&quot;: null };
+		if(avoidCache){
+			ts = {};
+		}else{
+			ts = tmplts[wt];
+		}
+	}
+	if((!obj.templateString)&amp;&amp;(!avoidCache)){
+		obj.templateString = templateString || ts[&quot;string&quot;];
+	}
+	if((!obj.templateNode)&amp;&amp;(!avoidCache)){
+		obj.templateNode = ts[&quot;node&quot;];
+	}
+	if((!obj.templateNode)&amp;&amp;(!obj.templateString)&amp;&amp;(tpath)){
+		// fetch a text fragment and assign it to templateString
+		// NOTE: we rely on blocking IO here!
+		var tstring = dojo.hostenv.getText(tpath);
+		if(tstring){
+			// strip &lt;?xml ...?&gt; declarations so that external SVG and XML
+			// documents can be added to a document without worry
+			tstring = tstring.replace(/^\s*&lt;\?xml(\s)+version=[\'\&quot;](\d)*.(\d)*[\'\&quot;](\s)*\?&gt;/im, &quot;&quot;);
+			var matches = tstring.match(/&lt;body[^&gt;]*&gt;\s*([\s\S]+)\s*&lt;\/body&gt;/im);
+			if(matches){
+				tstring = matches[1];
+			}
+		}else{
+			tstring = &quot;&quot;;
+		}
+		obj.templateString = tstring;
+		if(!avoidCache){
+			tmplts[wt][&quot;string&quot;] = tstring;
+		}
+	}
+	if((!ts[&quot;string&quot;])&amp;&amp;(!avoidCache)){
+		ts.string = obj.templateString;
+	}
+}
+dojo.widget._templateCache.dummyCount = 0;
+
+dojo.widget.attachProperties = [&quot;dojoAttachPoint&quot;, &quot;id&quot;];
+dojo.widget.eventAttachProperty = &quot;dojoAttachEvent&quot;;
+dojo.widget.onBuildProperty = &quot;dojoOnBuild&quot;;
+dojo.widget.waiNames  = [&quot;waiRole&quot;, &quot;waiState&quot;];
+dojo.widget.wai = {
+	waiRole: { 	name: &quot;waiRole&quot;, 
+				namespace: &quot;<A HREF="http://www.w3.org/TR/xhtml2">http://www.w3.org/TR/xhtml2</A>&quot;, 
+				alias: &quot;x2&quot;,
+				prefix: &quot;wairole:&quot;,
+				nsName: &quot;role&quot;
+	},
+	waiState: { name: &quot;waiState&quot;, 
+				namespace: &quot;<A HREF="http://www.w3.org/2005/07/aaa">http://www.w3.org/2005/07/aaa</A>&quot; , 
+				alias: &quot;aaa&quot;,
+				prefix: &quot;&quot;,
+				nsName: &quot;state&quot;
+	},
+	setAttr: function(node, attr, value){
+		if(dojo.render.html.ie){
+			node.setAttribute(this[attr].alias+&quot;:&quot;+this[attr].nsName, this[attr].prefix+value);
+		}else{
+			node.setAttributeNS(this[attr].namespace, this[attr].nsName, this[attr].prefix+value);
+		}
+	}
+};
+
+dojo.widget.attachTemplateNodes = function(rootNode, targetObj, events){
+	// FIXME: this method is still taking WAAAY too long. We need ways of optimizing:
+	//	a.) what we are looking for on each node
+	//	b.) the nodes that are subject to interrogation (use xpath instead?)
+	//	c.) how expensive event assignment is (less eval(), more connect())
+	// var start = new Date();
+	var elementNodeType = dojo.dom.ELEMENT_NODE;
+
+	function trim(str){
+		return str.replace(/^\s+|\s+$/g, &quot;&quot;);
+	}
+
+	if(!rootNode){ 
+		rootNode = targetObj.domNode;
+	}
+
+	if(rootNode.nodeType != elementNodeType){
+		return;
+	}
+	// alert(events.length);
+
+	var nodes = rootNode.all || rootNode.getElementsByTagName(&quot;*&quot;);
+	var _this = targetObj;
+	for(var x=-1; x&lt;nodes.length; x++){
+		var baseNode = (x == -1) ? rootNode : nodes[x];
+		// FIXME: is this going to have capitalization problems?  Could use getAttribute(name, 0); to get attributes case-insensitve
+		var attachPoint = [];
+		for(var y=0; y&lt;this.attachProperties.length; y++){
+			var tmpAttachPoint = baseNode.getAttribute(this.attachProperties[y]);
+			if(tmpAttachPoint){
+				attachPoint = tmpAttachPoint.split(&quot;;&quot;);
+				for(var z=0; z&lt;attachPoint.length; z++){
+					if(dojo.lang.isArray(targetObj[attachPoint[z]])){
+						targetObj[attachPoint[z]].push(baseNode);
+					}else{
+						targetObj[attachPoint[z]]=baseNode;
+					}
+				}
+				break;
+			}
+		}
+		// continue;
+
+		// FIXME: we need to put this into some kind of lookup structure
+		// instead of direct assignment
+		var tmpltPoint = baseNode.getAttribute(this.templateProperty);
+		if(tmpltPoint){
+			targetObj[tmpltPoint]=baseNode;
+		}
+
+		dojo.lang.forEach(dojo.widget.waiNames, function(name){
+			var wai = dojo.widget.wai[name];
+			var val = baseNode.getAttribute(wai.name);
+			if(val){
+				dojo.widget.wai.setAttr(baseNode, wai.name, val);
+			}
+		}, this);
+
+		var attachEvent = baseNode.getAttribute(this.eventAttachProperty);
+		if(attachEvent){
+			// NOTE: we want to support attributes that have the form
+			// &quot;domEvent: nativeEvent; ...&quot;
+			var evts = attachEvent.split(&quot;;&quot;);
+			for(var y=0; y&lt;evts.length; y++){
+				if((!evts[y])||(!evts[y].length)){ continue; }
+				var thisFunc = null;
+				var tevt = trim(evts[y]);
+				if(evts[y].indexOf(&quot;:&quot;) &gt;= 0){
+					// oh, if only JS had tuple assignment
+					var funcNameArr = tevt.split(&quot;:&quot;);
+					tevt = trim(funcNameArr[0]);
+					thisFunc = trim(funcNameArr[1]);
+				}
+				if(!thisFunc){
+					thisFunc = tevt;
+				}
+
+				var tf = function(){ 
+					var ntf = new String(thisFunc);
+					return function(evt){
+						if(_this[ntf]){
+							_this[ntf](dojo.event.browser.fixEvent(evt, this));
+						}
+					};
+				}();
+				dojo.event.browser.addListener(baseNode, tevt, tf, false, true);
+				// dojo.event.browser.addListener(baseNode, tevt, dojo.lang.hitch(_this, thisFunc));
+			}
+		}
+
+		for(var y=0; y&lt;events.length; y++){
+			//alert(events[x]);
+			var evtVal = baseNode.getAttribute(events[y]);
+			if((evtVal)&amp;&amp;(evtVal.length)){
+				var thisFunc = null;
+				var domEvt = events[y].substr(4); // clober the &quot;dojo&quot; prefix
+				thisFunc = trim(evtVal);
+				var funcs = [thisFunc];
+				if(thisFunc.indexOf(&quot;;&quot;)&gt;=0){
+					funcs = dojo.lang.map(thisFunc.split(&quot;;&quot;), trim);
+				}
+				for(var z=0; z&lt;funcs.length; z++){
+					if(!funcs[z].length){ continue; }
+					var tf = function(){ 
+						var ntf = new String(funcs[z]);
+						return function(evt){
+							if(_this[ntf]){
+								_this[ntf](dojo.event.browser.fixEvent(evt, this));
+							}
+						}
+					}();
+					dojo.event.browser.addListener(baseNode, domEvt, tf, false, true);
+					// dojo.event.browser.addListener(baseNode, domEvt, dojo.lang.hitch(_this, funcs[z]));
+				}
+			}
+		}
+
+		var onBuild = baseNode.getAttribute(this.onBuildProperty);
+		if(onBuild){
+			eval(&quot;var node = baseNode; var widget = targetObj; &quot;+onBuild);
+		}
+	}
+
+}
+
+dojo.widget.getDojoEventsFromStr = function(str){
+	// var lstr = str.toLowerCase();
+	var re = /(dojoOn([a-z]+)(\s?))=/gi;
+	var evts = str ? str.match(re)||[] : [];
+	var ret = [];
+	var lem = {};
+	for(var x=0; x&lt;evts.length; x++){
+		if(evts[x].legth &lt; 1){ continue; }
+		var cm = evts[x].replace(/\s/, &quot;&quot;);
+		cm = (cm.slice(0, cm.length-1));
+		if(!lem[cm]){
+			lem[cm] = true;
+			ret.push(cm);
+		}
+	}
+	return ret;
+}
+
+/*
+dojo.widget.buildAndAttachTemplate = function(obj, templatePath, templateCssPath, templateString, targetObj) {
+	this.buildFromTemplate(obj, templatePath, templateCssPath, templateString);
+	var node = dojo.dom.createNodesFromText(obj.templateString, true)[0];
+	this.attachTemplateNodes(node, targetObj||obj, dojo.widget.getDojoEventsFromStr(templateString));
+	return node;
+}
+*/
+
+dojo.declare(&quot;dojo.widget.DomWidget&quot;, dojo.widget.Widget, {
+	initializer: function() {
+		if((arguments.length&gt;0)&amp;&amp;(typeof arguments[0] == &quot;object&quot;)){
+			this.create(arguments[0]);
+		}
+	},
+								 
+	templateNode: null,
+	templateString: null,
+	templateCssString: null,
+	preventClobber: false,
+	domNode: null, // this is our visible representation of the widget!
+	containerNode: null, // holds child elements
+
+	// Process the given child widget, inserting it's dom node as a child of our dom node
+	// FIXME: should we support addition at an index in the children arr and
+	// order the display accordingly? Right now we always append.
+	addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+		if(!this.isContainer){ // we aren't allowed to contain other widgets, it seems
+			dojo.debug(&quot;dojo.widget.DomWidget.addChild() attempted on non-container widget&quot;);
+			return null;
+		}else{
+			this.addWidgetAsDirectChild(widget, overrideContainerNode, pos, ref, insertIndex);
+			this.registerChild(widget, insertIndex);
+		}
+		return widget;
+	},
+	
+	addWidgetAsDirectChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+		if((!this.containerNode)&amp;&amp;(!overrideContainerNode)){
+			this.containerNode = this.domNode;
+		}
+		var cn = (overrideContainerNode) ? overrideContainerNode : this.containerNode;
+		if(!pos){ pos = &quot;after&quot;; }
+		if(!ref){ 
+			// if(!cn){ cn = document.body; }
+			if(!cn){ cn = document.body; }
+			ref = cn.lastChild; 
+		}
+		if(!insertIndex) { insertIndex = 0; }
+		widget.domNode.setAttribute(&quot;dojoinsertionindex&quot;, insertIndex);
+
+		// insert the child widget domNode directly underneath my domNode, in the
+		// specified position (by default, append to end)
+		if(!ref){
+			cn.appendChild(widget.domNode);
+		}else{
+			// FIXME: was this meant to be the (ugly hack) way to support insert @ index?
+			//dojo.dom[pos](widget.domNode, ref, insertIndex);
+
+			// CAL: this appears to be the intended way to insert a node at a given position...
+			if (pos == 'insertAtIndex'){
+				// dojo.debug(&quot;idx:&quot;, insertIndex, &quot;isLast:&quot;, ref === cn.lastChild);
+				dojo.dom.insertAtIndex(widget.domNode, ref.parentNode, insertIndex);
+			}else{
+				// dojo.debug(&quot;pos:&quot;, pos, &quot;isLast:&quot;, ref === cn.lastChild);
+				if((pos == &quot;after&quot;)&amp;&amp;(ref === cn.lastChild)){
+					cn.appendChild(widget.domNode);
+				}else{
+					dojo.dom.insertAtPosition(widget.domNode, cn, pos);
+				}
+			}
+		}
+	},
+
+	// Record that given widget descends from me
+	registerChild: function(widget, insertionIndex){
+
+		// we need to insert the child at the right point in the parent's 
+		// 'children' array, based on the insertionIndex
+
+		widget.dojoInsertionIndex = insertionIndex;
+
+		var idx = -1;
+		for(var i=0; i&lt;this.children.length; i++){
+			if (this.children[i].dojoInsertionIndex &lt; insertionIndex){
+				idx = i;
+			}
+		}
+
+		this.children.splice(idx+1, 0, widget);
+
+		widget.parent = this;
+		widget.addedTo(this);
+		
+		// If this widget was created programatically, then it was erroneously added
+		// to dojo.widget.manager.topWidgets.  Fix that here.
+		delete dojo.widget.manager.topWidgets[widget.widgetId];
+	},
+
+	removeChild: function(widget){
+		// detach child domNode from parent domNode
+		dojo.dom.removeNode(widget.domNode);
+
+		// remove child widget from parent widget
+		return dojo.widget.DomWidget.superclass.removeChild.call(this, widget);
+	},
+
+	getFragNodeRef: function(frag){
+		if( !frag || !frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()] ){
+			dojo.raise(&quot;Error: no frag for widget type &quot; + this.widgetType +
+				&quot;, id &quot; + this.widgetId + &quot; (maybe a widget has set it's type incorrectly)&quot;);
+		}
+		return (frag ? frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()][&quot;nodeRef&quot;] : null);
+	},
+	
+	// Replace source domNode with generated dom structure, and register
+	// widget with parent.
+	postInitialize: function(args, frag, parentComp){
+		var sourceNodeRef = this.getFragNodeRef(frag);
+		// Stick my generated dom into the output tree
+		//alert(this.widgetId + &quot;: replacing &quot; + sourceNodeRef + &quot; with &quot; + this.domNode.innerHTML);
+		if (parentComp &amp;&amp; (parentComp.snarfChildDomOutput || !sourceNodeRef)){
+			// Add my generated dom as a direct child of my parent widget
+			// This is important for generated widgets, and also cases where I am generating an
+			// &lt;li&gt; node that can't be inserted back into the original DOM tree
+			parentComp.addWidgetAsDirectChild(this, &quot;&quot;, &quot;insertAtIndex&quot;, &quot;&quot;,  args[&quot;dojoinsertionindex&quot;], sourceNodeRef);
+		} else if (sourceNodeRef){
+			// Do in-place replacement of the my source node with my generated dom
+			if(this.domNode &amp;&amp; (this.domNode !== sourceNodeRef)){
+				var oldNode = sourceNodeRef.parentNode.replaceChild(this.domNode, sourceNodeRef);
+			}
+		}
+
+		// Register myself with my parent, or with the widget manager if
+		// I have no parent
+		// TODO: the code below erroneously adds all programatically generated widgets
+		// to topWidgets (since we don't know who the parent is until after creation finishes)
+		if ( parentComp ) {
+			parentComp.registerChild(this, args.dojoinsertionindex);
+		} else {
+			dojo.widget.manager.topWidgets[this.widgetId]=this;
+		}
+
+		// Expand my children widgets
+		if(this.isContainer){
+			//alert(&quot;recurse from &quot; + this.widgetId);
+			// build any sub-components with us as the parent
+			var fragParser = dojo.widget.getParser();
+			fragParser.createSubComponents(frag, this);
+		}
+	},
+
+	// method over-ride
+	buildRendering: function(args, frag){
+		// DOM widgets construct themselves from a template
+		var ts = dojo.widget._templateCache[this.widgetType];
+		if(	
+			(!this.preventClobber)&amp;&amp;(
+				(this.templatePath)||
+				(this.templateNode)||
+				(
+					(this[&quot;templateString&quot;])&amp;&amp;(this.templateString.length) 
+				)||
+				(
+					(typeof ts != &quot;undefined&quot;)&amp;&amp;( (ts[&quot;string&quot;])||(ts[&quot;node&quot;]) )
+				)
+			)
+		){
+			// if it looks like we can build the thing from a template, do it!
+			this.buildFromTemplate(args, frag);
+		}else{
+			// otherwise, assign the DOM node that was the source of the widget
+			// parsing to be the root node
+			this.domNode = this.getFragNodeRef(frag);
+		}
+		this.fillInTemplate(args, frag); 	// this is where individual widgets
+											// will handle population of data
+											// from properties, remote data
+											// sets, etc.
+	},
+
+	buildFromTemplate: function(args, frag){
+		// var start = new Date();
+		// copy template properties if they're already set in the templates object
+		// dojo.debug(&quot;buildFromTemplate:&quot;, this);
+		var avoidCache = false;
+		if(args[&quot;templatecsspath&quot;]){
+			args[&quot;templateCssPath&quot;] = args[&quot;templatecsspath&quot;];
+		}
+		if(args[&quot;templatepath&quot;]){
+			avoidCache = true;
+			args[&quot;templatePath&quot;] = args[&quot;templatepath&quot;];
+		}
+		dojo.widget.fillFromTemplateCache(	this, 
+											args[&quot;templatePath&quot;], 
+											args[&quot;templateCssPath&quot;],
+											null,
+											avoidCache);
+		var ts = dojo.widget._templateCache[this.widgetType];
+		if((ts)&amp;&amp;(!avoidCache)){
+			if(!this.templateString.length){
+				this.templateString = ts[&quot;string&quot;];
+			}
+			if(!this.templateNode){
+				this.templateNode = ts[&quot;node&quot;];
+			}
+		}
+		var matches = false;
+		var node = null;
+		// var tstr = new String(this.templateString); 
+		var tstr = this.templateString; 
+		// attempt to clone a template node, if there is one
+		if((!this.templateNode)&amp;&amp;(this.templateString)){
+			matches = this.templateString.match(/\$\{([^\}]+)\}/g);
+			if(matches) {
+				// if we do property replacement, don't create a templateNode
+				// to clone from.
+				var hash = this.strings || {};
+				// FIXME: should this hash of default replacements be cached in
+				// templateString?
+				for(var key in dojo.widget.defaultStrings) {
+					if(dojo.lang.isUndefined(hash[key])) {
+						hash[key] = dojo.widget.defaultStrings[key];
+					}
+				}
+				// FIXME: this is a lot of string munging. Can we make it faster?
+				for(var i = 0; i &lt; matches.length; i++) {
+					var key = matches[i];
+					key = key.substring(2, key.length-1);
+					var kval = (key.substring(0, 5) == &quot;this.&quot;) ? dojo.lang.getObjPathValue(key.substring(5), this) : hash[key];
+					var value;
+					if((kval)||(dojo.lang.isString(kval))){
+						value = (dojo.lang.isFunction(kval)) ? kval.call(this, key, this.templateString) : kval;
+						tstr = tstr.replace(matches[i], value);
+					}
+				}
+			}else{
+				// otherwise, we are required to instantiate a copy of the template
+				// string if one is provided.
+				
+				// FIXME: need to be able to distinguish here what should be done
+				// or provide a generic interface across all DOM implementations
+				// FIMXE: this breaks if the template has whitespace as its first 
+				// characters
+				// node = this.createNodesFromText(this.templateString, true);
+				// this.templateNode = node[0].cloneNode(true); // we're optimistic here
+				this.templateNode = this.createNodesFromText(this.templateString, true)[0];
+				if(!avoidCache){
+					ts.node = this.templateNode;
+				}
+			}
+		}
+		if((!this.templateNode)&amp;&amp;(!matches)){ 
+			dojo.debug(&quot;weren't able to create template!&quot;);
+			return false;
+		}else if(!matches){
+			node = this.templateNode.cloneNode(true);
+			if(!node){ return false; }
+		}else{
+			node = this.createNodesFromText(tstr, true)[0];
+		}
+
+		// recurse through the node, looking for, and attaching to, our
+		// attachment points which should be defined on the template node.
+
+		this.domNode = node;
+		// dojo.profile.start(&quot;attachTemplateNodes&quot;);
+		this.attachTemplateNodes(this.domNode, this);
+		// dojo.profile.end(&quot;attachTemplateNodes&quot;);
+		
+		// relocate source contents to templated container node
+		// this.containerNode must be able to receive children, or exceptions will be thrown
+		if (this.isContainer &amp;&amp; this.containerNode){
+			var src = this.getFragNodeRef(frag);
+			if (src){
+				dojo.dom.moveChildren(src, this.containerNode);
+			}
+		}
+	},
+
+	attachTemplateNodes: function(baseNode, targetObj){
+		if(!targetObj){ targetObj = this; }
+		return dojo.widget.attachTemplateNodes(baseNode, targetObj, 
+					dojo.widget.getDojoEventsFromStr(this.templateString));
+	},
+
+	fillInTemplate: function(){
+		// dojo.unimplemented(&quot;dojo.widget.DomWidget.fillInTemplate&quot;);
+	},
+	
+	// method over-ride
+	destroyRendering: function(){
+		try{
+			delete this.domNode;
+		}catch(e){ /* squelch! */ }
+	},
+
+	// FIXME: method over-ride
+	cleanUp: function(){},
+	
+	getContainerHeight: function(){
+		dojo.unimplemented(&quot;dojo.widget.DomWidget.getContainerHeight&quot;);
+	},
+
+	getContainerWidth: function(){
+		dojo.unimplemented(&quot;dojo.widget.DomWidget.getContainerWidth&quot;);
+	},
+
+	createNodesFromText: function(){
+		dojo.unimplemented(&quot;dojo.widget.DomWidget.createNodesFromText&quot;);
+	}
+});

Added: trunk/root/static/magic/src/widget/DropdownButton.js
===================================================================
--- trunk/root/static/magic/src/widget/DropdownButton.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DropdownButton.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,29 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DropdownButton&quot;);
+
+dojo.deprecated(&quot;dojo.widget.DropdownButton&quot;,  &quot;use dojo.widget.ComboButton&quot;, &quot;0.4&quot;);
+
+// Draws a button with a down arrow;
+// when you press the down arrow something appears (usually a menu)
+
+dojo.require(&quot;dojo.widget.*&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:dropdownbutton&quot;);
+
+dojo.widget.DropdownButton = function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = &quot;DropdownButton&quot;;
+}
+dojo.inherits(dojo.widget.DropdownButton, dojo.widget.Widget);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.DropdownButton&quot;);

Added: trunk/root/static/magic/src/widget/DropdownContainer.js
===================================================================
--- trunk/root/static/magic/src/widget/DropdownContainer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DropdownContainer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,118 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DropdownContainer&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.DropdownContainer&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		initializer: function(){
+		},
+
+		inputWidth: &quot;7em&quot;,
+		inputId: &quot;&quot;,
+		inputName: &quot;&quot;,
+		iconURL: dojo.uri.dojoUri(&quot;src/widget/templates/images/combo_box_arrow.png&quot;),
+		iconAlt: &quot;&quot;,
+
+		inputNode: null,
+		buttonNode: null,
+		containerNode: null,
+		subWidgetNode: null,
+
+		containerToggle: &quot;plain&quot;,
+		containerToggleDuration: 150,
+		containerAnimInProgress: false,
+
+		templateString: '&lt;div&gt;&lt;span style=&quot;white-space:nowrap&quot;&gt;&lt;input type=&quot;text&quot; value=&quot;&quot; style=&quot;vertical-align:middle;&quot; dojoAttachPoint=&quot;inputNode&quot; autocomplete=&quot;off&quot; /&gt; &lt;img src=&quot;${this.iconURL}&quot; alt=&quot;${this.iconAlt}&quot; dojoAttachPoint=&quot;buttonNode&quot; dojoAttachEvent=&quot;onclick: onIconClick;&quot; style=&quot;vertical-align:middle; cursor:pointer; cursor:hand;&quot; /&gt;&lt;/span&gt;&lt;br /&gt;&lt;div dojoAttachPoint=&quot;containerNode&quot; style=&quot;display:none;position:absolute;width:12em;background-color:#fff;&quot;&gt;&lt;/div&gt;&lt;/div&gt;',
+		templateCssPath: &quot;&quot;,
+
+		fillInTemplate: function(args, frag){
+			var source = this.getFragNodeRef(frag);
+			
+			this.containerNode.style.left = &quot;&quot;;
+			this.containerNode.style.top = &quot;&quot;;
+
+			if(this.inputId){ this.inputNode.id = this.inputId; }
+			if(this.inputName){ this.inputNode.name = this.inputName; }
+			this.inputNode.style.width = this.inputWidth;
+
+			dojo.event.connect(this.inputNode, &quot;onchange&quot;, this, &quot;onInputChange&quot;);
+			
+			this.containerIframe = new dojo.html.BackgroundIframe(this.containerNode);
+			this.containerIframe.size([0,0,0,0]);
+		},
+
+		postMixInProperties: function(args, frag, parentComp){
+			// now that we know the setting for toggle, get toggle object
+			// (default to plain toggler if user specified toggler not present)
+			this.containerToggleObj =
+				dojo.lfx.toggle[this.containerToggle.toLowerCase()] || dojo.lfx.toggle.plain;
+			dojo.widget.DropdownContainer.superclass.postMixInProperties.call(this, args, frag, parentComp);
+		},
+
+		onIconClick: function(evt){
+			this.toggleContainerShow();
+		},
+
+		toggleContainerShow: function(){
+			if(dojo.html.isShowing(this.containerNode)){
+				this.hideContainer();
+			}else{
+				this.showContainer();
+			}
+		},
+		
+		showContainer: function(){
+			this.containerAnimInProgress=true;
+			this.containerToggleObj.show(this.containerNode, this.containerToggleDuration, null,
+				dojo.lang.hitch(this, this.onContainerShow), this.explodeSrc);
+			dojo.lang.setTimeout(this, this.sizeBackgroundIframe, this.containerToggleDuration);
+		},
+
+		onContainerShow: function(){
+			this.containerAnimInProgress=false;
+		},
+
+		hideContainer: function(){
+			this.containerAnimInProgress=true;
+			this.containerToggleObj.hide(this.containerNode, this.containerToggleDuration, null,
+				dojo.lang.hitch(this, this.onContainerHide), this.explodeSrc);
+			dojo.lang.setTimeout(this, this.sizeBackgroundIframe, this.containerToggleDuration);
+		},
+
+		onContainerHide: function(){
+			this.containerAnimInProgress=false;
+		},
+		
+		sizeBackgroundIframe: function(){
+			var w = dojo.style.getOuterWidth(this.containerNode);
+			var h = dojo.style.getOuterHeight(this.containerNode);
+			if(w==0||h==0){
+				// need more time to calculate size
+				dojo.lang.setTimeout(this, &quot;sizeBackgroundIframe&quot;, 100);
+				return;
+			}
+			if(dojo.html.isShowing(this.containerNode)){
+				this.containerIframe.size([0,0,w,h]);
+			}
+		},
+
+		onInputChange: function(){}
+	},
+	&quot;html&quot;
+);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:dropdowncontainer&quot;);

Added: trunk/root/static/magic/src/widget/DropdownDatePicker.js
===================================================================
--- trunk/root/static/magic/src/widget/DropdownDatePicker.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/DropdownDatePicker.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,67 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.DropdownDatePicker&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.DropdownContainer&quot;);
+dojo.require(&quot;dojo.widget.DatePicker&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.DropdownDatePicker&quot;,
+	dojo.widget.DropdownContainer,
+	{
+		iconURL: dojo.uri.dojoUri(&quot;src/widget/templates/images/dateIcon.gif&quot;),
+		iconAlt: &quot;Select a Date&quot;,
+		zIndex: &quot;10&quot;,
+		datePicker: null,
+		
+		dateFormat: &quot;%m/%d/%Y&quot;,
+		date: null,
+		
+		fillInTemplate: function(args, frag){
+			dojo.widget.DropdownDatePicker.superclass.fillInTemplate.call(this, args, frag);
+			var source = this.getFragNodeRef(frag);
+			
+			if(args.date){ this.date = new Date(args.date); }
+			
+			var dpNode = document.createElement(&quot;div&quot;);
+			this.containerNode.appendChild(dpNode);
+			
+			var dateProps = { widgetContainerId: this.widgetId };
+			if(this.date){
+				dateProps[&quot;date&quot;] = this.date;
+				dateProps[&quot;storedDate&quot;] = dojo.widget.DatePicker.util.toRfcDate(this.date);
+				this.inputNode.value = dojo.date.format(this.date, this.dateFormat);
+			}
+			this.datePicker = dojo.widget.createWidget(&quot;DatePicker&quot;, dateProps, dpNode);
+			dojo.event.connect(this.datePicker, &quot;onSetDate&quot;, this, &quot;onSetDate&quot;);
+			this.containerNode.style.zIndex = this.zIndex;
+			this.containerNode.style.backgroundColor = &quot;transparent&quot;;
+		},
+		
+		onSetDate: function(){
+			this.inputNode.value = dojo.date.format(this.datePicker.date, this.dateFormat);
+			this.hideContainer();
+		},
+		
+		onInputChange: function(){
+			var tmp = new Date(this.inputNode.value);
+			this.datePicker.date = tmp;
+			this.datePicker.setDate(dojo.widget.DatePicker.util.toRfcDate(tmp));
+			this.datePicker.initData();
+			this.datePicker.initUI();
+		}
+	},
+	&quot;html&quot;
+);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:dropdowndatepicker&quot;);

Added: trunk/root/static/magic/src/widget/Editor.js
===================================================================
--- trunk/root/static/magic/src/widget/Editor.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Editor.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,533 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/* TODO:
+ * - font selector
+ * - test, bug fix, more features :)
+*/
+dojo.provide(&quot;dojo.widget.Editor&quot;);
+dojo.provide(&quot;dojo.widget.html.Editor&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.Toolbar&quot;);
+dojo.require(&quot;dojo.widget.RichText&quot;);
+dojo.require(&quot;dojo.widget.ColorPalette&quot;);
+dojo.require(&quot;dojo.string.extras&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:Editor&quot;);
+
+dojo.widget.html.Editor = function() {
+	dojo.widget.HtmlWidget.call(this);
+	this.contentFilters = [];
+	this._toolbars = [];
+}
+dojo.inherits(dojo.widget.html.Editor, dojo.widget.HtmlWidget);
+
+dojo.widget.html.Editor.itemGroups = {
+	textGroup: [&quot;bold&quot;, &quot;italic&quot;, &quot;underline&quot;, &quot;strikethrough&quot;],
+	blockGroup: [&quot;formatBlock&quot;, &quot;fontName&quot;, &quot;fontSize&quot;],
+	justifyGroup: [&quot;justifyleft&quot;, &quot;justifycenter&quot;, &quot;justifyright&quot;],
+	commandGroup: [&quot;save&quot;, &quot;cancel&quot;],
+	colorGroup: [&quot;forecolor&quot;, &quot;hilitecolor&quot;],
+	listGroup: [&quot;insertorderedlist&quot;, &quot;insertunorderedlist&quot;],
+	indentGroup: [&quot;outdent&quot;, &quot;indent&quot;],
+	linkGroup: [&quot;createlink&quot;, &quot;insertimage&quot;, &quot;inserthorizontalrule&quot;]
+};
+
+dojo.widget.html.Editor.formatBlockValues = {
+	&quot;Normal&quot;: &quot;p&quot;,
+	&quot;Main heading&quot;: &quot;h2&quot;,
+	&quot;Sub heading&quot;: &quot;h3&quot;,
+	&quot;Sub sub heading&quot;: &quot;h4&quot;,
+	&quot;Preformatted&quot;: &quot;pre&quot;
+};
+
+dojo.widget.html.Editor.fontNameValues = {
+	&quot;Arial&quot;: &quot;Arial, Helvetica, sans-serif&quot;,
+	&quot;Verdana&quot;: &quot;Verdana, sans-serif&quot;,
+	&quot;Times New Roman&quot;: &quot;Times New Roman, serif&quot;,
+	&quot;Courier&quot;: &quot;Courier New, monospace&quot;
+};
+
+dojo.widget.html.Editor.fontSizeValues = {
+	&quot;1 (8 pt)&quot; : &quot;1&quot;,
+	&quot;2 (10 pt)&quot;: &quot;2&quot;,
+	&quot;3 (12 pt)&quot;: &quot;3&quot;,
+	&quot;4 (14 pt)&quot;: &quot;4&quot;,
+	&quot;5 (18 pt)&quot;: &quot;5&quot;,
+	&quot;6 (24 pt)&quot;: &quot;6&quot;,
+	&quot;7 (36 pt)&quot;: &quot;7&quot;
+};
+
+dojo.widget.html.Editor.defaultItems = [
+	&quot;commandGroup&quot;, &quot;|&quot;, &quot;blockGroup&quot;, &quot;|&quot;, &quot;textGroup&quot;, &quot;|&quot;, &quot;colorGroup&quot;, &quot;|&quot;, &quot;justifyGroup&quot;, &quot;|&quot;, &quot;listGroup&quot;, &quot;indentGroup&quot;, &quot;|&quot;, &quot;linkGroup&quot;
+];
+
+// ones we support by default without asking the RichText component
+// NOTE: you shouldn't put buttons like bold, italic, etc in here
+dojo.widget.html.Editor.supportedCommands = [&quot;save&quot;, &quot;cancel&quot;, &quot;|&quot;, &quot;-&quot;, &quot;/&quot;, &quot; &quot;];
+
+dojo.lang.extend(dojo.widget.html.Editor, {
+	widgetType: &quot;Editor&quot;,
+
+	saveUrl: &quot;&quot;,
+	saveMethod: &quot;post&quot;,
+	saveArgName: &quot;editorContent&quot;,
+	closeOnSave: false,
+	items: dojo.widget.html.Editor.defaultItems,
+	formatBlockItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.formatBlockValues),
+	fontNameItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.fontNameValues),
+	fontSizeItems: dojo.lang.shallowCopy(dojo.widget.html.Editor.fontSizeValues),
+
+	// used to get the properties of an item if it is given as a string
+	getItemProperties: function(name) {
+		var props = {};
+		switch(name.toLowerCase()) {
+			case &quot;bold&quot;:
+			case &quot;italic&quot;:
+			case &quot;underline&quot;:
+			case &quot;strikethrough&quot;:
+				props.toggleItem = true;
+				break;
+
+			case &quot;justifygroup&quot;:
+				props.defaultButton = &quot;justifyleft&quot;;
+				props.preventDeselect = true;
+				props.buttonGroup = true;
+				break;
+
+			case &quot;listgroup&quot;:
+				props.buttonGroup = true;
+				break;
+
+			case &quot;save&quot;:
+			case &quot;cancel&quot;:
+				props.label = dojo.string.capitalize(name);
+				break;
+
+			case &quot;forecolor&quot;:
+			case &quot;hilitecolor&quot;:
+				props.name = name;
+				props.toggleItem = true; // FIXME: they aren't exactly toggle items
+				props.icon = this.getCommandImage(name);
+				break;
+
+			case &quot;formatblock&quot;:
+				props.name = &quot;formatBlock&quot;;
+				props.values = this.formatBlockItems;
+				break;
+
+			case &quot;fontname&quot;:
+				props.name = &quot;fontName&quot;;
+				props.values = this.fontNameItems;
+
+			case &quot;fontsize&quot;:
+				props.name = &quot;fontSize&quot;;
+				props.values = this.fontSizeItems;
+		}
+		return props;
+	},
+
+	validateItems: true, // set to false to add items, regardless of support
+	focusOnLoad: true,
+	minHeight: &quot;1em&quot;,
+
+	_richText: null, // RichText widget
+	_richTextType: &quot;RichText&quot;,
+
+	_toolbarContainer: null, // ToolbarContainer widget
+	_toolbarContainerType: &quot;ToolbarContainer&quot;,
+
+	_toolbars: [],
+	_toolbarType: &quot;Toolbar&quot;,
+
+	_toolbarItemType: &quot;ToolbarItem&quot;,
+
+	buildRendering: function(args, frag) {
+		// get the node from args/frag
+		var node = frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()][&quot;nodeRef&quot;];
+		var trt = dojo.widget.createWidget(this._richTextType, {
+			focusOnLoad: this.focusOnLoad,
+			minHeight: this.minHeight
+		}, node)
+		var _this = this;
+		// this appears to fix a weird timing bug on Safari
+		setTimeout(function(){
+			_this.setRichText(trt);
+
+			_this.initToolbar();
+
+			_this.fillInTemplate(args, frag);
+		}, 0);
+	},
+
+	setRichText: function(richText) {
+		if(this._richText &amp;&amp; this._richText == richText) {
+			dojo.debug(&quot;Already set the richText to this richText!&quot;);
+			return;
+		}
+
+		if(this._richText &amp;&amp; !this._richText.isClosed) {
+			dojo.debug(&quot;You are switching richTexts yet you haven't closed the current one. Losing reference!&quot;);
+		}
+		this._richText = richText;
+		dojo.event.connect(this._richText, &quot;close&quot;, this, &quot;onClose&quot;);
+		dojo.event.connect(this._richText, &quot;onLoad&quot;, this, &quot;onLoad&quot;);
+		dojo.event.connect(this._richText, &quot;onDisplayChanged&quot;, this, &quot;updateToolbar&quot;);
+		if(this._toolbarContainer) {
+			this._toolbarContainer.enable();
+			this.updateToolbar(true);
+		}
+	},
+
+	initToolbar: function() {
+		// var tic = new Date();
+		if(this._toolbarContainer) { return; } // only create it once
+		this._toolbarContainer = dojo.widget.createWidget(this._toolbarContainerType);
+		var tb = this.addToolbar();
+		var last = true;
+		for(var i = 0; i &lt; this.items.length; i++) {
+			if(this.items[i] == &quot;\n&quot;) { // new row
+				tb = this.addToolbar();
+			} else {
+				if((this.items[i] == &quot;|&quot;)&amp;&amp;(!last)){
+					last = true;
+				}else{
+					last = this.addItem(this.items[i], tb);
+				}
+			}
+		}
+		this.insertToolbar(this._toolbarContainer.domNode, this._richText.domNode);
+		// alert(new Date - tic);
+	},
+
+	// allow people to override this so they can make their own placement logic
+	insertToolbar: function(tbNode, richTextNode) {
+		dojo.html.insertBefore(tbNode, richTextNode);
+		//dojo.html.insertBefore(this._toolbarContainer.domNode, this._richText.domNode);
+	},
+
+	addToolbar: function(toolbar) {
+		this.initToolbar();
+		if(!(toolbar instanceof dojo.widget.html.Toolbar)) {
+			toolbar = dojo.widget.createWidget(this._toolbarType);
+		}
+		this._toolbarContainer.addChild(toolbar);
+		this._toolbars.push(toolbar);
+		return toolbar;
+	},
+
+	addItem: function(item, tb, dontValidate) {
+		if(!tb) { tb = this._toolbars[0]; }
+		var cmd = ((item)&amp;&amp;(!dojo.lang.isUndefined(item[&quot;getValue&quot;]))) ?  cmd = item[&quot;getValue&quot;](): item;
+
+		var groups = dojo.widget.html.Editor.itemGroups;
+		if(item instanceof dojo.widget.ToolbarItem) {
+			tb.addChild(item);
+		} else if(groups[cmd]) {
+			var group = groups[cmd];
+			var worked = true;
+			if(cmd == &quot;justifyGroup&quot; || cmd == &quot;listGroup&quot;) {
+				var btnGroup = [cmd];
+				for(var i = 0 ; i &lt; group.length; i++) {
+					if(dontValidate || this.isSupportedCommand(group[i])) {
+						btnGroup.push(this.getCommandImage(group[i]));
+					}else{
+						worked = false;
+					}
+				}
+				if(btnGroup.length){
+					/*
+					// the addChild interface is assinine. Work around it.
+					var tprops = this.getItemProperties(cmd);
+					var tmpGroup = dojo.widget.createWidget(&quot;ToolbarButtonGroup&quot;, tprops);
+					dojo.debug(btnGroup);
+					dojo.event.connect(tmpGroup, &quot;onClick&quot;, this, &quot;_action&quot;);
+					dojo.event.connect(tmpGroup, &quot;onChangeSelect&quot;, this, &quot;_action&quot;);
+					*/
+					var btn = tb.addChild(btnGroup, null, this.getItemProperties(cmd));
+					dojo.event.connect(btn, &quot;onClick&quot;, this, &quot;_action&quot;);
+					dojo.event.connect(btn, &quot;onChangeSelect&quot;, this, &quot;_action&quot;);
+				}
+				return worked;
+			} else {
+				for(var i = 0; i &lt; group.length; i++) {
+					if(!this.addItem(group[i], tb)){
+						worked = false;
+					}
+				}
+				return worked;
+			}
+		} else {
+			if((!dontValidate)&amp;&amp;(!this.isSupportedCommand(cmd))){
+				return false;
+			}
+			if(dontValidate || this.isSupportedCommand(cmd)) {
+				cmd = cmd.toLowerCase();
+				if(cmd == &quot;formatblock&quot;) {
+					var select = dojo.widget.createWidget(&quot;ToolbarSelect&quot;, {
+						name: &quot;formatBlock&quot;,
+						values: this.formatBlockItems
+					});
+					tb.addChild(select);
+					var _this = this;
+					dojo.event.connect(select, &quot;onSetValue&quot;, function(item, value) {
+						_this.onAction(&quot;formatBlock&quot;, value);
+					});
+				} else if(cmd == &quot;fontname&quot;) {
+					var select = dojo.widget.createWidget(&quot;ToolbarSelect&quot;, {
+						name: &quot;fontName&quot;,
+						values: this.fontNameItems
+					});
+					tb.addChild(select);
+					dojo.event.connect(select, &quot;onSetValue&quot;, dojo.lang.hitch(this, function(item, value) {
+						this.onAction(&quot;fontName&quot;, value);
+					}));
+				} else if(cmd == &quot;fontsize&quot;) {
+					var select = dojo.widget.createWidget(&quot;ToolbarSelect&quot;, {
+						name: &quot;fontSize&quot;,
+						values: this.fontSizeItems
+					});
+					tb.addChild(select);
+					dojo.event.connect(select, &quot;onSetValue&quot;, dojo.lang.hitch(this, function(item, value) {
+						this.onAction(&quot;fontSize&quot;, value);
+					}));
+				} else if(dojo.lang.inArray(cmd, [&quot;forecolor&quot;, &quot;hilitecolor&quot;])) {
+					var btn = tb.addChild(dojo.widget.createWidget(&quot;ToolbarColorDialog&quot;, this.getItemProperties(cmd)));
+					dojo.event.connect(btn, &quot;onSetValue&quot;, this, &quot;_setValue&quot;);
+				} else {
+					var btn = tb.addChild(this.getCommandImage(cmd), null, this.getItemProperties(cmd));
+					if(cmd == &quot;save&quot;){
+						dojo.event.connect(btn, &quot;onClick&quot;, this, &quot;_save&quot;);
+					}else if(cmd == &quot;cancel&quot;){
+						dojo.event.connect(btn, &quot;onClick&quot;, this, &quot;_close&quot;);
+					} else {
+						dojo.event.connect(btn, &quot;onClick&quot;, this, &quot;_action&quot;);
+						dojo.event.connect(btn, &quot;onChangeSelect&quot;, this, &quot;_action&quot;);
+					}
+				}
+			}
+		}
+		return true;
+	},
+
+	enableToolbar: function() {
+		if(this._toolbarContainer) {
+			this._toolbarContainer.domNode.style.display = &quot;&quot;;
+			this._toolbarContainer.enable();
+		}
+	},
+
+	disableToolbar: function(hide){
+		if(hide){
+			if(this._toolbarContainer){
+				this._toolbarContainer.domNode.style.display = &quot;none&quot;;
+			}
+		}else{
+			if(this._toolbarContainer){
+				this._toolbarContainer.disable();
+			}
+		}
+	},
+
+	_updateToolbarLastRan: null,
+	_updateToolbarTimer: null,
+	_updateToolbarFrequency: 500,
+
+	updateToolbar: function(force) {
+		if(!this._toolbarContainer) { return; }
+
+		// keeps the toolbar from updating too frequently
+		// TODO: generalize this functionality?
+		var diff = new Date() - this._updateToolbarLastRan;
+		if(!force &amp;&amp; this._updateToolbarLastRan &amp;&amp; (diff &lt; this._updateToolbarFrequency)) {
+			clearTimeout(this._updateToolbarTimer);
+			var _this = this;
+			this._updateToolbarTimer = setTimeout(function() {
+				_this.updateToolbar();
+			}, this._updateToolbarFrequency/2);
+			return;
+		} else {
+			this._updateToolbarLastRan = new Date();
+		}
+		// end frequency checker
+
+		var items = this._toolbarContainer.getItems();
+		for(var i = 0; i &lt; items.length; i++) {
+			var item = items[i];
+			if(item instanceof dojo.widget.html.ToolbarSeparator) { continue; }
+			var cmd = item._name;
+			if (cmd == &quot;save&quot; || cmd == &quot;cancel&quot;) { continue; }
+			else if(cmd == &quot;justifyGroup&quot;) {
+				try {
+					if(!this._richText.queryCommandEnabled(&quot;justifyleft&quot;)) {
+						item.disable(false, true);
+					} else {
+						item.enable(false, true);
+						var jitems = item.getItems();
+						for(var j = 0; j &lt; jitems.length; j++) {
+							var name = jitems[j]._name;
+							var value = this._richText.queryCommandValue(name);
+							if(typeof value == &quot;boolean&quot; &amp;&amp; value) {
+								value = name;
+								break;
+							} else if(typeof value == &quot;string&quot;) {
+								value = &quot;justify&quot;+value;
+							} else {
+								value = null;
+							}
+						}
+						if(!value) { value = &quot;justifyleft&quot;; } // TODO: query actual style
+						item.setValue(value, false, true);
+					}
+				} catch(err) {}
+			} else if(cmd == &quot;listGroup&quot;) {
+				var litems = item.getItems();
+				for(var j = 0; j &lt; litems.length; j++) {
+					this.updateItem(litems[j]);
+				}
+			} else {
+				this.updateItem(item);
+			}
+		}
+	},
+
+	updateItem: function(item) {
+		try {
+			var cmd = item._name;
+			var enabled = this._richText.queryCommandEnabled(cmd);
+			item.setEnabled(enabled, false, true);
+
+			var active = this._richText.queryCommandState(cmd);
+			if(active &amp;&amp; cmd == &quot;underline&quot;) {
+				// don't activate underlining if we are on a link
+				active = !this._richText.queryCommandEnabled(&quot;unlink&quot;);
+			}
+			item.setSelected(active, false, true);
+			return true;
+		} catch(err) {
+			return false;
+		}
+	},
+
+	supportedCommands: dojo.widget.html.Editor.supportedCommands.concat(),
+
+	isSupportedCommand: function(cmd) {
+		// FIXME: how do we check for ActiveX?
+		var yes = dojo.lang.inArray(cmd, this.supportedCommands);
+		if(!yes) {
+			try {
+				var richText = this._richText || dojo.widget.HtmlRichText.prototype;
+				yes = richText.queryCommandAvailable(cmd);
+			} catch(E) {}
+		}
+		return yes;
+	},
+
+	getCommandImage: function(cmd) {
+		if(cmd == &quot;|&quot;) {
+			return cmd;
+		} else {
+			return dojo.uri.dojoUri(&quot;src/widget/templates/buttons/&quot; + cmd + &quot;.gif&quot;);
+		}
+	},
+
+	_action: function(e) {
+		this._fire(&quot;onAction&quot;, e.getValue());
+	},
+
+	_setValue: function(a, b) {
+		this._fire(&quot;onAction&quot;, a.getValue(), b);
+	},
+
+	_save: function(e){
+		// FIXME: how should this behave when there's a larger form in play?
+		if(!this._richText.isClosed){
+			if(this.saveUrl.length){
+				var content = {};
+				content[this.saveArgName] = this.getHtml();
+				dojo.io.bind({
+					method: this.saveMethod,
+					url: this.saveUrl,
+					content: content
+				});
+			}else{
+				dojo.debug(&quot;please set a saveUrl for the editor&quot;);
+			}
+			if(this.closeOnSave){
+				this._richText.close(e.getName().toLowerCase() == &quot;save&quot;);
+			}
+		}
+	},
+
+	_close: function(e) {
+		if(!this._richText.isClosed) {
+			this._richText.close(e.getName().toLowerCase() == &quot;save&quot;);
+		}
+	},
+
+	onAction: function(cmd, value) {
+		switch(cmd) {
+			case &quot;createlink&quot;:
+				if(!(value = prompt(&quot;Please enter the URL of the link:&quot;, &quot;<A HREF="http://">http://</A>&quot;))) {
+					return;
+				}
+				break;
+			case &quot;insertimage&quot;:
+				if(!(value = prompt(&quot;Please enter the URL of the image:&quot;, &quot;<A HREF="http://">http://</A>&quot;))) {
+					return;
+				}
+				break;
+		}
+		this._richText.execCommand(cmd, value);
+	},
+
+	fillInTemplate: function(args, frag) {
+		// dojo.event.connect(this, &quot;onResized&quot;, this._richText, &quot;onResized&quot;);
+	},
+
+	_fire: function(eventName) {
+		if(dojo.lang.isFunction(this[eventName])) {
+			var args = [];
+			if(arguments.length == 1) {
+				args.push(this);
+			} else {
+				for(var i = 1; i &lt; arguments.length; i++) {
+					args.push(arguments[i]);
+				}
+			}
+			this[eventName].apply(this, args);
+		}
+	},
+
+	getHtml: function(){
+		this._richText.contentFilters = this._richText.contentFilters.concat(this.contentFilters);
+		return this._richText.getEditorContent();
+	},
+
+	getEditorContent: function(){
+		return this.getHtml();
+	},
+
+	onClose: function(save, hide){
+		this.disableToolbar(hide);
+		if(save) {
+			this._fire(&quot;onSave&quot;);
+		} else {
+			this._fire(&quot;onCancel&quot;);
+		}
+	},
+
+	// events baby!
+	onLoad: function(){},
+	onSave: function(){},
+	onCancel: function(){}
+});
+

Added: trunk/root/static/magic/src/widget/Editor2.js
===================================================================
--- trunk/root/static/magic/src/widget/Editor2.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Editor2.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,395 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/* TODO:
+ * - font selector
+ * - test, bug fix, more features :)
+*/
+dojo.provide(&quot;dojo.widget.Editor2&quot;);
+dojo.provide(&quot;dojo.widget.html.Editor2&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.RichText&quot;);
+dojo.require(&quot;dojo.widget.Editor2Toolbar&quot;);
+// dojo.require(&quot;dojo.widget.ColorPalette&quot;);
+// dojo.require(&quot;dojo.string.extras&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Editor2&quot;,
+	dojo.widget.html.RichText,
+	{
+		saveUrl: &quot;&quot;,
+		saveMethod: &quot;post&quot;,
+		saveArgName: &quot;editorContent&quot;,
+		closeOnSave: false,
+		shareToolbar: false,
+		toolbarAlwaysVisible: false,
+		htmlEditing: false,
+		_inHtmlMode: false,
+		_htmlEditNode: null,
+
+		commandList: dojo.widget.html.Editor2Toolbar.prototype.commandList,
+		toolbarWidget: null,
+		scrollInterval: null,
+		
+
+		editorOnLoad: function(){
+			var toolbars = dojo.widget.byType(&quot;Editor2Toolbar&quot;);
+			if((!toolbars.length)||(!this.shareToolbar)){
+				var tbOpts = {};
+				tbOpts.templatePath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlEditorToolbarOneline.html&quot;);
+				this.toolbarWidget = dojo.widget.createWidget(&quot;Editor2Toolbar&quot;, 
+										tbOpts, this.domNode, &quot;before&quot;);
+				dojo.event.connect(this, &quot;destroy&quot;, this.toolbarWidget, &quot;destroy&quot;);
+				this.toolbarWidget.hideUnusableButtons(this);
+
+				if(this.object){
+					this.tbBgIframe = new dojo.html.BackgroundIframe(this.toolbarWidget.domNode);
+					this.tbBgIframe.iframe.style.height = &quot;30px&quot;;
+				}
+
+				// need to set position fixed to wherever this thing has landed
+				if(this.toolbarAlwaysVisible){
+					var src = document[&quot;documentElement&quot;]||window;
+					this.scrollInterval = setInterval(dojo.lang.hitch(this, &quot;globalOnScrollHandler&quot;), 100);
+					// dojo.event.connect(src, &quot;onscroll&quot;, this, &quot;globalOnScrollHandler&quot;);
+					dojo.event.connect(&quot;before&quot;, this, &quot;destroyRendering&quot;, this, &quot;unhookScroller&quot;);
+				}
+			}else{
+				// FIXME: 	should we try harder to explicitly manage focus in
+				// 			order to prevent too many editors from all querying
+				// 			for button status concurrently?
+				// FIXME: 	selecting in one shared toolbar doesn't clobber
+				// 			selection in the others. This is problematic.
+				this.toolbarWidget = toolbars[0];
+			}
+			dojo.event.topic.registerPublisher(&quot;Editor2.clobberFocus&quot;, this.editNode, &quot;onfocus&quot;);
+			// dojo.event.topic.registerPublisher(&quot;Editor2.clobberFocus&quot;, this.editNode, &quot;onclick&quot;);
+			dojo.event.topic.subscribe(&quot;Editor2.clobberFocus&quot;, this, &quot;setBlur&quot;);
+			dojo.event.connect(this.editNode, &quot;onfocus&quot;, this, &quot;setFocus&quot;);
+			dojo.event.connect(this.toolbarWidget.linkButton, &quot;onclick&quot;, 
+				dojo.lang.hitch(this, function(){
+					var range;
+					if(this.document.selection){
+						range = this.document.selection.createRange().text;
+					}else if(dojo.render.html.mozilla){
+						range = this.window.getSelection().toString();
+					}
+					if(range.length){
+						this.toolbarWidget.exec(&quot;createlink&quot;, 
+							prompt(&quot;Please enter the URL of the link:&quot;, &quot;<A HREF="http://">http://</A>&quot;));
+					}else{
+						alert(&quot;Please select text to link&quot;);
+					}
+				})
+			);
+
+			var focusFunc = dojo.lang.hitch(this, function(){ 
+				if(dojo.render.html.ie){
+					this.editNode.focus();
+				}else{
+					this.window.focus(); 
+				}
+			});
+
+			dojo.event.connect(this.toolbarWidget, &quot;formatSelectClick&quot;, focusFunc);
+			dojo.event.connect(this, &quot;execCommand&quot;, focusFunc);
+
+			if(this.htmlEditing){
+				var tb = this.toolbarWidget.htmltoggleButton;
+				if(tb){
+					tb.style.display = &quot;&quot;;
+					dojo.event.connect(this.toolbarWidget, &quot;htmltoggleClick&quot;,
+										this, &quot;toggleHtmlEditing&quot;);
+				}
+			}
+		},
+
+		toggleHtmlEditing: function(){
+			if(!this._inHtmlMode){
+				this._inHtmlMode = true;
+				this.toolbarWidget.highlightButton(&quot;htmltoggle&quot;);
+				if(!this._htmlEditNode){
+					this._htmlEditNode = document.createElement(&quot;textarea&quot;);
+					dojo.html.insertBefore(this._htmlEditNode, this.domNode);
+				}
+				this._htmlEditNode.style.display = &quot;&quot;;
+				this._htmlEditNode.style.width = &quot;100%&quot;;
+				this._htmlEditNode.style.height = dojo.style.getInnerHeight(this.editNode)+&quot;px&quot;;
+				this._htmlEditNode.value = this.editNode.innerHTML;
+				this.domNode.style.display = &quot;none&quot;;
+			}else{
+				this._inHtmlMode = false;
+				this.domNode.style.display = &quot;&quot;;
+				this.toolbarWidget.unhighlightButton(&quot;htmltoggle&quot;);
+				dojo.lang.setTimeout(this, &quot;replaceEditorContent&quot;, 1, this._htmlEditNode.value);
+				this._htmlEditNode.style.display = &quot;none&quot;;
+				this.editNode.focus();
+			}
+		},
+
+		setFocus: function(){
+			// dojo.debug(&quot;setFocus:&quot;, this);
+			dojo.event.connect(this.toolbarWidget, &quot;exec&quot;, this, &quot;execCommand&quot;);
+		},
+
+		setBlur: function(){
+			// dojo.debug(&quot;setBlur:&quot;, this);
+			dojo.event.disconnect(this.toolbarWidget, &quot;exec&quot;, this, &quot;execCommand&quot;);
+		},
+
+		_scrollSetUp: false,
+		_fixEnabled: false,
+		_scrollThreshold: false,
+		_handleScroll: true,
+		globalOnScrollHandler: function(){
+			var isIE = dojo.render.html.ie;
+			if(!this._handleScroll){ return; }
+			var ds = dojo.style;
+			var tdn = this.toolbarWidget.domNode;
+			var db = document[&quot;body&quot;];
+			var totalHeight = ds.getOuterHeight(tdn);
+			if(!this._scrollSetUp){
+				this._scrollSetUp = true;
+				var editorWidth =  ds.getOuterWidth(this.domNode); 
+				this._scrollThreshold = ds.abs(tdn, false).y;
+				// dojo.debug(&quot;threshold:&quot;, this._scrollThreshold);
+				if((isIE)&amp;&amp;(db)&amp;&amp;(ds.getStyle(db, &quot;background-image&quot;)==&quot;none&quot;)){
+					with(db.style){
+						backgroundImage = &quot;url(&quot; + dojo.uri.dojoUri(&quot;src/widget/templates/images/blank.gif&quot;) + &quot;)&quot;;
+						backgroundAttachment = &quot;fixed&quot;;
+					}
+				}
+			}
+
+			var scrollPos = (window[&quot;pageYOffset&quot;]) ? window[&quot;pageYOffset&quot;] : (document[&quot;documentElement&quot;]||document[&quot;body&quot;]).scrollTop;
+
+			// FIXME: need to have top and bottom thresholds so toolbar doesn't keep scrolling past the bottom
+			if(scrollPos &gt; this._scrollThreshold){
+				// dojo.debug(scrollPos);
+				if(!this._fixEnabled){
+					this.domNode.style.marginTop = totalHeight+&quot;px&quot;;
+					if(isIE){
+						// FIXME: should we just use setBehvior() here instead?
+						var cl = dojo.style.abs(tdn).x;
+						document.body.appendChild(tdn);
+						tdn.style.left = cl+dojo.style.getPixelValue(document.body, &quot;margin-left&quot;)+&quot;px&quot;;
+						dojo.html.addClass(tdn, &quot;IEFixedToolbar&quot;);
+						if(this.object){
+							dojo.html.addClass(this.tbBgIframe, &quot;IEFixedToolbar&quot;);
+						}
+						
+					}else{
+						with(tdn.style){
+							position = &quot;fixed&quot;;
+							top = &quot;0px&quot;;
+						}
+					}
+					tdn.style.zIndex = 1000;
+					this._fixEnabled = true;
+				}
+				// if we're showing the floating toolbar, make sure that if
+				// we've scrolled past the bottom of the editor that we hide
+				// the toolbar for this instance of the editor.
+
+				// TODO: when we get multiple editor toolbar support working
+				// correctly, ensure that we check this against the scroll
+				// position of the bottom-most editor instance.
+				if(!dojo.render.html.safari){
+					// safari reports a bunch of things incorrectly here
+					var eHeight = (this.height) ? parseInt(this.height) : ((this.object) ? dojo.style.getInnerHeight(this.editNode) : this._lastHeight);
+					if(scrollPos &gt; (this._scrollThreshold+eHeight)){
+						tdn.style.display = &quot;none&quot;;
+					}else{
+						tdn.style.display = &quot;&quot;;
+					}
+				}
+
+			}else if(this._fixEnabled){
+				this.domNode.style.marginTop = null;
+				with(tdn.style){
+					position = &quot;&quot;;
+					top = &quot;&quot;;
+					zIndex = &quot;&quot;;
+					if(isIE){
+						marginTop = &quot;&quot;;
+					}
+				}
+				if(isIE){
+					dojo.html.removeClass(tdn, &quot;IEFixedToolbar&quot;);
+					dojo.html.insertBefore(tdn, this._htmlEditNode||this.domNode);
+				}
+				this._fixEnabled = false;
+			}
+		},
+
+		unhookScroller: function(){
+			this._handleScroll = false;
+			clearInterval(this.scrollInterval);
+			// var src = document[&quot;documentElement&quot;]||window;
+			// dojo.event.disconnect(src, &quot;onscroll&quot;, this, &quot;globalOnScrollHandler&quot;);
+			if(dojo.render.html.ie){
+				dojo.html.removeClass(this.toolbarWidget.domNode, &quot;IEFixedToolbar&quot;);
+			}
+		},
+
+		_updateToolbarLastRan: null,
+		_updateToolbarTimer: null,
+		_updateToolbarFrequency: 500,
+
+		updateToolbar: function(force){
+			if((!this.isLoaded)||(!this.toolbarWidget)){ return; }
+
+			// keeps the toolbar from updating too frequently
+			// TODO: generalize this functionality?
+			var diff = new Date() - this._updateToolbarLastRan;
+			if( (!force)&amp;&amp;(this._updateToolbarLastRan)&amp;&amp;
+				((diff &lt; this._updateToolbarFrequency)) ){
+
+				clearTimeout(this._updateToolbarTimer);
+				var _this = this;
+				this._updateToolbarTimer = setTimeout(function() {
+					_this.updateToolbar();
+				}, this._updateToolbarFrequency/2);
+				return;
+
+			}else{
+				this._updateToolbarLastRan = new Date();
+			}
+			// end frequency checker
+
+			dojo.lang.forEach(this.commandList, function(cmd){
+					if(cmd == &quot;inserthtml&quot;){ return; }
+					try{
+						if(this.queryCommandEnabled(cmd)){
+							if(this.queryCommandState(cmd)){
+								this.toolbarWidget.highlightButton(cmd);
+							}else{
+								this.toolbarWidget.unhighlightButton(cmd);
+							}
+						}
+					}catch(e){
+						// alert(cmd+&quot;:&quot;+e);
+					}
+				}, this);
+
+			var h = dojo.render.html;
+			
+			// safari f's us for selection primitives
+			if(h.safari){ return; }
+
+			var selectedNode = (h.ie) ? this.document.selection.createRange().parentElement() : this.window.getSelection().anchorNode;
+			// make sure we actuall have an element
+			while((selectedNode)&amp;&amp;(selectedNode.nodeType != 1)){
+				selectedNode = selectedNode.parentNode;
+			}
+			if(!selectedNode){ return; }
+
+			var formats = [&quot;p&quot;, &quot;pre&quot;, &quot;h1&quot;, &quot;h2&quot;, &quot;h3&quot;, &quot;h4&quot;];
+			// gotta run some specialized updates for the various
+			// formatting options
+			var type = formats[dojo.lang.find(formats, selectedNode.nodeName.toLowerCase())];
+			while((selectedNode)&amp;&amp;(selectedNode!=this.editNode)&amp;&amp;(!type)){
+				selectedNode = selectedNode.parentNode;
+				type = formats[dojo.lang.find(formats, selectedNode.nodeName.toLowerCase())];
+			}
+			if(!type){
+				type = &quot;&quot;;
+			}else{
+				if(type.charAt(0)==&quot;h&quot;){
+					this.toolbarWidget.unhighlightButton(&quot;bold&quot;);
+				}
+			}
+			this.toolbarWidget.selectFormat(type);
+		},
+
+		updateItem: function(item) {
+			try {
+				var cmd = item._name;
+				var enabled = this._richText.queryCommandEnabled(cmd);
+				item.setEnabled(enabled, false, true);
+
+				var active = this._richText.queryCommandState(cmd);
+				if(active &amp;&amp; cmd == &quot;underline&quot;) {
+					// don't activate underlining if we are on a link
+					active = !this._richText.queryCommandEnabled(&quot;unlink&quot;);
+				}
+				item.setSelected(active, false, true);
+				return true;
+			} catch(err) {
+				return false;
+			}
+		},
+
+
+		_save: function(e){
+			// FIXME: how should this behave when there's a larger form in play?
+			if(!this.isClosed){
+				if(this.saveUrl.length){
+					var content = {};
+					content[this.saveArgName] = this.getHtml();
+					dojo.io.bind({
+						method: this.saveMethod,
+						url: this.saveUrl,
+						content: content
+					});
+				}else{
+					dojo.debug(&quot;please set a saveUrl for the editor&quot;);
+				}
+				if(this.closeOnSave){
+					this.close(e.getName().toLowerCase() == &quot;save&quot;);
+				}
+			}
+		},
+
+		wireUpOnLoad: function(){
+			if(!dojo.render.html.ie){
+				/*
+				dojo.event.kwConnect({
+					srcObj:		this.document,
+					srcFunc:	&quot;click&quot;, 
+					targetObj:	this.toolbarWidget,
+					targetFunc:	&quot;hideAllDropDowns&quot;,
+					once:		true
+				});
+				*/
+			}
+		}
+	},
+	&quot;html&quot;,
+	function(){
+		var cp = dojo.widget.html.Editor2.prototype;
+		if(!cp._wrappersSet){
+			cp._wrappersSet = true;
+			cp.fillInTemplate = (function(fit){
+				return function(){
+					fit.call(this);
+					this.editorOnLoad();
+				};
+			})(cp.fillInTemplate);
+		
+			cp.onDisplayChanged = (function(odc){
+				return function(){
+					try{
+						odc.call(this);
+						this.updateToolbar();
+					}catch(e){}
+				};
+			})(cp.onDisplayChanged);
+
+			cp.onLoad = (function(ol){
+				return function(){
+					ol.call(this);
+					this.wireUpOnLoad();
+				};
+			})(cp.onLoad);
+		}
+	}
+);

Added: trunk/root/static/magic/src/widget/Editor2Toolbar.js
===================================================================
--- trunk/root/static/magic/src/widget/Editor2Toolbar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Editor2Toolbar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,319 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Editor2Toolbar&quot;);
+dojo.provide(&quot;dojo.widget.html.Editor2Toolbar&quot;);
+
+dojo.require(&quot;dojo.lang.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.RichText&quot;);
+dojo.require(&quot;dojo.widget.ColorPalette&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Editor2Toolbar&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		commandList: [ &quot;bold&quot;, &quot;italic&quot;, &quot;underline&quot;, &quot;subscript&quot;, &quot;superscript&quot;,
+			&quot;fontname&quot;, &quot;fontsize&quot;, &quot;forecolor&quot;, &quot;hilitecolor&quot;, &quot;justifycenter&quot;,
+			&quot;justifyfull&quot;, &quot;justifyleft&quot;, &quot;justifyright&quot;, &quot;cut&quot;, &quot;copy&quot;, &quot;paste&quot;,
+			&quot;delete&quot;, &quot;undo&quot;, &quot;redo&quot;, &quot;createlink&quot;, &quot;unlink&quot;, &quot;removeformat&quot;,
+			&quot;inserthorizontalrule&quot;, &quot;insertimage&quot;, &quot;insertorderedlist&quot;,
+			&quot;insertunorderedlist&quot;, &quot;indent&quot;, &quot;outdent&quot;, &quot;formatblock&quot;, &quot;strikethrough&quot;, 
+			&quot;inserthtml&quot;, &quot;blockdirltr&quot;, &quot;blockdirrtl&quot;, &quot;dirltr&quot;, &quot;dirrtl&quot;,
+			&quot;inlinedirltr&quot;, &quot;inlinedirrtl&quot;, &quot;inserttable&quot;, &quot;insertcell&quot;,
+			&quot;insertcol&quot;, &quot;insertrow&quot;, &quot;deletecells&quot;, &quot;deletecols&quot;, &quot;deleterows&quot;,
+			&quot;mergecells&quot;, &quot;splitcell&quot;
+		],
+
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlEditorToolbar.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlEditorToolbar.css&quot;),
+
+		forecolorPalette: null,
+		hilitecolorPalette: null,
+
+		// DOM Nodes
+		wikiwordButton: null,
+		htmltoggleButton: null,
+		insertimageButton: null,
+		styleDropdownButton: null,
+		styleDropdownContainer: null,
+		copyButton: null,
+		boldButton: null,
+		italicButton: null,
+		underlineButton: null,
+		justifycenterButton: null,
+		justifyleftButton: null,
+		justifyfullButton: null,
+		justifyrightButton: null,
+		pasteButton: null,
+		undoButton: null,
+		redoButton: null,
+		linkButton: null,
+		insertunorderedlistButton: null,
+		insertorderedlistButton: null,
+		forecolorButton: null,
+		forecolorDropDown: null,
+		hilitecolorButton: null,
+		hilitecolorDropDown: null,
+		formatSelectBox: null,
+		inserthorizontalruleButton: null,
+		strikethroughButton: null,
+		clickInterceptDiv: null,
+		oneLineTr: null,
+
+		buttonClick: function(e){ e.preventDefault(); /* dojo.debug(&quot;buttonClick&quot;); */ },
+
+		buttonMouseOver: function(e){  },
+		buttonMouseOut: function(e){  },
+
+
+		// event signals
+		preventSelect: function(e){ if(dojo.render.html.safari){ e.preventDefault(); } },
+		wikiwordClick: function(){ },
+		insertimageClick: function(){ },
+		htmltoggleClick: function(){ },
+
+		styleDropdownClick: function(){
+			dojo.debug(&quot;styleDropdownClick:&quot;, this.styleDropdownContainer);
+			dojo.style.toggleShowing(this.styleDropdownContainer);
+		},
+
+
+		copyClick: function(){ this.exec(&quot;copy&quot;); },
+		boldClick: function(){ this.exec(&quot;bold&quot;); },
+		italicClick: function(){ this.exec(&quot;italic&quot;); },
+		underlineClick: function(){ this.exec(&quot;underline&quot;); },
+		justifyleftClick: function(){ this.exec(&quot;justifyleft&quot;); },
+		justifycenterClick: function(){ this.exec(&quot;justifycenter&quot;); },
+		justifyfullClick: function(){ this.exec(&quot;justifyfull&quot;); },
+		justifyrightClick: function(){ this.exec(&quot;justifyright&quot;); },
+		pasteClick: function(){ this.exec(&quot;paste&quot;); },
+		undoClick: function(){ this.exec(&quot;undo&quot;); },
+		redoClick: function(){ this.exec(&quot;redo&quot;); },
+		linkClick: function(){ 
+			// FIXME: we need to alert the user if they haven't selected any text
+			// this.exec(	&quot;createlink&quot;, 
+			// 			prompt(&quot;Please enter the URL of the link:&quot;, &quot;<A HREF="http://">http://</A>&quot;));
+		},
+		insertunorderedlistClick: function(){ this.exec(&quot;insertunorderedlist&quot;); },
+		insertorderedlistClick: function(){ this.exec(&quot;insertorderedlist&quot;); },
+		inserthorizontalruleClick: function(){ this.exec(&quot;inserthorizontalrule&quot;); },
+		strikethroughClick: function(){ this.exec(&quot;strikethrough&quot;); },
+
+		formatSelectClick: function(){ 
+			var sv = this.formatSelectBox.value.toLowerCase();
+			this.exec(&quot;formatblock&quot;, sv);
+		},
+
+		normalTextClick: function(){ this.exec(&quot;formatblock&quot;, &quot;p&quot;); },
+		h1TextClick: function(){ this.exec(&quot;formatblock&quot;, &quot;h1&quot;); },
+		h2TextClick: function(){ this.exec(&quot;formatblock&quot;, &quot;h2&quot;); },
+		h3TextClick: function(){ this.exec(&quot;formatblock&quot;, &quot;h3&quot;); },
+		h4TextClick: function(){ this.exec(&quot;formatblock&quot;, &quot;h4&quot;); },
+		indentClick: function(){ this.exec(&quot;indent&quot;); },
+		outdentClick: function(){ this.exec(&quot;outdent&quot;); },
+
+
+		hideAllDropDowns: function(){
+			this.domNode.style.height = &quot;&quot;;
+			dojo.lang.forEach(dojo.widget.byType(&quot;Editor2Toolbar&quot;), function(tb){
+				try{
+					dojo.style.hide(tb.forecolorDropDown);
+					dojo.style.hide(tb.hilitecolorDropDown);
+					dojo.style.hide(tb.styleDropdownContainer);
+					if(tb.clickInterceptDiv){
+						dojo.style.hide(tb.clickInterceptDiv);
+					}
+				}catch(e){}
+				if(dojo.render.html.ie){
+					try{
+						dojo.style.hide(tb.forecolorPalette.bgIframe);
+					}catch(e){}
+					try{
+						dojo.style.hide(tb.hilitecolorPalette.bgIframe);
+					}catch(e){}
+				}
+			});
+		},
+
+		selectFormat: function(format){
+			dojo.lang.forEach(this.formatSelectBox.options, function(item){
+				if(item.value.toLowerCase() == format.toLowerCase()){
+					item.selected = true;
+				}
+			});
+		},
+
+		forecolorClick: function(e){
+			this.colorClick(e, &quot;forecolor&quot;);
+		},
+
+		hilitecolorClick: function(e){
+			this.colorClick(e, &quot;hilitecolor&quot;);
+		},
+
+		// FIXME: these methods aren't currently dealing with clicking in the
+		// general document to hide the menu
+		colorClick: function(e, type){
+			var h = dojo.render.html;
+			this.hideAllDropDowns();
+			// FIXME: if we've been &quot;popped out&quot;, we need to set the height of the toolbar.
+			e.stopPropagation();
+			var dd = this[type+&quot;DropDown&quot;];
+			var pal = this[type+&quot;Palette&quot;];
+			dojo.style.toggleShowing(dd);
+			if(!pal){
+				pal = this[type+&quot;Palette&quot;] = dojo.widget.createWidget(&quot;ColorPalette&quot;, {}, dd, &quot;first&quot;);
+				var fcp = pal.domNode;
+				with(dd.style){
+					width = dojo.html.getOuterWidth(fcp) + &quot;px&quot;;
+					height = dojo.html.getOuterHeight(fcp) + &quot;px&quot;;
+					zIndex = 1002;
+					position = &quot;absolute&quot;;
+				}
+
+				dojo.event.connect(	&quot;after&quot;,
+									pal, &quot;onColorSelect&quot;,
+									this, &quot;exec&quot;,
+									function(mi){ mi.args.unshift(type); return mi.proceed(); }
+				);
+
+				dojo.event.connect(	&quot;after&quot;,
+									pal, &quot;onColorSelect&quot;,
+									dojo.style, &quot;toggleShowing&quot;,
+									this, function(mi){ mi.args.unshift(dd); return mi.proceed(); }
+				);
+
+				var cid = this.clickInterceptDiv;
+				if(!cid){
+					cid = this.clickInterceptDiv = document.createElement(&quot;div&quot;);
+					document.body.appendChild(cid);
+					with(cid.style){
+						backgroundColor = &quot;transparent&quot;;
+						top = left = &quot;0px&quot;;
+						height = width = &quot;100%&quot;;
+						position = &quot;absolute&quot;;
+						border = &quot;none&quot;;
+						display = &quot;none&quot;;
+						zIndex = 1001;
+					}
+					dojo.event.connect(cid, &quot;onclick&quot;, function(){ cid.style.display = &quot;none&quot;; });
+				}
+				dojo.event.connect(pal, &quot;onColorSelect&quot;, function(){ cid.style.display = &quot;none&quot;; });
+
+				dojo.event.kwConnect({
+					srcObj:		document.body, 
+					srcFunc:	&quot;onclick&quot;, 
+					targetObj:	this,
+					targetFunc:	&quot;hideAllDropDowns&quot;,
+					once:		true
+				});
+				document.body.appendChild(dd);
+			}
+			dojo.style.toggleShowing(this.clickInterceptDiv);
+			var pos = dojo.style.abs(this[type+&quot;Button&quot;]);
+			dojo.html.placeOnScreenPoint(dd, pos.x, pos.y, 0, false);
+			if(pal.bgIframe){
+				with(pal.bgIframe.style){
+					display = &quot;block&quot;;
+					left = dd.style.left;
+					top = dd.style.top;
+					width = dojo.style.getOuterWidth(dd)+&quot;px&quot;;
+					height = dojo.style.getOuterHeight(dd)+&quot;px&quot;;
+				}
+			}
+		},
+
+		uninitialize: function(){
+			if(!dojo.render.html.ie){
+				// apparently this causes leakage on IE!
+				dojo.event.kwDisconnect({
+					srcObj:		document.body, 
+					srcFunc:	&quot;onclick&quot;, 
+					targetObj:	this,
+					targetFunc:	&quot;hideAllDropDowns&quot;,
+					once:		true
+				});
+			}
+		},
+
+		// stub for observers
+		exec: function(what, arg){ /* dojo.debug(what, new Date()); */ },
+
+		hideUnusableButtons: function(obj){
+			var op = obj||dojo.widget.html.RichText.prototype;
+			dojo.lang.forEach(this.commandList,
+				function(cmd){
+					if(this[cmd+&quot;Button&quot;]){
+						var cb = this[cmd+&quot;Button&quot;];
+						if(!op.queryCommandAvailable(cmd)){
+							cb.style.display = &quot;none&quot;;
+							cb.parentNode.style.display = &quot;none&quot;;
+						}
+					}
+				},
+				this);
+				if(this.oneLineTr){
+					var lastVisibleIsSpacer = false;
+					var lastVisible = false;
+					var tds = this.oneLineTr.getElementsByTagName(&quot;td&quot;);
+					dojo.lang.forEach(tds, function(td){
+						if(td.getAttribute(&quot;isSpacer&quot;)){
+							if(td.style.display != &quot;none&quot;){
+								if(lastVisibleIsSpacer){
+									td.style.display = &quot;none&quot;;
+								}
+								lastVisibleIsSpacer = true;
+							}else{
+								lastVisible = td;
+								lastVisibleIsSpacer = true;
+							}
+						}else{
+							if(td.style.display != &quot;none&quot;){
+								lastVisible = td;
+								lastVisibleIsSpacer = false;
+							}
+						}
+					});
+				}
+		},
+
+		highlightButton: function(name){
+			var bn = name+&quot;Button&quot;;
+			if(this[bn]){
+				with(this[bn].style){
+					backgroundColor = &quot;White&quot;;
+					border = &quot;1px solid #aeaeab&quot;;
+				}
+			}
+		},
+
+		unhighlightButton: function(name){
+			var bn = name+&quot;Button&quot;;
+			if(this[bn]){
+				// dojo.debug(&quot;unhighlighting:&quot;, name);
+				with(this[bn].style){
+					backgroundColor = &quot;&quot;;
+					border = &quot;&quot;;
+				}
+			}
+		}
+	},
+	&quot;html&quot;,
+	function(){
+		// dojo.event.connect(this, &quot;fillInTemplate&quot;, this, &quot;hideUnusableButtons&quot;);
+		dojo.event.connect(this, &quot;fillInTemplate&quot;, dojo.lang.hitch(this, function(){
+			if(dojo.render.html.ie){
+				this.domNode.style.zoom = 1.0;
+			}
+		}));
+	}
+);

Added: trunk/root/static/magic/src/widget/FisheyeList.js
===================================================================
--- trunk/root/static/magic/src/widget/FisheyeList.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/FisheyeList.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,743 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.FisheyeList&quot;);
+dojo.provide(&quot;dojo.widget.html.FisheyeList&quot;);
+dojo.provide(&quot;dojo.widget.html.FisheyeListItem&quot;);
+
+//
+// TODO
+// fix SVG support, and turn it on only if the browser supports it
+// fix really long labels in vertical mode
+//
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.event&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:FisheyeList&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:FisheyeListItem&quot;);
+
+dojo.widget.html.FisheyeList = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.FisheyeList, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.FisheyeList, {
+
+	templateString: '&lt;div class=&quot;dojoHtmlFisheyeListBar&quot;&gt;&lt;/div&gt;',
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlFisheyeList.css&quot;),
+	widgetType: &quot;FisheyeList&quot;,
+
+	EDGE: {
+		CENTER: 0,
+		LEFT: 1,
+		RIGHT: 2,
+		TOP: 3,
+		BOTTOM: 4
+	},
+
+	isContainer: true,
+	snarfChildDomOutput: true,
+	
+	pos: {x: -1, y: -1},		// current cursor position, relative to the grid
+	
+	// for conservative trigger mode, when triggered, timerScale is gradually increased from 0 to 1
+	timerScale: 1.0,
+
+	/////////////////////////////////////////////////////////////////
+	//
+	// i spy OPTIONS!!!!
+	//
+
+	itemWidth: 40,
+	itemHeight: 40,
+
+	itemMaxWidth: 150,
+	itemMaxHeight: 150,
+
+	orientation: 'horizontal',
+	
+	conservativeTrigger: false,		// don't active menu until mouse is over an image (macintosh style)
+
+	effectUnits: 2,
+	itemPadding: 10,
+
+	attachEdge: 'center',
+	labelEdge: 'bottom',
+
+	enableCrappySvgSupport: false,
+
+
+	//
+	//
+	//
+	/////////////////////////////////////////////////////////////////
+
+	fillInTemplate: function(args, frag) {
+		//dojo.debug(this.orientation);
+
+		dojo.html.disableSelection(this.domNode);
+
+		this.isHorizontal = (this.orientation == 'horizontal') ? 1 : 0;
+		this.selectedNode = -1;
+
+		this.isOver = false;
+		this.hitX1 = -1;
+		this.hitY1 = -1;
+		this.hitX2 = -1;
+		this.hitY2 = -1;
+
+		//
+		// only some edges make sense...
+		//
+
+		this.anchorEdge = this.toEdge(this.attachEdge, this.EDGE.CENTER);
+		this.labelEdge  = this.toEdge(this.labelEdge,  this.EDGE.TOP);
+
+		if ( this.isHorizontal &amp;&amp; (this.anchorEdge == this.EDGE.LEFT  )){ this.anchorEdge = this.EDGE.CENTER; }
+		if ( this.isHorizontal &amp;&amp; (this.anchorEdge == this.EDGE.RIGHT )){ this.anchorEdge = this.EDGE.CENTER; }
+		if (!this.isHorizontal &amp;&amp; (this.anchorEdge == this.EDGE.TOP   )){ this.anchorEdge = this.EDGE.CENTER; }
+		if (!this.isHorizontal &amp;&amp; (this.anchorEdge == this.EDGE.BOTTOM)){ this.anchorEdge = this.EDGE.CENTER; }
+
+		if (this.labelEdge == this.EDGE.CENTER){ this.labelEdge = this.EDGE.TOP; }
+		if ( this.isHorizontal &amp;&amp; (this.labelEdge == this.EDGE.LEFT  )){ this.labelEdge = this.EDGE.TOP; }
+		if ( this.isHorizontal &amp;&amp; (this.labelEdge == this.EDGE.RIGHT )){ this.labelEdge = this.EDGE.TOP; }
+		if (!this.isHorizontal &amp;&amp; (this.labelEdge == this.EDGE.TOP   )){ this.labelEdge = this.EDGE.LEFT; }
+		if (!this.isHorizontal &amp;&amp; (this.labelEdge == this.EDGE.BOTTOM)){ this.labelEdge = this.EDGE.LEFT; }
+
+
+		//
+		// figure out the proximity size
+		//
+
+		this.proximityLeft   = this.itemWidth  * (this.effectUnits - 0.5);
+		this.proximityRight  = this.itemWidth  * (this.effectUnits - 0.5);
+		this.proximityTop    = this.itemHeight * (this.effectUnits - 0.5);
+		this.proximityBottom = this.itemHeight * (this.effectUnits - 0.5);
+
+		if (this.anchorEdge == this.EDGE.LEFT){
+			this.proximityLeft = 0;
+		}
+		if (this.anchorEdge == this.EDGE.RIGHT){
+			this.proximityRight = 0;
+		}
+		if (this.anchorEdge == this.EDGE.TOP){
+			this.proximityTop = 0;
+		}
+		if (this.anchorEdge == this.EDGE.BOTTOM){
+			this.proximityBottom = 0;
+		}
+		if (this.anchorEdge == this.EDGE.CENTER){
+			this.proximityLeft   /= 2;
+			this.proximityRight  /= 2;
+			this.proximityTop    /= 2;
+			this.proximityBottom /= 2;
+		}
+	},
+	
+	postCreate: function(args, frag) {
+		this.initializePositioning();
+
+		//
+		// in liberal trigger mode, activate menu whenever mouse is close
+		//
+		if( !this.conservativeTrigger ){
+			dojo.event.connect(document.documentElement, &quot;onmousemove&quot;, this, &quot;mouseHandler&quot;);
+		}
+		
+		// Deactivate the menu if mouse is moved off screen (doesn't work for FF?)
+		dojo.event.connect(document.documentElement, &quot;onmouseout&quot;, this, &quot;onBodyOut&quot;);
+		dojo.event.connect(this, &quot;addChild&quot;, this, &quot;initializePositioning&quot;);
+	},
+
+	initializePositioning: function(){
+		this.itemCount = this.children.length;
+
+		this.barWidth  = (this.isHorizontal ? this.itemCount : 1) * this.itemWidth;
+		this.barHeight = (this.isHorizontal ? 1 : this.itemCount) * this.itemHeight;
+
+		this.totalWidth  = this.proximityLeft + this.proximityRight  + this.barWidth;
+		this.totalHeight = this.proximityTop  + this.proximityBottom + this.barHeight;
+
+		//
+		// calculate effect ranges for each item
+		//
+
+		for (var i=0; i&lt;this.children.length; i++){
+
+			this.children[i].posX = this.itemWidth  * (this.isHorizontal ? i : 0);
+			this.children[i].posY = this.itemHeight * (this.isHorizontal ? 0 : i);
+
+			this.children[i].cenX = this.children[i].posX + (this.itemWidth  / 2);
+			this.children[i].cenY = this.children[i].posY + (this.itemHeight / 2);
+
+			var isz = this.isHorizontal ? this.itemWidth : this.itemHeight;
+			var r = this.effectUnits * isz;
+			var c = this.isHorizontal ? this.children[i].cenX : this.children[i].cenY;
+			var lhs = this.isHorizontal ? this.proximityLeft : this.proximityTop;
+			var rhs = this.isHorizontal ? this.proximityRight : this.proximityBottom;
+			var siz = this.isHorizontal ? this.barWidth : this.barHeight;
+
+			var range_lhs = r;
+			var range_rhs = r;
+
+			if (range_lhs &gt; c+lhs){ range_lhs = c+lhs; }
+			if (range_rhs &gt; (siz-c+rhs)){ range_rhs = siz-c+rhs; }
+
+			this.children[i].effectRangeLeft = range_lhs / isz;
+			this.children[i].effectRangeRght = range_rhs / isz;
+
+			//dojo.debug('effect range for '+i+' is '+range_lhs+'/'+range_rhs);
+		}
+
+
+		//
+		// create the bar
+		//
+
+		this.domNode.style.width = this.barWidth + 'px';
+		this.domNode.style.height = this.barHeight + 'px';
+
+
+		//
+		// position the items
+		//
+		for (var i=0; i&lt;this.children.length; i++){
+			var itm = this.children[i];
+			var elm = itm.domNode;
+			elm.style.left   = itm.posX + 'px';
+			elm.style.top    = itm.posY + 'px';
+			elm.style.width  = this.itemWidth + 'px';
+			elm.style.height = this.itemHeight + 'px';
+			
+			if ( itm.svgNode ) {
+				itm.svgNode.style.position = 'absolute';
+				itm.svgNode.style.left = this.itemPadding+'%';
+				itm.svgNode.style.top = this.itemPadding+'%';
+				itm.svgNode.style.width = (100 - 2 * this.itemPadding) + '%';
+				itm.svgNode.style.height = (100 - 2 * this.itemPadding) + '%';
+				itm.svgNode.style.zIndex = 1;
+	
+				itm.svgNode.setSize(this.itemWidth, this.itemHeight);
+			} else {
+				itm.imgNode.style.left = this.itemPadding+'%';
+				itm.imgNode.style.top = this.itemPadding+'%';
+				itm.imgNode.style.width = (100 - 2 * this.itemPadding) + '%';
+				itm.imgNode.style.height = (100 - 2 * this.itemPadding) + '%';
+			}
+		}
+
+		//
+		// calc the grid
+		//
+
+		this.calcHitGrid();
+	},
+
+	onBodyOut: function(e){
+		// clicking over an object inside of body causes this event to fire; ignore that case
+		if( dojo.html.overElement(document.body, e) ){
+			return;
+		}
+		this.setDormant(e);
+	},
+
+	// when mouse moves out of menu's range
+	setDormant: function(e){
+		if( !this.isOver ){ return; }	// already dormant?
+		this.isOver = false;
+
+		if ( this.conservativeTrigger ) {
+			// user can't re-trigger the menu expansion
+			// until he mouses over a icon again
+			dojo.event.disconnect(document.documentElement, &quot;onmousemove&quot;, this, &quot;mouseHandler&quot;);
+		}
+		this.onGridMouseMove(-1, -1);
+	},
+
+	// when mouse is moved into menu's range
+	setActive: function(e){
+		if( this.isOver ){ return; }	// already activated?
+		this.isOver = true;
+
+		if ( this.conservativeTrigger ) {
+			// switch event handlers so that we handle mouse events from anywhere near
+			// the menu
+			dojo.event.connect(document.documentElement, &quot;onmousemove&quot;, this, &quot;mouseHandler&quot;);
+
+			this.timerScale=0.0;
+
+			// call mouse handler to do some initial necessary calculations/positioning
+			this.mouseHandler(e);
+
+			// slowly expand the icon size so it isn't jumpy
+			this.expandSlowly();
+		}
+	},
+
+	// when mouse is moved
+	mouseHandler: function(e) {
+		if ((e.pageX &gt;= this.hitX1) &amp;&amp; (e.pageX &lt;= this.hitX2) &amp;&amp;
+			(e.pageY &gt;= this.hitY1) &amp;&amp; (e.pageY &lt;= this.hitY2)){
+			if( !this.isOver ){
+				this.setActive(e);
+			}
+			this.onGridMouseMove(e.pageX-this.hitX1, e.pageY-this.hitY1);
+		}else{
+			if (this.isOver){
+				this.setDormant(e);
+			}
+		}
+	},
+
+	onResized: function() {
+		this.calcHitGrid();
+	},
+
+	onGridMouseMove: function(x, y){
+		this.pos = {x:x, y:y};
+		this.paint();
+	},
+	
+	paint: function(){
+		var x=this.pos.x;
+		var y=this.pos.y;
+
+		if( this.itemCount &lt;= 0 ){ return; }
+
+		//
+		// figure out our main index
+		//
+
+		var pos = this.isHorizontal ? x : y;
+		var prx = this.isHorizontal ? this.proximityLeft : this.proximityTop;
+		var siz = this.isHorizontal ? this.itemWidth : this.itemHeight;
+		var sim = this.isHorizontal ? 
+			(1.0-this.timerScale)*this.itemWidth + this.timerScale*this.itemMaxWidth :
+			(1.0-this.timerScale)*this.itemHeight + this.timerScale*this.itemMaxHeight ;
+
+		var cen = ((pos - prx) / siz) - 0.5;
+		var max_off_cen = (sim / siz) - 0.5;
+
+		if (max_off_cen &gt; this.effectUnits){ max_off_cen = this.effectUnits; }
+
+
+		//
+		// figure out our off-axis weighting
+		//
+
+		var off_weight = 0;
+
+		if (this.anchorEdge == this.EDGE.BOTTOM){
+			var cen2 = (y - this.proximityTop) / this.itemHeight;
+			off_weight = (cen2 &gt; 0.5) ? 1 : y / (this.proximityTop + (this.itemHeight / 2));
+		}
+		if (this.anchorEdge == this.EDGE.TOP){
+			var cen2 = (y - this.proximityTop) / this.itemHeight;
+			off_weight = (cen2 &lt; 0.5) ? 1 : (this.totalHeight - y) / (this.proximityBottom + (this.itemHeight / 2));
+		}
+		if (this.anchorEdge == this.EDGE.RIGHT){
+			var cen2 = (x - this.proximityLeft) / this.itemWidth;
+			off_weight = (cen2 &gt; 0.5) ? 1 : x / (this.proximityLeft + (this.itemWidth / 2));
+		}
+		if (this.anchorEdge == this.EDGE.LEFT){
+			var cen2 = (x - this.proximityLeft) / this.itemWidth;
+			off_weight = (cen2 &lt; 0.5) ? 1 : (this.totalWidth - x) / (this.proximityRight + (this.itemWidth / 2));
+		}
+		if (this.anchorEdge == this.EDGE.CENTER){
+
+			if (this.isHorizontal){
+				off_weight = y / (this.totalHeight);
+			}else{
+				off_weight = x / (this.totalWidth);
+			}
+
+			if (off_weight &gt; 0.5){
+				off_weight = 1 - off_weight;
+			}
+
+			off_weight *= 2;
+		}
+
+
+		//
+		// set the sizes
+		//
+
+		for(var i=0; i&lt;this.itemCount; i++){
+
+			var weight = this.weightAt(cen, i);
+
+			if (weight &lt; 0){weight = 0;}
+
+			this.setitemsize(i, weight * off_weight);
+		}
+
+		//
+		// set the positions
+		//
+
+		var main_p = Math.round(cen);
+		var offset = 0;
+
+		if (cen &lt; 0){
+			main_p = 0;
+
+		}else if (cen &gt; this.itemCount - 1){
+
+			main_p = this.itemCount -1;
+
+		}else{
+
+			offset = (cen - main_p) * ((this.isHorizontal ? this.itemWidth : this.itemHeight) - this.children[main_p].sizeMain);
+		}
+
+		this.positionElementsFrom(main_p, offset);
+	},
+
+	weightAt: function(cen, i){
+
+		var dist = Math.abs(cen - i);
+
+		var limit = ((cen - i) &gt; 0) ? this.children[i].effectRangeRght : this.children[i].effectRangeLeft;
+
+		return (dist &gt; limit) ? 0 : (1 - dist / limit);
+	},
+
+	positionFromNode: function(p, w){
+
+		//
+		// we need to grow all the nodes growing out from node 'i'
+		//
+
+		this.setitemsize(p, w);
+
+		var wx = w;
+		for(var i=p; i&lt;this.itemCount; i++){
+			wx = 0.8 * wx;
+			this.setitemsize(i, wx);
+		}
+
+		var wx = w;
+		for(var i=p; i&gt;=0; i--){
+			wx = 0.8 * wx;
+			this.setitemsize(i, wx);
+		}
+	},
+
+	setitemsize: function(p, scale){
+		scale *= this.timerScale;
+		var w = Math.round(this.itemWidth  + ((this.itemMaxWidth  - this.itemWidth ) * scale));
+		var h = Math.round(this.itemHeight + ((this.itemMaxHeight - this.itemHeight) * scale));
+
+		if (this.isHorizontal){
+
+			this.children[p].sizeW = w;
+			this.children[p].sizeH = h;
+
+			this.children[p].sizeMain = w;
+			this.children[p].sizeOff  = h;
+
+			var y = 0;
+
+			if (this.anchorEdge == this.EDGE.TOP){
+
+				y = (this.children[p].cenY - (this.itemHeight / 2));
+
+			}else if (this.anchorEdge == this.EDGE.BOTTOM){
+
+				y = (this.children[p].cenY - (h - (this.itemHeight / 2)));
+
+			}else{
+
+				y = (this.children[p].cenY - (h / 2));
+			}
+
+			this.children[p].usualX = Math.round(this.children[p].cenX - (w / 2));
+			
+			this.children[p].domNode.style.top  = y + 'px';
+
+			this.children[p].domNode.style.left  = this.children[p].usualX + 'px';
+
+		}else{
+
+			this.children[p].sizeW = w;
+			this.children[p].sizeH = h;
+
+			this.children[p].sizeOff  = w;
+			this.children[p].sizeMain = h;
+
+			var x = 0;
+
+			if (this.anchorEdge == this.EDGE.LEFT){
+
+				x = this.children[p].cenX - (this.itemWidth / 2);
+
+			}else if (this.anchorEdge == this.EDGE.RIGHT){
+
+				x = this.children[p].cenX - (w - (this.itemWidth / 2));
+			}else{
+
+				x = this.children[p].cenX - (w / 2);
+			}
+
+			this.children[p].domNode.style.left = x + 'px';
+			this.children[p].usualY = Math.round(this.children[p].cenY - (h / 2));
+
+			this.children[p].domNode.style.top  = this.children[p].usualY + 'px';
+		}
+
+		this.children[p].domNode.style.width  = w + 'px';
+		this.children[p].domNode.style.height = h + 'px';
+
+		if (this.children[p].svgNode){
+			this.children[p].svgNode.setSize(w, h);
+		}
+	},
+
+	positionElementsFrom: function(p, offset){
+
+		var pos = 0;
+
+		if (this.isHorizontal){
+			pos = Math.round(this.children[p].usualX + offset);
+			this.children[p].domNode.style.left = pos + 'px';
+		}else{
+			pos = Math.round(this.children[p].usualY + offset);
+			this.children[p].domNode.style.top = pos + 'px';
+		}
+		this.positionLabel(this.children[p]);
+
+
+		//
+		// position before
+		//
+
+		var bpos = pos;
+
+		for(var i=p-1; i&gt;=0; i--){
+
+			bpos -= this.children[i].sizeMain;
+
+			if (this.isHorizontal){
+				this.children[i].domNode.style.left = bpos + 'px';
+			}else{
+				this.children[i].domNode.style.top = bpos + 'px';
+			}
+			this.positionLabel(this.children[i]);
+		}
+
+		//
+		// position after
+		//
+
+		var apos = pos;
+
+		for(var i=p+1; i&lt;this.itemCount; i++){
+
+			apos += this.children[i-1].sizeMain;
+
+			if (this.isHorizontal){
+				this.children[i].domNode.style.left = apos + 'px';
+			}else{
+				this.children[i].domNode.style.top = apos + 'px';
+			}
+			this.positionLabel(this.children[i]);
+		}
+
+	},
+
+	positionLabel: function(itm){
+
+		var x = 0;
+		var y = 0;
+		
+		var labelW = dojo.style.getOuterWidth(itm.lblNode);
+		var labelH = dojo.style.getOuterHeight(itm.lblNode);
+
+		if (this.labelEdge == this.EDGE.TOP){
+			x = Math.round((itm.sizeW / 2) - (labelW / 2));
+			y = -labelH;
+		}
+
+		if (this.labelEdge == this.EDGE.BOTTOM){
+			x = Math.round((itm.sizeW / 2) - (labelW / 2));
+			y = itm.sizeH;
+		}
+
+		if (this.labelEdge == this.EDGE.LEFT){
+			x = -labelW;
+			y = Math.round((itm.sizeH / 2) - (labelH / 2));
+		}
+
+		if (this.labelEdge == this.EDGE.RIGHT){
+			x = itm.sizeW;
+			y = Math.round((itm.sizeH / 2) - (labelH / 2));
+		}
+
+		itm.lblNode.style.left = x + 'px';
+		itm.lblNode.style.top  = y + 'px';
+	},
+
+	calcHitGrid: function(){
+
+		var pos = dojo.style.getAbsolutePosition(this.domNode, true);
+
+		this.hitX1 = pos.x - this.proximityLeft;
+		this.hitY1 = pos.y - this.proximityTop;
+		this.hitX2 = this.hitX1 + this.totalWidth;
+		this.hitY2 = this.hitY1 + this.totalHeight;
+
+		//dojo.debug(this.hitX1+','+this.hitY1+' // '+this.hitX2+','+this.hitY2);
+	},
+
+	toEdge: function(inp, def){
+		return this.EDGE[inp.toUpperCase()] || def;
+	},
+	
+	// slowly expand the image to user specified max size
+	expandSlowly: function(){
+		if( !this.isOver ){ return; }
+		this.timerScale += 0.2;
+		this.paint();
+		if ( this.timerScale&lt;1.0 ) {
+			dojo.lang.setTimeout(this, &quot;expandSlowly&quot;, 10);
+		}
+	},
+
+	destroy: function(){
+		// need to disconnect when we destroy
+		dojo.event.disconnect(document.documentElement, &quot;onmouseout&quot;, this, &quot;onBodyOut&quot;);
+		dojo.event.disconnect(document.documentElement, &quot;onmousemove&quot;, this, &quot;mouseHandler&quot;);
+		dojo.widget.html.FisheyeList.superclass.destroy.call(this);
+	}
+});
+
+dojo.widget.html.FisheyeListItem = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.FisheyeListItem, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.FisheyeListItem, {
+	widgetType: &quot;FisheyeListItem&quot;,
+	
+	// Constructor arguments
+	iconSrc: &quot;&quot;,
+	svgSrc: &quot;&quot;,
+	caption: &quot;&quot;,
+
+	blankImgPath: dojo.uri.dojoUri(&quot;src/widget/templates/images/blank.gif&quot;),
+
+	templateString:
+		'&lt;div class=&quot;dojoHtmlFisheyeListItem&quot;&gt;' +
+		'  &lt;img class=&quot;dojoHtmlFisheyeListItemImage&quot; dojoAttachPoint=&quot;imgNode&quot; dojoAttachEvent=&quot;onMouseOver;onMouseOut;onClick&quot;&gt;' +
+		'  &lt;div class=&quot;dojoHtmlFisheyeListItemLabel&quot; dojoAttachPoint=&quot;lblNode&quot;&gt;&lt;/div&gt;' +
+		'&lt;/div&gt;',
+	
+	imgNode: null,
+
+	fillInTemplate: function() {
+		//
+		// set image
+		// TODO: turn on/off SVG support based on browser version.
+		// this.parent.enableCrappySvgSupport is not available to this function
+		//
+		if (this.svgSrc != &quot;&quot;){
+			this.svgNode = this.createSvgNode(this.svgSrc);
+			this.domNode.appendChild(this.svgNode);
+			this.imgNode.style.display = 'none';
+		} else if((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4)==&quot;.png&quot;)&amp;&amp;(dojo.render.html.ie)){
+			this.imgNode.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src='&quot;+this.iconSrc+&quot;', sizingMethod='scale')&quot;;
+			this.imgNode.src = this.blankImgPath.toString();
+		} else {
+			this.imgNode.src = this.iconSrc;
+		}
+
+		//
+		// Label
+		//
+		if ( this.lblNode ) {
+			this.lblNode.appendChild(document.createTextNode(this.caption));
+		}
+		dojo.html.disableSelection(this.domNode);
+	},
+	
+	createSvgNode: function(src){
+
+		var elm = document.createElement('embed');
+		elm.src = src;
+		elm.type = 'image/svg+xml';
+		//elm.style.border = '1px solid black';
+		elm.style.width = '1px';
+		elm.style.height = '1px';
+		elm.loaded = 0;
+		elm.setSizeOnLoad = false;
+
+		elm.onload = function(){
+			this.svgRoot = this.getSVGDocument().rootElement;
+			this.svgDoc = this.getSVGDocument().documentElement;
+			this.zeroWidth = this.svgRoot.width.baseVal.value;
+			this.zeroHeight = this.svgRoot.height.baseVal.value;
+			this.loaded = true;
+
+			if (this.setSizeOnLoad){
+				this.setSize(this.setWidth, this.setHeight);
+			}
+		}
+
+		elm.setSize = function(w, h){
+			if (!this.loaded){
+				this.setWidth = w;
+				this.setHeight = h;
+				this.setSizeOnLoad = true;
+				return;
+			}
+
+			this.style.width = w+'px';
+			this.style.height = h+'px';
+			this.svgRoot.width.baseVal.value = w;
+			this.svgRoot.height.baseVal.value = h;
+
+			var scale_x = w / this.zeroWidth;
+			var scale_y = h / this.zeroHeight;
+
+			for(var i=0; i&lt;this.svgDoc.childNodes.length; i++){
+				if (this.svgDoc.childNodes[i].setAttribute){
+					this.svgDoc.childNodes[i].setAttribute( &quot;transform&quot;, &quot;scale(&quot;+scale_x+&quot;,&quot;+scale_y+&quot;)&quot; );
+				}
+			}
+		}
+
+		return elm;
+	},
+
+	onMouseOver: function(e) {
+		// in conservative mode, don't activate the menu until user mouses over an icon
+		if( !this.parent.isOver ){
+			this.parent.setActive(e);
+		}
+		if ( this.caption != &quot;&quot; ) {
+			dojo.html.addClass(this.lblNode, &quot;selected&quot;);
+			this.parent.positionLabel(this);
+		}
+	},
+	
+	onMouseOut: function() {
+		dojo.html.removeClass(this.lblNode, &quot;selected&quot;);
+	},
+
+	onClick: function() {
+	}
+});
+

Added: trunk/root/static/magic/src/widget/FloatingPane.js
===================================================================
--- trunk/root/static/magic/src/widget/FloatingPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/FloatingPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,305 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.FloatingPane&quot;);
+dojo.provide(&quot;dojo.widget.html.FloatingPane&quot;);
+
+//
+// this widget provides a window-like floating pane
+//
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.Manager&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.html.shadow&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.html.layout&quot;);
+dojo.require(&quot;dojo.widget.ContentPane&quot;);
+dojo.require(&quot;dojo.dnd.HtmlDragMove&quot;);
+dojo.require(&quot;dojo.dnd.HtmlDragMoveSource&quot;);
+dojo.require(&quot;dojo.dnd.HtmlDragMoveObject&quot;);
+dojo.require(&quot;dojo.widget.ResizeHandle&quot;);
+
+dojo.widget.html.FloatingPane = function(){
+	dojo.widget.html.ContentPane.call(this);
+}
+
+dojo.inherits(dojo.widget.html.FloatingPane, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.html.FloatingPane, {
+	widgetType: &quot;FloatingPane&quot;,
+
+	// Constructor arguments
+	title: '',
+	iconSrc: '',
+	hasShadow: false,
+	constrainToContainer: false,
+	taskBarId: &quot;&quot;,
+	resizable: true,
+	titleBarDisplay: &quot;fancy&quot;,
+
+	windowState: &quot;normal&quot;,
+	displayCloseAction: false,
+	displayMinimizeAction: false,
+	displayMaximizeAction: false,
+
+	maxTaskBarConnectAttempts: 5,
+	taskBarConnectAttempts: 0,
+
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlFloatingPane.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlFloatingPane.css&quot;),
+
+	drag: null,
+
+	fillInTemplate: function(args, frag){
+		// Copy style info from input node to output node
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+
+		// necessary for safari, khtml (for computing width/height)
+		document.body.appendChild(this.domNode);
+
+		// if display:none then state=minimized, otherwise state=normal
+		if(!this.isShowing()){
+			this.windowState=&quot;minimized&quot;;
+		}
+
+		// &lt;img src=&quot;&quot;&gt; can hang IE!  better get rid of it
+		if(this.iconSrc==&quot;&quot;){
+			dojo.dom.removeNode(this.titleBarIcon);
+		}else{
+			this.titleBarIcon.src = this.iconSrc.toString();// dojo.uri.Uri obj req. toString()
+		}
+
+		if(this.titleBarDisplay!=&quot;none&quot;){	
+			this.titleBar.style.display=&quot;&quot;;
+			dojo.html.disableSelection(this.titleBar);
+
+			this.titleBarIcon.style.display = (this.iconSrc==&quot;&quot; ? &quot;none&quot; : &quot;&quot;);
+
+			this.minimizeAction.style.display = (this.displayMinimizeAction ? &quot;&quot; : &quot;none&quot;);
+			this.maximizeAction.style.display= 
+				(this.displayMaximizeAction &amp;&amp; this.windowState!=&quot;maximized&quot; ? &quot;&quot; : &quot;none&quot;);
+			this.restoreAction.style.display= 
+				(this.displayMaximizeAction &amp;&amp; this.windowState==&quot;maximized&quot; ? &quot;&quot; : &quot;none&quot;);
+			this.closeAction.style.display= (this.displayCloseAction ? &quot;&quot; : &quot;none&quot;);
+
+			this.drag = new dojo.dnd.HtmlDragMoveSource(this.domNode);	
+			if (this.constrainToContainer) {
+				this.drag.constrainTo();
+			}
+			this.drag.setDragHandle(this.titleBar);
+
+			var self = this;
+
+			dojo.event.topic.subscribe(&quot;dragMove&quot;,
+				function (info){
+					if (info.source.domNode == self.domNode){
+						dojo.event.topic.publish('floatingPaneMove', { source: self } );
+					}
+				}
+			);
+
+		}
+
+		if(this.resizable){
+			this.resizeBar.style.display=&quot;&quot;;
+			var rh = dojo.widget.createWidget(&quot;ResizeHandle&quot;, {targetElmId: this.widgetId, id:this.widgetId+&quot;_resize&quot;});
+			this.resizeBar.appendChild(rh.domNode);
+		}
+
+		// add a drop shadow
+		if(this.hasShadow){
+			this.shadow=new dojo.html.shadow(this.domNode);
+		}
+
+		// Prevent IE bleed-through problem
+		this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);
+
+		if( this.taskBarId ){
+			this.taskBarSetup();
+		}
+
+		if (dojo.hostenv.post_load_) {
+			this.setInitialWindowState();
+		} else {
+			dojo.addOnLoad(this, &quot;setInitialWindowState&quot;);
+		}
+
+		// counteract body.appendChild above
+		document.body.removeChild(this.domNode);
+
+		dojo.widget.html.FloatingPane.superclass.fillInTemplate.call(this, args, frag);
+	},
+
+	postCreate: function(){
+		if(this.isShowing()){
+			this.width=-1;	// force resize
+			this.resizeTo(dojo.style.getOuterWidth(this.domNode), dojo.style.getOuterHeight(this.domNode));
+		}
+	},
+
+	maximizeWindow: function(evt) {
+		this.previous={
+			width: dojo.style.getOuterWidth(this.domNode) || this.width,
+			height: dojo.style.getOuterHeight(this.domNode) || this.height,
+			left: this.domNode.style.left,
+			top: this.domNode.style.top,
+			bottom: this.domNode.style.bottom,
+			right: this.domNode.style.right
+		};
+		this.domNode.style.left =
+			dojo.style.getPixelValue(this.domNode.parentNode, &quot;padding-left&quot;, true) + &quot;px&quot;;
+		this.domNode.style.top =
+			dojo.style.getPixelValue(this.domNode.parentNode, &quot;padding-top&quot;, true) + &quot;px&quot;;
+
+		if ((this.domNode.parentNode.nodeName.toLowerCase() == 'body')) {
+			this.resizeTo(
+				dojo.html.getViewportWidth()-dojo.style.getPaddingWidth(document.body),
+				dojo.html.getViewportHeight()-dojo.style.getPaddingHeight(document.body)
+			);
+		} else {
+			this.resizeTo(
+				dojo.style.getContentWidth(this.domNode.parentNode),
+				dojo.style.getContentHeight(this.domNode.parentNode)
+			);
+		}
+		this.maximizeAction.style.display=&quot;none&quot;;
+		this.restoreAction.style.display=&quot;&quot;;
+		this.windowState=&quot;maximized&quot;;
+	},
+
+	minimizeWindow: function(evt) {
+		this.hide();
+		this.windowState = &quot;minimized&quot;;
+	},
+
+	restoreWindow: function(evt) {
+		if (this.windowState==&quot;minimized&quot;) {
+			this.show() 
+		} else {
+			for(var attr in this.previous){
+				this.domNode.style[attr] = this.previous[attr];
+			}
+			this.resizeTo(this.previous.width, this.previous.height);
+			this.previous=null;
+
+			this.restoreAction.style.display=&quot;none&quot;;
+			this.maximizeAction.style.display=this.displayMaximizeAction ? &quot;&quot; : &quot;none&quot;;
+		}
+
+		this.windowState=&quot;normal&quot;;
+	},
+
+	closeWindow: function(evt) {
+		dojo.dom.removeNode(this.domNode);
+		this.destroy();
+	},
+
+	onMouseDown: function(evt) {
+		this.bringToTop();
+	},
+
+	bringToTop: function() {
+		var floatingPanes= dojo.widget.manager.getWidgetsByType(this.widgetType);
+		var windows = [];
+		for (var x=0; x&lt;floatingPanes.length; x++) {
+			if (this.widgetId != floatingPanes[x].widgetId) {
+					windows.push(floatingPanes[x]);
+			}
+		}
+
+		windows.sort(function(a,b) {
+			return a.domNode.style.zIndex - b.domNode.style.zIndex;
+		});
+		
+		windows.push(this);
+
+		var floatingPaneStartingZ = 100;
+		for (x=0; x&lt;windows.length;x++) {
+			windows[x].domNode.style.zIndex = floatingPaneStartingZ + x;
+		}
+	},
+
+	setInitialWindowState: function() {
+		if (this.windowState == &quot;maximized&quot;) {
+			this.maximizeWindow();
+			this.show();
+			return;
+		}
+
+		if (this.windowState==&quot;normal&quot;) {
+			this.show();
+			return;
+		}
+
+		if (this.windowState==&quot;minimized&quot;) {
+			this.hide();
+			return;
+		}
+
+		this.windowState=&quot;minimized&quot;;
+	},
+
+	// add icon to task bar, connected to me
+	taskBarSetup: function() {
+		var taskbar = dojo.widget.getWidgetById(this.taskBarId);
+		if (!taskbar){
+			if (this.taskBarConnectAttempts &lt;  this.maxTaskBarConnectAttempts) {
+				dojo.lang.setTimeout(this, this.taskBarSetup, 50);
+				this.taskBarConnectAttempts++;
+			} else {
+				dojo.debug(&quot;Unable to connect to the taskBar&quot;);
+			}
+			return;
+		}
+		taskbar.addChild(this);
+	},
+
+	show: function(){
+		dojo.widget.html.FloatingPane.superclass.show.apply(this, arguments);
+		this.bringToTop();
+	},
+
+	onShow: function(){
+		dojo.widget.html.FloatingPane.superclass.onShow.call(this);
+		this.resizeTo(dojo.style.getOuterWidth(this.domNode), dojo.style.getOuterHeight(this.domNode));
+	},
+
+	// This is called when the user adjusts the size of the floating pane
+	resizeTo: function(w, h){
+		dojo.style.setOuterWidth(this.domNode, w);
+		dojo.style.setOuterHeight(this.domNode, h);
+
+		dojo.html.layout(this.domNode,
+			[
+			  {domNode: this.titleBar, layoutAlign: &quot;top&quot;},
+			  {domNode: this.resizeBar, layoutAlign: &quot;bottom&quot;},
+			  {domNode: this.containerNode, layoutAlign: &quot;client&quot;}
+			] );
+
+		// If any of the children have layoutAlign specified, obey it
+		dojo.html.layout(this.containerNode, this.children, &quot;top-bottom&quot;);
+		
+		this.bgIframe.onResized();
+		if(this.shadow){ this.shadow.size(w, h); }
+		this.onResized();
+	},
+
+	checkSize: function() {
+		// checkSize() is called when the user has resized the browser window,
+		// but that doesn't affect this widget (or this widget's children)
+		// so it can be safely ignored...
+		// TODO: unless we are maximized.  then we should resize ourself.
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:FloatingPane&quot;);

Added: trunk/root/static/magic/src/widget/GoogleMap.js
===================================================================
--- trunk/root/static/magic/src/widget/GoogleMap.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/GoogleMap.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,44 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.GoogleMap&quot;);
+dojo.provide(&quot;dojo.widget.GoogleMap.Controls&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:googlemap&quot;);
+
+dojo.widget.GoogleMap=function(){
+	//	summary
+	//	base class for the Google Map widget
+	dojo.widget.Widget.call(this);
+	this.widgetType=&quot;GoogleMap&quot;;
+	this.isContainer=false;
+}
+dojo.inherits(dojo.widget.GoogleMap, dojo.widget.Widget);
+
+dojo.widget.GoogleMap.Controls={
+	LargeMap:&quot;largemap&quot;,
+	SmallMap:&quot;smallmap&quot;,
+	SmallZoom:&quot;smallzoom&quot;,
+	Scale:&quot;scale&quot;,
+	MapType:&quot;maptype&quot;,
+	Overview:&quot;overview&quot;,
+	get:function(s){
+		for(var p in this){
+			if(typeof(this[p])==&quot;string&quot;
+				&amp;&amp; this[p]==s
+			){
+				return p;
+			}
+		}
+		return null;
+	}
+};
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.GoogleMap&quot;);

Added: trunk/root/static/magic/src/widget/HtmlWidget.js
===================================================================
--- trunk/root/static/magic/src/widget/HtmlWidget.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/HtmlWidget.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,163 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.DomWidget&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.html.extras&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.lfx.toggle&quot;);
+
+dojo.declare(&quot;dojo.widget.HtmlWidget&quot;, dojo.widget.DomWidget, {								 
+	widgetType: &quot;HtmlWidget&quot;,
+
+	templateCssPath: null,
+	templatePath: null,
+
+	// for displaying/hiding widget
+	toggle: &quot;plain&quot;,
+	toggleDuration: 150,
+
+	animationInProgress: false,
+
+	initialize: function(args, frag){
+	},
+
+	postMixInProperties: function(args, frag){
+		// now that we know the setting for toggle, get toggle object
+		// (default to plain toggler if user specified toggler not present)
+		this.toggleObj =
+			dojo.lfx.toggle[this.toggle.toLowerCase()] || dojo.lfx.toggle.plain;
+	},
+
+	getContainerHeight: function(){
+		// NOTE: container height must be returned as the INNER height
+		dojo.unimplemented(&quot;dojo.widget.HtmlWidget.getContainerHeight&quot;);
+	},
+
+	getContainerWidth: function(){
+		return this.parent.domNode.offsetWidth;
+	},
+
+	setNativeHeight: function(height){
+		var ch = this.getContainerHeight();
+	},
+
+	createNodesFromText: function(txt, wrap){
+		return dojo.html.createNodesFromText(txt, wrap);
+	},
+
+	destroyRendering: function(finalize){
+		try{
+			if(!finalize){
+				dojo.event.browser.clean(this.domNode);
+			}
+			this.domNode.parentNode.removeChild(this.domNode);
+			delete this.domNode;
+		}catch(e){ /* squelch! */ }
+	},
+
+	/////////////////////////////////////////////////////////
+	// Displaying/hiding the widget
+	/////////////////////////////////////////////////////////
+	isShowing: function(){
+		return dojo.style.isShowing(this.domNode);
+	},
+
+	toggleShowing: function(){
+		// dojo.style.toggleShowing(this.domNode);
+		if(this.isHidden){
+			this.show();
+		}else{
+			this.hide();
+		}
+	},
+
+	show: function(){
+		this.animationInProgress=true;
+		this.isHidden = false;
+		this.toggleObj.show(this.domNode, this.toggleDuration, null,
+			dojo.lang.hitch(this, this.onShow), this.explodeSrc);
+	},
+
+	// called after the show() animation has completed
+	onShow: function(){
+		this.animationInProgress=false;
+		this.checkSize();
+	},
+
+	hide: function(){
+		this.animationInProgress = true;
+		this.isHidden = true;
+		this.toggleObj.hide(this.domNode, this.toggleDuration, null,
+			dojo.lang.hitch(this, this.onHide), this.explodeSrc);
+	},
+
+	// called after the hide() animation has completed
+	onHide: function(){
+		this.animationInProgress=false;
+	},
+
+	//////////////////////////////////////////////////////////////////////////////
+	// Sizing related methods
+	//  If the parent changes size then for each child it should call either
+	//   - resizeTo(): size the child explicitly
+	//   - or checkSize(): notify the child the the parent has changed size
+	//////////////////////////////////////////////////////////////////////////////
+
+	// Test if my size has changed.
+	// If width &amp; height are specified then that's my new size; otherwise,
+	// query outerWidth/outerHeight of my domNode
+	_isResized: function(w, h){
+		// If I'm not being displayed then disregard (show() must
+		// check if the size has changed)
+		if(!this.isShowing()){ return false; }
+
+		// If my parent has been resized and I have style=&quot;height: 100%&quot;
+		// or something similar then my size has changed too.
+		w=w||dojo.style.getOuterWidth(this.domNode);
+		h=h||dojo.style.getOuterHeight(this.domNode);
+		if(this.width == w &amp;&amp; this.height == h){ return false; }
+
+		this.width=w;
+		this.height=h;
+		return true;
+	},
+
+	// Called when my parent has changed size, but my parent won't call resizeTo().
+	// This is useful if my size is height:100% or something similar.
+	// Also called whenever I am shown, because the first time I am shown I may need
+	// to do size calculations.
+	checkSize: function(){
+		if(!this._isResized()){ return; }
+		this.onResized();
+	},
+
+	// Explicitly set this widget's size (in pixels).
+	resizeTo: function(w, h){
+		if(!this._isResized(w,h)){ return; }
+		dojo.style.setOuterWidth(this.domNode, w);
+		dojo.style.setOuterHeight(this.domNode, h);
+		this.onResized();
+	},
+
+	resizeSoon: function(){
+		if(this.isShowing()){
+			dojo.lang.setTimeout(this, this.onResized, 0);
+		}
+	},
+
+	// Called when my size has changed.
+	// Must notify children if their size has (possibly) changed
+	onResized: function(){
+		dojo.lang.forEach(this.children, function(child){ child.checkSize(); });
+	}
+});

Added: trunk/root/static/magic/src/widget/InlineEditBox.js
===================================================================
--- trunk/root/static/magic/src/widget/InlineEditBox.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/InlineEditBox.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,172 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.InlineEditBox&quot;);
+dojo.provide(&quot;dojo.widget.html.InlineEditBox&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:inlineeditbox&quot;);
+
+dojo.widget.html.InlineEditBox = function(){
+	dojo.widget.HtmlWidget.call(this);
+	// mutable objects need to be in constructor to give each instance its own copy
+	this.history = [];
+}
+
+dojo.inherits(dojo.widget.html.InlineEditBox, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.InlineEditBox, {
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlInlineEditBox.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlInlineEditBox.css&quot;),
+	widgetType: &quot;InlineEditBox&quot;,
+
+	form: null,
+	editBox: null,
+	edit: null,
+	text: null,
+	textarea: null,
+	submitButton: null,
+	cancelButton: null,
+	mode: &quot;text&quot;,
+
+	minWidth: 100, //px. minimum width of edit box
+	minHeight: 200, //px. minimum width of edit box, if it's a TA
+
+	editing: false,
+	textValue: &quot;&quot;,
+	defaultText: &quot;&quot;,
+	doFade: false,
+	
+	onSave: function(newValue, oldValue){},
+	onUndo: function(value){},
+
+	postCreate: function(args, frag){
+		// put original node back in the document, and attach handlers
+		// which hide it and display the editor
+		this.editable = this.getFragNodeRef(frag);
+		dojo.dom.insertAfter(this.editable, this.form);
+		dojo.event.connect(this.editable, &quot;onmouseover&quot;, this, &quot;mouseover&quot;);
+		dojo.event.connect(this.editable, &quot;onmouseout&quot;, this, &quot;mouseout&quot;);
+		dojo.event.connect(this.editable, &quot;onclick&quot;, this, &quot;beginEdit&quot;);
+
+		this.textValue = dojo.string.trim(this.editable.innerHTML);
+		if(dojo.string.trim(this.textValue).length == 0){
+			this.editable.innerHTML = this.defaultText;
+		}		
+	},
+
+	mouseover: function(e){
+		if(!this.editing){
+			dojo.html.addClass(this.editable, &quot;editableRegion&quot;);
+			if(this.mode == &quot;textarea&quot;){
+				dojo.html.addClass(this.editable, &quot;editableTextareaRegion&quot;);
+			}
+		}
+	},
+
+	mouseout: function(e){
+		if(!this.editing){
+			dojo.html.removeClass(this.editable, &quot;editableRegion&quot;);
+			dojo.html.removeClass(this.editable, &quot;editableTextareaRegion&quot;);
+		}
+	},
+
+	// When user clicks the text, then start editing.
+	// Hide the text and display the form instead.
+	beginEdit: function(e){
+		if(this.editing){ return; }
+		this.mouseout();
+		this.editing = true;
+
+		// setup the form's &lt;input&gt; or &lt;textarea&gt; field, as specified by mode
+		var ee = this[this.mode.toLowerCase()];
+		ee.value = dojo.string.trim(this.textValue);
+		ee.style.fontSize = dojo.style.getStyle(this.editable, &quot;font-size&quot;);
+		ee.style.fontWeight = dojo.style.getStyle(this.editable, &quot;font-weight&quot;);
+		ee.style.fontStyle = dojo.style.getStyle(this.editable, &quot;font-style&quot;);
+		ee.style.width = Math.max(dojo.html.getInnerWidth(this.editable), this.minWidth) + &quot;px&quot;;
+		if(this.mode.toLowerCase()==&quot;textarea&quot;){
+			ee.style.display = &quot;block&quot;;
+			ee.style.height = Math.max(dojo.html.getInnerHeight(this.editable), this.minHeight) + &quot;px&quot;;
+		} else {
+			ee.style.display = &quot;&quot;;
+		}
+
+		// show the edit form and hide the read only version of the text
+		this.form.style.display = &quot;&quot;;
+		this.editable.style.display = &quot;none&quot;;
+
+		ee.select();
+		this.submitButton.disabled = true;
+	},
+
+	saveEdit: function(e){
+		e.preventDefault();
+		e.stopPropagation();
+		var ee = this[this.mode.toLowerCase()];
+		if((this.textValue != ee.value)&amp;&amp;
+			(dojo.string.trim(ee.value) != &quot;&quot;)){
+			this.doFade = true;
+			this.history.push(this.textValue);
+			this.onSave(ee.value, this.textValue);
+			this.textValue = ee.value;
+			this.editable.innerHTML = this.textValue;
+		}else{
+			this.doFade = false;
+		}
+		this.finishEdit(e);
+	},
+
+	cancelEdit: function(e){
+		if(!this.editing){ return false; }
+		this.editing = false;
+		this.form.style.display=&quot;none&quot;;
+		this.editable.style.display = &quot;&quot;;
+		return true;
+	},
+
+	finishEdit: function(e){
+		if(!this.cancelEdit(e)){ return; }
+		if(this.doFade) {
+			dojo.lfx.highlight(this.editable, dojo.graphics.color.hex2rgb(&quot;#ffc&quot;), 700).play(300);
+		}
+		this.doFade = false;
+	},
+
+	setText: function(txt){
+		// sets the text without informing the server
+		var tt = dojo.string.trim(txt);
+		this.textValue = tt
+		this.editable.innerHTML = tt;
+	},
+
+	undo: function(){
+		if(this.history.length &gt; 0){
+			var value = this.history.pop();
+			this.editable.innerHTML = value;
+			this.textValue = value;
+			this.onUndo(value);
+		}
+	},
+
+	checkForValueChange: function(){
+		var ee = this[this.mode.toLowerCase()];
+		if((this.textValue != ee.value)&amp;&amp;
+			(dojo.string.trim(ee.value) != &quot;&quot;)){
+			this.submitButton.disabled = false;
+		}
+	}
+});

Added: trunk/root/static/magic/src/widget/LayoutContainer.js
===================================================================
--- trunk/root/static/magic/src/widget/LayoutContainer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/LayoutContainer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,70 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+//
+// this widget provides Delphi-style panel layout semantics
+//
+
+dojo.provide(&quot;dojo.widget.LayoutContainer&quot;);
+dojo.provide(&quot;dojo.widget.html.LayoutContainer&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.html.layout&quot;);
+
+dojo.widget.html.LayoutContainer = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.LayoutContainer, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.LayoutContainer, {
+	widgetType: &quot;LayoutContainer&quot;,
+	isContainer: true,
+
+	layoutChildPriority: 'top-bottom',
+
+	postCreate: function(){
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	addChild: function(child, overrideContainerNode, pos, ref, insertIndex){
+		dojo.widget.html.LayoutContainer.superclass.addChild.call(this, child, overrideContainerNode, pos, ref, insertIndex);
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	removeChild: function(pane){
+		dojo.widget.html.LayoutContainer.superclass.removeChild.call(this,pane);
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	onResized: function(){
+		dojo.html.layout(this.domNode, this.children, this.layoutChildPriority);
+	},
+
+	show: function(){
+		// If this node was created while display==&quot;none&quot; then it
+		// hasn't been laid out yet.  Do that now.
+		this.domNode.style.display=&quot;&quot;;
+		this.checkSize();
+		this.domNode.style.display=&quot;none&quot;;
+		this.domNode.style.visibility=&quot;&quot;;
+
+		dojo.widget.html.LayoutContainer.superclass.show.call(this);
+	}
+});
+
+// This argument can be specified for the children of a LayoutContainer.
+// Since any widget can be specified as a LayoutContainer child, mix it
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	layoutAlign: 'none'
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:LayoutContainer&quot;);

Added: trunk/root/static/magic/src/widget/LinkPane.js
===================================================================
--- trunk/root/static/magic/src/widget/LinkPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/LinkPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,17 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.LinkPane&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.LinkPane&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:LinkPane&quot;);
+
+// NOTE: there's no stub file for this widget

Added: trunk/root/static/magic/src/widget/Manager.js
===================================================================
--- trunk/root/static/magic/src/widget/Manager.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Manager.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,306 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Manager&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+// Manager class
+dojo.widget.manager = new function(){
+	this.widgets = [];
+	this.widgetIds = [];
+	
+	// map of widgetId--&gt;widget for widgets without parents (top level widgets)
+	this.topWidgets = {};
+
+	var widgetTypeCtr = {};
+	var renderPrefixCache = [];
+
+	this.getUniqueId = function (widgetType) {
+		return widgetType + &quot;_&quot; + (widgetTypeCtr[widgetType] != undefined ?
+			++widgetTypeCtr[widgetType] : widgetTypeCtr[widgetType] = 0);
+	}
+
+	this.add = function(widget){
+		dojo.profile.start(&quot;dojo.widget.manager.add&quot;);
+		this.widgets.push(widget);
+		// Opera9 uses ID (caps)
+		if(!widget.extraArgs[&quot;id&quot;]){
+			widget.extraArgs[&quot;id&quot;] = widget.extraArgs[&quot;ID&quot;];
+		}
+		// FIXME: the rest of this method is very slow!
+		if(widget.widgetId == &quot;&quot;){
+			if(widget[&quot;id&quot;]){
+				widget.widgetId = widget[&quot;id&quot;];
+			}else if(widget.extraArgs[&quot;id&quot;]){
+				widget.widgetId = widget.extraArgs[&quot;id&quot;];
+			}else{
+				widget.widgetId = this.getUniqueId(widget.widgetType);
+			}
+		}
+		if(this.widgetIds[widget.widgetId]){
+			dojo.debug(&quot;widget ID collision on ID: &quot;+widget.widgetId);
+		}
+		this.widgetIds[widget.widgetId] = widget;
+		// Widget.destroy already calls removeById(), so we don't need to
+		// connect() it here
+		dojo.profile.end(&quot;dojo.widget.manager.add&quot;);
+	}
+
+	this.destroyAll = function(){
+		for(var x=this.widgets.length-1; x&gt;=0; x--){
+			try{
+				// this.widgets[x].destroyChildren();
+				this.widgets[x].destroy(true);
+				delete this.widgets[x];
+			}catch(e){ }
+		}
+	}
+
+	// FIXME: we should never allow removal of the root widget until all others
+	// are removed!
+	this.remove = function(widgetIndex){
+		var tw = this.widgets[widgetIndex].widgetId;
+		delete this.widgetIds[tw];
+		this.widgets.splice(widgetIndex, 1);
+	}
+	
+	// FIXME: suboptimal performance
+	this.removeById = function(id) {
+		for (var i=0; i&lt;this.widgets.length; i++){
+			if(this.widgets[i].widgetId == id){
+				this.remove(i);
+				break;
+			}
+		}
+	}
+
+	this.getWidgetById = function(id){
+		return this.widgetIds[id];
+	}
+
+	this.getWidgetsByType = function(type){
+		var lt = type.toLowerCase();
+		var ret = [];
+		dojo.lang.forEach(this.widgets, function(x){
+			if(x.widgetType.toLowerCase() == lt){
+				ret.push(x);
+			}
+		});
+		return ret;
+	}
+
+	this.getWidgetsOfType = function (id) {
+		dojo.deprecated(&quot;getWidgetsOfType&quot;, &quot;use getWidgetsByType&quot;, &quot;0.4&quot;);
+		return dojo.widget.manager.getWidgetsByType(id);
+	}
+
+	this.getWidgetsByFilter = function(unaryFunc, onlyOne){
+		var ret = [];
+		dojo.lang.every(this.widgets, function(x){
+			if(unaryFunc(x)){
+				ret.push(x);
+				if(onlyOne){return false;}
+			}
+			return true;
+		});
+		return (onlyOne ? ret[0] : ret);
+	}
+
+	this.getAllWidgets = function() {
+		return this.widgets.concat();
+	}
+
+	//	added, trt 2006-01-20
+	this.getWidgetByNode = function(/* DOMNode */ node){
+		var w=this.getAllWidgets();
+		for (var i=0; i&lt;w.length; i++){
+			if (w[i].domNode==node){
+				return w[i];
+			}
+		}
+		return null;
+	}
+
+	// shortcuts, baby
+	this.byId = this.getWidgetById;
+	this.byType = this.getWidgetsByType;
+	this.byFilter = this.getWidgetsByFilter;
+	this.byNode = this.getWidgetByNode;
+
+	// map of previousally discovered implementation names to constructors
+	var knownWidgetImplementations = {};
+
+	// support manually registered widget packages
+	var widgetPackages = [&quot;dojo.widget&quot;];
+	for (var i=0; i&lt;widgetPackages.length; i++) {
+		// convenience for checking if a package exists (reverse lookup)
+		widgetPackages[widgetPackages[i]] = true;
+	}
+
+	this.registerWidgetPackage = function(pname) {
+		if(!widgetPackages[pname]){
+			widgetPackages[pname] = true;
+			widgetPackages.push(pname);
+		}
+	}
+	
+	this.getWidgetPackageList = function() {
+		return dojo.lang.map(widgetPackages, function(elt) { return(elt!==true ? elt : undefined); });
+	}
+	
+	this.getImplementation = function(widgetName, ctorObject, mixins){
+		// try and find a name for the widget
+		var impl = this.getImplementationName(widgetName);
+		if(impl){ 
+			// var tic = new Date();
+			var ret = new impl(ctorObject);
+			// dojo.debug(new Date() - tic);
+			return ret;
+		}
+	}
+
+	this.getImplementationName = function(widgetName){
+		/*
+		 * This is the overly-simplistic implemention of getImplementation (har
+		 * har). In the future, we are going to want something that allows more
+		 * freedom of expression WRT to specifying different specializations of
+		 * a widget.
+		 *
+		 * Additionally, this implementation treats widget names as case
+		 * insensitive, which does not necessarialy mesh with the markup which
+		 * can construct a widget.
+		 */
+
+		var lowerCaseWidgetName = widgetName.toLowerCase();
+
+		var impl = knownWidgetImplementations[lowerCaseWidgetName];
+		if(impl){
+			return impl;
+		}
+
+		// first store a list of the render prefixes we are capable of rendering
+		if(!renderPrefixCache.length){
+			for(var renderer in dojo.render){
+				if(dojo.render[renderer][&quot;capable&quot;] === true){
+					var prefixes = dojo.render[renderer].prefixes;
+					for(var i = 0; i &lt; prefixes.length; i++){
+						renderPrefixCache.push(prefixes[i].toLowerCase());
+					}
+				}
+			}
+			// make sure we don't HAVE to prefix widget implementation names
+			// with anything to get them to render
+			renderPrefixCache.push(&quot;&quot;);
+		}
+
+		// look for a rendering-context specific version of our widget name
+		for(var i = 0; i &lt; widgetPackages.length; i++){
+			var widgetPackage = dojo.evalObjPath(widgetPackages[i]);
+			if(!widgetPackage) { continue; }
+
+			for (var j = 0; j &lt; renderPrefixCache.length; j++) {
+				if (!widgetPackage[renderPrefixCache[j]]) { continue; }
+				for (var widgetClass in widgetPackage[renderPrefixCache[j]]) {
+					if (widgetClass.toLowerCase() != lowerCaseWidgetName) { continue; }
+					knownWidgetImplementations[lowerCaseWidgetName] =
+						widgetPackage[renderPrefixCache[j]][widgetClass];
+					return knownWidgetImplementations[lowerCaseWidgetName];
+				}
+			}
+
+			for (var j = 0; j &lt; renderPrefixCache.length; j++) {
+				for (var widgetClass in widgetPackage) {
+					if (widgetClass.toLowerCase() !=
+						(renderPrefixCache[j] + lowerCaseWidgetName)) { continue; }
+	
+					knownWidgetImplementations[lowerCaseWidgetName] =
+						widgetPackage[widgetClass];
+					return knownWidgetImplementations[lowerCaseWidgetName];
+				}
+			}
+		}
+		
+		throw new Error('Could not locate &quot;' + widgetName + '&quot; class');
+	}
+
+	// FIXME: does it even belong in this name space?
+	// NOTE: this method is implemented by DomWidget.js since not all
+	// hostenv's would have an implementation.
+	/*this.getWidgetFromPrimitive = function(baseRenderType){
+		dojo.unimplemented(&quot;dojo.widget.manager.getWidgetFromPrimitive&quot;);
+	}
+
+	this.getWidgetFromEvent = function(nativeEvt){
+		dojo.unimplemented(&quot;dojo.widget.manager.getWidgetFromEvent&quot;);
+	}*/
+
+	// Catch window resize events and notify top level widgets
+	this.resizing=false;
+	this.onWindowResized = function(){
+		if(this.resizing){
+			return;	// duplicate event
+		}
+		try{
+			this.resizing=true;
+			for(var id in this.topWidgets){
+				var child = this.topWidgets[id];
+				if(child.checkSize ){
+					child.checkSize();
+				}
+			};
+		}catch(e){
+		}finally{
+			this.resizing=false;
+		}
+	}
+	if(typeof window != &quot;undefined&quot;) {
+		dojo.addOnLoad(this, 'onWindowResized');							// initial sizing
+		dojo.event.connect(window, 'onresize', this, 'onWindowResized');	// window resize
+	}
+
+	// FIXME: what else?
+};
+
+(function(){
+	var dw = dojo.widget;
+	var dwm = dw.manager;
+	var h = dojo.lang.curry(dojo.lang, &quot;hitch&quot;, dwm);
+	var g = function(oldName, newName){
+		dw[(newName||oldName)] = h(oldName);
+	}
+	// copy the methods from the default manager (this) to the widget namespace
+	g(&quot;add&quot;, &quot;addWidget&quot;);
+	g(&quot;destroyAll&quot;, &quot;destroyAllWidgets&quot;);
+	g(&quot;remove&quot;, &quot;removeWidget&quot;);
+	g(&quot;removeById&quot;, &quot;removeWidgetById&quot;);
+	g(&quot;getWidgetById&quot;);
+	g(&quot;getWidgetById&quot;, &quot;byId&quot;);
+	g(&quot;getWidgetsByType&quot;);
+	g(&quot;getWidgetsByFilter&quot;);
+	g(&quot;getWidgetsByType&quot;, &quot;byType&quot;);
+	g(&quot;getWidgetsByFilter&quot;, &quot;byFilter&quot;);
+	g(&quot;getWidgetByNode&quot;, &quot;byNode&quot;);
+	dw.all = function(n){
+		var widgets = dwm.getAllWidgets.apply(dwm, arguments);
+		if(arguments.length &gt; 0) {
+			return widgets[n];
+		}
+		return widgets;
+	}
+	g(&quot;registerWidgetPackage&quot;);
+	g(&quot;getImplementation&quot;, &quot;getWidgetImplementation&quot;);
+	g(&quot;getImplementationName&quot;, &quot;getWidgetImplementationName&quot;);
+
+	dw.widgets = dwm.widgets;
+	dw.widgetIds = dwm.widgetIds;
+	dw.root = dwm.root;
+})();

Added: trunk/root/static/magic/src/widget/Menu.js
===================================================================
--- trunk/root/static/magic/src/widget/Menu.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Menu.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,59 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Menu&quot;);
+dojo.provide(&quot;dojo.widget.DomMenu&quot;);
+
+dojo.deprecated(&quot;dojo.widget.Menu, dojo.widget.DomMenu&quot;,  &quot;use dojo.widget.Menu2&quot;, &quot;0.4&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:menu&quot;);
+
+/* Menu
+ *******/
+
+dojo.widget.Menu = function () {
+	dojo.widget.Menu.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.Menu, dojo.widget.Widget);
+
+dojo.lang.extend(dojo.widget.Menu, {
+	widgetType: &quot;Menu&quot;,
+	isContainer: true,
+	
+	items: [],
+	push: function(item){
+		dojo.connect.event(item, &quot;onSelect&quot;, this, &quot;onSelect&quot;);
+		this.items.push(item);
+	},
+	onSelect: function(){}
+});
+
+
+/* DomMenu
+ **********/
+
+dojo.widget.DomMenu = function(){
+	dojo.widget.DomMenu.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.DomMenu, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.DomMenu, {
+	widgetType: &quot;Menu&quot;,
+	isContainer: true,
+
+	push: function (item) {
+		dojo.widget.Menu.call(this, item);
+		this.domNode.appendChild(item.domNode);
+	}
+});
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.Menu&quot;);

Added: trunk/root/static/magic/src/widget/Menu2.js
===================================================================
--- trunk/root/static/magic/src/widget/Menu2.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Menu2.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,1190 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Menu2&quot;);
+dojo.provide(&quot;dojo.widget.html.Menu2&quot;);
+dojo.provide(&quot;dojo.widget.PopupMenu2&quot;);
+dojo.provide(&quot;dojo.widget.MenuItem2&quot;);
+dojo.provide(&quot;dojo.widget.MenuBar2&quot;);
+
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+
+dojo.widget.PopupMenu2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+	this.items = [];	// unused???
+	this.targetNodeIds = []; // fill this with nodeIds upon widget creation and it becomes context menu for those nodes
+	this.queueOnAnimationFinish = [];
+
+	this.eventNames =  {
+		open: &quot;&quot;
+	};
+
+}
+
+dojo.inherits(dojo.widget.PopupMenu2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.PopupMenu2, {
+	widgetType: &quot;PopupMenu2&quot;,
+	isContainer: true,
+
+	snarfChildDomOutput: true,
+
+	currentSubmenu: null,
+	currentSubmenuTrigger: null,
+	parentMenu: null,
+	parentMenuBar: null,
+	isShowingNow: false,
+	menuX: 0,
+	menuY: 0,
+	menuWidth: 0,
+	menuHeight: 0,
+	menuIndex: 0,
+
+	domNode: null,
+	containerNode: null,
+
+	eventNaming: &quot;default&quot;,
+
+
+	templateString: '&lt;div class=&quot;dojoPopupMenu2&quot; style=&quot;left:-9999px; top:-9999px; display: none;&quot;&gt;&lt;div dojoAttachPoint=&quot;containerNode&quot; class=&quot;dojoPopupMenu2Client&quot;&gt;&lt;/div&gt;&lt;/div&gt;',
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlMenu2.css&quot;),
+
+	itemHeight: 18,
+	iconGap: 1,
+	accelGap: 10,
+	submenuGap: 2,
+	finalGap: 5,
+	submenuIconSize: 4,
+	separatorHeight: 9,
+	submenuDelay: 500,
+	submenuOverlap: 5,
+	contextMenuForWindow: false,
+	openEvent: null,
+
+	submenuIconSrc: dojo.uri.dojoUri(&quot;src/widget/templates/images/submenu_off.gif&quot;).toString(),
+	submenuIconOnSrc: dojo.uri.dojoUri(&quot;src/widget/templates/images/submenu_on.gif&quot;).toString(),
+
+	initialize: function(args, frag) {
+
+		if (this.eventNaming == &quot;default&quot;) {
+			for (var eventName in this.eventNames) {
+				this.eventNames[eventName] = this.widgetId+&quot;/&quot;+eventName;
+			}
+		}
+
+	},
+
+	postCreate: function(){
+		if (this.domNode.style.display==&quot;none&quot;){
+			this.domNode.style.display = &quot;&quot;;
+		}
+		this.domNode.style.left = '-9999px'
+		this.domNode.style.top = '-9999px'
+
+		// attach menu to document body if it's not already there
+		if (this.domNode.parentNode != document.body){
+			document.body.appendChild(this.domNode);
+		}
+
+
+		if (this.contextMenuForWindow){
+			var doc = document.documentElement  || document.body;
+			dojo.widget.Menu2.OperaAndKonqFixer.fixNode(doc);
+			dojo.event.connect(doc, &quot;oncontextmenu&quot;, this, &quot;onOpen&quot;);
+		} else if ( this.targetNodeIds.length &gt; 0 ){
+			for(var i=0; i&lt;this.targetNodeIds.length; i++){
+				this.bindDomNode(this.targetNodeIds[i]);
+			}
+		}
+
+		this.subscribeSubitemsOnOpen();
+
+		this.layoutMenuSoon();
+	},
+
+	subscribeSubitemsOnOpen: function() {
+		var subItems = this.getChildrenOfType(dojo.widget.MenuItem2);
+
+		//dojo.debug(subItems)
+
+		for(var i=0; i&lt;subItems.length; i++) {
+			//dojo.debug(subItems[i]);
+			dojo.event.topic.subscribe(this.eventNames.open, subItems[i], &quot;menuOpen&quot;)
+		}
+	},
+
+	// get open event for current menu
+	getTopOpenEvent: function() {
+		var menu = this;
+		while (menu.parent){ menu = menu.parent; }
+		return menu.openEvent;
+	},
+
+	// attach menu to given node
+	bindDomNode: function(nodeName){
+		var node = dojo.byId(nodeName);
+
+		// fixes node so that it supports oncontextmenu if not natively supported, Konqueror, Opera more?
+		dojo.widget.Menu2.OperaAndKonqFixer.fixNode(node);
+
+		dojo.event.kwConnect({
+			srcObj:     node,
+			srcFunc:    &quot;oncontextmenu&quot;,
+			targetObj:  this,
+			targetFunc: &quot;onOpen&quot;,
+			once:       true
+		});
+	},
+
+	// detach menu from given node
+	unBindDomNode: function(nodeName){
+		var node = dojo.byId(nodeName);
+		dojo.event.kwDisconnect({
+			srcObj:     node,
+			srcFunc:    &quot;oncontextmenu&quot;,
+			targetObj:  this,
+			targetFunc: &quot;onOpen&quot;,
+			once:       true
+		});
+
+		// cleans a fixed node, konqueror and opera
+		dojo.widget.Menu2.OperaAndKonqFixer.cleanNode(node);
+	},
+
+	layoutMenuSoon: function(){
+		dojo.lang.setTimeout(this, &quot;layoutMenu&quot;, 0);
+	},
+
+	layoutMenu: function(){
+
+        // menu must be attached to DOM for size calculations to work
+		// even though we attached to document.body in postCreate(), here
+		// we seem to be attached to a #document-fragment.  Don't understand why.
+        document.body.appendChild(this.domNode);
+
+        // determine menu width
+		var max_label_w = 0;
+		var max_accel_w = 0;
+
+		for(var i=0; i&lt;this.children.length; i++){
+			if (this.children[i].getLabelWidth){
+				max_label_w = Math.max(max_label_w, this.children[i].getLabelWidth());
+			}
+
+			if (dojo.lang.isFunction(this.children[i].getAccelWidth)){
+				max_accel_w = Math.max(max_accel_w, this.children[i].getAccelWidth());
+			}
+		}
+
+		if( isNaN(max_label_w) || isNaN(max_accel_w) ){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
+		}
+
+		var clientLeft = dojo.style.getPixelValue(this.domNode, &quot;padding-left&quot;, true) + dojo.style.getPixelValue(this.containerNode, &quot;padding-left&quot;, true);
+		var clientTop  = dojo.style.getPixelValue(this.domNode, &quot;padding-top&quot;, true)  + dojo.style.getPixelValue(this.containerNode, &quot;padding-top&quot;, true);
+
+		if( isNaN(clientLeft) || isNaN(clientTop) ){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
+		}
+
+		var y = clientTop;
+		var max_item_width = 0;
+
+		for(var i=0; i&lt;this.children.length; i++){
+
+			var ch = this.children[i];
+
+			ch.layoutItem(max_label_w, max_accel_w);
+
+			ch.topPosition = y;
+
+			y += dojo.style.getOuterHeight(ch.domNode);
+			max_item_width = Math.max(max_item_width, dojo.style.getOuterWidth(ch.domNode));
+		}
+
+		dojo.style.setContentWidth(this.containerNode, max_item_width);
+		dojo.style.setContentHeight(this.containerNode, y-clientTop);
+
+		dojo.style.setContentWidth(this.domNode, dojo.style.getOuterWidth(this.containerNode));
+		dojo.style.setContentHeight(this.domNode, dojo.style.getOuterHeight(this.containerNode));
+
+		this.menuWidth = dojo.style.getOuterWidth(this.domNode);
+		this.menuHeight = dojo.style.getOuterHeight(this.domNode);
+	},
+
+	/**
+	 * Open the menu at position (x,y), relative to the viewport
+	 * (usually positions are relative to the document; why is this different??)
+	 */
+	open: function(x, y, parent, explodeSrc){
+
+		// if explodeSrc isn't specified then explode from my parent widget
+		explodeSrc = explodeSrc || parent[&quot;domNode&quot;] || [];
+
+		if (this.isShowingNow){ return; }
+
+		var parentMenu = (parent &amp;&amp; parent.widgetType==&quot;PopupMenu2&quot;) ? parent : null;
+
+		if ( !parentMenu ) {
+			// record whenever a top level menu is opened
+			// explodeSrc may or may not be a node - it may also be an [x,y] position array
+			var button = explodeSrc instanceof Array ? null : explodeSrc;
+			dojo.widget.html.Menu2Manager.opened(this, button);
+		}
+
+		//dojo.debug(&quot;open called for animation &quot;+this.animationInProgress)
+
+		// if I click  right button and menu is opened, then it gets 2 commands: close -&gt; open
+		// so close enables animation and next &quot;open&quot; is put to queue to occur at new location
+		if(this.animationInProgress){
+			this.queueOnAnimationFinish.push(this.open, arguments);
+			return;
+		}
+
+		var viewport = dojo.html.getViewportSize();
+		var scrolloffset = dojo.html.getScrollOffset();
+
+		var clientRect = {
+			'left'  : scrolloffset[0],
+			'right' : scrolloffset[0] + viewport[0],
+			'top'   : scrolloffset[1],
+			'bottom': scrolloffset[1] + viewport[1]
+		};
+
+		if (parentMenu){
+			// submenu is opening
+
+			if (x + this.menuWidth &gt; clientRect.right){ x = x - (this.menuWidth + parentMenu.menuWidth - (2 * this.submenuOverlap)); }
+
+			if (y + this.menuHeight &gt; clientRect.bottom){ y = y -
+			(this.menuHeight - (this.itemHeight + 5)); } // TODO: why 5?
+
+		}else{
+			// top level menu is opening
+			x+=scrolloffset[0];
+			y+=scrolloffset[1];
+			explodeSrc[0] += scrolloffset[0];
+			explodeSrc[1] += scrolloffset[1];
+
+			if (x &lt; clientRect.left){ x = clientRect.left; }
+			if (x + this.menuWidth &gt; clientRect.right){ x = x - this.menuWidth; }
+
+			if (y &lt; clientRect.top){ y = clientRect.top; }
+			if (y + this.menuHeight &gt; clientRect.bottom){ y = y - this.menuHeight; }
+		}
+
+		this.parentMenu = parentMenu;
+		this.explodeSrc = explodeSrc;
+		this.menuIndex = parentMenu ? parentMenu.menuIndex + 1 : 1;
+
+		this.menuX = x;
+		this.menuY = y;
+
+		// move the menu into position but make it invisible
+		// (because when menus are initially constructed they are visible but off-screen)
+		this.domNode.style.zIndex = 200 + this.menuIndex;
+		this.domNode.style.left = x + 'px';
+		this.domNode.style.top = y + 'px';
+		this.domNode.style.display='none';
+		this.domNode.style.position='absolute';
+
+		// then use the user defined method to display it
+		this.show();
+
+		this.isShowingNow = true;
+	},
+
+	close: function(){
+		// If we are in the process of opening the menu and we are asked to close it,
+		// we should really cancel the current animation, but for simplicity we will
+		// just ignore the request
+		if(this.animationInProgress){
+			this.queueOnAnimationFinish.push(this.close, []);
+			return;
+		}
+
+		this.closeSubmenu();
+		this.hide();
+		this.isShowingNow = false;
+		dojo.widget.html.Menu2Manager.closed(this);
+
+		if (this.parentMenuBar){
+			this.parentMenuBar.closedMenu(this);
+		}
+	},
+
+	onShow: function() {
+		dojo.widget.HtmlWidget.prototype.onShow.call(this);
+		this.processQueue();
+	},
+
+	// do events from queue
+	processQueue: function() {
+		if (!this.queueOnAnimationFinish.length) return;
+
+		var func = this.queueOnAnimationFinish.shift();
+		var args = this.queueOnAnimationFinish.shift();
+
+		func.apply(this, args);
+	},
+
+	onHide: function() {
+		dojo.widget.HtmlWidget.prototype.onHide.call(this);
+
+		this.processQueue();
+	},
+
+
+	closeAll: function(){
+		if (this.parentMenu){
+			this.parentMenu.closeAll();
+		}else{
+			this.close();
+		}
+	},
+
+	closeSubmenu: function(){
+		if (this.currentSubmenu == null){ return; }
+
+		this.currentSubmenu.close();
+		this.currentSubmenu = null;
+
+		this.currentSubmenuTrigger.is_open = false;
+		this.currentSubmenuTrigger.closedSubmenu();
+		this.currentSubmenuTrigger = null;
+	},
+
+	openSubmenu: function(submenu, from_item){
+
+		var our_x = dojo.style.getPixelValue(this.domNode, 'left');
+		var our_y = dojo.style.getPixelValue(this.domNode, 'top');
+		var our_w = dojo.style.getOuterWidth(this.domNode);
+		var item_y = from_item.topPosition;
+
+		var x = our_x + our_w - this.submenuOverlap;
+		var y = our_y + item_y;
+
+		this.currentSubmenu = submenu;
+		this.currentSubmenu.open(x, y, this, from_item.domNode);
+
+		this.currentSubmenuTrigger = from_item;
+		this.currentSubmenuTrigger.is_open = true;
+	},
+
+	onOpen: function(e){
+		this.openEvent = e;
+
+		//dojo.debugShallow(e);
+		this.open(e.clientX, e.clientY, null, [e.clientX, e.clientY]);
+
+		if(e[&quot;preventDefault&quot;]){
+			e.preventDefault();
+		}
+	},
+
+	isPointInMenu: function(x, y){
+
+		if (x &lt; this.menuX){ return false; }
+		if (x &gt; this.menuX + this.menuWidth){ return false; }
+
+		if (y &lt; this.menuY){ return false; }
+		if (y &gt; this.menuY + this.menuHeight){ return false; }
+
+		return true;
+	}
+});
+
+
+dojo.widget.MenuItem2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+
+	this.eventNames = {
+		engage: &quot;&quot;
+	};
+}
+
+dojo.inherits(dojo.widget.MenuItem2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuItem2, {
+	widgetType: &quot;MenuItem2&quot;,
+	templateString:
+			 '&lt;div class=&quot;dojoMenuItem2&quot;&gt;'
+			+'&lt;div dojoAttachPoint=&quot;iconNode&quot; class=&quot;dojoMenuItem2Icon&quot;&gt;&lt;/div&gt;'
+			+'&lt;span dojoAttachPoint=&quot;labelNode&quot; class=&quot;dojoMenuItem2Label&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'
+			+'&lt;span dojoAttachPoint=&quot;accelNode&quot; class=&quot;dojoMenuItem2Accel&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'
+			+'&lt;div dojoAttachPoint=&quot;submenuNode&quot; class=&quot;dojoMenuItem2Submenu&quot;&gt;&lt;/div&gt;'
+			+'&lt;div dojoAttachPoint=&quot;targetNode&quot; class=&quot;dojoMenuItem2Target&quot; dojoAttachEvent=&quot;onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;&quot;&gt;&nbsp;&lt;/div&gt;'
+			+'&lt;/div&gt;',
+
+	//
+	// nodes
+	//
+
+	domNode: null,
+	iconNode: null,
+	labelNode: null,
+	accelNode: null,
+	submenuNode: null,
+	targetNode: null,
+
+	//
+	// internal settings
+	//
+
+	is_hovering: false,
+	hover_timer: null,
+	is_open: false,
+	topPosition: 0,
+
+	//
+	// options
+	//
+
+	caption: 'Untitled',
+	accelKey: '',
+	iconSrc: '',
+	submenuId: '',
+	disabled: false,
+	eventNaming: &quot;default&quot;,
+
+
+	postCreate: function(){
+
+		dojo.html.disableSelection(this.domNode);
+
+		if (this.disabled){
+			this.setDisabled(true);
+		}
+
+		this.labelNode.childNodes[0].appendChild(document.createTextNode(this.caption));
+		this.accelNode.childNodes[0].appendChild(document.createTextNode(this.accelKey));
+
+		this.labelShadowNode = this.labelNode.childNodes[0].childNodes[0];
+		this.accelShadowNode = this.accelNode.childNodes[0].childNodes[0];
+
+		this.labelShadowNode.appendChild(document.createTextNode(this.caption));
+		this.accelShadowNode.appendChild(document.createTextNode(this.accelKey));
+
+		if (this.eventNaming == &quot;default&quot;) {
+			for (var eventName in this.eventNames) {
+				this.eventNames[eventName] = this.widgetId+&quot;/&quot;+eventName;
+			}
+		}
+	},
+
+	layoutItem: function(label_w, accel_w){
+
+		var x_label = this.parent.itemHeight + this.parent.iconGap;
+		var x_accel = x_label + label_w + this.parent.accelGap;
+		var x_submu = x_accel + accel_w + this.parent.submenuGap;
+		var total_w = x_submu + this.parent.submenuIconSize + this.parent.finalGap;
+
+
+		this.iconNode.style.left = '0px';
+		this.iconNode.style.top = '0px';
+
+
+		if (this.iconSrc){
+
+			if ((this.iconSrc.toLowerCase().substring(this.iconSrc.length-4) == &quot;.png&quot;) &amp;&amp; (dojo.render.html.ie)){
+
+				this.iconNode.style.filter = &quot;progid:DXImageTransform.Microsoft.AlphaImageLoader(src='&quot;+this.iconSrc+&quot;', sizingMethod='image')&quot;;
+				this.iconNode.style.backgroundImage = '';
+			}else{
+				this.iconNode.style.backgroundImage = 'url('+this.iconSrc+')';
+			}
+		}else{
+			this.iconNode.style.backgroundImage = '';
+		}
+
+		dojo.style.setOuterWidth(this.iconNode, this.parent.itemHeight);
+		dojo.style.setOuterHeight(this.iconNode, this.parent.itemHeight);
+
+		dojo.style.setOuterHeight(this.labelNode, this.parent.itemHeight);
+		dojo.style.setOuterHeight(this.accelNode, this.parent.itemHeight);
+
+		dojo.style.setContentWidth(this.domNode, total_w);
+		dojo.style.setContentHeight(this.domNode, this.parent.itemHeight);
+
+		this.labelNode.style.left = x_label + 'px';
+		this.accelNode.style.left = x_accel + 'px';
+		this.submenuNode.style.left = x_submu + 'px';
+
+		dojo.style.setOuterWidth(this.submenuNode, this.parent.submenuIconSize);
+		dojo.style.setOuterHeight(this.submenuNode, this.parent.itemHeight);
+
+		this.submenuNode.style.display = this.submenuId ? 'block' : 'none';
+		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconSrc+')';
+
+		dojo.style.setOuterWidth(this.targetNode, total_w);
+		dojo.style.setOuterHeight(this.targetNode, this.parent.itemHeight);
+	},
+
+	onHover: function(){
+
+		if (this.is_hovering){ return; }
+		if (this.is_open){ return; }
+
+		this.parent.closeSubmenu();
+		this.highlightItem();
+
+		if (this.is_hovering){ this.stopSubmenuTimer(); }
+		this.is_hovering = true;
+		this.startSubmenuTimer();
+	},
+
+	onUnhover: function(){
+		if (!this.is_open){ this.unhighlightItem(); }
+
+		this.is_hovering = false;
+		this.stopSubmenuTimer();
+	},
+
+	// Internal function for clicks
+	_onClick: function(){
+		if (this.disabled){ return; }
+
+		if (this.submenuId){
+			if (!this.is_open){
+				this.stopSubmenuTimer();
+				this.openSubmenu();
+			}
+		}else{
+			this.parent.closeAll();
+		}
+
+		// for some browsers the onMouseOut doesn't get called (?), so call it manually
+		this.onUnhover();
+
+		// user defined handler for click
+		this.onClick();
+
+		dojo.event.topic.publish(this.eventNames.engage, this);
+	},
+
+	// User defined function to handle clicks
+	onClick: function() { },
+
+	highlightItem: function(){
+		dojo.html.addClass(this.domNode, 'dojoMenuItem2Hover');
+		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconOnSrc+')';
+	},
+
+	unhighlightItem: function(){
+		dojo.html.removeClass(this.domNode, 'dojoMenuItem2Hover');
+		this.submenuNode.style.backgroundImage = 'url('+this.parent.submenuIconSrc+')';
+	},
+
+	startSubmenuTimer: function(){
+		this.stopSubmenuTimer();
+
+		if (this.disabled){ return; }
+
+		var self = this;
+		var closure = function(){ return function(){ self.openSubmenu(); } }();
+
+		this.hover_timer = window.setTimeout(closure, this.parent.submenuDelay);
+	},
+
+	stopSubmenuTimer: function(){
+		if (this.hover_timer){
+			window.clearTimeout(this.hover_timer);
+			this.hover_timer = null;
+		}
+	},
+
+	openSubmenu: function(){
+		// first close any other open submenu
+		this.parent.closeSubmenu();
+
+		var submenu = dojo.widget.getWidgetById(this.submenuId);
+		if (submenu){
+
+			this.parent.openSubmenu(submenu, this);
+		}
+
+		//dojo.debug('open submenu for item '+this.widgetId);
+	},
+
+	closedSubmenu: function(){
+
+		this.onUnhover();
+	},
+
+	setDisabled: function(value){
+		this.disabled = value;
+
+		if (this.disabled){
+			dojo.html.addClass(this.domNode, 'dojoMenuItem2Disabled');
+		}else{
+			dojo.html.removeClass(this.domNode, 'dojoMenuItem2Disabled');
+		}
+	},
+
+	getLabelWidth: function(){
+
+		var node = this.labelNode.childNodes[0];
+
+		return dojo.style.getOuterWidth(node);
+	},
+
+	getAccelWidth: function(){
+
+		var node = this.accelNode.childNodes[0];
+
+		return dojo.style.getOuterWidth(node);
+	},
+
+	menuOpen: function(message) {
+	}
+
+});
+
+
+dojo.widget.MenuSeparator2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.MenuSeparator2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuSeparator2, {
+	widgetType: &quot;MenuSeparator2&quot;,
+
+	domNode: null,
+	topNode: null,
+	bottomNode: null,
+
+	templateString: '&lt;div class=&quot;dojoMenuSeparator2&quot;&gt;'
+			+'&lt;div dojoAttachPoint=&quot;topNode&quot; class=&quot;dojoMenuSeparator2Top&quot;&gt;&lt;/div&gt;'
+			+'&lt;div dojoAttachPoint=&quot;bottomNode&quot; class=&quot;dojoMenuSeparator2Bottom&quot;&gt;&lt;/div&gt;'
+			+'&lt;/div&gt;',
+
+	postCreate: function(){
+		dojo.html.disableSelection(this.domNode);
+		this.layoutItem();
+	},
+
+	layoutItem: function(label_w, accel_w){
+
+		var full_width = this.parent.itemHeight
+				+ this.parent.iconGap
+				+ label_w
+				+ this.parent.accelGap
+				+ accel_w
+				+ this.parent.submenuGap
+				+ this.parent.submenuIconSize
+				+ this.parent.finalGap;
+
+		if (isNaN(full_width)){ return; }
+
+		dojo.style.setContentHeight(this.domNode, this.parent.separatorHeight);
+		dojo.style.setContentWidth(this.domNode, full_width);
+	}
+});
+
+//
+// the menu manager makes sure we don't have several menus
+// open at once. the root menu in an opening sequence calls
+// opened(). when a root menu closes it calls closed(). then
+// everything works. lovely.
+//
+
+dojo.widget.html.Menu2Manager = new function(){
+
+	this.currentMenu = null;
+	this.currentButton = null;		// button that opened current menu (if any)
+	this.focusNode = null;
+
+	dojo.event.connect(document, 'onmousedown', this, 'onClick');
+	dojo.event.connect(window, &quot;onscroll&quot;, this, &quot;onClick&quot;);
+
+	this.closed = function(menu){
+		if (this.currentMenu == menu){
+			this.currentMenu = null;
+			this.currentButton = null;
+		}
+	};
+
+	this.opened = function(menu, button){
+		if (menu == this.currentMenu){ return; }
+
+		if (this.currentMenu){
+			this.currentMenu.close();
+		}
+
+		this.currentMenu = menu;
+		this.currentButton = button;
+	};
+
+	this.onClick = function(e){
+
+		if (!this.currentMenu){ return; }
+
+		var scrolloffset = dojo.html.getScrollOffset();
+
+		var x = e.clientX + scrolloffset[0];
+		var y = e.clientY + scrolloffset[1];
+
+		var m = this.currentMenu;
+
+		// starting from the base menu, perform a hit test
+		// and exit when one succeeds
+
+		while (m){
+
+			if (m.isPointInMenu(x, y)){
+
+				return;
+			}
+
+			m = m.currentSubmenu;
+		}
+
+		// Also, if user clicked the button that opened this menu, then
+		// that button will send the menu a close() command, so this code
+		// shouldn't try to close the menu.  Closing twice messes up animation.
+		if (this.currentButton &amp;&amp; dojo.html.overElement(this.currentButton, e)){
+			return;
+		}
+
+		// the click didn't fall within the open menu tree
+		// so close it
+
+		this.currentMenu.close();
+	};
+}
+
+// ************************** make contextmenu work in konqueror and opera *********************
+dojo.widget.Menu2.OperaAndKonqFixer = new function(){
+ 	var implement = true;
+ 	var delfunc = false;
+
+ 	/** 	dom event check
+ 	*
+ 	*	make a event and dispatch it and se if it calls function below,
+ 	*	if it does its supported and we dont need to implement our own
+ 	*/
+
+ 	// gets called if we have support for oncontextmenu
+ 	if (!dojo.lang.isFunction(document.oncontextmenu)){
+ 		document.oncontextmenu = function(){
+ 			implement = false;
+ 			delfunc = true;
+ 		}
+ 	}
+
+ 	if (document.createEvent){ // moz, safari has contextmenu event, need to do livecheck on this env.
+ 		try {
+ 			var e = document.createEvent(&quot;MouseEvents&quot;);
+ 			e.initMouseEvent(&quot;contextmenu&quot;, 1, 1, window, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, null);
+ 			document.dispatchEvent(e);
+ 		} catch (e) {/* assume not supported */}
+ 	} else {
+ 		// IE no need to implement custom contextmenu
+ 		implement = false;
+ 	}
+
+ 	// clear this one if it wasn't there before
+ 	if (delfunc){
+ 		delete document.oncontextmenu;
+ 	}
+ 	/***** end dom event check *****/
+
+
+ 	/**
+ 	*	this fixes a dom node by attaching a custom oncontextmenu function that gets called when apropriate
+ 	*	@param	node	a dom node
+ 	*
+ 	*	no returns
+ 	*/
+ 	this.fixNode = function(node){
+ 		if (implement){
+ 			// attach stub oncontextmenu function
+ 			if (!dojo.lang.isFunction(node.oncontextmenu)){
+ 				node.oncontextmenu = function(e){/*stub*/}
+ 			}
+
+ 			// attach control function for oncontextmenu
+ 			if (window.opera){
+ 				// opera
+ 				// listen to ctrl-click events
+ 				node._menufixer_opera = function(e){
+ 					if (e.ctrlKey){
+ 						this.oncontextmenu(e);
+ 					}
+ 				};
+
+ 				dojo.event.connect(node, &quot;onclick&quot;, node, &quot;_menufixer_opera&quot;);
+
+ 			} else {
+ 				// konqueror
+ 				// rightclick, listen to mousedown events
+ 				node._menufixer_konq = function(e){
+ 					if (e.button==2 ){
+ 						e.preventDefault(); // need to prevent browsers menu
+ 						this.oncontextmenu(e);
+ 					}
+ 				};
+
+ 				dojo.event.connect(node, &quot;onmousedown&quot;, node, &quot;_menufixer_konq&quot;);
+ 			}
+ 		}
+ 	}
+
+ 	/**
+ 	*	this cleans up a fixed node, prevent memoryleak?
+ 	*	@param node	node to clean
+ 	*
+ 	*	no returns
+ 	*/
+ 	this.cleanNode = function(node){
+ 		if (implement){
+ 			// checks needed if we gets a non fixed node
+ 			if (node._menufixer_opera){
+ 				dojo.event.disconnect(node, &quot;onclick&quot;, node, &quot;_menufixer_opera&quot;);
+ 				delete node._menufixer_opera;
+ 			} else if(node._menufixer_konq){
+ 				dojo.event.disconnect(node, &quot;onmousedown&quot;, node, &quot;_menufixer_konq&quot;);
+ 				delete node._menufixer_konq;
+ 			}
+ 			if (node.oncontextmenu){
+ 				delete node.oncontextmenu;
+ 			}
+ 		}
+ 	}
+};
+
+
+dojo.widget.MenuBar2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.MenuBar2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuBar2, {
+	widgetType: &quot;MenuBar2&quot;,
+	isContainer: true,
+
+	snarfChildDomOutput: true,
+
+	currentItem: null,
+	isExpanded: false,
+
+	currentSubmenu: null,
+	currentSubmenuTrigger: null,
+
+	domNode: null,
+	containerNode: null,
+
+	templateString: '&lt;div class=&quot;dojoMenuBar2&quot;&gt;&lt;div dojoAttachPoint=&quot;containerNode&quot; class=&quot;dojoMenuBar2Client&quot;&gt;&lt;/div&gt;&lt;/div&gt;',
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlMenu2.css&quot;),
+
+	itemHeight: 18,
+	openEvent: null,
+
+
+	postCreate: function(){
+
+		// do something here
+
+		this.layoutMenuSoon();
+	},
+
+	layoutMenuSoon: function(){
+		dojo.lang.setTimeout(this, &quot;layoutMenu&quot;, 0);
+	},
+
+	layoutMenu: function(){
+
+		// menu must be attached to DOM for size calculations to work
+
+		var parent = this.domNode.parentNode;
+		if (! parent || parent == undefined) {
+			document.body.appendChild(this.domNode);
+		}
+
+
+		// determine menu height
+
+		var max_label_h = 0;
+
+		for(var i=0; i&lt;this.children.length; i++){
+
+			if (this.children[i].getLabelHeight){
+
+				max_label_h = Math.max(max_label_h, this.children[i].getLabelHeight());
+			}
+		}
+
+		if (isNaN(max_label_h)){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
+		}
+
+		var clientLeft = dojo.style.getPixelValue(this.domNode, &quot;padding-left&quot;, true)
+				+ dojo.style.getPixelValue(this.containerNode, &quot;margin-left&quot;, true)
+				+ dojo.style.getPixelValue(this.containerNode, &quot;padding-left&quot;, true);
+		var clientTop  = dojo.style.getPixelValue(this.domNode, &quot;padding-top&quot;, true)
+				+ dojo.style.getPixelValue(this.containerNode, &quot;padding-top&quot;, true);
+
+		if (isNaN(clientLeft) || isNaN(clientTop)){
+			// Browser needs some more time to calculate sizes
+			this.layoutMenuSoon();
+			return;
+		}
+
+		var max_item_height = 0;
+		var x = clientLeft;
+
+		for (var i=0; i&lt;this.children.length; i++){
+
+			var ch = this.children[i];
+
+			ch.layoutItem(max_label_h);
+
+			ch.leftPosition = x;
+			ch.domNode.style.left = x + 'px';
+
+			x += dojo.style.getOuterWidth(ch.domNode);
+			max_item_height = Math.max(max_item_height, dojo.style.getOuterHeight(ch.domNode));
+		}
+
+		dojo.style.setContentHeight(this.containerNode, max_item_height);
+		dojo.style.setContentHeight(this.domNode, dojo.style.getOuterHeight(this.containerNode));
+	},
+
+	openSubmenu: function(submenu, from_item){
+
+		var our_pos = dojo.style.getAbsolutePosition(this.domNode, false);
+
+		var our_h = dojo.style.getOuterHeight(this.domNode);
+		var item_x = from_item.leftPosition;
+
+		var x = our_pos.x + item_x;
+		var y = our_pos.y + our_h;
+
+		this.currentSubmenu = submenu;
+		this.currentSubmenu.open(x, y, this, from_item.domNode);
+		this.currentSubmenu.parentMenuBar = this;
+	},
+
+	closeSubmenu: function(){
+
+		if (this.currentSubmenu == null){ return; }
+
+		var menu = this.currentSubmenu;
+		this.currentSubmenu = null;
+		menu.close();
+	},
+
+	itemHover: function(item){
+
+		if (item == this.currentItem) return;
+
+		if (this.currentItem){
+			this.currentItem.unhighlightItem();
+
+			if (this.isExpanded){
+				this.closeSubmenu();
+			}
+		}
+
+		this.currentItem = item;
+		this.currentItem.highlightItem();
+
+		if (this.isExpanded){
+			this.currentItem.expandMenu();
+		}
+	},
+
+	itemUnhover: function(item){
+
+		if (item != this.currentItem) return;
+
+		if (this.currentItem &amp;&amp; !this.isExpanded){
+			this.currentItem.unhighlightItem();
+			this.currentItem = null;
+		}
+	},
+
+	itemClick: function(item){
+
+		if (item != this.currentItem){
+
+			this.itemHover(item);
+		}
+
+		if (this.isExpanded){
+
+			this.isExpanded = false;
+			this.closeSubmenu();
+
+		}else{
+
+			this.isExpanded = true;
+			this.currentItem.expandMenu();
+		}
+	},
+
+	closedMenu: function(menu){
+
+		if (this.currentSubmenu == menu){
+
+			this.isExpanded = false;
+			this.itemUnhover(this.currentItem);
+		}
+	}
+});
+
+
+dojo.widget.MenuBarItem2 = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.MenuBarItem2, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.MenuBarItem2, {
+
+	widgetType: &quot;MenuBarItem2&quot;,
+	templateString:
+			 '&lt;div class=&quot;dojoMenuBarItem2&quot;&gt;'
+			+'&lt;span dojoAttachPoint=&quot;labelNode&quot; class=&quot;dojoMenuBarItem2Label&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;'
+			+'&lt;div dojoAttachPoint=&quot;targetNode&quot; class=&quot;dojoMenuBarItem2Target&quot; dojoAttachEvent=&quot;onMouseOver: onHover; onMouseOut: onUnhover; onClick: _onClick;&quot;&gt;&nbsp;&lt;/div&gt;'
+			+'&lt;/div&gt;',
+
+	//
+	// nodes
+	//
+
+	domNode: null,
+	labelNode: null,
+	targetNode: null,
+
+	//
+	// internal settings
+	//
+
+	is_hovering: false,
+	hover_timer: null,
+	is_open: false,
+
+	//
+	// options
+	//
+
+	caption: 'Untitled',
+	accelKey: '',
+	iconSrc: '',
+	submenuId: '',
+	disabled: false,
+	eventNaming: &quot;default&quot;,
+
+
+	postCreate: function(){
+
+		dojo.html.disableSelection(this.domNode);
+
+		if (this.disabled){
+			this.setDisabled(true);
+		}
+
+		this.labelNode.childNodes[0].appendChild(document.createTextNode(this.caption));
+
+		this.labelShadowNode = this.labelNode.childNodes[0].childNodes[0];
+		this.labelShadowNode.appendChild(document.createTextNode(this.caption));
+
+		if (this.eventNaming == &quot;default&quot;) {
+			for (var eventName in this.eventNames) {
+				this.eventNames[eventName] = this.widgetId+&quot;/&quot;+eventName;
+			}
+		}
+	},
+
+	layoutItem: function(item_h){
+
+		var label_w = dojo.style.getOuterWidth(this.labelNode);
+
+		var clientLeft = dojo.style.getPixelValue(this.domNode, &quot;padding-left&quot;, true);
+		var clientTop  = dojo.style.getPixelValue(this.domNode, &quot;padding-top&quot;, true);
+
+		this.labelNode.style.left = clientLeft + 'px';
+
+		dojo.style.setOuterHeight(this.labelNode, item_h);
+		dojo.style.setContentWidth(this.domNode, label_w);
+		dojo.style.setContentHeight(this.domNode, item_h);
+
+		this.labelNode.style.left = '0px';
+
+		dojo.style.setOuterWidth(this.targetNode, label_w);
+		dojo.style.setOuterHeight(this.targetNode, item_h);
+	},
+
+	getLabelHeight: function(){
+
+		return dojo.style.getOuterHeight(this.labelNode);
+	},
+
+	onHover: function(){
+		this.parent.itemHover(this);
+	},
+
+	onUnhover: function(){
+		this.parent.itemUnhover(this);
+	},
+
+	_onClick: function(){
+		this.parent.itemClick(this);
+	},
+
+	highlightItem: function(){
+		dojo.html.addClass(this.domNode, 'dojoMenuBarItem2Hover');
+	},
+
+	unhighlightItem: function(){
+		dojo.html.removeClass(this.domNode, 'dojoMenuBarItem2Hover');
+	},
+
+	expandMenu: function(){
+
+		var submenu = dojo.widget.getWidgetById(this.submenuId);
+		if (submenu){
+
+			this.parent.openSubmenu(submenu, this);
+		}
+	},
+
+	setDisabled: function(value){
+		this.disabled = value;
+
+		if (this.disabled){
+			dojo.html.addClass(this.domNode, 'dojoMenuBarItem2Disabled');
+		}else{
+			dojo.html.removeClass(this.domNode, 'dojoMenuBarItem2Disabled');
+		}
+	}
+});
+
+// make it a tag
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:MenuBar2&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:MenuBarItem2&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:PopupMenu2&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:MenuItem2&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:MenuSeparator2&quot;);
+

Added: trunk/root/static/magic/src/widget/MenuItem.js
===================================================================
--- trunk/root/static/magic/src/widget/MenuItem.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/MenuItem.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,47 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.MenuItem&quot;);
+dojo.provide(&quot;dojo.widget.DomMenuItem&quot;);
+
+dojo.deprecated(&quot;dojo.widget.MenuItem, dojo.widget.DomMenuItem&quot;,  &quot;use dojo.widget.Menu2&quot;, &quot;0.4&quot;);
+
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:MenuItem&quot;);
+
+/* MenuItem
+ ***********/
+ 
+dojo.widget.MenuItem = function(){
+	dojo.widget.MenuItem.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.MenuItem, dojo.widget.Widget);
+
+dojo.lang.extend(dojo.widget.MenuItem, {
+	widgetType: &quot;MenuItem&quot;,
+	isContainer: true
+});
+
+
+/* DomMenuItem
+ **************/
+dojo.widget.DomMenuItem = function(){
+	dojo.widget.DomMenuItem.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.DomMenuItem, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.DomMenuItem, {
+	widgetType: &quot;MenuItem&quot;
+});
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.html&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.MenuItem&quot;);

Added: trunk/root/static/magic/src/widget/MonthlyCalendar.js
===================================================================
--- trunk/root/static/magic/src/widget/MonthlyCalendar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/MonthlyCalendar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,74 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.MonthlyCalendar&quot;);
+dojo.provide(&quot;dojo.widget.MonthlyCalendar.util&quot;);
+dojo.require(&quot;dojo.widget.DomWidget&quot;);
+dojo.require(&quot;dojo.date&quot;);
+
+dojo.widget.MonthlyCalendar= function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = &quot;MonthlyCalendar&quot;;
+	this.isContainer = false;
+	// the following aliases prevent breaking people using 0.2.x
+	this.months = dojo.date.months;
+	this.weekdays = dojo.date.days;
+	this.toRfcDate = dojo.widget.MonthlyCalendar.util.toRfcDate;
+	this.fromRfcDate = dojo.widget.MonthlyCalendar.util.fromRfcDate;
+	this.initFirstSaturday = dojo.widget.MonthlyCalendar.util.initFirstSaturday;
+}
+
+dojo.inherits(dojo.widget.MonthlyCalendar, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:monthlycalendar&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.MonthlyCalendar&quot;);
+
+dojo.widget.MonthlyCalendar.util= new function() {
+	this.months = dojo.date.months;
+	this.weekdays = dojo.date.days;
+	
+	this.toRfcDate = function(jsDate) {
+		if(!jsDate) {
+			jsDate = this.today;
+		}
+		var year = jsDate.getFullYear();
+		var month = jsDate.getMonth() + 1;
+		if (month &lt; 10) {
+			month = &quot;0&quot; + month.toString();
+		}
+		var date = jsDate.getDate();
+		if (date &lt; 10) {
+			date = &quot;0&quot; + date.toString();
+		}
+		// because this is a date picker and not a time picker, we treat time 
+		// as zero
+		return year + &quot;-&quot; + month + &quot;-&quot; + date + &quot;T00:00:00+00:00&quot;;
+	}
+	
+	this.fromRfcDate = function(rfcDate) {
+		var tempDate = rfcDate.split(&quot;-&quot;);
+		if(tempDate.length &lt; 3) {
+			return new Date();
+		}
+		// fullYear, month, date
+		return new Date(parseInt(tempDate[0]), (parseInt(tempDate[1], 10) - 1), parseInt(tempDate[2].substr(0,2), 10));
+	}
+	
+	this.initFirstSaturday = function(month, year) {
+		if(!month) {
+			month = this.date.getMonth();
+		}
+		if(!year) {
+			year = this.date.getFullYear();
+		}
+		var firstOfMonth = new Date(year, month, 1);
+		return {year: year, month: month, date: 7 - firstOfMonth.getDay()};
+	}
+}

Added: trunk/root/static/magic/src/widget/Parse.js
===================================================================
--- trunk/root/static/magic/src/widget/Parse.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Parse.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,312 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Parse&quot;);
+
+dojo.require(&quot;dojo.widget.Manager&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+
+dojo.widget.Parse = function(fragment) {
+	this.propertySetsList = [];
+	this.fragment = fragment;
+	
+	this.createComponents = function(frag, parentComp){
+		var comps = [ ];
+		var built = false;
+		// if we have items to parse/create at this level, do it!
+		try{
+			if((frag)&amp;&amp;(frag[&quot;tagName&quot;])&amp;&amp;(frag!=frag[&quot;nodeRef&quot;])){
+				var djTags = dojo.widget.tags;
+				// we split so that you can declare multiple
+				// non-destructive widgets from the same ctor node
+				var tna = String(frag[&quot;tagName&quot;]).split(&quot;;&quot;);
+				for(var x=0; x&lt;tna.length; x++){
+					var ltn = (tna[x].replace(/^\s+|\s+$/g, &quot;&quot;)).toLowerCase();
+					if(djTags[ltn]){
+						built = true;
+						frag.tagName = ltn;
+						var ret = djTags[ltn](frag, this, parentComp, frag[&quot;index&quot;]);
+						comps.push(ret);
+					}else{
+						if((dojo.lang.isString(ltn))&amp;&amp;(ltn.substr(0, 5)==&quot;dojo:&quot;)){
+							dojo.debug(&quot;no tag handler registed for type: &quot;, ltn);
+						}
+					}
+				}
+			}
+		}catch(e){
+			dojo.debug(&quot;dojo.widget.Parse: error:&quot;, e);
+			// throw(e);
+			// IE is such a bitch sometimes
+		}
+		// if there's a sub-frag, build widgets from that too
+		if(!built){
+			comps = comps.concat(this.createSubComponents(frag, parentComp));
+		}
+		return comps;
+	}
+
+	/*	createSubComponents recurses over a raw JavaScript object structure,
+			and calls the corresponding handler for its normalized tagName if it exists
+	*/
+	this.createSubComponents = function(fragment, parentComp){
+		var frag, comps = [];
+		for(var item in fragment){
+			frag = fragment[item];
+			if ((frag)&amp;&amp;(typeof frag == &quot;object&quot;)&amp;&amp;(frag!=fragment.nodeRef)&amp;&amp;(frag!=fragment[&quot;tagName&quot;])){
+				comps = comps.concat(this.createComponents(frag, parentComp));
+			}
+		}
+		return comps;
+	}
+
+	/*  parsePropertySets checks the top level of a raw JavaScript object
+			structure for any propertySets.  It stores an array of references to 
+			propertySets that it finds.
+	*/
+	this.parsePropertySets = function(fragment) {
+		return [];
+		var propertySets = [];
+		for(var item in fragment){
+			if(	(fragment[item][&quot;tagName&quot;] == &quot;dojo:propertyset&quot;) ) {
+				propertySets.push(fragment[item]);
+			}
+		}
+		// FIXME: should we store these propertySets somewhere for later retrieval
+		this.propertySetsList.push(propertySets);
+		return propertySets;
+	}
+	
+	/*  parseProperties checks a raw JavaScript object structure for
+			properties, and returns an array of properties that it finds.
+	*/
+	this.parseProperties = function(fragment) {
+		var properties = {};
+		for(var item in fragment){
+			// FIXME: need to check for undefined?
+			// case: its a tagName or nodeRef
+			if((fragment[item] == fragment[&quot;tagName&quot;])||
+				(fragment[item] == fragment.nodeRef)){
+				// do nothing
+			}else{
+				if((fragment[item][&quot;tagName&quot;])&amp;&amp;
+					(dojo.widget.tags[fragment[item].tagName.toLowerCase()])){
+					// TODO: it isn't a property or property set, it's a fragment, 
+					// so do something else
+					// FIXME: needs to be a better/stricter check
+					// TODO: handle xlink:href for external property sets
+				}else if((fragment[item][0])&amp;&amp;(fragment[item][0].value!=&quot;&quot;)&amp;&amp;(fragment[item][0].value!=null)){
+					try{
+						// FIXME: need to allow more than one provider
+						if(item.toLowerCase() == &quot;dataprovider&quot;) {
+							var _this = this;
+							this.getDataProvider(_this, fragment[item][0].value);
+							properties.dataProvider = this.dataProvider;
+						}
+						properties[item] = fragment[item][0].value;
+						var nestedProperties = this.parseProperties(fragment[item]);
+						// FIXME: this kind of copying is expensive and inefficient!
+						for(var property in nestedProperties){
+							properties[property] = nestedProperties[property];
+						}
+					}catch(e){ dojo.debug(e); }
+				}
+			}
+		}
+		return properties;
+	}
+
+	/* getPropertySetById returns the propertySet that matches the provided id
+	*/
+	
+	this.getDataProvider = function(objRef, dataUrl) {
+		// FIXME: this is currently sync.  To make this async, we made need to move 
+		//this step into the widget ctor, so that it is loaded when it is needed 
+		// to populate the widget
+		dojo.io.bind({
+			url: dataUrl,
+			load: function(type, evaldObj){
+				if(type==&quot;load&quot;){
+					objRef.dataProvider = evaldObj;
+				}
+			},
+			mimetype: &quot;text/javascript&quot;,
+			sync: true
+		});
+	}
+
+	
+	this.getPropertySetById = function(propertySetId){
+		for(var x = 0; x &lt; this.propertySetsList.length; x++){
+			if(propertySetId == this.propertySetsList[x][&quot;id&quot;][0].value){
+				return this.propertySetsList[x];
+			}
+		}
+		return &quot;&quot;;
+	}
+	
+	/* getPropertySetsByType returns the propertySet(s) that match(es) the
+	 * provided componentClass
+	 */
+	this.getPropertySetsByType = function(componentType){
+		var propertySets = [];
+		for(var x=0; x &lt; this.propertySetsList.length; x++){
+			var cpl = this.propertySetsList[x];
+			var cpcc = cpl[&quot;componentClass&quot;]||cpl[&quot;componentType&quot;]||null;
+			// FIXME: propertySetId is not in scope here
+			if((cpcc)&amp;&amp;(propertySetId == cpcc[0].value)){
+				propertySets.push(cpl);
+			}
+		}
+		return propertySets;
+	}
+	
+	/* getPropertySets returns the propertySet for a given component fragment
+	*/
+	this.getPropertySets = function(fragment){
+		var ppl = &quot;dojo:propertyproviderlist&quot;;
+		var propertySets = [];
+		var tagname = fragment[&quot;tagName&quot;];
+		if(fragment[ppl]){ 
+			var propertyProviderIds = fragment[ppl].value.split(&quot; &quot;);
+			// FIXME: should the propertyProviderList attribute contain #
+			// 		  syntax for reference to ids or not?
+			// FIXME: need a better test to see if this is local or external
+			// FIXME: doesn't handle nested propertySets, or propertySets that
+			// 		  just contain information about css documents, etc.
+			for(var propertySetId in propertyProviderIds){
+				if((propertySetId.indexOf(&quot;..&quot;)==-1)&amp;&amp;(propertySetId.indexOf(&quot;://&quot;)==-1)){
+					// get a reference to a propertySet within the current parsed structure
+					var propertySet = this.getPropertySetById(propertySetId);
+					if(propertySet != &quot;&quot;){
+						propertySets.push(propertySet);
+					}
+				}else{
+					// FIXME: add code to parse and return a propertySet from
+					// another document
+					// alex: is this even necessaray? Do we care? If so, why?
+				}
+			}
+		}
+		// we put the typed ones first so that the parsed ones override when
+		// iteration happens.
+		return (this.getPropertySetsByType(tagname)).concat(propertySets);
+	}
+	
+	/* 
+		nodeRef is the node to be replaced... in the future, we might want to add 
+		an alternative way to specify an insertion point
+
+		componentName is the expected dojo widget name, i.e. Button of ContextMenu
+
+		properties is an object of name value pairs
+	*/
+	this.createComponentFromScript = function(nodeRef, componentName, properties){
+		var ltn = &quot;dojo:&quot; + componentName.toLowerCase();
+		if(dojo.widget.tags[ltn]){
+			properties.fastMixIn = true;
+			return [dojo.widget.tags[ltn](properties, this, null, null, properties)];
+		}else{
+			if(ltn.substr(0, 5)==&quot;dojo:&quot;){
+				dojo.debug(&quot;no tag handler registed for type: &quot;, ltn);
+			}
+		}
+	}
+}
+
+
+dojo.widget._parser_collection = {&quot;dojo&quot;: new dojo.widget.Parse() };
+dojo.widget.getParser = function(name){
+	if(!name){ name = &quot;dojo&quot;; }
+	if(!this._parser_collection[name]){
+		this._parser_collection[name] = new dojo.widget.Parse();
+	}
+	return this._parser_collection[name];
+}
+
+/**
+ * Creates widget.
+ *
+ * @param name     The name of the widget to create
+ * @param props    Key-Value pairs of properties of the widget
+ * @param refNode  If the last argument is specified this node is used as
+ *                 a reference for inserting this node into a DOM tree else
+ *                 it beomces the domNode
+ * @param position The position to insert this widget's node relative to the
+ *                 refNode argument
+ * @return The new Widget object
+ */
+ 
+dojo.widget.createWidget = function(name, props, refNode, position){
+	var lowerCaseName = name.toLowerCase();
+	var namespacedName = &quot;dojo:&quot; + lowerCaseName;
+	var isNode = ( dojo.byId(name) &amp;&amp; (!dojo.widget.tags[namespacedName]) );
+
+	// if we got a node or an unambiguious ID, build a widget out of it
+	if(	(arguments.length==1) &amp;&amp; ((typeof name != &quot;string&quot;)||(isNode)) ){
+		// we got a DOM node
+		var xp = new dojo.xml.Parse();
+		// FIXME: we should try to find the parent!
+		var tn = (isNode) ? dojo.byId(name) : name;
+		return dojo.widget.getParser().createComponents(xp.parseElement(tn, null, true))[0];
+	}
+
+	function fromScript (placeKeeperNode, name, props) {
+		props[namespacedName] = { 
+			dojotype: [{value: lowerCaseName}],
+			nodeRef: placeKeeperNode,
+			fastMixIn: true
+		};
+		return dojo.widget.getParser().createComponentFromScript(
+			placeKeeperNode, name, props, true);
+	}
+
+	if (typeof name != &quot;string&quot; &amp;&amp; typeof props == &quot;string&quot;) {
+		dojo.deprecated(&quot;dojo.widget.createWidget&quot;, 
+			&quot;argument order is now of the form &quot; +
+			&quot;dojo.widget.createWidget(NAME, [PROPERTIES, [REFERENCENODE, [POSITION]]])&quot;, &quot;0.4&quot;);
+		return fromScript(name, props, refNode);
+	}
+	
+	props = props||{};
+	var notRef = false;
+	var tn = null;
+	var h = dojo.render.html.capable;
+	if(h){
+		tn = document.createElement(&quot;span&quot;);
+	}
+	if(!refNode){
+		notRef = true;
+		refNode = tn;
+		if(h){
+			document.body.appendChild(refNode);
+		}
+	}else if(position){
+		dojo.dom.insertAtPosition(tn, refNode, position);
+	}else{ // otherwise don't replace, but build in-place
+		tn = refNode;
+	}
+	var widgetArray = fromScript(tn, name, props);
+	if (!widgetArray || !widgetArray[0] || typeof widgetArray[0].widgetType == &quot;undefined&quot;) {
+		throw new Error(&quot;createWidget: Creation of \&quot;&quot; + name + &quot;\&quot; widget failed.&quot;);
+	}
+	if (notRef) {
+		if (widgetArray[0].domNode.parentNode) {
+			widgetArray[0].domNode.parentNode.removeChild(widgetArray[0].domNode);
+		}
+	}
+	return widgetArray[0]; // just return the widget
+}
+ 
+dojo.widget.fromScript = function(name, props, refNode, position){
+	dojo.deprecated(&quot;dojo.widget.fromScript&quot;, &quot; use &quot; +
+		&quot;dojo.widget.createWidget instead&quot;, &quot;0.4&quot;);
+	return dojo.widget.createWidget(name, props, refNode, position);
+}

Added: trunk/root/static/magic/src/widget/PopUpButton.js
===================================================================
--- trunk/root/static/magic/src/widget/PopUpButton.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/PopUpButton.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,192 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.PopUpButton&quot;);
+dojo.provide(&quot;dojo.widget.DomPopUpButton&quot;);
+dojo.provide(&quot;dojo.widget.HtmlPopUpButton&quot;);
+
+dojo.deprecated(&quot;dojo.widget.PopUpButton, dojo.widget.DomPopUpButton, dojo.widget.HtmlPopUpButton&quot;,  &quot;use dojo.widget.DropDownButton&quot;, &quot;0.4&quot;);
+
+//dojo.require(&quot;dojo.widget.Button&quot;);
+//dojo.require(&quot;dojo.widget.HtmlButton&quot;);
+
+dojo.require(&quot;dojo.widget.Menu&quot;);
+dojo.require(&quot;dojo.widget.MenuItem&quot;);
+
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:PopUpButton&quot;);
+
+/* PopUpButton
+ **************/
+ 
+dojo.widget.PopUpButton = function () {
+	dojo.widget.PopUpButton.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.PopUpButton, dojo.widget.Widget);
+
+dojo.lang.extend(dojo.widget.PopUpButton, {
+	widgetType: &quot;PopUpButton&quot;,
+	
+	label: &quot;&quot;
+});
+
+
+/* DomPopUpButton
+ *****************/
+dojo.widget.DomPopUpButton = function(){
+	dojo.widget.DomPopUpButton.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.DomPopUpButton, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.DomPopUpButton, {
+	widgetType: dojo.widget.PopUpButton.prototype.widgetType
+});
+
+
+/* HtmlPopUpButton
+ ******************/
+
+dojo.widget.HtmlPopUpButton = function () {
+	dojo.widget.HtmlPopUpButton.superclass.constructor.call(this);
+}
+dojo.inherits(dojo.widget.HtmlPopUpButton, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.HtmlPopUpButton, {
+	widgetType: dojo.widget.PopUpButton.prototype.widgetType,
+	templateString: null,
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/PopUpButton.css&quot;),
+	
+	buildRendering: function (args, frag) {
+		dojo.style.insertCssFile(this.templateCssPath, null, true);
+	
+		this.domNode = document.createElement(&quot;a&quot;);
+		this.domNode.className = &quot;PopUpButton&quot;;
+		dojo.event.connect(this.domNode, &quot;onmousedown&quot;, this, &quot;onMouseDown&quot;);
+		
+		// draw the arrow
+		var arrow = document.createElement(&quot;img&quot;);
+		arrow.src = dojo.uri.dojoUri(&quot;src/widget/templates/images/dropdownButtonsArrow.gif&quot;);
+		dojo.html.setClass(arrow, &quot;downArrow&quot;);
+		this.domNode.appendChild(arrow);
+
+		this.menu = dojo.widget.fromScript(&quot;Menu&quot;);
+		dojo.html.addClass(this.menu.domNode, &quot;PopUpButtonMenu&quot;);
+		dojo.event.connect(this.menu, &quot;onSelect&quot;, this, &quot;onSelect&quot;);
+		
+		if (frag[&quot;dojo:&quot; + this.widgetType.toLowerCase()].nodeRef) {
+			var node = frag[&quot;dojo:&quot; + this.widgetType.toLowerCase()].nodeRef;
+			var options = node.getElementsByTagName(&quot;option&quot;);
+			for (var i = 0; i &lt; options.length; i++) {
+				var properties = {
+					title: dojo.dom.textContent(options[i]),
+					value: options[i].value
+				}
+				this.addItem(dojo.widget.fromScript(&quot;MenuItem&quot;, properties));
+			}
+		}
+	},
+
+	addItem: function (item) {
+		// TODO: should be dojo.widget.MenuItem
+		if (item instanceof dojo.widget.html.MenuItem) {
+			this.menu.push(item);
+		} else {
+			// TODO: create one
+			var menuItem = dojo.widget.fromScript(&quot;MenuItem&quot;, {title: item});
+			this.menu.push(menuItem);
+		}
+	},
+	
+	
+/* Enabled utility methods
+ **************************/
+	
+	_enabled: true,
+	
+	isEnabled: function() { return this._enabled; },
+	
+	setEnabled: function(enabled, force, preventEvent) {
+		enabled = Boolean(enabled);
+		if (force || this._enabled != enabled) {
+			this._enabled = enabled;
+			if (!preventEvent) {
+				this._fireEvent(this._enabled ? &quot;onEnable&quot; : &quot;onDisable&quot;);
+				this._fireEvent(&quot;onChangeEnabled&quot;);
+			}
+		}
+		
+		dojo.html[(this._enabled ? &quot;add&quot; : &quot;remove&quot;)
+			+ &quot;Class&quot;](this.domNode, &quot;disabled&quot;);
+		
+		return this._enabled;
+	},
+	
+	enable: function(force, preventEvent) {
+		return this.setEnabled(true, force, preventEvent);
+	},
+	
+	disable: function(force, preventEvent) {
+		return this.setEnabled(false, force, preventEvent);
+	},
+	
+	toggleEnabled: function(force, preventEvent) {
+		return this.setEnabled(!this._enabled, force, preventEvent);
+	},
+
+
+/* Select utility methods
+ **************************/
+
+	onSelect: function (item, e) {
+		this.domNode.firstChild.nodeValue = item.title;
+	},
+	
+	onMouseDown: function (e) {
+		if (!this._menuVisible) {
+			this._showMenu(e);
+			dojo.lang.setTimeout(dojo.event.connect, 1, document, &quot;onmousedown&quot;, this, &quot;_hideMenu&quot;);
+		}
+	},
+	
+	
+	_fireEvent: function(evt) {
+		if(typeof this[evt] == &quot;function&quot;) {
+			var args = [this];
+			for(var i = 1; i &lt; arguments.length; i++) {
+				args.push(arguments[i]);
+			}
+			this[evt].apply(this, args);
+		}
+	},
+
+	
+	_showMenu: function (e) {
+		if (!this._enabled) { return; }
+		this._menuVisible = true;
+		with (dojo.html) {
+			var y = getAbsoluteY(this.domNode) + getInnerHeight(this.domNode);
+			var x = getAbsoluteX(this.domNode);
+		}
+	
+		document.body.appendChild(this.menu.domNode);
+		with (this.menu.domNode.style) {
+			top = y + &quot;px&quot;;
+			left = x + &quot;px&quot;;
+		}
+	},
+	
+	_hideMenu: function (e) {
+		this.menu.domNode.parentNode.removeChild(this.menu.domNode);
+		dojo.event.disconnect(document, &quot;onmousedown&quot;, this, &quot;_hideMenu&quot;);
+		this._menuVisible = false;
+	}
+
+});

Added: trunk/root/static/magic/src/widget/ResizableTextarea.js
===================================================================
--- trunk/root/static/magic/src/widget/ResizableTextarea.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ResizableTextarea.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,110 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ResizableTextarea&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.LayoutContainer&quot;);
+dojo.require(&quot;dojo.widget.ResizeHandle&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:resizabletextarea&quot;);
+
+dojo.widget.ResizableTextarea = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.ResizableTextarea, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.ResizableTextarea, {
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlResizableTextarea.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlResizableTextarea.css&quot;),
+	widgetType: &quot;ResizableTextarea&quot;,
+	tagName: &quot;dojo:resizabletextarea&quot;,
+	isContainer: false,
+	textAreaNode: null,
+	textAreaContainer: null,
+	textAreaContainerNode: null,
+	statusBar: null,
+	statusBarContainerNode: null,
+	statusLabelNode: null,
+	statusLabel: null,
+	rootLayoutNode: null,
+	resizeHandleNode: null,
+	resizeHandle: null,
+
+	fillInTemplate: function(args, frag){
+		this.textAreaNode = this.getFragNodeRef(frag).cloneNode(true);
+
+		// FIXME: Safari apparently needs this!
+		document.body.appendChild(this.domNode);
+
+		this.rootLayout = dojo.widget.createWidget(
+			&quot;LayoutContainer&quot;,
+			{
+				minHeight: 50,
+				minWidth: 100
+			},
+			this.rootLayoutNode
+		);
+
+
+		this.textAreaContainer = dojo.widget.createWidget(
+			&quot;LayoutContainer&quot;,
+			{ layoutAlign: &quot;client&quot; },
+			this.textAreaContainerNode
+		);
+		this.rootLayout.addChild(this.textAreaContainer);
+
+		this.textAreaContainer.domNode.appendChild(this.textAreaNode);
+		with(this.textAreaNode.style){
+			width=&quot;100%&quot;;
+			height=&quot;100%&quot;;
+		}
+
+		this.statusBar = dojo.widget.createWidget(
+			&quot;LayoutContainer&quot;,
+			{ 
+				layoutAlign: &quot;bottom&quot;, 
+				minHeight: 28
+			},
+			this.statusBarContainerNode
+		);
+		this.rootLayout.addChild(this.statusBar);
+
+		this.statusLabel = dojo.widget.createWidget(
+			&quot;LayoutContainer&quot;,
+			{ 
+				layoutAlign: &quot;client&quot;, 
+				minWidth: 50
+			},
+			this.statusLabelNode
+		);
+		this.statusBar.addChild(this.statusLabel);
+
+		this.resizeHandle = dojo.widget.createWidget(
+			&quot;ResizeHandle&quot;, 
+			{ targetElmId: this.rootLayout.widgetId },
+			this.resizeHandleNode
+		);
+		this.statusBar.addChild(this.resizeHandle);
+		// dojo.debug(this.rootLayout.widgetId);
+
+		// dojo.event.connect(this.resizeHandle, &quot;beginSizing&quot;, this, &quot;hideContent&quot;);
+		// dojo.event.connect(this.resizeHandle, &quot;endSizing&quot;, this, &quot;showContent&quot;);
+	},
+
+	hideContent: function(){
+		this.textAreaNode.style.display = &quot;none&quot;;
+	},
+
+	showContent: function(){
+		this.textAreaNode.style.display = &quot;&quot;;
+	}
+});

Added: trunk/root/static/magic/src/widget/ResizeHandle.js
===================================================================
--- trunk/root/static/magic/src/widget/ResizeHandle.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ResizeHandle.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,112 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ResizeHandle&quot;);
+dojo.provide(&quot;dojo.widget.html.ResizeHandle&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.event&quot;);
+
+dojo.widget.html.ResizeHandle = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.ResizeHandle, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.ResizeHandle, {
+	widgetType: &quot;ResizeHandle&quot;,
+
+	isSizing: false,
+	startPoint: null,
+	startSize: null,
+	minSize: null,
+
+	targetElmId: '',
+
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlResizeHandle.css&quot;),
+	templateString: '&lt;div class=&quot;dojoHtmlResizeHandle&quot;&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;',
+
+	postCreate: function(){
+		dojo.event.connect(this.domNode, &quot;onmousedown&quot;, this, &quot;beginSizing&quot;);
+	},
+
+	beginSizing: function(e){
+		if (this.isSizing){ return false; }
+
+		// get the target dom node to adjust.  targetElmId can refer to either a widget or a simple node
+		this.targetWidget = dojo.widget.byId(this.targetElmId);
+		this.targetDomNode = this.targetWidget ? this.targetWidget.domNode : dojo.byId(this.targetElmId);
+		if (!this.targetDomNode){ return; }
+
+		this.isSizing = true;
+		this.startPoint  = {'x':e.clientX, 'y':e.clientY};
+		this.startSize  = {'w':dojo.style.getOuterWidth(this.targetDomNode), 'h':dojo.style.getOuterHeight(this.targetDomNode)};
+
+		dojo.event.kwConnect({
+			srcObj: document.body, 
+			srcFunc: &quot;onmousemove&quot;,
+			targetObj: this,
+			targetFunc: &quot;changeSizing&quot;,
+			rate: 25
+		});
+		dojo.event.connect(document.body, &quot;onmouseup&quot;, this, &quot;endSizing&quot;);
+
+		e.preventDefault();
+	},
+
+	changeSizing: function(e){
+		// On IE, if you move the mouse above/to the left of the object being resized,
+		// sometimes clientX/Y aren't set, apparently.  Just ignore the event.
+		try{
+			if(!e.clientX  || !e.clientY){ return; }
+		}catch(e){
+			// sometimes you get an exception accessing above fields...
+			return;
+		}
+		var dx = this.startPoint.x - e.clientX;
+		var dy = this.startPoint.y - e.clientY;
+		
+		var newW = this.startSize.w - dx;
+		var newH = this.startSize.h - dy;
+
+		// minimum size check
+		if (this.minSize) {
+			if (newW &lt; this.minSize.w) {
+				newW = dojo.style.getOuterWidth(this.targetDomNode);
+			}
+			if (newH &lt; this.minSize.h) {
+				newH = dojo.style.getOuterHeight(this.targetDomNode);
+			}
+		}
+		
+		if(this.targetWidget){
+			this.targetWidget.resizeTo(newW, newH);
+		}else{
+			dojo.style.setOuterWidth(this.targetDomNode, newW);
+			dojo.style.setOuterHeight(this.targetDomNode, newH);
+		}
+		
+		e.preventDefault();
+	},
+
+	endSizing: function(e){
+		dojo.event.disconnect(document.body, &quot;onmousemove&quot;, this, &quot;changeSizing&quot;);
+		dojo.event.disconnect(document.body, &quot;onmouseup&quot;, this, &quot;endSizing&quot;);
+
+		this.isSizing = false;
+	}
+
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:ResizeHandle&quot;);

Added: trunk/root/static/magic/src/widget/RichText.js
===================================================================
--- trunk/root/static/magic/src/widget/RichText.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/RichText.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,1451 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+ /* -*- tab-width: 4 -*- */
+dojo.provide(&quot;dojo.widget.RichText&quot;);
+dojo.provide(&quot;dojo.widget.html.RichText&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+// used to save content
+try {
+	document.write('&lt;textarea id=&quot;dojo.widget.RichText.savedContent&quot; ' +
+		'style=&quot;display:none;position:absolute;top:-100px;left:-100px;height:3px;width:3px;overflow:hidden;&quot;&gt;&lt;/textarea&gt;');
+}catch(e){ }
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.RichText&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		/** whether to inherit the parent's width or simply use 100% */
+		inheritWidth: false,
+		focusOnLoad: true,
+		
+		/**
+		 * If a save name is specified the content is saved and restored if the
+		 * editor is not properly closed after editing has started.
+		 */
+		saveName: &quot;&quot;,
+		_content: &quot;&quot;,
+		
+		/* set height to fix the editor at a specific height, with scrolling */
+		height: null,
+
+		/** The minimum height that the editor should have */
+		minHeight: &quot;1em&quot;,
+		
+		isClosed: true,
+		isLoaded: false,
+		
+		/** whether to use the active-x object in IE */
+		useActiveX: false,
+
+		/* whether to use relative URLs for images - if this is enabled
+       	images will be given absolute URLs when inside the editor but
+       	will be changed to use relative URLs (to the current page) on save
+		*/
+		relativeImageUrls: false,
+		
+		_SEPARATOR: &quot;@@**%%__RICHTEXTBOUNDRY__%%**@@&quot;,
+
+		// contentFilters: [],
+
+		/*
+		defaultContentCleaner: function(content){
+			if(!dojo.render.html.ie){
+				return content;
+			}
+
+			content = content.replace(/\x20/g, &quot; &quot;);
+			// alert(content);
+			return content;
+		},
+		*/
+
+	/* Init
+	 *******/
+
+		fillInTemplate: function(){
+			this.open();
+
+			// add the formatting functions
+			var funcs = [&quot;queryCommandEnabled&quot;, &quot;queryCommandState&quot;,
+				&quot;queryCommandValue&quot;, &quot;execCommand&quot;];
+			for(var i = 0; i &lt; funcs.length; i++){
+				dojo.event.connect(&quot;around&quot;, this, funcs[i], this, &quot;_normalizeCommand&quot;);
+			}
+			
+			// backwards compatibility, needs to be removed
+			dojo.event.connect(this, &quot;onKeyPressed&quot;, this, &quot;afterKeyPress&quot;);
+			dojo.event.connect(this, &quot;onKeyPress&quot;, this, &quot;keyPress&quot;);
+			dojo.event.connect(this, &quot;onKeyDown&quot;, this, &quot;keyDown&quot;);
+			dojo.event.connect(this, &quot;onKeyUp&quot;, this, &quot;keyUp&quot;);
+
+			// add default some key handlers		
+			var ctrl = this.KEY_CTRL;
+			var exec = function (cmd, arg) {
+				return arguments.length == 1 ? function () { this.execCommand(cmd); } :
+					function () { this.execCommand(cmd, arg); }
+			}
+				
+			this.addKeyHandler(&quot;b&quot;, ctrl, exec(&quot;bold&quot;));
+			this.addKeyHandler(&quot;i&quot;, ctrl, exec(&quot;italic&quot;));
+			this.addKeyHandler(&quot;u&quot;, ctrl, exec(&quot;underline&quot;));
+			this.addKeyHandler(&quot;a&quot;, ctrl, exec(&quot;selectall&quot;));
+			//this.addKeyHandler(&quot;k&quot;, ctrl, exec(&quot;createlink&quot;, &quot;&quot;));
+			//this.addKeyHandler(&quot;K&quot;, ctrl, exec(&quot;unlink&quot;));
+			this.addKeyHandler(&quot;s&quot;, ctrl, function () { this.save(true); });
+			
+			this.addKeyHandler(&quot;1&quot;, ctrl, exec(&quot;formatblock&quot;, &quot;h1&quot;));
+			this.addKeyHandler(&quot;2&quot;, ctrl, exec(&quot;formatblock&quot;, &quot;h2&quot;));
+			this.addKeyHandler(&quot;3&quot;, ctrl, exec(&quot;formatblock&quot;, &quot;h3&quot;));
+			this.addKeyHandler(&quot;4&quot;, ctrl, exec(&quot;formatblock&quot;, &quot;h4&quot;));
+					
+			this.addKeyHandler(&quot;\\&quot;, ctrl, exec(&quot;insertunorderedlist&quot;));
+			if(!dojo.render.html.ie){
+				this.addKeyHandler(&quot;Z&quot;, ctrl, exec(&quot;redo&quot;));
+			}
+		},
+
+
+		events: [&quot;onBlur&quot;, &quot;onFocus&quot;, &quot;onKeyPress&quot;, &quot;onKeyDown&quot;, &quot;onKeyUp&quot;, &quot;onClick&quot;],
+
+		/**
+		 * Transforms the node referenced in this.domNode into a rich text editing
+		 * node. This can result in the creation and replacement with an &lt;iframe&gt; if
+		 * designMode is used, an &lt;object&gt; and active-x component if inside of IE or
+		 * a reguler element if contentEditable is available.
+		 */
+		open: function (element) {
+			dojo.event.topic.publish(&quot;dojo.widget.RichText::open&quot;, this);
+
+			if (!this.isClosed) { this.close(); }
+			this._content = &quot;&quot;;
+			if((arguments.length == 1)&amp;&amp;(element[&quot;nodeName&quot;])){ this.domNode = element; } // else unchanged
+
+			if(	(this.domNode[&quot;nodeName&quot;])&amp;&amp;
+				(this.domNode.nodeName.toLowerCase() == &quot;textarea&quot;)){
+				this.textarea = this.domNode;
+				var html = dojo.string.trim(this.textarea.value);
+				if(html == &quot;&quot;){ html = &quot;&nbsp;&quot;; }
+				this.domNode = document.createElement(&quot;div&quot;);
+				with(this.textarea.style){
+					display = &quot;block&quot;;
+					position = &quot;absolute&quot;;
+					width = &quot;1px&quot;;
+					height = &quot;1px&quot;;
+					border = margin = padding = &quot;0px&quot;;
+					visiblity = &quot;hidden&quot;;
+					if(dojo.render.html.ie){
+						overflow = &quot;hidden&quot;;
+					}
+				}
+				dojo.dom.insertBefore(this.domNode, this.textarea);
+				this.domNode.innerHTML = html;
+				
+				if(this.textarea.form){
+					dojo.event.connect(this.textarea.form, &quot;onsubmit&quot;, 
+						// FIXME: should we be calling close() here instead?
+						dojo.lang.hitch(this, function(){
+							this.textarea.value = this.getEditorContent();
+						})
+					);
+				}
+				
+				// dojo plucks our original domNode from the document so we need
+				// to go back and put ourselves back in
+				var editor = this;
+				dojo.event.connect(this, &quot;postCreate&quot;, function (){
+					dojo.dom.insertAfter(editor.textarea, editor.domNode);
+				});
+			}else{
+				var html = dojo.string.trim(this.domNode.innerHTML);
+				if(html == &quot;&quot;){ html = &quot;&nbsp;&quot;; }
+			}
+					
+			this._oldHeight = dojo.style.getContentHeight(this.domNode);
+			this._oldWidth = dojo.style.getContentWidth(this.domNode);
+
+			this._firstChildContributingMargin = this._getContributingMargin(this.domNode, &quot;top&quot;);
+			this._lastChildContributingMargin = this._getContributingMargin(this.domNode, &quot;bottom&quot;);
+
+			this.savedContent = document.createElement(&quot;div&quot;);
+			while (this.domNode.hasChildNodes()) {
+				this.savedContent.appendChild(this.domNode.firstChild);
+			}
+			
+			// If we're a list item we have to put in a blank line to force the
+			// bullet to nicely align at the top of text
+			if(	(this.domNode[&quot;nodeName&quot;])&amp;&amp;
+				(this.domNode.nodeName == &quot;LI&quot;)){
+				this.domNode.innerHTML = &quot; &lt;br&gt;&quot;;
+			}
+					
+			if(this.saveName != &quot;&quot;){
+				var saveTextarea = document.getElementById(&quot;dojo.widget.RichText.savedContent&quot;);
+				if (saveTextarea.value != &quot;&quot;) {
+					var datas = saveTextarea.value.split(this._SEPARATOR);
+					for (var i = 0; i &lt; datas.length; i++) {
+						var data = datas[i].split(&quot;:&quot;);
+						if (data[0] == this.saveName) {
+							html = data[1];
+							datas.splice(i, 1);
+							break;
+						}
+					}				
+				}
+				dojo.event.connect(&quot;before&quot;, window, &quot;onunload&quot;, this, &quot;_saveContent&quot;);
+				// dojo.event.connect(window, &quot;onunload&quot;, this, &quot;_saveContent&quot;);
+			}
+
+			// Safari's selections go all out of whack if we do it inline,
+			// so for now IE is our only hero
+			//if (typeof document.body.contentEditable != &quot;undefined&quot;) {
+			if (this.useActiveX &amp;&amp; dojo.render.html.ie) { // active-x
+				this._drawObject(html);
+				// dojo.debug(this.object.document);
+			} else if (dojo.render.html.ie) { // contentEditable, easy
+				this.editNode = document.createElement(&quot;div&quot;);
+				with (this.editNode) {
+					innerHTML = html;
+					contentEditable = true;
+					style.height = this.height ? this.height : this.minHeight;
+				}
+
+				if(this.height){ this.editNode.style.overflowY=&quot;scroll&quot;; }
+				// FIXME: setting contentEditable on switches this element to
+				// IE's hasLayout mode, triggering weird margin collapsing
+				// behavior. It's particularly bad if the element you're editing
+				// contains childnodes that don't have margin: defined in local
+				// css rules. It would be nice if it was possible to hack around
+				// this. Sadly _firstChildContributingMargin and 
+				// _lastChildContributingMargin don't work on IE unless all
+				// elements have margins set in CSS :-(
+
+				this.domNode.appendChild(this.editNode);
+
+				dojo.lang.forEach(this.events, function(e){
+					dojo.event.connect(this.editNode, e.toLowerCase(), this, e);
+				}, this);
+			
+				this.window = window;
+				this.document = document;
+				
+				this.onLoad();
+			} else { // designMode in iframe
+				this._drawIframe(html);
+			}
+
+			// TODO: this is a guess at the default line-height, kinda works
+			if (this.domNode.nodeName == &quot;LI&quot;) { this.domNode.lastChild.style.marginTop = &quot;-1.2em&quot;; }
+			dojo.html.addClass(this.domNode, &quot;RichTextEditable&quot;);
+			
+			this.isClosed = false;
+		},
+
+		_hasCollapseableMargin: function(element, side) {
+			// check if an element has padding or borders on the given side
+			// which would prevent it from collapsing margins
+			if (dojo.style.getPixelValue(element, 
+										 'border-'+side+'-width', 
+										 false)) {
+				return false;
+			} else if (dojo.style.getPixelValue(element, 
+												'padding-'+side,
+												false)) {
+				return false;
+			} else {
+				return true;
+			}
+		},
+
+		_getContributingMargin:	function(element, topOrBottom) {
+			// calculate how much margin this element and its first or last
+			// child are contributing to the total margin between this element
+			// and the adjacent node. CSS border collapsing makes this
+			// necessary.
+
+			if (topOrBottom == &quot;top&quot;) {
+				var siblingAttr = &quot;previousSibling&quot;;
+				var childSiblingAttr = &quot;nextSibling&quot;;
+				var childAttr = &quot;firstChild&quot;;
+				var marginProp = &quot;margin-top&quot;;
+				var siblingMarginProp = &quot;margin-bottom&quot;;
+			} else {
+				var siblingAttr = &quot;nextSibling&quot;;
+				var childSiblingAttr = &quot;previousSibling&quot;;
+				var childAttr = &quot;lastChild&quot;;
+				var marginProp = &quot;margin-bottom&quot;;
+				var siblingMarginProp = &quot;margin-top&quot;;
+			}
+
+			var elementMargin = dojo.style.getPixelValue(element, marginProp, false);
+
+			function isSignificantNode(element) {
+				// see if an node is significant in the current context
+				// for calulating margins
+				return !(element.nodeType==3 &amp;&amp; dojo.string.isBlank(element.data)) 
+					&amp;&amp; dojo.style.getStyle(element, &quot;display&quot;) != &quot;none&quot; 
+					&amp;&amp; !dojo.style.isPositionAbsolute(element);
+			}
+
+			// walk throuh first/last children to find total collapsed margin size
+			var childMargin = 0;
+			var child = element[childAttr];
+			while (child) {
+				// skip over insignificant elements (whitespace, etc)
+				while ((!isSignificantNode(child)) &amp;&amp; child[childSiblingAttr]) {
+					child = child[childSiblingAttr];
+				}
+						  
+				childMargin = Math.max(childMargin, dojo.style.getPixelValue(child, marginProp, false));
+				// stop if we hit a bordered/padded element
+				if (!this._hasCollapseableMargin(child, topOrBottom)) break;
+				child = child[childAttr];								   
+			}
+
+			// if this element has a border, return full child margin immediately
+			// as there won't be any margin collapsing
+			if (!this._hasCollapseableMargin(element, topOrBottom)){ return parseInt(childMargin); }
+
+			// find margin supplied by nearest sibling
+			var contextMargin = 0;
+			var sibling = element[siblingAttr];
+			while (sibling) {
+				if (isSignificantNode(sibling)) {
+					contextMargin = dojo.style.getPixelValue(sibling, 
+															 siblingMarginProp, 
+															 false);
+					break;
+				}
+				sibling = sibling[siblingAttr];
+			}
+			if (!sibling) { // no sibling, look at parent's margin instead
+				contextMargin = dojo.style.getPixelValue(element.parentNode, 
+												marginProp, false);
+			}
+
+			if (childMargin &gt; elementMargin) {
+				return parseInt(Math.max((childMargin-elementMargin)-contextMargin, 0));
+			} else {
+				return 0;
+			}
+			
+		},
+		
+		/** Draws an iFrame using the existing one if one exists. 
+			Used by Mozilla, Safari, and Opera */
+		_drawIframe: function (html) {
+
+			// detect firefox &lt; 1.5, which has some iframe loading issues
+			var oldMoz = Boolean(dojo.render.html.moz &amp;&amp; (
+									typeof window.XML == 'undefined'))
+
+			if (!this.iframe) {
+				var currentDomain = (new dojo.uri.Uri(document.location)).host;
+				this.iframe = document.createElement(&quot;iframe&quot;);
+				with (this.iframe) {
+					scrolling = this.height ? &quot;auto&quot; : &quot;no&quot;;
+					style.border = &quot;none&quot;;
+					style.lineHeight = &quot;0&quot;; // squash line height
+					style.verticalAlign = &quot;bottom&quot;;
+				}
+			}
+			// opera likes this to be outside the with block
+			this.iframe.src = dojo.uri.dojoUri(&quot;src/widget/templates/richtextframe.html&quot;) + &quot;#&quot; + ((document.domain != currentDomain) ? document.domain : &quot;&quot;);
+			this.iframe.width = this.inheritWidth ? this._oldWidth : &quot;100%&quot;;
+			if (this.height) {
+				this.iframe.style.height = this.height;
+			} else {
+				var height = this._oldHeight;
+				if (this._hasCollapseableMargin(this.domNode, 'top')) {
+					height += this._firstChildContributingMargin;
+				}
+				if (this._hasCollapseableMargin(this.domNode, 'bottom')) {
+					height += this._lastChildContributingMargin;
+				}
+				this.iframe.height = height;
+			}
+
+			var tmpContent = document.createElement('div');
+			tmpContent.innerHTML = html;
+
+			// make relative image urls absolute
+			if (this.relativeImageUrls) {
+				var imgs = tmpContent.getElementsByTagName('img');
+				for (var i=0; i&lt;imgs.length; i++) {
+					imgs[i].src = (new dojo.uri.Uri(window.location, imgs[i].src)).toString();
+				}
+				html = tmpContent.innerHTML;
+			}
+
+			// fix margins on tmpContent
+			var firstChild = dojo.dom.firstElement(tmpContent);
+			var lastChild = dojo.dom.lastElement(tmpContent);
+			if(firstChild){
+				firstChild.style.marginTop = this._firstChildContributingMargin+&quot;px&quot;;
+			}
+			if(lastChild){
+				lastChild.style.marginBottom = this._lastChildContributingMargin+&quot;px&quot;;
+			}
+
+			// show existing content behind iframe for now
+			tmpContent.style.position = &quot;absolute&quot;;
+			this.domNode.appendChild(tmpContent);
+			this.domNode.appendChild(this.iframe);
+
+			var _iframeInitialized = false;
+
+			// now we wait for onload. Janky hack!
+			var ifrFunc = dojo.lang.hitch(this, function(){
+				if(!_iframeInitialized){
+					_iframeInitialized = true;
+				}else{ return; }
+				if(!this.editNode){
+					if(this.iframe.contentWindow){
+						this.window = this.iframe.contentWindow;
+					}else{
+						// for opera
+						this.window = this.iframe.contentDocument.window;
+					}
+					if(dojo.render.html.moz){
+						this.document = this.iframe.contentWindow.document
+					}else{
+						this.document = this.iframe.contentDocument;
+					}
+
+					// curry the getStyle function
+					var getStyle = (function (domNode) { return function (style) {
+						return dojo.style.getStyle(domNode, style);
+					}; })(this.domNode);
+
+					var font =
+						getStyle('font-weight') + &quot; &quot; +
+						getStyle('font-size') + &quot; &quot; +
+						getStyle('font-family');
+					
+					// line height is tricky - applying a units value will mess things up.
+					// if we can't get a non-units value, bail out.
+					var lineHeight = &quot;1.0&quot;;
+					var lineHeightStyle = dojo.style.getUnitValue(this.domNode, 'line-height');
+					if (lineHeightStyle.value &amp;&amp; lineHeightStyle.units==&quot;&quot;) {
+						lineHeight = lineHeightStyle.value;
+					}
+
+					dojo.style.insertCssText(
+						'    body,html { background: transparent; padding: 0; margin: 0; }\n' +
+						// TODO: left positioning will case contents to disappear out of view
+						//       if it gets too wide for the visible area
+						'    body { top: 0; left: 0; right: 0;' +
+						(this.height ? '' : ' position: fixed; ') + 
+						'        font: ' + font + ';\n' + 
+						'        min-height: ' + this.minHeight + '; \n' +
+						'        line-height: ' + lineHeight + '} \n' +
+						'    p { margin: 1em 0 !important; }\n' +
+						'    body &gt; *:first-child { padding-top: 0 !important; margin-top: ' + this._firstChildContributingMargin + 'px !important; }\n' + // FIXME: test firstChild nodeType
+						'    body &gt; *:last-child { padding-bottom: 0 !important; margin-bottom: ' + this._lastChildContributingMargin + 'px !important; }\n' +
+						'    li &gt; ul:-moz-first-node, li &gt; ol:-moz-first-node { padding-top: 1.2em; }\n' +
+						'    li { min-height: 1.2em; }\n' +
+						//'    p,ul,li { padding-top: 0; padding-bottom: 0; margin-top:0; margin-bottom: 0; }\n' + 
+						'', this.document);
+
+					tmpContent.parentNode.removeChild(tmpContent);
+					this.document.body.innerHTML = html;
+					if(oldMoz){
+						this.document.designMode = &quot;on&quot;;
+					}
+					this.onLoad();
+				}else{
+					tmpContent.parentNode.removeChild(tmpContent);
+					this.editNode.innerHTML = html;
+					this.onDisplayChanged();
+				}
+			});
+
+			if(this.editNode){
+				ifrFunc(); // iframe already exists, just set content
+			}else if(dojo.render.html.moz){
+				// FIXME: if we put this on a delay, we get a height of 20px.
+				// Otherwise we get the correctly specified minHeight value.
+				this.iframe.onload = function(){
+					setTimeout(ifrFunc, 250);
+				}
+			}else{ // new mozillas, opera, safari
+				this.iframe.onload = ifrFunc;
+			}
+		},
+		
+		/** Draws an active x object, used by IE */
+		_drawObject: function (html) {
+			this.object = document.createElement(&quot;object&quot;);
+
+			with (this.object) {
+				classid = &quot;clsid:2D360201-FFF5-11D1-8D03-00A0C959BC0A&quot;;
+				width = this.inheritWidth ? this._oldWidth : &quot;100%&quot;;
+				style.height = this.height ? this.height : (this._oldHeight+&quot;px&quot;);
+				Scrollbars = this.height ? true : false;
+				Appearance = this._activeX.appearance.flat;
+			}
+			this.domNode.appendChild(this.object);
+
+			this.object.attachEvent(&quot;DocumentComplete&quot;, dojo.lang.hitch(this, &quot;onLoad&quot;));
+			this.object.attachEvent(&quot;DisplayChanged&quot;, dojo.lang.hitch(this, &quot;_updateHeight&quot;));
+			this.object.attachEvent(&quot;DisplayChanged&quot;, dojo.lang.hitch(this, &quot;onDisplayChanged&quot;));
+
+			dojo.lang.forEach(this.events, function(e){
+				this.object.attachEvent(e.toLowerCase(), dojo.lang.hitch(this, e));
+			}, this);
+
+			this.object.DocumentHTML = '&lt;!doctype HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;<A HREF="http://www.w3.org/TR/html4/strict.dtd">http://www.w3.org/TR/html4/strict.dtd</A>&quot;&gt;' +
+				'&lt;title&gt;&lt;/title&gt;' +
+				'&lt;style type=&quot;text/css&quot;&gt;' +
+				'    body,html { padding: 0; margin: 0; }' + //font: ' + font + '; }' +
+				(this.height ? '' : '    body { overflow: hidden; }') +
+				//'    #bodywrapper {  }' +
+				'&lt;/style&gt;' +
+				//'&lt;base href=&quot;' + window.location + '&quot;&gt;' +
+				'&lt;body&gt;&lt;div id=&quot;bodywrapper&quot;&gt;' + html + '&lt;/div&gt;&lt;/body&gt;';
+		},
+
+	/* Event handlers
+	 *****************/
+
+	 	_isResized: function(){ return false; },
+
+		onLoad: function(e){
+			this.isLoaded = true;
+			if (this.object){
+				this.document = this.object.DOM;
+				this.window = this.document.parentWindow;
+				this.editNode = this.document.body.firstChild;
+				this.domNode.style.height = this.height ? this.height : this.minHeight;
+				this.connect(this, &quot;onDisplayChanged&quot;, &quot;_updateHeight&quot;);
+			}else if (this.iframe){
+				this.editNode = this.document.body;
+				this.connect(this, &quot;onDisplayChanged&quot;, &quot;_updateHeight&quot;);
+		
+				try { // sanity check for Mozilla
+					this.document.execCommand(&quot;useCSS&quot;, false, true); // old moz call
+					this.document.execCommand(&quot;styleWithCSS&quot;, false, false); // new moz call
+					//this.document.execCommand(&quot;insertBrOnReturn&quot;, false, false); // new moz call
+				}catch(e2){ }
+				
+				if (dojo.render.html.safari) {
+					/*
+					this.iframe.style.visiblity = &quot;visible&quot;;
+					this.iframe.style.border = &quot;1px solid black&quot;;
+					this.editNode.style.visiblity = &quot;visible&quot;;
+					this.editNode.style.border = &quot;1px solid black&quot;;
+					*/
+					// this.onDisplayChanged();
+					this.connect(this.editNode, &quot;onblur&quot;, &quot;onBlur&quot;);
+					this.connect(this.editNode, &quot;onfocus&quot;, &quot;onFocus&quot;);
+				
+					this.interval = setInterval(dojo.lang.hitch(this, &quot;onDisplayChanged&quot;), 750);
+					// dojo.raise(&quot;onload&quot;);
+					// dojo.debug(this.editNode.parentNode.parentNode.parentNode.nodeName);
+				} else if (dojo.render.html.mozilla || dojo.render.html.opera) {
+
+					// We need to unhook the blur event listener on close as we
+					// can encounter a garunteed crash in FF if another event is
+					// also fired
+					var doc = this.document;
+					var blurfp = dojo.event.browser.addListener(this.document, &quot;blur&quot;, dojo.lang.hitch(this, &quot;onBlur&quot;));
+					var unBlur = { unBlur: function(e){
+							dojo.event.browser.removeListener(doc, &quot;blur&quot;, blurfp);
+					} };
+					dojo.event.connect(&quot;before&quot;, this, &quot;close&quot;, unBlur, &quot;unBlur&quot;);
+					dojo.event.browser.addListener(this.document, &quot;focus&quot;, dojo.lang.hitch(this, &quot;onFocus&quot;));
+				
+					// safari can't handle key listeners, it kills the speed
+					var addListener = dojo.event.browser.addListener;
+					addListener(this.document, &quot;keypress&quot;, dojo.lang.hitch(this, &quot;onKeyPress&quot;));
+					addListener(this.document, &quot;keydown&quot;, dojo.lang.hitch(this, &quot;onKeyDown&quot;));
+					addListener(this.document, &quot;keyup&quot;, dojo.lang.hitch(this, &quot;onKeyUp&quot;));
+					addListener(this.document, &quot;click&quot;, dojo.lang.hitch(this, &quot;onClick&quot;));
+				}
+
+				// FIXME: when scrollbars appear/disappear this needs to be fired						
+			}else if(dojo.render.html.ie){
+				// IE contentEditable
+				this.editNode.style.zoom = 1.0;
+			}
+			
+			if(this.focusOnLoad){
+				this.focus();
+			}
+			this.onDisplayChanged(e);
+		},
+
+		/** Fired on keydown */
+		onKeyDown: function(e){
+			if((!e)&amp;&amp;(this.object)){
+				e = dojo.event.browser.fixEvent(this.window.event);
+			}
+			dojo.debug(&quot;onkeydown:&quot;, e.keyCode);
+			// we need this event at the moment to get the events from control keys
+			// such as the backspace. It might be possible to add this to Dojo, so that
+			// keyPress events can be emulated by the keyDown and keyUp detection.
+			if((dojo.render.html.ie)&amp;&amp;(e.keyCode == e.KEY_TAB)){
+				e.preventDefault();
+				e.stopPropagation();
+				// FIXME: this is a poor-man's indent/outdent. It would be
+				// better if it added 4 &quot;&nbsp;&quot; chars in an undoable way.
+				// Unfortuantly pasteHTML does not prove to be undoable 
+				this.execCommand((e.shiftKey ? &quot;outdent&quot; : &quot;indent&quot;));
+			}else if(dojo.render.html.ie){
+				if((65 &lt;= e.keyCode)&amp;&amp;(e.keyCode &lt;= 90)){
+					e.charCode = e.keyCode;
+					this.onKeyPress(e);
+				}
+				// dojo.debug(e.ctrlKey);
+				// dojo.debug(e.keyCode);
+				// dojo.debug(e.charCode);
+				// this.onKeyPress(e);
+			}
+		},
+		
+		/** Fired on keyup */
+		onKeyUp: function(e){
+			return;
+		},
+		
+		KEY_CTRL: 1,
+		
+		/** Fired on keypress. */
+		onKeyPress: function(e){
+			if((!e)&amp;&amp;(this.object)){
+				e = dojo.event.browser.fixEvent(this.window.event);
+			}
+			// handle the various key events
+
+			var character = e.charCode &gt; 0 ? String.fromCharCode(e.charCode) : null;
+			var code = e.keyCode;
+
+			var modifiers = e.ctrlKey ? this.KEY_CTRL : 0;
+
+			if (this._keyHandlers[character]) {
+				dojo.debug(&quot;char:&quot;, character);
+				var handlers = this._keyHandlers[character], i = 0, handler;
+				while (handler = handlers[i++]) {
+					if (modifiers == handler.modifiers) {
+						handler.handler.call(this);
+						e.preventDefault();
+						break;
+					}
+				}
+			}
+			
+			/*
+			// define some key combos
+			if (e.ctrlKey || e.metaKey) { // modifier pressed
+				switch (character) {
+					case &quot;b&quot;: this.execCommand(&quot;bold&quot;); break;
+					case &quot;i&quot;: this.execCommand(&quot;italic&quot;); break;
+					case &quot;u&quot;: this.execCommand(&quot;underline&quot;); break;
+					//case &quot;a&quot;: this.execCommand(&quot;selectall&quot;); break;
+					//case &quot;k&quot;: this.execCommand(&quot;createlink&quot;, &quot;&quot;); break;
+					//case &quot;K&quot;: this.execCommand(&quot;unlink&quot;); break;
+					case &quot;Z&quot;: this.execCommand(&quot;redo&quot;); break;
+					case &quot;s&quot;: this.close(true); break; // saves
+					
+					case &quot;1&quot;: this.execCommand(&quot;formatblock&quot;, &quot;h1&quot;); break;
+					case &quot;2&quot;: this.execCommand(&quot;formatblock&quot;, &quot;h2&quot;); break;
+					case &quot;3&quot;: this.execCommand(&quot;formatblock&quot;, &quot;h3&quot;); break;
+					case &quot;4&quot;: this.execCommand(&quot;formatblock&quot;, &quot;h4&quot;); break;
+					
+					case &quot;\\&quot;: this.execCommand(&quot;insertunorderedlist&quot;); break;
+					
+					default: switch (code) {
+						case e.KEY_LEFT_ARROW:
+						case e.KEY_RIGHT_ARROW:
+							//break; // preventDefault stops the browser
+								   // going through its history
+						default:
+							preventDefault = false; break; // didn't handle here
+					}
+				}
+			} else {
+				switch (code) {
+					case e.KEY_TAB:
+					  // commenting out bcs it's crashing FF
+						// this.execCommand(e.shiftKey ? &quot;unindent&quot; : &quot;indent&quot;);
+						// break;
+					default:
+						preventDefault = false; break; // didn't handle here
+				}
+			}
+			
+			if (preventDefault) { e.preventDefault(); }
+			*/
+
+			// function call after the character has been inserted
+			dojo.lang.setTimeout(this, this.onKeyPressed, 1, e);
+		},
+		
+		addKeyHandler: function (key, modifiers, handler) {
+			if (!(this._keyHandlers[key] instanceof Array)) { this._keyHandlers[key] = []; }
+			this._keyHandlers[key].push({
+				modifiers: modifiers || 0,
+				handler: handler
+			});
+		},
+		
+		
+		
+		/**
+		 * Fired after a keypress event has occured and it's action taken. This
+		 * is useful if action needs to be taken after text operations have
+		 * finished
+		 */
+		onKeyPressed: function (e) {
+			// Mozilla adds a single &lt;p&gt; with an embedded &lt;br&gt; when you hit enter once:
+			//   &lt;p&gt;&lt;br&gt;\n&lt;/p&gt;
+			// when you hit enter again it adds another &lt;br&gt; inside your enter
+			//   &lt;p&gt;&lt;br&gt;\n&lt;br&gt;\n&lt;/p&gt;
+			// and if you hit enter again it splits the &lt;br&gt;s over 2 &lt;p&gt;s
+			//   &lt;p&gt;&lt;br&gt;\n&lt;/p&gt;\n&lt;p&gt;&lt;br&gt;\n&lt;/p&gt;
+			// now this assumes that &lt;p&gt;s have double the line-height of &lt;br&gt;s to work
+			// and so we need to remove the &lt;p&gt;s to ensure the position of the cursor
+			// changes from the users perspective when they hit enter, as the second two
+			// html snippets render the same when margins are set to 0.
+			
+			// TODO: doesn't really work; is this really needed?
+			//if (dojo.render.html.moz) {
+			//	for (var i = 0; i &lt; this.document.getElementsByTagName(&quot;p&quot;).length; i++) {
+			//		var p = this.document.getElementsByTagName(&quot;p&quot;)[i];
+			//		if (p.innerHTML.match(/^&lt;br&gt;\s$/m)) {
+			//			while (p.hasChildNodes()) { p.parentNode.insertBefore(p.firstChild, p); }
+			//			p.parentNode.removeChild(p);
+			//		}
+			//	}
+			//}
+			this.onDisplayChanged(/*e*/); // can't pass in e
+		},
+		
+		onClick: function(e){ this.onDisplayChanged(e); },
+		onBlur: function(e){ },
+		_initialFocus: true,
+		onFocus: function(e){ 
+			if( (dojo.render.html.mozilla)&amp;&amp;(this._initialFocus) ){
+				this._initialFocus = false;
+				if(dojo.string.trim(this.editNode.innerHTML) == &quot;&nbsp;&quot;){
+					this.execCommand(&quot;selectall&quot;);
+					this.window.getSelection().collapseToStart();
+				}
+			}
+		},
+
+		blur: function () {
+			if (this.iframe) { this.window.blur(); }
+			else if (this.editNode) { this.editNode.blur(); }
+		},
+		
+		focus: function () {
+			if(this.iframe){
+				this.window.focus();
+			}else if(this.editNode){
+				this.editNode.focus();
+			}
+		},
+		
+		/** this event will be fired everytime the display context changes and the
+		 result needs to be reflected in the UI */
+		onDisplayChanged: function (e){ },
+		
+
+	/* Formatting commands
+	 **********************/
+		
+		/** IE's Active X codes */
+		_activeX: {
+			command: {
+				bold: 5000,
+				italic: 5023,
+				underline: 5048,
+
+				justifycenter: 5024,
+				justifyleft: 5025,
+				justifyright: 5026,
+
+				cut: 5003,
+				copy: 5002,
+				paste: 5032,
+				&quot;delete&quot;: 5004,
+
+				undo: 5049,
+				redo: 5033,
+
+				removeformat: 5034,
+				selectall: 5035,
+				unlink: 5050,
+
+				indent: 5018,
+				outdent: 5031,
+
+				insertorderedlist: 5030,
+				insertunorderedlist: 5051,
+
+				// table commands
+				inserttable: 5022,
+				insertcell: 5019,
+				insertcol: 5020,
+				insertrow: 5021,
+				deletecells: 5005,
+				deletecols: 5006,
+				deleterows: 5007,
+				mergecells: 5029,
+				splitcell: 5047,
+				
+				// the command need mapping, they don't translate directly
+				// to the contentEditable commands
+				setblockformat: 5043,
+				getblockformat: 5011,
+				getblockformatnames: 5012,
+				setfontname: 5044,
+				getfontname: 5013,
+				setfontsize: 5045,
+				getfontsize: 5014,
+				setbackcolor: 5042,
+				getbackcolor: 5010,
+				setforecolor: 5046,
+				getforecolor: 5015,
+				
+				findtext: 5008,
+				font: 5009,
+				hyperlink: 5016,
+				image: 5017,
+				
+				lockelement: 5027,
+				makeabsolute: 5028,
+				sendbackward: 5036,
+				bringforward: 5037,
+				sendbelowtext: 5038,
+				bringabovetext: 5039,
+				sendtoback: 5040,
+				bringtofront: 5041,
+				
+				properties: 5052
+			},
+			
+			ui: {
+				&quot;default&quot;: 0,
+				prompt: 1,
+				noprompt: 2
+			},
+			
+			status: {
+				notsupported: 0,
+				disabled: 1,
+				enabled: 3,
+				latched: 7,
+				ninched: 11
+			},
+			
+			appearance: {
+				flat: 0,
+				inset: 1
+			},
+			
+			state: {
+				unchecked: 0,
+				checked: 1,
+				gray: 2
+			}
+		},
+		
+		/**
+		 * Used as the advice function by dojo.event.connect to map our
+		 * normalized set of commands to those supported by the target
+		 * browser
+		 *
+		 * @param arugments The arguments Array, containing at least one
+		 *                  item, the command and an optional second item,
+		 *                  an argument.
+		 */
+		_normalizeCommand: function (joinObject){
+			var drh = dojo.render.html;
+			
+			var command = joinObject.args[0].toLowerCase();
+			if(command == &quot;formatblock&quot;){
+				if(drh.safari){ command = &quot;heading&quot;; }
+				if(drh.ie){ joinObject.args[1] = &quot;&lt;&quot;+joinObject.args[1]+&quot;&gt;&quot;; }
+			}
+			if (command == &quot;hilitecolor&quot; &amp;&amp; !drh.mozilla) { command = &quot;backcolor&quot;; }
+			joinObject.args[0] = command;
+			
+			if (joinObject.args.length &gt; 1) { // a command was specified
+				var argument = joinObject.args[1];
+				if (command == &quot;heading&quot;) { throw new Error(&quot;unimplemented&quot;); }
+				joinObject.args[1] = argument;
+			}
+			
+			return joinObject.proceed();
+		},
+		
+		/**
+		 * Tests whether a command is supported by the host. Clients SHOULD check
+		 * whether a command is supported before attempting to use it, behaviour
+		 * for unsupported commands is undefined.
+		 *
+		 * @param command The command to test for
+		 * @return true if the command is supported, false otherwise
+		 */
+		queryCommandAvailable: function (command) {
+			var ie = 1;
+			var mozilla = 1 &lt;&lt; 1;
+			var safari = 1 &lt;&lt; 2;
+			var opera = 1 &lt;&lt; 3;
+			function isSupportedBy (browsers) {
+				return {
+					ie: Boolean(browsers &amp; ie),
+					mozilla: Boolean(browsers &amp; mozilla),
+					safari: Boolean(browsers &amp; safari),
+					opera: Boolean(browsers &amp; opera)
+				}
+			}
+
+			var supportedBy = null;
+			
+			switch (command.toLowerCase()) {
+				case &quot;bold&quot;: case &quot;italic&quot;: case &quot;underline&quot;:
+				case &quot;subscript&quot;: case &quot;superscript&quot;:
+				case &quot;fontname&quot;: case &quot;fontsize&quot;:
+				case &quot;forecolor&quot;: case &quot;hilitecolor&quot;:
+				case &quot;justifycenter&quot;: case &quot;justifyfull&quot;: case &quot;justifyleft&quot;: 
+				case &quot;justifyright&quot;: case &quot;delete&quot;: case &quot;undo&quot;: case &quot;redo&quot;:
+					supportedBy = isSupportedBy(mozilla | ie | safari | opera);
+					break;
+					
+				case &quot;createlink&quot;: case &quot;unlink&quot;: case &quot;removeformat&quot;:
+				case &quot;inserthorizontalrule&quot;: case &quot;insertimage&quot;:
+				case &quot;insertorderedlist&quot;: case &quot;insertunorderedlist&quot;:
+				case &quot;indent&quot;: case &quot;outdent&quot;: case &quot;formatblock&quot;: 
+				case &quot;inserthtml&quot;:
+					supportedBy = isSupportedBy(mozilla | ie | opera);
+					break;
+					
+				case &quot;strikethrough&quot;: 
+					supportedBy = isSupportedBy(mozilla |  opera | (this.object ? 0 : ie));
+					break;
+
+				case &quot;blockdirltr&quot;: case &quot;blockdirrtl&quot;:
+				case &quot;dirltr&quot;: case &quot;dirrtl&quot;:
+				case &quot;inlinedirltr&quot;: case &quot;inlinedirrtl&quot;:
+				case &quot;cut&quot;: case &quot;copy&quot;: case &quot;paste&quot;: 
+					supportedBy = isSupportedBy(ie);
+					break;
+				
+				case &quot;inserttable&quot;:
+					supportedBy = isSupportedBy(mozilla | (this.object ? ie : 0));
+					break;
+				
+				case &quot;insertcell&quot;: case &quot;insertcol&quot;: case &quot;insertrow&quot;:
+				case &quot;deletecells&quot;: case &quot;deletecols&quot;: case &quot;deleterows&quot;:
+				case &quot;mergecells&quot;: case &quot;splitcell&quot;:
+					supportedBy = isSupportedBy(this.object ? ie : 0);
+					break;
+				
+				default: return false;
+			}
+			
+			return (dojo.render.html.ie &amp;&amp; supportedBy.ie) ||
+				(dojo.render.html.mozilla &amp;&amp; supportedBy.mozilla) ||
+				(dojo.render.html.safari &amp;&amp; supportedBy.safari) ||
+				(dojo.render.html.opera &amp;&amp; supportedBy.opera);
+		},
+
+		/**
+		 * Executes a command in the Rich Text area
+		 *
+		 * @param command The command to execute
+		 * @param argument An optional argument to the command
+		 */
+		execCommand: function (command, argument){
+			var returnValue;
+			if(this.object){
+				if(command == &quot;forecolor&quot;){
+					command = &quot;setforecolor&quot;;
+				}else if(command == &quot;backcolor&quot;){
+					command = &quot;setbackcolor&quot;;
+				}
+			
+				//if (typeof this._activeX.command[command] == &quot;undefined&quot;) { return null; }
+			
+				if(command == &quot;inserttable&quot;){
+					var tableInfo = this.constructor._tableInfo;
+					if(!tableInfo){
+						tableInfo = document.createElement(&quot;object&quot;);
+						tableInfo.classid = &quot;clsid:47B0DFC7-B7A3-11D1-ADC5-006008A5848C&quot;;
+						document.body.appendChild(tableInfo);
+						this.constructor._table = tableInfo;
+					}
+					
+					tableInfo.NumRows = argument[&quot;rows&quot;];
+					tableInfo.NumCols = argument[&quot;cols&quot;];
+					tableInfo.TableAttrs = argument[&quot;TableAttrs&quot;];
+					tableInfo.CellAttrs = argument[&quot;CellAttrs&quot;];
+					tableInfo.Caption = argument[&quot;Caption&quot;];
+				}
+			
+				if(command == &quot;inserthtml&quot;){
+					var insertRange = this.document.selection.createRange();
+					insertRange.select();
+					insertRange.pasteHTML(argument);
+					insertRange.collapse(true);
+					return true;
+				}else if(arguments.length == 1){
+					return this.object.ExecCommand(this._activeX.command[command],
+						this._activeX.ui.noprompt);
+				}else{
+					return this.object.ExecCommand(this._activeX.command[command],
+						this._activeX.ui.noprompt, argument);
+				}
+		
+			/* */
+			}else if(command == &quot;inserthtml&quot;){
+				// on IE, we can use the pasteHTML method of the textRange object
+				// to get an undo-able innerHTML modification
+				if(dojo.render.html.ie){
+					dojo.debug(&quot;inserthtml breaks the undo stack when not using the ActiveX version of the control!&quot;);
+					var insertRange = this.document.selection.createRange();
+					insertRange.select();
+					insertRange.pasteHTML(argument);
+					insertRange.collapse(true);
+					return true;
+				}else{
+					return this.document.execCommand(command, false, argument);			
+				}
+			/* */
+			// fix up unlink in Mozilla to unlink the link and not just the selection
+			}else if((command == &quot;unlink&quot;)&amp;&amp;
+				(this.queryCommandEnabled(&quot;unlink&quot;))&amp;&amp;
+				(dojo.render.html.mozilla)){
+				// grab selection
+				// Mozilla gets upset if we just store the range so we have to
+				// get the basic properties and recreate to save the selection
+				var selection = this.window.getSelection();
+				var selectionRange = selection.getRangeAt(0);
+				var selectionStartContainer = selectionRange.startContainer;
+				var selectionStartOffset = selectionRange.startOffset;
+				var selectionEndContainer = selectionRange.endContainer;
+				var selectionEndOffset = selectionRange.endOffset;
+				
+				// select our link and unlink
+				var range = document.createRange();
+				var a = this.getSelectedNode();
+				while(a.nodeName != &quot;A&quot;){ a = a.parentNode; }
+				range.selectNode(a);
+				selection.removeAllRanges();
+				selection.addRange(range);
+				
+				returnValue = this.document.execCommand(&quot;unlink&quot;, false, null);
+				
+				// restore original selection
+				var selectionRange = document.createRange();
+				selectionRange.setStart(selectionStartContainer, selectionStartOffset);
+				selectionRange.setEnd(selectionEndContainer, selectionEndOffset);
+				selection.removeAllRanges();
+				selection.addRange(selectionRange);
+				
+				return returnValue;
+			}else if((command == &quot;inserttable&quot;)&amp;&amp;(dojo.render.html.mozilla)){
+
+				var cols = &quot;&lt;tr&gt;&quot;;
+				for (var i = 0; i &lt; argument.cols; i++) { cols += &quot;&lt;td&gt;&lt;/td&gt;&quot;; }
+				cols += &quot;&lt;/tr&gt;&quot;;
+			
+				var table = &quot;&lt;table&gt;&lt;tbody&gt;&quot;;
+				for (var i = 0; i &lt; argument.rows; i++) { table += cols; }
+				table += &quot;&lt;/tbody&gt;&lt;/table&gt;&quot;;
+				returnValue = this.document.execCommand(&quot;inserthtml&quot;, false, table);
+
+			}else if((command == &quot;hilitecolor&quot;)&amp;&amp;(dojo.render.html.mozilla)){
+				// mozilla doesn't support hilitecolor properly when useCSS is
+				// set to false (bugzilla #279330)
+				
+				this.document.execCommand(&quot;useCSS&quot;, false, false);
+				returnValue = this.document.execCommand(command, false, argument);			
+				this.document.execCommand(&quot;useCSS&quot;, false, true);
+			
+			}else if((dojo.render.html.ie)&amp;&amp;( (command == &quot;backcolor&quot;)||(command == &quot;forecolor&quot;) )){
+				// IE weirdly collapses ranges when we exec these commands, so prevent it	
+				var tr = this.document.selection.createRange();
+				argument = arguments.length &gt; 1 ? argument : null;
+				returnValue = this.document.execCommand(command, false, argument);
+				// timeout is workaround for weird IE behavior were the text
+				// selection gets correctly re-created, but subsequent input
+				// apparently isn't bound to it
+				setTimeout(function(){tr.select();}, 1);
+			}else{
+				// dojo.debug(&quot;command:&quot;, command, &quot;arg:&quot;, argument);
+
+				argument = arguments.length &gt; 1 ? argument : null;
+				if(dojo.render.html.moz){
+					this.document = this.iframe.contentWindow.document
+				}
+				returnValue = this.document.execCommand(command, false, argument);
+
+				// try{
+				// }catch(e){
+				// 	dojo.debug(e);
+				// }
+			}
+			
+			this.onDisplayChanged();
+			return returnValue;
+		},
+
+		queryCommandEnabled: function(command, argument){
+			if(this.object){
+				if(command == &quot;forecolor&quot;){
+					command = &quot;setforecolor&quot;;
+				}else if(command == &quot;backcolor&quot;){
+					command = &quot;setbackcolor&quot;;
+				}
+
+				if(typeof this._activeX.command[command] == &quot;undefined&quot;){ return false; }
+				var status = this.object.QueryStatus(this._activeX.command[command]);
+				return ((status != this.activeX.status.notsupported)&amp;&amp; 
+					(status != this.activeX.status.diabled));
+			}else{
+				// mozilla returns true always
+				if(command == &quot;unlink&quot; &amp;&amp; dojo.render.html.mozilla){
+					var node = this.getSelectedNode();
+					while (node.parentNode &amp;&amp; node.nodeName != &quot;A&quot;) { node = node.parentNode; }
+					return node.nodeName == &quot;A&quot;;
+				} else if (command == &quot;inserttable&quot; &amp;&amp; dojo.render.html.mozilla) {
+					return true;
+				}
+
+				// return this.document.queryCommandEnabled(command);
+				var elem = (dojo.render.html.ie) ? this.document.selection.createRange() : this.document;
+				return elem.queryCommandEnabled(command);
+			}
+		},
+
+		queryCommandState: function(command, argument){
+			if(this.object){
+				if(command == &quot;forecolor&quot;){
+					command = &quot;setforecolor&quot;;
+				}else if(command == &quot;backcolor&quot;){
+					command = &quot;setbackcolor&quot;;
+				}
+
+				if(typeof this._activeX.command[command] == &quot;undefined&quot;){ return null; }
+				var status = this.object.QueryStatus(this._activeX.command[command]);
+				return ((status == this._activeX.status.enabled)||
+					(status == this._activeX.status.ninched));
+			}else{
+				return this.document.queryCommandState(command);
+			}
+		},
+
+		queryCommandValue: function (command, argument) {
+			if (this.object) {
+				switch (command) {
+					case &quot;forecolor&quot;:
+					case &quot;backcolor&quot;:
+					case &quot;fontsize&quot;:
+					case &quot;fontname&quot;:
+					case &quot;blockformat&quot;:
+						command = &quot;get&quot; + command;
+						return this.object.execCommand(
+							this._activeX.command[command],
+							this._activeX.ui.noprompt);
+				}			
+			
+				//var status = this.object.QueryStatus(this._activeX.command[command]);
+			} else {
+				return this.document.queryCommandValue(command);
+			}
+		},
+		
+		
+	/* Misc.
+	 ********/
+
+		getSelectedNode: function(){
+			if(!this.isLoaded){ return; }
+			if(this.document.selection){
+				return this.document.selection.createRange().parentElement();
+			}else if(dojo.render.html.mozilla){
+				return this.window.getSelection().getRangeAt(0).commonAncestorContainer;
+			}
+			return this.editNode;
+		},
+		
+		placeCursorAtStart: function(){
+			if(!this.isLoaded){
+				dojo.event.connect(this, &quot;onLoad&quot;, this, &quot;placeCursorAtEnd&quot;);
+				return;
+			}
+			dojo.event.disconnect(this, &quot;onLoad&quot;, this, &quot;placeCursorAtEnd&quot;);
+			if(this.window.getSelection){
+				var selection = this.window.getSelection;
+				if(selection.removeAllRanges){ // Mozilla
+					var range = this.document.createRange();
+					range.selectNode(this.editNode.firstChild);
+					range.collapse(true);
+					var selection = this.window.getSelection();
+					selection.removeAllRanges();
+					selection.addRange(range);
+				}else{ // Safari
+					// not a great deal we can do
+				}
+			}else if(this.document.selection){ // IE
+				var range = this.document.body.createTextRange();
+				range.moveToElementText(this.editNode);
+				range.collapse(true);
+				range.select();
+			}
+		},
+
+		replaceEditorContent: function(html){
+			if(this.window.getSelection){
+				var selection = this.window.getSelection;
+				// if(selection.removeAllRanges){ // Mozilla			
+				if(dojo.render.html.moz){ // Mozilla			
+					var range = this.document.createRange();
+					range.selectNodeContents(this.editNode);
+					var selection = this.window.getSelection();
+					selection.removeAllRanges();
+					selection.addRange(range);
+					this.execCommand(&quot;inserthtml&quot;, html);
+				}else{ // Safari
+					// look ma! it's a totally f'd browser!
+					this.editNode.innerHTML = html;
+				}
+			}else if(this.document.selection){ // IE
+				var range = this.document.body.createTextRange();
+				range.moveToElementText(this.editNode);
+				range.select();
+				this.execCommand(&quot;inserthtml&quot;, html);
+			}
+		},
+		
+		placeCursorAtEnd: function(){
+			if(!this.isLoaded){
+				dojo.event.connect(this, &quot;onLoad&quot;, this, &quot;placeCursorAtEnd&quot;);
+				return;
+			}
+			dojo.event.disconnect(this, &quot;onLoad&quot;, this, &quot;placeCursorAtEnd&quot;);
+			if(this.window.getSelection){
+				var selection = this.window.getSelection;
+				if(selection.removeAllRanges){ // Mozilla
+					var range = this.document.createRange();
+					range.selectNode(this.editNode.lastChild);
+					range.collapse(false);
+					var selection = this.window.getSelection();
+					selection.removeAllRanges();
+					selection.addRange(range);
+				}else{ // Safari
+					// not a great deal we can do
+				}
+			}else if(this.document.selection){ // IE
+				var range = this.document.body.createTextRange();
+				range.moveToElementText(this.editNode);
+				range.collapse(true);
+				range.select();
+			}
+		},
+
+		_lastHeight: 0,
+
+		/** Updates the height of the iframe to fit the contents. */
+		_updateHeight: function(){
+			if(!this.isLoaded){ return; }
+			if(this.height){ return; }
+			if(this.iframe){
+				/*
+				if(!this.document.body[&quot;offsetHeight&quot;]){
+					return;
+				}
+				*/
+				// The height includes the padding, borders and margins so these
+				// need to be added on
+				var heights = [&quot;margin-top&quot;, &quot;margin-bottom&quot;,
+					&quot;padding-bottom&quot;, &quot;padding-top&quot;,
+					&quot;border-width-bottom&quot;, &quot;border-width-top&quot;];
+				for(var i = 0, chromeheight = 0; i &lt; heights.length; i++){
+					var height = dojo.style.getStyle(this.iframe, heights[i]);
+					// Safari doesn't have all the heights so we have to test
+					if(height){
+						chromeheight += Number(height.replace(/[^0-9]/g, &quot;&quot;));
+					}
+				}
+
+				if(this.document.body[&quot;offsetHeight&quot;]){
+					this._lastHeight = Math.max(this.document.body.scrollHeight, this.document.body.offsetHeight) + chromeheight;
+					this.iframe.height = this._lastHeight + &quot;px&quot;;
+					this.window.scrollTo(0, 0);
+				}
+				// dojo.debug(this.iframe.height);
+			}else if(this.object){
+				this.object.style.height = dojo.style.getInnerHeight(this.editNode)+&quot;px&quot;;
+			}
+		},
+		
+		/**
+		 * Saves the content in an onunload event if the editor has not been closed
+		 */
+		_saveContent: function(e){
+			var saveTextarea = document.getElementById(&quot;dojo.widget.RichText.savedContent&quot;);
+			saveTextarea.value += this._SEPARATOR + this.saveName + &quot;:&quot; + this.getEditorContent();
+		},
+
+		getEditorContent: function(){
+			var ec = &quot;&quot;;
+			try{
+				ec = (this._content.length &gt; 0) ? this._content : this.editNode.innerHTML;
+				if(dojo.string.trim(ec) == &quot;&nbsp;&quot;){ ec = &quot;&quot;; }
+			}catch(e){ /* squelch */ }
+
+			dojo.lang.forEach(this.contentFilters, function(ef){
+				ec = ef(ec);
+			});
+
+			if (this.relativeImageUrls) {
+				// why use a regexp instead of dom? because IE is stupid 
+				// and won't let us set img.src to a relative URL
+				// this comes after contentFilters because once content
+				// gets innerHTML'd img urls will be fully qualified
+				var siteBase = window.location.protocol + &quot;//&quot; + window.location.host;
+				var pathBase = window.location.pathname;
+				if (pathBase.match(/\/$/)) {
+					// ends with slash, match full path
+				} else {
+					// match parent path to find siblings
+					var pathParts = pathBase.split(&quot;/&quot;);
+					if (pathParts.length) {
+						pathParts.pop();
+					}
+					pathBase = pathParts.join(&quot;/&quot;) + &quot;/&quot;;
+
+				}
+				
+				var sameSite = new RegExp(&quot;(&lt;img[^&gt;]*\ src=[\&quot;'])(&quot;+siteBase+&quot;(&quot;+pathBase+&quot;)?)&quot;, &quot;ig&quot;);
+				ec = ec.replace(sameSite, &quot;$1&quot;);
+			}
+			return ec;
+		},
+		
+		/**
+		 * Kills the editor and optionally writes back the modified contents to the 
+		 * element from which it originated.
+		 *
+		 * @param save Whether or not to save the changes. If false, the changes are
+		 *             discarded.
+		 * @return true if the contents has been modified, false otherwise
+		 */
+		close: function(save, force){
+			if(this.isClosed){return false; }
+
+			if (arguments.length == 0) { save = true; }
+			this._content = this.editNode.innerHTML;
+			var changed = (this.savedContent.innerHTML != this._content);
+			
+			// line height is squashed for iframes
+			// FIXME: why was this here? if (this.iframe){ this.domNode.style.lineHeight = null; }
+
+			if(this.interval){ clearInterval(this.interval); }
+			
+			if(dojo.render.html.ie &amp;&amp; !this.object){
+				dojo.event.browser.clean(this.editNode);
+			}
+			
+			if (this.iframe) {
+				// FIXME: should keep iframe around for later re-use
+				delete this.iframe;
+			}
+			this.domNode.innerHTML = &quot;&quot;;
+
+			if(save){
+				// kill listeners on the saved content
+				dojo.event.browser.clean(this.savedContent);
+				if(dojo.render.html.moz){
+					var nc = document.createElement(&quot;span&quot;);
+					this.domNode.appendChild(nc);
+					nc.innerHTML = this.editNode.innerHTML;
+				}else{
+					this.domNode.innerHTML = this._content;
+				}
+			} else {
+				while (this.savedContent.hasChildNodes()) {
+					this.domNode.appendChild(this.savedContent.firstChild);
+				}
+			}
+			delete this.savedContent;
+			
+			dojo.html.removeClass(this.domNode, &quot;RichTextEditable&quot;);
+			this.isClosed = true;
+			this.isLoaded = false;
+			// FIXME: is this always the right thing to do?
+			delete this.editNode;
+
+			return changed;
+		},
+
+		destroyRendering: function(){}, // stub!
+		
+		destroy: function (){
+			this.destroyRendering();
+			if(!this.isClosed){ this.close(false); }
+		
+			// disconnect those listeners.
+			while(this._connected.length){
+				this.disconnect(this._connected[0],
+					this._connected[1], this._connected[2]);
+			}
+		},
+
+		_connected: [],
+		connect: function (targetObj, targetFunc, thisFunc) {
+			dojo.event.connect(targetObj, targetFunc, this, thisFunc);
+			// this._connected.push([targetObj, targetFunc, thisFunc]);	
+		},
+		
+		// FIXME: below two functions do not work with the above line commented out
+		disconnect: function (targetObj, targetFunc, thisFunc) {
+			for (var i = 0; i &lt; this._connected.length; i++) {
+				if (this._connected[0] == targetObj &amp;&amp;
+					this._connected[1] == targetFunc &amp;&amp;
+					this._connected[2] == thisFunc) {
+					dojo.event.disconnect(targetObj, targetFunc, this, thisFunc);
+					this._connected.splice(i, 1);
+					break;
+				}
+			}
+		},
+		
+		disconnectAllWithRoot: function (targetObj) {
+			for (var i = 0; i &lt; this._connected.length; i++) {
+				if (this._connected[0] == targetObj) {
+					dojo.event.disconnect(targetObj,
+						this._connected[1], this, this._connected[2]);
+					this._connected.splice(i, 1);
+				}
+			}	
+		}
+		
+	},
+	&quot;html&quot;,
+	function(){
+		this.contentFilters = [];
+		// this.contentFilters.push(this.defaultContentCleaner);
+		
+		this._keyHandlers = {};
+	}
+);

Added: trunk/root/static/magic/src/widget/Rounded.js
===================================================================
--- trunk/root/static/magic/src/widget/Rounded.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Rounded.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,713 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Rounded&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:rounded&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.html.ContentPane&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+/*
+ *	The following script is derived (with permission) from curvyCorners,
+ *	written by Cameron Cooke (CLA on file) and was adapted to Dojo by Brian
+ *	Lucas (CLA on file)
+ */
+
+dojo.widget.Rounded = function() {
+	dojo.widget.html.ContentPane.call(this);
+}
+
+dojo.inherits(dojo.widget.Rounded, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.Rounded, {
+	isSafari: dojo.render.html.safari,
+	widgetType: &quot;Rounded&quot;,
+	boxMargin: &quot;50px&quot;, // margin outside rounded corner box
+	radius: 14, // radius of corners
+	domNode: &quot;&quot;,
+	corners: &quot;TR,TL,BR,BL&quot;, // corner string to render
+	antiAlias: true, // false to disable anti-aliasing
+
+	fillInTemplate: function(args, frag) {
+		dojo.widget.Rounded.superclass.fillInTemplate.call(this, args, frag);
+
+		dojo.style.insertCssFile(this.templateCssPath);
+
+		// Magic to automatically calculate the box height/width if not supplied
+		if (this.domNode.style.height&lt;=0) {
+			var minHeight = (this.radius*1)+this.domNode.clientHeight;
+			this.domNode.style.height = minHeight+&quot;px&quot;;
+		}
+
+		if (this.domNode.style.width&lt;=0) {
+			var minWidth = (this.radius*1)+this.domNode.clientWidth;
+			this.domNode.style.width = minWidth+&quot;px&quot;;
+		}
+
+		var cornersAvailable = [&quot;TR&quot;, &quot;TL&quot;, &quot;BR&quot;, &quot;BL&quot;];
+		var cornersPassed = this.corners.split(&quot;,&quot;);
+
+		this.settings = {
+			antiAlias: this.antiAlias
+		};
+
+		var setCorner = function(currentCorner) {
+			var val = currentCorner.toLowerCase();
+			if(dojo.lang.inArray(cornersPassed, currentCorner)) {
+				this.settings[val] = { radius: this.radius, enabled: true };
+			} else {
+				this.settings[val] = { radius: 0 }
+			}
+		}
+		dojo.lang.forEach(cornersAvailable, setCorner, this);
+
+		this.domNode.style.margin = this.boxMargin;
+		this.curvyCorners(this.settings);
+		this.applyCorners();
+	},
+
+	// ------------- curvyCorners OBJECT
+
+	curvyCorners: function(settings){	
+
+		// Setup Globals
+		this.box             = this.domNode;
+		this.topContainer    = null;
+		this.bottomContainer = null;
+		this.masterCorners   = [];
+
+		// Get box formatting details
+		var boxHeight       = dojo.style.getStyle(this.box, &quot;height&quot;);
+		if(boxHeight==&quot;&quot;) boxHeight=&quot;0px&quot;;
+		var boxWidth        = dojo.style.getStyle(this.box, &quot;width&quot;);
+		var borderWidth     = dojo.style.getStyle(this.box, &quot;borderTopWidth&quot;);
+		if(borderWidth==&quot;&quot;) borderWidth=&quot;0px&quot;;
+		//alert(borderWidth);
+
+		var borderColour    = dojo.style.getStyle(this.box, &quot;borderTopColor&quot;);
+		// Set to true if we have a border
+		if(borderWidth&gt;0) this.antiAlias=true;
+
+		var boxColour       = dojo.style.getStyle(this.box, &quot;backgroundColor&quot;);
+		var backgroundImage = dojo.style.getStyle(this.box, &quot;backgroundImage&quot;);
+		var boxPosition     = dojo.style.getStyle(this.box, &quot;position&quot;);
+
+		// Set formatting propertes
+		this.boxHeight       = parseInt(((boxHeight != &quot;&quot; &amp;&amp; boxHeight != &quot;auto&quot; &amp;&amp; boxHeight.indexOf(&quot;%&quot;) == -1)? boxHeight.substring(0, boxHeight.indexOf(&quot;px&quot;)) : this.box.scrollHeight));
+		this.boxWidth        = parseInt(((boxWidth != &quot;&quot; &amp;&amp; boxWidth != &quot;auto&quot; &amp;&amp; boxWidth.indexOf(&quot;%&quot;) == -1)? boxWidth.substring(0, boxWidth.indexOf(&quot;px&quot;)) : this.box.scrollWidth));
+		this.borderWidth     = parseInt(((borderWidth != &quot;&quot; &amp;&amp; borderWidth.indexOf(&quot;px&quot;) !== -1)? borderWidth.slice(0, borderWidth.indexOf(&quot;px&quot;)) : 0));
+
+		// DEBUG ME?
+
+		//dojo.debug(this.rgb2Hex(boxColour));
+		var test  = new dojo.graphics.color.Color(boxColour);
+		//dojo.debug(test.toHex()); 
+
+		this.boxColour       = ((boxColour != &quot;&quot; &amp;&amp; boxColour != &quot;transparent&quot;)? ((boxColour.substr(0, 3) == &quot;rgb&quot;)? this.rgb2Hex(boxColour) : boxColour) : &quot;#ffffff&quot;);
+		this.borderColour    = ((borderColour != &quot;&quot; &amp;&amp; borderColour != &quot;transparent&quot; &amp;&amp; this.borderWidth &gt; 0)? ((borderColour.substr(0, 3) == &quot;rgb&quot;)? this.rgb2Hex(borderColour)  : borderColour) : this.boxColour);
+		this.borderString    = this.borderWidth + &quot;px&quot; + &quot; solid &quot; + this.borderColour;
+		this.backgroundImage = ((backgroundImage != &quot;none&quot;)? backgroundImage : &quot;&quot;);
+
+		// Make box relative if not already absolute
+		if(boxPosition != &quot;absolute&quot;) this.box.style.position = &quot;relative&quot;;
+
+		//This method creates the corners and
+		//applies them to the div element.
+
+		this.applyCorners = function() {
+			// Create top and bottom containers.
+			// These will be used as a parent for the corners and bars.
+			for(var t = 0; t &lt; 2; t++) {
+			    switch(t) {
+			        // Top
+			        case 0:
+						// Only build top bar if a top corner is to be draw
+						if(this.settings.tl.enabled || this.settings.tr.enabled ) {
+							var newMainContainer = document.createElement(&quot;DIV&quot;);
+			
+							with(newMainContainer.style){
+								width    = &quot;100%&quot;;
+								fontSize = &quot;1px&quot;;
+								overflow = &quot;hidden&quot;;
+								position = &quot;absolute&quot;;
+								//backgroundColor = &quot;#FFFFC4&quot;;
+								paddingLeft  = this.borderWidth + &quot;px&quot;;
+								paddingRight = this.borderWidth + &quot;px&quot;;
+								var topMaxRadius = Math.max(this.settings.tl ? this.settings.tl.radius : 0, this.settings.tr ? this.settings.tr.radius : 0);
+								height = topMaxRadius + &quot;px&quot;;
+								top    = 0 - topMaxRadius + &quot;px&quot;;
+								left   = 0 - this.borderWidth + &quot;px&quot;;
+							}
+							
+							this.topContainer = this.box.appendChild(newMainContainer);
+						}
+			            break;
+	
+			        // Bottom
+			        case 1:      
+			            // Only build bottom bar if a top corner is to be draw
+			            if(this.settings.bl.enabled || this.settings.br.enabled) {
+							var newMainContainer = document.createElement(&quot;DIV&quot;);
+							with(newMainContainer.style){
+								width    = &quot;100%&quot;;
+								fontSize = &quot;1px&quot;;
+								overflow = &quot;hidden&quot;;
+								position = &quot;absolute&quot;;
+								//backgroundColor = &quot;#FFFFC4&quot;;
+								paddingLeft  = this.borderWidth + &quot;px&quot;;
+								paddingRight = this.borderWidth + &quot;px&quot;;
+								var botMaxRadius = Math.max(this.settings.bl ? this.settings.bl.radius : 0, this.settings.br ? this.settings.br.radius : 0);
+								height  = botMaxRadius + &quot;px&quot;;
+								bottom  =  0 - botMaxRadius + &quot;px&quot;;
+								left    =  0 - this.borderWidth + &quot;px&quot;;
+							}
+						this.bottomContainer = this.box.appendChild(newMainContainer);
+			            }
+		            break;
+			    }
+			}
+	
+			// Turn off current borders
+			if(this.topContainer) this.box.style.borderTopWidth = &quot;0px&quot;;
+			if(this.bottomContainer) this.box.style.borderBottomWidth = &quot;0px&quot;;
+	
+			// Create array of available corners
+			var corners = [&quot;tr&quot;, &quot;tl&quot;, &quot;br&quot;, &quot;bl&quot;];
+		
+			//Loop for each corner
+	
+			for(var i in corners) {
+			    // Get current corner type from array
+			    var cc = corners[i];
+
+			    // Has the user requested the currentCorner be round?
+			    if(!this.settings[cc]) {
+			        // No
+			        if(((cc == &quot;tr&quot; || cc == &quot;tl&quot;) &amp;&amp; this.topContainer != null) || ((cc == &quot;br&quot; || cc == &quot;bl&quot;) &amp;&amp; this.bottomContainer != null)) {
+						// We need to create a filler div to fill the space upto the next horzontal corner.
+						var newCorner = document.createElement(&quot;DIV&quot;);
+		
+						// Setup corners properties
+						newCorner.style.position = &quot;relative&quot;;
+						newCorner.style.fontSize = &quot;1px&quot;;
+						newCorner.style.overflow = &quot;hidden&quot;;
+		
+						// Add background image?
+						if(this.backgroundImage == &quot;&quot;) {
+							newCorner.style.backgroundColor = this.boxColour;
+						} else {
+							newCorner.style.backgroundImage = this.backgroundImage;
+						}
+
+			            switch(cc) {
+							case &quot;tl&quot;:
+								with(newCorner.style){
+									height      = topMaxRadius - this.borderWidth + &quot;px&quot;;
+									marginRight = this.settings.tr.radius - (this.borderWidth*2) + &quot;px&quot;;
+									borderLeft  = this.borderString;
+									borderTop   = this.borderString;
+									left         = -this.borderWidth + &quot;px&quot;;
+								}
+							break;
+			
+							case &quot;tr&quot;:
+								with(newCorner.style){
+									height      = topMaxRadius - this.borderWidth + &quot;px&quot;;
+									marginLeft  = this.settings.tl.radius - (this.borderWidth*2) + &quot;px&quot;;
+									borderRight = this.borderString;
+									borderTop   = this.borderString;
+									backgroundPosition  = &quot;-&quot; + this.boxWidth + &quot;px 0px&quot;;
+									left         = this.borderWidth + &quot;px&quot;;
+								}
+							break;
+	
+							case &quot;bl&quot;:
+								with(newCorner.style){
+									height       = botMaxRadius - this.borderWidth + &quot;px&quot;;
+									marginRight  = this.settings.br.radius - (this.borderWidth*2) + &quot;px&quot;;
+									borderLeft   = this.borderString;
+									borderBottom = this.borderString;
+									left         = -this.borderWidth + &quot;px&quot;;
+								}
+							break;
+			
+							case &quot;br&quot;:
+								with(newCorner.style){
+									height       = botMaxRadius - this.borderWidth + &quot;px&quot;;
+									marginLeft   = this.settings.bl.radius - (this.borderWidth*2) + &quot;px&quot;;
+									borderRight  = this.borderString;
+									borderBottom = this.borderString;
+									left         = this.borderWidth + &quot;px&quot;
+								}
+							break;
+			            }
+			        }
+			    } else {
+			        /*
+			        PERFORMANCE NOTE:
+
+			        If more than one corner is requested and a corner has been already
+			        created for the same radius then that corner will be used as a master and cloned.
+			        The pixel bars will then be repositioned to form the new corner type.
+			        All new corners start as a bottom right corner.
+			        */
+			        if(this.masterCorners[this.settings[cc].radius]) {
+			            // Create clone of the master corner
+			            var newCorner = this.masterCorners[this.settings[cc].radius].cloneNode(true);
+			        } else {
+			            // Yes, we need to create a new corner
+			            var newCorner = document.createElement(&quot;DIV&quot;);
+						with(newCorner.style){
+							height = this.settings[cc].radius + &quot;px&quot;;
+							width  = this.settings[cc].radius + &quot;px&quot;;
+							position = &quot;absolute&quot;;
+							fontSize = &quot;1px&quot;;
+							overflow = &quot;hidden&quot;;
+						}
+						// THE FOLLOWING BLOCK OF CODE CREATES A ROUNDED CORNER
+						// ---------------------------------------------------- TOP
+			
+						// Get border radius
+						var borderRadius = parseInt(this.settings[cc].radius - this.borderWidth);
+			
+						// Cycle the x-axis
+						for(var intx = 0, j = this.settings[cc].radius; intx &lt; j; intx++) {
+							// Calculate the value of y1 which identifies the pixels inside the border
+							if((intx +1) &gt;= borderRadius) {
+								var y1 = -1;
+							} else {
+								var y1 = (Math.floor(Math.sqrt(Math.pow(borderRadius, 2) - Math.pow((intx+1), 2))) - 1);
+							}
+			
+							// Only calculate y2 and y3 if there is a border defined
+							if(borderRadius != j) {
+								if((intx) &gt;= borderRadius) {
+									var y2 = -1;
+								} else {
+									var y2 = Math.ceil(Math.sqrt(Math.pow(borderRadius,2) - Math.pow(intx, 2)));
+								}
+			
+								if((intx+1) &gt;= j) {
+									var y3 = -1;
+								} else {
+									var y3 = (Math.floor(Math.sqrt(Math.pow(j ,2) - Math.pow((intx+1), 2))) - 1);
+								}
+							}
+
+							// Calculate y4
+							if((intx) &gt;= j) {
+								var y4 = -1;
+							} else {
+								var y4 = Math.ceil(Math.sqrt(Math.pow(j ,2) - Math.pow(intx, 2)));
+							}
+
+							// Draw bar on inside of the border with foreground colour
+							if(y1 &gt; -1) this.drawPixel(intx, 0, this.boxColour, 100, (y1+1), newCorner, -1, this.settings[cc].radius);
+	
+							// Only draw border/foreground antialiased pixels and border if there is a border defined
+							if(borderRadius != j) {
+								// Draw aa pixels?
+								if(this.antiAlias) {
+									// Cycle the y-axis
+									for(var inty = (y1 + 1); inty &lt; y2; inty++) {
+										// For each of the pixels that need anti aliasing between the foreground and border colour draw single pixel divs
+										if(this.backgroundImage != &quot;&quot;) {					
+											var borderFract = (this.pixelFraction(intx, inty, borderRadius) * 100);
+					
+											if (borderFract &lt; 30) {
+												this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, 0, this.settings[cc].radius);
+											} else {
+												this.drawPixel(intx, inty, this.borderColour, 100, 1, newCorner, -1, this.settings[cc].radius);
+											}
+										} else {
+											var pixelcolour = dojo.graphics.color.blend(this.boxColour, this.borderColour, this.pixelFraction(intx, inty, borderRadius));
+											this.drawPixel(intx, inty, pixelcolour, 100, 1, newCorner, 0, this.settings[cc].radius);
+										}
+									}
+								}
+
+								// Draw bar for the border
+								if(y3 &gt;= y2) {
+									if (y1 == -1) {
+										y1 = 0;
+									}
+									this.drawPixel(intx, y2, this.borderColour, 100, (y3 - y2 + 1), newCorner, 0, this.settings[cc].radius);
+								}	
+								// Set the colour for the outside curve
+								var outsideColour = this.borderColour;
+							} else {
+								// Set the coour for the outside curve
+								var outsideColour = this.boxColour;
+								var y3 = y1;
+							}
+			
+							// Draw aa pixels?
+							if(this.antiAlias) {		
+								// Cycle the y-axis and draw the anti aliased pixels on the
+								// outside of the curve
+								for(var inty = (y3 + 1); inty &lt; y4; inty++) {
+									// For each of the pixels that need anti aliasing between 
+									//the foreground/border colour &amp; background draw single pixel divs
+									this.drawPixel(intx, inty, outsideColour, (this.pixelFraction(intx, inty , j) * 100), 1, newCorner, ((this.borderWidth &gt; 0)? 0 : -1), this.settings[cc].radius);
+								}
+							}
+			            }
+
+			            // END OF CORNER CREATION
+			            // ---------------------------------------------------- END
+
+			            // We now need to store the current corner in the masterConers array
+			            this.masterCorners[this.settings[cc].radius] = newCorner.cloneNode(true);
+			        }
+			
+					//Now we have a new corner we need to reposition all the pixels unless
+					//the current corner is the bottom right.
+			        if(cc != &quot;br&quot;) {	
+						// Loop through all children (pixel bars)
+						for(var t = 0, k = newCorner.childNodes.length; t &lt; k; t++) {
+							// Get current pixel bar
+							var pixelBar = newCorner.childNodes[t];
+	
+							// Get current top and left properties
+							var pixelBarTop    = parseInt(pixelBar.style.top.substring(0, pixelBar.style.top.indexOf(&quot;px&quot;)));
+							var pixelBarLeft   = parseInt(pixelBar.style.left.substring(0, pixelBar.style.left.indexOf(&quot;px&quot;)));
+							var pixelBarHeight = parseInt(pixelBar.style.height.substring(0, pixelBar.style.height.indexOf(&quot;px&quot;)));
+							
+							// Reposition pixels
+							if(cc == &quot;tl&quot; || cc == &quot;bl&quot;) {
+								pixelBar.style.left = this.settings[cc].radius -pixelBarLeft -1 + &quot;px&quot;; // Left
+							}
+							if(cc == &quot;tr&quot; || cc == &quot;tl&quot;) {
+								pixelBar.style.top =  this.settings[cc].radius -pixelBarHeight -pixelBarTop + &quot;px&quot;; // Top
+							}
+							var value;
+					
+							switch(cc) {
+								case &quot;tr&quot;:
+									value = (-1 *( Math.abs((this.boxWidth - this.settings[cc].radius + this.borderWidth) + pixelBarLeft) - (Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - this.borderWidth))));
+									pixelBar.style.backgroundPosition  = value + &quot;px&quot;;
+									
+								break;
+				
+								case &quot;tl&quot;:
+									value = (-1 *( Math.abs((this.settings[cc].radius -pixelBarLeft -1)  - this.borderWidth) - (Math.abs(this.settings[cc].radius -pixelBarHeight -pixelBarTop - this.borderWidth))));
+									pixelBar.style.backgroundPosition  = value + &quot;px&quot;;
+
+								break;
+				
+								case &quot;bl&quot;:
+									value = (-1 *( Math.abs((this.settings[cc].radius -pixelBarLeft -1) - this.borderWidth) - (Math.abs((this.boxHeight + this.settings[cc].radius + pixelBarTop) -this.borderWidth))));
+									pixelBar.style.backgroundPosition  = value + &quot;px&quot;;
+
+								break;
+							}
+						}
+					}
+				}
+				if(newCorner) {
+					// Position the container
+					switch(cc) {
+						case &quot;tl&quot;:
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.top  = &quot;0px&quot;;
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.left = &quot;0px&quot;;
+							if(this.topContainer) this.topContainer.appendChild(newCorner);
+						break;
+
+						case &quot;tr&quot;:
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.top  = &quot;0px&quot;;
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.right = &quot;0px&quot;;
+							if(this.topContainer) this.topContainer.appendChild(newCorner);
+						break;
+		
+						case &quot;bl&quot;:
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.bottom  = &quot;0px&quot;;
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.left = &quot;0px&quot;;
+							if(this.bottomContainer) this.bottomContainer.appendChild(newCorner);
+						break;
+						
+						case &quot;br&quot;:
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.bottom = &quot;0px&quot;;
+							if(newCorner.style.position == &quot;absolute&quot;) newCorner.style.right = &quot;0px&quot;;
+							if(this.bottomContainer) this.bottomContainer.appendChild(newCorner);
+						break;
+					}
+				}
+			}
+			//The last thing to do is draw the rest of the filler DIVs.
+			//We only need to create a filler DIVs when two corners have
+			//diffrent radiuses in either the top or bottom container.
+	
+			// Find out which corner has the biiger radius and get the difference amount
+			var radiusDiff = [];
+			radiusDiff[&quot;t&quot;] = this.settings.tl.enabled &amp;&amp; this.settings.tr.enabled ? Math.abs(this.settings.tl.radius - this.settings.tr.radius) : 0;
+			radiusDiff[&quot;b&quot;] = this.settings.bl.enabled &amp;&amp; this.settings.br.enabled ? Math.abs(this.settings.bl.radius - this.settings.br.radius) : 0;
+
+			for(var z in radiusDiff) {
+				if(radiusDiff[z]) {
+					// Get the type of corner that is the smaller one
+					var smallerCornerType = ((this.settings[z + &quot;l&quot;].radius &lt; this.settings[z + &quot;r&quot;].radius)? z +&quot;l&quot; : z +&quot;r&quot;);
+
+					// First we need to create a DIV for the space under the smaller corner
+					var newFiller = document.createElement(&quot;DIV&quot;);
+					with(newFiller.style) {
+						height = radiusDiff[z] + &quot;px&quot;;
+						width  =  this.settings[smallerCornerType].radius+ &quot;px&quot;
+						position = &quot;absolute&quot;;
+						fontSize = &quot;1px&quot;;
+						overflow = &quot;hidden&quot;;
+						backgroundColor = this.boxColour;
+					}
+
+					// Position filler
+					switch(smallerCornerType) {
+						case &quot;tl&quot;:
+							with(newFiller.style) {
+								bottom = &quot;0px&quot;;
+								left   = &quot;0px&quot;;
+								borderLeft = this.borderString;
+							}
+							this.topContainer.appendChild(newFiller);
+						break;
+	
+						case &quot;tr&quot;:
+							with(newFiller.style) {
+								bottom = &quot;0px&quot;;
+								right  = &quot;0px&quot;;
+								borderRight = this.borderString;
+							}
+							this.topContainer.appendChild(newFiller);
+						break;
+
+						case &quot;bl&quot;:
+							with(newFiller.style) {
+								top    = &quot;0px&quot;;
+								left   = &quot;0px&quot;;
+								borderLeft = this.borderString;
+							}
+							this.bottomContainer.appendChild(newFiller);
+						break;
+
+						case &quot;br&quot;:
+							with(newFiller.style) {
+								top    = &quot;0px&quot;;
+								right  = &quot;0px&quot;;
+								borderRight = this.borderString;
+							}
+							this.bottomContainer.appendChild(newFiller);
+						break;
+					}
+			    }
+
+				// Create the bar to fill the gap between each corner horizontally
+				var newFillerBar = document.createElement(&quot;DIV&quot;);
+				with(newFillerBar.style) {
+					position = &quot;relative&quot;;
+					fontSize = &quot;1px&quot;;
+					overflow = &quot;hidden&quot;;
+					backgroundColor = this.boxColour;
+				}
+
+				switch(z) {
+					case &quot;t&quot;:
+						// Top Bar
+						if(this.topContainer) {
+							with(newFillerBar.style) {
+								height      = topMaxRadius - this.borderWidth + &quot;px&quot;;
+								marginLeft  = this.settings.tl.radius - this.borderWidth + &quot;px&quot;;
+								marginRight = this.settings.tr.radius - this.borderWidth + &quot;px&quot;;
+								borderTop   = this.borderString;
+							}
+						this.topContainer.appendChild(newFillerBar);
+						}
+					break;
+
+					case &quot;b&quot;:
+						if(this.bottomContainer) {
+						// Bottom Bar
+						with(newFillerBar.style) {
+							height       = botMaxRadius - this.borderWidth + &quot;px&quot;;
+							marginLeft   = this.settings.bl.radius - this.borderWidth + &quot;px&quot;;
+							marginRight  = this.settings.br.radius - this.borderWidth + &quot;px&quot;;
+							borderBottom = this.borderString;
+						}
+						this.bottomContainer.appendChild(newFillerBar);
+					}
+					break;
+				}
+			}
+		}
+
+		// This function draws the pixles
+		this.drawPixel = function(intx, inty, colour, transAmount, height, newCorner, image, cornerRadius) {
+			// Create pixel
+			var pixel = document.createElement(&quot;DIV&quot;);
+
+			
+			// Section doesn't like with (pixel.style) { DEBUG?
+			pixel.style.height   = height + &quot;px&quot;;
+			pixel.style.width    = &quot;1px&quot;;
+			pixel.style.position = &quot;absolute&quot;;
+			pixel.style.fontSize = &quot;1px&quot;;
+			pixel.style.overflow = &quot;hidden&quot;;
+			
+			// Dont apply background image to border pixels
+			if(image == -1 &amp;&amp; this.backgroundImage != &quot;&quot;) {
+				pixel.style.backgroundImage = this.backgroundImage;
+				pixel.style.backgroundPosition  = &quot;-&quot; + (this.boxWidth - (cornerRadius - intx) + this.borderWidth) + &quot;px -&quot; + ((this.boxHeight + cornerRadius + inty) -this.borderWidth) + &quot;px&quot;;
+			} else {
+				pixel.style.backgroundColor = colour;
+			}
+			
+			// Set opacity if the transparency is anything other than 100
+			if (transAmount != 100) {
+				dojo.style.setOpacity(pixel, transAmount);
+			}
+			// Set the pixels position
+			pixel.style.top = inty + &quot;px&quot;;
+			pixel.style.left = intx + &quot;px&quot;;
+		
+			newCorner.appendChild(pixel);
+		}
+	},
+
+	//For a pixel cut by the line determines the fraction of the pixel on the 'inside' of the
+	//line.  Returns a number between 0 and 1
+	pixelFraction: function(x, y, r) {
+		var pixelfraction = 0;
+		
+		//determine the co-ordinates of the two points on the perimeter of the pixel that the
+		//circle crosses
+		
+		var xvalues = [];
+		var yvalues = [];
+		var point = 0;
+		var whatsides = &quot;&quot;;
+
+		// x + 0 = Left
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(x,2)));
+
+		if ((intersect &gt;= y) &amp;&amp; (intersect &lt; (y+1))) {
+			whatsides = &quot;Left&quot;;
+			xvalues[point] = 0;
+			yvalues[point] = intersect - y;
+			point =  point + 1;
+		}
+
+		// y + 1 = Top
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(y+1,2)));
+		
+		if ((intersect &gt;= x) &amp;&amp; (intersect &lt; (x+1))) {
+			whatsides = whatsides + &quot;Top&quot;;
+			xvalues[point] = intersect - x;
+			yvalues[point] = 1;
+			point = point + 1;
+		}
+		// x + 1 = Right
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(x+1,2)));
+
+		if ((intersect &gt;= y) &amp;&amp; (intersect &lt; (y+1))) {
+			whatsides = whatsides + &quot;Right&quot;;
+			xvalues[point] = 1;
+			yvalues[point] = intersect - y;
+			point =  point + 1;
+		}
+		// y + 0 = Bottom
+		var intersect = Math.sqrt((Math.pow(r,2) - Math.pow(y,2)));
+
+		if ((intersect &gt;= x) &amp;&amp; (intersect &lt; (x+1))) {
+			whatsides = whatsides + &quot;Bottom&quot;;
+			xvalues[point] = intersect - x;
+			yvalues[point] = 0;
+		}
+
+	    //depending on which sides of the perimeter of the pixel the circle crosses calculate the
+	    //fraction of the pixel inside the circle
+
+		switch (whatsides) {
+			case &quot;LeftRight&quot;:
+				pixelfraction = Math.min(yvalues[0],yvalues[1]) + ((Math.max(yvalues[0],yvalues[1]) - Math.min(yvalues[0],yvalues[1]))/2);
+			break;
+			
+			case &quot;TopRight&quot;:
+				pixelfraction = 1-(((1-xvalues[0])*(1-yvalues[1]))/2);
+			break;
+			
+			case &quot;TopBottom&quot;:
+				pixelfraction = Math.min(xvalues[0],xvalues[1]) + ((Math.max(xvalues[0],xvalues[1]) - Math.min(xvalues[0],xvalues[1]))/2);
+			break;
+			
+			case &quot;LeftBottom&quot;:
+				pixelfraction = (yvalues[0]*xvalues[1])/2;
+			break;
+			
+			default:
+				pixelfraction = 1;
+	    }
+	    return pixelfraction;
+	},
+
+	// This function converts CSS rgb(x, x, x) to hexadecimal
+	rgb2Hex: function (rgbColour) {
+		try{	
+			// Get array of RGB values
+			var rgbArray = this.rgb2Array(rgbColour);
+			
+			// Get RGB values
+			var red   = parseInt(rgbArray[0]);
+			var green = parseInt(rgbArray[1]);
+			var blue  = parseInt(rgbArray[2]);
+			
+			// Build hex colour code
+			var hexColour = &quot;#&quot; + this.intToHex(red) + this.intToHex(green) + this.intToHex(blue);
+		}
+		catch(e){ alert(&quot;There was an error converting the RGB value to Hexadecimal in function rgb2Hex&quot;);
+		}
+		return hexColour;
+	},
+
+	//Converts a number to hexadecimal format
+
+	intToHex: function (strNum) {
+		var base = strNum / 16;
+		var rem = strNum % 16;
+		var base = base - (rem / 16);
+		var baseS = this.makeHex(base);
+		var remS = this.makeHex(rem);
+		return baseS + '' + remS;
+	},
+	//gets the hex bits of a number
+
+	makeHex: function(x) {
+		if((x &gt;= 0) &amp;&amp; (x &lt;= 9)) {
+			return x;
+		} else {
+			switch(x) {
+				case 10: return &quot;A&quot;;
+				case 11: return &quot;B&quot;;
+				case 12: return &quot;C&quot;;
+				case 13: return &quot;D&quot;;
+				case 14: return &quot;E&quot;;
+				case 15: return &quot;F&quot;;
+			}
+		}
+	},
+
+	// Returns an array of rbg values
+	rgb2Array: function(rgbColour) {
+		// Remove rgb()
+		var rgbValues = rgbColour.substring(4, rgbColour.indexOf(&quot;)&quot;));
+	
+		// Split RGB into array
+		var rgbArray = rgbValues.split(&quot;, &quot;);
+		return rgbArray;
+	}
+}); // end function

Added: trunk/root/static/magic/src/widget/Select.js
===================================================================
--- trunk/root/static/magic/src/widget/Select.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Select.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,76 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Select&quot;);
+dojo.provide(&quot;dojo.widget.html.Select&quot;);
+
+dojo.require(&quot;dojo.widget.html.ComboBox&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.html.stabile&quot;);
+
+/*
+ * The Select widget is an enhanced version of HTML's &lt;select&gt; tag.
+ *
+ * Similar features:
+ *   - There is a drop down list of possible values.
+ *   - You can only enter a value from the drop down list.  (You can't enter an arbitrary value.)
+ *   - The value submitted with the form is the hidden value (ex: CA),
+       not the displayed value a.k.a. label (ex: California)
+ *
+ * Enhancements over plain HTML version:
+ *   - If you type in some text then it will filter down the list of possible values in the drop down list.
+ *   - List can be specified either as a static list or via a javascript function (that can get the list from a server)
+ */
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Select&quot;,
+	dojo.widget.html.ComboBox,
+	{
+		widgetType: &quot;Select&quot;,
+		forceValidOption: true,
+
+		setValue: function(value) {
+			this.comboBoxValue.value = value;
+			dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
+		},
+
+		setLabel: function(value){
+			// FIXME, not sure what to do here!
+			this.comboBoxSelectionValue.value = value;
+			if (this.textInputNode.value != value) { // prevent mucking up of selection
+				this.textInputNode.value = value;
+			}
+		},	  
+
+		getLabel: function(){
+			return this.comboBoxSelectionValue.value;
+		},
+
+		getState: function() {
+			return {
+				value: this.getValue(),
+				label: this.getLabel()
+			};
+		},
+
+		onKeyUp: function(evt){
+			this.setLabel(this.textInputNode.value);
+		},
+
+		setState: function(state) {
+			this.setValue(state.value);
+			this.setLabel(state.label);
+		},
+
+		setAllValues: function(value1, value2){
+			this.setValue(value2);
+			this.setLabel(value1);
+		}
+	});

Added: trunk/root/static/magic/src/widget/Show.js
===================================================================
--- trunk/root/static/magic/src/widget/Show.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Show.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,45 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Show&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+
+dojo.widget.Show = function(){}
+dojo.lang.extend(dojo.widget.Show, {
+	isContainer: true,
+	_slide: -1,
+	_slides: [],
+	gotoSlide: function(/*int*/ slide){
+		this._slide = slide;
+		// summary: Placeholder
+	},
+	nextSlide: function(/*Event?*/ event){
+		if(!this._slides[this._slide].nextAction(event)){
+			if((this._slide + 1) != this._slides.length){
+				this.gotoSlide(this._slide + 1);
+				return true; // boolean
+			}
+			return false; // boolean
+		}
+	},
+	previousSlide: function(/*Event?*/ event){
+		if(!this._slides[this._slide].previousAction(event)){
+			if((this._slide - 1) != -1){
+				this.gotoSlide(this._slide - 1);
+				return true; // boolean
+			}
+			return false; // boolean
+		}
+	}
+});
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.Show&quot;);
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/ShowAction.js
===================================================================
--- trunk/root/static/magic/src/widget/ShowAction.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ShowAction.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,26 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ShowAction&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+
+dojo.widget.ShowAction = function(){}
+dojo.lang.extend(dojo.widget.ShowAction, {
+	on: &quot;&quot;,
+	action: &quot;&quot;,
+	duration: 0,
+	from: &quot;&quot;,
+	to: &quot;&quot;,
+	auto: &quot;false&quot;
+});
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.ShowAction&quot;);
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/ShowSlide.js
===================================================================
--- trunk/root/static/magic/src/widget/ShowSlide.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/ShowSlide.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,43 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ShowSlide&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+
+dojo.widget.ShowSlide = function(){
+}
+dojo.lang.extend(dojo.widget.ShowSlide, {
+	title: &quot;&quot;,
+	_action: -1,
+	isContainer: true,
+	_components: {},
+	_actions: [],
+	gotoAction: function(/*int*/ action){
+		this._action = action;
+	},
+	nextAction: function(/*Event?*/ event){
+		if((this._action + 1) != this._actions.length){
+			++this._action;
+			return true; // boolean
+		}
+		return false; // boolean
+	},
+	previousAction: function(/*Event?*/ event){
+		if((this._action - 1) != -1){
+			--this._action;
+			return true; // boolean
+		}
+		return false; // boolean
+	}
+});
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.ShowSlide&quot;);
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/SimpleDropdownButtons.js
===================================================================
--- trunk/root/static/magic/src/widget/SimpleDropdownButtons.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SimpleDropdownButtons.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,158 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/* TODO:
+ * - make the dropdowns &quot;smart&quot; so they can't get cutoff on bottom of page, sides of page, etc.
+ * - unify menus with the MenuItem and Menu classes so we can add stuff to all menus at once
+ * - allow buttons to be enabled/disabled at runtime
+ *     - this probably means creating all menus upfront and then triggering a disable action
+ *       for disabled buttons in the constructor loop. we'll need a disable and enable action anyway
+ * - should each button with menu be a widget object of it's own?
+ */
+dojo.provide(&quot;dojo.widget.SimpleDropdownButtons&quot;);
+dojo.provide(&quot;dojo.widget.HtmlSimpleDropdownButtons&quot;);
+
+dojo.deprecated(&quot;dojo.widget.SimpleDropdownButtons&quot;,  &quot;use dojo.widget.DropDownButton&quot;, &quot;0.4&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.uri.Uri&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:simpledropdownbuttons&quot;);
+
+dojo.widget.HtmlSimpleDropdownButtons = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+	this.widgetType = &quot;SimpleDropdownButtons&quot;;
+	this.templateCssPath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlSimpleDropdownButtons.css&quot;);
+
+	this.menuTriggerClass = &quot;dojoSimpleDropdownButtons&quot;;
+	this.menuClass = &quot;dojoSimpleDropdownButtonsMenu&quot;;
+
+	// overwrite buildRendering so we don't clobber our list
+	this.buildRendering = function(args, frag) {
+		if(this.templateCssPath) {
+			dojo.style.insertCssFile(this.templateCssPath, null, true);
+		}
+		this.domNode = frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()][&quot;nodeRef&quot;];
+
+		var menu = this.domNode;
+		if( !dojo.html.hasClass(menu, this.menuTriggerClass) ) {
+			dojo.html.addClass(menu, this.menuTriggerClass);
+		}
+		var li = dojo.dom.getFirstChildElement(menu);
+		var menuIDs = [];
+		var arrowIDs = [];
+
+		while(li) {
+			if(li.getElementsByTagName(&quot;ul&quot;).length &gt; 0) {
+				var a = dojo.dom.getFirstChildElement(li);
+				var arrow = document.createElement(&quot;a&quot;);
+				arrow.href = &quot;javascript:;&quot;;
+				arrow.innerHTML = &quot;&nbsp;&quot;;
+				dojo.html.setClass(arrow, &quot;downArrow&quot;);
+				if(!arrow.id) {
+					arrow.id = dojo.dom.getUniqueId();
+				}
+				arrowIDs.push(arrow.id);
+				var submenu = dojo.dom.getNextSiblingElement(a);
+				if(!submenu.id) {
+					submenu.id = dojo.dom.getUniqueId();
+				}
+				menuIDs.push(submenu.id);
+
+				if( dojo.html.hasClass(a, &quot;disabled&quot;) ) {
+					dojo.html.addClass(arrow, &quot;disabled&quot;);
+					dojo.html.disableSelection(li);
+					arrow.onfocus = function(){ this.blur(); }
+				} else {
+					dojo.html.addClass(submenu, this.menuClass);
+					document.body.appendChild(submenu);
+					dojo.event.connect(arrow, &quot;onmousedown&quot;, (function() {
+						var ar = arrow;
+						return function(e) {
+							dojo.html.addClass(ar, &quot;pressed&quot;);
+						}
+					})());
+					dojo.event.connect(arrow, &quot;onclick&quot;, (function() {
+						var aa = a;
+						var ar = arrow;
+						var sm = submenu;
+						var setWidth = false;
+
+						return function(e) {
+							hideAll(sm, ar);
+							sm.style.left = (dojo.html.getScrollLeft()
+								+ e.clientX - e.layerX + aa.offsetLeft) + &quot;px&quot;;
+							sm.style.top = (dojo.html.getScrollTop() + e.clientY
+								- e.layerY + aa.offsetTop + aa.offsetHeight) + &quot;px&quot;;
+							sm.style.display = sm.style.display == &quot;block&quot; ? &quot;none&quot; : &quot;block&quot;;
+							if(sm.style.display == &quot;none&quot;) {
+								dojo.html.removeClass(ar, &quot;pressed&quot;);
+								e.target.blur()
+							}
+							if(!setWidth &amp;&amp; sm.style.display == &quot;block&quot;
+								&amp;&amp; sm.offsetWidth &lt; aa.offsetWidth + ar.offsetWidth) {
+								sm.style.width = aa.offsetWidth + ar.offsetWidth + &quot;px&quot;;
+								setWidth = true;
+							}
+							e.preventDefault();
+						}
+					})());
+				}
+
+				dojo.event.connect(a, &quot;onclick&quot;, function(e) {
+					if(e &amp;&amp; e.target &amp;&amp; e.target.blur) {
+						e.target.blur();
+					}
+				});
+
+				if(a.nextSibling) {
+					li.insertBefore(arrow, a.nextSibling);
+				} else {
+					li.appendChild(arrow);
+				}
+
+			}
+			li = dojo.dom.getNextSiblingElement(li);
+		}
+
+		function hideAll(excludeMenu, excludeArrow) {
+			// hide menus
+			for(var i = 0; i &lt; menuIDs.length; i++) {
+				var m = document.getElementById(menuIDs[i]);
+				if(!excludeMenu || m != excludeMenu) {
+					document.getElementById(menuIDs[i]).style.display = &quot;none&quot;;
+				}
+			}
+			// restore arrows to non-pressed state
+			for(var i = 0; i &lt; arrowIDs.length; i++) {
+				var m = document.getElementById(arrowIDs[i]);
+				if(!excludeArrow || m != excludeArrow) {
+					dojo.html.removeClass(m, &quot;pressed&quot;);
+				}
+			}
+		}
+
+		dojo.event.connect(document.documentElement, &quot;onmousedown&quot;, function(e) {
+			if( dojo.html.hasClass(e.target, &quot;downArrow&quot;) ) { return };
+			for(var i = 0; i &lt; menuIDs.length; i++) {
+				if( dojo.dom.isDescendantOf(e.target, document.getElementById(menuIDs[i])) ) {
+					return;
+				}
+			}
+			hideAll();
+		});
+	}
+}
+dojo.inherits(dojo.widget.HtmlSimpleDropdownButtons, dojo.widget.HtmlWidget);

Added: trunk/root/static/magic/src/widget/SlideShow.js
===================================================================
--- trunk/root/static/magic/src/widget/SlideShow.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SlideShow.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,132 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.SlideShow&quot;);
+dojo.provide(&quot;dojo.widget.html.SlideShow&quot;);
+
+dojo.require(&quot;dojo.event&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.SlideShow&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlSlideShow.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlSlideShow.css&quot;),
+
+		// over-ride some defaults
+		isContainer: false,
+		widgetType: &quot;SlideShow&quot;,
+
+		// useful properties
+		imgUrls: [],		// the images we'll go through
+		imgUrlBase: &quot;&quot;,
+		urlsIdx: 0,		// where in the images we are
+		delay: 4000, 		// give it 4 seconds
+		transitionInterval: 2000, // 2 seconds
+		imgWidth: 800,	// img width
+		imgHeight: 600,	// img height
+		background: &quot;img2&quot;, // what's in the bg
+		foreground: &quot;img1&quot;, // what's in the fg
+		stopped: false,	// should I stay or should I go?
+		fadeAnim: null, // references our animation
+
+		// our DOM nodes:
+		imagesContainer: null,
+		startStopButton: null,
+		controlsContainer: null,
+		img1: null,
+		img2: null,
+
+		fillInTemplate: function(){
+			dojo.style.setOpacity(this.img1, 0.9999);
+			dojo.style.setOpacity(this.img2, 0.9999);
+			with(this.imagesContainer.style){
+				width = this.imgWidth+&quot;px&quot;;
+				height = this.imgHeight+&quot;px&quot;;
+			}
+			with(this.img1.style){
+				width = this.imgWidth+&quot;px&quot;;
+				height = this.imgHeight+&quot;px&quot;;
+			}
+			with(this.img2.style){
+				width = this.imgWidth+&quot;px&quot;;
+				height = this.imgHeight+&quot;px&quot;;
+			}
+			if(this.imgUrls.length&gt;1){
+				this.img2.src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
+				this.endTransition();
+			}else{
+				this.img1.src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
+			}
+		},
+
+		togglePaused: function(){
+			if(this.stopped){
+				this.stopped = false;
+				this.backgroundImageLoaded();
+				this.startStopButton.value= &quot;pause&quot;;
+			}else{
+				this.stopped = true;
+				this.startStopButton.value= &quot;play&quot;;
+			}
+		},
+
+		backgroundImageLoaded: function(){
+			// start fading out the foreground image
+			if(this.stopped){ return; }
+
+			// actually start the fadeOut effect
+			// NOTE: if we wanted to use other transition types, we'd set them up
+			// 		 here as well
+			if(this.fadeAnim) {
+				this.fadeAnim.stop();
+			}
+			this.fadeAnim = dojo.lfx.fadeOut(this[this.foreground], 
+				this.transitionInterval, null);
+			dojo.event.connect(this.fadeAnim,&quot;onEnd&quot;,this,&quot;endTransition&quot;);
+			this.fadeAnim.play();
+		},
+
+		endTransition: function(){
+			// move the foreground image to the background 
+			with(this[this.background].style){ zIndex = parseInt(zIndex)+1; }
+			with(this[this.foreground].style){ zIndex = parseInt(zIndex)-1; }
+
+			// fg/bg book-keeping
+			var tmp = this.foreground;
+			this.foreground = this.background;
+			this.background = tmp;
+
+			// keep on truckin
+			this.loadNextImage();
+		},
+
+		loadNextImage: function(){
+			// load a new image in that container, and make sure it informs
+			// us when it finishes loading
+			dojo.event.kwConnect({
+				srcObj: this[this.background],
+				srcFunc: &quot;onload&quot;,
+				adviceObj: this,
+				adviceFunc: &quot;backgroundImageLoaded&quot;,
+				once: true, // make sure we only ever hear about it once
+				delay: this.delay
+			});
+			dojo.style.setOpacity(this[this.background], 1.0);
+			this[this.background].src = this.imgUrlBase+this.imgUrls[this.urlsIdx++];
+			if(this.urlsIdx&gt;(this.imgUrls.length-1)){
+				this.urlsIdx = 0;
+			}
+		}
+	}
+);

Added: trunk/root/static/magic/src/widget/SortableTable.js
===================================================================
--- trunk/root/static/magic/src/widget/SortableTable.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SortableTable.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,38 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.SortableTable&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.SortableTable&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:sortableTable&quot;);
+
+//	set up the general widget
+dojo.widget.SortableTable=function(){
+	//	summary
+	//	base class for the SortableTable
+	dojo.widget.Widget.call(this);
+	this.widgetType=&quot;SortableTable&quot;;
+	this.isContainer=false;
+
+	//	custom properties
+	this.enableMultipleSelect=false;
+	this.maximumNumberOfSelections=0;	//	0 for unlimited, is the default.
+	this.enableAlternateRows=false;
+	this.minRows=0;	//	0 means ignore.
+	this.defaultDateFormat=&quot;%D&quot;;
+	this.data=[];
+	this.selected=[];		//	always an array to handle multiple selections.
+	this.columns=[];
+	this.sortIndex=0;		//	index of the column sorted on, first is the default.
+	this.sortDirection=0;	//	0==asc, 1==desc
+	this.valueField=&quot;Id&quot;;	//	if a JSON structure is parsed and there is a field of this name,
+							//	a value attribute will be added to the row (tr value=&quot;{Id}&quot;)
+};
+dojo.inherits(dojo.widget.SortableTable, dojo.widget.Widget);

Added: trunk/root/static/magic/src/widget/Spinner.js
===================================================================
--- trunk/root/static/magic/src/widget/Spinner.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Spinner.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,194 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Spinner&quot;);
+dojo.provide(&quot;dojo.widget.AdjustableIntegerTextbox&quot;);
+
+dojo.require(&quot;dojo.widget.validate.IntegerTextbox&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+/*
+  ****** AdjustableIntegerTextbox ******
+
+  A subclass of IntegerTextbox.
+*/
+dojo.widget.AdjustableIntegerTextbox = function(node) {
+        // this property isn't a primitive and needs to be created on a per-item basis.
+        this.flags = {};
+}
+dojo.inherits(dojo.widget.AdjustableIntegerTextbox, dojo.widget.validate.IntegerTextbox);
+dojo.lang.extend(dojo.widget.AdjustableIntegerTextbox, {
+        // new subclass properties
+        widgetType: &quot;AdjustableIntegerTextbox&quot;,
+		delta: &quot;1&quot;,
+
+        adjustValue: function(direction, x){
+			var val = this.getValue().replace(/[^\-+\d]/g, &quot;&quot;);
+			if(val.length == 0){ return; }
+
+			num = Math.min(Math.max((parseInt(val)+(parseInt(this.delta) * direction)), this.flags.min), this.flags.max);
+			val = (new Number(num)).toString();
+
+			if(num &gt;= 0){
+				val = ((this.flags.signed == true)?'+':' ')+val; // make sure first char is a nondigit
+			}
+
+			if(this.flags.separator.length &gt; 0){
+				for (var i=val.length-3; i &gt; 1; i-=3){
+					val = val.substr(0,i)+this.flags.separator+val.substr(i);
+				}
+			}
+
+			if(val.substr(0,1) == ' '){ val = val.substr(1); } // remove space
+
+			this.setValue(val);
+
+			return val.length;
+	}
+});
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:AdjustableIntegerTextbox&quot;);
+
+/*
+  ****** AdjustableRealNumberTextbox ******
+
+  A subclass of RealNumberTextbox.
+  @attr places    The exact number of decimal places.  If omitted, it's unlimited and optional.
+  @attr exponent  Can be true or false.  If omitted the exponential part is optional.
+  @attr eSigned   Is the exponent signed?  Can be true or false, if omitted the sign is optional.
+*/
+dojo.widget.AdjustableRealNumberTextbox = function(node) {
+        // this property isn't a primitive and needs to be created on a per-item basis.
+        this.flags = {};
+}
+dojo.inherits(dojo.widget.AdjustableRealNumberTextbox, dojo.widget.validate.RealNumberTextbox);
+dojo.lang.extend(dojo.widget.AdjustableRealNumberTextbox, {
+        // new subclass properties
+        widgetType: &quot;AdjustableRealNumberTextbox&quot;,
+		delta: &quot;1e1&quot;,
+
+        adjustValue: function(direction, x){
+			var val = this.getValue().replace(/[^\-+\.eE\d]/g, &quot;&quot;);
+			if(!val.length){ return; }
+
+			var num = parseFloat(val);
+			if(isNaN(num)){ return; }
+			var delta = this.delta.split(/[eE]/);
+			if(!delta.length){
+				delta = [1, 1];
+			}else{
+				delta[0] = parseFloat(delta[0].replace(/[^\-+\.\d]/g, &quot;&quot;));
+				if(isNaN(delta[0])){ delta[0] = 1; }
+				if(delta.length &gt; 1){
+					delta[1] = parseInt(delta[1]);
+				}
+				if(isNaN(delta[1])){ delta[1] = 1; }
+			}
+			val = this.getValue().split(/[eE]/);
+			if(!val.length){ return; }
+			var numBase = parseFloat(val[0].replace(/[^\-+\.\d]/g, &quot;&quot;));
+			if(val.length == 1){
+				var numExp = 0;
+			}else{
+				var numExp = parseInt(val[1].replace(/[^\-+\d]/g, &quot;&quot;));
+			}
+			if(x &lt;= val[0].length){
+				x = 0;
+				numBase += delta[0] * direction;
+			}else{
+				x = Number.MAX_VALUE;
+				numExp += delta[1] * direction;
+				if(this.flags.eSigned == false &amp;&amp; numExp &lt; 0){
+					numExp = 0;
+				}
+			}
+			num = Math.min(Math.max((numBase * Math.pow(10,numExp)), this.flags.min), this.flags.max);
+			if((this.flags.exponent == true || (this.flags.exponent != false &amp;&amp; x != 0)) &amp;&amp; num.toExponential){
+				if (isNaN(this.flags.places) || this.flags.places == Infinity){
+					val = num.toExponential();
+				}else{
+					val = num.toExponential(this.flags.places);
+				}
+			}else if(num.toFixed &amp;&amp; num.toPrecision){
+				if(isNaN(this.flags.places)){
+					val = num.toPrecision((1/3).toString().length-1);
+				}else{
+					val = num.toFixed(this.flags.places);
+				}
+			}else{
+				val = num.toString();
+			}
+
+			if(num &gt;= 0){
+				if(this.flags.signed == true){
+					val = '+' + val;
+				}
+			}
+			val = val.split(/[eE]/);
+			if(this.flags.separator.length &gt; 0){
+				if(num &gt;= 0 &amp;&amp; val[0].substr(0,1) != '+'){
+					val[0] = ' ' + val[0]; // make sure first char is nondigit for easy algorithm
+				}
+				var i = val[0].lastIndexOf('.');
+				if(i &gt;= 0){
+					i -= 3;
+				}else{
+					i = val[0].length-3;
+				}
+				for (; i &gt; 1; i-=3){
+					val[0] = val[0].substr(0,i)+this.flags.separator+val[0].substr(i);
+				}
+				if(val[0].substr(0,1) == ' '){ val[0] = val[0].substr(1); } // remove space
+			}
+			if(val.length &gt; 1){
+				if((this.flags.eSigned == true)&amp;&amp;(val[1].substr(0,1) != '+')){
+					val[1] = '+' + val[1];
+				}else if((!this.flags.eSigned)&amp;&amp;(val[1].substr(0,1) == '+')){
+					val[1] = val[1].substr(1);
+				}else if((!this.flags.eSigned)&amp;&amp;(val[1].substr(0,1) == '-')&amp;&amp;(num.toFixed &amp;&amp; num.toPrecision)){
+					if(isNaN(this.flags.places)){
+						val[0] = num.toPrecision((1/3).toString().length-1);
+					}else{
+						val[0] = num.toFixed(this.flags.places).toString();
+					}
+					val[1] = &quot;0&quot;;
+				}
+				val[0] += 'e' + val[1];
+			}
+			this.setValue(val[0]);
+			if(x &gt; val[0].length){ x = val[0].length; }
+			return x;
+	}
+});
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:AdjustableRealNumberTextbox&quot;);
+
+dojo.widget.Spinner = function(){
+	dojo.widget.Widget.call(this);
+}
+
+dojo.inherits(dojo.widget.Spinner, dojo.widget.Widget);
+
+dojo.widget.Spinner.defaults = {
+	widgetType: &quot;Spinner&quot;,
+	isContainer: false
+};
+
+dojo.lang.extend(dojo.widget.Spinner, dojo.widget.Spinner.defaults);
+
+dojo.widget.DomSpinner = function(){
+	dojo.widget.Spinner.call(this);
+	dojo.widget.DomWidget.call(this, true);
+}
+
+dojo.inherits(dojo.widget.DomSpinner, dojo.widget.DomWidget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:Spinner&quot;);
+
+// render-specific includes
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.Spinner&quot;);

Added: trunk/root/static/magic/src/widget/SplitContainer.js
===================================================================
--- trunk/root/static/magic/src/widget/SplitContainer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SplitContainer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,579 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.SplitContainer&quot;);
+dojo.provide(&quot;dojo.widget.SplitContainerPanel&quot;);
+dojo.provide(&quot;dojo.widget.html.SplitContainer&quot;);
+dojo.provide(&quot;dojo.widget.html.SplitContainerPanel&quot;);
+
+//
+// TODO
+// make it prettier
+// active dragging upwards doesn't always shift other bars (direction calculation is wrong in this case)
+//
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.LayoutContainer&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.io&quot;);	// workaround dojo bug. dojo.io.cookie requires dojo.io but it still doesn't get pulled in
+dojo.require(&quot;dojo.io.cookie&quot;);
+
+dojo.widget.html.SplitContainer = function(){
+
+	dojo.widget.HtmlWidget.call(this);
+
+	this.sizers = [];
+}
+
+dojo.inherits(dojo.widget.html.SplitContainer, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.SplitContainer, {
+	widgetType: &quot;SplitContainer&quot;,
+	isContainer: true,
+
+	virtualSizer: null,
+	isHorizontal: 0,
+	paneBefore: null,
+	paneAfter: null,
+	isSizing: false,
+	dragOffset: null,
+	startPoint: null,
+	lastPoint: null,
+	sizingSplitter: null,
+	isActiveResize: 0,
+	offsetX: 0,
+	offsetY: 0,
+	isDraggingLeft: 0,
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlSplitContainer.css&quot;),
+	originPos: null,
+	persist: true,		// save splitter positions in a cookie
+
+	activeSizing: '',
+	sizerWidth: 15,
+	orientation: 'horizontal',
+
+	debugName: '',
+
+	fillInTemplate: function(){
+
+		dojo.style.insertCssFile(this.templateCssPath, null, true);
+		dojo.html.addClass(this.domNode, &quot;dojoSplitContainer&quot;);
+		this.domNode.style.overflow='hidden';	// workaround firefox bug
+
+		this.paneWidth = dojo.style.getContentWidth(this.domNode);
+		this.paneHeight = dojo.style.getContentHeight(this.domNode);
+
+		this.isHorizontal = (this.orientation == 'horizontal') ? 1 : 0;
+		this.isActiveResize = (this.activeSizing == '1') ? 1 : 0;
+
+		//dojo.debug(&quot;fillInTemplate for &quot;+this.debugName);
+	},
+
+	onResized: function(e){
+		this.paneWidth = dojo.style.getContentWidth(this.domNode);
+		this.paneHeight = dojo.style.getContentHeight(this.domNode);
+		this.layoutPanels();
+	},
+
+	postCreate: function(args, fragment, parentComp){
+
+		// dojo.debug(&quot;post create for &quot;+this.debugName);
+
+		// attach the children and create the draggers
+		for(var i=0; i&lt;this.children.length; i++){
+            with(this.children[i].domNode.style){
+                position = &quot;absolute&quot;;
+            }
+            dojo.html.addClass(this.children[i].domNode,
+                &quot;dojoSplitPane&quot;);
+
+            if(i == this.children.length-1){
+                break;
+            }
+
+            this._addSizer();
+		}
+
+		// create the fake dragger
+		this.virtualSizer = document.createElement('div');
+		this.virtualSizer.style.position = 'absolute';
+		this.virtualSizer.style.display = 'none';
+		//this.virtualSizer.style.backgroundColor = 'lime';
+		this.virtualSizer.style.zIndex = 10;
+		this.virtualSizer.className = this.isHorizontal ? 'dojoSplitContainerVirtualSizerH' : 'dojoSplitContainerVirtualSizerV';
+		this.domNode.appendChild(this.virtualSizer);
+
+		dojo.html.disableSelection(this.virtualSizer);
+
+		if(this.persist){
+			this.restoreState();
+		}
+
+		// size the panels once the browser has caught up
+		this.resizeSoon();
+	},
+
+    _injectChild: function(child) {
+        with(child.domNode.style){
+            position = &quot;absolute&quot;;
+        }
+        dojo.html.addClass(child.domNode,
+            &quot;dojoSplitPane&quot;);
+    },
+
+    _addSizer: function() {
+        var i = this.sizers.length;
+
+        this.sizers[i] = document.createElement('div');
+        this.sizers[i].style.position = 'absolute';
+        this.sizers[i].className = this.isHorizontal ? 'dojoSplitContainerSizerH' : 'dojoSplitContainerSizerV';
+
+        var self = this;
+        var handler = (function(){ var sizer_i = i; return function(e){ self.beginSizing(e, sizer_i); } })();
+        dojo.event.connect(this.sizers[i], &quot;onmousedown&quot;, handler);
+
+        this.domNode.appendChild(this.sizers[i]);
+        dojo.html.disableSelection(this.sizers[i]);
+    },
+
+    removeChild: function(widget){
+        // Remove sizer, but only if widget is really our child and
+        // we have at least one sizer to throw away
+        if (this.sizers.length &gt; 0) {
+            for(var x=0; x&lt;this.children.length; x++){
+                if(this.children[x] === widget){
+                    var i = this.sizers.length - 1;
+                    this.domNode.removeChild(this.sizers[i]);
+                    this.sizers.length = i;
+                    break;
+                }
+            }
+        }
+
+        // Remove widget and repaint
+        dojo.widget.html.SplitContainer.superclass.removeChild.call(this, widget, arguments);
+        this.onResized();
+    },
+
+    addChild: function(widget, overrideContainerNode, pos, ref, insertIndex){
+        dojo.widget.html.SplitContainer.superclass.addChild.call(this, widget, overrideContainerNode, pos, ref, insertIndex);
+        this._injectChild(widget);
+
+        if (this.children.length &gt; 1) {
+            this._addSizer();
+        }
+
+        this.layoutPanels();
+    },
+
+    layoutPanels: function(){
+        if (this.children.length == 0){ return; }
+
+		//
+		// calculate space
+		//
+
+		var space = this.isHorizontal ? this.paneWidth : this.paneHeight;
+
+		if (this.children.length &gt; 1){
+
+			space -= this.sizerWidth * (this.children.length - 1);
+		}
+
+
+		//
+		// calculate total of SizeShare values
+		//
+
+		var out_of = 0;
+
+		for(var i=0; i&lt;this.children.length; i++){
+
+			out_of += this.children[i].sizeShare;
+		}
+
+
+		//
+		// work out actual pixels per sizeshare unit
+		//
+
+		var pix_per_unit = space / out_of;
+
+
+		//
+		// set the SizeActual member of each pane
+		//
+
+		var total_size = 0;
+
+		for(var i=0; i&lt;this.children.length-1; i++){
+
+			var size = Math.round(pix_per_unit * this.children[i].sizeShare);
+			this.children[i].sizeActual = size;
+			total_size += size;
+		}
+		this.children[this.children.length-1].sizeActual = space - total_size;
+
+		//
+		// make sure the sizes are ok
+		//
+
+		this.checkSizes();
+
+
+		//
+		// now loop, positioning each pane and letting children resize themselves
+		//
+
+		var pos = 0;
+		var size = this.children[0].sizeActual;
+		this.movePanel(this.children[0].domNode, pos, size);
+		this.children[0].position = pos;
+        this.children[0].checkSize();
+		pos += size;
+
+		for(var i=1; i&lt;this.children.length; i++){
+
+			// first we position the sizing handle before this pane
+			this.movePanel(this.sizers[i-1], pos, this.sizerWidth);
+			this.sizers[i-1].position = pos;
+			pos += this.sizerWidth;
+
+			size = this.children[i].sizeActual;
+			this.movePanel(this.children[i].domNode, pos, size);
+			this.children[i].position = pos;
+            this.children[i].checkSize();
+			pos += size;
+		}
+	},
+
+	movePanel: function(panel, pos, size){
+		if (this.isHorizontal){
+			panel.style.left = pos + 'px';
+			panel.style.top = 0;
+
+			dojo.style.setOuterWidth(panel, size);
+			dojo.style.setOuterHeight(panel, this.paneHeight);
+		}else{
+			panel.style.left = 0;
+			panel.style.top = pos + 'px';
+
+			dojo.style.setOuterWidth(panel, this.paneWidth);
+			dojo.style.setOuterHeight(panel, size);
+		}
+	},
+
+	growPane: function(growth, pane){
+
+		if (growth &gt; 0){
+			if (pane.sizeActual &gt; pane.sizeMin){
+				if ((pane.sizeActual - pane.sizeMin) &gt; growth){
+
+					// stick all the growth in this pane
+					pane.sizeActual = pane.sizeActual - growth;
+					growth = 0;
+				}else{
+					// put as much growth in here as we can
+					growth -= pane.sizeActual - pane.sizeMin;
+					pane.sizeActual = pane.sizeMin;
+				}
+			}
+		}
+		return growth;
+	},
+
+	checkSizes: function(){
+
+		var total_min_size = 0;
+		var total_size = 0;
+
+		for(var i=0; i&lt;this.children.length; i++){
+
+			total_size += this.children[i].sizeActual;
+			total_min_size += this.children[i].sizeMin;
+		}
+
+		// only make adjustments if we have enough space for all the minimums
+
+		if (total_min_size &lt;= total_size){
+
+			var growth = 0;
+
+			for(var i=0; i&lt;this.children.length; i++){
+
+				if (this.children[i].sizeActual &lt; this.children[i].sizeMin){
+
+					growth += this.children[i].sizeMin - this.children[i].sizeActual;
+					this.children[i].sizeActual = this.children[i].sizeMin;
+				}
+			}
+
+			if (growth &gt; 0){
+				if (this.isDraggingLeft){
+					for(var i=this.children.length-1; i&gt;=0; i--){
+						growth = this.growPane(growth, this.children[i]);
+					}
+				}else{
+					for(var i=0; i&lt;this.children.length; i++){
+						growth = this.growPane(growth, this.children[i]);
+					}
+				}
+			}
+		}else{
+
+			for(var i=0; i&lt;this.children.length; i++){
+				this.children[i].sizeActual = Math.round(total_size * (this.children[i].sizeMin / total_min_size));
+			}
+		}
+	},
+
+	beginSizing: function(e, i){
+		var clientX = e.layerX;
+		var clientY = e.layerY;
+		var screenX = e.pageX;
+		var screenY = e.pageY;
+
+		this.paneBefore = this.children[i];
+		this.paneAfter = this.children[i+1];
+
+		this.isSizing = true;
+		this.sizingSplitter = this.sizers[i];
+		this.originPos = dojo.style.getAbsolutePosition(this.domNode, true);
+		this.dragOffset = {'x':clientX, 'y':clientY};
+		this.startPoint  = {'x':screenX, 'y':screenY};
+		this.lastPoint  = {'x':screenX, 'y':screenY};
+
+		this.offsetX = screenX - clientX;
+		this.offsetY = screenY - clientY;
+
+		if (!this.isActiveResize){
+			this.showSizingLine();
+		}
+
+		//
+		// attach mouse events
+		//
+
+		dojo.event.connect(document.documentElement, &quot;onmousemove&quot;, this, &quot;changeSizing&quot;);
+		dojo.event.connect(document.documentElement, &quot;onmouseup&quot;, this, &quot;endSizing&quot;);
+	},
+
+	changeSizing: function(e){
+		var screenX = e.pageX;
+		var screenY = e.pageY;
+
+		if (this.isActiveResize){
+			this.lastPoint = {'x':screenX, 'y':screenY};
+			this.movePoint();
+			this.updateSize();
+		}else{
+			this.lastPoint = {'x':screenX, 'y':screenY};
+			this.movePoint();
+			this.moveSizingLine();
+		}
+	},
+
+	endSizing: function(e){
+
+		if (!this.isActiveResize){
+			this.hideSizingLine();
+		}
+
+		this.updateSize();
+
+		this.isSizing = false;
+
+		dojo.event.disconnect(document.documentElement, &quot;onmousemove&quot;, this, &quot;changeSizing&quot;);
+		dojo.event.disconnect(document.documentElement, &quot;onmouseup&quot;, this, &quot;endSizing&quot;);
+		
+		if(this.persist){
+			this.saveState(this);
+		}
+	},
+
+	movePoint: function(){
+
+		// make sure FLastPoint is a legal point to drag to
+		var p = this.screenToMainClient(this.lastPoint);
+
+		if (this.isHorizontal){
+
+			var a = p.x - this.dragOffset.x;
+			a = this.legaliseSplitPoint(a);
+			p.x = a + this.dragOffset.x;
+		}else{
+			var a = p.y - this.dragOffset.y;
+			a = this.legaliseSplitPoint(a);
+			p.y = a + this.dragOffset.y;
+		}
+
+		this.lastPoint = this.mainClientToScreen(p);
+	},
+
+	screenToClient: function(pt){
+
+		pt.x -= (this.offsetX + this.sizingSplitter.position);
+		pt.y -= (this.offsetY + this.sizingSplitter.position);
+
+		return pt;
+	},
+
+	clientToScreen: function(pt){
+
+		pt.x += (this.offsetX + this.sizingSplitter.position);
+		pt.y += (this.offsetY + this.sizingSplitter.position);
+
+		return pt;
+	},
+
+	screenToMainClient: function(pt){
+
+		pt.x -= this.offsetX;
+		pt.y -= this.offsetY;
+
+		return pt;
+	},
+
+	mainClientToScreen: function(pt){
+
+		pt.x += this.offsetX;
+		pt.y += this.offsetY;
+
+		return pt;
+	},
+
+	legaliseSplitPoint: function(a){
+
+		a += this.sizingSplitter.position;
+
+		this.isDraggingLeft = (a &gt; 0) ? 1 : 0;
+
+		if (!this.isActiveResize){
+
+			if (a &lt; this.paneBefore.position + this.paneBefore.sizeMin){
+
+				a = this.paneBefore.position + this.paneBefore.sizeMin;
+			}
+
+			if (a &gt; this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin))){
+
+				a = this.paneAfter.position + (this.paneAfter.sizeActual - (this.sizerWidth + this.paneAfter.sizeMin));
+			}
+		}
+
+		a -= this.sizingSplitter.position;
+
+		this.checkSizes();
+
+		return a;
+	},
+
+	updateSize: function(){
+
+		var p = this.clientToScreen(this.lastPoint);
+		var p = this.screenToClient(this.lastPoint);
+
+		var pos = this.isHorizontal ? p.x - (this.dragOffset.x + this.originPos.x) : p.y - (this.dragOffset.y + this.originPos.y);
+
+		var start_region = this.paneBefore.position;
+		var end_region   = this.paneAfter.position + this.paneAfter.sizeActual;
+
+		this.paneBefore.sizeActual = pos - start_region;
+		this.paneAfter.position    = pos + this.sizerWidth;
+		this.paneAfter.sizeActual  = end_region - this.paneAfter.position;
+
+		for(var i=0; i&lt;this.children.length; i++){
+
+			this.children[i].sizeShare = this.children[i].sizeActual;
+		}
+
+		this.layoutPanels();
+	},
+
+	showSizingLine: function(){
+
+		this.moveSizingLine();
+
+		if (this.isHorizontal){
+			dojo.style.setOuterWidth(this.virtualSizer, this.sizerWidth);
+			dojo.style.setOuterHeight(this.virtualSizer, this.paneHeight);
+		}else{
+			dojo.style.setOuterWidth(this.virtualSizer, this.paneWidth);
+			dojo.style.setOuterHeight(this.virtualSizer, this.sizerWidth);
+		}
+
+		this.virtualSizer.style.display = 'block';
+	},
+
+	hideSizingLine: function(){
+
+		this.virtualSizer.style.display = 'none';
+	},
+
+	moveSizingLine: function(){
+
+		var origin = {'x':0, 'y':0};
+
+		if (this.isHorizontal){
+			origin.x += (this.lastPoint.x - this.startPoint.x) + this.sizingSplitter.position;
+		}else{
+			origin.y += (this.lastPoint.y - this.startPoint.y) + this.sizingSplitter.position;
+		}
+
+		this.virtualSizer.style.left = origin.x + 'px';
+		this.virtualSizer.style.top = origin.y + 'px';
+	},
+	
+	_getCookieName: function(i) {
+		return this.widgetId + &quot;_&quot; + i;
+	},
+
+	restoreState: function () {
+		for(var i=0; i&lt;this.children.length; i++) {
+			var cookieName = this._getCookieName(i);
+			var cookieValue = dojo.io.cookie.getCookie(cookieName);
+			if (cookieValue != null) {
+				var pos = parseInt(cookieValue);
+				this.children[i].sizeShare=pos;
+			}
+		}
+	},
+
+	saveState: function (){
+		for(var i=0; i&lt;this.children.length; i++) {
+			var cookieName = this._getCookieName(i);
+			dojo.io.cookie.setCookie(cookieName, this.children[i].sizeShare, null, null, null, null);
+		}
+	}
+});
+
+// These arguments can be specified for the children of a SplitContainer.
+// Since any widget can be specified as a SplitContainer child, mix them
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	sizeMin: 10,
+	sizeShare: 10
+});
+
+// Deprecated class for split pane children.
+// Actually any widget can be the child of a split pane
+dojo.widget.html.SplitContainerPanel = function(){
+	dojo.widget.html.LayoutContainer.call(this);
+}
+dojo.inherits(dojo.widget.html.SplitContainerPanel, dojo.widget.html.LayoutContainer);
+dojo.lang.extend(dojo.widget.html.SplitContainerPanel, {
+	widgetType: &quot;SplitContainerPanel&quot;
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:SplitContainer&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:SplitContainerPanel&quot;);

Added: trunk/root/static/magic/src/widget/SvgButton.js
===================================================================
--- trunk/root/static/magic/src/widget/SvgButton.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SvgButton.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,141 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+// FIXME: not yet functional
+
+dojo.provide(&quot;dojo.widget.SvgButton&quot;);
+
+dojo.require(&quot;dojo.widget.Button&quot;);
+
+dojo.widget.SvgButton = function(){
+	// FIXME: this is incomplete and doesn't work yet
+	// if DOMButton turns into a mixin, we should subclass Button instead and
+	// just mix in the DOMButton properties.
+
+	dojo.widget.DomButton.call(this);
+	dojo.widget.SvgWidget.call(this);
+
+	// FIXME: freaking implement this already!
+	this.onFoo = function(){ alert(&quot;bar&quot;); }
+
+	this.label = &quot;huzzah!&quot;;
+
+	this.setLabel = function(x, y, textSize, label, shape){
+		//var labelNode = this.domNode.ownerDocument.createTextNode(this.label);
+		//var textNode = this.domNode.ownerDocument.createElement(&quot;text&quot;);
+		var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
+		var textString = &quot;&quot;;
+		switch(shape) {
+			case &quot;ellipse&quot;:
+				textString = &quot;&lt;text x='&quot;+ coords[6] + &quot;' y='&quot;+ coords[7] + &quot;'&gt;&quot;+ label + &quot;&lt;/text&gt;&quot;;
+				//textNode.setAttribute(&quot;x&quot;, coords[6]);
+				//textNode.setAttribute(&quot;y&quot;, coords[7]);
+				break;
+			case &quot;rectangle&quot;:
+				//FIXME: implement
+				textString = &quot;&quot;;
+				//textNode.setAttribute(&quot;x&quot;, coords[6]);
+				//textNode.setAttribute(&quot;y&quot;, coords[7]);
+				break;
+			case &quot;circle&quot;:
+				//FIXME: implement
+				textString = &quot;&quot;;
+				//textNode.setAttribute(&quot;x&quot;, coords[6]);
+				//textNode.setAttribute(&quot;y&quot;, coords[7]);
+				break;
+		}
+		//textNode.appendChild(labelNode);
+		//this.domNode.appendChild(textNode);
+		return textString;
+		//alert(textNode.getComputedTextLength());
+	}
+
+	this.fillInTemplate = function(x, y, textSize, label, shape){
+		// the idea is to set the text to the appropriate place given its length
+		// and the template shape
+		
+		// FIXME: For now, assuming text sizes are integers in SVG units
+		this.textSize = textSize || 12;
+		this.label = label;
+		// FIXEME: for now, I'm going to fake this... need to come up with a real way to 
+		// determine the actual width of the text, such as computedStyle
+		var textWidth = this.label.length*this.textSize ;
+		//this.setLabel();
+	}
+}
+
+dojo.inherits(dojo.widget.SvgButton, dojo.widget.DomButton);
+
+// FIXME
+dojo.widget.SvgButton.prototype.shapeString = function(x, y, textSize, label, shape) {
+	switch(shape) {
+		case &quot;ellipse&quot;:
+			var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape)
+			return &quot;&lt;ellipse cx='&quot;+ coords[4]+&quot;' cy='&quot;+ coords[5]+&quot;' rx='&quot;+ coords[2]+&quot;' ry='&quot;+ coords[3]+&quot;'/&gt;&quot;;
+			break;
+		case &quot;rect&quot;:
+			//FIXME: implement
+			return &quot;&quot;;
+			//return &quot;&lt;rect x='110' y='45' width='70' height='30'/&gt;&quot;;
+			break;
+		case &quot;circle&quot;:
+			//FIXME: implement
+			return &quot;&quot;;
+			//return &quot;&lt;circle cx='210' cy='60' r='23'/&gt;&quot;;
+			break;
+	}
+}
+
+dojo.widget.SvgButton.prototype.coordinates = function(x, y, textSize, label, shape) {
+	switch(shape) {
+		case &quot;ellipse&quot;:
+			var buttonWidth = label.length*textSize;
+			var buttonHeight = textSize*2.5
+			var rx = buttonWidth/2;
+			var ry = buttonHeight/2;
+			var cx = rx + x;
+			var cy = ry + y;
+			var textX = cx - rx*textSize/25;
+			var textY = cy*1.1;
+			return [buttonWidth, buttonHeight, rx, ry, cx, cy, textX, textY];
+			break;
+		case &quot;rectangle&quot;:
+			//FIXME: implement
+			return &quot;&quot;;
+			break;
+		case &quot;circle&quot;:
+			//FIXME: implement
+			return &quot;&quot;;
+			break;
+	}
+}
+
+dojo.widget.SvgButton.prototype.labelString = function(x, y, textSize, label, shape){
+	var textString = &quot;&quot;;
+	var coords = dojo.widget.SvgButton.prototype.coordinates(x, y, textSize, label, shape);
+	switch(shape) {
+		case &quot;ellipse&quot;:
+			textString = &quot;&lt;text x='&quot;+ coords[6] + &quot;' y='&quot;+ coords[7] + &quot;'&gt;&quot;+ label + &quot;&lt;/text&gt;&quot;;
+			break;
+		case &quot;rectangle&quot;:
+			//FIXME: implement
+			textString = &quot;&quot;;
+			break;
+		case &quot;circle&quot;:
+			//FIXME: implement
+			textString = &quot;&quot;;
+			break;
+	}
+	return textString;
+}
+
+dojo.widget.SvgButton.prototype.templateString = function(x, y, textSize, label, shape) {
+	return &quot;&lt;g class='dojoButton' dojoAttachEvent='onClick; onMouseMove: onFoo;' dojoAttachPoint='labelNode'&gt;&quot;+ dojo.widgets.SVGButton.prototype.shapeString(x, y, textSize, label, shape) + dojo.widget.SVGButton.prototype.labelString(x, y, textSize, label, shape) + &quot;&lt;/g&gt;&quot;;
+}

Added: trunk/root/static/magic/src/widget/SvgWidget.js
===================================================================
--- trunk/root/static/magic/src/widget/SvgWidget.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SvgWidget.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,92 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.widget.DomWidget&quot;);
+dojo.provide(&quot;dojo.widget.SvgWidget&quot;);
+dojo.provide(&quot;dojo.widget.SVGWidget&quot;); // back compat
+
+dojo.require(&quot;dojo.dom&quot;);
+
+// SVGWidget is a mixin ONLY
+dojo.widget.SvgWidget = function(args){
+	// mix in the parent type
+	// dojo.widget.DomWidget.call(this);
+}
+dojo.inherits(dojo.widget.SvgWidget, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.SvgWidget, {
+	getContainerHeight: function(){
+		// NOTE: container height must be returned as the INNER height
+		dojo.unimplemented(&quot;dojo.widget.SvgWidget.getContainerHeight&quot;);
+	},
+
+	getContainerWidth: function(){
+		// return this.parent.domNode.offsetWidth;
+		dojo.unimplemented(&quot;dojo.widget.SvgWidget.getContainerWidth&quot;);
+	},
+
+	setNativeHeight: function(height){
+		// var ch = this.getContainerHeight();
+		dojo.unimplemented(&quot;dojo.widget.SVGWidget.setNativeHeight&quot;);
+	},
+
+	createNodesFromText: function(txt, wrap){
+		return dojo.dom.createNodesFromText(txt, wrap);
+	}
+});
+
+dojo.widget.SVGWidget = dojo.widget.SvgWidget;
+
+try{
+(function(){
+	var tf = function(){
+		// FIXME: fill this in!!!
+		var rw = new function(){
+			dojo.widget.SvgWidget.call(this);
+			this.buildRendering = function(){ return; }
+			this.destroyRendering = function(){ return; }
+			this.postInitialize = function(){ return; }
+			this.cleanUp = function(){ return; }
+			this.widgetType = &quot;SVGRootWidget&quot;;
+			this.domNode = document.documentElement;
+		}
+		var wm = dojo.widget.manager;
+		wm.root = rw;
+		wm.add(rw);
+
+		// extend the widgetManager with a getWidgetFromNode method
+		wm.getWidgetFromNode = function(node){
+			var filter = function(x){
+				if(x.domNode == node){
+					return true;
+				}
+			}
+			var widgets = [];
+			while((node)&amp;&amp;(widgets.length &lt; 1)){
+				widgets = this.getWidgetsByFilter(filter);
+				node = node.parentNode;
+			}
+			if(widgets.length &gt; 0){
+				return widgets[0];
+			}else{
+				return null;
+			}
+		}
+
+		wm.getWidgetFromEvent = function(domEvt){
+			return this.getWidgetFromNode(domEvt.target);
+		}
+
+		wm.getWidgetFromPrimitive = wm.getWidgetFromNode;
+	}
+	// make sure we get called when the time is right
+	dojo.event.connect(dojo.hostenv, &quot;loaded&quot;, tf);
+})();
+}catch(e){ alert(e); }

Added: trunk/root/static/magic/src/widget/SwtWidget.js
===================================================================
--- trunk/root/static/magic/src/widget/SwtWidget.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/SwtWidget.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,64 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.SwtWidget&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.Widget&quot;);
+dojo.require(&quot;dojo.uri.*&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+
+try{
+	importPackage(Packages.org.eclipse.swt.widgets);
+
+	dojo.declare(&quot;dojo.widget.SwtWidget&quot;, dojo.widget.Widget, {
+		initializer: function() {
+			if((arguments.length&gt;0)&amp;&amp;(typeof arguments[0] == &quot;object&quot;)){
+				this.create(arguments[0]);
+			}
+		},
+
+		display: null,
+		shell: null,
+
+		show: function(){ },
+		hide: function(){ },
+
+		addChild: function(){ },
+		registerChild: function(){ },
+		addWidgetAsDirectChild: function(){ },
+		removeChild: function(){ },
+		cleanUp: function(){ },
+		destroyRendering: function(){ },
+		postInitialize: function(){ },
+	});
+
+	// initialize SWT runtime
+
+	dojo.widget.SwtWidget.prototype.display = new Display();
+	dojo.widget.SwtWidget.prototype.shell = new Shell(dojo.widget.SwtWidget.prototype.display);
+
+	dojo.widget.manager.startShell = function(){
+		var sh = dojo.widget.SwtWidget.prototype.shell;
+		var d = dojo.widget.SwtWidget.prototype.display;
+		sh.open();
+		while(!sh.isDisposed()){
+			dojo.widget.manager.doNext();
+			if(!d.readAndDispatch()){
+				d.sleep();
+			}
+		}
+		d.dispose();
+	};
+}catch(e){
+	// seems we didn't have the SWT classes in the environment. Log it.
+	dojo.debug(&quot;dojo.widget.SwtWidget not loaded. SWT classes not available&quot;);
+}

Added: trunk/root/static/magic/src/widget/TabContainer.js
===================================================================
--- trunk/root/static/magic/src/widget/TabContainer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TabContainer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,261 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.TabContainer&quot;);
+dojo.provide(&quot;dojo.widget.html.TabContainer&quot;);
+dojo.provide(&quot;dojo.widget.Tab&quot;);
+
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html.layout&quot;);
+
+//////////////////////////////////////////
+// TabContainer -- a set of Tabs
+//////////////////////////////////////////
+dojo.widget.html.TabContainer = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.TabContainer, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.TabContainer, {
+	widgetType: &quot;TabContainer&quot;,
+    isContainer: true,
+
+	// Constructor arguments
+	labelPosition: &quot;top&quot;,
+	closeButton: &quot;none&quot;,
+
+	useVisibility: false,		// true--&gt;use visibility:hidden instead of display:none
+	
+	// if false, TabContainers size changes according to size of currently selected tab
+	doLayout: true,
+
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTabContainer.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTabContainer.css&quot;),
+
+	selectedTab: &quot;&quot;,		// initially selected tab (widgetId)
+
+	fillInTemplate: function(args, frag) {
+		// Copy style info from input node to output node
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+
+		dojo.widget.html.TabContainer.superclass.fillInTemplate.call(this, args, frag);
+	},
+
+	postCreate: function(args, frag) {
+		// Load all the tabs, creating a label for each one
+		for(var i=0; i&lt;this.children.length; i++){
+			this._setupTab(this.children[i]);
+		}
+
+		if (this.closeButton==&quot;pane&quot;) {
+			var div = document.createElement(&quot;div&quot;);
+			dojo.html.addClass(div, &quot;dojoTabPanePaneClose&quot;);
+			var self = this;
+			dojo.event.connect(div, &quot;onclick&quot;, function(){ self._runOnCloseTab(self.selectedTabWidget); });
+			dojo.event.connect(div, &quot;onmouseover&quot;, function(){ dojo.html.addClass(div, &quot;dojoTabPanePaneCloseHover&quot;); });
+			dojo.event.connect(div, &quot;onmouseout&quot;, function(){ dojo.html.removeClass(div, &quot;dojoTabPanePaneCloseHover&quot;); });
+			this.dojoTabLabels.appendChild(div);
+		}
+
+		if(this.doLayout){
+			dojo.html.addClass(this.dojoTabLabels, &quot;dojoTabLabels-&quot;+this.labelPosition);
+		} else {
+			dojo.html.addClass(this.dojoTabLabels, &quot;dojoTabLabels-&quot;+this.labelPosition+&quot;-noLayout&quot;);
+		}
+
+        this._doSizing();
+
+		// Display the selected tab
+		if(this.selectedTabWidget){
+			this.selectTab(this.selectedTabWidget, true);
+		}
+	},
+
+	addChild: function(child, overrideContainerNode, pos, ref, insertIndex){
+		this._setupTab(child);
+		dojo.widget.html.TabContainer.superclass.addChild.call(this,child, overrideContainerNode, pos, ref, insertIndex);
+
+		// in case the tab labels have overflowed from one line to two lines
+		this._doSizing();
+	},
+
+	_setupTab: function(tab){
+		tab.domNode.style.display=&quot;none&quot;;
+
+		// Create label
+		tab.div = document.createElement(&quot;div&quot;);
+		dojo.widget.wai.setAttr(tab.div, &quot;waiRole&quot;, &quot;tab&quot;);
+		dojo.html.addClass(tab.div, &quot;dojoTabPaneTab&quot;);
+		var span = document.createElement(&quot;span&quot;);
+		span.innerHTML = tab.label;
+		dojo.html.disableSelection(span);
+		if (this.closeButton==&quot;tab&quot;) {
+			var img = document.createElement(&quot;div&quot;);
+			dojo.html.addClass(img, &quot;dojoTabPaneTabClose&quot;);
+			var self = this;
+			dojo.event.connect(img, &quot;onclick&quot;, function(evt){ self._runOnCloseTab(tab); dojo.event.browser.stopEvent(evt); });
+			dojo.event.connect(img, &quot;onmouseover&quot;, function(){ dojo.html.addClass(img,&quot;dojoTabPaneTabCloseHover&quot;); });
+			dojo.event.connect(img, &quot;onmouseout&quot;, function(){ dojo.html.removeClass(img,&quot;dojoTabPaneTabCloseHover&quot;); });
+			span.appendChild(img);
+		}
+		tab.div.appendChild(span);
+		this.dojoTabLabels.appendChild(tab.div);
+		
+		var self = this;
+		dojo.event.connect(tab.div, &quot;onclick&quot;, function(){ self.selectTab(tab); });
+
+		if(!this.selectedTabWidget || this.selectedTab==tab.widgetId || tab.selected){
+    		this.selectedTabWidget = tab;
+        } else {
+            this._hideTab(tab);
+        }
+
+		dojo.html.addClass(tab.domNode, &quot;dojoTabPane&quot;);
+		with(tab.domNode.style){
+			top = dojo.style.getPixelValue(this.containerNode, &quot;padding-top&quot;, true);
+			left = dojo.style.getPixelValue(this.containerNode, &quot;padding-left&quot;, true);
+		}
+	},
+
+	// Configure the content pane to take up all the space except for where the tab labels are
+	_doSizing: function(){
+		// position the labels and the container node
+		var labelAlign=this.labelPosition.replace(/-h/,&quot;&quot;);
+		var children = [
+			{domNode: this.dojoTabLabels, layoutAlign: labelAlign},
+			{domNode: this.containerNode, layoutAlign: &quot;client&quot;}
+		];
+
+
+		if (this.doLayout) {
+			dojo.html.layout(this.domNode, children);
+		} 
+			
+		// size the current tab
+		// TODO: should have ptr to current tab rather than searching
+		var cw=dojo.style.getContentWidth(this.containerNode);
+		var ch=dojo.style.getContentHeight(this.containerNode);
+		dojo.lang.forEach(this.children, function(child){
+			//if (this.doLayout) {
+				if(child.selected){
+					child.resizeTo(cw, ch);
+				} 
+			//} else {
+			//	child.onResized();
+			//}
+		});
+		
+	},
+
+    removeChild: function(tab) {
+
+		// remove tab event handlers
+		dojo.event.disconnect(tab.div, &quot;onclick&quot;, function () { });
+		if (this.closeButton==&quot;tab&quot;) {
+			var img = tab.div.lastChild.lastChild;
+			if (img) {
+				dojo.html.removeClass(img, &quot;dojoTabPaneTabClose&quot;, function () { });
+				dojo.event.disconnect(img, &quot;onclick&quot;, function () { });
+				dojo.event.disconnect(img, &quot;onmouseover&quot;, function () { });
+				dojo.event.disconnect(img, &quot;onmouseout&quot;, function () { });
+			}
+		}
+
+        dojo.widget.html.TabContainer.superclass.removeChild.call(this, tab);
+
+        dojo.html.removeClass(tab.domNode, &quot;dojoTabPane&quot;);
+        this.dojoTabLabels.removeChild(tab.div);
+        delete(tab.div);
+
+        if (this.selectedTabWidget === tab) {
+            this.selectedTabWidget = undefined;
+            if (this.children.length &gt; 0) {
+                this.selectTab(this.children[0], true);
+            }
+        }
+
+		// in case the tab labels have overflowed from one line to two lines
+		this._doSizing();
+    },
+
+    selectTab: function(tab, _noRefresh) {
+		// Deselect old tab and select new one
+		if (this.selectedTabWidget) {
+			this._hideTab(this.selectedTabWidget);
+		}
+		this.selectedTabWidget = tab;
+		this._showTab(tab, _noRefresh);
+	},
+
+	_showTab: function(tab, _noRefresh) {
+		dojo.html.addClass(tab.div, &quot;current&quot;);
+		tab.selected=true;
+		if ( this.useVisibility &amp;&amp; !dojo.render.html.ie ) {
+			tab.domNode.style.visibility=&quot;visible&quot;;
+		} else {
+			// make sure we dont refresh onClose and on postCreate
+			// speeds up things a bit when using refreshOnShow and fixes #646
+			if(_noRefresh &amp;&amp; tab.refreshOnShow){
+				var tmp = tab.refreshOnShow;
+				tab.refreshOnShow = false;
+				tab.show();
+				tab.refreshOnShow = tmp;
+			}else{
+				tab.show();
+			}
+
+			tab.resizeTo(
+				dojo.style.getContentWidth(this.containerNode),
+				dojo.style.getContentHeight(this.containerNode)
+			);
+		}
+	},
+
+	_hideTab: function(tab) {
+		dojo.html.removeClass(tab.div, &quot;current&quot;);
+		tab.selected=false;
+		if( this.useVisibility ){
+			tab.domNode.style.visibility=&quot;hidden&quot;;
+		}else{
+			tab.hide();
+		}
+	},
+
+	_runOnCloseTab: function(tab) {
+		var onc = tab.extraArgs.onClose || tab.extraArgs.onclose;
+		var fcn = dojo.lang.isFunction(onc) ? onc : window[onc];
+		var remove = dojo.lang.isFunction(fcn) ? fcn(this,tab) : true;
+		if(remove) {
+			this.removeChild(tab);
+			// makes sure we can clean up executeScripts in ContentPane onUnLoad
+			tab.destroy();
+		}
+	},
+
+	onResized: function() {
+		this._doSizing();
+	}
+});
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TabContainer&quot;);
+
+// These arguments can be specified for the children of a TabContainer.
+// Since any widget can be specified as a TabContainer child, mix them
+// into the base widget class.  (This is a hack, but it's effective.)
+dojo.lang.extend(dojo.widget.Widget, {
+	label: &quot;&quot;,
+	selected: false	// is this tab currently selected?
+});

Added: trunk/root/static/magic/src/widget/TaskBar.js
===================================================================
--- trunk/root/static/magic/src/widget/TaskBar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TaskBar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,32 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.TaskBar&quot;);
+dojo.provide(&quot;dojo.widget.TaskBarItem&quot;);
+dojo.require(&quot;dojo.widget.Widget&quot;);
+
+dojo.widget.TaskBar = function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = &quot;TaskBar&quot;;
+	this.isContainer = true;
+}
+dojo.inherits(dojo.widget.TaskBar, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:taskbar&quot;);
+
+dojo.widget.TaskBarItem = function(){
+	dojo.widget.Widget.call(this);
+
+	this.widgetType = &quot;TaskBarItem&quot;;
+}
+dojo.inherits(dojo.widget.TaskBarItem, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:taskbaritem&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.TaskBar&quot;);

Added: trunk/root/static/magic/src/widget/TimePicker.js
===================================================================
--- trunk/root/static/magic/src/widget/TimePicker.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TimePicker.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,82 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.TimePicker&quot;);
+dojo.provide(&quot;dojo.widget.TimePicker.util&quot;);
+dojo.require(&quot;dojo.widget.DomWidget&quot;);
+dojo.require(&quot;dojo.date&quot;);
+
+dojo.widget.TimePicker = function(){
+	dojo.widget.Widget.call(this);
+	this.widgetType = &quot;TimePicker&quot;;
+	this.isContainer = false;
+	// the following aliases prevent breaking people using 0.2.x
+	this.toRfcDateTime = dojo.widget.TimePicker.util.toRfcDateTime;
+	this.fromRfcDateTime = dojo.widget.TimePicker.util.fromRfcDateTime;
+	this.toAmPmHour = dojo.widget.TimePicker.util.toAmPmHour;
+	this.fromAmPmHour = dojo.widget.TimePicker.util.fromAmPmHour;
+}
+
+dojo.inherits(dojo.widget.TimePicker, dojo.widget.Widget);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:timepicker&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.TimePicker&quot;);
+
+dojo.widget.TimePicker.util = new function() {
+	// utility functions
+	this.toRfcDateTime = function(jsDate) {
+		if(!jsDate) {
+			jsDate = new Date();
+		}
+		return dojo.date.format(jsDate, &quot;%Y-%m-%dT%H:%M:00%z&quot;);
+	}
+
+	this.fromRfcDateTime = function(rfcDate, useDefaultMinutes, isAnyTime) {
+		var tempDate = new Date();
+		if(!rfcDate || rfcDate.indexOf(&quot;T&quot;)==-1) {
+			if(useDefaultMinutes) {
+				tempDate.setMinutes(Math.floor(tempDate.getMinutes()/5)*5);
+			} else {
+				tempDate.setMinutes(0);
+			}
+		} else {
+			var tempTime = rfcDate.split(&quot;T&quot;)[1].split(&quot;:&quot;);
+			// fullYear, month, date
+			var tempDate = new Date();
+			tempDate.setHours(tempTime[0]);
+			tempDate.setMinutes(tempTime[1]);
+		}
+		return tempDate;
+	}
+
+	this.toAmPmHour = function(hour) {
+		var amPmHour = hour;
+		var isAm = true;
+		if (amPmHour == 0) {
+			amPmHour = 12;
+		} else if (amPmHour&gt;12) {
+			amPmHour = amPmHour - 12;
+			isAm = false;
+		} else if (amPmHour == 12) {
+			isAm = false;
+		}
+		return [amPmHour, isAm];
+	}
+
+	this.fromAmPmHour = function(amPmHour, isAm) {
+		var hour = parseInt(amPmHour, 10);
+		if(isAm &amp;&amp; hour == 12) {
+			hour = 0;
+		} else if (!isAm &amp;&amp; hour&lt;12) {
+			hour = hour + 12;
+		}
+		return hour;
+	}
+}

Added: trunk/root/static/magic/src/widget/TitlePane.js
===================================================================
--- trunk/root/static/magic/src/widget/TitlePane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TitlePane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.TitlePane&quot;);
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.TitlePane&quot;);

Added: trunk/root/static/magic/src/widget/Toggler.js
===================================================================
--- trunk/root/static/magic/src/widget/Toggler.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Toggler.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,40 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Toggler&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+// clicking on this node shows/hides another widget
+
+dojo.widget.Toggler = function(){
+	dojo.widget.DomWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.Toggler, dojo.widget.DomWidget);
+
+dojo.lang.extend(dojo.widget.Toggler, {
+	widgetType: &quot;Toggler&quot;,
+	
+	// Associated widget 
+	targetId: '',
+	
+	fillInTemplate: function() {
+		dojo.event.connect(this.domNode, &quot;onclick&quot;, this, &quot;onClick&quot;);
+	},
+	
+	onClick: function() {
+		var pane = dojo.widget.byId(this.targetId);
+		if(!pane){ return; }
+		pane.explodeSrc = this.domNode;
+		pane.toggleShowing();
+	}
+});
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toggler&quot;);

Added: trunk/root/static/magic/src/widget/Toolbar.js
===================================================================
--- trunk/root/static/magic/src/widget/Toolbar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Toolbar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,935 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.ToolbarContainer&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarContainer&quot;);
+dojo.provide(&quot;dojo.widget.Toolbar&quot;);
+dojo.provide(&quot;dojo.widget.html.Toolbar&quot;);
+dojo.provide(&quot;dojo.widget.ToolbarItem&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarButtonGroup&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarButton&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarDialog&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarMenu&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarSeparator&quot;);
+dojo.provide(&quot;dojo.widget.html.ToolbarSpace&quot;);
+dojo.provide(&quot;dojo.widget.Icon&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+/* ToolbarContainer
+ *******************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarContainer&quot;);
+dojo.widget.html.ToolbarContainer = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarContainer, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.html.ToolbarContainer, {
+	widgetType: &quot;ToolbarContainer&quot;,
+	isContainer: true,
+
+	templateString: '&lt;div class=&quot;toolbarContainer&quot; dojoAttachPoint=&quot;containerNode&quot;&gt;&lt;/div&gt;',
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlToolbar.css&quot;),
+
+	getItem: function(name) {
+		if(name instanceof dojo.widget.ToolbarItem) { return name; }
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				var item = child.getItem(name);
+				if(item) { return item; }
+			}
+		}
+		return null;
+	},
+
+	getItems: function() {
+		var items = [];
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				items = items.concat(child.getItems());
+			}
+		}
+		return items;
+	},
+
+	enable: function() {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.enable.apply(child, arguments);
+			}
+		}
+	},
+
+	disable: function() {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.disable.apply(child, arguments);
+			}
+		}
+	},
+
+	select: function(name) {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.select(arguments);
+			}
+		}
+	},
+
+	deselect: function(name) {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				child.deselect(arguments);
+			}
+		}
+	},
+
+	getItemsState: function() {
+		var values = {};
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				dojo.lang.mixin(values, child.getItemsState());
+			}
+		}
+		return values;
+	},
+
+	getItemsActiveState: function() {
+		var values = {};
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				dojo.lang.mixin(values, child.getItemsActiveState());
+			}
+		}
+		return values;
+	},
+
+	getItemsSelectedState: function() {
+		var values = {};
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.html.Toolbar) {
+				dojo.lang.mixin(values, child.getItemsSelectedState());
+			}
+		}
+		return values;
+	}
+});
+
+/* Toolbar
+ **********/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbar&quot;);
+dojo.widget.html.Toolbar = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.Toolbar, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.html.Toolbar, {
+	widgetType: &quot;Toolbar&quot;,
+	isContainer: true,
+
+	templateString: '&lt;div class=&quot;toolbar&quot; dojoAttachPoint=&quot;containerNode&quot; unselectable=&quot;on&quot; dojoOnMouseover=&quot;_onmouseover&quot; dojoOnMouseout=&quot;_onmouseout&quot; dojoOnClick=&quot;_onclick&quot; dojoOnMousedown=&quot;_onmousedown&quot; dojoOnMouseup=&quot;_onmouseup&quot;&gt;&lt;/div&gt;',
+	//templateString: '&lt;div class=&quot;toolbar&quot; dojoAttachPoint=&quot;containerNode&quot; unselectable=&quot;on&quot;&gt;&lt;/div&gt;',
+
+	// given a node, tries to find it's toolbar item
+	_getItem: function(node) {
+		var start = new Date();
+		var widget = null;
+		while(node &amp;&amp; node != this.domNode) {
+			if(dojo.html.hasClass(node, &quot;toolbarItem&quot;)) {
+				var widgets = dojo.widget.manager.getWidgetsByFilter(function(w) { return w.domNode == node; });
+				if(widgets.length == 1) {
+					widget = widgets[0];
+					break;
+				} else if(widgets.length &gt; 1) {
+					dojo.raise(&quot;Toolbar._getItem: More than one widget matches the node&quot;);
+				}
+			}
+			node = node.parentNode;
+		}
+		return widget;
+	},
+
+	_onmouseover: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget &amp;&amp; widget._onmouseover) { widget._onmouseover(e); }
+	},
+
+	_onmouseout: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget &amp;&amp; widget._onmouseout) { widget._onmouseout(e); }
+	},
+
+	_onclick: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget &amp;&amp; widget._onclick){ 
+			widget._onclick(e);
+		}
+	},
+
+	_onmousedown: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget &amp;&amp; widget._onmousedown) { widget._onmousedown(e); }
+	},
+
+	_onmouseup: function(e) {
+		var widget = this._getItem(e.target);
+		if(widget &amp;&amp; widget._onmouseup) { widget._onmouseup(e); }
+	},
+
+	addChild: function(item, pos, props) {
+		var widget = dojo.widget.ToolbarItem.make(item, null, props);
+		var ret = dojo.widget.html.Toolbar.superclass.addChild.call(this, widget, null, pos, null);
+		return ret;
+	},
+
+	push: function() {
+		for(var i = 0; i &lt; arguments.length; i++) {
+			this.addChild(arguments[i]);
+		}
+	},
+
+	getItem: function(name) {
+		if(name instanceof dojo.widget.ToolbarItem) { return name; }
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem
+				&amp;&amp; child._name == name) { return child; }
+		}
+		return null;
+	},
+
+	getItems: function() {
+		var items = [];
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				items.push(child);
+			}
+		}
+		return items;
+	},
+
+	getItemsState: function() {
+		var values = {};
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				values[child._name] = {
+					selected: child._selected,
+					enabled: child._enabled
+				};
+			}
+		}
+		return values;
+	},
+
+	getItemsActiveState: function() {
+		var values = this.getItemsState();
+		for(var item in values) {
+			values[item] = values[item].enabled;
+		}
+		return values;
+	},
+
+	getItemsSelectedState: function() {
+		var values = this.getItemsState();
+		for(var item in values) {
+			values[item] = values[item].selected;
+		}
+		return values;
+	},
+
+	enable: function() {
+		var items = arguments.length ? arguments : this.children;
+		for(var i = 0; i &lt; items.length; i++) {
+			var child = this.getItem(items[i]);
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.enable(false, true);
+			}
+		}
+	},
+
+	disable: function() {
+		var items = arguments.length ? arguments : this.children;
+		for(var i = 0; i &lt; items.length; i++) {
+			var child = this.getItem(items[i]);
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.disable();
+			}
+		}
+	},
+
+	select: function() {
+		for(var i = 0; i &lt; arguments.length; i++) {
+			var name = arguments[i];
+			var item = this.getItem(name);
+			if(item) { item.select(); }
+		}
+	},
+
+	deselect: function() {
+		for(var i = 0; i &lt; arguments.length; i++) {
+			var name = arguments[i];
+			var item = this.getItem(name);
+			if(item) { item.disable(); }
+		}
+	},
+
+	setValue: function() {
+		for(var i = 0; i &lt; arguments.length; i += 2) {
+			var name = arguments[i], value = arguments[i+1];
+			var item = this.getItem(name);
+			if(item) {
+				if(item instanceof dojo.widget.ToolbarItem) {
+					item.setValue(value);
+				}
+			}
+		}
+	}
+});
+
+/* ToolbarItem hierarchy:
+	- ToolbarItem
+		- ToolbarButton
+		- ToolbarDialog
+			- ToolbarMenu
+		- ToolbarSeparator
+			- ToolbarSpace
+				- ToolbarFlexibleSpace
+*/
+
+
+/* ToolbarItem
+ **************/
+dojo.widget.ToolbarItem = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.ToolbarItem, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.ToolbarItem, {
+	templateString: '&lt;span unselectable=&quot;on&quot; class=&quot;toolbarItem&quot;&gt;&lt;/span&gt;',
+
+	_name: null,
+	getName: function() { return this._name; },
+	setName: function(value) { return this._name = value; },
+	getValue: function() { return this.getName(); },
+	setValue: function(value) { return this.setName(value); },
+
+	_selected: false,
+	isSelected: function() { return this._selected; },
+	setSelected: function(is, force, preventEvent) {
+		if(!this._toggleItem &amp;&amp; !force) { return; }
+		is = Boolean(is);
+		if(force || this._enabled &amp;&amp; this._selected != is) {
+			this._selected = is;
+			this.update();
+			if(!preventEvent) {
+				this._fireEvent(is ? &quot;onSelect&quot; : &quot;onDeselect&quot;);
+				this._fireEvent(&quot;onChangeSelect&quot;);
+			}
+		}
+	},
+	select: function(force, preventEvent) {
+		return this.setSelected(true, force, preventEvent);
+	},
+	deselect: function(force, preventEvent) {
+		return this.setSelected(false, force, preventEvent);
+	},
+
+	_toggleItem: false,
+	isToggleItem: function() { return this._toggleItem; },
+	setToggleItem: function(value) { this._toggleItem = Boolean(value); },
+
+	toggleSelected: function(force) {
+		return this.setSelected(!this._selected, force);
+	},
+
+	_enabled: true,
+	isEnabled: function() { return this._enabled; },
+	setEnabled: function(is, force, preventEvent) {
+		is = Boolean(is);
+		if(force || this._enabled != is) {
+			this._enabled = is;
+			this.update();
+			if(!preventEvent) {
+				this._fireEvent(this._enabled ? &quot;onEnable&quot; : &quot;onDisable&quot;);
+				this._fireEvent(&quot;onChangeEnabled&quot;);
+			}
+		}
+		return this._enabled;
+	},
+	enable: function(force, preventEvent) {
+		return this.setEnabled(true, force, preventEvent);
+	},
+	disable: function(force, preventEvent) {
+		return this.setEnabled(false, force, preventEvent);
+	},
+	toggleEnabled: function(force, preventEvent) {
+		return this.setEnabled(!this._enabled, force, preventEvent);
+	},
+
+	_icon: null,
+	getIcon: function() { return this._icon; },
+	setIcon: function(value) {
+		var icon = dojo.widget.Icon.make(value);
+		if(this._icon) {
+			this._icon.setIcon(icon);
+		} else {
+			this._icon = icon;
+		}
+		var iconNode = this._icon.getNode();
+		if(iconNode.parentNode != this.domNode) {
+			if(this.domNode.hasChildNodes()) {
+				this.domNode.insertBefore(iconNode, this.domNode.firstChild);
+			} else {
+				this.domNode.appendChild(iconNode);
+			}
+		}
+		return this._icon;
+	},
+
+	// TODO: update the label node (this.labelNode?)
+	_label: &quot;&quot;,
+	getLabel: function() { return this._label; },
+	setLabel: function(value) {
+		var ret = this._label = value;
+		if(!this.labelNode) {
+			this.labelNode = document.createElement(&quot;span&quot;);
+			this.domNode.appendChild(this.labelNode);
+		}
+		this.labelNode.innerHTML = &quot;&quot;;
+		this.labelNode.appendChild(document.createTextNode(this._label));
+		this.update();
+		return ret;
+	},
+
+	// fired from: setSelected, setEnabled, setLabel
+	update: function() {
+		if(this._enabled) {
+			dojo.html.removeClass(this.domNode, &quot;disabled&quot;);
+			if(this._selected) {
+				dojo.html.addClass(this.domNode, &quot;selected&quot;);
+			} else {
+				dojo.html.removeClass(this.domNode, &quot;selected&quot;);
+			}
+		} else {
+			this._selected = false;
+			dojo.html.addClass(this.domNode, &quot;disabled&quot;);
+			dojo.html.removeClass(this.domNode, &quot;down&quot;);
+			dojo.html.removeClass(this.domNode, &quot;hover&quot;);
+		}
+		this._updateIcon();
+	},
+
+	_updateIcon: function() {
+		if(this._icon) {
+			if(this._enabled) {
+				if(this._cssHover) {
+					this._icon.hover();
+				} else if(this._selected) {
+					this._icon.select();
+				} else {
+					this._icon.enable();
+				}
+			} else {
+				this._icon.disable();
+			}
+		}
+	},
+
+	_fireEvent: function(evt) {
+		if(typeof this[evt] == &quot;function&quot;) {
+			var args = [this];
+			for(var i = 1; i &lt; arguments.length; i++) {
+				args.push(arguments[i]);
+			}
+			this[evt].apply(this, args);
+		}
+	},
+
+	_onmouseover: function(e) {
+		if(!this._enabled) { return };
+		dojo.html.addClass(this.domNode, &quot;hover&quot;);
+	},
+
+	_onmouseout: function(e) {
+		dojo.html.removeClass(this.domNode, &quot;hover&quot;);
+		dojo.html.removeClass(this.domNode, &quot;down&quot;);
+		if(!this._selected) {
+			dojo.html.removeClass(this.domNode, &quot;selected&quot;);
+		}
+	},
+
+	_onclick: function(e) {
+		// FIXME: buttons never seem to have this._enabled set to true on Opera 9
+		// dojo.debug(&quot;widget:&quot;, this.widgetType, &quot;:&quot;, this.getName(), &quot;, enabled:&quot;, this._enabled);
+		if(this._enabled &amp;&amp; !this._toggleItem) {
+			this._fireEvent(&quot;onClick&quot;);
+		}
+	},
+
+	_onmousedown: function(e) {
+		if(e.preventDefault) { e.preventDefault(); }
+		if(!this._enabled) { return };
+		dojo.html.addClass(this.domNode, &quot;down&quot;);
+		if(this._toggleItem) {
+			if(this.parent.preventDeselect &amp;&amp; this._selected) {
+				return;
+			}
+			this.toggleSelected();
+		}
+	},
+
+	_onmouseup: function(e) {
+		dojo.html.removeClass(this.domNode, &quot;down&quot;);
+	},
+
+	fillInTemplate: function(args, frag) {
+		if(args.name) { this._name = args.name; }
+		if(args.selected) { this.select(); }
+		if(args.disabled) { this.disable(); }
+		if(args.label) { this.setLabel(args.label); }
+		if(args.icon) { this.setIcon(args.icon); }
+		if(args.toggleitem||args.toggleItem) { this.setToggleItem(true); }
+	}
+});
+
+dojo.widget.ToolbarItem.make = function(wh, whIsType, props) {
+	var item = null;
+
+	if(wh instanceof Array) {
+		item = dojo.widget.createWidget(&quot;ToolbarButtonGroup&quot;, props);
+		item.setName(wh[0]);
+		for(var i = 1; i &lt; wh.length; i++) {
+			item.addChild(wh[i]);
+		}
+	} else if(wh instanceof dojo.widget.ToolbarItem) {
+		item = wh;
+	} else if(wh instanceof dojo.uri.Uri) {
+		item = dojo.widget.createWidget(&quot;ToolbarButton&quot;,
+			dojo.lang.mixin(props||{}, {icon: new dojo.widget.Icon(wh.toString())}));
+	} else if(whIsType) {
+		item = dojo.widget.createWidget(wh, props)
+	} else if(typeof wh == &quot;string&quot; || wh instanceof String) {
+		switch(wh.charAt(0)) {
+			case &quot;|&quot;:
+			case &quot;-&quot;:
+			case &quot;/&quot;:
+				item = dojo.widget.createWidget(&quot;ToolbarSeparator&quot;, props);
+				break;
+			case &quot; &quot;:
+				if(wh.length == 1) {
+					item = dojo.widget.createWidget(&quot;ToolbarSpace&quot;, props);
+				} else {
+					item = dojo.widget.createWidget(&quot;ToolbarFlexibleSpace&quot;, props);
+				}
+				break;
+			default:
+				if(/\.(gif|jpg|jpeg|png)$/i.test(wh)) {
+					item = dojo.widget.createWidget(&quot;ToolbarButton&quot;,
+						dojo.lang.mixin(props||{}, {icon: new dojo.widget.Icon(wh.toString())}));
+				} else {
+					item = dojo.widget.createWidget(&quot;ToolbarButton&quot;,
+						dojo.lang.mixin(props||{}, {label: wh.toString()}));
+				}
+		}
+	} else if(wh &amp;&amp; wh.tagName &amp;&amp; /^img$/i.test(wh.tagName)) {
+		item = dojo.widget.createWidget(&quot;ToolbarButton&quot;,
+			dojo.lang.mixin(props||{}, {icon: wh}));
+	} else {
+		item = dojo.widget.createWidget(&quot;ToolbarButton&quot;,
+			dojo.lang.mixin(props||{}, {label: wh.toString()}));
+	}
+	return item;
+}
+
+/* ToolbarButtonGroup
+ *********************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarButtonGroup&quot;);
+dojo.widget.html.ToolbarButtonGroup = function() {
+	dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarButtonGroup, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarButtonGroup, {
+	widgetType: &quot;ToolbarButtonGroup&quot;,
+	isContainer: true,
+
+	templateString: '&lt;span unselectable=&quot;on&quot; class=&quot;toolbarButtonGroup&quot; dojoAttachPoint=&quot;containerNode&quot;&gt;&lt;/span&gt;',
+
+	// if a button has the same name, it will be selected
+	// if this is set to a number, the button at that index will be selected
+	defaultButton: &quot;&quot;,
+
+    postCreate: function() {
+        for (var i = 0; i &lt; this.children.length; i++) {
+            this._injectChild(this.children[i]);
+        }
+    },
+
+	addChild: function(item, pos, props) {
+		var widget = dojo.widget.ToolbarItem.make(item, null, dojo.lang.mixin(props||{}, {toggleItem:true}));
+		var ret = dojo.widget.html.ToolbarButtonGroup.superclass.addChild.call(this, widget, null, pos, null);
+        this._injectChild(widget);
+        return ret;
+    },
+
+    _injectChild: function(widget) {
+        dojo.event.connect(widget, &quot;onSelect&quot;, this, &quot;onChildSelected&quot;);
+        dojo.event.connect(widget, &quot;onDeselect&quot;, this, &quot;onChildDeSelected&quot;);
+        if(widget._name == this.defaultButton
+			|| (typeof this.defaultButton == &quot;number&quot;
+			&amp;&amp; this.children.length-1 == this.defaultButton)) {
+			widget.select(false, true);
+		}
+	},
+
+	getItem: function(name) {
+		if(name instanceof dojo.widget.ToolbarItem) { return name; }
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem
+				&amp;&amp; child._name == name) { return child; }
+		}
+		return null;
+	},
+
+	getItems: function() {
+		var items = [];
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				items.push(child);
+			}
+		}
+		return items;
+	},
+
+	onChildSelected: function(e) {
+		this.select(e._name);
+	},
+
+	onChildDeSelected: function(e) {
+		this._fireEvent(&quot;onChangeSelect&quot;, this._value);
+	},
+
+	enable: function(force, preventEvent) {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.enable(force, preventEvent);
+				if(child._name == this._value) {
+					child.select(force, preventEvent);
+				}
+			}
+		}
+	},
+
+	disable: function(force, preventEvent) {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				child.disable(force, preventEvent);
+			}
+		}
+	},
+
+	_value: &quot;&quot;,
+	getValue: function() { return this._value; },
+
+	select: function(name, force, preventEvent) {
+		for(var i = 0; i &lt; this.children.length; i++) {
+			var child = this.children[i];
+			if(child instanceof dojo.widget.ToolbarItem) {
+				if(child._name == name) {
+					child.select(force, preventEvent);
+					this._value = name;
+				} else {
+					child.deselect(true, true);
+				}
+			}
+		}
+		if(!preventEvent) {
+			this._fireEvent(&quot;onSelect&quot;, this._value);
+			this._fireEvent(&quot;onChangeSelect&quot;, this._value);
+		}
+	},
+	setValue: this.select,
+
+	preventDeselect: false // if true, once you select one, you can't have none selected
+});
+
+/* ToolbarButton
+ ***********************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarButton&quot;);
+dojo.widget.html.ToolbarButton = function() {
+	dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarButton, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarButton, {
+	widgetType: &quot;ToolbarButton&quot;,
+
+	fillInTemplate: function(args, frag) {
+		dojo.widget.html.ToolbarButton.superclass.fillInTemplate.call(this, args, frag);
+		dojo.html.addClass(this.domNode, &quot;toolbarButton&quot;);
+		if(this._icon) {
+			this.setIcon(this._icon);
+		}
+		if(this._label) {
+			this.setLabel(this._label);
+		}
+
+		if(!this._name) {
+			if(this._label) {
+				this.setName(this._label);
+			} else if(this._icon) {
+				var src = this._icon.getSrc(&quot;enabled&quot;).match(/[\/^]([^\.\/]+)\.(gif|jpg|jpeg|png)$/i);
+				if(src) { this.setName(src[1]); }
+			} else {
+				this._name = this._widgetId;
+			}
+		}
+	}
+});
+
+/* ToolbarDialog
+ **********************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarDialog&quot;);
+dojo.widget.html.ToolbarDialog = function() {
+	dojo.widget.html.ToolbarButton.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarDialog, dojo.widget.html.ToolbarButton);
+dojo.lang.extend(dojo.widget.html.ToolbarDialog, {
+	widgetType: &quot;ToolbarDialog&quot;,
+	
+	fillInTemplate: function (args, frag) {
+		dojo.widget.html.ToolbarDialog.superclass.fillInTemplate.call(this, args, frag);
+		dojo.event.connect(this, &quot;onSelect&quot;, this, &quot;showDialog&quot;);
+		dojo.event.connect(this, &quot;onDeselect&quot;, this, &quot;hideDialog&quot;);
+	},
+	
+	showDialog: function (e) {
+		dojo.lang.setTimeout(dojo.event.connect, 1, document, &quot;onmousedown&quot;, this, &quot;deselect&quot;);
+	},
+	
+	hideDialog: function (e) {
+		dojo.event.disconnect(document, &quot;onmousedown&quot;, this, &quot;deselect&quot;);
+	}
+
+});
+
+/* ToolbarMenu
+ **********************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarMenu&quot;);
+dojo.widget.html.ToolbarMenu = function() {
+	dojo.widget.html.ToolbarDialog.call(this);
+
+	this.widgetType = &quot;ToolbarMenu&quot;;
+}
+dojo.inherits(dojo.widget.html.ToolbarMenu, dojo.widget.html.ToolbarDialog);
+
+/* ToolbarMenuItem
+ ******************/
+dojo.widget.ToolbarMenuItem = function() {
+}
+
+/* ToolbarSeparator
+ **********************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarSeparator&quot;);
+dojo.widget.html.ToolbarSeparator = function() {
+    dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarSeparator, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarSeparator, {
+	widgetType: &quot;ToolbarSeparator&quot;,
+	templateString: '&lt;span unselectable=&quot;on&quot; class=&quot;toolbarItem toolbarSeparator&quot;&gt;&lt;/span&gt;',
+
+	defaultIconPath: new dojo.uri.dojoUri(&quot;src/widget/templates/buttons/-.gif&quot;),
+
+	fillInTemplate: function(args, frag, skip) {
+		dojo.widget.html.ToolbarSeparator.superclass.fillInTemplate.call(this, args, frag);
+		this._name = this.widgetId;
+		if(!skip) {
+			if(!this._icon) {
+				this.setIcon(this.defaultIconPath);
+			}
+			this.domNode.appendChild(this._icon.getNode());
+		}
+	},
+
+	// don't want events!
+	_onmouseover: null, 
+    _onmouseout: null, 
+    _onclick: null, 
+    _onmousedown: null, 
+    _onmouseup: null 
+});
+
+/* ToolbarSpace
+ **********************/
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarSpace&quot;);
+dojo.widget.html.ToolbarSpace = function() {
+	dojo.widget.html.ToolbarSeparator.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarSpace, dojo.widget.html.ToolbarSeparator);
+dojo.lang.extend(dojo.widget.html.ToolbarSpace, {
+    widgetType: &quot;ToolbarSpace&quot;,
+
+	fillInTemplate: function(args, frag, skip) {
+		dojo.widget.html.ToolbarSpace.superclass.fillInTemplate.call(this, args, frag, true);
+		if(!skip) {
+			dojo.html.addClass(this.domNode, &quot;toolbarSpace&quot;);
+		}
+	}
+});
+
+/* ToolbarSelect
+ ******************/ 
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:toolbarSelect&quot;);
+dojo.widget.html.ToolbarSelect = function() {
+	dojo.widget.ToolbarItem.call(this);
+}
+dojo.inherits(dojo.widget.html.ToolbarSelect, dojo.widget.ToolbarItem);
+dojo.lang.extend(dojo.widget.html.ToolbarSelect, {
+    widgetType: &quot;ToolbarSelect&quot;,
+	templateString: '&lt;span class=&quot;toolbarItem toolbarSelect&quot; unselectable=&quot;on&quot;&gt;&lt;select dojoAttachPoint=&quot;selectBox&quot; dojoOnChange=&quot;changed&quot;&gt;&lt;/select&gt;&lt;/span&gt;',
+
+	fillInTemplate: function(args, frag) {
+		dojo.widget.html.ToolbarSelect.superclass.fillInTemplate.call(this, args, frag, true);
+		var keys = args.values;
+		var i = 0;
+		for(var val in keys) {
+			var opt = document.createElement(&quot;option&quot;);
+			opt.setAttribute(&quot;value&quot;, keys[val]);
+			opt.innerHTML = val;
+			this.selectBox.appendChild(opt);
+		}
+	},
+
+	changed: function(e) {
+		this._fireEvent(&quot;onSetValue&quot;, this.selectBox.value);
+	},
+
+	setEnabled: function(is, force, preventEvent) {
+		var ret = dojo.widget.html.ToolbarSelect.superclass.setEnabled.call(this, is, force, preventEvent);
+		this.selectBox.disabled = !this._enabled;
+		return ret;
+	},
+
+	// don't want events!
+	_onmouseover: null,
+    _onmouseout: null,
+    _onclick: null,
+    _onmousedown: null,
+    _onmouseup: null
+});
+
+/* Icon
+ *********/
+// arguments can be IMG nodes, Image() instances or URLs -- enabled is the only one required
+dojo.widget.Icon = function(enabled, disabled, hover, selected){
+	if(!arguments.length){
+		// FIXME: should this be dojo.raise?
+		throw new Error(&quot;Icon must have at least an enabled state&quot;);
+	}
+	var states = [&quot;enabled&quot;, &quot;disabled&quot;, &quot;hover&quot;, &quot;selected&quot;];
+	var currentState = &quot;enabled&quot;;
+	var domNode = document.createElement(&quot;img&quot;);
+
+	this.getState = function(){ return currentState; }
+	this.setState = function(value){
+		if(dojo.lang.inArray(value, states)){
+			if(this[value]){
+				currentState = value;
+				domNode.setAttribute(&quot;src&quot;, this[currentState].src);
+			}
+		}else{
+			throw new Error(&quot;Invalid state set on Icon (state: &quot; + value + &quot;)&quot;);
+		}
+	}
+
+	this.setSrc = function(state, value){
+		if(/^img$/i.test(value.tagName)){
+			this[state] = value;
+		}else if(typeof value == &quot;string&quot; || value instanceof String
+			|| value instanceof dojo.uri.Uri){
+			this[state] = new Image();
+			this[state].src = value.toString();
+		}
+		return this[state];
+	}
+
+	this.setIcon = function(icon){
+		for(var i = 0; i &lt; states.length; i++){
+			if(icon[states[i]]){
+				this.setSrc(states[i], icon[states[i]]);
+			}
+		}
+		this.update();
+	}
+
+	this.enable = function(){ this.setState(&quot;enabled&quot;); }
+	this.disable = function(){ this.setState(&quot;disabled&quot;); }
+	this.hover = function(){ this.setState(&quot;hover&quot;); }
+	this.select = function(){ this.setState(&quot;selected&quot;); }
+
+	this.getSize = function(){
+		return {
+			width: domNode.width||domNode.offsetWidth,
+			height: domNode.height||domNode.offsetHeight
+		};
+	}
+
+	this.setSize = function(w, h){
+		domNode.width = w;
+		domNode.height = h;
+		return { width: w, height: h };
+	}
+
+	this.getNode = function(){
+		return domNode;
+	}
+
+	this.getSrc = function(state){
+		if(state){ return this[state].src; }
+		return domNode.src||&quot;&quot;;
+	}
+
+	this.update = function(){
+		this.setState(currentState);
+	}
+
+	for(var i = 0; i &lt; states.length; i++){
+		var arg = arguments[i];
+		var state = states[i];
+		this[state] = null;
+		if(!arg){ continue; }
+		this.setSrc(state, arg);
+	}
+
+	this.enable();
+}
+
+dojo.widget.Icon.make = function(a,b,c,d){
+	for(var i = 0; i &lt; arguments.length; i++){
+		if(arguments[i] instanceof dojo.widget.Icon){
+			return arguments[i];
+		}
+	}
+
+	return new dojo.widget.Icon(a,b,c,d);
+}

Added: trunk/root/static/magic/src/widget/Tooltip.js
===================================================================
--- trunk/root/static/magic/src/widget/Tooltip.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Tooltip.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Tooltip&quot;);
+dojo.require(&quot;dojo.widget.Widget&quot;);
+
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.Tooltip&quot;);

Added: trunk/root/static/magic/src/widget/Tree.js
===================================================================
--- trunk/root/static/magic/src/widget/Tree.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Tree.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,569 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+ * Tree model does all the drawing, visual node management etc.
+ * Throws events about clicks on it, so someone may catch them and process
+ * Tree knows nothing about DnD stuff, covered in TreeDragAndDrop and (if enabled) attached by controller
+*/
+
+/**
+ * TODO: use domNode.cloneNode instead of createElement for grid
+ * Should be faster (lyxsus)
+ */
+dojo.provide(&quot;dojo.widget.Tree&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.TreeNode&quot;);
+
+
+
+// make it a tag
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:Tree&quot;);
+
+
+dojo.widget.Tree = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+	this.eventNames = {};
+
+	this.tree = this;
+	this.DNDAcceptTypes = [];
+	this.actionsDisabled = [];
+
+}
+dojo.inherits(dojo.widget.Tree, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.Tree, {
+	widgetType: &quot;Tree&quot;,
+
+	eventNamesDefault: {
+		// new child does not get domNode filled in (only template draft)
+		// until addChild-&gt;createDOMNode is called(program way) OR createDOMNode (html-way)
+		// hook events to operate on new DOMNode, create dropTargets etc
+		createDOMNode: &quot;createDOMNode&quot;,
+		// tree created.. Perform tree-wide actions if needed
+		treeCreate: &quot;treeCreate&quot;,
+		treeDestroy: &quot;treeDestroy&quot;,
+		// expand icon clicked
+		treeClick: &quot;treeClick&quot;,
+		// node icon clicked
+		iconClick: &quot;iconClick&quot;,
+		// node title clicked
+		titleClick: &quot;titleClick&quot;,
+
+		moveFrom: &quot;moveFrom&quot;,
+		moveTo: &quot;moveTo&quot;,
+		addChild: &quot;addChild&quot;,
+		removeNode: &quot;removeNode&quot;,
+		expand: &quot;expand&quot;,
+		collapse: &quot;collapse&quot;
+	},
+
+	isContainer: true,
+
+	DNDMode: &quot;off&quot;,
+
+	lockLevel: 0, // lock ++ unlock --, so nested locking works fine
+
+	strictFolders: true,
+
+	DNDModes: {
+		BETWEEN: 1,
+		ONTO: 2
+	},
+
+	DNDAcceptTypes: &quot;&quot;,
+
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/Tree.css&quot;),
+
+	templateString: '&lt;div class=&quot;dojoTree&quot;&gt;&lt;/div&gt;',
+
+	isExpanded: true, // consider this &quot;root node&quot; to be always expanded
+
+	isTree: true,
+
+	objectId: &quot;&quot;,
+
+	// autoCreate if not &quot;off&quot;
+	// used to get the autocreated controller ONLY.
+	// generally, tree DOES NOT KNOW about its CONTROLLER, it just doesn't care
+	// controller gets messages via dojo.event
+	controller: &quot;&quot;,
+
+	// autoCreate if not &quot;off&quot;
+	// used to get the autocreated selector ONLY.
+	// generally, tree DOES NOT KNOW its SELECTOR
+	// binding is made with dojo.event
+	selector: &quot;&quot;,
+
+	// used ONLY at initialization time
+	menu: &quot;&quot;, // autobind menu if menu's widgetId is set here
+
+	expandLevel: &quot;&quot;, // expand to level automatically
+
+	//
+	// these icons control the grid and expando buttons for the whole tree
+	//
+
+	blankIconSrc: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_blank.gif&quot;),
+
+	gridIconSrcT: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_t.gif&quot;), // for non-last child grid
+	gridIconSrcL: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_l.gif&quot;), // for last child grid
+	gridIconSrcV: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_v.gif&quot;), // vertical line
+	gridIconSrcP: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_p.gif&quot;), // for under parent item child icons
+	gridIconSrcC: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_c.gif&quot;), // for under child item child icons
+	gridIconSrcX: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_x.gif&quot;), // grid for sole root item
+	gridIconSrcY: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_y.gif&quot;), // grid for last rrot item
+	gridIconSrcZ: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_grid_z.gif&quot;), // for under root parent item child icon
+
+	expandIconSrcPlus: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_expand_plus.gif&quot;),
+	expandIconSrcMinus: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_expand_minus.gif&quot;),
+	expandIconSrcLoading: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/treenode_loading.gif&quot;),
+
+
+	iconWidth: 18,
+	iconHeight: 18,
+
+
+	//
+	// tree options
+	//
+
+	showGrid: true,
+	showRootGrid: true,
+
+	actionIsDisabled: function(action) {
+		var _this = this;
+		return dojo.lang.inArray(_this.actionsDisabled, action)
+	},
+
+
+	actions: {
+    	ADDCHILD: &quot;ADDCHILD&quot;
+	},
+
+
+	getInfo: function() {
+		var info = {
+			widgetId: this.widgetId,
+			objectId: this.objectId
+		}
+
+		return info;
+	},
+
+	initializeController: function() {
+		if (this.controller != &quot;off&quot;) {
+			if (this.controller) {
+				this.controller = dojo.widget.byId(this.controller);
+			}
+			else {
+				// create default controller here
+				dojo.require(&quot;dojo.widget.TreeBasicController&quot;);
+				this.controller = dojo.widget.createWidget(&quot;TreeBasicController&quot;,
+					{ DNDController: (this.DNDMode ? &quot;create&quot; : &quot;&quot;), dieWithTree: true }
+				 );
+
+			}
+			this.controller.listenTree(this); // controller listens to my events
+
+		} else {
+			this.controller = null;
+		}
+	},
+
+	initializeSelector: function() {
+
+		if (this.selector != &quot;off&quot;) {
+			if (this.selector) {
+				this.selector = dojo.widget.byId(this.selector);
+			}
+			else {
+				// create default controller here
+				dojo.require(&quot;dojo.widget.TreeSelector&quot;);
+				this.selector = dojo.widget.createWidget(&quot;TreeSelector&quot;, {dieWithTree: true});
+			}
+
+			this.selector.listenTree(this);
+
+		} else {
+			this.selector = null;
+		}
+	},
+
+	initialize: function(args, frag){
+
+		var _this = this;
+
+		for(name in this.eventNamesDefault) {
+			if (dojo.lang.isUndefined(this.eventNames[name])) {
+				this.eventNames[name] = this.widgetId+&quot;/&quot;+this.eventNamesDefault[name];
+			}
+		}
+
+		for(var i=0; i&lt;this.actionsDisabled.length; i++) {
+			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
+		}
+
+		if (this.DNDMode == &quot;off&quot;) {
+			this.DNDMode = 0;
+		} else if (this.DNDMode == &quot;between&quot;) {
+			this.DNDMode = this.DNDModes.ONTO | this.DNDModes.BETWEEN;
+		} else if (this.DNDMode == &quot;onto&quot;) {
+			this.DNDMode = this.DNDModes.ONTO;
+		}
+
+		this.expandLevel = parseInt(this.expandLevel);
+
+		this.initializeSelector();
+		this.initializeController();
+
+		if (this.menu) {
+			this.menu = dojo.widget.byId(this.menu);
+			this.menu.listenTree(this);
+		}
+
+
+		this.containerNode = this.domNode;
+
+	},
+
+
+	postCreate: function() {
+		this.createDOMNode();
+	},
+
+
+	createDOMNode: function() {
+
+		dojo.html.disableSelection(this.domNode);
+
+		for(var i=0; i&lt;this.children.length; i++){
+			this.children[i].parent = this; // root nodes have tree as parent
+
+			var node = this.children[i].createDOMNode(this, 0);
+
+
+			this.domNode.appendChild(node);
+		}
+
+
+		if (!this.showRootGrid){
+			for(var i=0; i&lt;this.children.length; i++){
+				this.children[i].expand();
+			}
+		}
+
+		dojo.event.topic.publish(this.eventNames.treeCreate, { source: this } );
+
+	},
+
+
+	destroy: function() {
+		dojo.event.topic.publish(this.tree.eventNames.treeDestroy, { source: this } );
+
+		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
+	},
+
+
+	addChild: function(child, index) {
+
+//		dojo.debug(&quot;doAddChild &quot;+index+&quot; called for &quot;+child);
+
+		var message = {
+			child: child,
+			index: index,
+			parent: this,
+			// remember if dom was already initialized
+			// initialized =&gt; no createDOMNode =&gt; no createDOMNode event
+			domNodeInitialized: child.domNodeInitialized
+		}
+
+		this.doAddChild.apply(this, arguments);
+
+		dojo.event.topic.publish(this.tree.eventNames.addChild, message);
+	},
+
+
+	// not called for initial tree building. See createDOMNode instead.
+	// builds child html node if needed
+	// index is &quot;last node&quot; by default
+	/**
+	 * FIXME: Is it possible that removeNode from the tree will cause leaks cause of attached events ?
+	 * if yes, then only attach events in addChild and detach in remove.. Seems all ok yet.
+	*/
+	doAddChild: function(child, index){
+
+		if (dojo.lang.isUndefined(index)) {
+			index = this.children.length;
+		}
+
+		if (!child.isTreeNode){
+			dojo.raise(&quot;You can only add TreeNode widgets to a &quot;+this.widgetType+&quot; widget!&quot;);
+			return;
+		}
+
+		// usually it is impossible to change &quot;isFolder&quot; state, but if anyone wants to add a child to leaf,
+		// it is possible program-way.
+		if (this.isTreeNode){
+			if (!this.isFolder) { // just became a folder.
+				//dojo.debug(&quot;becoming folder &quot;+this);
+				this.setFolder();
+			}
+		}
+
+		// adjust tree
+		var _this = this;
+		dojo.lang.forEach(child.getDescendants(), function(elem) { elem.tree = _this.tree; });
+
+		// fix parent
+		child.parent = this;
+
+
+		// no dynamic loading for those who become parents
+		if (this.isTreeNode) {
+			this.state = this.loadStates.LOADED;
+		}
+
+		// add new child into DOM after it was added into children
+		if (index &lt; this.children.length) { // children[] already has child
+			//dojo.debug(&quot;Inserting before &quot;+this.children[index].title);
+			dojo.dom.insertBefore(child.domNode, this.children[index].domNode);
+		} else {
+			this.containerNode.appendChild(child.domNode);
+			if (this.isExpanded &amp;&amp; this.isTreeNode) {
+				/* When I add children to hidden containerNode =&gt; show container w/ them */
+				this.showChildren();
+			}
+		}
+
+
+		this.children.splice(index, 0, child);
+
+		//dojo.debugShallow(this.children);
+
+
+		// if node exists - adjust its depth, otherwise build it
+		if (child.domNodeInitialized) {
+			var d = this.isTreeNode ? this.depth : -1;
+			child.adjustDepth( d - child.depth + 1 );
+
+
+			// update icons to link generated dom with Tree =&gt; updateParentGrid
+			// if I moved child from LastNode inside the tree =&gt; need to link it up'n'down =&gt;
+			// updateExpandGridColumn
+			// if I change depth =&gt; need to update all grid..
+			child.updateIconTree();
+		} else {
+			//dojo.debug(&quot;Create domnode &quot;);
+			child.depth = this.isTreeNode ? this.depth+1 : 0;
+			child.createDOMNode(child.tree, child.depth);
+		}
+
+
+
+		// Use-case:
+		// When previous sibling was created =&gt; it was last, no children after it
+		// so it did not create link down =&gt; let's add it for all descendants
+		// Use-case:
+		// a child was moved down under the last node so last node should be updated
+		var prevSibling = child.getPreviousSibling();
+		if (child.isLastNode() &amp;&amp; prevSibling) {
+			prevSibling.updateExpandGridColumn();
+		}
+
+
+		//dojo.debug(&quot;Added child &quot;+child);
+
+
+
+	},
+
+
+
+
+	makeBlankImg: function() {
+		var img = document.createElement('img');
+
+		img.style.width = this.iconWidth + 'px';
+		img.style.height = this.iconHeight + 'px';
+		img.src = this.blankIconSrc;
+		img.style.verticalAlign = 'middle';
+
+		return img;
+	},
+
+
+	updateIconTree: function(){
+
+		//dojo.debug(&quot;Update icons for &quot;+this)
+		if (!this.isTree) {
+			this.updateIcons();
+		}
+
+		for(var i=0; i&lt;this.children.length; i++){
+			this.children[i].updateIconTree();
+		}
+
+	},
+
+	toString: function() {
+		return &quot;[&quot;+this.widgetType+&quot; ID:&quot;+this.widgetId+&quot;]&quot;
+	},
+
+
+
+
+	/**
+	 * Move child to newParent as last child
+	 * redraw tree and update icons.
+	 *
+	 * Called by target, saves source in event.
+	 * events are published for BOTH trees AFTER update.
+	*/
+	move: function(child, newParent, index) {
+
+		//dojo.debug(child+&quot; &quot;+newParent+&quot; at &quot;+index);
+
+		var oldParent = child.parent;
+		var oldTree = child.tree;
+
+		this.doMove.apply(this, arguments);
+
+		var newParent = child.parent;
+		var newTree = child.tree;
+
+		var message = {
+				oldParent: oldParent, oldTree: oldTree,
+				newParent: newParent, newTree: newTree,
+				child: child
+		};
+
+		/* publish events here about structural changes for both source and target trees */
+		dojo.event.topic.publish(oldTree.eventNames.moveFrom, message);
+		dojo.event.topic.publish(newTree.eventNames.moveTo, message);
+
+	},
+
+
+	/* do actual parent change here. Write remove child first */
+	doMove: function(child, newParent, index) {
+		//var parent = child.parent;
+		child.parent.doRemoveNode(child);
+
+		newParent.doAddChild(child, index);
+	},
+
+
+
+// ================================ removeNode ===================================
+
+	removeNode: function(child) {
+		if (!child.parent) return;
+
+		var oldTree = child.tree;
+		var oldParent = child.parent;
+
+		var removedChild = this.doRemoveNode.apply(this, arguments);
+
+
+		dojo.event.topic.publish(this.tree.eventNames.removeNode,
+			{ child: removedChild, tree: oldTree, parent: oldParent }
+		);
+
+		return removedChild;
+	},
+
+
+	doRemoveNode: function(child) {
+		if (!child.parent) return;
+
+		var parent = child.parent;
+
+		var children = parent.children;
+
+
+		var index = child.getParentIndex();
+		if (index &lt; 0) {
+			dojo.raise(&quot;Couldn't find node &quot;+child+&quot; for removal&quot;);
+		}
+
+
+		children.splice(index,1);
+		dojo.dom.removeNode(child.domNode);
+
+		if (parent.children.length == 0) {
+			parent.containerNode.style.display = &quot;none&quot;;
+		}
+
+		// if WAS last node (children.length decreased already) and has prevSibling
+		if (index == children.length &amp;&amp; index&gt;0) {
+			children[index-1].updateExpandGridColumn();
+		}
+		// if it WAS first node in WHOLE TREE -
+		// update link up of its former lower neighbour(if exists still)
+		if (parent instanceof dojo.widget.Tree &amp;&amp; index == 0 &amp;&amp; children.length&gt;0) {
+			children[0].updateExpandGrid();
+		}
+
+		//parent.updateIconTree();
+
+
+		child.parent = child.tree = null;
+
+		return child;
+	},
+
+	markLoading: function() {
+		// no way to mark tree loading
+	},
+
+	unMarkLoading: function() {
+		// no way to show that tree finished loading
+	},
+
+
+	lock: function() {
+		!this.lockLevel &amp;&amp; this.markLoading();
+		this.lockLevel++;
+	},
+	unlock: function() {
+		if (!this.lockLevel) {
+			dojo.raise(&quot;unlock: not locked&quot;);
+		}
+		this.lockLevel--;
+		!this.lockLevel &amp;&amp; this.unMarkLoading();
+	},
+
+	isLocked: function() {
+		var node = this;
+		while (true) {
+			if (node.lockLevel) {
+				return true;
+			}
+			if (node instanceof dojo.widget.Tree) {
+				break;
+			}
+			node = node.parent;
+		}
+
+		return false;
+	},
+
+	flushLock: function() {
+		this.lockLevel = 0;
+		this.unMarkLoading();
+	}
+});
+
+

Added: trunk/root/static/magic/src/widget/TreeBasicController.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeBasicController.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeBasicController.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,294 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+
+dojo.provide(&quot;dojo.widget.TreeBasicController&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.json&quot;)
+dojo.require(&quot;dojo.io.*&quot;);
+
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeBasicController&quot;);
+
+
+dojo.widget.TreeBasicController = function() {
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.TreeBasicController, dojo.widget.HtmlWidget);
+
+
+dojo.lang.extend(dojo.widget.TreeBasicController, {
+	widgetType: &quot;TreeBasicController&quot;,
+
+	DNDController: &quot;&quot;,
+
+	dieWithTree: false,
+
+	initialize: function(args, frag){
+
+		/* no DND by default for compatibility */
+		if (this.DNDController == &quot;create&quot;) {
+			dojo.require(&quot;dojo.dnd.TreeDragAndDrop&quot;);
+			this.DNDController = new dojo.dnd.TreeDNDController(this);
+		}
+
+
+
+	},
+
+
+	/**
+	 * Binds controller to all tree events
+	*/
+	listenTree: function(tree) {
+		//dojo.debug(&quot;Event &quot;+tree.eventNames.treeClick);
+		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, &quot;onCreateDOMNode&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.treeClick, this, &quot;onTreeClick&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.treeCreate, this, &quot;onTreeCreate&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+
+		if (this.DNDController) {
+			this.DNDController.listenTree(tree);
+		}
+	},
+
+	unlistenTree: function(tree) {
+		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, &quot;onCreateDOMNode&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.treeClick, this, &quot;onTreeClick&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.treeCreate, this, &quot;onTreeCreate&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+	},
+
+	onTreeDestroy: function(message) {
+		var tree = message.source;
+
+		this.unlistenTree(tree);
+
+		if (this.dieWithTree) {
+			//alert(&quot;Killing myself &quot;+this.widgetId);
+			this.destroy();
+			//dojo.debug(&quot;done&quot;);
+		}
+	},
+
+	onCreateDOMNode: function(message) {
+
+		var node = message.source;
+
+
+		if (node.expandLevel &gt; 0) {
+			this.expandToLevel(node, node.expandLevel);
+		}
+	},
+
+	// perform actions-initializers for tree
+	onTreeCreate: function(message) {
+		var tree = message.source;
+		var _this = this;
+		if (tree.expandLevel) {
+			dojo.lang.forEach(tree.children,
+				function(child) {
+					_this.expandToLevel(child, tree.expandLevel-1)
+				}
+			);
+		}
+	},
+
+	expandToLevel: function(node, level) {
+		if (level == 0) return;
+
+		var children = node.children;
+		var _this = this;
+
+		var handler = function(node, expandLevel) {
+			this.node = node;
+			this.expandLevel = expandLevel;
+			// recursively expand opened node
+			this.process = function() {
+				//dojo.debug(&quot;Process &quot;+node+&quot; level &quot;+level);
+				for(var i=0; i&lt;this.node.children.length; i++) {
+					var child = node.children[i];
+
+					_this.expandToLevel(child, this.expandLevel);
+				}
+			};
+		}
+
+		var h = new handler(node, level-1);
+
+
+		this.expand(node, false, h, h.process);
+
+	},
+
+
+
+
+	onTreeClick: function(message){
+		var node = message.source;
+
+		if(node.isLocked()) {
+			return false;
+		}
+
+		if (node.isExpanded){
+			this.collapse(node);
+		} else {
+			this.expand(node);
+		}
+	},
+
+	expand: function(node, sync, callObj, callFunc) {
+		node.expand();
+		if (callFunc) callFunc.apply(callObj, [node]);
+	},
+
+	collapse: function(node) {
+
+		node.collapse();
+	},
+
+// =============================== move ============================
+
+	/**
+	 * Checks whether it is ok to change parent of child to newParent
+	 * May incur type checks etc
+	 *
+	 * It should check only hierarchical possibility w/o index, etc
+	 * because in onDragOver event for Between DND mode we can't calculate index at once on onDragOVer.
+	 * index changes as client moves mouse up-down over the node
+	 */
+	canMove: function(child, newParent){
+
+		if (child.actionIsDisabled(child.actions.MOVE)) {
+			return false;
+		}
+
+		// if we move under same parent then no matter if ADDCHILD disabled for him
+		// but if we move to NEW parent then check if action is disabled for him
+		// also covers case for newParent being a non-folder in strict mode etc
+		if (child.parent !== newParent &amp;&amp; newParent.actionIsDisabled(newParent.actions.ADDCHILD)) {
+			return false;
+		}
+
+		// Can't move parent under child. check whether new parent is child of &quot;child&quot;.
+		var node = newParent;
+		while(node.isTreeNode) {
+			//dojo.debugShallow(node.title)
+			if (node === child) {
+				// parent of newParent is child
+				return false;
+			}
+			node = node.parent;
+		}
+
+		return true;
+	},
+
+
+	move: function(child, newParent, index) {
+
+		/* move sourceTreeNode to new parent */
+		if (!this.canMove(child, newParent)) {
+			return false;
+		}
+
+		var result = this.doMove(child, newParent, index);
+
+		if (!result) return result;
+
+		if (newParent.isTreeNode) {
+			this.expand(newParent);
+		}
+
+		return result;
+	},
+
+	doMove: function(child, newParent, index) {
+		child.tree.move(child, newParent, index);
+
+		return true;
+	},
+
+// =============================== removeNode ============================
+
+
+	canRemoveNode: function(child) {
+		if (child.actionIsDisabled(child.actions.REMOVE)) {
+			return false;
+		}
+
+		return true;
+	},
+
+
+	removeNode: function(node, callObj, callFunc) {
+		if (!this.canRemoveNode(node)) {
+			return false;
+		}
+
+		return this.doRemoveNode(node, callObj, callFunc);
+	},
+
+
+	doRemoveNode: function(node, callObj, callFunc) {
+		node.tree.removeNode(node);
+
+		if (callFunc) {
+			callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node]);
+		}
+	},
+
+
+	// -----------------------------------------------------------------------------
+	//                             Create node stuff
+	// -----------------------------------------------------------------------------
+
+
+	canCreateChild: function(parent, index, data) {
+		if (parent.actionIsDisabled(parent.actions.ADDCHILD)) return false;
+
+		return true;
+	},
+
+
+	/* send data to server and add child from server */
+	/* data may contain an almost ready child, or anything else, suggested to server */
+	/*in RPC controllers server responds with child data to be inserted */
+	createChild: function(parent, index, data, callObj, callFunc) {
+		if (!this.canCreateChild(parent, index, data)) {
+			return false;
+		}
+
+		return this.doCreateChild.apply(this, arguments);
+	},
+
+	doCreateChild: function(parent, index, data, callObj, callFunc) {
+
+		var widgetType = data.widgetType ? data.widgetType : &quot;TreeNode&quot;;
+
+		var newChild = dojo.widget.createWidget(widgetType, data);
+
+		parent.addChild(newChild, index);
+
+		this.expand(parent);
+
+		if (callFunc) {
+			callFunc.apply(callObj, [newChild]);
+		}
+
+		return newChild;
+	}
+
+
+
+});

Added: trunk/root/static/magic/src/widget/TreeContextMenu.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeContextMenu.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeContextMenu.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,214 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+
+
+dojo.provide(&quot;dojo.widget.TreeContextMenu&quot;);
+dojo.provide(&quot;dojo.widget.TreeMenuItem&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.Menu2&quot;);
+
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeContextMenu&quot;);
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeMenuItem&quot;);
+
+
+
+dojo.widget.TreeContextMenu = function() {
+	dojo.widget.PopupMenu2.call(this);
+
+	this.listenedTrees = [];
+
+}
+
+
+dojo.inherits(dojo.widget.TreeContextMenu, dojo.widget.PopupMenu2);
+
+dojo.lang.extend(dojo.widget.TreeContextMenu, {
+
+	widgetType: &quot;TreeContextMenu&quot;,
+
+	open: function(x, y, parentMenu, explodeSrc){
+
+		var result = dojo.widget.PopupMenu2.prototype.open.apply(this, arguments);
+
+		/* publish many events here about structural changes */
+		dojo.event.topic.publish(this.eventNames.open, { menu:this });
+
+		return result;
+	},
+
+	listenTree: function(tree) {
+		/* add context menu to all nodes that exist already */
+		var nodes = tree.getDescendants();
+
+		for(var i=0; i&lt;nodes.length; i++) {
+			if (!nodes[i].isTreeNode) continue;
+			this.bindDomNode(nodes[i].labelNode);
+		}
+
+
+		/* bind context menu to all nodes that will be created in the future (e.g loaded from server)*/
+		var _this = this;
+		dojo.event.topic.subscribe(tree.eventNames.createDOMNode, this, &quot;onCreateDOMNode&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, &quot;onMoveFrom&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.moveTo, this, &quot;onMoveTo&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, &quot;onRemoveNode&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.addChild, this, &quot;onAddChild&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+
+		this.listenedTrees.push(tree);
+
+	},
+
+	unlistenTree: function(tree) {
+		/* clear event listeners */
+
+		dojo.event.topic.unsubscribe(tree.eventNames.createDOMNode, this, &quot;onCreateDOMNode&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, &quot;onMoveFrom&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.moveTo, this, &quot;onMoveTo&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, &quot;onRemoveNode&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.addChild, this, &quot;onAddChild&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+
+		for(var i=0; i&lt;this.listenedTrees.length; i++){
+           if(this.listenedTrees[i] === tree){
+                   this.listenedTrees.splice(i, 1);
+                   break;
+           }
+		}
+	},
+
+	onTreeDestroy: function(message) {
+		this.unlistenTree(message.source);
+	},
+
+	bindTreeNode: function(node) {
+		var _this = this;
+		//dojo.debug(&quot;bind to &quot;+node);
+		dojo.lang.forEach(node.getDescendants(),
+			function(e) {_this.bindDomNode(e.labelNode); }
+		);
+	},
+
+
+	unBindTreeNode: function(node) {
+		var _this = this;
+		//dojo.debug(&quot;Unbind from &quot;+node);
+		dojo.lang.forEach(node.getDescendants(),
+			function(e) {_this.unBindDomNode(e.labelNode); }
+		);
+	},
+
+	onCreateDOMNode: function(message) {
+		this.bindTreeNode(message.source);
+	},
+
+
+	onMoveFrom: function(message) {
+		if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+			this.unBindTreeNode(message.child);
+		}
+	},
+
+	onMoveTo: function(message) {
+		if (dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+			this.bindTreeNode(message.child);
+		}
+	},
+
+	onRemoveNode: function(message) {
+		this.unBindTreeNode(message.child);
+	},
+
+	onAddChild: function(message) {
+		if (message.domNodeInitialized) {
+			// dom node was there already =&gt; I did not process onNodeDomCreate
+			this.bindTreeNode(message.child);
+		}
+	}
+
+
+});
+
+
+
+
+
+
+dojo.widget.TreeMenuItem = function() {
+	dojo.widget.MenuItem2.call(this);
+
+}
+
+
+dojo.inherits(dojo.widget.TreeMenuItem, dojo.widget.MenuItem2);
+
+
+dojo.lang.extend(dojo.widget.TreeMenuItem, {
+
+	widgetType: &quot;TreeMenuItem&quot;,
+
+	// treeActions menu item performs following actions (to be checked for permissions)
+	treeActions: &quot;&quot;,
+
+	initialize: function(args, frag) {
+
+		this.treeActions = this.treeActions.split(&quot;,&quot;);
+		for(var i=0; i&lt;this.treeActions.length; i++) {
+			this.treeActions[i] = this.treeActions[i].toUpperCase();
+		}
+
+	},
+
+	getTreeNode: function() {
+		var menu = this;
+
+		while (! (menu instanceof dojo.widget.TreeContextMenu) ) {
+			menu = menu.parent;
+		}
+
+		var source = menu.getTopOpenEvent().target;
+
+		while (!source.getAttribute('treeNode') &amp;&amp; source.tagName != 'body') {
+			source = source.parentNode;
+		}
+		if (source.tagName == 'body') {
+			dojo.raise(&quot;treeNode not detected&quot;);
+		}
+		var treeNode = dojo.widget.manager.getWidgetById(source.getAttribute('treeNode'));
+
+		return treeNode;
+	},
+
+
+	menuOpen: function(message) {
+		var treeNode = this.getTreeNode();
+
+		this.setDisabled(false); // enable by default
+
+		var _this = this;
+		dojo.lang.forEach(_this.treeActions,
+			function(action) {
+				_this.setDisabled( treeNode.actionIsDisabled(action) );
+			}
+		);
+
+	},
+
+	toString: function() {
+		return &quot;[&quot;+this.widgetType+&quot; node &quot;+this.getTreeNode()+&quot;]&quot;;
+	}
+
+});
+
+

Added: trunk/root/static/magic/src/widget/TreeControllerExtension.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeControllerExtension.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeControllerExtension.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,95 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+ * Additional tree utils
+ *
+ */
+dojo.provide(&quot;dojo.widget.TreeControllerExtension&quot;);
+
+
+dojo.widget.TreeControllerExtension = function() { }
+
+dojo.lang.extend(dojo.widget.TreeControllerExtension, {
+
+	saveExpandedIndices: function(node, field) {
+		var obj = {};
+
+		for(var i=0; i&lt;node.children.length; i++) {
+			if (node.children[i].isExpanded) {
+				var key = dojo.lang.isUndefined(field) ? i : node.children[i][field];
+				obj[key] = this.saveExpandedIndices(node.children[i], field);
+			}
+		}
+
+		return obj;
+	},
+
+
+	restoreExpandedIndices: function(node, savedIndices, field) {
+		var _this = this;
+
+		var handler = function(node, savedIndices) {
+			this.node = node; //.children[i];
+			this.savedIndices = savedIndices; //[i];
+			// recursively read next savedIndices level and apply to opened node
+			this.process = function() {
+				//dojo.debug(&quot;Callback applied for &quot;+this.node);
+				_this.restoreExpandedIndices(this.node, this.savedIndices, field);
+			};
+		}
+
+
+		for(var i=0; i&lt;node.children.length; i++) {
+			var child = node.children[i];
+
+			var found = false;
+			var key = -1;
+
+			//dojo.debug(&quot;Check &quot;+child)
+			// process field set case
+			if (dojo.lang.isUndefined(field) &amp;&amp; savedIndices[i]) {
+				found = true;
+				key = i;
+			}
+
+			// process case when field is not set
+			if (field) {
+				for(var key in savedIndices) {
+					//dojo.debug(&quot;Compare &quot;+key+&quot; &quot;+child[field])
+					if (key == child[field]) {
+						found = true;
+						break;
+					}
+				}
+			}
+
+			// if we found anything - expand it
+			if (found) {
+				//dojo.debug(&quot;Found at &quot;+key)
+				var h = new handler(child, savedIndices[key]);
+				_this.expand(child, false, h, h.process);
+			} else if (child.isExpanded) { // not found, so collapse
+				//dojo.debug(&quot;Collapsing all descendants &quot;+node.children[i])
+				dojo.lang.forEach(child.getDescendants(), function(elem) { _this.collapse(elem); });
+				//this.collapse(node.children[i]);
+			}
+
+		}
+
+
+	}
+
+});
+
+
+
+
+

Added: trunk/root/static/magic/src/widget/TreeLoadingController.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeLoadingController.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeLoadingController.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,217 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+
+dojo.provide(&quot;dojo.widget.TreeLoadingController&quot;);
+
+dojo.require(&quot;dojo.widget.TreeBasicController&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.json&quot;)
+dojo.require(&quot;dojo.io.*&quot;);
+
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeLoadingController&quot;);
+
+
+dojo.widget.TreeLoadingController = function() {
+	dojo.widget.TreeBasicController.call(this);
+}
+
+dojo.inherits(dojo.widget.TreeLoadingController, dojo.widget.TreeBasicController);
+
+
+dojo.lang.extend(dojo.widget.TreeLoadingController, {
+	widgetType: &quot;TreeLoadingController&quot;,
+
+	RPCUrl: &quot;&quot;,
+
+	RPCActionParam: &quot;action&quot;, // used for GET for RPCUrl
+
+
+	/**
+	 * Common RPC error handler (dies)
+	*/
+	RPCErrorHandler: function(type, obj, evt) {
+		alert( &quot;RPC Error: &quot; + (obj.message||&quot;no message&quot;));
+	},
+
+
+
+	getRPCUrl: function(action) {
+
+		// RPCUrl=local meant SOLELY for DEMO and LOCAL TESTS.
+		// May lead to widgetId collisions
+		if (this.RPCUrl == &quot;local&quot;) {
+			var dir = document.location.href.substr(0, document.location.href.lastIndexOf('/'));
+			var localUrl = dir+&quot;/&quot;+action;
+			//dojo.debug(localUrl);
+			return localUrl;
+		}
+
+		if (!this.RPCUrl) {
+			dojo.raise(&quot;Empty RPCUrl: can't load&quot;);
+		}
+
+		return this.RPCUrl + ( this.RPCUrl.indexOf(&quot;?&quot;) &gt; -1 ? &quot;&amp;&quot; : &quot;?&quot;) + this.RPCActionParam+&quot;=&quot;+action;
+	},
+
+
+	/**
+	 * Add all loaded nodes from array obj as node children and expand it
+	*/
+	loadProcessResponse: function(node, result, callObj, callFunc) {
+
+		if (!dojo.lang.isUndefined(result.error)) {
+			this.RPCErrorHandler(&quot;server&quot;, result.error);
+			return false;
+		}
+
+		//dojo.debugShallow(result);
+
+		var newChildren = result;
+
+		if (!dojo.lang.isArray(newChildren)) {
+			dojo.raise('loadProcessResponse: Not array loaded: '+newChildren);
+		}
+
+		for(var i=0; i&lt;newChildren.length; i++) {
+			// looks like dojo.widget.manager needs no special &quot;add&quot; command
+			newChildren[i] = dojo.widget.createWidget(node.widgetType, newChildren[i]);
+			node.addChild(newChildren[i]);
+		}
+
+
+		//node.addAllChildren(newChildren);
+
+		node.state = node.loadStates.LOADED;
+
+		//dojo.debug(callFunc);
+
+		if (dojo.lang.isFunction(callFunc)) {
+			callFunc.apply(dojo.lang.isUndefined(callObj) ? this : callObj, [node, newChildren]);
+		}
+		//this.expand(node);
+	},
+
+	getInfo: function(obj) {
+		return obj.getInfo();
+	},
+
+	runRPC: function(kw) {
+		var _this = this;
+
+		var handle = function(type, data, evt) {
+			// unlock BEFORE any processing is done
+			// so errorHandler may apply locking
+			if (kw.lock) {
+				dojo.lang.forEach(kw.lock,
+					function(t) { t.unlock() }
+				);
+			}
+
+			if(type == &quot;load&quot;){
+				kw.load.call(this, data);
+			}else{
+				this.RPCErrorHandler(type, data, evt);
+			}
+
+		}
+
+		if (kw.lock) {
+			dojo.lang.forEach(kw.lock,
+				function(t) { t.lock() }
+			);
+		}
+
+
+		dojo.io.bind({
+			url: kw.url,
+			/* I hitch to get this.loadOkHandler */
+			handle: dojo.lang.hitch(this, handle),
+			mimetype: &quot;text/json&quot;,
+			preventCache: true,
+			sync: kw.sync,
+			content: { data: dojo.json.serialize(kw.params) }
+		});
+	},
+
+
+
+	/**
+	 * Load children of the node from server
+	 * Synchroneous loading doesn't break control flow
+	 * I need sync mode for DnD
+	*/
+	loadRemote: function(node, sync, callObj, callFunc){
+		var _this = this;
+
+		var params = {
+			node: this.getInfo(node),
+			tree: this.getInfo(node.tree)
+		};
+
+		//dojo.debug(callFunc)
+
+		this.runRPC({
+			url: this.getRPCUrl('getChildren'),
+			load: function(result) {
+				_this.loadProcessResponse(node, result, callObj, callFunc) ;
+			},
+			sync: sync,
+			lock: [node],
+			params: params
+		});
+
+	},
+
+
+	expand: function(node, sync, callObj, callFunc) {
+
+		if (node.state == node.loadStates.UNCHECKED &amp;&amp; node.isFolder) {
+
+			this.loadRemote(node, sync,
+				this,
+				function(node, newChildren) {
+					this.expand(node, sync, callObj, callFunc);
+				}
+			);
+
+			return;
+		}
+
+		dojo.widget.TreeBasicController.prototype.expand.apply(this, arguments);
+
+	},
+
+
+
+	doMove: function(child, newParent, index) {
+		/* load nodes into newParent in sync mode, if needed, first */
+		if (newParent.isTreeNode &amp;&amp; newParent.state == newParent.loadStates.UNCHECKED) {
+			this.loadRemote(newParent, true);
+		}
+
+		return dojo.widget.TreeBasicController.prototype.doMove.apply(this, arguments);
+	},
+
+
+	doCreateChild: function(parent, index, data, callObj, callFunc) {
+
+		/* load nodes into newParent in sync mode, if needed, first */
+		if (parent.state == parent.loadStates.UNCHECKED) {
+			this.loadRemote(parent, true);
+		}
+
+		return dojo.widget.TreeBasicController.prototype.doCreateChild.apply(this, arguments);
+	}
+
+
+
+});

Added: trunk/root/static/magic/src/widget/TreeNode.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeNode.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeNode.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,534 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+
+dojo.provide(&quot;dojo.widget.TreeNode&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+
+// make it a tag
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeNode&quot;);
+
+
+// # //////////
+
+dojo.widget.TreeNode = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+	this.actionsDisabled = [];
+}
+
+dojo.inherits(dojo.widget.TreeNode, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.TreeNode, {
+	widgetType: &quot;TreeNode&quot;,
+
+	loadStates: {
+		UNCHECKED: &quot;UNCHECKED&quot;,
+    	LOADING: &quot;LOADING&quot;,
+    	LOADED: &quot;LOADED&quot;
+	},
+
+
+	actions: {
+		MOVE: &quot;MOVE&quot;,
+    	REMOVE: &quot;REMOVE&quot;,
+    	EDIT: &quot;EDIT&quot;,
+    	ADDCHILD: &quot;ADDCHILD&quot;
+	},
+
+	isContainer: true,
+
+	lockLevel: 0, // lock ++ unlock --, so nested locking works fine
+
+
+	templateString: ('&lt;div class=&quot;dojoTreeNode&quot;&gt; '
+		+ '&lt;span treeNode=&quot;${this.widgetId}&quot; class=&quot;dojoTreeNodeLabel&quot; dojoAttachPoint=&quot;labelNode&quot;&gt; '
+		+ '		&lt;span dojoAttachPoint=&quot;titleNode&quot; dojoAttachEvent=&quot;onClick: onTitleClick&quot; class=&quot;dojoTreeNodeLabelTitle&quot;&gt;${this.title}&lt;/span&gt; '
+		+ '&lt;/span&gt; '
+		+ '&lt;span class=&quot;dojoTreeNodeAfterLabel&quot; dojoAttachPoint=&quot;afterLabelNode&quot;&gt;${this.afterLabel}&lt;/span&gt; '
+		+ '&lt;div dojoAttachPoint=&quot;containerNode&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt; '
+		+ '&lt;/div&gt;').replace(/(&gt;|&lt;)\s+/g, '$1'), // strip whitespaces between nodes
+
+
+	childIconSrc: &quot;&quot;,
+	childIconFolderSrc: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/closed.gif&quot;), // for under root parent item child icon,
+	childIconDocumentSrc: dojo.uri.dojoUri(&quot;src/widget/templates/images/Tree/document.gif&quot;), // for under root parent item child icon,
+
+	childIcon: null,
+	isTreeNode: true,
+
+	objectId: &quot;&quot;, // the widget represents an object
+
+	afterLabel: &quot;&quot;,
+	afterLabelNode: null, // node to the left of labelNode
+
+	// an icon left from childIcon: imgs[-2].
+	// if +/- for folders, blank for leaves
+	expandIcon: null,
+
+	title: &quot;&quot;,
+	object: &quot;&quot;, // node may have object attached, settable from HTML
+	isFolder: false,
+
+	labelNode: null, // the item label
+	titleNode: null, // the item title
+	imgs: null, // an array of icons imgs
+
+	expandLevel: &quot;&quot;, // expand to level
+
+	tree: null,
+
+	depth: 0,
+
+	isExpanded: false,
+
+	state: null,  // after creation will change to loadStates: &quot;loaded/loading/unchecked&quot;
+	domNodeInitialized: false,  // domnode is initialized with icons etc
+
+
+	isFirstNode: function() {
+		return this.getParentIndex() == 0 ? true: false;
+	},
+
+	isLastNode: function() {
+		return this.getParentIndex() == this.parent.children.length-1 ? true : false;
+	},
+
+	lock: function(){ return this.tree.lock.apply(this, arguments) },
+	unlock: function(){ return this.tree.unlock.apply(this, arguments) },
+	isLocked: function(){ return this.tree.isLocked.apply(this, arguments) },
+	cleanLock: function(){ return this.tree.cleanLock.apply(this, arguments) },
+
+	actionIsDisabled: function(action) {
+		var _this = this;
+
+		var disabled = false;
+
+		if (this.tree.strictFolders &amp;&amp; action == this.actions.ADDCHILD &amp;&amp; !this.isFolder) {
+			disabled = true;
+		}
+
+		if (dojo.lang.inArray(_this.actionsDisabled, action)) {
+			disabled = true;
+		}
+
+		if (this.isLocked()) {
+			disabled = true;
+		}
+
+		return disabled;
+	},
+
+	getInfo: function() {
+		// No title here (title may be widget)
+		var info = {
+			widgetId: this.widgetId,
+			objectId: this.objectId,
+			index: this.getParentIndex(),
+			isFolder: this.isFolder
+		}
+
+		return info;
+	},
+
+	initialize: function(args, frag){
+
+		//dojo.debug(this.title)
+
+		this.state = this.loadStates.UNCHECKED;
+
+		for(var i=0; i&lt;this.actionsDisabled.length; i++) {
+			this.actionsDisabled[i] = this.actionsDisabled[i].toUpperCase();
+		}
+
+		this.expandLevel = parseInt(this.expandLevel);
+
+	},
+
+
+	/**
+	 * Change visible node depth by appending/prepending with blankImgs
+	 * @param depthDiff Integer positive =&gt; move right, negative =&gt; move left
+	*/
+	adjustDepth: function(depthDiff) {
+
+		for(var i=0; i&lt;this.children.length; i++) {
+			this.children[i].adjustDepth(depthDiff);
+		}
+
+		this.depth += depthDiff;
+
+		if (depthDiff&gt;0) {
+			for(var i=0; i&lt;depthDiff; i++) {
+				var img = this.tree.makeBlankImg();
+				this.imgs.unshift(img);
+				//dojo.debugShallow(this.domNode);
+				dojo.dom.insertBefore(this.imgs[0], this.domNode.firstChild);
+
+			}
+		}
+		if (depthDiff&lt;0) {
+			for(var i=0; i&lt;-depthDiff;i++) {
+				this.imgs.shift();
+				dojo.dom.removeNode(this.domNode.firstChild);
+			}
+		}
+
+	},
+
+
+	markLoading: function() {
+		this._markLoadingSavedIcon = this.expandIcon.src;
+		this.expandIcon.src = this.tree.expandIconSrcLoading;
+	},
+
+	// if icon is &quot;Loading&quot; then
+	unMarkLoading: function() {
+		if (!this._markLoadingSavedIcon) return;
+
+		var im = new Image();
+		im.src = this.tree.expandIconSrcLoading;
+
+		//dojo.debug(&quot;Unmark &quot;+this.expandIcon.src+&quot; : &quot;+im.src);
+		if (this.expandIcon.src == im.src) {
+			this.expandIcon.src = this._markLoadingSavedIcon;
+		}
+		this._markLoadingSavedIcon = null;
+	},
+
+
+	setFolder: function() {
+		dojo.event.connect(this.expandIcon, 'onclick', this, 'onTreeClick');
+		this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
+		this.isFolder = true;
+	},
+
+
+	createDOMNode: function(tree, depth){
+
+		this.tree = tree;
+		this.depth = depth;
+
+
+		//
+		// add the tree icons
+		//
+
+		this.imgs = [];
+
+		for(var i=0; i&lt;this.depth+1; i++){
+
+			var img = this.tree.makeBlankImg();
+
+			this.domNode.insertBefore(img, this.labelNode);
+
+			this.imgs.push(img);
+		}
+
+
+		this.expandIcon = this.imgs[this.imgs.length-1];
+
+
+		this.childIcon = this.tree.makeBlankImg();
+
+		// add to images before the title
+		this.imgs.push(this.childIcon);
+
+		dojo.dom.insertBefore(this.childIcon, this.titleNode);
+
+		// node with children(from source html) becomes folder on build stage.
+		if (this.children.length || this.isFolder) {
+			this.setFolder();
+		}
+		else {
+			// leaves are always loaded
+			//dojo.debug(&quot;Set &quot;+this+&quot; state to loaded&quot;);
+			this.state = this.loadStates.LOADED;
+		}
+
+		dojo.event.connect(this.childIcon, 'onclick', this, 'onIconClick');
+
+
+		//
+		// create the child rows
+		//
+
+
+		for(var i=0; i&lt;this.children.length; i++){
+			this.children[i].parent = this;
+
+			var node = this.children[i].createDOMNode(this.tree, this.depth+1);
+
+			this.containerNode.appendChild(node);
+		}
+
+
+		if (this.children.length) {
+			this.state = this.loadStates.LOADED;
+		}
+
+		this.updateIcons();
+
+		this.domNodeInitialized = true;
+
+		dojo.event.topic.publish(this.tree.eventNames.createDOMNode, { source: this } );
+
+		return this.domNode;
+	},
+
+	onTreeClick: function(e){
+		dojo.event.topic.publish(this.tree.eventNames.treeClick, { source: this, event: e });
+	},
+
+	onIconClick: function(e){
+		dojo.event.topic.publish(this.tree.eventNames.iconClick, { source: this, event: e });
+	},
+
+	onTitleClick: function(e){
+		dojo.event.topic.publish(this.tree.eventNames.titleClick, { source: this, event: e });
+	},
+
+	markSelected: function() {
+		dojo.html.addClass(this.titleNode, 'dojoTreeNodeLabelSelected');
+	},
+
+
+	unMarkSelected: function() {
+		//dojo.debug('unmark')
+		dojo.html.removeClass(this.titleNode, 'dojoTreeNodeLabelSelected');
+	},
+
+	updateExpandIcon: function() {
+		if (this.isFolder){
+			this.expandIcon.src = this.isExpanded ? this.tree.expandIconSrcMinus : this.tree.expandIconSrcPlus;
+		} else {
+			this.expandIcon.src = this.tree.blankIconSrc;
+		}
+	},
+
+	/* set the grid under the expand icon */
+	updateExpandGrid: function() {
+
+		if (this.tree.showGrid){
+			if (this.depth){
+				this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
+			}else{
+				if (this.isFirstNode()){
+					this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcX : this.tree.gridIconSrcY);
+				}else{
+					this.setGridImage(-2, this.isLastNode() ? this.tree.gridIconSrcL : this.tree.gridIconSrcT);
+				}
+			}
+		}else{
+			this.setGridImage(-2, this.tree.blankIconSrc);
+		}
+
+	},
+
+	/* set the grid under the child icon */
+	updateChildGrid: function() {
+
+		if ((this.depth || this.tree.showRootGrid) &amp;&amp; this.tree.showGrid){
+			this.setGridImage(-1, (this.children.length &amp;&amp; this.isExpanded) ? this.tree.gridIconSrcP : this.tree.gridIconSrcC);
+		}else{
+			if (this.tree.showGrid &amp;&amp; !this.tree.showRootGrid){
+				this.setGridImage(-1, (this.children.length &amp;&amp; this.isExpanded) ? this.tree.gridIconSrcZ : this.tree.blankIconSrc);
+			}else{
+				this.setGridImage(-1, this.tree.blankIconSrc);
+			}
+		}
+
+
+	},
+
+	updateParentGrid: function() {
+		var parent = this.parent;
+
+		//dojo.debug(&quot;updateParentGrid &quot;+this);
+
+		for(var i=0; i&lt;this.depth; i++){
+
+			//dojo.debug(&quot;Parent &quot;+parent);
+
+			var idx = this.imgs.length-(3+i);
+			var img = (this.tree.showGrid &amp;&amp; !parent.isLastNode()) ? this.tree.gridIconSrcV : this.tree.blankIconSrc;
+
+			//dojo.debug(&quot;Image &quot;+img+&quot; for &quot;+idx);
+
+			this.setGridImage(idx, img);
+
+			parent = parent.parent;
+		}
+	},
+
+	updateExpandGridColumn: function() {
+		if (!this.tree.showGrid) return;
+
+		var _this = this;
+
+		var icon = this.isLastNode() ? this.tree.blankIconSrc : this.tree.gridIconSrcV;
+
+		dojo.lang.forEach(_this.getDescendants(),
+			function(node) { node.setGridImage(_this.depth, icon); }
+		);
+
+		this.updateExpandGrid();
+	},
+
+	updateIcons: function(){
+
+
+		//dojo.profile.start(&quot;updateIcons&quot;)
+
+		//dojo.debug(&quot;Update icons for &quot;+this)
+		//dojo.debug(this.isFolder)
+
+		this.imgs[0].style.display = this.tree.showRootGrid ? 'inline' : 'none';
+
+
+		//
+		// set the expand icon
+		//
+
+
+		//
+		// set the child icon
+		//
+		this.buildChildIcon();
+
+		this.updateExpandGrid();
+		this.updateChildGrid();
+		this.updateParentGrid();
+
+
+
+		dojo.profile.stop(&quot;updateIcons&quot;)
+
+	},
+
+	buildChildIcon: function() {
+		// IE (others?) tries to download whatever is on src attribute so setting &quot;url()&quot; like before isnt a good idea
+		// Only results in a 404
+		if(this.childIconSrc){
+			this.childIcon.src = this.childIconSrc;
+		}
+		this.childIcon.style.display = this.childIconSrc ? 'inline' : 'none';
+	},
+
+	setGridImage: function(idx, src){
+
+		if (idx &lt; 0){
+			idx = this.imgs.length + idx;
+		}
+
+		//if (idx &gt;= this.imgs.length-2) return;
+		this.imgs[idx].style.backgroundImage = 'url(' + src + ')';
+	},
+
+
+	updateIconTree: function(){
+		this.tree.updateIconTree.call(this);
+	},
+
+
+
+
+	expand: function(){
+		if (this.isExpanded) return;
+
+		if (this.children.length) {
+			this.showChildren();
+		}
+
+		this.isExpanded = true;
+
+		this.updateExpandIcon();
+
+		dojo.event.topic.publish(this.tree.eventNames.expand, {source: this} );
+	},
+
+	collapse: function(){
+		if (!this.isExpanded) return;
+
+		this.hideChildren();
+		this.isExpanded = false;
+
+		this.updateExpandIcon();
+
+		dojo.event.topic.publish(this.tree.eventNames.collapse, {source: this} );
+	},
+
+	hideChildren: function(){
+		this.tree.toggleObj.hide(
+			this.containerNode, this.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, &quot;onHide&quot;)
+		);
+
+		/* if dnd is in action, recalculate changed coordinates */
+		if(dojo.exists(dojo, 'dnd.dragManager.dragObjects') &amp;&amp; dojo.dnd.dragManager.dragObjects.length) {
+			dojo.dnd.dragManager.cacheTargetLocations();
+		}
+	},
+
+	showChildren: function(){
+		this.tree.toggleObj.show(
+			this.containerNode, this.toggleDuration, this.explodeSrc, dojo.lang.hitch(this, &quot;onShow&quot;)
+		);
+
+		/* if dnd is in action, recalculate changed coordinates */
+		if(dojo.exists(dojo, 'dnd.dragManager.dragObjects') &amp;&amp; dojo.dnd.dragManager.dragObjects.length) {
+			dojo.dnd.dragManager.cacheTargetLocations();
+		}
+	},
+
+	addChild: function(){
+		return this.tree.addChild.apply(this, arguments);
+	},
+
+	doAddChild: function(){
+		return this.tree.doAddChild.apply(this, arguments);
+	},
+
+
+
+	/* Edit current node : change properties and update contents */
+	edit: function(props) {
+		dojo.lang.mixin(this, props);
+		if (props.title) {
+			this.titleNode.innerHTML = this.title;
+		}
+
+		if (props.afterLabel) {
+			this.afterLabelNode.innerHTML = this.afterLabel;
+		}
+
+		if (props.childIconSrc) {
+			this.buildChildIcon();
+		}
+
+
+	},
+
+
+	removeNode: function(){ return this.tree.removeNode.apply(this, arguments) },
+	doRemoveNode: function(){ return this.tree.doRemoveNode.apply(this, arguments) },
+
+
+	toString: function() {
+		return &quot;[&quot;+this.widgetType+&quot; Tree:&quot;+this.tree+&quot; ID:&quot;+this.widgetId+&quot; Title:&quot;+this.title+&quot;]&quot;;
+
+	}
+
+});
+
+
+
+

Added: trunk/root/static/magic/src/widget/TreeRPCController.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeRPCController.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeRPCController.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,171 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+
+dojo.provide(&quot;dojo.widget.TreeRPCController&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.json&quot;)
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.TreeLoadingController&quot;);
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeRPCController&quot;);
+
+dojo.widget.TreeRPCController = function(){
+	dojo.widget.TreeLoadingController.call(this);
+}
+
+dojo.inherits(dojo.widget.TreeRPCController, dojo.widget.TreeLoadingController);
+
+dojo.lang.extend(dojo.widget.TreeRPCController, {
+	widgetType: &quot;TreeRPCController&quot;,
+
+	/**
+	 * Make request to server about moving children.
+	 *
+	 * Request returns &quot;true&quot; if move succeeded,
+	 * object with error field if failed
+	 *
+	 * I can't leave DragObject floating until async request returns, need to return false/true
+	 * so making it sync way...
+	 *
+	 * Also, &quot;loading&quot; icon is not shown until function finishes execution, so no indication for remote request.
+	*/
+	doMove: function(child, newParent, index){
+
+		//if (newParent.isTreeNode) newParent.markLoading();
+
+		var params = {
+			// where from
+			child: this.getInfo(child),
+			childTree: this.getInfo(child.tree),
+			// where to
+			newParent: this.getInfo(newParent),
+			newParentTree: this.getInfo(newParent.tree),
+			newIndex: index
+		};
+
+		var success;
+
+		this.runRPC({		
+			url: this.getRPCUrl('move'),
+			/* I hitch to get this.loadOkHandler */
+			load: function(response){
+				success = this.doMoveProcessResponse(response, child, newParent, index) ;
+			},
+			sync: true,
+			lock: [child, newParent],
+			params: params
+		});
+
+
+		return success;
+	},
+
+	doMoveProcessResponse: function(response, child, newParent, index){
+
+		if(!dojo.lang.isUndefined(response.error)){
+			this.RPCErrorHandler(&quot;server&quot;, response.error);
+			return false;
+		}
+
+		var args = [child, newParent, index];
+		return dojo.widget.TreeLoadingController.prototype.doMove.apply(this, args);
+
+	},
+
+
+	doRemoveNode: function(node, callObj, callFunc){
+
+		var params = {
+			node: this.getInfo(node),
+			tree: this.getInfo(node.tree)
+		}
+
+		this.runRPC({
+				url: this.getRPCUrl('removeNode'),
+				/* I hitch to get this.loadOkHandler */
+				load: function(response){
+					this.doRemoveNodeProcessResponse(response, node, callObj, callFunc) 
+				},
+				params: params,
+				lock: [node]
+		});
+
+	},
+
+
+	doRemoveNodeProcessResponse: function(response, node, callObj, callFunc){
+		if(!dojo.lang.isUndefined(response.error)){
+			this.RPCErrorHandler(&quot;server&quot;, response.error);
+			return false;
+		}
+
+		if(!response){ return false; }
+
+		if(response == true){
+			/* change parent succeeded */
+			var args = [ node, callObj, callFunc ];
+			dojo.widget.TreeLoadingController.prototype.doRemoveNode.apply(this, args);
+
+			return;
+		}else if(dojo.lang.isObject(response)){
+			dojo.raise(response.error);
+		}else{
+			dojo.raise(&quot;Invalid response &quot;+response)
+		}
+
+
+	},
+
+
+
+	// -----------------------------------------------------------------------------
+	//                             Create node stuff
+	// -----------------------------------------------------------------------------
+
+
+	doCreateChild: function(parent, index, output, callObj, callFunc){
+
+			var params = {
+				tree: this.getInfo(parent.tree),
+				parent: this.getInfo(parent),
+				index: index,
+				data: output
+			}
+
+			this.runRPC({
+				url: this.getRPCUrl('createChild'),
+				load: function(response) {
+					// suggested data is dead, fresh data from server is used
+					this.doCreateChildProcessResponse( response, parent, index, callObj, callFunc) 
+				},
+				params: params,
+				lock: [parent]
+			});
+
+	},
+
+	doCreateChildProcessResponse: function(response, parent, index, callObj, callFunc){
+
+		if(!dojo.lang.isUndefined(response.error)){
+			this.RPCErrorHandler(&quot;server&quot;,response.error);
+			return false;
+		}
+
+		if(!dojo.lang.isObject(response)){
+			dojo.raise(&quot;Invalid result &quot;+response)
+		}
+
+		var args = [parent, index, response, callObj, callFunc];
+		
+		dojo.widget.TreeLoadingController.prototype.doCreateChild.apply(this, args);
+	}
+});

Added: trunk/root/static/magic/src/widget/TreeSelector.js
===================================================================
--- trunk/root/static/magic/src/widget/TreeSelector.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/TreeSelector.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,183 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+
+dojo.provide(&quot;dojo.widget.TreeSelector&quot;);
+
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TreeSelector&quot;);
+
+
+dojo.widget.TreeSelector = function() {
+	dojo.widget.HtmlWidget.call(this);
+
+
+	this.eventNames = {};
+
+	this.listenedTrees = [];
+
+}
+
+dojo.inherits(dojo.widget.TreeSelector, dojo.widget.HtmlWidget);
+
+
+dojo.lang.extend(dojo.widget.TreeSelector, {
+	widgetType: &quot;TreeSelector&quot;,
+	selectedNode: null,
+
+	dieWithTree: false,
+
+	eventNamesDefault: {
+		select : &quot;select&quot;,
+		destroy : &quot;destroy&quot;,
+		deselect : &quot;deselect&quot;,
+		dblselect: &quot;dblselect&quot; // select already selected node.. Edit or whatever
+	},
+
+	initialize: function() {
+
+		for(name in this.eventNamesDefault) {
+			if (dojo.lang.isUndefined(this.eventNames[name])) {
+				this.eventNames[name] = this.widgetId+&quot;/&quot;+this.eventNamesDefault[name];
+			}
+		}
+
+	},
+
+
+	destroy: function() {
+		dojo.event.topic.publish(this.eventNames.destroy, { source: this } );
+
+		return dojo.widget.HtmlWidget.prototype.destroy.apply(this, arguments);
+	},
+
+
+	listenTree: function(tree) {
+		dojo.event.topic.subscribe(tree.eventNames.titleClick, this, &quot;select&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.iconClick, this, &quot;select&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.collapse, this, &quot;onCollapse&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.moveFrom, this, &quot;onMoveFrom&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.removeNode, this, &quot;onRemoveNode&quot;);
+		dojo.event.topic.subscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+
+		/* remember all my trees to deselect when element is movedFrom them */
+		this.listenedTrees.push(tree);
+	},
+
+
+	unlistenTree: function(tree) {
+
+		dojo.event.topic.unsubscribe(tree.eventNames.titleClick, this, &quot;select&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.iconClick, this, &quot;select&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.collapse, this, &quot;onCollapse&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.moveFrom, this, &quot;onMoveFrom&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.removeNode, this, &quot;onRemoveNode&quot;);
+		dojo.event.topic.unsubscribe(tree.eventNames.treeDestroy, this, &quot;onTreeDestroy&quot;);
+
+
+		for(var i=0; i&lt;this.listenedTrees.length; i++){
+           if(this.listenedTrees[i] === tree){
+                   this.listenedTrees.splice(i, 1);
+                   break;
+           }
+		}
+	},
+
+
+	onTreeDestroy: function(message) {
+
+		this.unlistenTree(message.source);
+
+		if (this.dieWithTree) {
+			//dojo.debug(&quot;Killing myself &quot;+this.widgetId);
+			this.destroy();
+			//dojo.debug(&quot;done&quot;);
+		}
+	},
+
+
+	// deselect node if parent is collapsed
+	onCollapse: function(message) {
+		if (!this.selectedNode) return;
+
+		var node = message.source;
+		var parent = this.selectedNode.parent;
+		while (parent !== node &amp;&amp; parent.isTreeNode) {
+			parent = parent.parent;
+		}
+		if (parent.isTreeNode) {
+			this.deselect();
+		}
+	},
+
+
+
+	select: function(message) {
+		var node = message.source;
+		var e = message.event;
+
+		if (this.selectedNode === node) {
+			dojo.event.topic.publish(this.eventNames.dblselect, { node: node });
+			return;
+		}
+
+		if (this.selectedNode) {
+			this.deselect();
+		}
+
+		this.doSelect(node);
+
+		dojo.event.topic.publish(this.eventNames.select, {node: node} );
+	},
+
+	/**
+	 * Deselect node if target tree is out of our concern
+	 */
+	onMoveFrom: function(message) {
+		if (message.child !== this.selectedNode) {
+			return;
+		}
+
+		if (!dojo.lang.inArray(this.listenedTrees, message.newTree)) {
+			this.deselect();
+		}
+	},
+
+	onRemoveNode: function(message) {
+		if (message.child !== this.selectedNode) {
+			return;
+		}
+
+		this.deselect();
+	},
+
+	doSelect: function(node){
+
+		node.markSelected();
+
+		this.selectedNode = node;
+	},
+
+	deselect: function(){
+
+		var node = this.selectedNode;
+
+		this.selectedNode = null;
+		node.unMarkSelected();
+		dojo.event.topic.publish(this.eventNames.deselect, {node: node} );
+
+	}
+
+});
+
+
+

Added: trunk/root/static/magic/src/widget/Widget.js
===================================================================
--- trunk/root/static/magic/src/widget/Widget.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Widget.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,576 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Widget&quot;);
+dojo.provide(&quot;dojo.widget.tags&quot;);
+
+dojo.require(&quot;dojo.lang.func&quot;);
+dojo.require(&quot;dojo.lang.array&quot;);
+dojo.require(&quot;dojo.lang.extras&quot;);
+dojo.require(&quot;dojo.lang.declare&quot;);
+dojo.require(&quot;dojo.widget.Manager&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+
+dojo.declare(&quot;dojo.widget.Widget&quot;, null, {
+	initializer: function() {								 
+		// these properties aren't primitives and need to be created on a per-item
+		// basis.
+		this.children = [];
+		// this.selection = new dojo.widget.Selection();
+		// FIXME: need to replace this with context menu stuff
+		this.extraArgs = {};
+	},
+	// FIXME: need to be able to disambiguate what our rendering context is
+	//        here!
+	//
+	// needs to be a string with the end classname. Every subclass MUST
+	// over-ride.
+	//
+	// base widget properties
+	parent: null,
+	// obviously, top-level and modal widgets should set these appropriately
+	isTopLevel:  false,
+	isModal: false,
+
+	isEnabled: true,
+	isHidden: false,
+	isContainer: false, // can we contain other widgets?
+	widgetId: &quot;&quot;,
+	widgetType: &quot;Widget&quot;, // used for building generic widgets
+
+	toString: function() {
+		return '[Widget ' + this.widgetType + ', ' + (this.widgetId || 'NO ID') + ']';
+	},
+
+	repr: function(){
+		return this.toString();
+	},
+
+	enable: function(){
+		// should be over-ridden
+		this.isEnabled = true;
+	},
+
+	disable: function(){
+		// should be over-ridden
+		this.isEnabled = false;
+	},
+
+	hide: function(){
+		// should be over-ridden
+		this.isHidden = true;
+	},
+
+	show: function(){
+		// should be over-ridden
+		this.isHidden = false;
+	},
+
+	onResized: function(){
+		// Clients should override this function to do special processing,
+		// then call this.notifyChildrenOfResize() to notify children of resize
+		this.notifyChildrenOfResize();
+	},
+	
+	notifyChildrenOfResize: function(){
+		for(var i=0; i&lt;this.children.length; i++){
+			var child = this.children[i];
+			//dojo.debug(this.widgetId + &quot; resizing child &quot; + child.widgetId);
+			if( child.onResized ){
+				child.onResized();
+			}
+		}
+	},
+
+	create: function(args, fragment, parentComp){
+		// dojo.debug(this.widgetType, &quot;create&quot;);
+		this.satisfyPropertySets(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;-&gt; mixInProperties&quot;);
+		this.mixInProperties(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;-&gt; postMixInProperties&quot;);
+		this.postMixInProperties(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;-&gt; dojo.widget.manager.add&quot;);
+		dojo.widget.manager.add(this);
+		// dojo.debug(this.widgetType, &quot;-&gt; buildRendering&quot;);
+		this.buildRendering(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;-&gt; initialize&quot;);
+		this.initialize(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;-&gt; postInitialize&quot;);
+		this.postInitialize(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;-&gt; postCreate&quot;);
+		this.postCreate(args, fragment, parentComp);
+		// dojo.debug(this.widgetType, &quot;done!&quot;);
+		return this;
+	},
+
+	// Destroy this widget and it's descendants
+	destroy: function(finalize){
+		// FIXME: this is woefully incomplete
+		this.destroyChildren();
+		this.uninitialize();
+		this.destroyRendering(finalize);
+		dojo.widget.manager.removeById(this.widgetId);
+	},
+
+	// Destroy the children of this widget, and their descendents
+	destroyChildren: function(){
+		while(this.children.length &gt; 0){
+			var tc = this.children[0];
+			this.removeChild(tc);
+			tc.destroy();
+		}
+	},
+
+	getChildrenOfType: function(type, recurse){
+		var ret = [];
+		var isFunc = dojo.lang.isFunction(type);
+		if(!isFunc){
+			type = type.toLowerCase();
+		}
+		for(var x=0; x&lt;this.children.length; x++){
+			if(isFunc){
+				if(this.children[x] instanceof type){
+					ret.push(this.children[x]);
+				}
+			}else{
+				if(this.children[x].widgetType.toLowerCase() == type){
+					ret.push(this.children[x]);
+				}
+			}
+			if(recurse){
+				ret = ret.concat(this.children[x].getChildrenOfType(type, recurse));
+			}
+		}
+		return ret;
+	},
+
+	getDescendants: function(){
+		var result = [];
+		var stack = [this];
+		var elem;
+		while (elem = stack.pop()){
+			result.push(elem);
+			dojo.lang.forEach(elem.children, function(elem) { stack.push(elem); });
+		}
+		return result;
+	},
+
+	satisfyPropertySets: function(args){
+		// dojo.profile.start(&quot;satisfyPropertySets&quot;);
+		// get the default propsets for our component type
+		/*
+		var typePropSets = []; // FIXME: need to pull these from somewhere!
+		var localPropSets = []; // pull out propsets from the parser's return structure
+
+		// for(var x=0; x&lt;args.length; x++){
+		// }
+
+		for(var x=0; x&lt;typePropSets.length; x++){
+		}
+
+		for(var x=0; x&lt;localPropSets.length; x++){
+		}
+		*/
+		// dojo.profile.end(&quot;satisfyPropertySets&quot;);
+		
+		return args;
+	},
+
+	mixInProperties: function(args, frag){
+		if((args[&quot;fastMixIn&quot;])||(frag[&quot;fastMixIn&quot;])){
+			// dojo.profile.start(&quot;mixInProperties_fastMixIn&quot;);
+			// fast mix in assumes case sensitivity, no type casting, etc...
+			// dojo.lang.mixin(this, args);
+			for(var x in args){
+				this[x] = args[x];
+			}
+			// dojo.profile.end(&quot;mixInProperties_fastMixIn&quot;);
+			return;
+		}
+		// dojo.profile.start(&quot;mixInProperties&quot;);
+		/*
+		 * the actual mix-in code attempts to do some type-assignment based on
+		 * PRE-EXISTING properties of the &quot;this&quot; object. When a named property
+		 * of a propset is located, it is first tested to make sure that the
+		 * current object already &quot;has one&quot;. Properties which are undefined in
+		 * the base widget are NOT settable here. The next step is to try to
+		 * determine type of the pre-existing property. If it's a string, the
+		 * property value is simply assigned. If a function, the property is
+		 * replaced with a &quot;new Function()&quot; declaration. If an Array, the
+		 * system attempts to split the string value on &quot;;&quot; chars, and no
+		 * further processing is attempted (conversion of array elements to a
+		 * integers, for instance). If the property value is an Object
+		 * (testObj.constructor === Object), the property is split first on &quot;;&quot;
+		 * chars, secondly on &quot;:&quot; chars, and the resulting key/value pairs are
+		 * assigned to an object in a map style. The onus is on the property
+		 * user to ensure that all property values are converted to the
+		 * expected type before usage.
+		 */
+
+		var undef;
+
+		// NOTE: we cannot assume that the passed properties are case-correct
+		// (esp due to some browser bugs). Therefore, we attempt to locate
+		// properties for assignment regardless of case. This may cause
+		// problematic assignments and bugs in the future and will need to be
+		// documented with big bright neon lights.
+
+		// FIXME: fails miserably if a mixin property has a default value of null in 
+		// a widget
+
+		// NOTE: caching lower-cased args in the prototype is only 
+		// acceptable if the properties are invariant.
+		// if we have a name-cache, get it
+		var lcArgs = dojo.widget.lcArgsCache[this.widgetType];
+		if ( lcArgs == null ){
+			// build a lower-case property name cache if we don't have one
+			lcArgs = {};
+			for(var y in this){
+				lcArgs[((new String(y)).toLowerCase())] = y;
+			}
+			dojo.widget.lcArgsCache[this.widgetType] = lcArgs;
+		}
+		var visited = {};
+		for(var x in args){
+			if(!this[x]){ // check the cache for properties
+				var y = lcArgs[(new String(x)).toLowerCase()];
+				if(y){
+					args[y] = args[x];
+					x = y; 
+				}
+			}
+			if(visited[x]){ continue; }
+			visited[x] = true;
+			if((typeof this[x]) != (typeof undef)){
+				if(typeof args[x] != &quot;string&quot;){
+					this[x] = args[x];
+				}else{
+					if(dojo.lang.isString(this[x])){
+						this[x] = args[x];
+					}else if(dojo.lang.isNumber(this[x])){
+						this[x] = new Number(args[x]); // FIXME: what if NaN is the result?
+					}else if(dojo.lang.isBoolean(this[x])){
+						this[x] = (args[x].toLowerCase()==&quot;false&quot;) ? false : true;
+					}else if(dojo.lang.isFunction(this[x])){
+
+						// FIXME: need to determine if always over-writing instead
+						// of attaching here is appropriate. I suspect that we
+						// might want to only allow attaching w/ action items.
+						
+						// RAR, 1/19/05: I'm going to attach instead of
+						// over-write here. Perhaps function objects could have
+						// some sort of flag set on them? Or mixed-into objects
+						// could have some list of non-mutable properties
+						// (although I'm not sure how that would alleviate this
+						// particular problem)? 
+
+						// this[x] = new Function(args[x]);
+
+						// after an IRC discussion last week, it was decided
+						// that these event handlers should execute in the
+						// context of the widget, so that the &quot;this&quot; pointer
+						// takes correctly.
+						
+						// argument that contains no punctuation other than . is 
+						// considered a function spec, not code
+						if(args[x].search(/[^\w\.]+/i) == -1){
+							this[x] = dojo.evalObjPath(args[x], false);
+						}else{
+							var tn = dojo.lang.nameAnonFunc(new Function(args[x]), this);
+							dojo.event.connect(this, x, this, tn);
+						}
+					}else if(dojo.lang.isArray(this[x])){ // typeof [] == &quot;object&quot;
+						this[x] = args[x].split(&quot;;&quot;);
+					} else if (this[x] instanceof Date) {
+						this[x] = new Date(Number(args[x])); // assume timestamp
+					}else if(typeof this[x] == &quot;object&quot;){ 
+						// FIXME: should we be allowing extension here to handle
+						// other object types intelligently?
+
+						// if we defined a URI, we probablt want to allow plain strings
+						// to override it
+						if (this[x] instanceof dojo.uri.Uri){
+
+							this[x] = args[x];
+						}else{
+
+							// FIXME: unlike all other types, we do not replace the
+							// object with a new one here. Should we change that?
+							var pairs = args[x].split(&quot;;&quot;);
+							for(var y=0; y&lt;pairs.length; y++){
+								var si = pairs[y].indexOf(&quot;:&quot;);
+								if((si != -1)&amp;&amp;(pairs[y].length&gt;si)){
+									this[x][pairs[y].substr(0, si).replace(/^\s+|\s+$/g, &quot;&quot;)] = pairs[y].substr(si+1);
+								}
+							}
+						}
+					}else{
+						// the default is straight-up string assignment. When would
+						// we ever hit this?
+						this[x] = args[x];
+					}
+				}
+			}else{
+				// collect any extra 'non mixed in' args
+				this.extraArgs[x.toLowerCase()] = args[x];
+			}
+		}
+		// dojo.profile.end(&quot;mixInProperties&quot;);
+	},
+	
+	postMixInProperties: function(){
+	},
+
+	initialize: function(args, frag){
+		// dojo.unimplemented(&quot;dojo.widget.Widget.initialize&quot;);
+		return false;
+	},
+
+	postInitialize: function(args, frag){
+		return false;
+	},
+
+	postCreate: function(args, frag){
+		return false;
+	},
+
+	uninitialize: function(){
+		// dojo.unimplemented(&quot;dojo.widget.Widget.uninitialize&quot;);
+		return false;
+	},
+
+	buildRendering: function(){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented(&quot;dojo.widget.Widget.buildRendering, on &quot;+this.toString()+&quot;, &quot;);
+		return false;
+	},
+
+	destroyRendering: function(){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented(&quot;dojo.widget.Widget.destroyRendering&quot;);
+		return false;
+	},
+
+	cleanUp: function(){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented(&quot;dojo.widget.Widget.cleanUp&quot;);
+		return false;
+	},
+
+	addedTo: function(parent){
+		// this is just a signal that can be caught
+	},
+
+	addChild: function(child){
+		// SUBCLASSES MUST IMPLEMENT
+		dojo.unimplemented(&quot;dojo.widget.Widget.addChild&quot;);
+		return false;
+	},
+
+	// Detach the given child widget from me, but don't destroy it
+	removeChild: function(widget){
+		for(var x=0; x&lt;this.children.length; x++){
+			if(this.children[x] === widget){
+				this.children.splice(x, 1);
+				break;
+			}
+		}
+		return widget;
+	},
+
+	resize: function(width, height){
+		// both width and height may be set as percentages. The setWidth and
+		// setHeight  functions attempt to determine if the passed param is
+		// specified in percentage or native units. Integers without a
+		// measurement are assumed to be in the native unit of measure.
+		this.setWidth(width);
+		this.setHeight(height);
+	},
+
+	setWidth: function(width){
+		if((typeof width == &quot;string&quot;)&amp;&amp;(width.substr(-1) == &quot;%&quot;)){
+			this.setPercentageWidth(width);
+		}else{
+			this.setNativeWidth(width);
+		}
+	},
+
+	setHeight: function(height){
+		if((typeof height == &quot;string&quot;)&amp;&amp;(height.substr(-1) == &quot;%&quot;)){
+			this.setPercentageHeight(height);
+		}else{
+			this.setNativeHeight(height);
+		}
+	},
+
+	setPercentageHeight: function(height){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	setNativeHeight: function(height){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	setPercentageWidth: function(width){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	setNativeWidth: function(width){
+		// SUBCLASSES MUST IMPLEMENT
+		return false;
+	},
+
+	getPreviousSibling: function() {
+		var idx = this.getParentIndex();
+ 
+		 // first node is idx=0 not found is idx&lt;0
+		if (idx&lt;=0) return null;
+ 
+		return this.getSiblings()[idx-1];
+	},
+ 
+	getSiblings: function() {
+		return this.parent.children;
+	},
+ 
+	getParentIndex: function() {
+		return dojo.lang.indexOf( this.getSiblings(), this, true);
+	},
+ 
+	getNextSibling: function() {
+ 
+		var idx = this.getParentIndex();
+ 
+		if (idx == this.getSiblings().length-1) return null; // last node
+		if (idx &lt; 0) return null; // not found
+ 
+		return this.getSiblings()[idx+1];
+ 
+	}
+});
+
+// Lower case name cache: listing of the lower case elements in each widget.
+// We can't store the lcArgs in the widget itself because if B subclasses A,
+// then B.prototype.lcArgs might return A.prototype.lcArgs, which is not what we
+// want
+dojo.widget.lcArgsCache = {};
+
+// TODO: should have a more general way to add tags or tag libraries?
+// TODO: need a default tags class to inherit from for things like getting propertySets
+// TODO: parse properties/propertySets into component attributes
+// TODO: parse subcomponents
+// TODO: copy/clone raw markup fragments/nodes as appropriate
+dojo.widget.tags = {};
+dojo.widget.tags.addParseTreeHandler = function(type){
+	var ltype = type.toLowerCase();
+	this[ltype] = function(fragment, widgetParser, parentComp, insertionIndex, localProps){ 
+		return dojo.widget.buildWidgetFromParseTree(ltype, fragment, widgetParser, parentComp, insertionIndex, localProps);
+	}
+}
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:widget&quot;);
+
+dojo.widget.tags[&quot;dojo:propertyset&quot;] = function(fragment, widgetParser, parentComp){
+	// FIXME: Is this needed?
+	// FIXME: Not sure that this parses into the structure that I want it to parse into...
+	// FIXME: add support for nested propertySets
+	var properties = widgetParser.parseProperties(fragment[&quot;dojo:propertyset&quot;]);
+}
+
+// FIXME: need to add the &lt;dojo:connect /&gt;
+dojo.widget.tags[&quot;dojo:connect&quot;] = function(fragment, widgetParser, parentComp){
+	var properties = widgetParser.parseProperties(fragment[&quot;dojo:connect&quot;]);
+}
+
+// FIXME: if we know the insertion point (to a reasonable location), why then do we:
+//	- create a template node
+//	- clone the template node
+//	- render the clone and set properties
+//	- remove the clone from the render tree
+//	- place the clone
+// this is quite dumb
+dojo.widget.buildWidgetFromParseTree = function(type, frag, 
+												parser, parentComp, 
+												insertionIndex, localProps){
+	var stype = type.split(&quot;:&quot;);
+	stype = (stype.length == 2) ? stype[1] : type;
+	// FIXME: we don't seem to be doing anything with this!
+	// var propertySets = parser.getPropertySets(frag);
+	var localProperties = localProps || parser.parseProperties(frag[&quot;dojo:&quot;+stype]);
+	// var tic = new Date();
+	var twidget = dojo.widget.manager.getImplementation(stype);
+	if(!twidget){
+		throw new Error(&quot;cannot find \&quot;&quot; + stype + &quot;\&quot; widget&quot;);
+	}else if (!twidget.create){
+		throw new Error(&quot;\&quot;&quot; + stype + &quot;\&quot; widget object does not appear to implement *Widget&quot;);
+	}
+	localProperties[&quot;dojoinsertionindex&quot;] = insertionIndex;
+	// FIXME: we loose no less than 5ms in construction!
+	var ret = twidget.create(localProperties, frag, parentComp);
+	// dojo.debug(new Date() - tic);
+	return ret;
+}
+
+/*
+ * Create a widget constructor function (aka widgetClass)
+ */
+dojo.widget.defineWidget = function(widgetClass /*string*/, renderer /*string*/, superclasses /*function||array*/, init /*function*/, props /*object*/){
+	// This meta-function does parameter juggling for backward compat and overloading
+	// if 4th argument is a string, we are using the old syntax
+	// old sig: widgetClass, superclasses, props (object), renderer (string), init (function)
+	if(dojo.lang.isString(arguments[3])){
+		dojo.widget._defineWidget(arguments[0], arguments[3], arguments[1], arguments[4], arguments[2]);
+	}else{
+		// widgetClass
+		var args = [ arguments[0] ], p = 3;
+		if(dojo.lang.isString(arguments[1])){
+			// renderer, superclass
+			args.push(arguments[1], arguments[2]);
+		}else{
+			// superclass
+			args.push('', arguments[1]);
+			p = 2;
+		}
+		if(dojo.lang.isFunction(arguments[p])){
+			// init (function), props (object) 
+			args.push(arguments[p], arguments[p+1]);
+		}else{
+			// props (object) 
+			args.push(null, arguments[p]);
+		}
+		dojo.widget._defineWidget.apply(this, args);
+	}
+}
+
+dojo.widget.defineWidget.renderers = &quot;html|svg|vml&quot;;
+
+dojo.widget._defineWidget = function(widgetClass /*string*/, renderer /*string*/, superclasses /*function||array*/, init /*function*/, props /*object*/){
+	// FIXME: uncomment next line to test parameter juggling ... remove when confidence improves
+	//dojo.debug('(c:)' + widgetClass + '\n\n(r:)' + renderer + '\n\n(i:)' + init + '\n\n(p:)' + props);
+	// widgetClass takes the form foo.bar.baz&lt;.renderer&gt;.WidgetName (e.g. foo.bar.baz.WidgetName or foo.bar.baz.html.WidgetName)
+	var namespace = widgetClass.split(&quot;.&quot;);
+	var type = namespace.pop(); // type &lt;= WidgetName, namespace &lt;= foo.bar.baz&lt;.renderer&gt;
+	var regx = &quot;\\.(&quot; + (renderer ? renderer + '|' : '') + dojo.widget.defineWidget.renderers + &quot;)\\.&quot;;
+	var r = widgetClass.search(new RegExp(regx));
+	namespace = (r &lt; 0 ? namespace.join(&quot;.&quot;) : widgetClass.substr(0, r));
+
+	dojo.widget.manager.registerWidgetPackage(namespace);
+	dojo.widget.tags.addParseTreeHandler(&quot;dojo:&quot;+type.toLowerCase());
+
+	props=(props)||{};
+	props.widgetType = type;
+	if((!init)&amp;&amp;(props[&quot;classConstructor&quot;])){
+		init = props.classConstructor;
+		delete props.classConstructor;
+	}
+	dojo.declare(widgetClass, superclasses, init, props);
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/Wizard.js
===================================================================
--- trunk/root/static/magic/src/widget/Wizard.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/Wizard.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,210 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.Wizard&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.LayoutContainer&quot;);
+dojo.require(&quot;dojo.widget.ContentPane&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+//////////////////////////////////////////
+// WizardContainer -- a set of panels
+//////////////////////////////////////////
+dojo.widget.WizardContainer = function() {
+	dojo.widget.html.LayoutContainer.call(this);
+}
+dojo.inherits(dojo.widget.WizardContainer, dojo.widget.html.LayoutContainer);
+
+dojo.lang.extend(dojo.widget.WizardContainer, {
+
+	widgetType: &quot;WizardContainer&quot;,
+
+	labelPosition: &quot;top&quot;,
+
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/Wizard.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/Wizard.css&quot;),
+
+	selected: null,		// currently selected panel
+	wizardNode: null, // the outer wizard node
+	wizardPanelContainerNode: null, // the container for the panels
+	wizardControlContainerNode: null, // the container for the wizard controls
+	previousButton: null, // the previous button
+	nextButton: null, // the next button
+	cancelButton: null, // the cancel button
+	doneButton: null, // the done button
+	nextButtonLabel: &quot;next&quot;,
+	previousButtonLabel: &quot;previous&quot;,
+	cancelButtonLabel: &quot;cancel&quot;,
+	doneButtonLabel: &quot;done&quot;,
+	cancelFunction : &quot;&quot;,
+
+	hideDisabledButtons: false,
+
+	fillInTemplate: function(args, frag){
+		dojo.event.connect(this.nextButton, &quot;onclick&quot;, this, &quot;nextPanel&quot;);
+		dojo.event.connect(this.previousButton, &quot;onclick&quot;, this, &quot;previousPanel&quot;);
+		if (this.cancelFunction){
+			dojo.event.connect(this.cancelButton, &quot;onclick&quot;, this.cancelFunction);
+		}else{
+			this.cancelButton.style.display = &quot;none&quot;;
+		}
+		dojo.event.connect(this.doneButton, &quot;onclick&quot;, this, &quot;done&quot;);
+		this.nextButton.value = this.nextButtonLabel;
+		this.previousButton.value = this.previousButtonLabel;
+		this.cancelButton.value = this.cancelButtonLabel;
+		this.doneButton.value = this.doneButtonLabel;
+	},
+
+	checkButtons: function(){
+		var lastStep = !this.hasNextPanel();
+		this.nextButton.disabled = lastStep;
+		this.setButtonClass(this.nextButton);
+		if(this.selected.doneFunction){
+			this.doneButton.style.display = &quot;&quot;;
+			// hide the next button if this is the last one and we have a done function
+			if(lastStep){
+				this.nextButton.style.display = &quot;none&quot;;
+			}
+		}else{
+			this.doneButton.style.display = &quot;none&quot;;
+		}
+		this.previousButton.disabled = ((!this.hasPreviousPanel()) || (!this.selected.canGoBack));
+		this.setButtonClass(this.previousButton);
+	},
+
+	setButtonClass: function(button){
+		if(!this.hideDisabledButtons){
+			button.style.display = &quot;&quot;;
+			dojo.html.setClass(button, button.disabled ? &quot;WizardButtonDisabled&quot; : &quot;WizardButton&quot;);
+		}else{
+			button.style.display = button.disabled ? &quot;none&quot; : &quot;&quot;;
+		}
+	},
+
+	registerChild: function(panel, insertionIndex){
+		dojo.widget.WizardContainer.superclass.registerChild.call(this, panel, insertionIndex);
+		this.wizardPanelContainerNode.appendChild(panel.domNode);
+		panel.hide();
+
+		if(!this.selected){
+			this.onSelected(panel);
+		}
+		this.checkButtons();
+	},
+
+	onSelected: function(panel){
+		// Deselect old panel and select new one
+		if(this.selected ){
+			if (this.selected.checkPass()) {
+				this.selected.hide();
+			} else {
+				return;
+			}
+		}
+		panel.show();
+		this.selected = panel;
+	},
+
+	getPanels: function() {
+		return this.getChildrenOfType(&quot;WizardPane&quot;, false);
+	},
+
+	selectedIndex: function() {
+		if (this.selected) {
+			return dojo.lang.indexOf(this.getPanels(), this.selected);
+		}
+		return -1;
+	},
+
+	nextPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		if ( selectedIndex &gt; -1 ) {
+			var childPanels = this.getPanels();
+			if (childPanels[selectedIndex + 1]) {
+				this.onSelected(childPanels[selectedIndex + 1]);
+			}
+		}
+		this.checkButtons();
+	},
+
+	previousPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		if ( selectedIndex &gt; -1 ) {
+			var childPanels = this.getPanels();
+			if (childPanels[selectedIndex - 1]) {
+				this.onSelected(childPanels[selectedIndex - 1]);
+			}
+		}
+		this.checkButtons();
+	},
+
+	hasNextPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		return (selectedIndex &lt; (this.getPanels().length - 1));
+	},
+
+	hasPreviousPanel: function() {
+		var selectedIndex = this.selectedIndex();
+		return (selectedIndex &gt; 0);
+	},
+
+	done: function() {
+		this.selected.done();
+	}
+});
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:WizardContainer&quot;);
+
+//////////////////////////////////////////
+// WizardPane -- a panel in a wizard
+//////////////////////////////////////////
+dojo.widget.WizardPane = function() {
+	dojo.widget.html.ContentPane.call(this);
+}
+dojo.inherits(dojo.widget.WizardPane, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.WizardPane, {
+	widgetType: &quot;WizardPane&quot;,
+
+	canGoBack: true,
+
+	passFunction: &quot;&quot;,
+	doneFunction: &quot;&quot;,
+
+	fillInTemplate: function(args, frag) {
+		if (this.passFunction) {
+			this.passFunction = dj_global[this.passFunction];
+		}
+		if (this.doneFunction) {
+			this.doneFunction = dj_global[this.doneFunction];
+		}
+	},
+
+	checkPass: function() {
+		if (this.passFunction &amp;&amp; dojo.lang.isFunction(this.passFunction)) {
+			var failMessage = this.passFunction();
+			if (failMessage) {
+				alert(failMessage);
+				return false;
+			}
+		}
+		return true;
+	},
+
+	done: function() {
+		if (this.doneFunction &amp;&amp; dojo.lang.isFunction(this.doneFunction)) {
+			this.doneFunction();
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:WizardPane&quot;);

Added: trunk/root/static/magic/src/widget/YahooMap.js
===================================================================
--- trunk/root/static/magic/src/widget/YahooMap.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/YahooMap.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,27 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.YahooMap&quot;);
+dojo.provide(&quot;dojo.widget.YahooMap.Controls&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.YahooMap&quot;,
+	dojo.widget.Widget,
+	{ isContainer: false }
+);
+
+dojo.widget.YahooMap.Controls={
+	MapType:&quot;maptype&quot;,
+	Pan:&quot;pan&quot;,
+	ZoomLong:&quot;zoomlong&quot;,
+	ZoomShort:&quot;zoomshort&quot;
+};
+dojo.requireAfterIf(&quot;html&quot;, &quot;dojo.widget.html.YahooMap&quot;);

Added: trunk/root/static/magic/src/widget/__package__.js
===================================================================
--- trunk/root/static/magic/src/widget/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,23 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	common: [&quot;dojo.xml.Parse&quot;, 
+			 &quot;dojo.widget.Widget&quot;, 
+			 &quot;dojo.widget.Parse&quot;, 
+			 &quot;dojo.widget.Manager&quot;],
+	browser: [&quot;dojo.widget.DomWidget&quot;,
+			  &quot;dojo.widget.HtmlWidget&quot;],
+	dashboard: [&quot;dojo.widget.DomWidget&quot;,
+			  &quot;dojo.widget.HtmlWidget&quot;],
+	svg: 	 [&quot;dojo.widget.SvgWidget&quot;],
+	rhino: 	 [&quot;dojo.widget.SwtWidget&quot;]
+});
+dojo.provide(&quot;dojo.widget.*&quot;);

Added: trunk/root/static/magic/src/widget/demoEngine/DemoContainer.js
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/DemoContainer.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/DemoContainer.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,107 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.demoEngine.DemoContainer&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.demoEngine.DemoPane&quot;);
+dojo.require(&quot;dojo.widget.demoEngine.SourcePane&quot;);
+dojo.require(&quot;dojo.widget.TabContainer&quot;);
+
+dojo.widget.defineWidget(&quot;my.widget.demoEngine.DemoContainer&quot;, 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoContainer.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoContainer.css&quot;),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.html.addClass(this.tabNode, this.tabClass);
+			dojo.html.addClass(this.returnImageNode, this.returnClass);
+			this.returnImageNode.src=this.returnImage;
+
+			this.tabContainer = dojo.widget.createWidget(&quot;TabContainer&quot;,{},this.tabNode);
+
+			this.demoTab = dojo.widget.createWidget(&quot;DemoPane&quot;,{});
+			this.tabContainer.addChild(this.demoTab);
+
+			this.sourceTab= dojo.widget.createWidget(&quot;SourcePane&quot;,{});
+			this.tabContainer.addChild(this.sourceTab);
+
+			dojo.html.setOpacity(this.domNode,0);
+			dojo.html.hide(this.domNode);
+		},
+
+		loadDemo: function(url) {
+			this.demoTab.setHref(url);
+			this.sourceTab.setHref(url);
+			this.showDemo();
+		},
+
+		setName: function(name) {
+			dojo.html.removeChildren(this.demoNameNode);
+			this.demoNameNode.appendChild(document.createTextNode(name));
+		},
+
+		setSummary: function(summary) {
+			dojo.html.removeChildren(this.summaryNode);
+			this.summaryNode.appendChild(document.createTextNode(summary));
+		},
+
+		showSource: function() {
+			dojo.html.removeClass(this.demoButtonNode,this.selectedButtonClass);
+			dojo.html.addClass(this.sourceButtonNode,this.selectedButtonClass);
+			this.tabContainer.selectTab(this.sourceTab);	
+		},
+
+		showDemo: function() {
+			dojo.html.removeClass(this.sourceButtonNode,this.selectedButtonClass);
+			dojo.html.addClass(this.demoButtonNode,this.selectedButtonClass);
+			this.tabContainer.selectTab(this.demoTab);
+		},
+
+		returnToDemos: function() {
+			dojo.debug(&quot;Return To Demos&quot;);
+		},
+
+		show: function() {
+			dojo.html.setOpacity(this.domNode,1);
+			dojo.html.show(this.domNode);
+			this.tabContainer.checkSize();
+		}
+	},
+	&quot;&quot;,
+	function() {
+		dojo.debug(&quot;DemoPane Init&quot;);
+		this.domNodeClass=&quot;demoContainer&quot;;
+
+		this.tabContainer=&quot;&quot;;
+		this.sourceTab=&quot;&quot;;
+		this.demoTab=&quot;&quot;;
+
+		this.headerNode=&quot;&quot;;
+		this.returnNode=&quot;&quot;;
+	
+		this.returnImageNode=&quot;&quot;;
+		this.returnImage=&quot;images/dojoDemos.gif&quot;;
+		this.returnClass=&quot;return&quot;;
+		
+		this.summaryNode=&quot;&quot;;
+		this.demoNameNode=&quot;&quot;;
+		this.tabControlNode=&quot;&quot;;
+
+		this.tabNode=&quot;&quot;;
+		this.tabClass = &quot;demoContainerTabs&quot;;
+
+		this.sourceButtonNode=&quot;&quot;;
+		this.demoButtonNode=&quot;&quot;;
+
+		this.selectedButtonClass=&quot;selected&quot;;
+	}
+);

Added: trunk/root/static/magic/src/widget/demoEngine/DemoItem.js
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/DemoItem.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/DemoItem.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,71 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.demoEngine.DemoItem&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+dojo.widget.defineWidget(&quot;my.widget.demoEngine.DemoItem&quot;, 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoItem.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoItem.css&quot;),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.html.addClass(this.summaryBoxNode, this.summaryBoxClass);
+			dojo.html.addClass(this.screenshotTdNode, this.screenshotTdClass);
+			dojo.html.addClass(this.summaryContainerNode, this.summaryContainerClass);
+			dojo.html.addClass(this.summaryNode, this.summaryClass);
+			dojo.html.addClass(this.viewDemoLinkNode, this.viewDemoLinkClass);
+
+			this.nameNode.appendChild(document.createTextNode(this.name));
+			this.descriptionNode.appendChild(document.createTextNode(this.description));
+			this.thumbnailImageNode.src = this.thumbnail;
+			this.thumbnailImageNode.name=this.name;
+			this.viewDemoImageNode.src = this.viewDemoImage;
+			this.viewDemoImageNode.name=this.name;
+		},
+		onSelectDemo: function() {
+			//Attach to this to do something when a demo is selected
+		}
+	},
+	&quot;&quot;,
+	function() {
+		this.demo = &quot;&quot;;
+
+		this.domNodeClass=&quot;demoItemWrapper&quot;;
+
+		this.summaryBoxNode=&quot;&quot;;
+		this.summaryBoxClass=&quot;demoItemSummaryBox&quot;;
+
+		this.nameNode=&quot;&quot;;
+		this.thumbnailImageNode=&quot;&quot;;
+		this.viewDemoImageNode=&quot;&quot;;
+
+		this.screenshotTdNode=&quot;&quot;;
+		this.screenshotTdClass=&quot;demoItemScreenshot&quot;;
+
+		this.summaryContainerNode=&quot;&quot;;
+		this.summaryContainerClass=&quot;demoItemSummaryContainer&quot;;
+
+		this.summaryNode=&quot;&quot;;
+		this.summaryClass=&quot;demoItemSummary&quot;;
+
+		this.viewDemoLinkNode=&quot;&quot;;
+		this.viewDemoLinkClass=&quot;demoItemView&quot;;
+
+		this.descriptionNode=&quot;&quot;;
+
+		this.name=&quot;Some Demo&quot;;
+		this.description=&quot;This is the description of this demo.&quot;;
+		this.thumbnail=&quot;images/test_thumb.gif&quot;;
+		this.viewDemoImage=&quot;images/viewDemo.png&quot;;
+	}
+);

Added: trunk/root/static/magic/src/widget/demoEngine/DemoNavigator.js
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/DemoNavigator.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/DemoNavigator.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,188 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.demoEngine.DemoNavigator&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.Button&quot;);
+dojo.require(&quot;dojo.widget.demoEngine.DemoItem&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+dojo.require(&quot;dojo.lang.Common&quot;);
+
+dojo.widget.defineWidget(&quot;my.widget.demoEngine.DemoNavigator&quot;, 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoNavigator.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoNavigator.css&quot;),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.html.addClass(this.demoListWrapperNode,this.demoListWrapperClass);
+			dojo.html.addClass(this.demoListContainerNode,this.demoListContainerClass);
+
+			if (dojo.render.html.ie) {
+				dojo.debug(&quot;render ie&quot;);
+				dojo.html.hide(this.demoListWrapperNode); 
+			} else {
+				dojo.debug(&quot;render non-ie&quot;);
+				dojo.lfx.html.fadeHide(this.demoListWrapperNode, 0).play();	
+			}
+
+			this.getRegistry(this.demoRegistryUrl);
+
+			this.demoContainer = dojo.widget.createWidget(&quot;DemoContainer&quot;,{returnImage: this.returnImage},this.demoNode);
+			dojo.event.connect(this.demoContainer,&quot;returnToDemos&quot;, this, &quot;returnToDemos&quot;);
+			this.demoContainer.hide();
+		},
+
+		returnToDemos: function() {
+			this.demoContainer.hide();
+			if (dojo.render.html.ie) {
+				dojo.debug(&quot;render ie&quot;);
+				dojo.html.show(this.navigationContainer) ;
+			} else {	
+				dojo.debug(&quot;render non-ie&quot;);
+				dojo.lfx.html.fadeShow(this.navigationContainer,250).play();
+			}
+
+			//if (dojo.render.html.ie) {
+			//	dojo.html.setOpacity(this.navigationContainer);
+			//}
+
+			dojo.lang.forEach(this.categoriesChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+
+			dojo.lang.forEach(this.demoListChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+		},
+
+		show: function() {
+			//dojo.widget.demoEngine.DemoNavigator.superclass.show.call(this);
+			dojo.html.show(this.domNode);
+			dojo.html.setOpacity(this.domNode,1);
+			//dojo.html.setOpacity(this.navigationContainer);	
+			//dojo.html.show(this.navigationContainer);
+			dojo.html.setOpacity(this.navigationContainer,1);
+
+			dojo.lang.forEach(this.categoriesChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+
+			dojo.lang.forEach(this.demoListChildren, dojo.lang.hitch(this, function(child){
+				child.checkSize();
+			}));
+		},
+		getRegistry: function(url) {
+			dojo.io.bind({
+				url: url,
+				load: dojo.lang.hitch(this,this.processRegistry),
+				mimetype: &quot;text/json&quot;
+			});
+		},
+
+		processRegistry: function(type,registry,e) {
+			dojo.debug(&quot;Processing Registry&quot;);
+			this.registry = registry;
+			dojo.lang.forEach(this.registry.navigation, dojo.lang.hitch(this,this.addCategory)); 
+		},
+
+		addCategory: function(category) {
+				var newCat = dojo.widget.createWidget(&quot;Button&quot;,{caption: category.name});
+
+				if(!dojo.lang.isObject(this.registry.categories)) {
+					this.registry.categories=function(){};
+				}
+
+				this.registry.categories[category.name] = category;
+				this.categoriesChildren.push(newCat);
+				this.categoriesButtonsNode.appendChild(newCat.domNode);	
+				newCat.domNode.categoryName = category.name;
+				dojo.event.connect(newCat,&quot;onClick&quot;, this, &quot;onSelectCategory&quot;);
+		},
+
+		addDemo: function(demoName) {
+			var demo = this.registry.definitions[demoName];
+
+			if (dojo.render.html.ie) {
+				dojo.html.show(this.demoListWrapperNode) 
+			} else {
+				dojo.lfx.html.fadeShow(this.demoListWrapperNode, 250).play();
+			}
+
+			var newDemo = dojo.widget.createWidget(&quot;DemoItem&quot;,{viewDemoImage: this.viewDemoImage, name: demoName, description: demo.description, thumbnail: demo.thumbnail});
+			this.demoListChildren.push(newDemo);
+			this.demoListContainerNode.appendChild(newDemo.domNode);	
+			dojo.event.connect(newDemo,&quot;onSelectDemo&quot;,this,&quot;onSelectDemo&quot;);
+		},
+
+		onSelectCategory: function(e) {
+			catName = e.currentTarget.categoryName;	
+			dojo.debug(&quot;Selected Category: &quot; + catName);
+			//Remove current list of demos
+			dojo.lang.forEach(this.demoListChildren, function(child) {
+					child.destroy();
+			});
+			this.demoListChildren=[];
+
+			//add demos from this cat
+			dojo.lang.forEach(this.registry.categories[catName].demos, dojo.lang.hitch(this,function(demoName){
+				this.addDemo(demoName);
+			}));
+		},
+
+		onSelectDemo: function(e) {
+			//Attach to this to do something when a demo is selected
+			dojo.debug(&quot;Demo Selected: &quot; + e.target.name);
+
+			if (dojo.render.html.ie) {
+				dojo.debug(&quot;render ie&quot;);
+				dojo.html.hide(this.navigationContainer) ;
+				this.demoContainer.show();
+				this.demoContainer.showDemo();
+			} else {
+				dojo.debug(&quot;render non-ie&quot;);
+				dojo.lfx.html.fadeHide(this.navigationContainer,250,null,dojo.lang.hitch(this, function() {
+					this.demoContainer.show();	
+					this.demoContainer.showDemo();
+				})).play();
+			}
+
+			this.demoContainer.loadDemo(this.registry.definitions[e.target.name].url);
+			this.demoContainer.setName(e.target.name);
+			this.demoContainer.setSummary(this.registry.definitions[e.target.name].description);
+		}
+		
+	},
+	&quot;&quot;,
+	function() {
+		this.demoRegistryUrl=&quot;demoRegistry.json&quot;;
+		this.registry=function(){};
+
+		this.categoriesNode=&quot;&quot;;
+		this.categoriesButtonsNode=&quot;&quot;;
+		this.navigationContainer=&quot;&quot;;
+
+		this.domNodeClass=&quot;demoNavigator&quot;;
+
+		this.demoNode=&quot;&quot;;
+		this.demoContainer=&quot;&quot;;
+
+		this.demoListWrapperNode=&quot;&quot;;
+		this.demoListWrapperClass=&quot;demoNavigatorListWrapper&quot;;
+		this.demoListContainerClass=&quot;demoNavigatorListContainer&quot;;
+
+		this.returnImage=&quot;images/dojoDemos.gif&quot;;
+		this.viewDemoImage=&quot;images/viewDemo.png&quot;;
+		this.demoListChildren = [];
+		this.categoriesChildren = [];
+	}
+);

Added: trunk/root/static/magic/src/widget/demoEngine/DemoPane.js
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/DemoPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/DemoPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,44 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.demoEngine.DemoPane&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+dojo.widget.defineWidget(&quot;my.widget.demoEngine.DemoPane&quot;, 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoPane.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/DemoPane.css&quot;),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.debug(&quot;PostCreate&quot;);
+			this._launchDemo();
+		},
+		
+		_launchDemo: function() {
+			dojo.debug(&quot;Launching Demo&quot;);
+			dojo.debug(this.demoNode);
+			this.demoNode.src=this.href;
+		},
+
+		setHref: function(url) {
+			this.href = url;
+			this._launchDemo();
+		}
+	},
+	&quot;&quot;,
+	function() {
+		dojo.debug(&quot;DemoPane Init&quot;);
+		this.domNodeClass=&quot;demoPane&quot;;
+		this.demoNode = &quot;&quot;;
+		this.href = &quot;&quot;;
+	}
+);

Added: trunk/root/static/magic/src/widget/demoEngine/SourcePane.js
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/SourcePane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/SourcePane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,52 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.demoEngine.SourcePane&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+
+dojo.widget.defineWidget(&quot;my.widget.demoEngine.SourcePane&quot;, 
+	dojo.widget.HtmlWidget, 
+	{
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/SourcePane.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/demoEngine/templates/SourcePane.css&quot;),
+		postCreate: function() {
+			dojo.html.addClass(this.domNode,this.domNodeClass);
+			dojo.debug(&quot;PostCreate&quot;);
+		},
+	
+		getSource: function() {
+			if (this.href) {
+				dojo.io.bind({
+					url: this.href,
+					load: dojo.lang.hitch(this, &quot;fillInSource&quot;),
+					mimetype: &quot;text/plain&quot;
+				});
+			}
+		},	
+
+		fillInSource: function(type, source, e) {
+			this.sourceNode.value=source;
+		},
+
+		setHref: function(url) {
+			this.href = url;
+			this.getSource();
+		}
+	},
+	&quot;&quot;,
+	function() {
+		dojo.debug(&quot;SourcePane Init&quot;);
+		this.domNodeClass=&quot;sourcePane&quot;;
+		this.sourceNode = &quot;&quot;;
+		this.href = &quot;&quot;;
+	}
+);

Added: trunk/root/static/magic/src/widget/demoEngine/__package__.js
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,20 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.kwCompoundRequire({
+	browser: [
+		&quot;dojo.widget.demoEngine.DemoItem&quot;,
+		&quot;dojo.widget.demoEngine.DemoNavigator&quot;,
+		&quot;dojo.widget.demoEngine.DemoPane&quot;,
+		&quot;dojo.widget.demoEngine.SourcePane&quot;,
+		&quot;dojo.widget.demoEngine.DemoContainer&quot;
+	]
+});
+dojo.provide(&quot;dojo.widget.demoEngine.*&quot;);

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.css
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,39 @@
+.demoContainer{
+	width: 100%;
+	height: 100%;
+	padding: 0px;
+	margin: 0px;
+}
+
+.demoContainer .return {
+	cursor: pointer;
+}
+
+.demoContainer span {
+	margin-right: 10px;
+	cursor: pointer;
+}
+
+.demoContainer .selected {
+	border-bottom: 5px solid #95bfff;
+}
+
+.demoContainer table {
+	background: #f5f5f5;
+	width: 100%;
+	height: 100%;
+}
+
+.demoContainerTabs {
+	width: 100%;
+	height: 400px;
+}
+
+.demoContainerTabs .dojoTabLabels-top {
+	display: none;
+}
+
+.demoContainerTabs .dojoTabPaneWrapper {
+	border: 0px;
+}
+

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.html
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoContainer.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,25 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+	&lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
+		&lt;tbody&gt;
+			&lt;tr dojoAttachPoint=&quot;headerNode&quot;&gt;
+				&lt;td dojoAttachPoint=&quot;returnNode&quot; valign=&quot;middle&quot; width=&quot;1%&quot;&gt;
+					&lt;img dojoAttachPoint=&quot;returnImageNode&quot; dojoAttachEvent=&quot;onclick: returnToDemos&quot;/&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;h1 dojoAttachPoint=&quot;demoNameNode&quot;&gt;&lt;/h1&gt;
+					&lt;p dojoAttachPoint=&quot;summaryNode&quot;&gt;&lt;/p&gt;
+				&lt;/td&gt;
+				&lt;td dojoAttachPoint=&quot;tabControlNode&quot; valign=&quot;middle&quot; align=&quot;right&quot; nowrap&gt;
+					&lt;span dojoAttachPoint=&quot;sourceButtonNode&quot; dojoAttachEvent=&quot;onclick: showSource&quot;&gt;source&lt;/span&gt;
+					&lt;span dojoAttachPoint=&quot;demoButtonNode&quot; dojoAttachEvent=&quot;onclick: showDemo&quot;&gt;demo&lt;/span&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr&gt;
+				&lt;td colspan=&quot;3&quot;&gt;
+					&lt;div dojoAttachPoint=&quot;tabNode&quot;&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+	&lt;/table&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.css
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,58 @@
+.demoItemSummaryBox {
+	background: #efefef;
+	border:1px solid #dae3ee;
+}
+
+.demoItemScreenshot {
+	padding:0.65em;
+	width:175px;
+	border-right:1px solid #fafafa;
+	text-align:center;
+	cursor: pointer;
+}
+
+.demoItemWrapper{
+	margin-bottom:1em;
+}
+
+.demoItemWrapper a:link, .demoItemWrapper a:visited {
+	color:#a6238f;
+	text-decoration:none;
+}
+
+.demoItemSummaryContainer {
+	border-left:1px solid #ddd;
+}
+
+.demoItemSummaryContainer h1 {
+	background-color:#e8e8e8;
+	border-bottom: 1px solid #e6e6e6;
+	color:#738fb9;
+	margin:1px;
+	padding:0.5em;
+	font-family:&quot;Lucida Grande&quot;, &quot;Tahoma&quot;, serif;
+	font-size:1.25em;
+	font-weight:normal;
+}
+
+.demoItemSummaryContainer h1 .packageSummary {
+	display:block;
+	color:#000;
+	font-size:10px;
+	margin-top:2px;
+}
+
+.demoItemSummaryContainer .demoItemSummary{
+	padding:1em;
+}
+
+.demoItemSummaryContainer .demoItemSummary p {
+	font-size:0.85em;
+	padding:0;
+	margin:0;
+}
+
+.demoItemView {
+	text-align:right;
+	cursor: pointer;
+}

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.html
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoItem.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,21 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+	&lt;div dojoAttachPoint=&quot;summaryBoxNode&quot;&gt;
+		&lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
+			&lt;tbody&gt;
+				&lt;tr&gt;
+					&lt;td dojoAttachPoint=&quot;screenshotTdNode&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;
+						&lt;img dojoAttachPoint=&quot;thumbnailImageNode&quot; dojoAttachEvent=&quot;onclick: onSelectDemo&quot; /&gt;
+					&lt;/td&gt;
+					&lt;td dojoAttachPoint=&quot;summaryContainerNode&quot; valign=&quot;top&quot;&gt;
+						&lt;h1 dojoAttachPoint=&quot;nameNode&quot;&gt;
+						&lt;/h1&gt;
+						&lt;div dojoAttachPoint=&quot;summaryNode&quot;&gt;
+							&lt;p dojoAttachPoint=&quot;descriptionNode&quot;&gt;&lt;/p&gt;
+							&lt;div dojoAttachPoint=&quot;viewDemoLinkNode&quot;&gt;&lt;img dojoAttachPoint=&quot;viewDemoImageNode&quot;/ dojoAttachEvent=&quot;onclick: onSelectDemo&quot;&gt;&lt;/div&gt;
+						&lt;/div&gt;
+					&lt;/td&gt;
+				&lt;/tr&gt;
+			&lt;/tbody&gt;
+		&lt;/table&gt;
+	&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.css
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,28 @@
+.demoNavigatorListWrapper {
+	border:1px solid #dcdbdb;
+	background-color:#f8f8f8;
+	padding:2px;
+}
+
+.demoNavigatorListContainer {
+	border:1px solid #f0f0f0;
+	background-color:#fff;
+	padding:1em;
+}
+
+.demoNavigator h1 {
+	margin-top: 0px;
+	margin-bottom: 10px;
+	font-size: 1.2em;
+	border-bottom:1px dotted #a9ccf5;
+}
+
+.demoNavigator .dojoButton {
+	margin-bottom: 5px;
+}
+
+.demoNavigator .dojoButton .dojoButtonContents {
+	font-size: 1.1em;
+	width: 100px;
+	color: black;
+}

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.html
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoNavigator.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,24 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+	&lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;5&quot;&gt;
+		&lt;tbody&gt;
+			&lt;tr dojoAttachPoint=&quot;navigationContainer&quot;&gt;
+				&lt;td dojoAttachPoint=&quot;categoriesNode&quot; valign=&quot;top&quot; width=&quot;1%&quot;&gt;
+					&lt;h1&gt;Categories&lt;/h1&gt;
+					&lt;div dojoAttachPoint=&quot;categoriesButtonsNode&quot;&gt;&lt;/div&gt;
+				&lt;/td&gt;
+
+				&lt;td dojoAttachPoint=&quot;demoListNode&quot; valign=&quot;top&quot;&gt;
+					&lt;div dojoAttachPoint=&quot;demoListWrapperNode&quot;&gt;
+						&lt;div dojoAttachPoint=&quot;demoListContainerNode&quot;&gt;
+						&lt;/div&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr&gt;
+				&lt;td colspan=&quot;2&quot;&gt;
+					&lt;div dojoAttachPoint=&quot;demoNode&quot;&gt;&lt;/div&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+	&lt;/table&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.css
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,18 @@
+.demoPane {
+	width: 100%;
+	height: 100%;
+	padding: 0px;
+	margin: 0px;
+	overflow: hidden;
+}
+
+.demoPane iframe {
+	width: 100%;
+	height: 100%;
+	border: 0px;
+	border: none;
+	overflow: auto;
+	padding: 0px;
+	margin:0px;
+	background: #ffffff;
+}

Added: trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.html
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/DemoPane.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,3 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+	&lt;iframe dojoAttachPoint=&quot;demoNode&quot;&gt;&lt;/iframe&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.css
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,20 @@
+.sourcePane {
+	width: 100%;
+	height: 100%;
+	padding: 0px;
+	margin: 0px;
+	overflow: hidden;
+}
+
+.sourcePane textarea{
+	width: 100%;
+	height: 100%;
+	border: 0px;
+	overflow: auto;
+	padding: 0px;
+	margin:0px;
+}
+
+* html .sourcePane {
+	overflow: auto;
+}

Added: trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.html
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/SourcePane.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,3 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+	&lt;textarea dojoAttachPoint=&quot;sourceNode&quot; rows=&quot;100%&quot;&gt;&lt;/textarea&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/demoEngine/templates/general.css
===================================================================
--- trunk/root/static/magic/src/widget/demoEngine/templates/general.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/demoEngine/templates/general.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,73 @@
+.demoListWrapper {
+	border:1px solid #dcdbdb;
+	background-color:#f8f8f8;
+	padding:2px;
+}
+
+.demoListContainer {
+	border:1px solid #f0f0f0;
+	background-color:#fff;
+	padding:1em;
+}
+
+.demoSummaryBox {
+	background: #efefef;
+	border:1px solid #dae3ee;
+}
+
+.screenshot {
+	padding:0.65em;
+	width:175px;
+	border-right:1px solid #fafafa;
+	text-align:center;
+}
+
+.demoSummary {
+	margin-bottom:1em;
+}
+
+.demoSummary a:link, .demoSummary a:visited {
+	color:#a6238f;
+	text-decoration:none;
+}
+
+.summaryContainer {
+	border-left:1px solid #ddd;
+}
+
+.summaryContainer h1 {
+	background-color:#e8e8e8;
+	border-bottom: 1px solid #e6e6e6;
+	color:#738fb9;
+	margin:1px;
+	padding:0.5em;
+	font-family:&quot;Lucida Grande&quot;, &quot;Tahoma&quot;, serif;
+	font-size:1.25em;
+	font-weight:normal;
+}
+
+.summaryContainer h1 .packageSummary {
+	display:block;
+	color:#000;
+	font-size:10px;
+	margin-top:2px;
+}
+
+.summaryContainer .summary {
+	padding:1em;
+}
+
+.summaryContainer .summary p {
+	font-size:0.85em;
+	padding:0;
+	margin:0;
+}
+
+.reflection {
+	background: url(&quot;images/demoBoxReflection.gif&quot;) repeat-x top left;
+	height:25px;
+}
+
+.view {
+	text-align:right;
+}

Added: trunk/root/static/magic/src/widget/demoEngine/templates/images/test_thumb.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/demoEngine/templates/images/test_thumb.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/demoEngine/templates/images/viewDemo.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/demoEngine/templates/images/viewDemo.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/html/AccordionPane.js
===================================================================
--- trunk/root/static/magic/src/widget/html/AccordionPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/AccordionPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,98 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.AccordionPane&quot;);
+dojo.require(&quot;dojo.widget.TitlePane&quot;);
+
+dojo.widget.html.AccordionPane = function(){
+
+	dojo.widget.html.TitlePane.call(this);
+	this.widgetType = &quot;AccordionPane&quot;;
+
+	this.open=false;
+	this.allowCollapse=true;
+	this.label=&quot;&quot;;
+	this.open=false;
+
+	this.labelNodeClass=&quot;&quot;;
+	this.containerNodeClass=&quot;&quot;;
+}
+
+dojo.inherits(dojo.widget.html.AccordionPane, dojo.widget.html.TitlePane);
+
+dojo.lang.extend(dojo.widget.html.AccordionPane, {
+        postCreate: function() {
+                dojo.widget.html.AccordionPane.superclass.postCreate.call(this);
+		this.domNode.widgetType=this.widgetType;
+		this.setSizes();
+		dojo.html.addClass(this.labelNode, this.labelNodeClass);
+		dojo.html.disableSelection(this.labelNode);
+		dojo.html.addClass(this.containerNode, this.containerNodeClass);
+        },
+
+	collapse: function() {
+		//dojo.fx.html.wipeOut(this.containerNode,250);
+		//var anim = dojo.fx.html.wipe(this.containerNode, 1000, this.containerNode.offsetHeight, 0, null, true);
+		this.containerNode.style.display=&quot;none&quot;;
+		this.open=false;
+	},
+
+	expand: function() {
+		//dojo.fx.html.wipeIn(this.containerNode,250);
+		this.containerNode.style.display=&quot;block&quot;;
+		//var anim = dojo.fx.html.wipe(this.containerNode, 1000, 0, this.containerNode.scrollHeight, null, true);
+		this.open=true;
+	},
+
+	getCollapsedHeight: function() {
+		return dojo.style.getOuterHeight(this.labelNode)+1;
+	},
+
+	setSizes: function() {
+		var siblings = this.domNode.parentNode.childNodes;
+		var height=dojo.style.getInnerHeight(this.domNode.parentNode)-this.getCollapsedHeight();
+
+		this.siblingWidgets = [];
+	
+		for (var x=0; x&lt;siblings.length; x++) {
+			if (siblings[x].widgetType==this.widgetType) {
+				if (this.domNode != siblings[x]) {
+					var ap = dojo.widget.byNode(siblings[x]);
+					this.siblingWidgets.push(ap);
+					height -= ap.getCollapsedHeight();
+				}
+			}
+		}
+	
+		for (var x=0; x&lt;this.siblingWidgets.length; x++) {
+			dojo.style.setOuterHeight(this.siblingWidgets[x].containerNode,height);
+		}
+
+		dojo.style.setOuterHeight(this.containerNode,height);
+	},
+
+	onLabelClick: function() {
+		this.setSizes();
+		if (!this.open) { 
+			for (var x=0; x&lt;this.siblingWidgets.length;x++) {
+				if (this.siblingWidgets[x].open) {
+					this.siblingWidgets[x].collapse();
+				}
+			}
+			this.expand();
+		} else {
+			if (this.allowCollapse) {
+				this.collapse();
+			}
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:AccordionPane&quot;);

Added: trunk/root/static/magic/src/widget/html/Button2.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Button2.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Button2.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,25 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+// this is a stub that will be removed in 0.4, see ../Button2.html for details
+
+dojo.provide(&quot;dojo.widget.html.Button2&quot;);
+
+dojo.widget.html.Button2 = function(){}
+dojo.inherits(dojo.widget.html.Button2, dojo.widget.html.Button);
+dojo.lang.extend(dojo.widget.html.Button2, { widgetType: &quot;Button2&quot; });
+
+dojo.widget.html.DropDownButton2 = function(){}
+dojo.inherits(dojo.widget.html.DropDownButton2, dojo.widget.html.DropDownButton);
+dojo.lang.extend(dojo.widget.html.DropDownButton2, { widgetType: &quot;DropDownButton2&quot; });
+
+dojo.widget.html.ComboButton2 = function(){}
+dojo.inherits(dojo.widget.html.ComboButton2, dojo.widget.html.ComboButton);
+dojo.lang.extend(dojo.widget.html.ComboButton2, { widgetType: &quot;ComboButton2&quot; });
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/html/Checkbox.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Checkbox.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Checkbox.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,82 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.Checkbox&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Checkbox&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		widgetType: &quot;Checkbox&quot;,
+	
+		templatePath: dojo.uri.dojoUri('src/widget/templates/HtmlCheckBox.html'),
+
+		srcOn: dojo.uri.dojoUri('src/widget/templates/check_on.gif'),
+		srcOff: dojo.uri.dojoUri('src/widget/templates/check_off.gif'),
+		srcDisabledOn: dojo.uri.dojoUri('src/widget/templates/check_disabled_on.gif'),
+		srcDisabledOff: dojo.uri.dojoUri('src/widget/templates/check_disabled_off.gif'),
+		srcHoverOn: dojo.uri.dojoUri('src/widget/templates/check_hover_on.gif'),
+		srcHoverOff: dojo.uri.dojoUri('src/widget/templates/check_hover_off.gif'),
+
+		imgSrc: null,
+
+		// parameters
+		disabled: &quot;enabled&quot;,
+		name: &quot;&quot;,
+		checked: false,
+		tabIndex: -1,
+
+		imgNode: null,
+		inputNode: null,
+
+		postMixInProperties: function(){
+			// set correct source for image before instantiating template
+			this._updateImgSrc();
+		},
+
+		onMouseUp: function(){
+			if(this.disabled == &quot;enabled&quot;){
+				this.checked = !this.checked;
+				this.inputNode.checked = this.checked;
+				this._updateImgSrc();
+			}
+		},
+
+		onMouseOver: function(){
+			this.hover=true;
+			this._updateImgSrc();
+		},
+
+		onMouseOut: function(){
+			this.hover=false;
+			this._updateImgSrc();
+		},
+
+		_updateImgSrc: function(){
+			if(this.disabled == &quot;enabled&quot;){
+				if(this.hover){
+					this.imgSrc = this.checked ? this.srcHoverOn : this.srcHoverOff;
+				}else{
+					this.imgSrc = this.checked ? this.srcOn : this.srcOff;
+				}
+			}else{
+				this.imgSrc = this.checked ? this.srcDisabledOn : this.srcDisabledOff;
+			}
+			if(this.imgNode){
+				this.imgNode.src = this.imgSrc;
+			}
+		}
+	}
+);
+

Added: trunk/root/static/magic/src/widget/html/ComboBox.js
===================================================================
--- trunk/root/static/magic/src/widget/html/ComboBox.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/ComboBox.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,611 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.ComboBox&quot;);
+dojo.require(&quot;dojo.widget.ComboBox&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.widget.html.stabile&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.ComboBox&quot;,
+	[dojo.widget.HtmlWidget, dojo.widget.ComboBox],
+	{
+		autoComplete: true,
+		formInputName: &quot;&quot;,
+		name: &quot;&quot;, // clone in the name from the DOM node
+		textInputNode: null,
+		comboBoxValue: null,
+		comboBoxSelectionValue: null,
+		optionsListWrapper: null,
+		optionsListNode: null,
+		downArrowNode: null,
+		cbTableNode: null,
+		searchTimer: null,
+		searchDelay: 100,
+		dataUrl: &quot;&quot;,
+		fadeTime: 200,
+		// maxListLength limits list to X visible rows, scroll on rest 
+		maxListLength: 8, 
+		// mode can also be &quot;remote&quot; for JSON-returning live search or &quot;html&quot; for
+		// dumber live search
+		mode: &quot;local&quot;, 
+		selectedResult: null,
+		_highlighted_option: null,
+		_prev_key_backspace: false,
+		_prev_key_esc: false,
+		_result_list_open: false,
+		_gotFocus: false,
+		_mouseover_list: false,
+		dataProviderClass: &quot;dojo.widget.ComboBoxDataProvider&quot;,
+
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlComboBox.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlComboBox.css&quot;),
+	
+		setValue: function(value) {
+			this.comboBoxValue.value = value;
+			if (this.textInputNode.value != value) { // prevent mucking up of selection
+				this.textInputNode.value = value;
+			}
+			dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
+		},
+	
+		getValue: function() {
+			return this.comboBoxValue.value;
+		},
+	
+		getState: function() {
+			return {value: this.getValue()};
+		},
+	
+		setState: function(state) {
+			this.setValue(state.value);
+		},
+	
+		getCaretPos: function(element){
+			// khtml 3.5.2 has selection* methods as does webkit nightlies from 2005-06-22
+			if(dojo.lang.isNumber(element.selectionStart)){
+				// FIXME: this is totally borked on Moz &lt; 1.3. Any recourse?
+				return element.selectionStart;
+			}else if(dojo.render.html.ie){
+				// in the case of a mouse click in a popup being handled,
+				// then the document.selection is not the textarea, but the popup
+				// var r = document.selection.createRange();
+				// hack to get IE 6 to play nice. What a POS browser.
+				var tr = document.selection.createRange().duplicate();
+				var ntr = element.createTextRange();
+				tr.move(&quot;character&quot;,0);
+				ntr.move(&quot;character&quot;,0);
+				try {
+					// If control doesnt have focus, you get an exception.
+					// Seems to happen on reverse-tab, but can also happen on tab (seems to be a race condition - only happens sometimes).
+					// There appears to be no workaround for this - googled for quite a while.
+					ntr.setEndPoint(&quot;EndToEnd&quot;, tr);
+					return String(ntr.text).replace(/\r/g,&quot;&quot;).length;
+				} catch (e) {
+					return 0; // If focus has shifted, 0 is fine for caret pos.
+				}
+				
+			}
+		},
+	
+		setCaretPos: function(element, location){
+			location = parseInt(location);
+			this.setSelectedRange(element, location, location);
+		},
+	
+		setSelectedRange: function(element, start, end){
+			if(!end){ end = element.value.length; }  // NOTE: Strange - should be able to put caret at start of text?
+			// Mozilla
+			// parts borrowed from <A HREF="http://www.faqts.com/knowledge_base/view.phtml/aid/13562/fid/130">http://www.faqts.com/knowledge_base/view.phtml/aid/13562/fid/130</A>
+			if(element.setSelectionRange){
+				element.focus();
+				element.setSelectionRange(start, end);
+			}else if(element.createTextRange){ // IE
+				var range = element.createTextRange();
+				with(range){
+					collapse(true);
+					moveEnd('character', end);
+					moveStart('character', start);
+					select();
+				}
+			}else{ //otherwise try the event-creation hack (our own invention)
+				// do we need these?
+				element.value = element.value;
+				element.blur();
+				element.focus();
+				// figure out how far back to go
+				var dist = parseInt(element.value.length)-end;
+				var tchar = String.fromCharCode(37);
+				var tcc = tchar.charCodeAt(0);
+				for(var x = 0; x &lt; dist; x++){
+					var te = document.createEvent(&quot;KeyEvents&quot;);
+					te.initKeyEvent(&quot;keypress&quot;, true, true, null, false, false, false, false, tcc, tcc);
+					element.dispatchEvent(te);
+				}
+			}
+		},
+	
+		// does the keyboard related stuff
+		_handleKeyEvents: function(evt){
+			if(evt.ctrlKey || evt.altKey){ return; }
+	
+			// reset these
+			this._prev_key_backspace = false;
+			this._prev_key_esc = false;
+	
+			var k = dojo.event.browser.keys;
+			var doSearch = true;
+	
+			// mozilla quirk 
+			// space has no keyCode in mozilla
+			var keyCode = evt.keyCode;
+			if(keyCode==0 &amp;&amp; evt.charCode==k.KEY_SPACE){
+				keyCode = k.KEY_SPACE;
+			}
+			switch(keyCode){
+	 			case k.KEY_DOWN_ARROW:
+					if(!this._result_list_open){
+						this.startSearchFromInput();
+					}
+					this.highlightNextOption();
+					dojo.event.browser.stopEvent(evt);
+					return;
+				case k.KEY_UP_ARROW:
+					this.highlightPrevOption();
+					dojo.event.browser.stopEvent(evt);
+					return;
+				case k.KEY_ENTER:
+					// prevent submitting form if we press enter with list open
+					if(this._result_list_open){
+						dojo.event.browser.stopEvent(evt);
+					}
+					// fallthrough
+				case k.KEY_TAB:
+					// using linux alike tab for autocomplete
+					if(!this.autoComplete &amp;&amp; this._result_list_open &amp;&amp; this._highlighted_option){
+						dojo.event.browser.stopEvent(evt);
+						this.selectOption({ 'target': this._highlighted_option, 'noHide': true });
+	
+						// put caret last
+						this.setSelectedRange(this.textInputNode, this.textInputNode.value.length, null);
+					}else{
+						this.selectOption();
+						return;
+					}
+					break;
+				case k.KEY_SPACE:
+					if(this._result_list_open &amp;&amp; this._highlighted_option){
+						dojo.event.browser.stopEvent(evt);
+						this.selectOption();
+						this.hideResultList();
+						return;
+					}
+					break;
+				case k.KEY_ESCAPE:
+					this.hideResultList();
+					this._prev_key_esc = true;
+					return;
+				case k.KEY_BACKSPACE:
+					this._prev_key_backspace = true;
+					if(!this.textInputNode.value.length){
+						this.setAllValues(&quot;&quot;, &quot;&quot;);
+						this.hideResultList();
+						doSearch = false;
+					}
+					break;
+				case k.KEY_RIGHT_ARROW: // fall through
+				case k.KEY_LEFT_ARROW: // fall through
+				case k.KEY_SHIFT:
+					doSearch = false;
+					break;
+				<A HREF="default://">default://</A> non char keys (F1-F12 etc..)  shouldn't open list
+					if(evt.charCode==0){
+						doSearch = false;
+					}
+			}
+	
+			if(this.searchTimer){
+				clearTimeout(this.searchTimer);
+			}
+			if(doSearch){
+				// if we have gotten this far we dont want to keep our highlight
+				this.blurOptionNode();
+	
+				// need to wait a tad before start search so that the event bubbles through DOM and we have value visible
+				this.searchTimer = setTimeout(dojo.lang.hitch(this, this.startSearchFromInput), this.searchDelay);
+			}
+		},
+	
+		onKeyDown: function(evt){
+			// IE needs to stop keyDown others need to stop keyPress
+			if(!document.createEvent){ // only IE
+				this._handleKeyEvents(evt);
+			}
+			// FIXME: What about ESC ??
+		},
+	
+		onKeyPress: function(evt){
+			if(document.createEvent){ // never IE
+				this._handleKeyEvents(evt);
+			}
+		},
+	
+		onKeyUp: function(evt){
+			this.setValue(this.textInputNode.value);
+		},
+	
+		setSelectedValue: function(value){
+			// FIXME, not sure what to do here!
+			this.comboBoxSelectionValue.value = value;
+		},
+
+		setAllValues: function(value1, value2){
+			this.setValue(value1);
+			this.setSelectedValue(value2);
+		},
+	
+		// opera, khtml, safari doesnt support node.scrollIntoView(), workaround
+		scrollIntoView: function(){
+			var node = this._highlighted_option;
+			var parent = this.optionsListNode;
+			// don't rely on that node.scrollIntoView works just because the function is there
+			// it doesnt work in Konqueror or Opera even though the function is there and probably
+			// not safari either
+			// dont like browser sniffs implementations but sometimes you have to use it
+			if(dojo.render.html.ie || dojo.render.html.mozilla){
+				// IE, mozilla
+				node.scrollIntoView(false);	
+			}else{
+				var parentBottom = parent.scrollTop + dojo.style.getInnerHeight(parent);
+				var nodeBottom = node.offsetTop + dojo.style.getOuterHeight(node);
+				if(parentBottom &lt; nodeBottom){
+					parent.scrollTop += (nodeBottom - parentBottom);
+				}else if(parent.scrollTop &gt; node.offsetTop){
+					parent.scrollTop -= (parent.scrollTop - node.offsetTop);
+				}
+			}
+		},
+	
+		// does the actual highlight
+		focusOptionNode: function(node){
+			if(this._highlighted_option != node){
+				this.blurOptionNode();
+				this._highlighted_option = node;
+				dojo.html.addClass(this._highlighted_option, &quot;dojoComboBoxItemHighlight&quot;);
+			}
+		},
+	
+		// removes highlight on highlighted
+		blurOptionNode: function(){
+			if(this._highlighted_option){
+				dojo.html.removeClass(this._highlighted_option, &quot;dojoComboBoxItemHighlight&quot;);
+				this._highlighted_option = null;
+			}
+		},
+	
+		highlightNextOption: function(){
+			if((!this._highlighted_option) || !this._highlighted_option.parentNode){
+				this.focusOptionNode(this.optionsListNode.firstChild);
+			}else if(this._highlighted_option.nextSibling){
+				this.focusOptionNode(this._highlighted_option.nextSibling);
+			}
+			this.scrollIntoView();
+		},
+	
+		highlightPrevOption: function(){
+			if(this._highlighted_option &amp;&amp; this._highlighted_option.previousSibling){
+				this.focusOptionNode(this._highlighted_option.previousSibling);
+			}else{
+				this._highlighted_option = null;
+				this.hideResultList();
+				return;
+			}
+			this.scrollIntoView();
+		},
+	
+		itemMouseOver: function(evt){
+			this.focusOptionNode(evt.target);
+			dojo.html.addClass(this._highlighted_option, &quot;dojoComboBoxItemHighlight&quot;);
+		},
+	
+		itemMouseOut: function(evt){
+			this.blurOptionNode();
+		},
+	
+		fillInTemplate: function(args, frag){
+			// FIXME: need to get/assign DOM node names for form participation here.
+			this.comboBoxValue.name = this.name;
+			this.comboBoxSelectionValue.name = this.name+&quot;_selected&quot;;
+	
+			var source = this.getFragNodeRef(frag);
+			dojo.html.copyStyle(this.domNode, source);
+	
+			var dpClass;
+			if(this.mode == &quot;remote&quot;){
+				dpClass = dojo.widget.incrementalComboBoxDataProvider;
+			}else if(typeof this.dataProviderClass == &quot;string&quot;){
+				dpClass = dojo.evalObjPath(this.dataProviderClass)
+			}else{
+				dpClass = this.dataProviderClass;
+			}
+			this.dataProvider = new dpClass();
+			this.dataProvider.init(this, this.getFragNodeRef(frag));
+	
+			// Prevent IE bleed-through problem
+			this.optionsIframe = new dojo.html.BackgroundIframe(this.optionsListWrapper);
+			this.optionsIframe.size([0,0,0,0]);
+		},
+	
+	
+		focus: function(){
+			// summary
+			//	set focus to input node from code
+			this.tryFocus();
+		},
+	
+		openResultList: function(results){
+			this.clearResultList();
+			if(!results.length){
+				this.hideResultList();
+			}
+	
+			if(	(this.autoComplete)&amp;&amp;
+				(results.length)&amp;&amp;
+				(!this._prev_key_backspace)&amp;&amp;
+				(this.textInputNode.value.length &gt; 0)){
+				var cpos = this.getCaretPos(this.textInputNode);
+				// only try to extend if we added the last character at the end of the input
+				if((cpos+1) &gt; this.textInputNode.value.length){
+					// only add to input node as we would overwrite Capitalisation of chars
+					this.textInputNode.value += results[0][0].substr(cpos);
+					// build a new range that has the distance from the earlier
+					// caret position to the end of the first string selected
+					this.setSelectedRange(this.textInputNode, cpos, this.textInputNode.value.length);
+				}
+			}
+	
+			var even = true;
+			while(results.length){
+				var tr = results.shift();
+				if(tr){
+					var td = document.createElement(&quot;div&quot;);
+					td.appendChild(document.createTextNode(tr[0]));
+					td.setAttribute(&quot;resultName&quot;, tr[0]);
+					td.setAttribute(&quot;resultValue&quot;, tr[1]);
+					td.className = &quot;dojoComboBoxItem &quot;+((even) ? &quot;dojoComboBoxItemEven&quot; : &quot;dojoComboBoxItemOdd&quot;);
+					even = (!even);
+					this.optionsListNode.appendChild(td);
+					dojo.event.connect(td, &quot;onmouseover&quot;, this, &quot;itemMouseOver&quot;);
+					dojo.event.connect(td, &quot;onmouseout&quot;, this, &quot;itemMouseOut&quot;);
+				}
+			}
+	
+			// show our list (only if we have content, else nothing)
+			this.showResultList();
+		},
+	
+		onFocusInput: function(){
+			this._hasFocus = true;
+		},
+	
+		onBlurInput: function(){
+			this._hasFocus = false;
+			this._handleBlurTimer(true, 500);
+		},
+	
+		// collect all blur timers issues here
+		_handleBlurTimer: function(/*Boolean*/clear, /*Number*/ millisec){
+			if(this.blurTimer &amp;&amp; (clear || millisec)){
+				clearTimeout(this.blurTimer);
+			}
+			if(millisec){ // we ignore that zero is false and never sets as that never happens in this widget
+				this.blurTimer = dojo.lang.setTimeout(this, &quot;checkBlurred&quot;, millisec);
+			}
+		},
+	
+		// these 2 are needed in IE and Safari as inputTextNode loses focus when scrolling optionslist
+		_onMouseOver: function(evt){
+			if(!this._mouseover_list){
+				this._handleBlurTimer(true, 0);
+				this._mouseover_list = true;
+			}
+		},
+	
+		_onMouseOut:function(evt){
+			var relTarget = evt.relatedTarget;
+			if(!relTarget || relTarget.parentNode!=this.optionsListNode){
+				this._mouseover_list = false;
+				this._handleBlurTimer(true, 100);
+				this.tryFocus();
+			}
+		},
+	
+		_isInputEqualToResult: function(result){
+			input = this.textInputNode.value;
+			if(!this.dataProvider.caseSensitive){
+				input = input.toLowerCase();
+				result = result.toLowerCase();
+			}
+			return (input == result);
+		},
+
+		_isValidOption: function(){
+			tgt = dojo.dom.firstElement(this.optionsListNode);
+			isValidOption = false;
+			while(!isValidOption &amp;&amp; tgt){
+				if(this._isInputEqualToResult(tgt.getAttribute(&quot;resultName&quot;))){
+					isValidOption = true;
+				}else{
+					tgt = dojo.dom.nextElement(tgt);
+				}
+			}
+			return isValidOption;
+		},
+
+		checkBlurred: function(){
+			if(!this._hasFocus &amp;&amp; !this._mouseover_list){
+				this.hideResultList();
+				// clear the list if the user empties field and moves away.
+				if(!this.textInputNode.value.length){
+					this.setAllValues(&quot;&quot;, &quot;&quot;);
+					return;
+				}
+				
+				isValidOption = this._isValidOption();
+				// enforce selection from option list
+				if(this.forceValidOption &amp;&amp; !isValidOption){
+					this.setAllValues(&quot;&quot;, &quot;&quot;);
+					return;
+				}
+				if(!isValidOption){// clear
+					this.setSelectedValue(&quot;&quot;);
+				}
+			}
+		},
+	
+		sizeBackgroundIframe: function(){
+			var w = dojo.style.getOuterWidth(this.optionsListNode);
+			var h = dojo.style.getOuterHeight(this.optionsListNode);
+			if( w==0 || h==0 ){
+				// need more time to calculate size
+				dojo.lang.setTimeout(this, &quot;sizeBackgroundIframe&quot;, 100);
+				return;
+			}
+			if(this._result_list_open){
+				this.optionsIframe.size([0,0,w,h]);
+			}
+		},
+	
+		selectOption: function(evt){
+			var tgt = null;
+			if(!evt){
+				evt = { target: this._highlighted_option };
+			}
+	
+			if(!dojo.dom.isDescendantOf(evt.target, this.optionsListNode)){
+				// handle autocompletion where the the user has hit ENTER or TAB
+	
+				// if the input is empty do nothing
+				if(!this.textInputNode.value.length){
+					return;
+				}
+				tgt = dojo.dom.firstElement(this.optionsListNode);
+	
+				// user has input value not in option list
+				if(!tgt || !this._isInputEqualToResult(tgt.getAttribute(&quot;resultName&quot;))){
+					return;
+				}
+				// otherwise the user has accepted the autocompleted value
+			}else{
+				tgt = evt.target; 
+			}
+	
+			while((tgt.nodeType!=1)||(!tgt.getAttribute(&quot;resultName&quot;))){
+				tgt = tgt.parentNode;
+				if(tgt === document.body){
+					return false;
+				}
+			}
+	
+			this.textInputNode.value = tgt.getAttribute(&quot;resultName&quot;);
+			this.selectedResult = [tgt.getAttribute(&quot;resultName&quot;), tgt.getAttribute(&quot;resultValue&quot;)];
+			this.setAllValues(tgt.getAttribute(&quot;resultName&quot;), tgt.getAttribute(&quot;resultValue&quot;));
+			if(!evt.noHide){
+				this.hideResultList();
+				this.setSelectedRange(this.textInputNode, 0, null);
+			}
+			this.tryFocus();
+		},
+	
+		clearResultList: function(){
+			var oln = this.optionsListNode;
+			while(oln.firstChild){
+				dojo.event.disconnect(oln.firstChild, &quot;onmouseover&quot;, this, &quot;itemMouseOver&quot;);
+				dojo.event.disconnect(oln.firstChild, &quot;onmouseout&quot;, this, &quot;itemMouseOut&quot;);
+				oln.removeChild(oln.firstChild);
+			}
+		},
+	
+		hideResultList: function(){
+			if(this._result_list_open){
+				this._result_list_open = false;
+				this.optionsIframe.size([0,0,0,0]);
+				dojo.lfx.fadeHide(this.optionsListNode, this.fadeTime).play();
+			}
+		},
+	
+		showResultList: function(){
+			// Our dear friend IE doesnt take max-height so we need to calculate that on our own every time
+			var childs = this.optionsListNode.childNodes;
+			if(childs.length){
+				var visibleCount = this.maxListLength;
+				if(childs.length &lt; visibleCount){
+					visibleCount = childs.length;
+				}
+	
+				with(this.optionsListNode.style){
+					display = &quot;&quot;;
+					height = ((visibleCount) ? (dojo.style.getOuterHeight(childs[0]) * visibleCount) : 0)+&quot;px&quot;;
+					width = dojo.html.getOuterWidth(this.cbTableNode)-2+&quot;px&quot;;
+				}
+				// only fadein once (flicker)
+				if(!this._result_list_open){
+					dojo.html.setOpacity(this.optionsListNode, 0);
+					dojo.lfx.fadeIn(this.optionsListNode, this.fadeTime).play();
+				}
+				
+				// prevent IE bleed through
+				this._iframeTimer = dojo.lang.setTimeout(this, &quot;sizeBackgroundIframe&quot;, 200);
+				this._result_list_open = true;
+			}else{
+				this.hideResultList();
+			}
+		},
+	
+		handleArrowClick: function(){
+			this._handleBlurTimer(true, 0);
+			this.tryFocus();
+			if(this._result_list_open){
+				this.hideResultList();
+			}else{
+				this.startSearchFromInput();
+			}
+		},
+	
+		tryFocus: function(){
+			try {
+				this.textInputNode.focus();
+			} catch (e) {
+				// element isn't focusable if disabled, or not visible etc - not easy to test for.
+	 		};
+		},
+		
+		startSearchFromInput: function(){
+			this.startSearch(this.textInputNode.value);
+		},
+	
+		postCreate: function(){
+			dojo.event.connect(this, &quot;startSearch&quot;, this.dataProvider, &quot;startSearch&quot;);
+			dojo.event.connect(this.dataProvider, &quot;provideSearchResults&quot;, this, &quot;openResultList&quot;);
+			dojo.event.connect(this.textInputNode, &quot;onblur&quot;, this, &quot;onBlurInput&quot;);
+			dojo.event.connect(this.textInputNode, &quot;onfocus&quot;, this, &quot;onFocusInput&quot;);
+	
+			var s = dojo.widget.html.stabile.getState(this.widgetId);
+			if (s) {
+				this.setState(s);
+			}
+		}
+	}
+);

Added: trunk/root/static/magic/src/widget/html/ContentPane.js
===================================================================
--- trunk/root/static/magic/src/widget/html/ContentPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/ContentPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,566 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.ContentPane&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.ContentPane&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.string.extras&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+dojo.widget.html.ContentPane = function(){
+	this._onLoadStack = [];
+	this._onUnLoadStack = [];
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.ContentPane, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.ContentPane, {
+	widgetType: &quot;ContentPane&quot;,
+	isContainer: true,
+
+	// remote loading options
+	adjustPaths: true,
+	href: &quot;&quot;,
+	extractContent: true,
+	parseContent: true,
+	cacheContent: true,
+	preload: false,			// force load of data even if pane is hidden
+	refreshOnShow: false,
+	handler: &quot;&quot;,			// generate pane content from a java function
+	executeScripts: false,	// if true scripts in content will be evaled after content is set and parsed
+	scriptScope: null,		// scopeContainer for downloaded scripts
+
+		// If the user want a global in the remote script he/she just omitts the var
+		// examples:
+		//--------------------------
+		// these gets collected by scriptScope and is reached by dojo.widget.byId('..').scriptScope.myCustomproperty
+		//	this.myString = &quot;dojo is a great javascript toolkit!&quot;;
+		//
+		//	this.alertMyString = function(){
+		//		alert(myString);
+		//	}
+		// -------------------------
+		// these go into the global namespace (window) notice lack of var, equiv to window.myString
+		//	myString = &quot;dojo is a javascript toolkit!&quot;;
+		//
+		//	alertMyString = function(){
+		//		alert(myString);
+		// }
+
+
+	// private
+	_remoteStyles: null,	// array of stylenodes inserted to document head
+							// by remote content, used when we clean up for new content
+
+	_callOnUnLoad: false,		// used by setContent and _handleDefults, makes sure onUnLoad is only called once
+
+	postCreate: function(args, frag, parentComp){
+		if ( this.handler != &quot;&quot; ){
+			this.setHandler(this.handler);
+		}
+		if(this.isShowing()||this.preload){ this.loadContents(); }
+	},
+
+	show: function(){
+		// if refreshOnShow is true, reload the contents every time; otherwise, load only the first time
+		if(this.refreshOnShow){
+			this.refresh();
+		}else{
+			this.loadContents();
+		}
+		dojo.widget.html.ContentPane.superclass.show.call(this);
+	},
+
+	refresh: function(){
+		this.isLoaded=false;
+		this.loadContents();
+	},
+
+	loadContents: function() {
+		if ( this.isLoaded ){
+			return;
+		}
+		this.isLoaded=true;
+		if ( dojo.lang.isFunction(this.handler)) {
+			this._runHandler();
+		} else if ( this.href != &quot;&quot; ) {
+			this._downloadExternalContent(this.href, this.cacheContent);
+		}
+	},
+
+	
+	setUrl: function(/*String*/ url) {
+		// summary:
+		// 	Reset the (external defined) content of this pane and replace with new url
+		this.href = url;
+		this.isLoaded = false;
+		if ( this.preload || this.isShowing() ){
+			this.loadContents();
+		}
+	},
+
+	_downloadExternalContent: function(url, useCache) {
+		this._handleDefaults(&quot;Loading...&quot;, &quot;onDownloadStart&quot;);
+		var self = this;
+		dojo.io.bind({
+			url: url,
+			useCache: useCache,
+			preventCache: !useCache,
+			mimetype: &quot;text/html&quot;,
+			handler: function(type, data, e) {
+				if(type == &quot;load&quot;) {
+					self.onDownloadEnd.call(self, url, data);
+				} else {
+					// works best when from a live server instead of from file system 
+					self._handleDefaults.call(self, &quot;Error loading '&quot; + url + &quot;' (&quot; + e.status + &quot; &quot;+  e.statusText + &quot;)&quot;, &quot;onDownloadError&quot;);
+					self.onLoad();
+				}
+			}
+		});
+	},
+
+	// called when setContent is finished
+	onLoad: function(e){
+		this._runStack(&quot;_onLoadStack&quot;);
+	},
+
+	// called before old content is cleared
+	onUnLoad: function(e){
+		this._runStack(&quot;_onUnLoadStack&quot;);
+		this.scriptScope = null;
+	},
+
+	_runStack: function(stName){
+		var st = this[stName]; var err = &quot;&quot;;
+		for(var i = 0;i &lt; st.length; i++){
+			try{
+				st[i].call(this.scriptScope);
+			}catch(e){ 
+				err += &quot;\n&quot;+st[i]+&quot; failed: &quot;+e.description;
+			}
+		}
+		this[stName] = [];
+
+		if(err.length){
+			var name = (stName== &quot;_onLoadStack&quot;) ? &quot;addOnLoad&quot; : &quot;addOnUnLoad&quot;;
+			this._handleDefaults(name+&quot; failure\n &quot;+err, &quot;onExecError&quot;, true);
+		}
+	},
+
+	addOnLoad: function(obj, func){
+		// summary
+		// 	same as to dojo.addOnLoad but does not take &quot;function_name&quot; as a string
+		this._pushOnStack(this._onLoadStack, obj, func);
+	},
+
+	addOnUnLoad: function(obj, func){
+		// summary
+		// 	same as to dojo.addUnOnLoad but does not take &quot;function_name&quot; as a string
+		this._pushOnStack(this._onUnLoadStack, obj, func);
+	},
+
+	_pushOnStack: function(stack, obj, func){
+		if(typeof func == 'undefined') {
+			stack.push(obj);
+		}else{
+			stack.push(function(){ obj[func](); });
+		}
+	},
+
+	destroy: function(){
+		// make sure we call onUnLoad
+		this.onUnLoad();
+		dojo.widget.html.ContentPane.superclass.destroy.call(this);
+	},
+
+	// called when content script eval error or Java error occurs, preventDefault-able
+	onExecError: function(e){ /*stub*/ },
+
+	// called on DOM faults, require fault etc in content, preventDefault-able
+	onContentError: function(e){ /*stub*/ },
+
+	// called when download error occurs, preventDefault-able
+	onDownloadError: function(e){ /*stub*/ },
+
+	// called before download starts, preventDefault-able
+	onDownloadStart: function(e){ /*stub*/ },
+
+	// called when download is finished
+	onDownloadEnd: function(url, data){
+		data = this.splitAndFixPaths(data, url);
+		this.setContent(data);
+	},
+
+	// usefull if user wants to prevent default behaviour ie: _setContent(&quot;Error...&quot;)
+	_handleDefaults: function(e, handler, useAlert){
+		if(!handler){ handler = &quot;onContentError&quot;; }
+		if(dojo.lang.isString(e)){
+			e = {
+				&quot;text&quot;: e,
+				&quot;toString&quot;: function(){ return this.text; }
+			}
+		}
+		if(typeof e.returnValue != &quot;boolean&quot;){
+			e.returnValue = true; 
+		}
+		if(typeof e.preventDefault != &quot;function&quot;){
+			e.preventDefault = function(){
+				this.returnValue = false;
+			}
+		}
+		// call our handler
+		this[handler](e);
+		if(e.returnValue){
+			if(useAlert){
+				alert(e.toString());
+			}else{
+				if(this._callOnUnLoad){
+					this.onUnLoad(); // makes sure scripts can clean up after themselves, before we setContent
+				}
+				this._callOnUnLoad = false; // makes sure we dont try to call onUnLoad again on this event,
+											// ie onUnLoad before 'Loading...' but not before clearing 'Loading...'
+				this._setContent(e.toString());
+			}
+		}
+	},
+
+	
+	splitAndFixPaths: function(/*String*/s, /*dojo.uri.Uri?*/url){
+		// summary:
+		// 	fixes all remote paths in (hopefully) all cases for example images, remote scripts, links etc.
+		// 	splits up content in different pieces, scripts, title, style, link and whats left becomes .xml
+
+		if(!url) { url = &quot;./&quot;; } // point to this page if not set
+		if(!s) { return &quot;&quot;; }
+
+		// fix up paths in data
+		var titles = []; var scripts = []; var linkStyles = [];
+		var styles = []; var remoteScripts = []; var requires = [];
+
+		// khtml is much more picky about dom faults, you can't for example attach a style node under body of document
+		// must go into head, as does a title node, so we need to cut out those tags
+		// cut out title tags
+		var match = [];
+		while(match){
+			match = s.match(/&lt;title[^&gt;]*&gt;([\s\S]*?)&lt;\/title&gt;/i); // can't match with dot as that 
+			if(!match){ break;}					//doesnt match newline in js
+			titles.push(match[1]);
+			s = s.replace(/&lt;title[^&gt;]*&gt;[\s\S]*?&lt;\/title&gt;/i, &quot;&quot;);
+		}
+
+		// cut out &lt;style&gt; url(...) &lt;/style&gt;, as that bails out in khtml
+		var match = [];
+		while(match){
+			match = s.match(/&lt;style[^&gt;]*&gt;([\s\S]*?)&lt;\/style&gt;/i);
+			if(!match){ break; }
+			styles.push(dojo.style.fixPathsInCssText(match[1], url));
+			s = s.replace(/&lt;style[^&gt;]*?&gt;[\s\S]*?&lt;\/style&gt;/i, &quot;&quot;);
+		}
+
+		// attributepaths one tag can have multiple paths example:
+		// &lt;input src=&quot;...&quot; style=&quot;url(..)&quot;/&gt; or &lt;a style=&quot;url(..)&quot; href=&quot;..&quot;&gt;
+		// strip out the tag and run fix on that.
+		// this guarantees that we won't run replace another tag's attribute + it was easier do
+		var pos = 0; var pos2 = 0; var stop = 0 ;var str = &quot;&quot;; var fixedPath = &quot;&quot;;
+		var attr = []; var fix = &quot;&quot;; var tagFix = &quot;&quot;; var tag = &quot;&quot;; var regex = &quot;&quot;; 
+		while(pos&gt;-1){
+			pos = s.search(/&lt;[a-z][a-z0-9]*[^&gt;]*\s(?:(?:src|href|style)=[^&gt;])+[^&gt;]*&gt;/i);
+			if(pos==-1){ break; }
+			str += s.substring(0, pos);
+			s = s.substring(pos, s.length);
+			tag = s.match(/^&lt;[a-z][a-z0-9]*[^&gt;]*&gt;/i)[0];
+			s = s.substring(tag.length, s.length);
+
+			// loop through attributes
+			pos2 = 0; tagFix = &quot;&quot;; fix = &quot;&quot;; regex = &quot;&quot;; var regexlen = 0;
+			while(pos2!=-1){
+				// slices up before next attribute check, values from previous loop
+				tagFix += tag.substring(0, pos2) + fix;
+				tag = tag.substring(pos2+regexlen, tag.length);
+
+				// fix next attribute or bail out when done
+				// hopefully this charclass covers most urls
+				attr = tag.match(/ (src|href|style)=(['&quot;]?)([\w()\[\]\/.,\\'&quot;-:;#=&amp;?\s@]+?)\2/i);
+				if(!attr){ break; }
+
+				switch(attr[1].toLowerCase()){
+					case &quot;src&quot;:// falltrough
+					case &quot;href&quot;:
+						// this hopefully covers most common protocols
+						if(attr[3].search(/^(?:[#]|(?:(?:https?|ftps?|file|javascript|mailto|news):))/)==-1){
+							fixedPath = (new dojo.uri.Uri(url, attr[3]).toString());
+						} else {
+							pos2 = pos2 + attr[3].length;
+							continue;
+						}
+						break;
+					case &quot;style&quot;:// style
+						fixedPath = dojo.style.fixPathsInCssText(attr[3], url);
+						break;
+					default:
+						pos2 = pos2 + attr[3].length;
+						continue;
+				}
+
+				regex = &quot; &quot; + attr[1] + &quot;=&quot; + attr[2] + attr[3] + attr[2];
+				regexlen = regex.length;
+				fix = &quot; &quot; + attr[1] + &quot;=&quot; + attr[2] + fixedPath + attr[2];
+				pos2 = tag.search(new RegExp(dojo.string.escapeRegExp(regex)));
+			}
+			str += tagFix + tag;
+			pos = 0; // reset for next mainloop
+		}
+		s = str+s;
+
+		// cut out all script tags, push them into scripts array
+		match = []; var tmp = [];
+		while(match){
+			match = s.match(/&lt;script([^&gt;]*)&gt;([\s\S]*?)&lt;\/script&gt;/i);
+			if(!match){ break; }
+			if(match[1]){
+				attr = match[1].match(/src=(['&quot;]?)([^&quot;']*)\1/i);
+				if(attr){
+					// remove a dojo.js or dojo.js.uncompressed.js from remoteScripts
+					// we declare all files with dojo.js as bad, regardless of folder
+					var tmp = attr[2].search(/.*(\bdojo\b(?:\.uncompressed)?\.js)$/);
+					if(tmp &gt; -1){
+						dojo.debug(&quot;Security note! inhibit:&quot;+attr[2]+&quot; from  beeing loaded again.&quot;);
+					}else{
+						remoteScripts.push(attr[2]);
+					}
+				}
+			}
+			if(match[2]){
+				// strip out all djConfig variables from script tags nodeValue
+				// this is ABSOLUTLY needed as reinitialize djConfig after dojo is initialised
+				// makes a dissaster greater than Titanic, update remove writeIncludes() to
+				var sc = match[2].replace(/(?:var )?\bdjConfig\b(?:[\s]*=[\s]*\{[^}]+\}|\.[\w]*[\s]*=[\s]*[^;\n]*)?;?|dojo\.hostenv\.writeIncludes\(\s*\);?/g, &quot;&quot;);
+				if(!sc){ continue; }
+
+				// cut out all dojo.require (...) calls, if we have execute 
+				// scripts false widgets dont get there require calls
+				// does suck out possible widgetpackage registration as well
+				tmp = [];
+				while(tmp &amp;&amp; requires.length&lt;100){
+					tmp = sc.match(/dojo\.(?:(?:require(?:After)?(?:If)?)|(?:widget\.(?:manager\.)?registerWidgetPackage)|(?:(?:hostenv\.)?setModulePrefix))\((['&quot;]).*?\1\)\s*;?/);
+					if(!tmp){ break;}
+					requires.push(tmp[0]);
+					sc = sc.replace(tmp[0], &quot;&quot;);
+				}
+				scripts.push(sc);
+			}
+			s = s.replace(/&lt;script[^&gt;]*&gt;[\s\S]*?&lt;\/script&gt;/i, &quot;&quot;);
+		}
+
+		// scan for scriptScope in html eventHandlers and replace with link to this pane
+		if(this.executeScripts){
+			var regex = /(&lt;[a-zA-Z][a-zA-Z0-9]*\s[^&gt;]*\S=(['&quot;])[^&gt;]*[^\.\]])scriptScope([^&gt;]*&gt;)/;
+			var pos = 0;var str = &quot;&quot;;match = [];var cit = &quot;&quot;;
+			while(pos &gt; -1){
+				pos = s.search(regex);
+				if(pos &gt; -1){
+					cit = ((RegExp.$2==&quot;'&quot;) ? '&quot;': &quot;'&quot;);
+					str += s.substring(0, pos);
+					s = s.substr(pos).replace(regex, &quot;$1dojo.widget.byId(&quot;+ cit + this.widgetId + cit + &quot;).scriptScope$3&quot;);
+				}
+			}
+			s = str + s;
+		}
+
+		// cut out all &lt;link rel=&quot;stylesheet&quot; href=&quot;..&quot;&gt;
+		match = [];
+		while(match){
+			match = s.match(/&lt;link ([^&gt;]*rel=['&quot;]?stylesheet['&quot;]?[^&gt;]*)&gt;/i);
+			if(!match){ break; }
+			attr = match[1].match(/href=(['&quot;]?)([^'&quot;&gt;]*)\1/i);
+			if(attr){
+				linkStyles.push(attr[2]);
+			}
+			s = s.replace(new RegExp(match[0]), &quot;&quot;);
+		}
+
+		return {&quot;xml&quot;: s, // Object
+			&quot;styles&quot;: styles,
+			&quot;linkStyles&quot;: linkStyles,
+			&quot;titles&quot;: titles,
+			&quot;requires&quot;: 	requires,
+			&quot;scripts&quot;: scripts,
+			&quot;remoteScripts&quot;: remoteScripts,
+			&quot;url&quot;: url};
+	},
+
+	
+	_setContent: function(/*String*/ xml){
+		// summary: 
+		//		private internal function without path regExpCheck and no onLoad calls aftervards
+
+		// remove old children from current content
+		this.destroyChildren();
+
+		// remove old stylenodes from HEAD
+		if(this._remoteStyles){
+			for(var i = 0; i &lt; this._remoteStyles.length; i++){
+				if(this._remoteStyles[i] &amp;&amp; this._remoteStyles.parentNode){
+					this._remoteStyles[i].parentNode.removeChild(this._remoteStyles[i]);
+				}
+			}
+			this._remoteStyles = null;
+		}
+
+		var node = this.containerNode || this.domNode;
+		try{
+			if(typeof xml != &quot;string&quot;){
+				node.innerHTML = &quot;&quot;;
+				node.appendChild(xml);
+			}else{
+				node.innerHTML = xml;
+			}
+		} catch(e){
+			e = &quot;Could'nt load content:&quot;+e;
+			this._handleDefaults(e, &quot;onContentError&quot;);
+		}
+	},
+
+	setContent: function(/*String*/ data){
+		// summary:
+		// 	Destroys old content and setting new content, and possibly initialize any widgets within 'data'
+
+		if(this._callOnUnLoad){ // this tells a remote script clean up after itself
+			this.onUnLoad();
+		}
+		this._callOnUnLoad = true;
+
+		if(!data || dojo.dom.isNode(data)){
+			// if we do a clean using setContent(&quot;&quot;); or setContent(#node) bypass all parseing, extractContent etc
+			this._setContent(data);
+			this.onResized();
+			this.onLoad();
+		}else{
+			// need to run splitAndFixPaths? ie. manually setting content
+			 if((!data.xml)&amp;&amp;(this.adjustPaths)){
+				data = this.splitAndFixPaths(data);
+			}
+			if(this.extractContent) {
+				var matches = data.xml.match(/&lt;body[^&gt;]*&gt;\s*([\s\S]+)\s*&lt;\/body&gt;/im);
+				if(matches) { data.xml = matches[1]; }
+			}
+			// insert styleNodes, from &lt;style&gt;....
+			for(var i = 0; i &lt; data.styles.length; i++){
+				if(i==0){ 
+					this._remoteStyles = []; 
+				}
+				this._remoteStyles.push(dojo.style.insertCssText(data.styles[i]));
+			}
+			// insert styleNodes, from &lt;link href=&quot;...&quot;&gt;
+			for(var i = 0; i &lt; data.linkStyles.length; i++){
+				if(i==0){ 
+					this._remoteStyles = []; 
+				}
+				this._remoteStyles.push(dojo.style.insertCssFile(data.linkStyles[i]));
+			}
+			this._setContent(data.xml);
+
+			if(this.parseContent){
+				for(var i = 0; i &lt; data.requires.length; i++){
+					try{ 
+						eval(data.requires[i]);
+					} catch(e){
+						this._handleDefaults(e, &quot;onContentError&quot;, true);
+					}
+				}
+			}
+			// need to allow async load, Xdomain uses it
+			// is inline function because we cant send args to addOnLoad function
+			var _self = this;
+			function asyncParse(){
+				if(_self.executeScripts){
+					_self._executeScripts(data);
+				}
+
+				if(_self.parseContent){
+					var node = _self.containerNode || _self.domNode;
+					var parser = new dojo.xml.Parse();
+					var frag = parser.parseElement(node, null, true);
+					// createSubComponents not createComponents because frag has already been created
+					dojo.widget.getParser().createSubComponents(frag, _self);
+				}
+
+				_self.onResized();
+				_self.onLoad();
+			}
+			// try as long as possible to make setContent sync call
+			if(dojo.hostenv.isXDomain &amp;&amp; data.requires.length){
+				dojo.addOnLoad(asyncParse);
+			}else{
+				asyncParse();
+			}
+		}
+	},
+
+	// Generate pane content from given java function
+	setHandler: function(handler) {
+		var fcn = dojo.lang.isFunction(handler) ? handler : window[handler];
+		if(!dojo.lang.isFunction(fcn)) {
+			// FIXME: needs testing! somebody with java knowledge needs to try this
+			this._handleDefaults(&quot;Unable to set handler, '&quot; + handler + &quot;' not a function.&quot;, &quot;onExecError&quot;, true);
+			return;
+		}
+		this.handler = function() {
+			return fcn.apply(this, arguments);
+		}
+	},
+
+	_runHandler: function() {
+		if(dojo.lang.isFunction(this.handler)) {
+			this.handler(this, this.domNode);
+			return false;
+		}
+		return true;
+	},
+
+	_executeScripts: function(data) {
+		// do remoteScripts first
+		var self = this;
+		for(var i = 0; i &lt; data.remoteScripts.length; i++){
+			dojo.io.bind({
+				&quot;url&quot;: data.remoteScripts[i],
+				&quot;useCash&quot;:	this.cacheContent,
+				&quot;load&quot;:     function(type, scriptStr){
+						dojo.lang.hitch(self, data.scripts.push(scriptStr));
+				},
+				&quot;error&quot;:    function(type, error){
+						self._handleDefaults.call(self, type + &quot; downloading remote script&quot;, &quot;onExecError&quot;, true);
+				},
+				&quot;mimetype&quot;: &quot;text/plain&quot;,
+				&quot;sync&quot;:     true
+			});
+		}
+
+		var scripts = &quot;&quot;;
+		for(var i = 0; i &lt; data.scripts.length; i++){
+			scripts += data.scripts[i];
+		}
+
+		try{
+			// initialize a new anonymous container for our script, dont make it part of this widgets scope chain
+			// instead send in a variable that points to this widget, usefull to connect events to onLoad, onUnLoad etc..
+			this.scriptScope = null;
+			this.scriptScope = new (new Function('_container_', scripts+'; return this;'))(self);
+		}catch(e){
+			this._handleDefaults(&quot;Error running scripts from content:\n&quot;+e, &quot;onExecError&quot;, true);
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:ContentPane&quot;);

Added: trunk/root/static/magic/src/widget/html/ContextMenu.js
===================================================================
--- trunk/root/static/magic/src/widget/html/ContextMenu.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/ContextMenu.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,166 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.ContextMenu&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.ContextMenu&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+dojo.widget.html.ContextMenu = function(){
+	dojo.widget.ContextMenu.call(this);
+	dojo.widget.HtmlWidget.call(this);
+
+	this.isShowing = 0;
+	this.templatePath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlContextMenuTemplate.html&quot;);
+	this.templateCssPath = dojo.uri.dojoUri(&quot;src/widget/templates/Menu.css&quot;);
+
+	this.targetNodeIds = []; // fill this with nodeIds upon widget creation and it only responds to those nodes
+
+	// default event detection method 
+	var eventType = &quot;oncontextmenu&quot;; 
+
+	var doc = document.documentElement  || document.body; 
+
+	var _blockHide = false; 
+
+	this.fillInTemplate = function(args, frag){
+
+		var func = &quot;onOpen&quot;;
+		var attached = false;
+
+		// connect with rightclick if oncontextmenu is not around
+		// NOTE: It would be very nice to have a dojo.event.browser.supportsEvent here
+		// NOTE: Opera does not have rightclick events, it is listed here only because
+		//     it bails out when connecting with oncontextmenu event
+
+		if((dojo.render.html.khtml &amp;&amp; !dojo.render.html.safari) || (dojo.render.html.opera)){
+			eventType = &quot;onmousedown&quot;;
+			func = &quot;_checkRightClick&quot;;
+		}
+
+		// attach event listeners to our selected nodes
+		for(var i=0; i&lt;this.targetNodeIds.length; i++){
+			var node = document.getElementById(this.targetNodeIds[i]);
+			if(node){
+				dojo.event.connect(node, eventType, this, func);
+				attached = true;
+			}else{
+				// remove this nodeId
+				dojo.debug(&quot;Couldent find &quot;+this.targetNodeIds[i]+&quot;, cant do ContextMenu on this node&quot;);
+				this.targetNodeIds.splice(i,1);
+			}
+		}
+
+		// if we got attached to a node, hide on all non node contextevents
+		if(attached){ func = &quot;_canHide&quot;; }
+
+		dojo.event.connect(doc, eventType, this, func);
+	}
+
+	this.onOpen = function(evt){
+		// if (this.isShowing){ this.onHide(evt); } // propably not needed
+		this.isShowing = 1;
+
+		// if I do this, I cant preventDefault in khtml
+		//evt = dojo.event.browser.fixEvent(evt);
+ 
+		// stop default contextmenu, needed in khtml
+		if (evt.preventDefault){ evt.preventDefault(); }
+
+		// need to light up this one before we check width and height
+		this.domNode.style.left = &quot;-9999px&quot;;
+		this.domNode.style.top  = &quot;-9999px&quot;;
+		this.domNode.style.display = &quot;block&quot;;
+
+		// calculate if menu is going to apear within window
+		// or if its partially out of visable area
+		with(dojo.html){
+
+			var menuW = getInnerWidth(this.domNode);
+			var menuH = getInnerHeight(this.domNode);
+
+			var viewport = getViewportSize();
+			var scrolloffset = getScrollOffset();
+		}
+
+		var minX = viewport[0];
+		var minY = viewport[1];
+
+		var maxX = (viewport[0] + scrolloffset[0]) - menuW;
+		var maxY = (viewport[1] + scrolloffset[1]) - menuH;
+
+		var posX = evt.clientX + scrolloffset[0];
+		var posY = evt.clientY + scrolloffset[1];
+
+		if (posX &gt; maxX){ posX = posX - menuW; }
+		if (posY &gt; maxY){ posY = posY - menuH; }
+
+		this.domNode.style.left = posX + &quot;px&quot;;
+		this.domNode.style.top = posY + &quot;px&quot;;
+
+
+		// block the onclick that follows this particular right click
+		// not if the eventtrigger is documentElement and always when
+		// we use onmousedown hack
+		_blockHide = (evt.currentTarget!=doc || eventType=='onmousedown');
+
+		//return false; // we propably doesnt need to return false as we dont stop the event as we did before
+	}
+
+	/*
+	* _canHide is meant to block the onHide call that follows the event that triggered
+	* onOpen. This is (hopefully) faster that event.connect and event.disconnect every
+	* time the code executes and it makes connecting with onmousedown event possible
+	* and we dont have to stop the event from bubbling further.
+	*
+	* this code is moved into a separete function because it makes it possible for the
+	* user to connect to a onHide event, if anyone would like that.
+	*/
+
+	this._canHide = function(evt){
+		// block the onclick that follows the same event that turn on contextmenu
+		if(_blockHide){
+			// the onclick check is needed to prevent displaying multiple
+			// menus when we have 2 or more contextmenus loaded and are using
+			// the onmousedown hack
+			if(evt.type=='click' || eventType=='oncontextmenu'){
+				_blockHide = false;
+				return;
+			}else{
+				return;
+			}
+		}
+
+		this.onHide(evt);
+	}
+	
+	this.onHide = function(evt){
+		// FIXME: use whatever we use to do more general style setting?
+		this.domNode.style.display = &quot;none&quot;;
+		//dojo.event.disconnect(doc, &quot;onclick&quot;, this, &quot;onHide&quot;);
+		this.isShowing = 0;
+	}
+
+	// callback for rightclicks, needed for browsers that doesnt implement oncontextmenu, konqueror and more? 
+	this._checkRightClick = function(evt){ 
+
+		// for some reason konq comes here even when we are not clicking on the attached nodes 
+		// added check for targetnode 
+		if (evt.button==2 &amp;&amp; (this.targetNodeIds.length==0 || (evt.currentTarget.id!=&quot;&quot; &amp;&amp; dojo.lang.inArray(this.targetNodeIds, evt.currentTarget.id)))){
+
+			return this.onOpen(evt);
+		}
+	}
+
+	dojo.event.connect(doc, &quot;onclick&quot;, this, &quot;_canHide&quot;);
+}
+
+dojo.inherits(dojo.widget.html.ContextMenu, dojo.widget.HtmlWidget);

Added: trunk/root/static/magic/src/widget/html/DatePicker.js
===================================================================
--- trunk/root/static/magic/src/widget/html/DatePicker.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/DatePicker.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,346 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.DatePicker&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.DatePicker&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.date&quot;);
+
+/*
+	Some assumptions:
+	- I'm planning on always showing 42 days at a time, and we can scroll by week,
+	not just by month or year
+	- To get a sense of what month to highlight, I basically initialize on the 
+	first Saturday of each month, since that will be either the first of two or 
+	the second of three months being partially displayed, and then I work forwards 
+	and backwards from that point.
+	Currently, I assume that dates are stored in the RFC 3339 format,
+	because I find it to be most human readable and easy to parse
+	<A HREF="http://www.faqs.org/rfcs/rfc3339.html:">http://www.faqs.org/rfcs/rfc3339.html:</A> 		2005-06-30T08:05:00-07:00
+*/
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.DatePicker&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		classConstructor: function() {
+			// mixin dojo.widget.DatePicker non-demoninational code
+			dojo.widget.DatePicker.call(this);
+			// today's date, JS Date object
+			this.today = &quot;&quot;;
+			// selected date, JS Date object
+			this.date = &quot;&quot;;
+			// rfc 3339 date
+			this.storedDate = &quot;&quot;;
+			// date currently selected in the UI, stored in year, month, date in the format that will be actually displayed
+			this.currentDate = {};
+			// stored in year, month, date in the format that will be actually displayed
+			this.firstSaturday = {};
+		},
+		classNames: {
+			previous: &quot;previousMonth&quot;,
+			current: &quot;currentMonth&quot;,
+			next: &quot;nextMonth&quot;,
+			currentDate: &quot;currentDate&quot;,
+			selectedDate: &quot;selectedItem&quot;
+		},
+		templatePath:  dojo.uri.dojoUri(&quot;src/widget/templates/HtmlDatePicker.html&quot;),
+		templateCssPath:  dojo.uri.dojoUri(&quot;src/widget/templates/HtmlDatePicker.css&quot;),
+
+		fillInTemplate: function(){
+			dojo.widget.DatePicker.call(this);
+			this.initData();
+			this.initUI();
+		},
+		initData: function() {
+			this.today = new Date();
+			if(this.storedDate &amp;&amp; (this.storedDate.split(&quot;-&quot;).length &gt; 2)) {
+				this.date = dojo.widget.DatePicker.util.fromRfcDate(this.storedDate);
+			} else {
+				this.date = this.today;
+			}
+			// calendar math is simplified if time is set to 0
+			this.today.setHours(0);
+			this.date.setHours(0);
+			var month = this.date.getMonth();
+			var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(this.date.getMonth().toString(), this.date.getFullYear());
+			this.firstSaturday.year = tempSaturday.year;
+			this.firstSaturday.month = tempSaturday.month;
+			this.firstSaturday.date = tempSaturday.date;
+		},
+		
+		setDate: function(rfcDate) {
+			this.storedDate = rfcDate;
+		},
+		
+		initUI: function() {
+			this.selectedIsUsed = false;
+			this.currentIsUsed = false;
+			var currentClassName = &quot;&quot;;
+			var previousDate = new Date();
+			var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName(&quot;td&quot;);
+			var currentCalendarNode;
+			// set hours of date such that there is no chance of rounding error due to 
+			// time change in local time zones
+			previousDate.setHours(8);
+			var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
+			
+			if(this.firstSaturday.date &lt; 7) {
+				// this means there are days to show from the previous month
+				var dayInWeek = 6;
+				for (var i=this.firstSaturday.date; i&gt;0; i--) {
+					currentCalendarNode = calendarNodes.item(dayInWeek);
+					currentCalendarNode.innerHTML = nextDate.getDate();
+					dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;current&quot;));
+					dayInWeek--;
+					previousDate = nextDate;
+					nextDate = this.incrementDate(nextDate, false);
+				}
+				for(var i=dayInWeek; i&gt;-1; i--) {
+					currentCalendarNode = calendarNodes.item(i);
+					currentCalendarNode.innerHTML = nextDate.getDate();
+					dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;previous&quot;));
+					previousDate = nextDate;
+					nextDate = this.incrementDate(nextDate, false);				
+				}
+			} else {
+				nextDate.setDate(this.firstSaturday.date-6);
+				for(var i=0; i&lt;7; i++) {
+					currentCalendarNode = calendarNodes.item(i);
+					currentCalendarNode.innerHTML = nextDate.getDate();
+					dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;current&quot;));
+					previousDate = nextDate;
+					nextDate = this.incrementDate(nextDate, true);				
+				}
+			}
+			previousDate.setDate(this.firstSaturday.date);
+			previousDate.setMonth(this.firstSaturday.month);
+			previousDate.setFullYear(this.firstSaturday.year);
+			nextDate = this.incrementDate(previousDate, true);
+			var count = 7;
+			currentCalendarNode = calendarNodes.item(count);
+			while((nextDate.getMonth() == previousDate.getMonth()) &amp;&amp; (count&lt;42)) {
+				currentCalendarNode.innerHTML = nextDate.getDate();
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;current&quot;));
+				currentCalendarNode = calendarNodes.item(++count);
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, true);
+			}
+			
+			while(count &lt; 42) {
+				currentCalendarNode.innerHTML = nextDate.getDate();
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;next&quot;));
+				currentCalendarNode = calendarNodes.item(++count);
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, true);
+			}
+			this.setMonthLabel(this.firstSaturday.month);
+			this.setYearLabels(this.firstSaturday.year);
+		},
+		
+		incrementDate: function(date, bool) {
+			// bool: true to increase, false to decrease
+			var time = date.getTime();
+			var increment = 1000 * 60 * 60 * 24;
+			time = (bool) ? (time + increment) : (time - increment);
+			var returnDate = new Date();
+			returnDate.setTime(time);
+			return returnDate;
+		},
+		
+		incrementWeek: function(evt) {
+			var date = this.firstSaturday.date;
+			var month = this.firstSaturday.month;
+			var year = this.firstSaturday.year;
+			switch(evt.target) {
+				case this.increaseWeekNode.getElementsByTagName(&quot;img&quot;).item(0): 
+				case this.increaseWeekNode:
+					date = date + 7;
+					if (date&gt;this._daysIn(month,year)) {
+						date = date - this._daysIn(month,year);
+						if (month &lt; 11) {
+							month++;	
+						} else {
+							month=0;
+							year++;
+						}
+					}
+					break;
+				case this.decreaseWeekNode.getElementsByTagName(&quot;img&quot;).item(0):
+				case this.decreaseWeekNode:
+					if (date &gt; 7) {
+						date = date - 7;
+					} else {
+						var diff = 7 - date;
+						if (month &gt; 0) {
+							month--;
+							date = this._daysIn(month,year) - diff;
+						}else {
+							year--;
+							month=11;
+							date = 31 - diff;
+						}
+					}
+					break;
+	
+			}
+	
+			this.firstSaturday.date=date;
+			this.firstSaturday.month=month;
+			this.firstSaturday.year=year;
+			this.initUI();
+		},
+	
+		incrementMonth: function(evt) {
+			var month = this.firstSaturday.month;
+			var year = this.firstSaturday.year;
+			switch(evt.currentTarget) {
+				case this.increaseMonthNode:
+					if(month &lt; 11) {
+						month++;
+					} else {
+						month = 0;
+						year++;
+						
+						this.setYearLabels(year);
+					}
+					break;
+				case this.decreaseMonthNode:
+					if(month &gt; 0) {
+						month--;
+					} else {
+						month = 11;
+						year--;
+						this.setYearLabels(year);
+					}
+					break;
+				case this.increaseMonthNode.getElementsByTagName(&quot;img&quot;).item(0):
+					if(month &lt; 11) {
+						month++;
+					} else {
+						month = 0;
+						year++;
+						this.setYearLabels(year);
+					}
+					break;
+				case this.decreaseMonthNode.getElementsByTagName(&quot;img&quot;).item(0):
+					if(month &gt; 0) {
+						month--;
+					} else {
+						month = 11;
+						year--;
+						this.setYearLabels(year);
+					}
+					break;
+			}
+			var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(month.toString(), year);
+			this.firstSaturday.year = tempSaturday.year;
+			this.firstSaturday.month = tempSaturday.month;
+			this.firstSaturday.date = tempSaturday.date;
+			this.initUI();
+		},
+	
+		incrementYear: function(evt) {
+			var year = this.firstSaturday.year;
+			switch(evt.target) {
+				case this.nextYearLabelNode:
+					year++;
+					break;
+				case this.previousYearLabelNode:
+					year--;
+					break;
+			}
+			var tempSaturday = dojo.widget.DatePicker.util.initFirstSaturday(this.firstSaturday.month.toString(), year);
+			this.firstSaturday.year = tempSaturday.year;
+			this.firstSaturday.month = tempSaturday.month;
+			this.firstSaturday.date = tempSaturday.date;
+			this.initUI();
+		},
+	
+		_daysIn: function(month,year) {
+			var daysIn = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; 
+			
+			if (month==1) {
+				return (year%400 == 0) ? 29: (year%100 == 0) ? 28: (year%4 == 0) ? 29: 28;
+			} else {
+				return daysIn[month];
+			}
+		},
+	
+		onIncrementDate: function(evt) {
+			dojo.unimplemented('dojo.widget.html.DatePicker.onIncrementDate');
+		},
+	
+		onIncrementWeek: function(evt) {
+			evt.stopPropagation();
+			this.incrementWeek(evt);
+		},
+	
+		onIncrementMonth: function(evt) {
+			evt.stopPropagation();
+			this.incrementMonth(evt);
+		},
+		
+		onIncrementYear: function(evt) {
+			evt.stopPropagation();
+			this.incrementYear(evt);
+		},
+	
+		setMonthLabel: function(monthIndex) {
+			this.monthLabelNode.innerHTML = dojo.date.months[monthIndex];
+		},
+		
+		setYearLabels: function(year) {
+			this.previousYearLabelNode.innerHTML = year - 1;
+			this.currentYearLabelNode.innerHTML = year;
+			this.nextYearLabelNode.innerHTML = year + 1;
+		},
+		
+		getDateClassName: function(date, monthState) {
+			var currentClassName = this.classNames[monthState];
+			if ((!this.selectedIsUsed) &amp;&amp; (date.getDate() == this.date.getDate()) &amp;&amp; (date.getMonth() == this.date.getMonth()) &amp;&amp; (date.getFullYear() == this.date.getFullYear())) {
+				currentClassName = this.classNames.selectedDate + &quot; &quot; + currentClassName;
+				this.selectedIsUsed = 1;
+			}
+			if((!this.currentIsUsed) &amp;&amp; (date.getDate() == this.today.getDate()) &amp;&amp; (date.getMonth() == this.today.getMonth()) &amp;&amp; (date.getFullYear() == this.today.getFullYear())) {
+				currentClassName = currentClassName + &quot; &quot;  + this.classNames.currentDate;
+				this.currentIsUsed = 1;
+			}
+			return currentClassName;
+		},
+	
+		onClick: function(evt) {
+			dojo.event.browser.stopEvent(evt)
+		},
+		
+		onSetDate: function(evt) {
+			dojo.event.browser.stopEvent(evt);
+			this.selectedIsUsed = 0;
+			this.todayIsUsed = 0;
+			var month = this.firstSaturday.month;
+			var year = this.firstSaturday.year;
+			if (dojo.html.hasClass(evt.target, this.classNames[&quot;next&quot;])) {
+				month = ++month % 12;
+				// if month is now == 0, add a year
+				year = (month==0) ? ++year : year;
+			} else if (dojo.html.hasClass(evt.target, this.classNames[&quot;previous&quot;])) {
+				month = --month % 12;
+				// if month is now == 0, add a year
+				year = (month==11) ? --year : year;
+			}
+			this.date = new Date(year, month, evt.target.innerHTML);
+			this.setDate(dojo.widget.DatePicker.util.toRfcDate(this.date));
+			this.initUI();
+		}
+	}
+);

Added: trunk/root/static/magic/src/widget/html/DebugConsole.js
===================================================================
--- trunk/root/static/magic/src/widget/html/DebugConsole.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/DebugConsole.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,31 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.DebugConsole&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.FloatingPane&quot;);
+
+dojo.widget.html.DebugConsole= function(){
+
+	dojo.widget.html.FloatingPane.call(this);
+	dojo.widget.DebugConsole.call(this);
+}
+
+dojo.inherits(dojo.widget.html.DebugConsole, dojo.widget.html.FloatingPane);
+
+dojo.lang.extend(dojo.widget.html.DebugConsole, {
+	fillInTemplate: function() {
+		dojo.widget.html.DebugConsole.superclass.fillInTemplate.apply(this, arguments);
+		this.containerNode.id = &quot;debugConsoleClientPane&quot;;
+		djConfig.isDebug = true;
+		djConfig.debugContainerId = this.containerNode.id;
+	}
+});

Added: trunk/root/static/magic/src/widget/html/DocPane.js
===================================================================
--- trunk/root/static/magic/src/widget/html/DocPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/DocPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,210 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.DocPane&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+
+dojo.widget.html.DocPane = function(){
+	dojo.widget.HtmlWidget.call(this);
+
+	this.templatePath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlDocPane.html&quot;);
+	this.templateCssPath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlDocPane.css&quot;);
+	this.widgetType = &quot;DocPane&quot;;
+	this.isContainer = true;
+
+	this.select;
+	this.result;
+	this.fn;
+	this.fnLink;
+	this.count;
+	this.row;
+	this.summary;
+	this.description;
+	this.variables;
+	this.vRow;
+	this.vLink;
+	this.vDesc;
+	this.parameters;
+	this.pRow;
+	this.pLink;
+	this.pDesc;
+	this.pOpt;
+	this.pType;
+	this.source;
+	this.sType;
+	this.sName;
+	this.sParams;
+	this.sPType;
+	this.sPTypeSave;
+	this.sPName;
+	this.sPNameSave;
+
+	dojo.event.topic.subscribe(&quot;/doc/results&quot;, this, &quot;onDocResults&quot;);
+	dojo.event.topic.subscribe(&quot;/doc/functionDetail&quot;, this, &quot;onDocSelectFunction&quot;);
+}
+
+dojo.inherits(dojo.widget.html.DocPane, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.DocPane, {
+	fillInTemplate: function(){
+		this.homeSave = this.containerNode.cloneNode(true);
+		this.selectSave = dojo.dom.removeNode(this.select);
+		this.resultSave = dojo.dom.removeNode(this.result);
+		this.rowParent = this.row.parentNode;
+		this.rowSave = dojo.dom.removeNode(this.row);
+		this.vParent = this.vRow.parentNode;
+		this.vSave = dojo.dom.removeNode(this.vRow);
+		this.pParent = this.pRow.parentNode;
+		this.pSave = dojo.dom.removeNode(this.pRow);
+		this.sPTypeSave = dojo.dom.removeNode(this.sPType);
+		this.sPNameSave = dojo.dom.removeNode(this.sPName);
+	},
+
+	onDocSelectFunction: function(message){
+		var meta = message.meta;
+		if(meta){
+			var variables = meta.variables;
+			var this_variables = meta.this_variables;
+			var child_variables = meta.child_variables;
+			var parameters = meta.parameters;
+		}
+		var doc = message.doc;
+
+		var appends = [];
+		dojo.dom.removeChildren(this.domNode);
+		this.fn.innerHTML = message.name;
+		this.description.innerHTML = doc.description;
+
+		this.variables.style.display = &quot;block&quot;;
+		var all = [];
+		if(variables){
+			all = variables;
+		}
+		if(this_variables){
+			all = all.concat(this_variables);
+		}
+		if(child_variables){
+			all = all.concat(child_variables);
+		}
+		if(!all.length){
+			this.variables.style.display = &quot;none&quot;;
+		}else{
+			for(var i = 0, one; one = all[i]; i++){
+				this.vLink.innerHTML = one;
+				this.vDesc.parentNode.style.display = &quot;none&quot;;
+				appends.push(this.vParent.appendChild(this.vSave.cloneNode(true)));
+			}
+		}
+		
+		this.sParams.innerHTML = &quot;&quot;;
+		for(var param in parameters){
+			var paramType = parameters[param][0];
+			var paramName = parameters[param][1];
+			this.parameters.style.display = &quot;block&quot;;		
+			this.pLink.innerHTML = paramName;
+			this.pOpt.style.display = &quot;none&quot;;
+			if(parameters[param].opt){
+				this.pOpt.style.display = &quot;inline&quot;;				
+			}
+			this.pType.parentNode.style.display = &quot;none&quot;;
+			if(parameters[param][0]){
+				this.pType.parentNode.style.display = &quot;inline&quot;;
+				this.pType.innerHTML = paramType;
+			}
+			this.pDesc.parentNode.style.display = &quot;none&quot;;
+			if(doc.parameters[paramName] &amp;&amp; doc.parameters[paramName].description){
+				this.pDesc.parentNode.style.display = &quot;inline&quot;;
+				this.pDesc.innerHTML = doc.parameters[paramName].description;
+			}
+			appends.push(this.pParent.appendChild(this.pSave.cloneNode(true)));
+			
+			if(param &gt; 0) {
+				this.sParams.appendChild(document.createTextNode(&quot;, &quot;));
+			}
+			if(paramType){
+				dojo.debug(this.sPTypeSave);
+				this.sPTypeSave.innerHTML = paramType;
+				this.sParams.appendChild(this.sPTypeSave.cloneNode(true));
+				this.sParams.appendChild(document.createTextNode(&quot; &quot;));
+			}
+			dojo.debug(this.sPNameSave);
+			this.sPNameSave.innerHTML = paramName;
+			this.sParams.appendChild(this.sPNameSave.cloneNode(true))
+		}
+
+		if(message.returns){
+			this.sType.innerHTML = message.returns;
+		}else{
+			this.sType.innerHTML = &quot;void&quot;;
+		}
+		
+		this.sName.innerHTML = message.name;
+		
+		dojo.dom.removeChildren(this.source);
+                this.source.appendChild(document.createTextNode(&quot;\n\r&quot;));
+		this.source.appendChild(document.createTextNode(message.src.replace(/\n/g, &quot;\r\n\t&quot;)));
+                this.source.appendChild(document.createTextNode(&quot;\n\r&quot;));
+		
+		this.domNode.appendChild(this.selectSave.cloneNode(true));
+
+		for(var i = 0, append; append = appends[i]; i++){
+			dojo.dom.removeNode(append);
+		}
+	},
+
+	onDocResults: function(message){
+		var results = message.docResults;
+		
+		if(results.length == 1){
+			dojo.event.topic.publish(&quot;/doc/selectFunction&quot;, results[0]);
+			return;
+		}
+
+		dojo.dom.removeChildren(this.domNode);
+
+		this.count.innerHTML = results.length;
+		var appends = [];
+		for(var i = 0, row; row = results[i]; i++){
+			this.fnLink.innerHTML = row.name;
+			this.fnLink.href = &quot;#&quot; + row.name;
+			if(row.id){
+				this.fnLink.href = this.fnLink.href + &quot;,&quot; + row.id;	
+			}
+			this.summary.parentNode.style.display = &quot;none&quot;;
+			if(row.summary){
+				this.summary.parentNode.style.display = &quot;inline&quot;;				
+				this.summary.innerHTML = row.summary;
+			}
+			appends.push(this.rowParent.appendChild(this.rowSave.cloneNode(true)));
+		}
+		
+		function makeSelect(x){
+			return function(e) {
+				dojo.event.topic.publish(&quot;/doc/selectFunction&quot;, x);
+			}
+		}
+
+		this.domNode.appendChild(this.resultSave.cloneNode(true));
+		var as = this.domNode.getElementsByTagName(&quot;a&quot;);
+		for(var i = 0, a; a = as[i]; i++){
+			dojo.event.connect(a, &quot;onclick&quot;, makeSelect(results[i]));
+		}
+		
+		for(var i = 0, append; append = appends[i]; i++){
+			this.rowParent.removeChild(append);
+		}
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:DocPane&quot;);

Added: trunk/root/static/magic/src/widget/html/DropdownButton.js
===================================================================
--- trunk/root/static/magic/src/widget/html/DropdownButton.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/DropdownButton.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,188 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/* TODO:
+ * - make the dropdown &quot;smart&quot; so it can't get cutoff on bottom of page, sides of page, etc.
+ */
+
+dojo.provide(&quot;dojo.widget.html.DropdownButton&quot;);
+
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.uri.Uri&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.html.DropdownButton = function() {
+	// mix in the button properties
+	dojo.widget.DropdownButton.call(this);
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.DropdownButton, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.DropdownButton, {
+	
+	// In IE, event handlers on objects inside buttons don't work correctly, so
+	// we just set onClick on the button itself.
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlDropDownButtonTemplate.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlButtonTemplate.css&quot;),
+
+	// attach points
+	button: null,
+	table: null,
+	labelCell: null,
+	borderCell: null,
+	arrowCell: null,
+	arrow: null,
+
+	fillInTemplate: function(args, frag) {
+		// input data (containing the anchor for the button itself, plus the
+		// thing to display when you push the down arrow)
+		var input = frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()][&quot;nodeRef&quot;];
+
+		// Recursively expand widgets inside of the &lt;dojo:dropdownButton&gt;
+		var parser = new dojo.xml.Parse();
+		var frag = parser.parseElement(input, null, true);
+		var ary = dojo.widget.getParser().createComponents(frag);
+
+		this.a = dojo.dom.getFirstChildElement(input);	// the button contents
+		this.menu = dojo.dom.getNextSiblingElement(this.a);	// the menu under the button
+		
+		this.disabled = dojo.html.hasClass(this.a, &quot;disabled&quot;);
+		if( this.disabled ) {
+			dojo.html.addClass(this.button, &quot;dojoDisabled&quot;);
+			this.domNode.setAttribute(&quot;disabled&quot;, &quot;true&quot;);
+		}
+
+		dojo.html.disableSelection(this.a);
+		this.a.style[&quot;text-decoration&quot;]=&quot;none&quot;;
+		this.labelCell.appendChild(this.a);
+
+		this.arrow.src =
+			dojo.uri.dojoUri(&quot;src/widget/templates/images/dropdownButtonsArrow&quot; +
+			(this.disabled ? &quot;-disabled&quot; : &quot;&quot;) + &quot;.gif&quot;);
+
+		// Attach menu to body so that it appears above other buttons
+		this.menu.style.position=&quot;absolute&quot;;
+		this.menu.style.display=&quot;none&quot;;
+		this.menu.style[&quot;z-index&quot;] = 99;
+		document.body.appendChild(this.menu);
+	},
+
+	postCreate: function() {
+		if ( dojo.render.html.ie ) {
+			// Compensate for IE's weird padding of button content, which seems to be relative
+			// to the length of the content
+			var contentWidth = dojo.style.getOuterWidth(this.table);
+			this.labelCell.style[&quot;left&quot;] = &quot;-&quot; + (contentWidth / 10) + &quot;px&quot;;
+			this.arrowCell.style[&quot;left&quot;] = (contentWidth / 10) + &quot;px&quot;;
+		}
+
+		// Make menu at least as wide as the button
+		var buttonWidth = dojo.style.getOuterWidth(this.button);
+		var menuWidth = dojo.style.getOuterWidth(this.menu);
+		if ( buttonWidth &gt; menuWidth ) {
+			dojo.style.setOuterWidth(this.menu, buttonWidth);
+		}
+	},
+
+	// If someone clicks anywhere else on the screen (including another menu),
+	// then close this menu.
+	onCanvasMouseDown: function(e) {
+		if( !dojo.dom.isDescendantOf(e.target, this.button) &amp;&amp;
+			!dojo.dom.isDescendantOf(e.target, this.menu) ) {
+			this.hideMenu();
+		}
+	},
+
+	eventWasOverArrow: function(e) {
+		// want to use dojo.html.overElement() but also need to detect clicks
+		// on the area between the arrow and the edge of the button
+		var eventX = e.clientX;
+		var borderX = dojo.style.totalOffsetLeft(this.borderCell);
+		return (eventX &gt; borderX );
+	},
+
+	onMouseOver: function(e) {
+		dojo.html.addClass(this.button, &quot;dojoButtonHover&quot;);
+		dojo.html.removeClass(this.button, &quot;dojoButtonNoHover&quot;);
+	},
+	
+	onMouseOut: function(e) {
+		dojo.html.removeClass(this.button, &quot;dojoButtonHover&quot;);
+		dojo.html.addClass(this.button, &quot;dojoButtonNoHover&quot;);
+	},
+
+	onClick: function(e) {
+		if ( this.eventWasOverArrow(e) ) {
+			this._onClickArrow();
+		} else {
+			this._onClickButton();
+		}
+	},
+
+	// Action when the user presses the button
+	_onClickButton: function(e) {
+		if ( this.a ) {
+			if ( this.a.click ) {
+				this.a.click();
+			} else if ( this.a.href ) {
+				location.href = this.a.href;
+			}
+		}
+	},
+
+	// Action when user presses the arrow
+	_onClickArrow: function() {
+		if ( this.menu.style.display == &quot;none&quot; ) {
+			this.showMenu();
+		} else {
+			this.hideMenu();
+		}
+	},
+	
+	showMenu: function() {
+		if ( this.disabled )
+			return;
+
+		// Position it accordingly, relative to screen root (since
+		// it's attached to document.body)
+		this.menu.style.left = dojo.style.totalOffsetLeft(this.button) + &quot;px&quot;;
+		this.menu.style.top = dojo.style.totalOffsetTop(this.button) + dojo.style.getOuterHeight(this.button) + &quot;px&quot;;
+
+		// Display the menu; do this funky code below to stop the menu from extending
+		// all the way to the right edge of the screen.
+		// TODO: retest simple display=&quot;&quot; to confirm that it doesn't work.
+		try {
+			this.menu.style.display=&quot;table&quot;;	// mozilla
+		} catch(e) {
+			this.menu.style.display=&quot;block&quot;;	// IE
+		}
+
+		// If someone clicks somewhere else on the screen then close the menu
+		dojo.event.connect(document.documentElement, &quot;onmousedown&quot;, this, &quot;onCanvasMouseDown&quot;);
+		
+		// When someone clicks the menu, after the menu handles the event,
+		// close the menu (be careful not to close the menu too early or else
+		// the menu will never receive the event.)
+		dojo.event.connect(this.menu, &quot;onclick&quot;, this, &quot;hideMenu&quot;);
+	},
+
+	hideMenu: function() {
+		this.menu.style.display = &quot;none&quot;;
+		dojo.event.disconnect(document.documentElement, &quot;onmousedown&quot;, this, &quot;onCanvasMouseDown&quot;);
+		dojo.event.disconnect(this.menu, &quot;onclick&quot;, this, &quot;hideMenu&quot;);
+	}
+});
+
+

Added: trunk/root/static/magic/src/widget/html/GoogleMap.js
===================================================================
--- trunk/root/static/magic/src/widget/html/GoogleMap.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/GoogleMap.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,198 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.GoogleMap&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.math&quot;);
+dojo.require(&quot;dojo.uri.Uri&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.GoogleMap&quot;);
+
+(function(){
+	var gkey = djConfig[&quot;gMapKey&quot;]||djConfig[&quot;googleMapKey&quot;];
+
+	//	the Google API key mechanism sucks.  We're hardcoding here for love and affection but I don't like it.
+	var uri=new dojo.uri.Uri(window.location.href);
+	if(uri.host==&quot;www.dojotoolkit.org&quot;){
+		gkey=&quot;ABQIAAAACUNdgv_7FGOmUslbm9l6_hRqjp7ri2mNiOEYqetD3xnFHpt5rBSjszDd1sdufPyQKUTyCf_YxoIxvw&quot;;
+	}
+	else if(uri.host==&quot;blog.dojotoolkit.org&quot;){
+		gkey=&quot;ABQIAAAACUNdgv_7FGOmUslbm9l6_hSkep6Av1xaMhVn3yCLkorJeXeLARQ6fammI_P3qSGleTJhoI5_1JmP_Q&quot;;
+	}
+	else if(uri.host==&quot;archive.dojotoolkit.org&quot;){
+		gkey=&quot;ABQIAAAACUNdgv_7FGOmUslbm9l6_hTaQpDt0dyGLIHbXMPTzg1kWeAfwRTwZNyrUfbfxYE9yIvRivEjcXoDTg&quot;;
+	}
+	else if(uri.host==&quot;dojotoolkit.org&quot;){
+		gkey=&quot;ABQIAAAACUNdgv_7FGOmUslbm9l6_hSaOaO_TgJ5c3mtQFnk5JO2zD5dZBRZk-ieqVs7BORREYNzAERmcJoEjQ&quot;;
+	}
+
+	if(!dojo.hostenv.post_load_){
+		var tag = &quot;&lt;scr&quot;+&quot;ipt src='<A HREF="http://maps.google.com/maps?file=api&amp;amp;v=2&amp;amp;key=">http://maps.google.com/maps?file=api&amp;v=2&amp;key=</A>&quot;+gkey+&quot;'&gt;&lt;/scri&quot;+&quot;pt&gt;&quot;;
+		if(!dj_global[&quot;GMap2&quot;]){ // prevent multi-inclusion
+			document.write(tag);
+		}
+	}else{
+		dojo.debug(&quot;cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Google in your page or require() the GoogleMap widget before onload has fired&quot;);
+	}
+})();
+
+dojo.widget.html.GoogleMap=function(){
+	dojo.widget.HtmlWidget.call(this);
+	dojo.widget.GoogleMap.call(this);
+
+	var gm=dojo.widget.GoogleMap;
+
+	this.map=null;
+	this.data=[];
+	this.datasrc=&quot;&quot;;
+	// FIXME: this is pehraps the stupidest way to specify this enum I can think of
+	this.controls=[gm.Controls.LargeMap,gm.Controls.Scale,gm.Controls.MapType];
+};
+dojo.inherits(dojo.widget.html.GoogleMap, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.GoogleMap, {
+	templatePath:null,
+	templateCssPath:null,
+
+	setControls:function(){
+		var c=dojo.widget.GoogleMap.Controls;
+		for(var i=0; i&lt;this.controls.length; i++){
+			var type=this.controls[i];
+			switch(type){
+				case c.LargeMap:{
+					this.map.addControl(new GLargeMapControl());
+					break;
+				}
+				case c.SmallMap:{
+					this.map.addControl(new GSmallMapControl());
+					break;
+				}
+				case c.SmallZoom:{
+					this.map.addControl(new GSmallZoomControl());
+					break;
+				}
+				case c.Scale:{
+					this.map.addControl(new GScaleControl());
+					break;
+				}
+				case c.MapType:{
+					this.map.addControl(new GMapTypeControl());
+					break;
+				}
+				case c.Overview:{
+					this.map.addControl(new GOverviewMapControl());
+					break;
+				}
+				default:{
+					break;
+				}
+			}
+		}
+	},
+	
+	findCenter:function(bounds){
+		var clat=(bounds.getNorthEast().lat()+bounds.getSouthWest().lat())/2;
+		var clng=(bounds.getNorthEast().lng()+bounds.getSouthWest().lng())/2;
+		return (new GLatLng(clat,clng));
+	},
+
+	createPinpoint:function(pt,overlay){
+		var m=new GMarker(pt);
+		if(overlay){
+			GEvent.addListener(m,&quot;click&quot;,function(){
+				m.openInfoWindowHtml(&quot;&lt;div&gt;&quot;+overlay+&quot;&lt;/div&gt;&quot;);
+			});
+		}
+		return m;
+	},
+
+	parse:function(table){
+		this.data=[];
+
+		//	get the column indices
+		var h=table.getElementsByTagName(&quot;thead&quot;)[0];
+		if(!h){
+			return;
+		}
+
+		var a=[];
+		var cols=h.getElementsByTagName(&quot;td&quot;);
+		if(cols.length==0){
+			cols=h.getElementsByTagName(&quot;th&quot;);
+		}
+		for(var i=0; i&lt;cols.length; i++){
+			var c=cols[i].innerHTML.toLowerCase();
+			if(c==&quot;long&quot;) c=&quot;lng&quot;;
+			a.push(c);
+		}
+		
+		//	parse the data
+		var b=table.getElementsByTagName(&quot;tbody&quot;)[0];
+		if(!b){
+			return;
+		}
+		for(var i=0; i&lt;b.childNodes.length; i++){
+			if(!(b.childNodes[i].nodeName&amp;&amp;b.childNodes[i].nodeName.toLowerCase()==&quot;tr&quot;)){
+				continue;
+			}
+			var cells=b.childNodes[i].getElementsByTagName(&quot;td&quot;);
+			var o={};
+			for(var j=0; j&lt;a.length; j++){
+				var col=a[j];
+				if(col==&quot;lat&quot;||col==&quot;lng&quot;){
+					o[col]=parseFloat(cells[j].innerHTML);					
+				}else{
+					o[col]=cells[j].innerHTML;
+				}
+			}
+			this.data.push(o);
+		}
+	},
+	render:function(){
+		var bounds=new GLatLngBounds();
+		var d=this.data;
+		var pts=[];
+		for(var i=0; i&lt;d.length; i++){
+			bounds.extend(new GLatLng(d[i].lat,d[i].lng));
+		}
+
+		this.map.setCenter(this.findCenter(bounds), this.map.getBoundsZoomLevel(bounds));
+
+		for(var i=0; i&lt;this.data.length; i++){
+			var p=new GLatLng(this.data[i].lat,this.data[i].lng);
+			var d=this.data[i].description||null;
+			var m=this.createPinpoint(p,d);
+			this.map.addOverlay(m);
+		}
+	},
+	
+
+	initialize:function(args, frag){
+		if(!GMap2){
+			dojo.raise(&quot;dojo.widget.GoogleMap: The Google Map script must be included (with a proper API key) in order to use this widget.&quot;);
+		}
+		if(this.datasrc){
+			this.parse(dojo.byId(this.datasrc));
+		}
+		else if(this.domNode.getElementsByTagName(&quot;table&quot;)[0]){
+			this.parse(this.domNode.getElementsByTagName(&quot;table&quot;)[0]);
+		}
+	},
+	postCreate:function(){
+		//	clean the domNode before creating the map.
+		while(this.domNode.childNodes.length&gt;0){
+			this.domNode.removeChild(this.domNode.childNodes[0]);
+		}
+		this.map=new GMap2(this.domNode);
+		this.render();
+		this.setControls();
+	}
+});

Added: trunk/root/static/magic/src/widget/html/LinkPane.js
===================================================================
--- trunk/root/static/magic/src/widget/html/LinkPane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/LinkPane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,54 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.LinkPane&quot;);
+dojo.provide(&quot;dojo.widget.html.LinkPane&quot;);
+
+//
+// a div that loads from a URL.  (Similar to an iframe, but
+// it's in the same environment as the main window)
+//
+
+dojo.require(&quot;dojo.widget.LinkPane&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.widget.ContentPane&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.string&quot;);
+
+
+dojo.widget.html.LinkPane = function(){
+	dojo.widget.html.ContentPane.call(this);
+}
+
+dojo.inherits(dojo.widget.html.LinkPane, dojo.widget.html.ContentPane);
+
+dojo.lang.extend(dojo.widget.html.LinkPane, {
+	widgetType: &quot;LinkPane&quot;,
+
+	// I'm using a template because the user may specify the input as
+	// &lt;a href=&quot;foo.html&quot;&gt;label&lt;/a&gt;, in which case we need to get rid of the
+	// &lt;a&gt; because we don't want a link.
+	templateString: '&lt;div class=&quot;dojoLinkPane&quot;&gt;&lt;/div&gt;',
+
+	fillInTemplate: function(args, frag){
+		var source = this.getFragNodeRef(frag);
+
+		// If user has specified node contents, they become the label
+		// (the link must be plain text)
+		this.label += source.innerHTML;
+
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+	}
+});

Added: trunk/root/static/magic/src/widget/html/Menu.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Menu.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Menu.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,51 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.widget.Menu&quot;);
+dojo.provide(&quot;dojo.widget.html.Menu&quot;);
+
+/* HtmlMenu
+ ***********/
+ 
+dojo.widget.html.Menu = function(){
+	dojo.widget.html.Menu.superclass.constructor.call(this);
+	this.items = [];
+}
+dojo.inherits(dojo.widget.html.Menu, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.Menu, {
+	widgetType: &quot;Menu&quot;,
+	isContainer: true,
+
+	// copy children widgets output directly to parent (this node), to avoid
+	// errors trying to insert an &lt;li&gt; under a &lt;div&gt;
+	snarfChildDomOutput: true,
+
+	templateString: '&lt;ul&gt;&lt;/ul&gt;',
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/Menu.css&quot;),
+	
+	fillInTemplate: function (args, frag){
+		//dojo.widget.HtmlMenu.superclass.fillInTemplate.apply(this, arguments);
+		this.domNode.className = &quot;dojoMenu&quot;;
+	},
+	
+ 
+	_register: function (item ) {
+		dojo.event.connect(item, &quot;onSelect&quot;, this, &quot;onSelect&quot;);
+		this.items.push(item);
+	},
+
+	push: function (item) {
+		this.domNode.appendChild(item.domNode);
+		this._register(item);
+	}
+
+});
+

Added: trunk/root/static/magic/src/widget/html/MenuItem.js
===================================================================
--- trunk/root/static/magic/src/widget/html/MenuItem.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/MenuItem.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,60 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.MenuItem&quot;);
+
+/* HtmlMenuItem
+ ***************/
+
+dojo.widget.html.MenuItem = function(){
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.MenuItem, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.MenuItem, {
+	widgetType: &quot;MenuItem&quot;,
+	templateString: '&lt;li class=&quot;dojoMenuItem&quot; dojoAttachEvent=&quot;onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick;&quot;&gt;&lt;/li&gt;',
+	title: &quot;&quot;,
+
+	fillInTemplate: function(args, frag){
+		dojo.html.disableSelection(this.domNode);
+
+		if(!dojo.string.isBlank(this.title)){
+			this.domNode.appendChild(document.createTextNode(this.title));
+		}else{
+			this.domNode.appendChild(frag[&quot;dojo:&quot;+this.widgetType.toLowerCase()][&quot;nodeRef&quot;]);
+		}
+	},
+	
+	onMouseOver: function(e){
+		dojo.html.addClass(this.domNode, &quot;dojoMenuItemHover&quot;);
+	},
+	
+	onMouseOut: function(e){
+		dojo.html.removeClass(this.domNode, &quot;dojoMenuItemHover&quot;);
+	},
+	
+	onClick: function(e){ this.onSelect(this, e); },
+	onMouseDown: function(e){},
+	onMouseUp: function(e){},
+	
+	// By default, when I am clicked, click the item inside of me
+	onSelect: function (item, e) {
+		var child = dojo.dom.getFirstChildElement(this.domNode);
+		if(child){
+			if(child.click){
+				child.click();
+			}else if(child.href){
+				location.href = child.href;
+			}
+		}
+	}
+});
+

Added: trunk/root/static/magic/src/widget/html/MonthlyCalendar.js
===================================================================
--- trunk/root/static/magic/src/widget/html/MonthlyCalendar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/MonthlyCalendar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,134 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.MonthlyCalendar&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.html.DatePicker&quot;);
+dojo.require(&quot;dojo.widget.MonthlyCalendar&quot;);
+//dojo.require(&quot;dojo.widget.MonthlyCalendar.util&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.html.MonthlyCalendar= function(){
+	dojo.widget.MonthlyCalendar.call(this);
+	//dojo.widget.html.DatePicker.call(this);
+	this.widgetType = &quot;MonthlyCalendar&quot;;
+	this.templatePath =  dojo.uri.dojoUri(&quot;src/widget/templates/HtmlMonthlyCalendar.html&quot;);
+	this.templateCssPath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlMonthlyCalendar.css&quot;);
+
+	this.iCalendars = [];
+}
+
+dojo.inherits(dojo.widget.html.MonthlyCalendar, dojo.widget.html.DatePicker);
+
+dojo.lang.extend(dojo.widget.html.MonthlyCalendar, {
+	cache: function() {
+	},
+
+	addCalendar: function(/* dojo.iCalendar */ cal) {
+		dojo.debug(&quot;Adding Calendar&quot;);
+		this.iCalendars.push(cal);
+		dojo.debug(&quot;Starting init&quot;);
+		this.initUI()
+		dojo.debug(&quot;done init&quot;);
+	},
+
+	createDayContents: function(node,mydate) {
+		dojo.dom.removeChildren(node);
+		node.appendChild(document.createTextNode(mydate.getDate()));	
+			for(var x=0; x&lt;this.iCalendars.length; x++) {
+				var evts = this.iCalendars[x].getEvents(mydate);
+				if ((dojo.lang.isArray(evts)) &amp;&amp; (evts.length&gt;0)) {
+				for(var y=0;y&lt;evts.length;y++) {
+					var el = document.createElement(&quot;div&quot;);
+					dojo.html.addClass(el, &quot;dojoMonthlyCalendarEvent&quot;);          
+					el.appendChild(document.createTextNode(evts[y].summary.value));
+					el.width = dojo.style.getContentWidth(node);
+					node.appendChild(el);
+				}
+			}
+		}
+	},
+
+	initUI: function() {
+		this.selectedIsUsed = false;
+		this.currentIsUsed = false;
+		var currentClassName = &quot;&quot;;
+		var previousDate = new Date();
+		var calendarNodes = this.calendarDatesContainerNode.getElementsByTagName(&quot;td&quot;);
+		var currentCalendarNode;
+		// set hours of date such that there is no chance of rounding error due to 
+		// time change in local time zones
+		previousDate.setHours(8);
+		var nextDate = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date, 8);
+		var lastDay = new Date(this.firstSaturday.year, this.firstSaturday.month, this.firstSaturday.date + 42, 8);
+		
+		if (this.iCalendars.length &gt; 0) {
+			for (var x=0; x&lt;this.iCalendars.length;x++) {
+				this.iCalendars[x].preComputeRecurringEvents(lastDay);
+			}
+		}
+
+		if(this.firstSaturday.date &lt; 7) {
+			// this means there are days to show from the previous month
+			var dayInWeek = 6;
+			for (var i=this.firstSaturday.date; i&gt;0; i--) {
+				currentCalendarNode = calendarNodes.item(dayInWeek);
+				this.createDayContents(currentCalendarNode, nextDate);
+				
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;current&quot;));
+				dayInWeek--;
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, false);
+			}
+			for(var i=dayInWeek; i&gt;-1; i--) {
+				currentCalendarNode = calendarNodes.item(i);
+
+				this.createDayContents(currentCalendarNode, nextDate);
+
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;previous&quot;));
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, false);				
+			}
+		} else {
+			nextDate.setDate(1);
+			for(var i=0; i&lt;7; i++) {
+				currentCalendarNode = calendarNodes.item(i);
+				this.createDayContents(currentCalendarNode, nextDate);
+				dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;current&quot;));
+				previousDate = nextDate;
+				nextDate = this.incrementDate(nextDate, true);				
+			}
+		}
+		previousDate.setDate(this.firstSaturday.date);
+		previousDate.setMonth(this.firstSaturday.month);
+		previousDate.setFullYear(this.firstSaturday.year);
+		nextDate = this.incrementDate(previousDate, true);
+		var count = 7;
+		currentCalendarNode = calendarNodes.item(count);
+		while((nextDate.getMonth() == previousDate.getMonth()) &amp;&amp; (count&lt;42)) {
+			this.createDayContents(currentCalendarNode, nextDate);
+			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;current&quot;));
+			currentCalendarNode = calendarNodes.item(++count);
+			previousDate = nextDate;
+			nextDate = this.incrementDate(nextDate, true);
+		}
+		
+		while(count &lt; 42) {
+			this.createDayContents(currentCalendarNode, nextDate);
+			dojo.html.setClass(currentCalendarNode, this.getDateClassName(nextDate, &quot;next&quot;));
+			currentCalendarNode = calendarNodes.item(++count);
+			previousDate = nextDate;
+			nextDate = this.incrementDate(nextDate, true);
+		}
+		this.setMonthLabel(this.firstSaturday.month);
+		this.setYearLabels(this.firstSaturday.year);
+	}	
+});

Added: trunk/root/static/magic/src/widget/html/Show.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Show.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Show.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,177 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.Show&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.Show&quot;);
+dojo.require(&quot;dojo.uri.Uri&quot;);
+dojo.require(&quot;dojo.event&quot;);
+dojo.require(&quot;dojo.animation.Animation&quot;);
+dojo.require(&quot;dojo.math.curves&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.lang.func&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Show&quot;,
+	dojo.widget.HtmlWidget,
+	null,
+	&quot;html&quot;,
+	function(){
+		dojo.widget.Show.call(this);
+	}
+);
+dojo.lang.extend(dojo.widget.html.Show, dojo.widget.Show.prototype);
+dojo.lang.extend(dojo.widget.html.Show, {
+	body: null,
+	nav: null,
+	hider: null,
+	select: null,
+	option: null,
+	inNav: false,
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlShow.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlShow.css&quot;),
+	fillInTemplate: function(args, frag){
+		var source = this.getFragNodeRef(frag);
+		this.sourceNode = document.body.appendChild(source.cloneNode(true));
+		for(var i = 0, child; child = this.sourceNode.childNodes[i]; i++){
+			if(child.tagName &amp;&amp; child.getAttribute(&quot;dojotype&quot;).toLowerCase() == &quot;showslide&quot;){
+				child.className = &quot;dojoShowPrintSlide&quot;;
+				child.innerHTML = &quot;&lt;h1&gt;&quot; + child.title + &quot;&lt;/h1&gt;&quot; + child.innerHTML;
+			}
+		}
+		this.sourceNode.className = &quot;dojoShowPrint&quot;;
+		this.sourceNode.style.display = &quot;none&quot;;
+		
+		dojo.event.connect(document, &quot;onclick&quot;, this, &quot;gotoSlideByEvent&quot;);
+		dojo.event.connect(document, &quot;onkeypress&quot;, this, &quot;gotoSlideByEvent&quot;);
+		dojo.event.connect(window, &quot;onresize&quot;, this, &quot;resizeWindow&quot;);
+		dojo.event.connect(this.nav, &quot;onmousemove&quot;, this, &quot;popUpNav&quot;);
+	},
+	postCreate: function(){		
+		this._slides = [];
+		for(var i = 0, child; child = this.children[i]; i++){
+			if(child.widgetType == &quot;ShowSlide&quot;){
+				this._slides.push(child);
+				this.option.text = child.title;
+				this.option.parentNode.insertBefore(this.option.cloneNode(true), this.option);
+			}
+		}
+		this.option.parentNode.removeChild(this.option);
+
+		document.body.style.display = &quot;block&quot;;
+		this.resizeWindow();
+		this.gotoSlide(0);
+	},
+	gotoSlide: function(/*int*/ slide){
+		if(slide == this._slide){
+			return;
+		}
+
+		if(!this._slides[slide]){
+			// slide: string
+			for(var i = 0, child; child = this._slides[i]; i++){
+				if(child.title == slide){
+					slide = i;
+					break;
+				}
+			}
+		}
+		
+		if(!this._slides[slide]){
+			return;
+		}
+		
+		if(this._slide != -1){
+			while(this._slides[this._slide].previousAction()){}
+		}
+		
+		this._slide = slide;
+		this.select.selectedIndex = slide;
+		while(this.contentNode.hasChildNodes()){ this.contentNode.removeChild(this.contentNode.firstChild); }
+		this.contentNode.appendChild(this._slides[slide].domNode);
+	},
+	gotoSlideByEvent: function(/*Event*/ event){
+		var node = event.target;
+		var type = event.type;
+		if(type == &quot;click&quot;){
+			if(node.tagName == &quot;OPTION&quot;){
+				this.gotoSlide(node.index);
+			}else if(node.tagName == &quot;SELECT&quot;){
+				this.gotoSlide(node.selectedIndex);
+			}else if(node.tagName != &quot;A&quot;){
+				this.nextSlide(event);
+			}
+		}else if(type == &quot;keypress&quot;){
+			var key = event.keyCode;
+			var ch = event.charCode;
+			if(key == 63234 || key == 37){
+				this.previousSlide(event);
+			}else if(key == 63235 || key == 39 || ch == 32){
+				this.nextSlide(event);
+			}
+		}
+	},
+	nextSlide: function(/*Event?*/ event){
+		this.stopEvent(event);
+		return dojo.widget.Show.prototype.nextSlide.call(this, event);
+	},
+	previousSlide: function(/*Event?*/ event){
+		this.stopEvent(event);
+		return dojo.widget.Show.prototype.previousSlide.call(this, event);
+	},
+	stopEvent: function(/*Event*/ ev){
+		if(window.event){
+			ev.returnValue = false;
+			ev.cancelBubble = true;
+		}else{
+			ev.preventDefault();
+			ev.stopPropagation();
+		}
+	},
+	popUpNav: function(){
+		if(!this.inNav){
+			dojo.widget.Show.node = this.nav;
+			var anim = new dojo.animation.Animation(new dojo.math.curves.Line([5], [30]), 250, -1);
+			dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+				dojo.widget.Show.node.style.height = e.x + &quot;px&quot;;
+			});
+			dojo.event.connect(anim, &quot;onEnd&quot;, function(e) {
+				dojo.widget.Show.node.style.height = e.x + &quot;px&quot;;
+			});
+			anim.play(true);
+		}
+		clearTimeout(this.inNav);
+		this.inNav = setTimeout(dojo.lang.hitch(this, &quot;hideNav&quot;), 2000);
+	},
+	hideNav: function(){
+		clearTimeout(this.inNav);
+		this.inNav = false;
+
+		dojo.widget.Show.node = this.nav;
+		var anim = new dojo.animation.Animation(new dojo.math.curves.Line([30], [5]), 250, 1);
+		dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+			dojo.widget.Show.node.style.height = e.x + &quot;px&quot;;
+		});
+		dojo.event.connect(anim, &quot;onEnd&quot;, function(e) {
+			dojo.widget.Show.node.style.height = e.x + &quot;px&quot;;
+		});
+		anim.play(true);
+	},
+	resizeWindow: function(/*Event*/ ev){
+		document.body.style.height = &quot;auto&quot;;
+		var h = Math.max(
+			document.documentElement.scrollHeight || document.body.scrollHeight,
+			dojo.html.getViewportHeight());
+		document.body.style.height = h + &quot;px&quot;;
+	}
+});
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/html/ShowAction.js
===================================================================
--- trunk/root/static/magic/src/widget/html/ShowAction.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/ShowAction.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,28 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.ShowAction&quot;);
+
+dojo.require(&quot;dojo.widget.ShowAction&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.ShowAction&quot;,
+	dojo.widget.HtmlWidget,
+	null,
+	&quot;html&quot;,
+	function(){
+		dojo.widget.ShowAction.call(this);
+	}
+);
+dojo.lang.extend(dojo.widget.html.ShowAction, dojo.widget.ShowAction.prototype);
+dojo.lang.extend(dojo.widget.html.ShowAction, {
+});
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/html/ShowSlide.js
===================================================================
--- trunk/root/static/magic/src/widget/html/ShowSlide.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/ShowSlide.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,189 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.ShowSlide&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.lang.common&quot;);
+dojo.require(&quot;dojo.widget.ShowSlide&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.lfx.html&quot;);
+dojo.require(&quot;dojo.animation.Animation&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.ShowSlide&quot;,
+	dojo.widget.HtmlWidget,
+	null,
+	&quot;html&quot;,
+	function(){
+		dojo.widget.ShowSlide.call(this);
+	}
+);
+dojo.lang.extend(dojo.widget.html.ShowSlide, dojo.widget.ShowSlide.prototype);
+dojo.lang.extend(dojo.widget.html.ShowSlide, {
+	htmlTitle: null,
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlShowSlide.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlShowSlide.css&quot;),
+	fillInTemplate: function(){
+		this.htmlTitle.innerHTML = this.title;
+
+		this._components = {};
+		var nodes = this.containerNode.all ? this.containerNode.all : this.containerNode.getElementsByTagName('*');
+		for(var i = 0, node; node = nodes[i]; i++){
+			var as = node.getAttribute(&quot;as&quot;);
+			if(as){
+				if(!this._components[as]){
+					this._components[as] = [];
+				}
+				this._components[as].push(node);
+			}
+		}
+	},
+	postCreate: function(){
+		this._actions = [];
+		for(var i = 0, child; child = this.children[i]; i++){
+			if(child.widgetType == &quot;ShowAction&quot;){
+				this._actions.push(child);
+				var components = this._components[child.on];
+				for(var j = 0, component; component = components[j]; j++){
+					if(child.action &amp;&amp; child.action != &quot;remove&quot;){
+						this.hideComponent(component);
+					}
+				}
+			}
+		}
+	},
+	previousAction: function(/*Event?*/ event){
+		this.stopEvent(event);
+
+		var action = this._actions[this._action];
+		if(!action){
+			return false;
+		}
+
+		var on = action.on;
+		while(action.on == on){
+			var components = this._components[on];
+			for(var i = 0, component; component = components[i]; i++){
+				if(action.action == &quot;remove&quot;){
+					if(component.style.display == &quot;none&quot;){
+						component.style.display = &quot;&quot;;
+						component.style.visibility = &quot;visible&quot;;
+						var exits = true;
+					}
+				}else if(action.action){
+					this.hideComponent(component);
+				}
+			}
+
+			--this._action;
+
+			if(exits){
+				return true;
+			}	
+
+			if(action.auto == &quot;true&quot;){
+				on = this._actions[this._action].on;
+			}
+
+			action = this._actions[this._action];
+			if(!action){
+				return false;
+			}
+		}
+		return true;
+	},
+	hideComponent: function(/*Node*/ component){
+		component.style.visibility = &quot;hidden&quot;;
+		component.style.backgroundColor = &quot;transparent&quot;;
+		var parent = component.parentNode;
+		if((parent)&amp;&amp;(parent.tagName == &quot;LI&quot;)){
+			parent.oldType = parent.style.listStyleType;
+			parent.style.listStyleType = &quot;none&quot;;
+		}
+	},
+	nextAction: function(/*Event?*/ event){
+		this.stopEvent(event);
+
+		if(!dojo.widget.ShowSlide.prototype.nextAction.call(this, event)){
+			return false;
+		}
+
+		var action = this._actions[this._action];
+		if(!action){
+			return false;
+		}
+		
+		var components = this._components[action.on];
+		for(var i = 0, component; component = components[i]; i++){
+			if(action.action){
+				var duration = action.duration || 1000;
+				if(action.action == &quot;fade&quot;){
+					dojo.style.setOpacity(component, 0);
+					dojo.lfx.html.fadeIn(component, duration).play(true);
+				}else if(action.action == &quot;fly&quot;){
+					var width = dojo.style.getMarginBoxWidth(component);
+					var position = dojo.style.getAbsolutePosition(component);
+					// alert(position);
+					component.style.position = &quot;relative&quot;;
+					component.style.left = -(width + position.x) + &quot;px&quot;;
+					dojo.lfx.html.slideBy(component, [0, (width + position.x)], duration, -1, this.callWith).play(true);
+				}else if(action.action == &quot;wipe&quot;){
+					dojo.lfx.html.wipeIn(component, duration).play();
+				}else if(action.action == &quot;color&quot;){
+					var from = new dojo.graphics.color.Color(action.from).toRgb();
+					var to = new dojo.graphics.color.Color(action.to).toRgb();
+					var anim = new dojo.animation.Animation(new dojo.math.curves.Line(from, to), duration, 0);
+					node = component;
+					dojo.event.connect(anim, &quot;onAnimate&quot;, function(e) {
+						node.style.color = &quot;rgb(&quot; + e.coordsAsInts().join(&quot;,&quot;) + &quot;)&quot;;
+					});
+					anim.play(true);
+				}else if(action.action == &quot;bgcolor&quot;){
+					dojo.lfx.html.unhighlight(component, action.to, duration).play();
+				}else if(action.action == &quot;remove&quot;){
+					component.style.display = &quot;none&quot;;
+				}
+				component.style.visibility = &quot;visible&quot;;
+			}
+		}
+		
+		action = this._actions[this._action + 1];
+		if(action &amp;&amp; action.auto == &quot;true&quot;){
+			this.nextAction();
+		}
+
+		return true;
+	},
+	callWith: function(/*Node*/ node){
+		if(!node){ return; }
+		if(dojo.lang.isArray(node)){
+			dojo.lang.forEach(node, arguments.callee);
+			return;
+		}
+		var parent = node.parentNode;
+		if((parent)&amp;&amp;(parent.tagName.toLowerCase() == &quot;li&quot;)){
+			parent.style.listStyleType = parent.oldType;
+		}
+	},
+	stopEvent: function(/*Event*/ ev){
+		if(!ev){
+			return;
+		}
+		if(window.event){
+			ev.returnValue = false;
+			ev.cancelBubble = true;
+		}else{
+			ev.preventDefault();
+			ev.stopPropagation();
+		}
+	}
+});

Added: trunk/root/static/magic/src/widget/html/Slider.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Slider.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Slider.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,500 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+/**
+ * Slider Widget.
+ * 
+ * The slider widget comes in three forms:
+ *  1. Base Slider widget which supports movement in x and y dimensions
+ *  2. Vertical Slider (SliderVertical) widget which supports movement
+ *     only in the y dimension.
+ *  3. Horizontal Slider (SliderHorizontal) widget which supports movement
+ *     only in the x dimension.
+ *
+ * The key objects in the widget are:
+ *  - a container div which displays a bar in the background (Slider object)
+ *  - a handle inside the container div, which represents the value
+ *    (sliderHandle DOM node)
+ *  - the object which moves the handle (handleMove is of type 
+ *    SliderDragMoveSource)
+ *
+ * The values for the slider are calculated by grouping pixels together, 
+ * based on the number of values to be represented by the slider.
+ * The number of pixels in a group is called the valueSize
+ *  e.g. if slider is 150 pixels long, and is representing the values
+ *       0,1,...10 then pixels are grouped into lots of 15 (valueSize), where:
+ *         value 0 maps to pixels  0 -  7
+ *               1                 8 - 22
+ *               2                23 - 37 etc.
+ * The accuracy of the slider is limited to the number of pixels
+ * (i.e tiles &gt; pixels will result in the slider not being able to
+ *  represent some values).
+ *
+ * Technical Notes:
+ *  - 3 widgets exist because the framework caches the template in
+ *    dojo.widget.fillFromTemplateCache (which ignores the changed URI)
+ *
+ * Todo:
+ *  - Setting of initial value currently doesn't work, because the one or
+ *    more of the offsets, constraints or containing block are not set and
+ *    are required to set the valueSize is not set before fillInTemplate
+ *    is called.
+ *  - Issues with dragging handle when page has been scrolled
+ *  - 
+ *
+ * References (aka sources of inspiration):
+ *  - <A HREF="http://dojotoolkit.org/docs/fast_widget_authoring.html">http://dojotoolkit.org/docs/fast_widget_authoring.html</A>
+ *  - <A HREF="http://dojotoolkit.org/docs/dojo_event_system.html">http://dojotoolkit.org/docs/dojo_event_system.html</A>
+ * 
+ * @author Marcel Linnenfelser (<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">m.linnen at synflag.de</A>)
+ * @author Mathew Pole (<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">mathew.pole at ebor.com</A>)
+ *
+ * $Id: $
+ */
+
+// tell the package system what functionality is provided in this module (file)
+// (note that the package system works on modules, not the classes)
+dojo.provide(&quot;dojo.widget.html.Slider&quot;);
+
+// load dependencies
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.dnd.*&quot;);
+// dojo.dnd.* doesn't include this package, because it's not in __package__.js
+dojo.require(&quot;dojo.dnd.HtmlDragMove&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+
+/**
+ * Define the two dimensional slider widget class.
+ */
+dojo.widget.defineWidget (
+	&quot;dojo.widget.html.Slider&quot;,
+	dojo.widget.HtmlWidget,
+	{
+		// over-ride some defaults
+		isContainer: false,
+		widgetType: &quot;Slider&quot;,
+
+		// useful properties (specified as attributes in the html tag)
+		// number of values to be represented by slider in the horizontal direction
+		valuesX: 10,
+		// number of values to be represented by slider in the vertical direction
+		valuesY: 10,
+		// can values be changed on the x (horizontal) axis?
+		isEnableX: true,
+		// can values be changed on the y (vertical) axis?
+		isEnableY: true,
+		// value size (pixels) in the x dimension
+		valueSizeX: 0.0,
+		// value size (pixels) in the y dimension
+		valueSizeY: 0.0,
+		// initial value in the x dimension
+		initialValueX: 0,
+		// initial value in the y dimension
+		initialValueY: 0,
+
+		// do we allow the user to click on the slider to set the position?
+		// (note: dojo's infrastructor will convert attribute to a boolean)
+		clickSelect: true,
+		// should the handle snap to the grid or remain where it was dragged to?
+		// (note: dojo's infrastructor will convert attribute to a boolean)
+		snapToGrid: false,
+		// should the value change while you are dragging, or just after drag finishes?
+		activeDrag: false,
+
+		templateCssPath: dojo.uri.dojoUri (&quot;src/widget/templates/HtmlSlider.css&quot;),
+		templatePath: dojo.uri.dojoUri (&quot;src/widget/templates/HtmlSlider.html&quot;),
+
+		// our DOM nodes
+		sliderHandle: null,
+
+		// private attributes
+		// This is set to true when a drag is started, so that it is not confused
+		// with a click
+		isDragInProgress: false,
+
+
+		// This function is called when the template is loaded
+		fillInTemplate: function () 
+		{
+			// dojo.debug (&quot;fillInTemplate - className = &quot; + this.domNode.className);
+
+			// setup drag-n-drop for the sliderHandle
+			this.handleMove = new dojo.widget.html.SliderDragMoveSource (this.sliderHandle);
+			this.handleMove.setParent (this);
+			dojo.event.connect(this.handleMove, &quot;onDragMove&quot;, this, &quot;onDragMove&quot;);
+			dojo.event.connect(this.handleMove, &quot;onDragEnd&quot;, this, &quot;onDragEnd&quot;);
+			dojo.event.connect(this.handleMove, &quot;onClick&quot;, this, &quot;onClick&quot;);
+
+			// keep the slider handle inside it's parent container
+			this.handleMove.constrainToContainer = true;
+		
+			if (this.clickSelect) {
+				dojo.event.connect (this.domNode, &quot;onclick&quot;, this, &quot;setPosition&quot;);
+			} 
+
+			if (this.isEnableX &amp;&amp; this.initialValueX &gt; 0) {
+				alert(&quot;setting x to &quot; + this.initialValueX);
+				this.setValueX (this.initialValueX);
+			}
+			if (this.isEnableY &amp;&amp; this.initialValueY &gt; 0) {
+				this.setValueY (this.initialValueY);
+			}
+		},
+
+
+		// Move the handle (in the x dimension) to the specified value
+		setValueX: function (value) {
+			if (0.0 == this.valueSizeX) {
+				this.valueSizeX = this.handleMove.calcValueSizeX ();
+			}
+			if (value &gt; this.valuesX) {
+				value = this.valuesX;
+			}
+			else if (value &lt; 0) {
+				value = 0;
+			}
+			//dojo.debug (&quot;value = &quot; + value, &quot;, valueSizeX = &quot; + this.valueSizeX);
+			this.handleMove.domNode.style.left = (value * this.valueSizeX) + &quot;px&quot;;
+		},
+
+
+		// Get the number of the value that matches the position of the handle
+		getValueX: function () {
+			if (0.0 == this.valueSizeX) {
+				this.valueSizeX = this.handleMove.calcValueSizeX ();
+			}
+			return Math.round (dojo.style.getPixelValue (this.handleMove.domNode, &quot;left&quot;) / this.valueSizeX);
+		},
+
+
+		// set the slider to a particular value
+		setValueY: function (value) {
+			if (0.0 == this.valueSizeY) {
+				this.valueSizeY = this.handleMove.calcValueSizeY ();
+			}
+			if (value &gt; this.valuesY) {
+				value = this.valuesY;
+			}
+			else if (value &lt; 0) {
+				value = 0;
+			}
+
+			this.handleMove.domNode.style.top = (value * this.valueSizeY) + &quot;px&quot;;
+		},
+
+
+		// Get the number of the value that the matches the position of the handle
+		getValueY: function () {
+			if (0.0 == this.valueSizeY) {
+				this.valueSizeY = this.handleMove.calcValueSizeY ();
+			}
+			return Math.round (dojo.style.getPixelValue (this.handleMove.domNode, &quot;top&quot;) / this.valueSizeY);
+		},
+
+
+		// set the position of the handle
+		setPosition: function (e) {
+			//dojo.debug (&quot;Slider#setPosition - e.clientX = &quot; + e.clientX
+			//            + &quot;, e.clientY = &quot; + e.clientY);
+			if (this.isDragInProgress) {
+				this.isDragInProgress = false;
+			}
+
+			var offset = dojo.html.getScrollOffset();
+			var parent = dojo.style.getAbsolutePosition(this.domNode, true);
+			
+			if (this.isEnableX) {
+				var x = offset.x + e.clientX - parent.x;
+				if (x &gt; this.domNode.offsetWidth) {
+					x = this.domNode.offsetWidth;
+				}
+				if (this.snapToGrid &amp;&amp; x &gt; 0) {
+					if (0.0 == this.valueSizeX) {
+						this.valueSizeX = this.handleMove.calcValueSizeX ();
+					}
+					x = this.valueSizeX * (Math.round (x / this.valueSizeX));
+				}
+				this.handleMove.domNode.style.left = x + &quot;px&quot;;
+			}
+			if (this.isEnableY) {
+				var y = offset.y + e.clientY - parent.y;
+				if (y &gt; this.domNode.offsetHeight) {
+					y = this.domNode.offsetHeight;
+				}
+				if (this.snapToGrid &amp;&amp; y &gt; 0) {
+					if (0.0 == this.valueSizeY) {
+						this.valueSizeY = this.handleMove.calcValueSizeY ();
+					}
+					y = this.valueSizeY * (Math.round (y / this.valueSizeY));
+				}
+				this.handleMove.domNode.style.top = y + &quot;px&quot;;
+			}
+		},
+
+		onDragMove: function(){
+			this.onValueChanged(this.getValueX(), this.getValueY());
+		},
+	
+		onClick: function(){
+			this.onValueChanged(this.getValueX(), this.getValueY());
+		},
+		
+		onValueChanged: function(x, y){
+		}
+	}
+);
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * Define the horizontal slider widget class.
+ */
+dojo.widget.defineWidget (
+	&quot;dojo.widget.html.SliderHorizontal&quot;,
+	dojo.widget.html.Slider,
+	{
+		widgetType: &quot;SliderHorizontal&quot;,
+
+		value: 0,
+
+		isEnableY: false,
+		templatePath: dojo.uri.dojoUri (&quot;src/widget/templates/HtmlSliderHorizontal.html&quot;),
+
+		postMixInProperties: function(){
+			this.initialValue = this.value;
+		},
+
+		// wrapper for getValueX
+		getValue: function () {
+			return this.getValueX ();
+		},
+
+		// wrapper for setValueX
+		setValue: function (value) {
+			this.setValueX (value);
+			this.onValueChanged(value);
+		},
+
+		onDragMove: function(){
+			if(this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onDragEnd: function(){
+			if(!this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onClick: function(){
+			this.onValueChanged(this.getValue());
+		},
+		
+		onValueChanged: function(value){
+			this.value=value;
+		}
+	}
+);
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * Define the vertical slider widget class.
+ */
+dojo.widget.defineWidget (
+	&quot;dojo.widget.html.SliderVertical&quot;,
+	dojo.widget.html.Slider,
+	{
+		widgetType: &quot;SliderVertical&quot;,
+
+		value: 0,
+
+		isEnableX: false,
+		templatePath: dojo.uri.dojoUri (&quot;src/widget/templates/HtmlSliderVertical.html&quot;),
+
+		postMixInProperties: function(){
+			this.initialValueY = this.value;
+		},
+
+		// wrapper for getValueY
+		getValue: function () {
+			return this.getValueY ();
+		},
+
+		// wrapper for setValueY
+		setValue: function (value) {
+			this.setValueY (value);
+		},
+
+		onDragMove: function(){
+			if(this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onDragEnd: function(){
+			if(!this.activeDrag){
+				this.onValueChanged(this.getValue());
+			}
+		},
+	
+		onClick: function(){
+			this.onValueChanged(this.getValue());
+		},
+		
+		onValueChanged: function(value){
+			this.value=value;
+		}
+	}
+);
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * This class extends the HtmlDragMoveSource class to provide
+ * features for the slider handle.
+ */
+dojo.declare (
+	&quot;dojo.widget.html.SliderDragMoveSource&quot;,
+	dojo.dnd.HtmlDragMoveSource,
+{
+	isDragInProgress: false,
+	slider: null,
+
+
+	/** Setup the handle for drag
+	 *  Extends dojo.dnd.HtmlDragMoveSource by creating a SliderDragMoveSource */
+	onDragStart: function (e) {
+		this.isDragInProgress = true;
+		this.constrainToContainer = true;
+
+		var dragObj = this.createDragMoveObject ();
+		var constraints = null;
+
+
+		dojo.event.connect (dragObj, &quot;onDragMove&quot;, this, &quot;onDragMove&quot;);
+
+		return dragObj;
+	},
+
+
+	onDragMove: function (e) {
+		// placeholder to enable event connection
+	},
+
+
+	createDragMoveObject: function () {
+		//dojo.debug (&quot;SliderDragMoveSource#createDragMoveObject - &quot; + this.slider);
+		var dragObj = new dojo.widget.html.SliderDragMoveObject (this.dragObject, this.type);
+		dragObj.slider = this.slider;
+
+		// this code copied from dojo.dnd.HtmlDragSource#onDragStart
+		if (this.dragClass) { 
+			dragObj.dragClass = this.dragClass; 
+		}
+		if (this.constrainToContainer) {
+			dragObj.constrainTo(this.constrainingContainer || this.domNode.parentNode);
+		}
+		return dragObj;
+	},
+
+
+	setParent: function (slider) {
+		this.slider = slider;
+	},
+
+	
+	calcValueSizeX: function () {
+		var dragObj = this.createDragMoveObject ();
+		dragObj.containingBlockPosition = dragObj.domNode.offsetParent ? 
+		dojo.style.getAbsolutePosition(dragObj.domNode.offsetParent) : {x:0, y:0};
+		
+		var constraints = dragObj.getConstraints ();
+		return (constraints.maxX - constraints.minX) / this.slider.valuesX;
+	},
+
+	
+	calcValueSizeY: function () {
+		var dragObj = this.createDragMoveObject ();
+		dragObj.containingBlockPosition = dragObj.domNode.offsetParent ? 
+		dojo.style.getAbsolutePosition(dragObj.domNode.offsetParent) : {x:0, y:0};
+		var constraints = dragObj.getConstraints ();
+		return (constraints.maxY - constraints.minY) / this.slider.valuesY;
+	}
+});
+
+
+/* ------------------------------------------------------------------------- */
+
+
+/**
+ * This class extends the HtmlDragMoveObject class to provide
+ * features for the slider handle.
+ */
+dojo.declare (
+	&quot;dojo.widget.html.SliderDragMoveObject&quot;,
+	dojo.dnd.HtmlDragMoveObject,
+{
+	// reference to dojo.widget.html.Slider
+	slider: null,
+
+	/** Moves the node to follow the mouse.
+	 *  Extends functon HtmlDragObject by adding functionality to snap handle
+	 *  to a discrete value */
+	onDragMove: function (e) {
+		if (this.slider.isEnableX &amp;&amp; 0.0 == this.slider.valueSizeX) {
+			this.slider.valueSizeX = (this.constraints.maxX - this.constraints.minX) / this.slider.valuesX;
+		}
+		if (this.slider.isEnableY &amp;&amp; 0.0 == this.slider.valueSizeY) {
+			this.slider.valueSizeY = (this.constraints.maxY - this.constraints.minY) / this.slider.valuesY;
+		}
+
+		this.updateDragOffset ();
+
+		var x = this.dragOffset.x + e.pageX;
+		var y = this.dragOffset.y + e.pageY;
+
+		if (this.constrainToContainer) {
+			if (x &lt; this.constraints.minX) { x = this.constraints.minX; }
+			if (y &lt; this.constraints.minY) { y = this.constraints.minY; }
+			if (x &gt; this.constraints.maxX) { x = this.constraints.maxX; }
+			if (y &gt; this.constraints.maxY) { y = this.constraints.maxY; }
+		}
+
+		if (this.slider.isEnableX) {
+			var selectedValue = 0;
+			if (x &gt; 0) {
+				selectedValue = Math.round (x / this.slider.valueSizeX);
+			}
+			// dojo.debug (&quot;x = &quot; + x + &quot;, valueSize = &quot; + valueSize 
+			//             + &quot;, selectedValue = &quot; + selectedValue);
+			x = (selectedValue * this.slider.valueSizeX);
+		}
+
+		if (this.slider.isEnableY) {
+			var selectedValue = 0;
+			if (y &gt; 0) {
+				selectedValue = Math.round (y / this.slider.valueSizeY);
+			}
+			y = (selectedValue * this.slider.valueSizeY);
+		}
+
+		this.setAbsolutePosition (x, y);
+	}
+});

Added: trunk/root/static/magic/src/widget/html/SortableTable.js
===================================================================
--- trunk/root/static/magic/src/widget/html/SortableTable.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/SortableTable.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,582 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.SortableTable&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+dojo.require(&quot;dojo.date&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.SortableTable&quot;);
+
+dojo.widget.html.SortableTable=function(){
+	//	summary
+	//	Constructor for the SortableTable widget
+	dojo.widget.SortableTable.call(this);
+	dojo.widget.HtmlWidget.call(this);
+
+	this.headClass=&quot;&quot;;
+	this.tbodyClass=&quot;&quot;;
+	this.headerClass=&quot;&quot;;
+	this.headerSortUpClass=&quot;selected&quot;;
+	this.headerSortDownClass=&quot;selected&quot;;
+	this.rowClass=&quot;&quot;;
+	this.rowAlternateClass=&quot;alt&quot;;
+	this.rowSelectedClass=&quot;selected&quot;;
+	this.columnSelected=&quot;sorted-column&quot;;
+};
+dojo.inherits(dojo.widget.html.SortableTable, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.SortableTable, {
+	templatePath:null,
+	templateCssPath:null,
+
+	getTypeFromString:function(/* string */ s){
+		//	summary
+		//	Find the constructor that matches param s by searching through the entire object tree.
+		var parts=s.split(&quot;.&quot;),i=0,obj=dj_global; 
+		do{obj=obj[parts[i++]];}while(i&lt;parts.length&amp;&amp;obj); 
+		return(obj!=dj_global)?obj:null;	//	function
+	},
+	compare:function(/* object */ o1, /* object */ o2){
+		//	summary
+		//	Compare two objects using a shallow property compare
+		for(var p in o1){
+			if(!(p in o2)) return false;	//	boolean
+			if(o1[p].valueOf()!=o2[p].valueOf()) return false;	//	boolean
+		}
+		return true;	// boolean
+	},
+	isSelected:function(/* object */ o){
+		//	summary
+		//	checked to see if the passed object is in the current selection.
+		for(var i=0;i&lt;this.selected.length;i++){
+			if(this.compare(this.selected[i],o)){
+				return true; // boolean
+			}
+		}
+		return false;	// boolean
+	},
+	removeFromSelected:function(/* object */ o){
+		//	summary
+		//	remove the passed object from the current selection.
+		var idx=-1;
+		for(var i=0;i&lt;this.selected.length;i++){
+			if(this.compare(this.selected[i],o)){
+				idx=i;
+				break;
+			}
+		}
+		if(idx&gt;=0){
+			this.selected.splice(idx,1);
+		}
+	},
+	getSelection:function(){
+		//	summary
+		//	return the array of currently selected objects (JSON format)
+		return this.selected;	//	array
+	},
+	getValue:function(){
+		//	summary
+		//	return a comma-delimited list of selected valueFields.
+		var a=[];
+		for(var i=0;i&lt;this.selected.length;i++){
+			if (this.selected[i][this.valueField]){
+				a.push(this.selected[i][this.valueField]);
+			}
+		}
+		return a.join();	//	string
+	},
+	reset:function(){
+		//	summary
+		//	completely resets the internal representations.
+		this.columns=[];
+		this.data=[];
+		this.resetSelections(this.domNode.getElementsByTagName(&quot;tbody&quot;)[0]);
+	},
+	resetSelections:function(/* HTMLTableBodyElement */ body){
+		this.selected=[];
+		var idx=0;
+		var rows=body.getElementsByTagName(&quot;tr&quot;);
+		for(var i=0; i&lt;rows.length; i++){
+			if(rows[i].parentNode==body){
+				rows[i].removeAttribute(&quot;selected&quot;);
+				if(this.enableAlternateRows&amp;&amp;idx%2==1){
+					rows[i].className=this.rowAlternateClass;
+				}else{
+					rows[i].className=&quot;&quot;;
+				}
+				idx++;
+			}
+		}
+	},
+
+	getObjectFromRow:function(/* HTMLTableRowElement */ row){
+		//	summary
+		//	creates a JSON object based on the passed row
+		var cells=row.getElementsByTagName(&quot;td&quot;);
+		var o={};
+		for(var i=0; i&lt;this.columns.length;i++){
+			if(this.columns[i].sortType==&quot;__markup__&quot;){
+				//	FIXME: should we parse this instead?  Because if the user may not get back the markup they put in...
+				o[this.columns[i].getField()]=cells[i].innerHTML;
+			}else{
+				var text=dojo.html.renderedTextContent(cells[i]);
+				var val=new (this.columns[i].getType())(text);
+				o[this.columns[i].getField()]=val;
+			}
+		}
+		if(dojo.html.hasAttribute(row,&quot;value&quot;)){
+			o[this.valueField]=dojo.html.getAttribute(row,&quot;value&quot;);
+		}
+		return o;	//	object
+	},
+	setSelectionByRow:function(/* HTMLTableElementRow */ row){
+		//	summary
+		//	create the selection object based on the passed row, makes sure it's unique.
+		//	note that you need to call render manually (because of multi-select operations)
+		var o=this.getObjectFromRow(row);
+		var b=false;
+		for(var i=0;i&lt;this.selected.length;i++){
+			if(this.compare(this.selected[i], o)){
+				b=true;
+				break;
+			}
+		}
+		if(!b){
+			this.selected.push(o);
+		}
+	},
+
+	parseColumns:function(/* HTMLTableHeadElement */ node){
+		//	summary
+		//	parses the passed element to create column objects
+		this.reset();
+		var row=node.getElementsByTagName(&quot;tr&quot;)[0];
+		var cells=row.getElementsByTagName(&quot;td&quot;);
+		if (cells.length==0) cells=row.getElementsByTagName(&quot;th&quot;);
+		for(var i=0; i&lt;cells.length; i++){
+			var o={
+				field:null,
+				format:null,
+				noSort:false,
+				sortType:&quot;String&quot;,
+				dataType:String,
+				sortFunction:null,
+				label:null,
+				align:&quot;left&quot;,
+				valign:&quot;middle&quot;,
+				getField:function(){ return this.field||this.label; },
+				getType:function(){ return this.dataType; }
+			};
+			//	presentation attributes
+			if(dojo.html.hasAttribute(cells[i], &quot;align&quot;)){
+				o.align=dojo.html.getAttribute(cells[i],&quot;align&quot;);
+			}
+			if(dojo.html.hasAttribute(cells[i], &quot;valign&quot;)){
+				o.valign=dojo.html.getAttribute(cells[i],&quot;valign&quot;);
+			}
+
+			//	sorting features.
+			if(dojo.html.hasAttribute(cells[i], &quot;nosort&quot;)){
+				o.noSort=dojo.html.getAttribute(cells[i],&quot;nosort&quot;)==&quot;true&quot;;
+			}
+			if(dojo.html.hasAttribute(cells[i], &quot;sortusing&quot;)){
+				var trans=dojo.html.getAttribute(cells[i],&quot;sortusing&quot;);
+				var f=this.getTypeFromString(trans);
+				if (f!=null &amp;&amp; f!=window &amp;&amp; typeof(f)==&quot;function&quot;) 
+					o.sortFunction=f;
+			}
+
+			if(dojo.html.hasAttribute(cells[i], &quot;field&quot;)){
+				o.field=dojo.html.getAttribute(cells[i],&quot;field&quot;);
+			}
+			if(dojo.html.hasAttribute(cells[i], &quot;format&quot;)){
+				o.format=dojo.html.getAttribute(cells[i],&quot;format&quot;);
+			}
+			if(dojo.html.hasAttribute(cells[i], &quot;dataType&quot;)){
+				var sortType=dojo.html.getAttribute(cells[i],&quot;dataType&quot;);
+				if(sortType.toLowerCase()==&quot;html&quot;||sortType.toLowerCase()==&quot;markup&quot;){
+					o.sortType=&quot;__markup__&quot;;	//	always convert to &quot;__markup__&quot;
+					o.noSort=true;
+				}else{
+					var type=this.getTypeFromString(sortType);
+					if(type){
+						o.sortType=sortType;
+						o.dataType=type;
+					}
+				}
+			}
+			o.label=dojo.html.renderedTextContent(cells[i]);
+			this.columns.push(o);
+
+			//	check to see if there's a default sort, and set the properties necessary
+			if(dojo.html.hasAttribute(cells[i], &quot;sort&quot;)){
+				this.sortIndex=i;
+				var dir=dojo.html.getAttribute(cells[i], &quot;sort&quot;);
+				if(!isNaN(parseInt(dir))){
+					dir=parseInt(dir);
+					this.sortDirection=(dir!=0)?1:0;
+				}else{
+					this.sortDirection=(dir.toLowerCase()==&quot;desc&quot;)?1:0;
+				}
+			}
+		}
+	},
+
+	parseData:function(/* array */ data){
+		//	summary
+		//	Parse the passed JSON data structure, and cast based on columns.
+		this.data=[];
+		this.selected=[];
+		for(var i=0; i&lt;data.length; i++){
+			var o={};	//	new data object.
+			for(var j=0; j&lt;this.columns.length; j++){
+				var field=this.columns[j].getField();
+				if(this.columns[j].sortType==&quot;__markup__&quot;){
+					o[field]=String(data[i][field]);
+				}else{
+					var type=this.columns[j].getType();
+					var val=data[i][field];
+					var t=this.columns[j].sortType.toLowerCase();
+					if(val){
+						o[field]=new type(val);
+					}else{
+						o[field]=new type();	//	let it use the default.
+					}
+				}
+			}
+			//	check for the valueField if not already parsed.
+			if(data[i][this.valueField]&amp;&amp;!o[this.valueField]){
+				o[this.valueField]=data[i][this.valueField];
+			}
+			this.data.push(o);
+		}
+	}, 
+
+	parseDataFromTable:function(/* HTMLTableBodyElement */ tbody){
+		//	summary
+		//	parses the data in the tbody of a table to create a set of objects.
+		//	Will add objects to this.selected if an attribute 'selected=&quot;true&quot;' is present on the row.
+		this.data=[];
+		this.selected=[];
+		var rows=tbody.getElementsByTagName(&quot;tr&quot;);
+		for(var i=0; i&lt;rows.length; i++){
+			if(dojo.html.getAttribute(rows[i],&quot;ignoreIfParsed&quot;)==&quot;true&quot;){
+				continue;
+			}
+			var o={};	//	new data object.
+			var cells=rows[i].getElementsByTagName(&quot;td&quot;);
+			for(var j=0; j&lt;this.columns.length; j++){
+				var field=this.columns[j].getField();
+				if(this.columns[j].sortType==&quot;__markup__&quot;){
+					//	FIXME: parse this?
+					o[field]=cells[j].innerHTML;
+				}else{
+					var type=this.columns[j].getType();
+					var val=dojo.html.renderedTextContent(cells[j]); //	should be the same index as the column.
+					if (val) o[field]=new type(val);
+					else o[field]=new type();	//	let it use the default.
+				}
+			}
+			if(dojo.html.hasAttribute(rows[i],&quot;value&quot;)&amp;&amp;!o[this.valueField]){
+				o[this.valueField]=dojo.html.getAttribute(rows[i],&quot;value&quot;);
+			}
+			//	FIXME: add code to preserve row attributes in __metadata__ field?
+			this.data.push(o);
+			
+			//	add it to the selections if selected=&quot;true&quot; is present.
+			if(dojo.html.getAttribute(rows[i],&quot;selected&quot;)==&quot;true&quot;){
+				this.selected.push(o);
+			}
+		}
+	},
+	
+	showSelections:function(){
+		var body=this.domNode.getElementsByTagName(&quot;tbody&quot;)[0];
+		var rows=body.getElementsByTagName(&quot;tr&quot;);
+		var idx=0;
+		for(var i=0; i&lt;rows.length; i++){
+			if(rows[i].parentNode==body){
+				if(dojo.html.getAttribute(rows[i],&quot;selected&quot;)==&quot;true&quot;){
+					rows[i].className=this.rowSelectedClass;
+				} else {
+					if(this.enableAlternateRows&amp;&amp;idx%2==1){
+						rows[i].className=this.rowAlternateClass;
+					}else{
+						rows[i].className=&quot;&quot;;
+					}
+				}
+				idx++;
+			}
+		}
+	},
+	render:function(bDontPreserve){
+		//	summary
+		//	renders the table to the browser
+		var data=[];
+		var body=this.domNode.getElementsByTagName(&quot;tbody&quot;)[0];
+
+		if(!bDontPreserve){
+			//	rebuild data and selection
+			this.parseDataFromTable(body);
+		}
+
+		//	clone this.data for sorting purposes.
+		for(var i=0; i&lt;this.data.length; i++){
+			data.push(this.data[i]);
+		}
+		
+		var col=this.columns[this.sortIndex];
+		if(!col.noSort){
+			var field=col.getField();
+			if(col.sortFunction){
+				var sort=col.sortFunction;
+			}else{
+				var sort=function(a,b){
+					if (a[field]&gt;b[field]) return 1;
+					if (a[field]&lt;b[field]) return -1;
+					return 0;
+				}
+			}
+			data.sort(sort);
+			if(this.sortDirection!=0) data.reverse();
+		}
+
+		//	build the table and pop it in.
+		while(body.childNodes.length&gt;0) body.removeChild(body.childNodes[0]);
+		for(var i=0; i&lt;data.length;i++){
+			var row=document.createElement(&quot;tr&quot;);
+			dojo.html.disableSelection(row);
+			if (data[i][this.valueField]){
+				row.setAttribute(&quot;value&quot;,data[i][this.valueField]);
+			}
+			if(this.isSelected(data[i])){
+				row.className=this.rowSelectedClass;
+				row.setAttribute(&quot;selected&quot;,&quot;true&quot;);
+			} else {
+				if(this.enableAlternateRows&amp;&amp;i%2==1){
+					row.className=this.rowAlternateClass;
+				}
+			}
+			for(var j=0;j&lt;this.columns.length;j++){
+				var cell=document.createElement(&quot;td&quot;);
+				cell.setAttribute(&quot;align&quot;, this.columns[j].align);
+				cell.setAttribute(&quot;valign&quot;, this.columns[j].valign);
+				dojo.html.disableSelection(cell);
+				if(this.sortIndex==j){
+					cell.className=this.columnSelected;
+				}
+				if(this.columns[j].sortType==&quot;__markup__&quot;){
+					cell.innerHTML=data[i][this.columns[j].getField()];
+					for(var k=0; k&lt;cell.childNodes.length; k++){
+						var node=cell.childNodes[k];
+						if(node&amp;&amp;node.nodeType==dojo.html.ELEMENT_NODE){
+							dojo.html.disableSelection(node);
+						}
+					}
+				}else{
+					if(this.columns[j].getType()==Date){
+						var format=this.defaultDateFormat;
+						if(this.columns[j].format) format=this.columns[j].format;
+						cell.appendChild(document.createTextNode(dojo.date.format(data[i][this.columns[j].getField()], format)));
+					}else{
+						cell.appendChild(document.createTextNode(data[i][this.columns[j].getField()]));
+					}
+				}
+				row.appendChild(cell);
+			}
+			body.appendChild(row);
+			dojo.event.connect(row, &quot;onclick&quot;, this, &quot;onUISelect&quot;);
+		}
+		
+		//	if minRows exist.
+		var minRows=parseInt(this.minRows);
+		if (!isNaN(minRows) &amp;&amp; minRows&gt;0 &amp;&amp; data.length&lt;minRows){
+			var mod=0;
+			if(data.length%2==0) mod=1;
+			var nRows=minRows-data.length;
+			for(var i=0; i&lt;nRows; i++){
+				var row=document.createElement(&quot;tr&quot;);
+				row.setAttribute(&quot;ignoreIfParsed&quot;,&quot;true&quot;);
+				if(this.enableAlternateRows&amp;&amp;i%2==mod){
+					row.className=this.rowAlternateClass;
+				}
+				for(var j=0;j&lt;this.columns.length;j++){
+					var cell=document.createElement(&quot;td&quot;);
+					cell.appendChild(document.createTextNode(&quot;\u00A0&quot;));
+					row.appendChild(cell);
+				}
+				body.appendChild(row);
+			}
+		}
+	},
+
+	//	the following the user can override.
+	onSelect:function(/* DomEvent */ e){ 
+		//	summary
+		//	empty function for the user to attach code to, fired by onUISelect
+	},
+	onUISelect:function(/* DomEvent */ e){
+		//	summary
+		//	fired when a user selects a row
+		var row=dojo.html.getParentByType(e.target,&quot;tr&quot;);
+		var body=dojo.html.getParentByType(row,&quot;tbody&quot;);
+		if(this.enableMultipleSelect){
+			if(e.metaKey||e.ctrlKey){
+				if(this.isSelected(this.getObjectFromRow(row))){
+					this.removeFromSelected(this.getObjectFromRow(row));
+					row.removeAttribute(&quot;selected&quot;);
+				}else{
+					//	push onto the selection stack.
+					this.setSelectionByRow(row);
+					row.setAttribute(&quot;selected&quot;,&quot;true&quot;);
+				}
+			}else if(e.shiftKey){
+				//	the tricky one.  We need to figure out the *last* selected row above, 
+				//	and select all the rows in between.
+				var startRow;
+				var rows=body.getElementsByTagName(&quot;tr&quot;);
+				//	if there's a selection above, we go with that first. 
+				for(var i=0;i&lt;rows.length;i++){
+					if(rows[i].parentNode==body){
+						if(rows[i]==row) break;
+						if(dojo.html.getAttribute(rows[i],&quot;selected&quot;)==&quot;true&quot;){
+							startRow=rows[i];
+						}
+					}
+				}
+				//	if there isn't a selection above, we continue with a selection below.
+				if(!startRow){
+					startRow=row;
+					for(;i&lt;rows.length;i++){
+						if(dojo.html.getAttribute(rows[i],&quot;selected&quot;)==&quot;true&quot;){
+							row=rows[i];
+							break;
+						}
+					}
+				}
+				this.resetSelections(body);
+				if(startRow==row){
+					//	this is the only selection
+					row.setAttribute(&quot;selected&quot;,&quot;true&quot;);
+					this.setSelectionByRow(row);
+				}else{
+					var doSelect=false;
+					for(var i=0; i&lt;rows.length; i++){
+						if(rows[i].parentNode==body){
+							rows[i].removeAttribute(&quot;selected&quot;);
+							if(rows[i]==startRow){
+								doSelect=true;
+							}
+							if(doSelect){
+								this.setSelectionByRow(rows[i]);
+								rows[i].setAttribute(&quot;selected&quot;,&quot;true&quot;);
+							}
+							if(rows[i]==row){
+								doSelect=false;
+							}
+						}
+					}
+				}
+			}else{
+				//	reset the selection
+				this.resetSelections(body);
+				row.setAttribute(&quot;selected&quot;,&quot;true&quot;);
+				this.setSelectionByRow(row);
+			}
+		}else{
+			//	reset the data selection and go.
+			this.resetSelections(body);
+			row.setAttribute(&quot;selected&quot;,&quot;true&quot;);
+			this.setSelectionByRow(row);
+		}
+		this.showSelections();
+		this.onSelect(e);
+		e.stopPropagation();
+		e.preventDefault();
+	},
+	onHeaderClick:function(/* DomEvent */ e){
+		//	summary
+		//	Main handler function for each header column click.
+		var oldIndex=this.sortIndex;
+		var oldDirection=this.sortDirection;
+		var source=e.target;
+		var row=dojo.html.getParentByType(source,&quot;tr&quot;);
+		var cellTag=&quot;td&quot;;
+		if(row.getElementsByTagName(cellTag).length==0) cellTag=&quot;th&quot;;
+
+		var headers=row.getElementsByTagName(cellTag);
+		var header=dojo.html.getParentByType(source,cellTag);
+		
+		for(var i=0; i&lt;headers.length; i++){
+			if(headers[i]==header){
+				if(i!=oldIndex){
+					//	new col.
+					this.sortIndex=i;
+					this.sortDirection=0;
+					headers[i].className=this.headerSortDownClass
+				}else{
+					this.sortDirection=(oldDirection==0)?1:0;
+					if(this.sortDirection==0){
+						headers[i].className=this.headerSortDownClass;
+					}else{
+						headers[i].className=this.headerSortUpClass;
+					}
+				}
+			}else{
+				//	reset the header class.
+				headers[i].className=this.headerClass;
+			}
+		}
+		this.render();
+	},
+
+	postCreate:function(){ 
+		// 	summary
+		//	overridden from HtmlWidget, initializes and renders the widget.
+		var thead=this.domNode.getElementsByTagName(&quot;thead&quot;)[0];
+		if(this.headClass.length&gt;0){
+			thead.className=this.headClass;
+		}
+
+		//	disable selections
+		dojo.html.disableSelection(this.domNode);
+
+		//	parse the columns.
+		this.parseColumns(thead);
+
+		//	attach header handlers.
+		var header=&quot;td&quot;;
+		if(thead.getElementsByTagName(header).length==0) header=&quot;th&quot;;
+		var headers=thead.getElementsByTagName(header);
+		for(var i=0; i&lt;headers.length; i++){
+			if(!this.columns[i].noSort){
+				dojo.event.connect(headers[i], &quot;onclick&quot;, this, &quot;onHeaderClick&quot;);
+			}
+			if(this.sortIndex==i){
+				if(this.sortDirection==0){
+					headers[i].className=this.headerSortDownClass;
+				}else{
+					headers[i].className=this.headerSortUpClass;
+				}
+			}
+		}
+
+		//	parse the tbody element and re-render it.
+		var tbody=this.domNode.getElementsByTagName(&quot;tbody&quot;)[0];
+		if (this.tbodyClass.length&gt;0) {
+			tbody.className=this.tbodyClass;
+		}
+
+		this.parseDataFromTable(tbody);
+		this.render(true);
+	}
+});

Added: trunk/root/static/magic/src/widget/html/Spinner.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Spinner.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Spinner.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,383 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.Spinner&quot;);
+dojo.require(&quot;dojo.widget.Spinner&quot;);
+dojo.require(&quot;dojo.widget.Manager.*&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.io.*&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.string&quot;);
+dojo.require(&quot;dojo.widget.html.stabile&quot;);
+
+dojo.widget.html.Spinner = function(){
+	dojo.widget.Spinner.call(this);
+	dojo.widget.HtmlWidget.call(this);
+}
+
+dojo.inherits(dojo.widget.html.Spinner, dojo.widget.HtmlWidget);
+
+// copied from superclass since we can't really over-ride via prototype
+dojo.lang.extend(dojo.widget.html.Spinner, dojo.widget.Spinner.defaults);
+
+dojo.lang.extend(dojo.widget.html.Spinner, {
+
+	name: &quot;&quot;, // clone in the name from the DOM node
+	inputNode: null,
+	upArrowNode: null,
+	downArrowNode: null,
+	absNode: null,
+	relNode: null,
+	innerRelNode: null,
+	spacerNode: null,
+	inputWidgetId: &quot;&quot;,
+	inputWidget: null,
+	typamaticTimer: null,
+	typamaticFunction: null,
+	defaultTimeout: 500,
+	currentTimeout: this.defaultTimeout,
+	eventCount: 0,
+
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlSpinner.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlSpinner.css&quot;),
+
+	setValue: function(value){
+		this.inputWidget.setValue(value);
+		this.inputWidget.adjustValue(0);
+		dojo.widget.html.stabile.setState(this.widgetId, this.getState(), true);
+	},
+
+	getValue: function(){
+		return this.inputWidget.getValue();
+	},
+
+	getState: function(){
+		return {value: this.getValue()};
+	},
+
+	setState: function(state){
+		this.setValue(state.value);
+	},
+
+	// does the keyboard related stuff
+	_handleKeyEvents: function(evt){
+		var k = dojo.event.browser.keys;
+		var keyCode = evt.keyCode;
+
+		switch(keyCode){
+ 			case k.KEY_DOWN_ARROW:
+				dojo.event.browser.stopEvent(evt);
+				this.downArrowPressed(evt);
+				return;
+			case k.KEY_UP_ARROW:
+				dojo.event.browser.stopEvent(evt);
+				this.upArrowPressed(evt);
+				return;
+		}
+		this.eventCount++;
+
+	},
+
+	onKeyDown: function(evt){
+		// IE needs to stop keyDown others need to stop keyPress
+		if(!document.createEvent){ // only IE
+			this._handleKeyEvents(evt);
+		}
+	},
+
+	onKeyPress: function(evt){
+		if(document.createEvent){ // never IE
+			this._handleKeyEvents(evt);
+		}
+	},
+
+	fillInTemplate: function(args, frag){
+		var source = this.getFragNodeRef(frag);
+		dojo.html.copyStyle(this.domNode, source);
+	},
+
+
+	resizeUpArrow: function(){
+		var newh = dojo.style.getContentBoxHeight(this.inputNode) &gt;&gt; 1;
+		if(newh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, &quot;resizeUpArrow&quot;, 100);
+			return;
+		}
+		var oldh = this.upArrowNode.height;
+		if(oldh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, &quot;resizeUpArrow&quot;, 100);
+			return;
+		}
+		var ratio = newh / oldh;
+		this.upArrowNode.width=Math.floor(this.upArrowNode.width * ratio);
+		this.upArrowNode.height=newh;
+	},
+
+	resizeDownArrow: function(){
+		var newh = dojo.style.getContentBoxHeight(this.inputNode) &gt;&gt; 1;
+		if(newh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, &quot;resizeDownArrow&quot;, 100);
+			return;
+		}
+		var oldh = this.downArrowNode.height;
+		if(oldh==0){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, &quot;resizeDownArrow&quot;, 100);
+			return;
+		}
+		var ratio = newh / oldh;
+		this.downArrowNode.width=Math.floor(this.downArrowNode.width * ratio);
+		this.downArrowNode.height=newh;
+	},
+
+	resizeSpacer: function(){
+		var newh = dojo.style.getContentBoxHeight(this.inputNode) &gt;&gt; 1;
+		if( newh==0 ){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, &quot;resizeSpacer&quot;, 100);
+			return;
+		}
+		var oldh = this.downArrowNode.height;
+		if( oldh==0 ){
+			// need more time to calculate size
+			dojo.lang.setTimeout(this, &quot;resizeSpacer&quot;, 100);
+			return;
+		}
+		var ratio = newh / oldh;
+		this.spacerNode.width=Math.floor(this.spacerNode.width * ratio);
+		this.spacerNode.height=newh;
+	},
+
+	_pressButton: function(node){
+		with(node.style){
+			borderRight = &quot;0px&quot;;
+			borderBottom = &quot;0px&quot;;
+			borderLeft = &quot;1px solid black&quot;;
+			borderTop = &quot;1px solid black&quot;;
+		}
+	},
+
+	_releaseButton: function(node){
+		with(node.style){
+			borderLeft = &quot;0px&quot;;
+			borderTop = &quot;0px&quot;;
+			borderRight = &quot;1px solid gray&quot;;
+			borderBottom = &quot;1px solid gray&quot;;
+		}
+	},
+
+	downArrowPressed: function(evt){
+		if(typeof evt != &quot;number&quot;){
+		    if(this.typamaticTimer != null){
+				if(this.typamaticFunction == this.downArrowPressed){
+					return;
+				}
+		        clearTimeout(this.typamaticTimer);
+		    }
+		    this._releaseButton(this.upArrowNode);
+		    this.eventCount++;
+		    this.typamaticTimer = null;
+		    this.currentTimeout = this.defaultTimeout;
+
+		}else if (evt != this.eventCount){
+		    this._releaseButton(this.downArrowNode);
+		    return;
+		}
+		this._pressButton(this.downArrowNode);
+		this.setCursorX(this.inputWidget.adjustValue(-1,this.getCursorX()));
+		this.typamaticFunction = this.downArrowPressed;
+		this.typamaticTimer = setTimeout( dojo.lang.hitch(this,function(){this.downArrowPressed(this.eventCount);}), this.currentTimeout);
+		this.currentTimeout = Math.round(this.currentTimeout * 90 / 100);
+	},
+
+	upArrowPressed: function(evt){
+		if(typeof evt != &quot;number&quot;){
+		    if(this.typamaticTimer != null){
+				if(this.typamaticFunction == this.upArrowPressed){
+					return;
+				}
+		        clearTimeout(this.typamaticTimer);
+		    }
+		    this._releaseButton(this.downArrowNode);
+		    this.eventCount++;
+		    this.typamaticTimer = null;
+		    this.currentTimeout = this.defaultTimeout;
+		}else if(evt != this.eventCount) {
+		    this._releaseButton(this.upArrowNode);
+		    return;
+		}
+		this._pressButton(this.upArrowNode);
+		this.setCursorX(this.inputWidget.adjustValue(+1,this.getCursorX()));
+		this.typamaticFunction = this.upArrowPressed;
+		this.typamaticTimer = setTimeout( dojo.lang.hitch(this,function(){this.upArrowPressed(this.eventCount);}), this.currentTimeout);
+		this.currentTimeout = Math.round(this.currentTimeout * 90 / 100);
+	},
+
+	arrowReleased: function(evt){
+		this.inputNode.focus();
+		if(evt.keyCode &amp;&amp; evt.keyCode != null){
+			var keyCode = evt.keyCode;
+			var k = dojo.event.browser.keys;
+
+			switch(keyCode){
+				case k.KEY_DOWN_ARROW:
+				case k.KEY_UP_ARROW:
+					dojo.event.browser.stopEvent(evt);
+					break;
+			}
+		}
+		this._releaseButton(this.upArrowNode);
+		this._releaseButton(this.downArrowNode);
+		this.eventCount++;
+		if(this.typamaticTimer != null){
+		    clearTimeout(this.typamaticTimer);
+		}
+		this.typamaticTimer = null;
+		this.currentTimeout = this.defaultTimeout;
+	},
+
+	mouseWheeled: function(evt) {
+		var scrollAmount = 0;
+		if(typeof evt.wheelDelta == 'number'){ // IE
+		    scrollAmount = evt.wheelDelta;
+		}else if (typeof evt.detail == 'number'){ // Mozilla+Firefox
+		    scrollAmount = -evt.detail;
+		}
+		if(scrollAmount &gt; 0){
+		    this.upArrowPressed(evt);
+		    this.arrowReleased(evt);
+		}else if (scrollAmount &lt; 0){
+		    this.downArrowPressed(evt);
+		    this.arrowReleased(evt);
+		}
+	},
+
+	getCursorX: function(){
+		var x = -1;
+		try{
+		    this.inputNode.focus();
+		    if (typeof this.inputNode.selectionEnd == &quot;number&quot;){
+				x = this.inputNode.selectionEnd;
+		    }else if (document.selection &amp;&amp; document.selection.createRange) {
+				var range = document.selection.createRange().duplicate();
+				if(range.parentElement() == this.inputNode){
+					range.moveStart('textedit', -1);
+					x = range.text.length;
+				}
+		    }
+		}catch(e){ /* squelch! */ }
+		return x;
+	},
+
+	setCursorX: function(x){
+		try{
+			this.inputNode.focus();
+		    if(!x){ x = 0 }
+		    if(typeof this.inputNode.selectionEnd == &quot;number&quot;){
+		        this.inputNode.selectionEnd = x;
+		    }else if(this.inputNode.createTextRange){
+		        var range = this.inputNode.createTextRange();
+		        range.collapse(true);
+		        range.moveEnd('character', x);
+		        range.moveStart('character', x);
+		        range.select();
+		    }
+		}catch(e){ /* squelch! */ }
+	},
+
+	postCreate: function(){
+		this.domNode.style.display=&quot;none&quot;;
+
+		if((typeof this.inputWidgetId != 'string')||(this.inputWidgetId.length == 0)){
+		    var w=dojo.widget.manager.getAllWidgets();
+		    for(var i=w.length-1; i&gt;=0; i--){
+		        if(w[i].adjustValue){
+					this.inputWidget = w[i];
+					break;
+		        }
+		    }
+		}else{
+		    this.inputWidget = dojo.widget.getWidgetById(this.inputWidgetId);
+		}
+
+		if(typeof this.inputWidget != 'object'){
+			dojo.lang.setTimeout(this, &quot;postCreate&quot;, 100); 
+			return;
+		}
+		var widgetNode = this.inputWidget.domNode;
+		var inputNodes = widgetNode.getElementsByTagName('INPUT');
+		this.inputNode = inputNodes[0];
+
+		/*
+		// unlink existing dom nodes from domNode
+		this.downArrowNode = dojo.dom.removeNode(this.downArrowNode);
+		this.upArrowNode = dojo.dom.removeNode(this.upArrowNode);
+		this.spacerNode = dojo.dom.removeNode(this.spacerNode);
+		this.innerRelNode = dojo.dom.removeNode(this.innerRelNode);
+		this.absNode = dojo.dom.removeNode(this.absNode);
+		this.relNode = dojo.dom.removeNode(this.relNode);
+		*/
+
+		// create a disconnected node
+		this.innerRelNode.appendChild(this.upArrowNode);
+		this.innerRelNode.appendChild(this.downArrowNode);
+		this.absNode.appendChild(this.innerRelNode);
+		this.relNode.appendChild(this.absNode);
+		this.relNode.appendChild(this.spacerNode);
+
+		dojo.event.connect(this.inputNode, &quot;onkeypress&quot;, this, &quot;onKeyPress&quot;);
+		dojo.event.connect(this.inputNode, &quot;onkeydown&quot;, this, &quot;onKeyDown&quot;);
+		dojo.event.connect(this.inputNode, &quot;onkeyup&quot;, this, &quot;arrowReleased&quot;);
+		dojo.event.connect(this.downArrowNode, &quot;onmousedown&quot;, this, &quot;downArrowPressed&quot;);
+		dojo.event.connect(this.downArrowNode, &quot;onmouseup&quot;, this, &quot;arrowReleased&quot;);
+		dojo.event.connect(this.upArrowNode, &quot;onmousedown&quot;, this, &quot;upArrowPressed&quot;);
+		dojo.event.connect(this.upArrowNode, &quot;onmouseup&quot;, this, &quot;arrowReleased&quot;);
+		if(this.inputNode.addEventListener){
+			// FIXME: why not use dojo.event.connect() to DOMMouseScroll here?
+		    this.inputNode.addEventListener('DOMMouseScroll', dojo.lang.hitch(this, &quot;mouseWheeled&quot;), false); // Mozilla + Firefox + Netscape
+		}else{
+		    dojo.event.connect(this.inputNode, &quot;onmousewheel&quot;, this, &quot;mouseWheeled&quot;); // IE + Safari
+		}
+
+		this.resizeDownArrow();
+		this.resizeUpArrow();
+		this.resizeSpacer();
+
+		// make sure the disconnected node will fit right next to the INPUT tag w/o any interference
+		dojo.html.copyStyle(this.relNode, this.inputNode);
+		with(this.relNode.style){
+			display = &quot;inline&quot;;
+			position = &quot;relative&quot;;
+			backgroundColor = &quot;&quot;;
+			marginLeft = &quot;-1px&quot;;
+			paddingLeft = &quot;0&quot;;
+		}
+		this.inputNode.style.marginRight = &quot;0px&quot;;
+		this.inputNode.style.paddingRight = &quot;0px&quot;;
+
+		// add the disconnected node right after the INPUT tag
+		dojo.dom.insertAfter(this.relNode, this.inputNode, false);
+		this.domNode = dojo.dom.removeNode(this.domNode);
+		// realign the spinner vertically in case there's a slight difference
+		var absOffset = dojo.html.getAbsoluteY(this.relNode,true)-dojo.html.getAbsoluteY(this.absNode,true);
+		this.absNode.style.top = absOffset-dojo.style.getBorderExtent(this.inputNode, &quot;top&quot;)+&quot;px&quot;;
+
+		var s = dojo.widget.html.stabile.getState(this.widgetId);
+		this.setValue(this.getValue());
+		if(s){
+			this.setState(s);
+		}
+	}
+});

Added: trunk/root/static/magic/src/widget/html/TaskBar.js
===================================================================
--- trunk/root/static/magic/src/widget/html/TaskBar.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/TaskBar.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,85 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.TaskBar&quot;);
+dojo.provide(&quot;dojo.widget.html.TaskBarItem&quot;);
+
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.FloatingPane&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.event&quot;);
+
+// Icon associated w/a floating pane
+dojo.widget.html.TaskBarItem = function(){
+	dojo.widget.TaskBarItem.call(this);
+	dojo.widget.HtmlWidget.call(this);
+}
+dojo.inherits(dojo.widget.html.TaskBarItem, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.TaskBarItem, {
+	// constructor arguments
+	iconSrc: '',
+	caption: 'Untitled',
+	window: null,
+	templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTaskBarItemTemplate.html&quot;),
+	templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTaskBar.css&quot;),
+
+	fillInTemplate: function() {
+		if ( this.iconSrc != '' ) {
+			var img = document.createElement(&quot;img&quot;);
+			img.src = this.iconSrc;
+			this.domNode.appendChild(img);
+		}
+		this.domNode.appendChild(document.createTextNode(this.caption));
+		dojo.html.disableSelection(this.domNode);
+	},
+
+	postCreate: function() {
+		this.window=dojo.widget.getWidgetById(this.windowId);
+		this.window.explodeSrc = this.domNode;
+		dojo.event.connect(this.window, &quot;destroy&quot;, this, &quot;destroy&quot;)
+	},
+
+	onClick: function() {
+		this.window.show();
+	}
+});
+
+// Collection of widgets in a bar, like Windows task bar
+dojo.widget.html.TaskBar = function(){
+
+	dojo.widget.html.FloatingPane.call(this);
+	dojo.widget.TaskBar.call(this);
+	this._addChildStack = [];
+}
+
+dojo.inherits(dojo.widget.html.TaskBar, dojo.widget.html.FloatingPane);
+
+dojo.lang.extend(dojo.widget.html.TaskBar, {
+
+	resizable: false,
+	titleBarDisplay: &quot;none&quot;,
+
+	addChild: function(child) {
+		if(!this.containerNode){ 
+			this._addChildStack.push(child);
+		}else if(this._addChildStack.length &gt; 0){
+			var oarr = this._addChildStack;
+			this._addChildStack = [];
+			dojo.lang.forEach(oarr, this.addChild, this);
+		}
+		var tbi = dojo.widget.createWidget(&quot;TaskBarItem&quot;,
+			{	windowId: child.widgetId, 
+				caption: child.title, 
+				iconSrc: child.iconSrc
+			});
+		dojo.widget.html.TaskBar.superclass.addChild.call(this,tbi);
+	}
+});

Added: trunk/root/static/magic/src/widget/html/TimePicker.js
===================================================================
--- trunk/root/static/magic/src/widget/html/TimePicker.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/TimePicker.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,249 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.TimePicker&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.TimePicker&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.date&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.html.TimePicker = function(){
+	dojo.widget.TimePicker.call(this);
+	dojo.widget.HtmlWidget.call(this);
+
+
+	var _this = this;
+	// selected time, JS Date object
+	this.time = &quot;&quot;;
+	// set following flag to true if a default time should be set
+	this.useDefaultTime = false;
+	// set the following to true to set default minutes to current time, false to // use zero
+	this.useDefaultMinutes = false;
+	// rfc 3339 date
+	this.storedTime = &quot;&quot;;
+	// time currently selected in the UI, stored in hours, minutes, seconds in the format that will be actually displayed
+	this.currentTime = {};
+	this.classNames = {
+		selectedTime: &quot;selectedItem&quot;
+	}
+	this.any = &quot;any&quot;
+	// dom node indecies for selected hour, minute, amPm, and &quot;any time option&quot;
+	this.selectedTime = {
+		hour: &quot;&quot;,
+		minute: &quot;&quot;,
+		amPm: &quot;&quot;,
+		anyTime: false
+	}
+
+	// minutes are ordered as follows: [&quot;12&quot;, &quot;6&quot;, &quot;1&quot;, &quot;7&quot;, &quot;2&quot;, &quot;8&quot;, &quot;3&quot;, &quot;9&quot;, &quot;4&quot;, &quot;10&quot;, &quot;5&quot;, &quot;11&quot;]
+	this.hourIndexMap = [&quot;&quot;, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11, 0];
+	// minutes are ordered as follows: [&quot;00&quot;, &quot;30&quot;, &quot;05&quot;, &quot;35&quot;, &quot;10&quot;, &quot;40&quot;, &quot;15&quot;, &quot;45&quot;, &quot;20&quot;, &quot;50&quot;, &quot;25&quot;, &quot;55&quot;]
+	this.minuteIndexMap = [0, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9, 11];
+
+	this.templatePath =  dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTimePicker.html&quot;);
+	this.templateCssPath = dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTimePicker.css&quot;);
+
+	this.fillInTemplate = function(){
+		this.initData();
+		this.initUI();
+	}
+
+	this.initData = function() {
+		// FIXME: doesn't currently validate the time before trying to set it
+		// Determine the date/time from stored info, or by default don't 
+		//  have a set time
+		// FIXME: should normalize against whitespace on storedTime... for now 
+		// just a lame hack
+		if(this.storedTime.indexOf(&quot;T&quot;)!=-1 &amp;&amp; this.storedTime.split(&quot;T&quot;)[1] &amp;&amp; this.storedTime!=&quot; &quot; &amp;&amp; this.storedTime.split(&quot;T&quot;)[1]!=&quot;any&quot;) {
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime(this.storedTime, this.useDefaultMinutes, this.selectedTime.anyTime);
+		} else if (this.useDefaultTime) {
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime(&quot;&quot;, this.useDefaultMinutes, this.selectedTime.anyTime);
+		} else {
+			this.selectedTime.anyTime = true;
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime(&quot;&quot;, 0, 1);
+		}
+	}
+
+	this.initUI = function() {
+		// set UI to match the currently selected time
+		if(!this.selectedTime.anyTime &amp;&amp; this.time) {
+			var amPmHour = dojo.widget.TimePicker.util.toAmPmHour(this.time.getHours());
+			var hour = amPmHour[0];
+			var isAm = amPmHour[1];
+			var minute = this.time.getMinutes();
+			var minuteIndex = parseInt(minute/5);
+			this.onSetSelectedHour(this.hourIndexMap[hour]);
+			this.onSetSelectedMinute(this.minuteIndexMap[minuteIndex]);
+			this.onSetSelectedAmPm(isAm);
+		} else {
+			this.onSetSelectedAnyTime();
+		}
+	}
+
+	this.setDateTime = function(rfcDate) {
+		this.storedTime = rfcDate;
+	}
+	
+	this.onClearSelectedHour = function(evt) {
+		this.clearSelectedHour();
+	}
+
+	this.onClearSelectedMinute = function(evt) {
+		this.clearSelectedMinute();
+	}
+
+	this.onClearSelectedAmPm = function(evt) {
+		this.clearSelectedAmPm();
+	}
+
+	this.onClearSelectedAnyTime = function(evt) {
+		this.clearSelectedAnyTime();
+		if(this.selectedTime.anyTime) {
+			this.selectedTime.anyTime = false;
+			this.time = dojo.widget.TimePicker.util.fromRfcDateTime(&quot;&quot;, this.useDefaultMinutes);
+			this.initUI();
+		}
+	}
+
+	this.clearSelectedHour = function() {
+		var hourNodes = this.hourContainerNode.getElementsByTagName(&quot;td&quot;);
+		for (var i=0; i&lt;hourNodes.length; i++) {
+			dojo.html.setClass(hourNodes.item(i), &quot;&quot;);
+		}
+	}
+
+	this.clearSelectedMinute = function() {
+		var minuteNodes = this.minuteContainerNode.getElementsByTagName(&quot;td&quot;);
+		for (var i=0; i&lt;minuteNodes.length; i++) {
+			dojo.html.setClass(minuteNodes.item(i), &quot;&quot;);
+		}
+	}
+
+	this.clearSelectedAmPm = function() {
+		var amPmNodes = this.amPmContainerNode.getElementsByTagName(&quot;td&quot;);
+		for (var i=0; i&lt;amPmNodes.length; i++) {
+			dojo.html.setClass(amPmNodes.item(i), &quot;&quot;);
+		}
+	}
+
+	this.clearSelectedAnyTime = function() {
+		dojo.html.setClass(this.anyTimeContainerNode, &quot;anyTimeContainer&quot;);
+	}
+
+	this.onSetSelectedHour = function(evt) {
+		this.onClearSelectedAnyTime();
+		this.onClearSelectedHour();
+		this.setSelectedHour(evt);
+		this.onSetTime();
+	}
+
+	this.setSelectedHour = function(evt) {
+		if(evt &amp;&amp; evt.target) {
+			dojo.html.setClass(evt.target, this.classNames.selectedTime);
+			this.selectedTime[&quot;hour&quot;] = evt.target.innerHTML;
+		} else if (!isNaN(evt)) {
+			var hourNodes = this.hourContainerNode.getElementsByTagName(&quot;td&quot;);
+			if(hourNodes.item(evt)) {
+				dojo.html.setClass(hourNodes.item(evt), this.classNames.selectedTime);
+				this.selectedTime[&quot;hour&quot;] = hourNodes.item(evt).innerHTML;
+			}
+		}
+		this.selectedTime.anyTime = false;
+	}
+
+	this.onSetSelectedMinute = function(evt) {
+		this.onClearSelectedAnyTime();
+		this.onClearSelectedMinute();
+		this.setSelectedMinute(evt);
+		this.selectedTime.anyTime = false;
+		this.onSetTime();
+	}
+
+	this.setSelectedMinute = function(evt) {
+		if(evt &amp;&amp; evt.target) {
+			dojo.html.setClass(evt.target, this.classNames.selectedTime);
+			this.selectedTime[&quot;minute&quot;] = evt.target.innerHTML;
+		} else if (!isNaN(evt)) {
+			var minuteNodes = this.minuteContainerNode.getElementsByTagName(&quot;td&quot;);
+			if(minuteNodes.item(evt)) {
+				dojo.html.setClass(minuteNodes.item(evt), this.classNames.selectedTime);
+				this.selectedTime[&quot;minute&quot;] = minuteNodes.item(evt).innerHTML;
+			}
+		}
+	}
+
+	this.onSetSelectedAmPm = function(evt) {
+		this.onClearSelectedAnyTime();
+		this.onClearSelectedAmPm();
+		this.setSelectedAmPm(evt);
+		this.selectedTime.anyTime = false;
+		this.onSetTime();
+	}
+
+	this.setSelectedAmPm = function(evt) {
+		if(evt &amp;&amp; evt.target) {
+			dojo.html.setClass(evt.target, this.classNames.selectedTime);
+			this.selectedTime[&quot;amPm&quot;] = evt.target.innerHTML;
+		} else {
+			evt = evt ? 0 : 1;
+			var amPmNodes = this.amPmContainerNode.getElementsByTagName(&quot;td&quot;);
+			if(amPmNodes.item(evt)) {
+				dojo.html.setClass(amPmNodes.item(evt), this.classNames.selectedTime);
+				this.selectedTime[&quot;amPm&quot;] = amPmNodes.item(evt).innerHTML;
+			}
+		}
+	}
+
+	this.onSetSelectedAnyTime = function(evt) {
+		this.onClearSelectedHour();
+		this.onClearSelectedMinute();
+		this.onClearSelectedAmPm();
+		this.setSelectedAnyTime();
+		this.onSetTime();
+	}
+
+	this.setSelectedAnyTime = function(evt) {
+		this.selectedTime.anyTime = true;
+		dojo.html.setClass(this.anyTimeContainerNode, this.classNames.selectedTime + &quot; &quot; + &quot;anyTimeContainer&quot;);
+	}
+
+	this.onClick = function(evt) {
+		dojo.event.browser.stopEvent(evt)
+	}
+
+	this.onSetTime = function() {
+		if(this.selectedTime.anyTime) {
+			this.time = new Date();
+			var tempDateTime = dojo.widget.TimePicker.util.toRfcDateTime(this.time);
+			this.setDateTime(tempDateTime.split(&quot;T&quot;)[0]);
+		} else {
+			var hour = 12;
+			var minute = 0;
+			var isAm = false;
+			if(this.selectedTime[&quot;hour&quot;]) {
+				hour = parseInt(this.selectedTime[&quot;hour&quot;], 10);
+			}
+			if(this.selectedTime[&quot;minute&quot;]) {
+				minute = parseInt(this.selectedTime[&quot;minute&quot;], 10);
+			}
+			if(this.selectedTime[&quot;amPm&quot;]) {
+				isAm = (this.selectedTime[&quot;amPm&quot;].toLowerCase() == &quot;am&quot;);
+			}
+			this.time = new Date();
+			this.time.setHours(dojo.widget.TimePicker.util.fromAmPmHour(hour, isAm));
+			this.time.setMinutes(minute);
+			this.setDateTime(dojo.widget.TimePicker.util.toRfcDateTime(this.time));
+		}
+	}
+
+}
+dojo.inherits(dojo.widget.html.TimePicker, dojo.widget.HtmlWidget);

Added: trunk/root/static/magic/src/widget/html/TitlePane.js
===================================================================
--- trunk/root/static/magic/src/widget/html/TitlePane.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/TitlePane.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,70 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.TitlePane&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.lfx.*&quot;);
+
+dojo.widget.html.TitlePane = function(){
+	dojo.widget.HtmlWidget.call(this);
+	this.widgetType = &quot;TitlePane&quot;;
+
+	this.labelNode=&quot;&quot;;
+	this.labelNodeClass=&quot;&quot;;
+	this.containerNodeClass=&quot;&quot;;
+	this.label=&quot;&quot;;
+
+	this.open=true;
+	this.templatePath = dojo.uri.dojoUri(&quot;src/widget/templates/TitlePane.html&quot;);
+}
+
+dojo.inherits(dojo.widget.html.TitlePane, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.TitlePane, {
+	isContainer: true,
+	postCreate: function() {
+		if (this.label) {
+			this.labelNode.appendChild(document.createTextNode(this.label));
+		}
+
+		if (this.labelNodeClass) {
+			dojo.html.addClass(this.labelNode, this.labelNodeClass);
+		}	
+
+		if (this.containerNodeClass) {
+			dojo.html.addClass(this.containerNode, this.containerNodeClass);
+		}	
+
+		if (!this.open) {
+			dojo.lfx.wipeOut(this.containerNode,0).play();
+		}
+	},
+
+	onLabelClick: function() {
+		if (this.open) {
+			dojo.lfx.wipeOut(this.containerNode,250).play();
+			this.open=false;
+		}else {
+			dojo.lfx.wipeIn(this.containerNode,250).play();
+			this.open=true;
+		}
+	},
+
+	setContent: function(content) {
+		this.containerNode.innerHTML=content;
+	},
+
+	setLabel: function(label) {
+		this.labelNode.innerHTML=label;
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TitlePane&quot;);

Added: trunk/root/static/magic/src/widget/html/Tooltip.js
===================================================================
--- trunk/root/static/magic/src/widget/html/Tooltip.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/Tooltip.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,183 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.Tooltip&quot;);
+dojo.require(&quot;dojo.widget.html.ContentPane&quot;);
+dojo.require(&quot;dojo.widget.Tooltip&quot;);
+dojo.require(&quot;dojo.uri&quot;);
+dojo.require(&quot;dojo.widget.*&quot;);
+dojo.require(&quot;dojo.event&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.html&quot;);
+
+dojo.widget.defineWidget(
+	&quot;dojo.widget.html.Tooltip&quot;,
+	dojo.widget.html.ContentPane,
+	{
+		widgetType: &quot;Tooltip&quot;,
+		isContainer: true,
+	
+		// Constructor arguments
+		caption: &quot;&quot;,
+		showDelay: 500,
+		hideDelay: 100,
+		connectId: &quot;&quot;,
+	
+		templatePath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTooltipTemplate.html&quot;),
+		templateCssPath: dojo.uri.dojoUri(&quot;src/widget/templates/HtmlTooltipTemplate.css&quot;),
+	
+		connectNode: null,
+	
+		// Tooltip has the following possible states:
+		//   erased - nothing on screen
+		//   displaying - currently being faded in (partially displayed)
+		//   displayed - fully displayed
+		//   erasing - currently being faded out (partially erased)
+		state: &quot;erased&quot;,
+	
+		fillInTemplate: function(args, frag){
+			if(this.caption != &quot;&quot;){
+				this.domNode.appendChild(document.createTextNode(this.caption));
+			}
+			this.connectNode = dojo.byId(this.connectId);		
+			dojo.widget.html.Tooltip.superclass.fillInTemplate.call(this, args, frag);
+		},
+		
+		postCreate: function(args, frag){
+			// The domnode was appended to my parent widget's domnode, but the positioning
+			// only works if the domnode is a child of document.body
+			document.body.appendChild(this.domNode);
+	
+			dojo.event.connect(this.connectNode, &quot;onmouseover&quot;, this, &quot;onMouseOver&quot;);
+			dojo.widget.html.Tooltip.superclass.postCreate.call(this, args, frag);
+		},
+		
+		onMouseOver: function(e) {
+			this.mouse = {x: e.pageX, y: e.pageY};
+	
+			if(!this.showTimer){
+				this.showTimer = setTimeout(dojo.lang.hitch(this, &quot;show&quot;), this.showDelay);
+				dojo.event.connect(document.documentElement, &quot;onmousemove&quot;, this, &quot;onMouseMove&quot;);
+			}
+		},
+	
+		onMouseMove: function(e) {
+			this.mouse = {x: e.pageX, y: e.pageY};
+	
+			if(dojo.html.overElement(this.connectNode, e) || dojo.html.overElement(this.domNode, e)) {
+				// If the tooltip has been scheduled to be erased, cancel that timer
+				// since we are hovering over element/tooltip again
+				if(this.hideTimer) {
+					clearTimeout(this.hideTimer);
+					delete this.hideTimer;
+				}
+			} else {
+				// mouse has been moved off the element/tooltip
+				// note: can't use onMouseOut to detect this because the &quot;explode&quot; effect causes
+				// spurious onMouseOut/onMouseOver events (due to interference from outline)
+				if(this.showTimer){
+					clearTimeout(this.showTimer);
+					delete this.showTimer;
+				}
+				if((this.state==&quot;displaying&quot;||this.state==&quot;displayed&quot;) &amp;&amp; !this.hideTimer){
+					this.hideTimer = setTimeout(dojo.lang.hitch(this, &quot;hide&quot;), this.hideDelay);
+				}
+			}
+		},
+	
+		show: function() {
+			if(this.state==&quot;erasing&quot;){
+				// we are in the process of erasing; when that is finished, display it.
+				this.displayScheduled=true;
+				return;
+			}
+			if ( this.state==&quot;displaying&quot; || this.state==&quot;displayed&quot; ) { return; }
+	
+			// prevent IE bleed through (iframe creation is deferred until first show()
+			// call because apparently it takes a long time)
+			if(!this.bgIframe){
+				this.bgIframe = new dojo.html.BackgroundIframe(this.domNode);
+			}
+	
+			this.position();
+	
+			// if rendering using explosion effect, need to set explosion source
+			this.explodeSrc = [this.mouse.x, this.mouse.y];
+	
+			this.state=&quot;displaying&quot;;
+	
+			dojo.widget.html.Tooltip.superclass.show.call(this);
+		},
+	
+		onShow: function() {
+			dojo.widget.html.Tooltip.superclass.onShow.call(this);
+			
+			this.state=&quot;displayed&quot;;
+			
+			// in the corner case where the user has moved his mouse away
+			// while the tip was fading in
+			if(this.eraseScheduled){
+				this.hide();
+				this.eraseScheduled=false;
+			}
+		},
+	
+		hide: function() {
+			if(this.state==&quot;displaying&quot;){
+				// in the process of fading in.  wait until that is finished and then fade out
+				this.eraseScheduled=true;
+				return;
+			}
+			if ( this.state==&quot;displayed&quot; ) {
+				this.state=&quot;erasing&quot;;
+				if ( this.showTimer ) {
+					clearTimeout(this.showTimer);
+					delete this.showTimer;
+				}
+				if ( this.hideTimer ) {
+					clearTimeout(this.hideTimer);
+					delete this.hideTimer;
+				}
+				dojo.event.disconnect(document.documentElement, &quot;onmousemove&quot;, this, &quot;onMouseMove&quot;);
+				dojo.widget.html.Tooltip.superclass.hide.call(this);
+			}
+		},
+	
+		onHide: function(){
+			this.state=&quot;erased&quot;;
+	
+			// in the corner case where the user has moved his mouse back
+			// while the tip was fading out
+			if(this.displayScheduled){
+				this.display();
+				this.displayScheduled=false;
+			}
+		},
+	
+		position: function(){
+			dojo.html.placeOnScreenPoint(this.domNode, this.mouse.x, this.mouse.y, [10,15], true);
+			this.bgIframe.onResized();
+		},
+	
+		onLoad: function(){
+			if(this.isShowing()){
+				// the tooltip has changed size due to downloaded contents, so reposition it
+				dojo.lang.setTimeout(this, this.position, 50);
+				dojo.widget.html.Tooltip.superclass.onLoad.apply(this, arguments);
+			}
+		},
+	
+		checkSize: function() {
+			// checkSize() is called when the user has resized the browser window,
+			// but that doesn't affect this widget (or this widget's children)
+			// so it can be safely ignored
+		}
+	}
+);

Added: trunk/root/static/magic/src/widget/html/YahooMap.js
===================================================================
--- trunk/root/static/magic/src/widget/html/YahooMap.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/YahooMap.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,180 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.html.YahooMap&quot;);
+dojo.require(&quot;dojo.event.*&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.math&quot;);
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.YahooMap&quot;);
+
+(function(){
+	var yappid = djConfig[&quot;yAppId&quot;]||djConfig[&quot;yahooAppId&quot;]||&quot;dojotoolkit&quot;;
+	if(!dojo.hostenv.post_load_){
+		if(yappid == &quot;dojotoolkit&quot;){
+			dojo.debug(&quot;please provide a unique Yahoo App ID in djConfig.yahooAppId when using the map widget&quot;);
+		}
+		var tag = &quot;&lt;scr&quot;+&quot;ipt src='<A HREF="http://api.maps.yahoo.com/ajaxymap?v=3.0&amp;appid=">http://api.maps.yahoo.com/ajaxymap?v=3.0&amp;appid=</A>&quot;+yappid+&quot;'&gt;&lt;/scri&quot;+&quot;pt&gt;&quot;;
+		if(!dj_global[&quot;YMap&quot;]){
+			document.write(tag);
+		}
+	}else{
+		dojo.debug(&quot;cannot initialize map system after the page has been loaded! Please either manually include the script block provided by Yahoo in your page or require() the YahooMap widget before onload has fired&quot;);
+	}
+})();
+
+dojo.widget.html.YahooMap=function(){
+	dojo.widget.HtmlWidget.call(this);
+	dojo.widget.YahooMap.call(this);
+
+	this.map=null;
+	this.datasrc=&quot;&quot;;
+	this.data=[];
+	this.width=0;
+	this.height=0;
+	this.controls=[&quot;zoomlong&quot;,&quot;maptype&quot;,&quot;pan&quot;];
+};
+dojo.inherits(dojo.widget.html.YahooMap, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.html.YahooMap, {
+	widgetType: &quot;YahooMap&quot;,
+	templatePath:null,
+	templateCssPath:null,
+
+	findCenter:function(aPts){
+		var start=new YGeoPoint(37,-90);
+		if(aPts.length==0) return start;
+		var minLat,maxLat, minLon, maxLon, cLat, cLon;
+		minLat=maxLat=aPts[0].Lat;
+		minLon=maxLon=aPts[0].Lon;
+		for(var i=0; i&lt;aPts.length; i++){
+			minLat=Math.min(minLat,aPts[i].Lat);
+			maxLat=Math.max(maxLat,aPts[i].Lat);
+			minLon=Math.min(minLon,aPts[i].Lon);
+			maxLon=Math.max(maxLon,aPts[i].Lon);
+		}
+		cLat=dojo.math.round((minLat+maxLat)/2,6);
+		cLon=dojo.math.round((minLon+maxLon)/2,6);
+		return new YGeoPoint(cLat,cLon);
+	},
+	setControls:function(){
+		var c=this.controls;
+		var t=dojo.widget.YahooMap.Controls;
+		for(var i=0; i&lt;c.length; i++){
+			switch(c[i]){
+				case t.MapType:{
+					this.map.addTypeControl();
+					break;
+				}
+				case t.Pan:{
+					this.map.addPanControl();
+					break;
+				}
+				case t.ZoomLong:{
+					this.map.addZoomLong();
+					break;
+				}
+				case t.ZoomShort:{
+					this.map.addZoomShort();
+					break;
+				}
+			}
+		}
+	},
+	
+	parse:function(table){
+		this.data=[];
+
+		//	get the column indices
+		var h=table.getElementsByTagName(&quot;thead&quot;)[0];
+		if(!h){
+			return;
+		}
+
+		var a=[];
+		var cols=h.getElementsByTagName(&quot;td&quot;);
+		if(cols.length==0){
+			cols=h.getElementsByTagName(&quot;th&quot;);
+		}
+		for(var i=0; i&lt;cols.length; i++){
+			var c=cols[i].innerHTML.toLowerCase();
+			if(c==&quot;long&quot;) c=&quot;lng&quot;;
+			a.push(c);
+		}
+		
+		//	parse the data
+		var b=table.getElementsByTagName(&quot;tbody&quot;)[0];
+		if(!b){
+			return;
+		}
+		for(var i=0; i&lt;b.childNodes.length; i++){
+			if(!(b.childNodes[i].nodeName&amp;&amp;b.childNodes[i].nodeName.toLowerCase()==&quot;tr&quot;)){
+				continue;
+			}
+			var cells=b.childNodes[i].getElementsByTagName(&quot;td&quot;);
+			var o={};
+			for(var j=0; j&lt;a.length; j++){
+				var col=a[j];
+				if(col==&quot;lat&quot;||col==&quot;lng&quot;){
+					o[col]=parseFloat(cells[j].innerHTML);					
+				}else{
+					o[col]=cells[j].innerHTML;
+				}
+			}
+			this.data.push(o);
+		}
+	},
+	render:function(){
+		var pts=[];
+		var d=this.data;
+		for(var i=0; i&lt;d.length; i++){
+			var pt=new YGeoPoint(d[i].lat, d[i].lng);
+			pts.push(pt);
+			var icon=d[i].icon||null;
+			if(icon){
+				icon=new YImage(icon);
+			}
+			var m=new YMarker(pt,icon);
+			if(d[i].description){
+				m.addAutoExpand(&quot;&lt;div&gt;&quot;+d[i].description+&quot;&lt;/div&gt;&quot;);
+			}
+			this.map.addOverlay(m);
+		}
+		var c=this.findCenter(pts);
+		var z=this.map.getZoomLevel(pts);
+		this.map.drawZoomAndCenter(c,z);
+	},
+	
+	initialize:function(args, frag){
+		if(!YMap || !YGeoPoint){
+			dojo.raise(&quot;dojo.widget.YahooMap: The Yahoo Map script must be included in order to use this widget.&quot;);
+		}
+		if(this.datasrc){
+			this.parse(dojo.byId(this.datasrc));
+		}
+		else if(this.domNode.getElementsByTagName(&quot;table&quot;)[0]){
+			this.parse(this.domNode.getElementsByTagName(&quot;table&quot;)[0]);
+		}
+	},
+	postCreate:function(){
+		//	clean the domNode before creating the map.
+		while(this.domNode.childNodes.length&gt;0){
+			this.domNode.removeChild(this.domNode.childNodes[0]);
+		}
+
+		if(this.width&gt;0&amp;&amp;this.height&gt;0){
+			this.map=new YMap(this.domNode, YAHOO_MAP_REG, new YSize(this.width, this.height));
+		}else{
+			this.map=new YMap(this.domNode);
+		}
+		this.setControls();
+		this.render();
+	}
+});

Added: trunk/root/static/magic/src/widget/html/stabile.js
===================================================================
--- trunk/root/static/magic/src/widget/html/stabile.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/html/stabile.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,213 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+// Maintain state of widgets when user hits back/forward button
+
+dojo.provide(&quot;dojo.widget.html.stabile&quot;);
+
+dojo.widget.html.stabile = {
+	// Characters to quote in single-quoted regexprs
+	_sqQuotables: new RegExp(&quot;([\\\\'])&quot;, &quot;g&quot;),
+
+	// Current depth.
+	_depth: 0,
+
+	// Set to true when calling v.toString, to sniff for infinite
+	// recursion.
+	_recur: false,
+
+	// Levels of nesting of Array and object displays.
+	// If when &gt;= depth, no display or array or object internals.
+	depthLimit: 2
+};
+
+
+
+
+
+//// PUBLIC METHODS
+
+// Get the state stored for the widget with the given ID, or undefined
+// if none.
+// 
+dojo.widget.html.stabile.getState = function(id){
+	dojo.widget.html.stabile.setup();
+	return dojo.widget.html.stabile.widgetState[id];
+}
+
+
+// Set the state stored for the widget with the given ID.  If isCommit
+// is true, commits all widget state to more stable storage.
+// 
+dojo.widget.html.stabile.setState = function(id, state, isCommit){
+	dojo.widget.html.stabile.setup();
+	dojo.widget.html.stabile.widgetState[id] = state;
+	if(isCommit){
+		dojo.widget.html.stabile.commit(dojo.widget.html.stabile.widgetState);
+	}
+}
+
+
+// Sets up widgetState: a hash keyed by widgetId, maps to an object
+// or array writable with &quot;describe&quot;.  If there is data in the widget
+// storage area, use it, otherwise initialize an empty object.
+// 
+dojo.widget.html.stabile.setup = function(){
+	if(!dojo.widget.html.stabile.widgetState){
+		var text = dojo.widget.html.stabile.getStorage().value;
+		dojo.widget.html.stabile.widgetState = text ? dj_eval(&quot;(&quot;+text+&quot;)&quot;) : {};
+	}
+}
+
+
+// Commits all widget state to more stable storage, so if the user
+// navigates away and returns, it can be restored.
+// 
+dojo.widget.html.stabile.commit = function(state){
+	dojo.widget.html.stabile.getStorage().value = dojo.widget.html.stabile.description(state);
+}
+
+// Return a JSON &quot;description string&quot; for the given value.
+// Supports only core JavaScript types with literals, plus Date,
+// and cyclic structures are unsupported.
+// showAll defaults to false -- if true, this becomes a simple symbolic
+// object dumper, but you cannot &quot;eval&quot; the output.
+//
+dojo.widget.html.stabile.description = function(v, showAll){
+	// Save and later restore dojo.widget.html.stabile._depth;
+	var depth = dojo.widget.html.stabile._depth;
+
+	var describeThis = function() {
+		 return this.description(this, true);
+	} 
+	
+	try {
+
+		if(v===void(0)){
+			return &quot;undefined&quot;;
+		}
+		if(v===null){
+			return &quot;null&quot;;
+		}
+		if(typeof(v)==&quot;boolean&quot; || typeof(v)==&quot;number&quot;
+		    || v instanceof Boolean || v instanceof Number){
+			return v.toString();
+		}
+
+		if(typeof(v)==&quot;string&quot; || v instanceof String){
+			// Quote strings and their contents as required.
+			// Replacing by $&amp; fails in IE 5.0
+			var v1 = v.replace(dojo.widget.html.stabile._sqQuotables, &quot;\\$1&quot;); 
+			v1 = v1.replace(/\n/g, &quot;\\n&quot;);
+			v1 = v1.replace(/\r/g, &quot;\\r&quot;);
+			// Any other important special cases?
+			return &quot;'&quot;+v1+&quot;'&quot;;
+		}
+
+		if(v instanceof Date){
+			// Create a data constructor.
+			return &quot;new Date(&quot;+d.getFullYear+&quot;,&quot;+d.getMonth()+&quot;,&quot;+d.getDate()+&quot;)&quot;;
+		}
+
+		var d;
+		if(v instanceof Array || v.push){
+			// &quot;push&quot; test needed for KHTML/Safari, don't know why -cp
+
+			if(depth&gt;=dojo.widget.html.stabile.depthLimit)
+			  return &quot;[ ... ]&quot;;
+
+			d = &quot;[&quot;;
+			var first = true;
+			dojo.widget.html.stabile._depth++;
+			for(var i=0; i&lt;v.length; i++){
+				// Skip functions and undefined values
+				// if(v[i]==undef || typeof(v[i])==&quot;function&quot;)
+				//   continue;
+				if(first){
+					first = false;
+				}else{
+					d += &quot;,&quot;;
+				}
+				d+=arguments.callee(v[i], showAll);
+			}
+			return d+&quot;]&quot;;
+		}
+
+		if(v.constructor==Object
+		    || v.toString==describeThis){
+			if(depth&gt;=dojo.widget.html.stabile.depthLimit)
+			  return &quot;{ ... }&quot;;
+
+			// Instanceof Hash is good, or if we just use Objects,
+			// we can say v.constructor==Object.
+			// IE (5?) lacks hasOwnProperty, but perhaps objects do not always
+			// have prototypes??
+			if(typeof(v.hasOwnProperty)!=&quot;function&quot; &amp;&amp; v.prototype){
+				throw new Error(&quot;description: &quot;+v+&quot; not supported by script engine&quot;);
+			}
+			var first = true;
+			d = &quot;{&quot;;
+			dojo.widget.html.stabile._depth++;
+			for(var key in v){
+				// Skip values that are functions or undefined.
+				if(v[key]==void(0) || typeof(v[key])==&quot;function&quot;)
+					continue;
+				if(first){
+					first = false;
+				}else{
+					d += &quot;, &quot;;
+				}
+				var kd = key;
+				// If the key is not a legal identifier, use its description.
+				// For strings this will quote the stirng.
+				if(!kd.match(/^[a-zA-Z_][a-zA-Z0-9_]*$/)){
+					kd = arguments.callee(key, showAll);
+				}
+				d += kd+&quot;: &quot;+arguments.callee(v[key], showAll);
+			}
+			return d+&quot;}&quot;;
+		}
+
+		if(showAll){
+			if(dojo.widget.html.stabile._recur){
+				// Save the original definitions of toString;
+				var objectToString = Object.prototype.toString;
+				return objectToString.apply(v, []);
+			}else{
+				dojo.widget.html.stabile._recur = true;
+				return v.toString();
+			}
+		}else{
+			// log(&quot;Description? &quot;+v.toString()+&quot;, &quot;+typeof(v));
+			throw new Error(&quot;Unknown type: &quot;+v);
+			return &quot;'unknown'&quot;;
+		}
+
+	} finally {
+		// Always restore the global current depth.
+		dojo.widget.html.stabile._depth = depth;
+	}
+
+}
+
+
+
+//// PRIVATE TO MODULE
+
+// Gets an object (form field) with a read/write &quot;value&quot; property.
+// 
+dojo.widget.html.stabile.getStorage = function(){
+	if (dojo.widget.html.stabile.dataField) {
+		return dojo.widget.html.stabile.dataField;
+	}
+	var form = document.forms._dojo_form;
+	return dojo.widget.html.stabile.dataField = form ? form.stabile : {value: &quot;&quot;};
+}
+

Added: trunk/root/static/magic/src/widget/svg/Chart.js
===================================================================
--- trunk/root/static/magic/src/widget/svg/Chart.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/svg/Chart.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,531 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.svg.Chart&quot;);
+
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.Chart&quot;);
+dojo.require(&quot;dojo.math&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.svg&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+
+dojo.widget.svg.Chart=function(){
+	dojo.widget.Chart.call(this);
+	dojo.widget.HtmlWidget.call(this);
+};
+dojo.inherits(dojo.widget.svg.Chart, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.svg.Chart, {
+	//	widget props
+	templatePath:null,
+	templateCssPath:null,
+
+	//	state
+	_isInitialized:false,
+	hasData:false,
+
+	//	chart props
+	vectorNode:null,
+	plotArea:null,
+	dataGroup:null,
+	axisGroup:null,
+
+	properties:{
+		height:400,	//	defaults, will resize to the domNode.
+		width:600,
+		plotType:null,
+		padding:{
+			top:10,
+			bottom:2,
+			left:60,
+			right:30
+		},
+		axes:{
+			x:{
+				plotAt:0,
+				label:&quot;&quot;,
+				unitLabel:&quot;&quot;,
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
+			},
+			y:{
+				plotAt:0,
+				label:&quot;&quot;,
+				unitLabel:&quot;&quot;,
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
+			}
+		}
+	},
+	
+	fillInTemplate:function(args,frag){
+		this.initialize();
+		this.render();
+	},
+	parseData:function(){
+	},
+	initialize:function(){
+		this.parseData();
+	
+		//	begin by grabbing the table, and reading it in.
+		var table=this.domNode.getElementsByTagName(&quot;table&quot;)[0];
+		if (!table) return;
+		
+		var bRangeX=false;
+		var bRangeY=false;
+		
+		//	properties off the table
+		if (table.getAttribute(&quot;width&quot;)) this.properties.width=table.getAttribute(&quot;width&quot;);
+		if (table.getAttribute(&quot;height&quot;)) this.properties.height=table.getAttribute(&quot;height&quot;);
+		if (table.getAttribute(&quot;plotType&quot;)) this.properties.plotType=table.getAttribute(&quot;plotType&quot;);
+		if (table.getAttribute(&quot;padding&quot;)){
+			if (table.getAttribute(&quot;padding&quot;).indexOf(&quot;,&quot;) &gt; -1)
+				var p=table.getAttribute(&quot;padding&quot;).split(&quot;,&quot;); 
+			else var p=table.getAttribute(&quot;padding&quot;).split(&quot; &quot;);
+			if (p.length==1){
+				var pad=parseFloat(p[0]);
+				this.properties.padding.top=pad;
+				this.properties.padding.right=pad;
+				this.properties.padding.bottom=pad;
+				this.properties.padding.left=pad;
+			} else if(p.length==2){
+				var padV=parseFloat(p[0]);
+				var padH=parseFloat(p[1]);
+				this.properties.padding.top=padV;
+				this.properties.padding.right=padH;
+				this.properties.padding.bottom=padV;
+				this.properties.padding.left=padH;
+			} else if(p.length==4){
+				this.properties.padding.top=parseFloat(p[0]);
+				this.properties.padding.right=parseFloat(p[1]);
+				this.properties.padding.bottom=parseFloat(p[2]);
+				this.properties.padding.left=parseFloat(p[3]);
+			}
+		}
+		if (table.getAttribute(&quot;rangeX&quot;)){
+			var p=table.getAttribute(&quot;rangeX&quot;);
+			if (p.indexOf(&quot;,&quot;)&gt;-1) p=p.split(&quot;,&quot;);
+			else p=p.split(&quot; &quot;);
+			this.properties.axes.x.range.min=parseFloat(p[0]);
+			this.properties.axes.x.range.max=parseFloat(p[1]);
+			bRangeX=true;
+		}
+		if (table.getAttribute(&quot;rangeY&quot;)){
+			var p=table.getAttribute(&quot;rangeY&quot;);
+			if (p.indexOf(&quot;,&quot;)&gt;-1) p=p.split(&quot;,&quot;);
+			else p=p.split(&quot; &quot;);
+			this.properties.axes.y.range.min=parseFloat(p[0]);
+			this.properties.axes.y.range.max=parseFloat(p[1]);
+			bRangeY=true;
+		}
+
+		var thead=table.getElementsByTagName(&quot;thead&quot;)[0];
+		var tbody=table.getElementsByTagName(&quot;tbody&quot;)[0];
+		if(!(thead&amp;&amp;tbody)) dojo.raise(&quot;dojo.widget.Chart: supplied table must define a head and a body.&quot;);
+
+		//	set up the series.
+		var columns=thead.getElementsByTagName(&quot;tr&quot;)[0].getElementsByTagName(&quot;th&quot;);	//	should be &lt;tr&gt;&lt;..&gt;
+		
+		//	assume column 0 == X
+		for (var i=1; i&lt;columns.length; i++){
+			var key=&quot;column&quot;+i;
+			var label=columns[i].innerHTML;
+			var plotType=columns[i].getAttribute(&quot;plotType&quot;)||&quot;line&quot;;
+			var color=columns[i].getAttribute(&quot;color&quot;);
+			var ds=new dojo.widget.Chart.DataSeries(key,label,plotType,color);
+			this.series.push(ds);
+		}
+
+		//	ok, get the values.
+		var rows=tbody.getElementsByTagName(&quot;tr&quot;);
+		var xMin=Number.MAX_VALUE,xMax=Number.MIN_VALUE;
+		var yMin=Number.MAX_VALUE,yMax=Number.MIN_VALUE;
+		var ignore = [
+			&quot;accesskey&quot;,&quot;align&quot;,&quot;bgcolor&quot;,&quot;class&quot;,
+			&quot;colspan&quot;,&quot;height&quot;,&quot;id&quot;,&quot;nowrap&quot;,
+			&quot;rowspan&quot;,&quot;style&quot;,&quot;tabindex&quot;,&quot;title&quot;,
+			&quot;valign&quot;,&quot;width&quot;
+		];
+
+		for(var i=0; i&lt;rows.length; i++){
+			var row=rows[i];
+			var cells=row.getElementsByTagName(&quot;td&quot;);
+			var x=Number.MIN_VALUE;
+			for (var j=0; j&lt;cells.length; j++){
+				if (j==0){
+					x=parseFloat(cells[j].innerHTML);
+					xMin=Math.min(xMin, x);
+					xMax=Math.max(xMax, x);
+				} else {
+					var ds=this.series[j-1];
+					var y=parseFloat(cells[j].innerHTML);
+					yMin=Math.min(yMin,y);
+					yMax=Math.max(yMax,y);
+					var o={x:x, value:y};
+					var attrs=cells[j].attributes;
+					for(var k=0; k&lt;attrs.length; k++){
+						var attr=attrs.item(k);
+						var bIgnore=false;
+						for (var l=0; l&lt;ignore.length; l++){
+							if (attr.nodeName.toLowerCase()==ignore[l]){
+								bIgnore=true;
+								break;
+							}
+						}
+						if(!bIgnore) o[attr.nodeName]=attr.nodeValue;
+					}
+					ds.add(o);
+				}
+			}
+		}
+
+		//	fix the axes
+		if(!bRangeX){
+			this.properties.axes.x.range={min:xMin, max:xMax};
+		}
+		if(!bRangeY){
+			this.properties.axes.y.range={min:yMin, max:yMax};
+		}
+
+		//	where to plot the axes
+		if (table.getAttribute(&quot;axisAt&quot;)){
+			var p=table.getAttribute(&quot;axisAt&quot;);
+			if (p.indexOf(&quot;,&quot;)&gt;-1) p=p.split(&quot;,&quot;);
+			else p=p.split(&quot; &quot;);
+			
+			//	x axis
+			if (!isNaN(parseFloat(p[0]))){
+				this.properties.axes.x.plotAt=parseFloat(p[0]);
+			} else if (p[0].toLowerCase()==&quot;ymin&quot;){
+				this.properties.axes.x.plotAt=this.properties.axes.y.range.min;
+			} else if (p[0].toLowerCase()==&quot;ymax&quot;){
+				this.properties.axes.x.plotAt=this.properties.axes.y.range.max;
+			}
+
+			// y axis
+			if (!isNaN(parseFloat(p[1]))){
+				this.properties.axes.y.plotAt=parseFloat(p[1]);
+			} else if (p[1].toLowerCase()==&quot;xmin&quot;){
+				this.properties.axes.y.plotAt=this.properties.axes.x.range.min;
+			} else if (p[1].toLowerCase()==&quot;xmax&quot;){
+				this.properties.axes.y.plotAt=this.properties.axes.x.range.max;
+			}
+		} else {
+			this.properties.axes.x.plotAt=this.properties.axes.y.range.min;
+			this.properties.axes.y.plotAt=this.properties.axes.x.range.min;
+		}
+
+		//	table values should be populated, now pop it off.
+		this.domNode.removeChild(table);
+
+		//	get the width and the height.
+//		this.properties.width=dojo.html.getInnerWidth(this.domNode);
+//		this.properties.height=dojo.html.getInnerHeight(this.domNode);
+
+		// ok, lets create the chart itself.
+		dojo.svg.g.suspend();		
+		if(this.vectorNode) this.destroy();
+		this.vectorNode=document.createElementNS(dojo.svg.xmlns.svg, &quot;svg&quot;);
+		this.vectorNode.setAttribute(&quot;width&quot;, this.properties.width);
+		this.vectorNode.setAttribute(&quot;height&quot;, this.properties.height);
+
+		//	set up the clip path for the plot area.
+		var defs = document.createElementNS(dojo.svg.xmlns.svg, &quot;defs&quot;);
+		var clip = document.createElementNS(dojo.svg.xmlns.svg, &quot;clipPath&quot;);
+		clip.setAttribute(&quot;id&quot;,&quot;plotClip&quot;+this.widgetId);
+		var rect = document.createElementNS(dojo.svg.xmlns.svg, &quot;rect&quot;);		
+		rect.setAttribute(&quot;x&quot;, this.properties.padding.left);
+		rect.setAttribute(&quot;y&quot;, this.properties.padding.top);
+		rect.setAttribute(&quot;width&quot;, this.properties.width-this.properties.padding.left-this.properties.padding.right);
+		rect.setAttribute(&quot;height&quot;, this.properties.height-this.properties.padding.bottom-this.properties.padding.bottom);
+		clip.appendChild(rect);
+		defs.appendChild(clip);
+		this.vectorNode.appendChild(defs);
+
+		//	the plot background.
+		this.plotArea = document.createElementNS(dojo.svg.xmlns.svg, &quot;g&quot;);
+		this.vectorNode.appendChild(this.plotArea);
+		var rect = document.createElementNS(dojo.svg.xmlns.svg, &quot;rect&quot;);		
+		rect.setAttribute(&quot;x&quot;, this.properties.padding.left);
+		rect.setAttribute(&quot;y&quot;, this.properties.padding.top);
+		rect.setAttribute(&quot;width&quot;, this.properties.width-this.properties.padding.left-this.properties.padding.right);
+		rect.setAttribute(&quot;height&quot;, this.properties.height-this.properties.padding.bottom-this.properties.padding.bottom);
+		rect.setAttribute(&quot;fill&quot;, &quot;#fff&quot;);
+		this.plotArea.appendChild(rect);
+
+		//	data group
+		this.dataGroup = document.createElementNS(dojo.svg.xmlns.svg, &quot;g&quot;);
+		this.dataGroup.setAttribute(&quot;style&quot;,&quot;clip-path:url(#plotClip&quot;+this.widgetId+&quot;);&quot;);
+		this.plotArea.appendChild(this.dataGroup);
+
+		//	axis group
+		this.axisGroup = document.createElementNS(dojo.svg.xmlns.svg, &quot;g&quot;);
+		this.plotArea.appendChild(this.axisGroup);
+
+		//	x axis
+		var stroke=1;
+		var line = document.createElementNS(dojo.svg.xmlns.svg, &quot;line&quot;);
+		var y=dojo.widget.svg.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
+		line.setAttribute(&quot;y1&quot;, y);
+		line.setAttribute(&quot;y2&quot;, y);
+		line.setAttribute(&quot;x1&quot;,this.properties.padding.left-stroke);
+		line.setAttribute(&quot;x2&quot;,this.properties.width-this.properties.padding.right);
+		line.setAttribute(&quot;style&quot;,&quot;stroke:#000;stroke-width:&quot;+stroke+&quot;;&quot;);
+		this.axisGroup.appendChild(line);
+		
+		//	x axis units.
+		//	(min and max)
+		var textSize=10;
+		var text = document.createElementNS(dojo.svg.xmlns.svg, &quot;text&quot;);
+		text.setAttribute(&quot;x&quot;, this.properties.padding.left);
+		text.setAttribute(&quot;y&quot;, this.properties.height-this.properties.padding.bottom+textSize+2);
+		text.setAttribute(&quot;style&quot;, &quot;text-anchor:middle;font-size:&quot;+textSize+&quot;px;fill:#000;&quot;);
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.min),2)));
+		this.axisGroup.appendChild(text);
+		
+		var text = document.createElementNS(dojo.svg.xmlns.svg, &quot;text&quot;);
+		text.setAttribute(&quot;x&quot;, this.properties.width-this.properties.padding.right-(textSize/2));
+		text.setAttribute(&quot;y&quot;, this.properties.height-this.properties.padding.bottom+textSize+2);
+		text.setAttribute(&quot;style&quot;, &quot;text-anchor:middle;font-size:&quot;+textSize+&quot;px;fill:#000;&quot;);
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.x.range.max),2)));
+		this.axisGroup.appendChild(text);	
+		
+		//	y axis
+		var line=document.createElementNS(dojo.svg.xmlns.svg, &quot;line&quot;);
+		var x=dojo.widget.svg.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
+		line.setAttribute(&quot;x1&quot;, x);
+		line.setAttribute(&quot;x2&quot;, x);
+		line.setAttribute(&quot;y1&quot;, this.properties.padding.top);
+		line.setAttribute(&quot;y2&quot;, this.properties.height-this.properties.padding.bottom);
+		line.setAttribute(&quot;style&quot;, &quot;stroke:#000;stroke-width:&quot;+stroke+&quot;;&quot;);
+		this.axisGroup.appendChild(line);
+
+		//	y axis units
+		var text = document.createElementNS(dojo.svg.xmlns.svg, &quot;text&quot;);
+		text.setAttribute(&quot;x&quot;, this.properties.padding.left-4);
+		text.setAttribute(&quot;y&quot;, this.properties.height-this.properties.padding.bottom);
+		text.setAttribute(&quot;style&quot;, &quot;text-anchor:end;font-size:&quot;+textSize+&quot;px;fill:#000;&quot;);
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.min),2)));
+		this.axisGroup.appendChild(text);
+		
+		var text = document.createElementNS(dojo.svg.xmlns.svg, &quot;text&quot;);
+		text.setAttribute(&quot;x&quot;, this.properties.padding.left-4);
+		text.setAttribute(&quot;y&quot;, this.properties.padding.top+(textSize/2));
+		text.setAttribute(&quot;style&quot;, &quot;text-anchor:end;font-size:&quot;+textSize+&quot;px;fill:#000;&quot;);
+		text.appendChild(document.createTextNode(dojo.math.round(parseFloat(this.properties.axes.y.range.max),2)));
+		this.axisGroup.appendChild(text);	
+
+		this.domNode.appendChild(this.vectorNode);
+		dojo.svg.g.resume();
+
+		//	this is last.
+		this.assignColors();
+		this._isInitialized=true;
+	},
+	destroy:function(){
+		while(this.domNode.childNodes.length&gt;0){
+			this.domNode.removeChild(this.domNode.childNodes.item(0));
+		}
+		this.vectorNode=this.plotArea=this.dataGroup=this.axisGroup=null;
+	},
+	render:function(){
+		dojo.svg.g.suspend();
+		
+		if (this.dataGroup){
+			while(this.dataGroup.childNodes.length&gt;0){
+				this.dataGroup.removeChild(this.dataGroup.childNodes.item(0));
+			}
+		} else {
+			this.initialize();
+		}
+
+		//	the remove/append is an attempt to streamline the rendering, it's totally optional
+//		var p=this.dataGroup.parentNode;
+//		p.removeChild(this.dataGroup);
+		for(var i=0; i&lt;this.series.length; i++){
+			dojo.widget.svg.Chart.Plotter.plot(this.series[i], this);
+		}
+//		p.appendChild(this.dataGroup);
+		
+		dojo.svg.g.resume();
+	}
+});
+
+dojo.widget.svg.Chart.Plotter=new function(){
+	var _this=this;
+	var plotters = {};
+	var types=dojo.widget.Chart.PlotTypes;
+	
+	this.getX=function(value, chart){
+		var v=parseFloat(value);
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+		min+=ofst; max+=ofst; v+=ofst;
+
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var x=(v*((xmax-xmin)/max))+xmin;
+		return x;
+	};
+	this.getY=function(value, chart){
+		var v=parseFloat(value);
+		var max=chart.properties.axes.y.range.max;
+		var min=chart.properties.axes.y.range.min;
+		var ofst=0;
+		if(min&lt;0)ofst+=Math.abs(min);
+		min+=ofst; max+=ofst; v+=ofst;
+		
+		var ymin=chart.properties.height-chart.properties.padding.bottom;
+		var ymax=chart.properties.padding.top;
+		var y=(((ymin-ymax)/(max-min))*(max-v))+ymax;
+		return y;
+	};
+
+	this.addPlotter=function(name, func){
+		plotters[name]=func;
+	};
+	this.plot=function(series, chart){
+		if (series.values.length==0) return;
+		if (series.plotType &amp;&amp; plotters[series.plotType]){
+			return plotters[series.plotType](series, chart);
+		}
+		else if (chart.plotType &amp;&amp; plotters[chart.plotType]){
+			return plotters[chart.plotType](series, chart);
+		}
+	};
+
+	//	plotting
+	plotters[types.Bar]=function(series, chart){
+		var space=1;
+		var lastW = 0;
+		for (var i=0; i&lt;series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var w;
+			if (i==series.values.length-1){
+				w=lastW;
+			} else{
+				w=_this.getX(series.values[i+1].x, chart)-x-space;
+				lastW=w;
+			}
+			x-=(w/2);
+
+			var yA=_this.getY(chart.properties.axes.x.plotAt, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var h=Math.abs(yA-y);
+			if (parseFloat(series.values[i].value)&lt;chart.properties.axes.x.plotAt){
+				var oy=yA;
+				yA=y;
+				y=oy;
+			}
+
+			var bar=document.createElementNS(dojo.svg.xmlns.svg, &quot;rect&quot;);
+			bar.setAttribute(&quot;fill&quot;, series.color);
+			bar.setAttribute(&quot;title&quot;, series.label + &quot;: &quot; + series.values[i].value);
+			bar.setAttribute(&quot;stroke-width&quot;, &quot;0&quot;);
+			bar.setAttribute(&quot;x&quot;, x);
+			bar.setAttribute(&quot;y&quot;, y);
+			bar.setAttribute(&quot;width&quot;, w);
+			bar.setAttribute(&quot;height&quot;, h);
+			bar.setAttribute(&quot;fill-opacity&quot;, &quot;0.9&quot;);
+			chart.dataGroup.appendChild(bar);
+		}
+	};
+	plotters[types.Line]=function(series, chart){
+		var tension=3;
+		var line = document.createElementNS(dojo.svg.xmlns.svg, &quot;path&quot;);
+		line.setAttribute(&quot;fill&quot;, &quot;none&quot;);
+		line.setAttribute(&quot;stroke&quot;, series.color);
+		line.setAttribute(&quot;stroke-width&quot;, &quot;2&quot;);
+		line.setAttribute(&quot;stroke-opacity&quot;, &quot;0.85&quot;);
+		line.setAttribute(&quot;title&quot;, series.label);
+		chart.dataGroup.appendChild(line);
+
+		var path = [];
+		for (var i=0; i&lt;series.values.length; i++){
+			var x = _this.getX(series.values[i].x, chart)
+			var y = _this.getY(series.values[i].value, chart);
+
+			var dx = chart.properties.padding.left+1;
+			var dy = chart.properties.height-chart.properties.padding.bottom;
+			if (i&gt;0){
+				dx=x-_this.getX(series.values[i-1].x, chart);
+				dy=_this.getY(series.values[i-1].value, chart);
+			}
+			
+			if (i==0) path.push(&quot;M&quot;);
+			else {
+				path.push(&quot;C&quot;);
+				var cx=x-(tension-1)*(dx/tension);
+				path.push(cx+&quot;,&quot;+dy);
+				cx=x-(dx/tension);
+				path.push(cx+&quot;,&quot;+y);
+			}
+			path.push(x+&quot;,&quot;+y);
+		}
+		line.setAttribute(&quot;d&quot;, path.join(&quot; &quot;));
+	};
+	plotters[types.Scatter]=function(series, chart){
+		var r=7;
+		for (var i=0; i&lt;series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var point = document.createElementNS(dojo.svg.xmlns.svg, &quot;path&quot;);
+			point.setAttribute(&quot;fill&quot;, series.color);
+			point.setAttribute(&quot;stroke-width&quot;, &quot;0&quot;);
+			point.setAttribute(&quot;title&quot;, series.label + &quot;: &quot; + series.values[i].value);
+			point.setAttribute(&quot;d&quot;,
+				&quot;M &quot; + x + &quot;,&quot; + (y-r) + &quot; &quot; +
+				&quot;Q &quot; + x + &quot;,&quot; + y + &quot; &quot; + (x+r) + &quot;,&quot; + y + &quot; &quot; +
+				&quot;Q &quot; + x + &quot;,&quot; + y + &quot; &quot; + x + &quot;,&quot; + (y+r) + &quot; &quot; +
+				&quot;Q &quot; + x + &quot;,&quot; + y + &quot; &quot; + (x-r) + &quot;,&quot; + y + &quot; &quot; +
+				&quot;Q &quot; + x + &quot;,&quot; + y + &quot; &quot; + x + &quot;,&quot; + (y-r) + &quot; &quot; +
+				&quot;Z&quot;
+			);
+			chart.dataGroup.appendChild(point);
+		}
+	};
+	plotters[types.Bubble]=function(series, chart){
+		//	added param for series[n].value: size
+		var minR=1;
+		
+		//	do this off the x axis?
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+		min+=ofst; max+=ofst;
+
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var factor=(max-min)/(xmax-xmin)*25;
+		
+		for (var i=0; i&lt;series.values.length; i++){
+			var size = series.values[i].size;
+			if (isNaN(parseFloat(size))) size=minR;
+			var point=document.createElementNS(dojo.svg.xmlns.svg, &quot;circle&quot;);
+			point.setAttribute(&quot;stroke-width&quot;, 0);
+			point.setAttribute(&quot;fill&quot;, series.color);
+			point.setAttribute(&quot;fill-opacity&quot;, &quot;0.8&quot;);
+			point.setAttribute(&quot;r&quot;, (parseFloat(size)*factor)/2);
+			point.setAttribute(&quot;cx&quot;, _this.getX(series.values[i].x, chart));
+			point.setAttribute(&quot;cy&quot;, _this.getY(series.values[i].value, chart));
+			point.setAttribute(&quot;title&quot;, series.label + &quot;: &quot; + series.values[i].value + &quot; (&quot; + size + &quot;)&quot;);
+			chart.dataGroup.appendChild(point);
+		}
+	};
+}();

Added: trunk/root/static/magic/src/widget/templates/DemoEngine.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/DemoEngine.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/DemoEngine.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,24 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+	&lt;div dojoAttachPoint=&quot;navigationNode&quot;&gt;
+		&lt;table border=&quot;0&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;
+			&lt;tr&gt;
+				&lt;td width=&quot;1%&quot; valign=&quot;top&quot; class=&quot;navigationCell&quot;&gt;&lt;h1&gt;Categories&lt;/h1&gt;&lt;div dojoAttachPoint=&quot;menuNavigationNode&quot;&gt;&lt;/div&gt;&lt;/td&gt;
+				&lt;td width=&quot;99%&quot; valign=&quot;top&quot;&gt;
+					&lt;div dojoAttachPoint=&quot;demoNavigationNode&quot;&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/table&gt;
+	&lt;/div&gt;
+
+	&lt;div dojoAttachPoint=&quot;demoContainerNode&quot;&gt;
+
+		&lt;div dojoAttachPoint=&quot;demoPaneNode&quot;&gt;
+		&lt;/div&gt;
+
+		&lt;div dojoAttachPoint=&quot;demoHeaderNode&quot;&gt;
+			&lt;span dojoAttachPoint=&quot;collapsedMenuNode&quot; dojoAttachEvent=&quot;onclick: expandDemoNavigation&quot;&gt;&lt;/span&gt;
+			&lt;div dojoAttachPoint=&quot;aboutNode&quot;&gt;About this Demo&lt;/div&gt;
+		&lt;/div&gt;
+	&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,59 @@
+/* ---- button --- */
+.dojoButton {
+	padding: 0 0 0 0;
+	font-size: 8pt;
+	white-space: nowrap;
+	cursor: pointer;
+	font-family: Myriad, Tahoma, Verdana, sans-serif;
+}
+
+.dojoButton .dojoButtonContents {
+	padding: 2px 2px 2px 2px;
+	text-align: center;		/* if icon and label are split across two lines, center icon */
+	color: white;
+}
+
+.dojoButtonLeftPart .dojoButtonContents {
+	padding-right: 8px;
+}
+
+.dojoButtonDisabled {
+	cursor: url(&quot;images/no.gif&quot;), default;
+}
+
+
+.dojoButtonContents img {
+	vertical-align: middle;	/* if icon and label are on same line, center them */
+}
+
+/* -------- colors ------------ */
+
+.dojoButtonHover .dojoButtonContents {
+}
+
+.dojoButtonDepressed .dojoButtonContents {
+	color: #293a4b;
+}
+
+.dojoButtonDisabled .dojoButtonContents {
+	color: #eeeeee;
+}
+
+
+/* ---------- drop down button specific ---------- */
+
+/* border between label and arrow (for drop down buttons */
+.dojoButton .border {
+	width: 1px;
+	background: gray;
+}
+
+/* button arrow */
+.dojoButton .downArrow {
+	padding-left: 10px;
+	text-align: center;
+}
+
+.dojoButton.disabled .downArrow {
+	cursor : default;
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlButtonTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,6 @@
+&lt;div class=&quot;dojoButton&quot; style=&quot;position:relative;&quot; dojoAttachEvent=&quot;onMouseOver; onMouseOut; onMouseDown; onMouseUp; onClick:buttonClick;&quot;&gt;
+  &lt;div class=&quot;dojoButtonContents&quot; align=center dojoAttachPoint=&quot;containerNode&quot; style=&quot;position:absolute;z-index:2;&quot;&gt;&lt;/div&gt;
+  &lt;img dojoAttachPoint=&quot;leftImage&quot; style=&quot;position:absolute;left:0px;&quot;&gt;
+  &lt;img dojoAttachPoint=&quot;centerImage&quot; style=&quot;position:absolute;z-index:1;&quot;&gt;
+  &lt;img dojoAttachPoint=&quot;rightImage&quot; style=&quot;position:absolute;top:0px;right:0px;&quot;&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlCheckBox.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlCheckBox.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlCheckBox.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,6 @@
+&lt;span&gt;
+	&lt;input type=&quot;checkbox&quot; name=&quot;${this.name}&quot; checked=&quot;${this.checked}&quot; tabIndex=&quot;${this.tabIndex}&quot; style=&quot;display: none&quot;
+		dojoAttachPoint=&quot;inputNode&quot;&gt;
+	&lt;img src='${this.imgSrc}' class='dojoHtmlCheckbox'
+		dojoAttachPoint=&quot;imgNode&quot; dojoAttachEvent=&quot;onMouseUp;onMouseOver;onMouseOut&quot;&gt;
+&lt;/span&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlCiviCrmDatePicker.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot; width=&quot;400&quot;&gt;
+	&lt;tr&gt;
+		&lt;td id=&quot;dateHolderTd&quot; width=&quot;200&quot;&gt;
+		&lt;/td&gt;
+		&lt;td id=&quot;timeHolderTd&quot; width=&quot;200&quot;&gt;
+		&lt;/td&gt;
+	&lt;/tr&gt;
+	&lt;tr style=&quot;display: none;&quot; id=&quot;formItemsTr&quot;&gt;
+		&lt;td id=&quot;formItemsTd&quot;&gt;&nbsp;&lt;/td&gt;
+		&lt;td&gt;&nbsp;&lt;/td&gt;
+	&lt;/tr&gt;
+&lt;/table&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlComboBox.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlComboBox.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlComboBox.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,40 @@
+input.dojoComboBoxInput {
+	/* font-size: 0.8em; */
+	border: 0px;
+	
+}
+
+.dojoComboBoxOptions {
+	font-family: Verdana, Helvetica, Garamond, sans-serif;
+	/* font-size: 0.7em; */
+	background-color: white;
+	border: 1px solid #afafaf;
+	position: absolute;
+	z-index: 1000; 
+	overflow: auto;
+	-moz-opacity: 0;
+	cursor: default;
+}
+
+table.dojoComboBox {
+	border: 1px solid #afafaf;
+}
+
+.dojoComboBoxItem {
+	padding-left: 2px;
+	padding-top: 2px;
+	margin: 0px;
+}
+
+.dojoComboBoxItemEven {
+	background-color: #f4f4f4;
+}
+
+.dojoComboBoxItemOdd {
+	background-color: white;
+}
+
+.dojoComboBoxItemHighlight {
+	background-color: #63709A;
+	color: white;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlComboBox.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlComboBox.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlComboBox.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,34 @@
+&lt;div style=&quot;position: relative; z-index: 100;&quot;&gt;
+	&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot; 
+		dojoAttachPoint=&quot;comboBoxValue&quot;&gt;
+	&lt;input type=&quot;hidden&quot; name=&quot;&quot; value=&quot;&quot; 
+		dojoAttachPoint=&quot;comboBoxSelectionValue&quot;&gt;
+	&lt;table class=&quot;dojoComboBox&quot;
+		cellpadding=&quot;0&quot;
+		cellmargin=&quot;0&quot;
+		border=&quot;0&quot;
+		dojoAttachPoint=&quot;cbTableNode&quot;&gt;
+		&lt;tr valign=&quot;top&quot;&gt;
+			&lt;td width=100%&gt;
+				&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; class=&quot;dojoComboBoxInput&quot;
+					dojoAttachEvent=&quot;keyDown: onKeyDown; keyUp: onKeyUp; keyPress: onKeyPress;&quot;
+					dojoAttachPoint=&quot;textInputNode&quot;
+					style=&quot;width: 100%;&quot;&gt;
+			&lt;/td&gt;
+			&lt;td&gt;
+				&lt;img border=&quot;0&quot; 
+					hspace=&quot;0&quot;
+					vspace=&quot;0&quot;
+					dojoAttachPoint=&quot;downArrowNode&quot;
+					dojoAttachEvent=&quot;onMouseUp: handleArrowClick;&quot;
+					src=&quot;${dojoRoot}src/widget/templates/images/combo_box_arrow.png&quot;&gt;
+			&lt;/td&gt;
+		&lt;/tr&gt;
+	&lt;/table&gt;
+	&lt;div dojoAttachPoint=&quot;optionsListWrapper&quot; style=&quot;position:relative;&quot; tabindex=&quot;-1&quot;&gt;
+		&lt;div class=&quot;dojoComboBoxOptions&quot; dojoAttachPoint=&quot;optionsListNode&quot;
+			dojoAttachEvent=&quot;onClick: selectOption;  onMouseOver: _onMouseOver; onMouseOut: _onMouseOut;&quot;
+			style=&quot;display:none;&quot; tabindex=&quot;-1&quot;&gt;
+		&lt;/div&gt;
+	&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlComboButtonTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,18 @@
+&lt;div class=&quot;dojoButton&quot; style=&quot;position:relative;top:0px;left:0px; text-align:none;&quot;&gt;
+
+	&lt;div dojoAttachPoint=&quot;leftPart&quot; class=&quot;dojoButtonLeftPart&quot; style=&quot;position:absolute;left:0px;top:0px;&quot;
+		dojoAttachEvent=&quot;onMouseOver:leftOver; onMouseOut:leftOut; onMouseUp:leftUp; onClick:leftClick;&quot;&gt;
+		&lt;div class=&quot;dojoButtonContents&quot; dojoAttachPoint=&quot;containerNode&quot; style=&quot;position:absolute;top:0px;right:0px;z-index:2;&quot;&gt;&lt;/div&gt;
+		&lt;img dojoAttachPoint=&quot;leftImage&quot; style=&quot;position:absolute;left:0px;top:0px;&quot;&gt;
+		&lt;img dojoAttachPoint=&quot;centerImage&quot; style=&quot;position:absolute;right:0px;top:0px;z-index:1;&quot;&gt;
+	&lt;/div&gt;
+
+	&lt;div dojoAttachPoint=&quot;rightPart&quot; class=&quot;dojoButtonRightPart&quot; style=&quot;position:absolute;top:0px;right:0px;&quot;
+		dojoAttachEvent=&quot;onMouseOver:rightOver; onMouseOut:rightOut; onMouseUp:rightUp; onClick:rightClick;&quot;&gt;
+		&lt;img dojoAttachPoint=&quot;arrowBackgroundImage&quot; style=&quot;position:absolute;top:0px;left:0px;z-index:1;&quot;&gt;
+		&lt;img src=&quot;${dojoRoot}src/widget/templates/images/whiteDownArrow.gif&quot;
+		  		style=&quot;z-index:2;position:absolute;left:3px;top:50%;&quot;&gt;
+		&lt;img dojoAttachPoint=&quot;rightImage&quot; style=&quot;position:absolute;top:0px;right:0px;&quot;&gt;
+	&lt;/div&gt;
+
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlContextMenuTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,3 @@
+&lt;ul class=&quot;dojoContextMenu&quot; 
+	dojoAttachPoint=&quot;containerNode&quot;&gt;
+&lt;/ul&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlDatePicker.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlDatePicker.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlDatePicker.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,143 @@
+.calendarContainer {
+/*	border:1px solid #566f8f;*/
+}
+
+.calendarBodyContainer {
+	width:160px;
+	background: #7591bc url(&quot;images/dpBg.gif&quot;) top left repeat-x;
+}
+
+.calendarBodyContainer thead tr td {
+	color:#293a4b;
+	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
+	text-align:center;
+	padding:0.25em;
+	background: url(&quot;images/dpHorizLine.gif&quot;) bottom left repeat-x;
+}
+
+.calendarBodyContainer tbody tr td {
+	color:#fff;
+	font:bold 0.7em Helvetica, Arial, Verdana, sans-serif;
+	text-align:center;
+	padding:0.4em;
+	background: url(&quot;images/dpVertLine.gif&quot;) top right repeat-y;
+	cursor:pointer;
+	cursor:hand;
+}
+
+
+.monthWrapper {
+	padding-bottom:2px;
+	background: url(&quot;images/dpHorizLine.gif&quot;) bottom left repeat-x;
+}
+
+.monthContainer {
+	width:100%;
+}
+
+.monthLabelContainer {
+	text-align:center;
+	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
+	background: url(&quot;images/dpMonthBg.png&quot;) repeat-x top left !important;
+	color:#293a4b;
+	padding:0.25em;
+}
+
+.monthCurve {
+	width:12px;
+}
+
+.monthCurveTL {
+	background: url(&quot;images/dpCurveTL.png&quot;) no-repeat top left !important;
+}
+
+.monthCurveTR {
+		background: url(&quot;images/dpCurveTR.png&quot;) no-repeat top left !important;
+}
+
+
+.yearWrapper {
+	background: url(&quot;images/dpHorizLineFoot.gif&quot;) top left repeat-x;
+	padding-top:2px;
+}
+
+.yearContainer {
+	width:100%;
+}
+
+.yearContainer td {
+	background:url(&quot;images/dpYearBg.png&quot;) top left repeat-x;
+}
+
+.yearContainer .yearLabel {
+	margin:0;
+	padding:0.45em 0 0.45em 0;
+	color:#fff;
+	font:bold 0.75em Helvetica, Arial, Verdana, sans-serif;
+	text-align:center;
+}
+
+.curveBL {
+	background: url(&quot;images/dpCurveBL.png&quot;) bottom left no-repeat !important;
+	width:9px !important;
+	padding:0;
+	margin:0;
+}
+
+.curveBR {
+	background: url(&quot;images/dpCurveBR.png&quot;) bottom left no-repeat !important;
+	width:9px !important;
+	padding:0;
+	margin:0;
+}
+
+
+.previousMonth {
+	background-color:#6782a8 !important;
+}
+
+.currentMonth {
+}
+
+.nextMonth {
+	background-color:#6782a8 !important;
+}
+
+.currentDate {
+	text-decoration:underline;
+	font-style:italic;
+}
+
+.selectedItem {
+	background-color:#fff !important;
+	color:#6782a8 !important;
+}
+
+.yearLabel .selectedYear {
+	padding:0.2em;
+	background-color:#9ec3fb !important;
+}
+
+.nextYear, .previousYear {
+	cursor:pointer;cursor:hand;
+	margin:0 0.55em;
+}
+
+.incrementControl {
+	cursor:pointer;cursor:hand;
+	width:1em;
+}
+
+.increase {
+	float:right;
+}
+
+.decrease {
+	float:left;
+}
+
+.lastColumn {
+	background-image:none !important;
+}
+
+

Added: trunk/root/static/magic/src/widget/templates/HtmlDatePicker.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlDatePicker.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlDatePicker.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,141 @@
+&lt;div class=&quot;datePickerContainer&quot; dojoAttachPoint=&quot;datePickerContainerNode&quot;&gt;
+	&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; class=&quot;calendarContainer&quot;&gt;
+		&lt;thead&gt;
+			&lt;tr&gt;
+				&lt;td class=&quot;monthWrapper&quot; valign=&quot;top&quot;&gt;
+					&lt;table class=&quot;monthContainer&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;
+						&lt;tr&gt;
+							&lt;td class=&quot;monthCurve monthCurveTL&quot; valign=&quot;top&quot;&gt;&lt;/td&gt;
+							&lt;td class=&quot;monthLabelContainer&quot; valign=&quot;top&quot;&gt;
+								&lt;span dojoAttachPoint=&quot;increaseWeekNode&quot; 
+									dojoAttachEvent=&quot;onClick: onIncrementWeek;&quot; 
+									class=&quot;incrementControl increase&quot;&gt;
+									&lt;img src=&quot;${dojoRoot}src/widget/templates/images/incrementMonth.png&quot; 
+									alt=&quot;&darr;&quot; style=&quot;width:7px;height:5px;&quot; /&gt;
+								&lt;/span&gt;
+								&lt;span 
+									dojoAttachPoint=&quot;increaseMonthNode&quot; 
+									dojoAttachEvent=&quot;onClick: onIncrementMonth;&quot; class=&quot;incrementControl increase&quot;&gt;
+									&lt;img src=&quot;${dojoRoot}src/widget/templates/images/incrementMonth.png&quot; 
+										alt=&quot;&darr;&quot;  dojoAttachPoint=&quot;incrementMonthImageNode&quot;&gt;
+								&lt;/span&gt;
+								&lt;span 
+									dojoAttachPoint=&quot;decreaseWeekNode&quot; 
+									dojoAttachEvent=&quot;onClick: onIncrementWeek;&quot; 
+									class=&quot;incrementControl decrease&quot;&gt;
+									&lt;img src=&quot;${dojoRoot}src/widget/templates/images/decrementMonth.png&quot; alt=&quot;&uarr;&quot; style=&quot;width:7px;height:5px;&quot; /&gt;
+								&lt;/span&gt;
+								&lt;span 
+									dojoAttachPoint=&quot;decreaseMonthNode&quot; 
+									dojoAttachEvent=&quot;onClick: onIncrementMonth;&quot; class=&quot;incrementControl decrease&quot;&gt;
+									&lt;img src=&quot;${dojoRoot}src/widget/templates/images/decrementMonth.png&quot; 
+										alt=&quot;&uarr;&quot; dojoAttachPoint=&quot;decrementMonthImageNode&quot;&gt;
+								&lt;/span&gt;
+								&lt;span dojoAttachPoint=&quot;monthLabelNode&quot; class=&quot;month&quot;&gt;July&lt;/span&gt;
+							&lt;/td&gt;
+							&lt;td class=&quot;monthCurve monthCurveTR&quot; valign=&quot;top&quot;&gt;&lt;/td&gt;
+						&lt;/tr&gt;
+					&lt;/table&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/thead&gt;
+		&lt;tbody&gt;
+			&lt;tr&gt;
+				&lt;td colspan=&quot;3&quot;&gt;
+					&lt;table class=&quot;calendarBodyContainer&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;
+						&lt;thead&gt;
+							&lt;tr&gt;
+								&lt;td&gt;S&lt;/td&gt;
+								&lt;td&gt;M&lt;/td&gt;
+								&lt;td&gt;T&lt;/td&gt;
+								&lt;td&gt;W&lt;/td&gt;
+								&lt;td&gt;T&lt;/td&gt;
+								&lt;td&gt;F&lt;/td&gt;
+								&lt;td&gt;S&lt;/td&gt;
+							&lt;/tr&gt;
+						&lt;/thead&gt;
+						&lt;tbody dojoAttachPoint=&quot;calendarDatesContainerNode&quot; 
+							dojoAttachEvent=&quot;onClick: onSetDate;&quot;&gt;
+							&lt;tr dojoAttachPoint=&quot;calendarRow0&quot;&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr dojoAttachPoint=&quot;calendarRow1&quot;&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr dojoAttachPoint=&quot;calendarRow2&quot;&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr dojoAttachPoint=&quot;calendarRow3&quot;&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr dojoAttachPoint=&quot;calendarRow4&quot;&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr dojoAttachPoint=&quot;calendarRow5&quot;&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+								&lt;td&gt;&lt;/td&gt;
+							&lt;/tr&gt;
+						&lt;/tbody&gt;
+					&lt;/table&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+		&lt;tfoot&gt;
+			&lt;tr&gt;
+				&lt;td colspan=&quot;3&quot; class=&quot;yearWrapper&quot;&gt;
+					&lt;table cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot; class=&quot;yearContainer&quot;&gt;
+						&lt;tr&gt;
+							&lt;td class=&quot;curveBL&quot; valign=&quot;top&quot;&gt;&lt;/td&gt;
+							&lt;td valign=&quot;top&quot;&gt;
+								&lt;h3 class=&quot;yearLabel&quot;&gt;
+									&lt;span dojoAttachPoint=&quot;previousYearLabelNode&quot;
+										dojoAttachEvent=&quot;onClick: onIncrementYear;&quot; class=&quot;previousYear&quot;&gt;&lt;/span&gt;
+									&lt;span class=&quot;selectedYear&quot; dojoAttachPoint=&quot;currentYearLabelNode&quot;&gt;&lt;/span&gt;
+									&lt;span dojoAttachPoint=&quot;nextYearLabelNode&quot; 
+										dojoAttachEvent=&quot;onClick: onIncrementYear;&quot; class=&quot;nextYear&quot;&gt;&lt;/span&gt;
+								&lt;/h3&gt;
+							&lt;/td&gt;
+							&lt;td class=&quot;curveBR&quot; valign=&quot;top&quot;&gt;&lt;/td&gt;
+						&lt;/tr&gt;
+					&lt;/table&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tfoot&gt;
+	&lt;/table&gt;
+	
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlDialog.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlDialog.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlDialog.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,13 @@
+&lt;div id=&quot;${this.widgetId}&quot; class=&quot;dojoDialog&quot; dojoAttachPoint=&quot;wrapper&quot;&gt;
+
+	&lt;span dojoAttachPoint=&quot;tabStart&quot; 
+		dojoOnFocus=&quot;trapTabs&quot; 
+		dojoOnBlur=&quot;clearTrap&quot; tabindex=&quot;0&quot;&gt;&lt;/span&gt;
+
+	&lt;div dojoAttachPoint=&quot;containerNode&quot; style=&quot; position: relative; z-index: 2;&quot;&gt;&lt;/div&gt;
+
+	&lt;span dojoAttachPoint=&quot;tabEnd&quot; 
+		dojoOnFocus=&quot;trapTabs&quot; 
+		dojoOnBlur=&quot;clearTrap&quot; tabindex=&quot;0&quot;&gt;&lt;/span&gt;
+
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlDocPane.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlDocPane.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlDocPane.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,19 @@
+.dojoDocSrc {
+	white-space: pre;
+	font-family: Courier, &quot;Courier New&quot;, monospace;
+	font-size: 0.8em;
+}
+.dojoDocReturn {
+	color: #369;
+}
+.dojoDocFunction {
+	color: #98543F;
+	font-weight: bold;
+}
+.dojoDocParamType {
+	font-style: italic;
+	color: #D17575;
+}
+.dojoDocParamName {
+	color: #D14040;
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlDocPane.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlDocPane.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlDocPane.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,23 @@
+&lt;div&gt;
+	&lt;div dojoAttachPoint=&quot;containerNode&quot;&gt;&lt;/div&gt;
+	&lt;div dojoAttachPoint=&quot;select&quot;&gt;
+		&lt;h1&gt;Detail: &lt;span dojoAttachPoint=&quot;fn&quot;&gt;dojo.select&lt;/span&gt;&lt;/h1&gt;
+		&lt;div dojoAttachPoint=&quot;description&quot;&gt;Description&lt;/div&gt;
+		&lt;div class=&quot;dojoDocParams&quot; dojoAttachPoint=&quot;parameters&quot;&gt;
+			&lt;h2&gt;Parameters&lt;/h2&gt;
+			&lt;div dojoAttachPoint=&quot;pRow&quot;&gt;&lt;span dojoAttachPoint=&quot;pOpt&quot;&gt;&lt;em&gt;optional&lt;/em&gt; &lt;/span&gt;&lt;span&gt;&lt;span dojoAttachPoint=&quot;pType&quot;&gt;type&lt;/span&gt; &lt;/span&gt;&lt;a href=&quot;#&quot; dojoAttachPoint=&quot;pLink&quot;&gt;variable&lt;/a&gt;&lt;span&gt; - &lt;span dojoAttachPoint=&quot;pDesc&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
+		&lt;/div&gt;
+		&lt;div class=&quot;dojoDocVars&quot; dojoAttachPoint=&quot;variables&quot;&gt;
+			&lt;h2&gt;Variables&lt;/h2&gt;
+			&lt;div dojoAttachPoint=&quot;vRow&quot;&gt;&lt;a href=&quot;#&quot; dojoAttachPoint=&quot;vLink&quot;&gt;variable&lt;/a&gt;&lt;span&gt; - &lt;span dojoAttachPoint=&quot;vDesc&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
+		&lt;/div&gt;
+		&lt;div&gt;
+			&lt;h2&gt;Source Code&lt;/h2&gt;
+			&lt;div class=&quot;dojoDocSrc&quot;&gt;&lt;span class=&quot;dojoDocReturn&quot; dojoAttachPoint=&quot;sType&quot;&gt;returnType&lt;/span&gt; &lt;span class=&quot;dojoDocFunction&quot; dojoAttachPoint=&quot;sName&quot;&gt;foo&lt;/span&gt;(&lt;span dojoAttachPoint=&quot;sParams&quot;&gt;&lt;span class=&quot;dojoDocParamType&quot; dojoAttachPoint=&quot;sPType&quot;&gt;type &lt;/span&gt;&lt;span class=&quot;dojoDocParamName&quot; dojoAttachPoint=&quot;sPName&quot;&gt;paramName&lt;/span&gt;&lt;/span&gt;){&lt;span dojoAttachPoint=&quot;source&quot;&gt;...&lt;/span&gt;}&lt;/div&gt;
+		&lt;/div&gt;
+	&lt;/div&gt;
+	&lt;div dojoAttachPoint=&quot;result&quot;&gt;
+		&lt;h1&gt;Search Results: &lt;span dojoAttachPoint=&quot;count&quot;&gt;0&lt;/span&gt; matches&lt;/h1&gt;
+		&lt;div dojoAttachPoint=&quot;row&quot;&gt;&lt;a href=&quot;#&quot; dojoAttachPoint=&quot;fnLink&quot;&gt;dojo.fnLink&lt;/a&gt;&lt;span&gt; - &lt;span dojoAttachPoint=&quot;summary&quot;&gt;summary&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
+	&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlDropDownButtonTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,9 @@
+&lt;button dojoAttachPoint=&quot;button&quot; class=&quot;dojoButton dojoButtonNoHover&quot; dojoAttachEvent=&quot;onMouseOver: ; onMouseOut: ; onClick: ;&quot;&gt;
+  &lt;table dojoAttachPoint=&quot;table&quot; style=&quot;margin:0 0 0 0;&quot;&gt;&lt;tr&gt;
+    &lt;td class=&quot;label&quot; dojoAttachPoint=&quot;labelCell&quot;&gt;&lt;/td&gt;
+    &lt;td class=&quot;border&quot; dojoAttachPoint=&quot;borderCell&quot;&gt;&lt;/td&gt;
+    &lt;td class=&quot;downArrow&quot; dojoAttachPoint=&quot;arrowCell&quot;&gt;
+      &lt;img dojoAttachPoint=&quot;arrow&quot;&gt;
+    &lt;/td&gt;
+  &lt;/tr&gt;&lt;/table&gt;
+&lt;/button&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,138 @@
+.StyleDropdownContainer {
+	position: absolute;
+	z-index: 1000;
+	overflow: auto;
+	cursor: default;
+	width: 250px;
+	height: 250px;
+	background-color: white;
+	border: 1px solid black;
+}
+
+.ColorDropdownContainer {
+	position: absolute;
+	z-index: 1000;
+	overflow: auto;
+	cursor: default;
+	width: 250px;
+	height: 150px;
+	background-color: white;
+	border: 1px solid black;
+}
+
+.EditorToolbarDomNode {
+	background-image: url(buttons/bg-fade.png);
+	background-repeat: repeat-x;
+	background-position: 0px -50px;
+}
+
+.EditorToolbarSmallBg {
+	background-image: url(images/toolbar-bg.gif);
+	background-repeat: repeat-x;
+	background-position: 0px 0px;
+}
+
+/*
+body {
+	background:url(images/blank.gif) fixed;
+}*/
+
+.IEFixedToolbar {
+	position:absolute;
+	/* top:0; */
+	top: expression(eval((document.documentElement||document.body).scrollTop));
+}
+
+div.bigIcon {
+	width: 40px;
+	height: 40px; 
+	/* background-color: white; */
+	/* border: 1px solid #a6a7a3; */
+	font-family: Verdana, Trebuchet, Tahoma, Arial;
+}
+
+.iconContainer {
+	font-family: Verdana, Trebuchet, Tahoma, Arial;
+	font-size: 13px;
+	float: left;
+	height: 18px;
+	display: block;
+	/* background-color: white; */
+	/* border: 1px solid white; */
+	/* border: 1px solid #a6a7a3; */
+	padding-right: 3px;
+	cursor: pointer;
+	border: 1px solid transparent;
+	_border: none;
+}
+
+span.icon {
+	display: block;
+	text-align: center;
+	min-width: 18px;
+	width: 18px;
+	height: 18px;
+	/* background-color: #a6a7a3; */
+	background-repeat: no-repeat;
+	background-image: url(buttons/aggregate.gif);
+}
+
+
+span.icon[class~=icon] {
+}
+
+.headingContainer {
+	width: 150px;
+	height: 30px;
+	margin: 0px;
+	/* padding-left: 5px; */
+	overflow: hidden;
+	line-height: 25px;
+	border-bottom: 1px solid black;
+	border-top: 1px solid white;
+}
+
+.EditorToolbarDomNode select {
+	font-size: 14px;
+}
+
+.sep { width: 5px; min-width: 5px; max-width: 5px; background-position: 0px 0px}
+.backcolor { background-position: -18px 0px}
+.bold { background-position: -36px 0px}
+.cancel { background-position: -54px 0px}
+.copy { background-position: -72px 0px}
+.createlink { background-position: -90px 0px}
+.cut { background-position: -108px 0px}
+.delete { background-position: -126px 0px}
+.forecolor { background-position: -144px 0px}
+.hilitecolor { background-position: -162px 0px}
+.indent { background-position: -180px 0px}
+.inserthorizontalrule { background-position: -198px 0px}
+.insertimage { background-position: -216px 0px}
+.insertorderedlist { background-position: -234px 0px}
+.inserttable { background-position: -252px 0px}
+.insertunorderedlist { background-position: -270px 0px}
+.italic { background-position: -288px 0px}
+.justifycenter { background-position: -306px 0px}
+.justifyfull { background-position: -324px 0px}
+.justifyleft { background-position: -342px 0px}
+.justifyright { background-position: -360px 0px}
+.left_to_right { background-position: -378px 0px}
+.list_bullet_indent { background-position: -396px 0px}
+.list_bullet_outdent { background-position: -414px 0px}
+.list_num_indent { background-position: -432px 0px}
+.list_num_outdent { background-position: -450px 0px}
+.outdent { background-position: -468px 0px}
+.paste { background-position: -486px 0px}
+.redo { background-position: -504px 0px}
+.removeformat { background-position: -522px 0px}
+.right_to_left { background-position: -540px 0px}
+.save { background-position: -558px 0px}
+.space { background-position: -576px 0px}
+.strikethrough { background-position: -594px 0px}
+.subscript { background-position: -612px 0px}
+.superscript { background-position: -630px 0px}
+.underline { background-position: -648px 0px}
+.undo { background-position: -666px 0px}
+.wikiword { background-position: -684px 0px}
+

Added: trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlEditorToolbar.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,152 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot; class=&quot;EditorToolbarDomNode&quot; unselectable=&quot;on&quot;&gt;
+	&lt;table cellpadding=&quot;3&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
+		&lt;!--
+			our toolbar should look something like:
+
+			+=======+=======+=======+=============================================+
+			| w   w | style | copy  | bo | it | un | le | ce | ri |
+			| w w w | style |=======|==============|==============|
+			|  w w  | style | paste |  undo | redo | change style |
+			+=======+=======+=======+=============================================+
+		--&gt;
+		&lt;tbody&gt;
+			&lt;tr valign=&quot;top&quot;&gt;
+				&lt;td rowspan=&quot;2&quot;&gt;
+					&lt;div class=&quot;bigIcon&quot; dojoAttachPoint=&quot;wikiWordButton&quot;
+						dojoOnClick=&quot;wikiWordClick; buttonClick;&quot;&gt;
+						&lt;span style=&quot;font-size: 30px; margin-left: 5px;&quot;&gt;
+							W
+						&lt;/span&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+				&lt;td rowspan=&quot;2&quot;&gt;
+					&lt;div class=&quot;bigIcon&quot; dojoAttachPoint=&quot;styleDropdownButton&quot;
+						dojoOnClick=&quot;styleDropdownClick; buttonClick;&quot;&gt;
+						&lt;span unselectable=&quot;on&quot;
+							style=&quot;font-size: 30px; margin-left: 5px;&quot;&gt;
+							S
+						&lt;/span&gt;
+					&lt;/div&gt;
+					&lt;div class=&quot;StyleDropdownContainer&quot; style=&quot;display: none;&quot;
+						dojoAttachPoint=&quot;styleDropdownContainer&quot;&gt;
+						&lt;table cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;
+							height=&quot;100%&quot; width=&quot;100%&quot;&gt;
+							&lt;tr valign=&quot;top&quot;&gt;
+								&lt;td rowspan=&quot;2&quot;&gt;
+									&lt;div style=&quot;height: 245px; overflow: auto;&quot;&gt;
+										&lt;div class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;normalTextClick&quot;&gt;normal&lt;/div&gt;
+										&lt;h1 class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;h1TextClick&quot;&gt;Heading 1&lt;/h1&gt;
+										&lt;h2 class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;h2TextClick&quot;&gt;Heading 2&lt;/h2&gt;
+										&lt;h3 class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;h3TextClick&quot;&gt;Heading 3&lt;/h3&gt;
+										&lt;h4 class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;h4TextClick&quot;&gt;Heading 4&lt;/h4&gt;
+										&lt;div class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;blahTextClick&quot;&gt;blah&lt;/div&gt;
+										&lt;div class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;blahTextClick&quot;&gt;blah&lt;/div&gt;
+										&lt;div class=&quot;headingContainer&quot;
+											unselectable=&quot;on&quot;
+											dojoOnClick=&quot;blahTextClick&quot;&gt;blah&lt;/div&gt;
+										&lt;div class=&quot;headingContainer&quot;&gt;blah&lt;/div&gt;
+										&lt;div class=&quot;headingContainer&quot;&gt;blah&lt;/div&gt;
+										&lt;div class=&quot;headingContainer&quot;&gt;blah&lt;/div&gt;
+										&lt;div class=&quot;headingContainer&quot;&gt;blah&lt;/div&gt;
+									&lt;/div&gt;
+								&lt;/td&gt;
+								&lt;!--
+								&lt;td&gt;
+									&lt;span class=&quot;iconContainer&quot; dojoOnClick=&quot;buttonClick;&quot;&gt;
+										&lt;span class=&quot;icon justifyleft&quot; 
+											style=&quot;float: left;&quot;&gt;&nbsp;&lt;/span&gt;
+									&lt;/span&gt;
+									&lt;span class=&quot;iconContainer&quot; dojoOnClick=&quot;buttonClick;&quot;&gt;
+										&lt;span class=&quot;icon justifycenter&quot; 
+											style=&quot;float: left;&quot;&gt;&nbsp;&lt;/span&gt;
+									&lt;/span&gt;
+									&lt;span class=&quot;iconContainer&quot; dojoOnClick=&quot;buttonClick;&quot;&gt;
+										&lt;span class=&quot;icon justifyright&quot; 
+											style=&quot;float: left;&quot;&gt;&nbsp;&lt;/span&gt;
+									&lt;/span&gt;
+									&lt;span class=&quot;iconContainer&quot; dojoOnClick=&quot;buttonClick;&quot;&gt;
+										&lt;span class=&quot;icon justifyfull&quot; 
+											style=&quot;float: left;&quot;&gt;&nbsp;&lt;/span&gt;
+									&lt;/span&gt;
+								&lt;/td&gt;
+								--&gt;
+							&lt;/tr&gt;
+							&lt;tr valign=&quot;top&quot;&gt;
+								&lt;td&gt;
+									thud
+								&lt;/td&gt;
+							&lt;/tr&gt;
+						&lt;/table&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- copy --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;copyButton&quot;
+						unselectable=&quot;on&quot;
+						dojoOnClick=&quot;copyClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon copy&quot; 
+							unselectable=&quot;on&quot;
+							style=&quot;float: left;&quot;&gt;&nbsp;&lt;/span&gt; copy
+					&lt;/span&gt;
+					&lt;!-- &quot;droppable&quot; options --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;boldButton&quot;
+						unselectable=&quot;on&quot;
+						dojoOnClick=&quot;boldClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon bold&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;italicButton&quot;
+						dojoOnClick=&quot;italicClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon italic&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;underlineButton&quot;
+						dojoOnClick=&quot;underlineClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon underline&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;leftButton&quot;
+						dojoOnClick=&quot;leftClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon justifyleft&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;fullButton&quot;
+						dojoOnClick=&quot;fullClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon justifyfull&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;rightButton&quot;
+						dojoOnClick=&quot;rightClick; buttonClick;&quot;&gt;
+						&lt;span class=&quot;icon justifyright&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr&gt;
+				&lt;td&gt;
+					&lt;!-- paste --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;pasteButton&quot;
+						dojoOnClick=&quot;pasteClick; buttonClick;&quot; unselectable=&quot;on&quot;&gt;
+						&lt;span class=&quot;icon paste&quot; style=&quot;float: left;&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt; paste
+					&lt;/span&gt;
+					&lt;!-- &quot;droppable&quot; options --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;undoButton&quot;
+						dojoOnClick=&quot;undoClick; buttonClick;&quot; unselectable=&quot;on&quot;&gt;
+						&lt;span class=&quot;icon undo&quot; style=&quot;float: left;&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt; undo
+					&lt;/span&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;redoButton&quot;
+						dojoOnClick=&quot;redoClick; buttonClick;&quot; unselectable=&quot;on&quot;&gt;
+						&lt;span class=&quot;icon redo&quot; style=&quot;float: left;&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt; redo
+					&lt;/span&gt;
+				&lt;/td&gt;	
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+	&lt;/table&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlEditorToolbarOneline.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,266 @@
+&lt;div class=&quot;EditorToolbarDomNode EditorToolbarSmallBg&quot; 
+	unselectable=&quot;on&quot; dojoOnMouseDown=&quot;preventSelect&quot;&gt;
+	&lt;table cellpadding=&quot;1&quot; cellspacing=&quot;0&quot; border=&quot;0&quot;&gt;
+		&lt;!--
+			toobar options, in order:
+
+				* wikiword
+				* paste
+				* copy
+				* undo
+				* redo
+				* link
+				* insert image
+				* insert &lt;hr&gt;
+				* font-select
+				* bold
+				* italic
+				* underline
+				* strikethrough
+				* numlist
+				* dotlist
+				* indent
+				* outdent
+				* text color
+				* bg color
+
+		--&gt;
+		&lt;tbody&gt;
+			&lt;tr valign=&quot;top&quot; align=&quot;left&quot; dojoAttachPoint=&quot;oneLineTr&quot;&gt;
+				&lt;td&gt;
+					&lt;!-- htmltoggle --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;htmltoggleButton&quot;
+						dojoOnClick=&quot;htmltoggleClick; buttonClick;&quot; style=&quot;display: none;&quot;&gt;
+						&lt;span title=&quot;Toggle Rich Text and HTML Markup Editing Modes&quot; class=&quot;icon&quot; 
+						style=&quot;background-image: none; width: 30px;&quot; 
+						unselectable=&quot;on&quot;&gt;&lt;h&gt;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- wikiword --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;wikiwordButton&quot;
+						dojoOnClick=&quot;wikiwordClick; buttonClick;&quot; style=&quot;display: none;&quot;&gt;
+						&lt;span title=&quot;Toggle Wiki Word&quot; class=&quot;icon wikiword&quot; 
+						unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- paste --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;copyButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;copyClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Copy (Ctrl-C)&quot; class=&quot;icon copy&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- copy --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;pasteButton&quot;
+						dojoOnClick=&quot;pasteClick; buttonClick;&quot; unselectable=&quot;on&quot;&gt;
+						&lt;span title=&quot;Paste (Ctrl-V)&quot; class=&quot;icon paste&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- undo --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;undoButton&quot;
+						dojoOnClick=&quot;undoClick; buttonClick;&quot; unselectable=&quot;on&quot;&gt;
+						&lt;!-- FIXME: should we have the text &quot;undo&quot; here? --&gt;
+						&lt;span title=&quot;Undo (Ctrl-Z)&quot; class=&quot;icon undo&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- redo --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;redoButton&quot;
+						dojoOnClick=&quot;redoClick; buttonClick;&quot; unselectable=&quot;on&quot;&gt;
+						&lt;span title=&quot;Redo (Ctrl-R)&quot; class=&quot;icon redo&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td isSpacer=&quot;true&quot;&gt;
+					&lt;!-- spacer --&gt;
+					&lt;span class=&quot;iconContainer&quot;&gt;
+						&lt;span class=&quot;icon sep&quot; unselectable=&quot;on&quot; 
+							style=&quot;width: 5px; min-width: 5px;&quot;&gt;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- link --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;linkButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;linkClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Create Link&quot; class=&quot;icon createlink&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- insertimage --&gt;
+					&lt;span class=&quot;iconContainer&quot; 
+						style=&quot;display: none;&quot;
+						dojoAttachPoint=&quot;insertimageButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;insertimageClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Insert Image&quot; class=&quot;icon insertimage&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- inserthorizontalrule --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;inserthorizontalruleButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;inserthorizontalruleClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Insert Horizontal Rule&quot; class=&quot;icon inserthorizontalrule &quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- bold --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;boldButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;boldClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Toggle Bold (Ctrl-B)&quot; class=&quot;icon bold&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- italic --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;italicButton&quot;
+						dojoOnClick=&quot;italicClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Toggle Italic (Ctrl-I)&quot; class=&quot;icon italic&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- underline --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;underlineButton&quot;
+						dojoOnClick=&quot;underlineClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Toggle Underline (Ctrl-U)&quot; class=&quot;icon underline&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- strikethrough --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;strikethroughButton&quot;
+						dojoOnClick=&quot;strikethroughClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Toggle Strike-Through&quot; 
+							class=&quot;icon strikethrough&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td isSpacer=&quot;true&quot;&gt;
+					&lt;!-- spacer --&gt;
+					&lt;span class=&quot;iconContainer&quot;&gt;
+						&lt;span class=&quot;icon sep&quot; unselectable=&quot;on&quot; 
+							style=&quot;width: 5px; min-width: 5px;&quot;&gt;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- insertunorderedlist --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;insertunorderedlistButton&quot;
+						unselectable=&quot;on&quot; 
+						dojoOnClick=&quot;insertunorderedlistClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Insert Bullet List&quot; 
+							class=&quot;icon insertunorderedlist&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- insertorderedlist --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;insertorderedlistButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;insertorderedlistClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Insert Numbered List&quot; 
+							class=&quot;icon insertorderedlist&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td isSpacer=&quot;true&quot;&gt;
+					&lt;!-- spacer --&gt;
+					&lt;span class=&quot;iconContainer&quot;&gt;
+						&lt;span class=&quot;icon sep&quot; unselectable=&quot;on&quot; 
+							style=&quot;width: 5px; min-width: 5px;&quot;&gt;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- indent --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;indentButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;indentClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Indent Selection&quot; class=&quot;icon indent&quot; 
+							unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- outdent --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;outdentButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;outdentClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Outdent Selection&quot; class=&quot;icon outdent&quot; 
+							unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td isSpacer=&quot;true&quot;&gt;
+					&lt;!-- spacer --&gt;
+					&lt;span class=&quot;iconContainer&quot;&gt;
+						&lt;span class=&quot;icon sep&quot; unselectable=&quot;on&quot; 
+							style=&quot;width: 5px; min-width: 5px;&quot;&gt;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- forecolor --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;forecolorButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;forecolorClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Change Text Color&quot; class=&quot;icon forecolor&quot; 
+							unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;div class=&quot;ColorDropdownContainer&quot; 
+						style=&quot;display: none; margin-top: 22px;&quot;
+						dojoAttachPoint=&quot;forecolorDropDown&quot;&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- hilitecolor --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;hilitecolorButton&quot;
+						unselectable=&quot;on&quot; dojoOnClick=&quot;hilitecolorClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Change Background Color&quot; class=&quot;icon hilitecolor&quot; 
+							unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+					&lt;div class=&quot;ColorDropdownContainer&quot; 
+						style=&quot;display: none; margin-top: 22px;&quot;
+						dojoAttachPoint=&quot;hilitecolorDropDown&quot;&gt;
+					&lt;/div&gt;
+				&lt;/td&gt;
+				&lt;td isSpacer=&quot;true&quot;&gt;
+					&lt;!-- spacer --&gt;
+					&lt;span class=&quot;iconContainer&quot;&gt;
+						&lt;span class=&quot;icon sep&quot; unselectable=&quot;on&quot; 
+							style=&quot;width: 5px; min-width: 5px;&quot;&gt;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- justify left --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;justifyleftButton&quot;
+						dojoOnClick=&quot;justifyleftClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Justify Left&quot; class=&quot;icon justifyleft&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- justify center --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;justifycenterButton&quot;
+						dojoOnClick=&quot;justifycenterClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Center&quot; class=&quot;icon justifycenter&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- justify right --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;justifyrightButton&quot;
+						dojoOnClick=&quot;justifyrightClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Justify Right&quot; class=&quot;icon justifyright&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;
+				&lt;td&gt;
+					&lt;!-- justify full --&gt;
+					&lt;span class=&quot;iconContainer&quot; dojoAttachPoint=&quot;justifyfullButton&quot;
+						dojoOnClick=&quot;justifyfullClick; buttonClick;&quot;&gt;
+						&lt;span title=&quot;Justify Both&quot; class=&quot;icon justifyfull&quot; unselectable=&quot;on&quot;&gt;&nbsp;&lt;/span&gt;
+					&lt;/span&gt;
+				&lt;/td&gt;	
+				&lt;td&gt;
+					&lt;!-- font select --&gt;
+					&lt;select dojoOnChange=&quot;formatSelectClick; buttonClick;&quot;
+						dojoAttachPoint=&quot;formatSelectBox&quot; unselectable=&quot;on&quot;&gt;
+						&lt;!-- FIXME: using &quot;p&quot; here inserts a paragraph in most cases! --&gt;
+						&lt;option value=&quot;&quot;&gt;-- format --&lt;/option&gt;
+						&lt;option value=&quot;p&quot;&gt;Normal&lt;/option&gt;
+						&lt;option value=&quot;pre&quot;&gt;Fixed Font&lt;/option&gt;
+						&lt;option value=&quot;h1&quot;&gt;Main Heading&lt;/option&gt;
+						&lt;option value=&quot;h2&quot;&gt;Section Heading&lt;/option&gt;
+						&lt;option value=&quot;h3&quot;&gt;Sub-Heading&lt;/option&gt;
+						&lt;!-- &lt;option value=&quot;blockquote&quot;&gt;Block Quote&lt;/option&gt; --&gt;
+					&lt;/select&gt;
+				&lt;/td&gt;
+				&lt;td width=&quot;*&quot;&gt;&nbsp;&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+	&lt;/table&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlFisheyeList.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlFisheyeList.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlFisheyeList.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,27 @@
+.dojoHtmlFisheyeListItemLabel {
+	font-family: Arial, Helvetica, sans-serif;
+	background-color: #eee;
+	border: 2px solid #666;
+	padding: 2px;
+	text-align: center;
+	position: absolute;
+	display: none;
+}
+
+.dojoHtmlFisheyeListItemLabel.selected {
+	display: block;
+}
+
+.dojoHtmlFisheyeListItemImage {
+	border: 0px;
+	position: absolute;
+}
+
+.dojoHtmlFisheyeListItem {
+	position: absolute;
+	z-index: 2;
+}
+
+.dojoHtmlFisheyeListBar {
+	position: relative;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,118 @@
+
+/********** Outer Window ***************/
+
+.dojoFloatingPane {
+	/* essential css */
+	position: absolute;
+	overflow: visible;		/* so drop shadow is displayed */
+	z-index: 10;
+
+	/* styling css */
+	border: 1px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	background-color: ThreeDFace;
+}
+
+
+/********** Title Bar ****************/
+
+.dojoFloatingPaneTitleBar {
+	vertical-align: top;
+	margin: 2px 2px 2px 2px;
+	z-index: 10;
+	background-color: #7596c6;
+	cursor: default;
+	overflow: hidden;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	vertical-align: middle;
+}
+
+.dojoFloatingPaneTitleText {
+	float: left;
+	padding: 2px 4px 2px 2px;
+	white-space: nowrap;
+	color: CaptionText;
+	font: small-caption;
+}
+
+.dojoTitleBarIcon {
+	float: left;
+	height: 22px;
+	width: 22px;
+	vertical-align: middle;
+	margin-right: 5px;
+	margin-left: 5px;
+}
+
+.dojoFloatingPaneActions{
+	float: right;
+	position: absolute;
+	right: 2px;
+	top: 2px;
+	vertical-align: middle;
+}
+
+
+.dojoFloatingPaneActionItem {
+	vertical-align: middle;
+	margin-right: 1px;
+	height: 22px;
+	width: 22px;
+}
+
+
+.dojoFloatingPaneTitleBarIcon {
+	/* essential css */
+	float: left;
+
+	/* styling css */
+	margin-left: 2px;
+	margin-right: 4px;
+	height: 22px;
+}
+
+/* minimize/maximize icons are specified by CSS only */
+.dojoFloatingPaneMinimizeIcon,
+.dojoFloatingPaneMaximizeIcon,
+.dojoFloatingPaneRestoreIcon,
+.dojoFloatingPaneCloseIcon {
+	vertical-align: middle;
+	height: 22px;
+	width: 22px;
+	float: right;
+}
+.dojoFloatingPaneMinimizeIcon {
+	background-image: url(images/floatingPaneMinimize.gif);
+}
+.dojoFloatingPaneMaximizeIcon {
+	background-image: url(images/floatingPaneMaximize.gif);
+}
+.dojoFloatingPaneRestoreIcon {
+	background-image: url(images/floatingPaneRestore.gif);
+}
+.dojoFloatingPaneCloseIcon {
+	background-image: url(images/floatingPaneClose.gif);
+}
+
+/* bar at bottom of window that holds resize handle */
+.dojoFloatingPaneResizebar {
+	z-index: 10;
+	height: 13px;
+	background-color: ThreeDFace;
+}
+
+/************* Client Area ***************/
+
+.dojoFloatingPaneClient {
+	position: relative;
+	z-index: 10;
+	border: 1px solid;
+	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
+	margin: 2px;
+	background-color: ThreeDFace;
+	padding: 8px;
+	font-family: Verdana, Helvetica, Garamond, sans-serif;
+	font-size: 12px;
+	overflow: auto;
+}
+

Added: trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlFloatingPane.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,18 @@
+&lt;div id=&quot;${this.widgetId}&quot; class=&quot;dojoFloatingPane&quot;&gt;
+	&lt;div dojoAttachPoint=&quot;titleBar&quot; class=&quot;dojoFloatingPaneTitleBar&quot;  dojoAttachEvent=&quot;onMouseDown&quot; style=&quot;display:none&quot;&gt;
+	  	&lt;img dojoAttachPoint=&quot;titleBarIcon&quot;  class=&quot;dojoFloatingPaneTitleBarIcon&quot;&gt;
+		&lt;div dojoAttachPoint=&quot;closeAction&quot; dojoAttachEvent=&quot;onClick:closeWindow&quot;
+   	  		class=&quot;dojoFloatingPaneCloseIcon&quot;&gt;&lt;/div&gt;
+		&lt;div dojoAttachPoint=&quot;restoreAction&quot; dojoAttachEvent=&quot;onClick:restoreWindow&quot;
+   	  		class=&quot;dojoFloatingPaneRestoreIcon&quot;&gt;&lt;/div&gt;
+		&lt;div dojoAttachPoint=&quot;maximizeAction&quot; dojoAttachEvent=&quot;onClick:maximizeWindow&quot;
+   	  		class=&quot;dojoFloatingPaneMaximizeIcon&quot;&gt;&lt;/div&gt;
+		&lt;div dojoAttachPoint=&quot;minimizeAction&quot; dojoAttachEvent=&quot;onClick:minimizeWindow&quot;
+   	  		class=&quot;dojoFloatingPaneMinimizeIcon&quot;&gt;&lt;/div&gt;
+	  	&lt;div dojoAttachPoint=&quot;titleBarText&quot; class=&quot;dojoFloatingPaneTitleText&quot;&gt;${this.title}&lt;/div&gt;
+	&lt;/div&gt;
+
+	&lt;div id=&quot;${this.widgetId}_container&quot; dojoAttachPoint=&quot;containerNode&quot; class=&quot;dojoFloatingPaneClient&quot;&gt;&lt;/div&gt;
+
+	&lt;div dojoAttachPoint=&quot;resizeBar&quot; class=&quot;dojoFloatingPaneResizebar&quot; style=&quot;display:none&quot;&gt;&lt;/div&gt;
+&lt;/div&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,24 @@
+.editLabel {
+	font-size : small;
+	padding : 0 5px;
+	display : none;
+}
+
+.editableRegion {
+	background-color : #ffc !important;
+	cursor : pointer;
+	_cursor : hand;
+}
+
+.editableRegion .editLabel {
+	display : inline;
+}
+
+.editableTextareaRegion .editLabel {
+	display : block;
+}
+
+.inlineEditBox {
+	/*background-color : #ffc;*/
+	display : inline;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlInlineEditBox.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,6 @@
+&lt;form class=&quot;inlineEditBox&quot; style=&quot;display: none&quot; dojoAttachPoint=&quot;form&quot; dojoAttachEvent=&quot;onSubmit:saveEdit; onReset:cancelEdit; onKeyUp: checkForValueChange;&quot;&gt;
+	&lt;input type=&quot;text&quot; dojoAttachPoint=&quot;text&quot; style=&quot;display: none;&quot; /&gt;
+	&lt;textarea dojoAttachPoint=&quot;textarea&quot; style=&quot;display: none;&quot;&gt;&lt;/textarea&gt;
+	&lt;input type=&quot;submit&quot; value=&quot;Save&quot; dojoAttachPoint=&quot;submitButton&quot; /&gt;
+	&lt;input type=&quot;reset&quot; value=&quot;Cancel&quot; dojoAttachPoint=&quot;cancelButton&quot; /&gt;
+&lt;/form&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlMenu2.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlMenu2.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlMenu2.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,202 @@
+
+.dojoPopupMenu2 {
+	position: absolute;
+	border: 1px solid;
+	border-color: ThreeDLightShadow ThreeDDarkShadow ThreeDDarkShadow ThreeDLightShadow;
+}
+
+.dojoPopupMenu2Client {
+	border: 1px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	background-color: ThreeDFace;
+	padding: 1px;
+}
+
+.dojoMenuItem2 {
+	position: relative;
+	white-space: nowrap;
+	font: menu;
+	color: WindowText;
+	margin: 0;
+}
+
+.dojoMenuItem2 span {
+	margin: 0;
+}
+
+.dojoMenuItem2Hover {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoMenuItem2Icon {
+	position: absolute;
+	background-position: center center;
+	background-repeat: no-repeat;
+	z-index: 1;
+}
+
+.dojoMenuItem2Label {
+	position: absolute;
+	vertical-align: middle;
+	z-index: 1;
+}
+
+.dojoMenuItem2Label span {
+	position: relative;
+	vertical-align: middle;
+	z-index: 2;
+}
+
+.dojoMenuItem2Label span span {
+	position: absolute;
+	color: ThreeDHighlight;
+	display: none;
+	left: 1px;
+	top: 1px;
+	z-index: -2;
+}
+
+.dojoMenuItem2Accel {
+	position: absolute;
+	vertical-align: middle;
+	z-index: 1;
+}
+
+.dojoMenuItem2Accel span {
+	position: relative;
+	vertical-align: middle;
+	z-index: 2;
+}
+
+.dojoMenuItem2Accel span span {
+	position: absolute;
+	color: ThreeDHighlight;
+	display: none;
+	left: 1px;
+	top: 1px;
+	z-index: -2;
+}
+
+.dojoMenuItem2Disabled .dojoMenuItem2Label span,
+.dojoMenuItem2Disabled .dojoMenuItem2Accel span {
+	color: ThreeDShadow;
+}
+
+.dojoMenuItem2Disabled .dojoMenuItem2Label span span,
+.dojoMenuItem2Disabled .dojoMenuItem2Accel span span {
+	color: ThreeDHighlight;
+	display: block;
+}
+
+.dojoMenuItem2Hover .dojoMenuItem2Label span span,
+.dojoMenuItem2Hover .dojoMenuItem2Accel span span {
+	display: none;
+}
+
+.dojoMenuItem2Submenu {
+	position: absolute;
+	background-position: center center;
+	background-repeat: no-repeat;
+}
+
+.dojoMenuItem2Target {
+	position: absolute;
+	z-index: 10;
+	font-size: 1px;
+	background-image: url('images/transparent.gif');
+}
+
+.dojoMenuSeparator2 {
+	font-size: 1px;
+	margin: 0;
+}
+
+.dojoMenuSeparator2Top {
+	height: 50%;
+	border-bottom: 1px solid ThreeDShadow;
+	margin: 0px 2px;
+	font-size: 1px;
+}
+
+.dojoMenuSeparator2Bottom {
+	height: 50%;
+	border-top: 1px solid ThreeDHighlight;
+	margin: 0px 2px;
+	font-size: 1px;
+}
+
+
+
+.dojoMenuBar2 {
+	/*position: relative;*/
+	background-color: ThreeDFace;
+	border-bottom: 1px solid ThreeDHighlight;
+}
+
+.dojoMenuBar2Client {
+	padding: 1px;
+	border-top: 1px solid ThreeDHighlight;
+	border-bottom: 1px solid ThreeDShadow;
+}
+
+.dojoMenuBarItem2 {
+	position: absolute;
+	white-space: nowrap;
+	font: menu;
+	color: WindowText;
+	margin: 0;
+}
+
+.dojoMenuBarItem2 span {
+	margin: 0;
+}
+
+.dojoMenuBarItem2Target {
+	position: absolute;
+	z-index: 10;
+	font-size: 1px;
+	background-image: url('images/transparent.gif');
+}
+
+.dojoMenuBarItem2Label {
+	position: absolute;
+	vertical-align: middle;
+	z-index: 1;
+	padding: 3px 8px;
+}
+
+.dojoMenuBarItem2Label span {
+	position: relative;
+	z-index: 2;
+}
+
+.dojoMenuBarItem2Label span span {
+	position: absolute;
+	color: ThreeDHighlight;
+	display: none;
+	left: 1px;
+	top: 1px;
+	z-index: -2;
+}
+
+.dojoMenuBarItem2Hover {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Label span,
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Accel span {
+	color: ThreeDShadow;
+}
+
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Label span span,
+.dojoMenuBarItem2Disabled .dojoMenuBarItem2Accel span span {
+	color: ThreeDHighlight;
+	display: block;
+}
+
+.dojoMenuBarItem2Hover .dojoMenuBarItem2Label span span,
+.dojoMenuBarItem2Hover .dojoMenuBarItem2Accel span span {
+	display: none;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlMenuItemTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,2 @@
+&lt;div dojoAttachPoint=&quot;labelNode&quot; dojoAttachEvent=&quot;onClick&quot;&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,91 @@
+.datePickerContainer {
+	margin:0.5em 2em 0.5em 0;
+	/*width:10em;*/
+	float:left;
+}
+
+.previousMonth {
+	background-color:#bbbbbb;
+}
+
+.currentMonth {
+	background-color:#8f8f8f;
+}
+
+.nextMonth {
+	background-color:#eeeeee;
+}
+
+.currentDate {
+	text-decoration:underline;
+	font-style:italic;
+}
+
+.selectedItem {
+	background-color:#3a3a3a;
+	color:#ffffff;
+}
+
+.calendarContainer {
+	border-collapse:collapse;
+	border-spacing:0;
+	border-bottom:1px solid #e6e6e6;
+	overflow: hidden;
+	text-align: right;
+}
+
+.calendarContainer thead{
+	border-bottom:1px solid #e6e6e6;
+}
+
+.calendarContainer tbody * td {
+        height: 100px;
+        border: 1px solid gray;
+}
+
+.calendarContainer td {
+        width: 100px;
+        padding: 2px;
+	vertical-align: top;
+}
+
+.monthLabel {
+	font-size:0.9em;
+	font-weight:400;
+	margin:0;
+	text-align:center;
+}
+
+.monthLabel .month {
+	padding:0 0.4em 0 0.4em;
+}
+
+.yearLabel {
+	font-size:0.9em;
+	font-weight:400;
+	margin:0.25em 0 0 0;
+	text-align:right;
+	color:#a3a3a3;
+}
+
+.yearLabel .selectedYear {
+	color:#000;
+	padding:0 0.2em;
+}
+
+.nextYear, .previousYear {
+	cursor:pointer;cursor:hand;
+}
+
+.incrementControl {
+	cursor:pointer;cursor:hand;
+	width:1em;
+}
+
+.dojoMonthlyCalendarEvent {
+	font-size:0.7em;
+	overflow: hidden;
+	font-color: grey;
+	white-space: nowrap;
+	text-align: left;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlMonthlyCalendar.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,110 @@
+&lt;div class=&quot;datePickerContainer&quot; dojoAttachPoint=&quot;datePickerContainerNode&quot;&gt;
+	&lt;h3 class=&quot;monthLabel&quot;&gt;
+	&lt;!--
+	&lt;span 
+		dojoAttachPoint=&quot;decreaseWeekNode&quot; 
+		dojoAttachEvent=&quot;onClick: onIncrementWeek;&quot; 
+		class=&quot;incrementControl&quot;&gt;
+		&lt;img src=&quot;${dojoRoot}src/widget/templates/decrementWeek.gif&quot; alt=&quot;&uarr;&quot; /&gt;
+	&lt;/span&gt;
+	--&gt;
+	&lt;span 
+		dojoAttachPoint=&quot;decreaseMonthNode&quot; 
+		dojoAttachEvent=&quot;onClick: onIncrementMonth;&quot; class=&quot;incrementControl&quot;&gt;
+		&lt;img src=&quot;${dojoRoot}src/widget/templates/decrementMonth.gif&quot; 
+			alt=&quot;&uarr;&quot; dojoAttachPoint=&quot;decrementMonthImageNode&quot;&gt;
+	&lt;/span&gt;
+	&lt;span dojoAttachPoint=&quot;monthLabelNode&quot; class=&quot;month&quot;&gt;July&lt;/span&gt;
+	&lt;span 
+		dojoAttachPoint=&quot;increaseMonthNode&quot; 
+		dojoAttachEvent=&quot;onClick: onIncrementMonth;&quot; class=&quot;incrementControl&quot;&gt;
+		&lt;img src=&quot;${dojoRoot}src/widget/templates/incrementMonth.gif&quot; 
+			alt=&quot;&darr;&quot;  dojoAttachPoint=&quot;incrementMonthImageNode&quot;&gt;
+	&lt;/span&gt;
+	&lt;!--
+		&lt;span dojoAttachPoint=&quot;increaseWeekNode&quot; 
+			dojoAttachEvent=&quot;onClick: onIncrementWeek;&quot; 
+			class=&quot;incrementControl&quot;&gt;
+			&lt;img src=&quot;${dojoRoot}src/widget/templates/incrementWeek.gif&quot; 
+			alt=&quot;&darr;&quot; /&gt;
+		&lt;/span&gt;
+	--&gt;
+	&lt;/h3&gt;
+	&lt;table class=&quot;calendarContainer&quot;&gt;
+		&lt;thead&gt;
+			&lt;tr&gt;
+				&lt;td&gt;Sunday&lt;/td&gt;
+				&lt;td&gt;Monday&lt;/td&gt;
+				&lt;td&gt;Tuesday&lt;/td&gt;
+				&lt;td&gt;Wednesday&lt;/td&gt;
+				&lt;td&gt;Thursday&lt;/td&gt;
+				&lt;td&gt;Friday&lt;/td&gt;
+				&lt;td&gt;Saturday&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/thead&gt;
+		&lt;tbody dojoAttachPoint=&quot;calendarDatesContainerNode&quot; 
+			dojoAttachEvent=&quot;onClick: onSetDate;&quot;&gt;
+			&lt;tr dojoAttachPoint=&quot;calendarRow0&quot;&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr dojoAttachPoint=&quot;calendarRow1&quot;&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr dojoAttachPoint=&quot;calendarRow2&quot;&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr dojoAttachPoint=&quot;calendarRow3&quot;&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr dojoAttachPoint=&quot;calendarRow4&quot;&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr dojoAttachPoint=&quot;calendarRow5&quot;&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+	&lt;/table&gt;
+	&lt;h3 class=&quot;yearLabel&quot;&gt;
+		&lt;span dojoAttachPoint=&quot;previousYearLabelNode&quot;
+			dojoAttachEvent=&quot;onClick: onIncrementYear;&quot; class=&quot;previousYear&quot;&gt;&lt;/span&gt;
+		&lt;span class=&quot;selectedYear&quot; dojoAttachPoint=&quot;currentYearLabelNode&quot;&gt;&lt;/span&gt;
+		&lt;span dojoAttachPoint=&quot;nextYearLabelNode&quot; 
+			dojoAttachEvent=&quot;onClick: onIncrementYear;&quot; class=&quot;nextYear&quot;&gt;&lt;/span&gt;
+	&lt;/h3&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+div.statusBar {
+	background-color: ThreeDFace;
+	height: 28px;
+	padding: 1px;
+	overflow: hidden;
+	font-size: 12px;
+}
+
+div.statusPanel {
+	background-color: ThreeDFace;
+	border: 1px solid;
+	border-color: ThreeDShadow ThreeDHighlight ThreeDHighlight ThreeDShadow;
+	margin: 1px;
+	padding: 2px 6px;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlResizableTextarea.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,14 @@
+&lt;div&gt;
+	&lt;div style=&quot;border: 2px solid black; width: 90%; height: 200px;&quot;
+		dojoAttachPoint=&quot;rootLayoutNode&quot;&gt;
+		&lt;div dojoAttachPoint=&quot;textAreaContainerNode&quot; 
+			style=&quot;border: 0px; margin: 0px; overflow: hidden;&quot;&gt;
+		&lt;/div&gt;
+		&lt;div dojoAttachPoint=&quot;statusBarContainerNode&quot; class=&quot;statusBar&quot;&gt;
+			&lt;div dojoAttachPoint=&quot;statusLabelNode&quot; 
+				class=&quot;statusPanel&quot;
+				style=&quot;padding-right: 0px; z-index: 1;&quot;&gt;drag to resize&lt;/div&gt;
+			&lt;div dojoAttachPoint=&quot;resizeHandleNode&quot;&gt;&lt;/div&gt;
+		&lt;/div&gt;
+	&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlResizeHandle.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlResizeHandle.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlResizeHandle.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+.dojoHtmlResizeHandle {
+	float: right;
+	position: absolute;
+	right: 2px;
+	bottom: 2px;
+	width: 13px;
+	height: 13px;
+	z-index: 20;
+	cursor: nw-resize;
+	background-image: url(grabCorner.gif);
+	line-height: 0px;
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlShow.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlShow.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlShow.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,59 @@
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at media</A> screen {
+	html, body {
+		margin: 0px;
+		padding: 0px;
+		width: 100%;
+	}
+	body {
+		display: none;
+	}
+	h1 {
+		font-size: 50px;
+	}
+	p, li {
+		font-size: 30px;
+	}
+	.dojoShowNav {
+		background: #369;
+		overflow: hidden;
+		position: absolute;
+		height: 5px;
+		bottom: 0px;
+		left: 0px;
+		width: 100%;
+		text-align: center;
+	}
+	.dojoShowNav input {
+		margin: 0px;
+	}
+	.dojoShowHider {
+		height: 5px;
+		overflow: hidden;
+		width: 100%;
+	}
+	.dojoShowPrint {
+		position: absolute;
+		left: 5px;
+		top: 0px;
+	}
+}
<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">+ at media</A> print {
+	.dojoShow {
+		display: none !important;
+	}
+	.dojoShowPrint {
+		display: block !important;
+	}
+	.dojoShowPrintSlide {
+		border: 1px solid #aaa;
+		padding: 10px;
+		margin-bottom: 15px;
+	}
+	.dojoShowPrintSlide, ul {
+	page-break-inside: avoid;
+	}
+	h1 {
+		margin-top: 0;
+		page-break-after: avoid;
+	}
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlShow.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlShow.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlShow.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,11 @@
+&lt;div class=&quot;dojoShow&quot;&gt;
+	&lt;div dojoAttachPoint=&quot;contentNode&quot;&gt;&lt;/div&gt;
+	&lt;div class=&quot;dojoShowNav&quot; dojoAttachPoint=&quot;nav&quot;&gt;
+		&lt;div class=&quot;dojoShowHider&quot; dojoAttachPoint=&quot;hider&quot;&gt;&lt;/div&gt;
+		&lt;span dojoAttachEvent=&quot;onClick:previousSlide&quot;&gt;&lt;&lt;/span&gt;
+		&lt;select dojoAttachEvent=&quot;onClick:gotoSlideByEvent&quot; dojoAttachPoint=&quot;select&quot;&gt;
+			&lt;option dojoAttachPoint=&quot;option&quot;&gt;Title&lt;/option&gt;
+		&lt;/select&gt;
+		&lt;span dojoAttachEvent=&quot;onClick:nextSlide&quot;&gt;&gt;&lt;/span&gt;
+	&lt;/div&gt;
+&lt;/div&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlShowSlide.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlShowSlide.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlShowSlide.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,12 @@
+.dojoShowSlideTitle {
+	height: 100px;
+	background: #369;
+}
+.dojoShowSlideTitle h1 {
+	margin-top: 0;
+	line-height: 100px;
+	margin-left: 30px;
+}
+.dojoShowSlideBody {
+	margin: 15px;
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlShowSlide.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlShowSlide.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlShowSlide.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,6 @@
+&lt;div class=&quot;dojoShowSlide&quot;&gt;
+	&lt;div class=&quot;dojoShowSlideTitle&quot;&gt;
+		&lt;h1 dojoAttachPoint=&quot;htmlTitle&quot;&gt;Title&lt;/h1&gt;
+	&lt;/div&gt;
+	&lt;div class=&quot;dojoShowSlideBody&quot; dojoAttachPoint=&quot;containerNode&quot;&gt;&lt;/div&gt;
+&lt;/div&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSimpleDropdownButtons.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,100 @@
+ul.dojoSimpleDropdownButtons {
+	margin : 0;
+	padding : 5px 0;
+}
+
+ul.dojoSimpleDropdownButtons li {
+	display : inline;
+	margin-right : 5px;
+	padding : 2px 0;
+}
+
+ul.dojoSimpleDropdownButtons li a {
+	padding : 2px 9px;
+	border : 2px outset #ccc;
+	border-right-width : 1px;
+	background : #f4f4f4;
+	color : #333;
+	text-decoration : none;
+}
+
+ul.dojoSimpleDropdownButtons li ul {
+	display : none;
+}
+
+ul.dojoSimpleDropdownButtons li a.disabled {
+	color : #999;
+	cursor : default;
+}
+
+ul.dojoSimpleDropdownButtons li .downArrow {
+	display : inline;
+	padding : 2px 4px;
+	border : 2px outset #ccc;
+	border-left : 0;
+	background : #f4f4f4 url(images/dropdownButtonsArrow.gif) no-repeat 4px 9px;
+	text-decoration : none;
+	color : black;
+	cursor : pointer;
+	_cursor : hand;
+}
+
+ul.dojoSimpleDropdownButtons li .downArrow.disabled {
+	background-image : url(images/dropdownButtonsArrow-disabled.gif);
+	cursor : default;
+}
+
+ul.dojoSimpleDropdownButtons li a:hover,
+ul.dojoSimpleDropdownButtons li span.downArrow:hover {
+	color : black;
+	background-color : #ddd;
+}
+
+ul.dojoSimpleDropdownButtons li .downArrow.pressed, ul.dojoSimpleDropdownButtons li .downArrow:focus {
+	border-style : inset;
+	background-position : 5px 10px;
+	padding : 2px 4px;
+}
+
+ul.dojoSimpleDropdownButtons li a.disabled:hover,
+ul.dojoSimpleDropdownButtons li span.downArrow.disabled:hover {
+	color : #999;
+	background-color : #f4f4f4;
+}
+
+ul.dojoSimpleDropdownButtons li a:focus {
+	padding : 3px 8px 1px 10px;
+	color : #333;
+	border-style : inset;
+}
+
+/* Menu
+ ******************** */
+ul.dojoSimpleDropdownButtonsMenu {
+	position : absolute;
+	margin : 0;
+	_margin : -2px;
+	padding : 0;
+	display : none;
+	border : 1px solid #aaa;
+	background : #f4f4f4;
+	list-style : none;
+	z-index : 99;
+}
+
+ul.dojoSimpleDropdownButtonsMenu li {
+	_display : inline;
+}
+
+ul.dojoSimpleDropdownButtonsMenu a {
+	display : block;
+	padding : 2px 5px;
+	color : #333;
+	text-decoration : none;
+}
+
+ul.dojoSimpleDropdownButtonsMenu a:hover {
+	background : #ddd;
+	color : black;
+}
+

Added: trunk/root/static/magic/src/widget/templates/HtmlSlideShow.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSlideShow.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSlideShow.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,9 @@
+.slideShowImg {
+	position: absolute;
+	left: 0px;
+	top: 0px; 
+	border: 2px solid #4d4d4d;
+	padding: 0px;
+	margin: 0px;
+}
+

Added: trunk/root/static/magic/src/widget/templates/HtmlSlideShow.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSlideShow.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSlideShow.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,15 @@
+&lt;div style=&quot;position: relative; padding: 3px;&quot;&gt;
+		&lt;div dojoAttachPoint=&quot;controlsContainer&quot;&gt;
+			&lt;input type=&quot;button&quot; value=&quot;pause&quot; 
+				dojoAttachPoint=&quot;startStopButton&quot;
+				dojoAttachEvent=&quot;onClick: togglePaused;&quot;&gt;
+		&lt;/div&gt;
+		&lt;div style=&quot;position: relative; width: 800px; height: 600px;&quot;
+			dojoAttachPoint=&quot;imagesContainer&quot;
+			dojoAttachEvent=&quot;onClick: togglePaused;&quot;&gt;
+			&lt;img dojoAttachPoint=&quot;img1&quot; class=&quot;slideShowImg&quot; 
+				style=&quot;z-index: 1;&quot;  /&gt;
+			&lt;img dojoAttachPoint=&quot;img2&quot; class=&quot;slideShowImg&quot; 
+				style=&quot;z-index: 0;&quot; /&gt;
+		&lt;/div&gt;	
+&lt;/div&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlSlider.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSlider.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSlider.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,47 @@
+.sliderMain { 
+  position: relative; 
+  /*top: 80px; left: 0px;*/
+  padding: 0px; 
+  border: 1px solid black;
+  width: 300px; height: 300px; 
+}
+
+.sliderHandle { 
+  color: #FF0000;
+  position: relative; 
+  background-image: url(images/slider-button.png);
+  width: 25px; 
+  height: 25px;
+}
+
+.sliderMainHorizontal { 
+  position: relative; 
+  /*top: 80px; left: 0px;*/
+  padding: 0px; 
+  width: 300px; height: 35px; 
+  background: url(images/slider-bg.gif) no-repeat 0px 4px;
+}
+
+.sliderHandleHorizontal { 
+  color: #FF0000;
+  position: relative; 
+  background-image: url(images/slider-button-horz.png);
+  width: 25px; 
+  height: 35px;
+}
+
+.sliderMainVertical { 
+  position: relative; 
+  /*top: 80px; left: 0px;*/
+  padding: 0px; 
+  width: 35px; height: 300px; 
+  background: url(images/slider-bg-vert.gif) no-repeat 4px 0px;
+}
+
+.sliderHandleVertical { 
+  color: #FF0000;
+  position: relative; 
+  background-image: url(images/slider-button-vert.png);
+  width: 35px; 
+  height: 25px;
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlSlider.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSlider.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSlider.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,3 @@
+&lt;div class=&quot;sliderMain&quot;&gt;
+    &lt;div class=&quot;sliderHandle&quot; dojoAttachPoint=&quot;sliderHandle&quot;&gt;&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSliderHorizontal.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,3 @@
+&lt;div class=&quot;sliderMainHorizontal&quot;&gt;
+    &lt;div class=&quot;sliderHandleHorizontal&quot; dojoAttachPoint=&quot;sliderHandle&quot;&gt;&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlSliderVertical.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSliderVertical.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSliderVertical.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,3 @@
+&lt;div class=&quot;sliderMainVertical&quot;&gt;
+    &lt;div class=&quot;sliderHandleVertical&quot; dojoAttachPoint=&quot;sliderHandle&quot;&gt;&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlSpinner.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSpinner.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSpinner.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,39 @@
+input.dojoSpinnerInput {
+	/* font-size: 0.8em; */
+	border: 0px;
+}
+
+.dojoSpinnerOptions {
+	font-family: Verdana, Helvetica, Garamond, sans-serif;
+	/* font-size: 0.7em; */
+	background-color: white;
+	border: 1px solid #afafaf;
+	position: absolute;
+	z-index: 1000; 
+	overflow: auto;
+	-moz-opacity: 0;
+	cursor: default;
+}
+
+table.dojoSpinner {
+	border: 1px solid #afafaf;
+}
+
+.dojoSpinnerItem {
+	padding-left: 2px;
+	padding-top: 2px;
+	margin: 0px;
+}
+
+.dojoSpinnerItemEven {
+	background-color: #f4f4f4;
+}
+
+.dojoSpinnerItemOdd {
+	background-color: white;
+}
+
+.dojoSpinnerItemHighlight {
+	background-color: #63709A;
+	color: white;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlSpinner.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSpinner.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSpinner.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,28 @@
+&lt;span style=&quot;display:none;&quot;&gt;
+	&lt;span style=&quot;position:relative;&quot; dojoAttachPoint=&quot;relNode&quot;&gt;
+		&lt;span style=&quot;position:absolute; left:0; top:0;&quot; dojoAttachPoint=&quot;absNode&quot;&gt;
+			&lt;span style=&quot;position:relative;&quot; dojoAttachPoint=&quot;innerRelNode&quot;&gt;
+				&lt;img border=&quot;0&quot;
+					hspace=&quot;0&quot;
+					vspace=&quot;0&quot;
+					style=&quot;position:absolute; left:0;top:0; border-right:1px solid black;border-bottom:1px solid black;&quot;
+					dojoAttachPoint=&quot;upArrowNode&quot;
+					src=&quot;${dojoRoot}src/widget/templates/images/spinnerIncrement.gif&quot;&gt;
+				&lt;img border=&quot;0&quot;
+					hspace=&quot;0&quot;
+					vspace=&quot;0&quot;
+					style=&quot;vertical-align:bottom;border-right:1px solid black;border-bottom:1px solid black;&quot;
+					dojoAttachPoint=&quot;downArrowNode&quot;
+					src=&quot;${dojoRoot}src/widget/templates/images/spinnerDecrement.gif&quot;&gt;
+			&lt;/span&gt;
+		&lt;/span&gt;
+		&lt;span style=&quot;position:relative;&quot; dojoAttachPoint=&quot;spacerRelNode&quot;&gt;
+			&lt;img border=&quot;0&quot;
+				hspace=&quot;0&quot;
+				vspace=&quot;0&quot;
+				style=&quot;visibility:hidden;&quot;
+				dojoAttachPoint=&quot;spacerNode&quot;
+				src=&quot;${dojoRoot}src/widget/templates/images/spinnerIncrement.gif&quot;&gt;
+		&lt;/span&gt;
+	&lt;/span&gt;
+&lt;/span&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlSplitContainer.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlSplitContainer.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlSplitContainer.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,39 @@
+.dojoSplitContainer{
+	position: relative;
+	overflow: hidden;
+}
+
+.dojoSplitPane{
+	position: absolute;
+}
+
+.dojoSplitContainerSizerH,
+.dojoSplitContainerSizerV {
+	font-size: 1px;
+	cursor: move;
+	cursor: w-resize;
+	background-color: ThreeDFace;
+	border: 1px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	margin: 0;
+}
+
+.dojoSplitContainerSizerV {
+	cursor: n-resize;
+}
+
+.dojoSplitContainerVirtualSizerH,
+.dojoSplitContainerVirtualSizerV {
+	font-size: 1px;
+	cursor: move;
+	cursor: w-resize;
+	background-color: ThreeDShadow;
+	-moz-opacity: 0.5;
+	opacity: 0.5;
+	filter: Alpha(Opacity=50);
+	margin: 0;
+}
+
+.dojoSplitContainerVirtualSizerV {
+	cursor: n-resize;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlTabContainer.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTabContainer.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTabContainer.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,173 @@
+.dojoTabContainer {
+	position : relative;
+}
+
+.dojoTabPaneWrapper {
+	position : relative;
+	border : 1px solid #6290d2;
+	clear: both;
+}
+
+.dojoTabLabels-top {
+	position : absolute;
+	top : 0px;
+	left : 0px;
+	overflow : visible;
+	margin-bottom : -1px;
+	width : 100%;
+	z-index: 2;	/* so the bottom of the tab label will cover up the border of dojoTabPaneWrapper */
+}
+.dojoTabLabels-top-noLayout {
+	overflow : visible;
+	margin-bottom : -1px;
+	width : 100%;
+	z-index: 2;
+}
+
+.dojoTabPaneTab {
+	position : relative;
+	float : left;
+	padding-left : 9px;
+	border-bottom : 1px solid #6290d2;
+	background : url(images/tab_left.gif) no-repeat left top;
+	cursor: pointer;
+}
+
+.dojoTabPaneTab span {
+	display : block;
+	padding : 4px 15px 4px 6px;
+	background : url(images/tab_top_right.gif) no-repeat right top;
+	color : #333;
+	font-size : 90%;
+}
+
+.dojoTabPanePaneClose {
+	position : absolute;
+	bottom : 0px;
+	right : 6px;
+	height : 12px;
+	width : 12px;
+	background : url(images/tab_close.gif) no-repeat right top;
+}
+
+.dojoTabPanePaneCloseHover {
+	background-image : url(images/tab_close_h.gif);
+}
+
+.dojoTabPaneTabClose {
+	display : inline;
+	height : 12px;
+	width : 12px;
+	padding : 0 12px 0 0;
+	margin : 0 -10px 0 10px;
+	background : url(images/tab_close.gif) no-repeat right top;
+	cursor : default;
+}
+
+.dojoTabPaneTabCloseHover {
+	background-image : url(images/tab_close_h.gif);
+}
+
+.dojoTabPaneTab.current {
+	padding-bottom : 1px;
+	border-bottom : 0;
+	background-position : 0 -150px;
+}
+
+.dojoTabPaneTab.current span {
+	padding-bottom : 5px;
+	margin-bottom : -1px;
+	background-position : 100% -150px;
+}
+
+/* bottom tabs */
+
+.dojoTabLabels-bottom {
+	position : absolute;
+	bottom : 0px;
+	left : 0px;
+	overflow : visible;
+	margin-top : -1px;
+	width : 100%;
+	z-index: 2;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab {
+	border-top :  1px solid #6290d2;
+	border-bottom : 0;
+	background : url(images/tab_bot_left.gif) no-repeat left bottom;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab span {
+	background : url(images/tab_bot_right.gif) no-repeat right bottom;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab.current {
+	padding-top : 1px;
+	border-top : 0;
+	background : url(images/tab_bot_left_curr.gif) no-repeat left bottom;
+}
+
+.dojoTabLabels-bottom .dojoTabPaneTab.current span {
+	padding-top : 5px;
+	margin-top : -1px;
+	background : url(images/tab_bot_right_curr.gif) no-repeat right bottom;
+}
+
+/* right-h tabs */
+
+.dojoTabLabels-right-h {
+	position : absolute;
+	top : 0px;
+	right : 0px;
+	overflow : visible;
+	margin-left : -1px;
+	z-index: 2;
+}
+
+.dojoTabLabels-right-h .dojoTabPaneTab {
+	padding-left : 0;
+	border-left :  1px solid #6290d2;
+	border-bottom : 0;
+	background : url(images/tab_bot_right.gif) no-repeat right bottom;
+	float : none;
+}
+
+.dojoTabLabels-right-h .dojoTabPaneTab span {
+	padding : 4px 15px 4px 15px;
+}
+
+.dojoTabLabels-right-h .dojoTabPaneTab.current {
+	border-left :  0;
+	border-bottom :  1px solid #6290d2;
+}
+
+/* left-h tabs */
+
+.dojoTabLabels-left-h {
+	position : absolute;
+	top : 0px;
+	left : 0px;
+	overflow : visible;
+	margin-right : -1px;
+	z-index: 2;
+}
+
+.dojoTabLabels-left-h .dojoTabPaneTab {
+	border-right :  1px solid #6290d2;
+	border-bottom : 0;
+	float : none;
+	background : url(images/tab_top_left.gif) no-repeat left top;
+}
+
+.dojoTabLabels-left-h .dojoTabPaneTab.current {
+	border-right : 0;
+	border-bottom :  1px solid #6290d2;
+	padding-bottom : 0;
+	background : url(images/tab_top_left.gif) no-repeat 0 -150px;
+}
+
+.dojoTabLabels-left-h .dojoTabPaneTab span {
+	background : 0;
+	border-bottom :  1px solid #6290d2;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlTabContainer.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTabContainer.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTabContainer.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,4 @@
+&lt;div id=&quot;${this.widgetId}&quot; class=&quot;dojoTabContainer&quot; waiRole=&quot;tabpanel&quot;&gt;
+	&lt;div dojoAttachPoint=&quot;dojoTabLabels&quot;&gt;&lt;/div&gt;
+	&lt;div class=&quot;dojoTabPaneWrapper&quot; dojoAttachPoint=&quot;containerNode&quot; &gt;&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlTaskBar.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTaskBar.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTaskBar.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,29 @@
+.dojoTaskBarItem {
+	display: inline-block;
+	background-color: ThreeDFace;
+	border: outset 2px;
+	margin-right: 5px;
+	cursor: pointer;
+	height: 35px;
+	width: 100px;
+	font-size: 10pt;
+	white-space: nowrap;
+	text-align: center;
+	float: left;
+	overflow: hidden;
+}
+
+.dojoTaskBarItem img {
+	vertical-align: middle;
+	margin-right: 5px;
+	margin-left: 5px;	
+	height: 32px;
+	width: 32px;
+}
+
+.dojoTaskBarItem a {
+	 color: black;
+	text-decoration: none;
+}
+
+

Added: trunk/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTaskBarItemTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,2 @@
+&lt;div class=&quot;dojoTaskBarItem&quot; dojoAttachEvent=&quot;onClick&quot;&gt;
+&lt;/div&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/HtmlTimePicker.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTimePicker.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTimePicker.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,37 @@
+.timePickerContainer {
+	margin:1.75em 0 0.5em 0;
+	width:10em;
+	float:left;
+}
+
+.timeContainer {
+	border-collapse:collapse;
+	border-spacing:0;
+}
+
+.timeContainer thead td{
+	border-bottom:1px solid #e6e6e6;
+	padding:0 0.4em 0.2em 0.4em;
+}
+
+.timeContainer td {
+	font-size:0.9em;
+	padding:0 0.25em 0 0.25em;
+	text-align:left;
+	cursor:pointer;cursor:hand;
+}
+
+.timeContainer td.minutesHeading {
+	border-left:1px solid #e6e6e6;
+	border-right:1px solid #e6e6e6;	
+}
+
+.timeContainer .minutes {
+	border-left:1px solid #e6e6e6;
+	border-right:1px solid #e6e6e6;
+}
+
+.selectedItem {
+	background-color:#3a3a3a;
+	color:#ffffff;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlTimePicker.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTimePicker.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTimePicker.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,99 @@
+&lt;div class=&quot;timePickerContainer&quot; dojoAttachPoint=&quot;timePickerContainerNode&quot;&gt;
+	&lt;table class=&quot;timeContainer&quot; cellspacing=&quot;0&quot; &gt;
+		&lt;thead&gt;
+			&lt;tr&gt;
+				&lt;td&gt;Hour&lt;/td&gt;
+				&lt;td class=&quot;minutesHeading&quot;&gt;Minute&lt;/td&gt;
+				&lt;td&gt;&nbsp;&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/thead&gt;
+		&lt;tbody&gt;
+			&lt;tr&gt;
+				&lt;td valign=&quot;top&quot;&gt;
+					&lt;table&gt;
+						&lt;tbody dojoAttachPoint=&quot;hourContainerNode&quot;  
+							dojoAttachEvent=&quot;onClick: onSetSelectedHour;&quot;&gt;
+							&lt;tr&gt;
+								&lt;td&gt;12&lt;/td&gt;
+								&lt;td&gt;6&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;1&lt;/td&gt;
+								&lt;td&gt;7&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;2&lt;/td&gt;
+								&lt;td&gt;8&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;3&lt;/td&gt;
+								&lt;td&gt;9&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;4&lt;/td&gt;
+								&lt;td&gt;10&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;5&lt;/td&gt;
+								&lt;td&gt;11&lt;/td&gt;
+							&lt;/tr&gt;
+						&lt;/tbody&gt;
+					&lt;/table&gt;
+				&lt;/td&gt;
+				&lt;td valign=&quot;top&quot; class=&quot;minutes&quot;&gt;
+					&lt;table&gt;
+						&lt;tbody dojoAttachPoint=&quot;minuteContainerNode&quot; 
+							dojoAttachEvent=&quot;onClick: onSetSelectedMinute;&quot;&gt;
+							&lt;tr&gt;
+								&lt;td&gt;00&lt;/td&gt;
+								&lt;td&gt;30&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;05&lt;/td&gt;
+								&lt;td&gt;35&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;10&lt;/td&gt;
+								&lt;td&gt;40&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;15&lt;/td&gt;
+								&lt;td&gt;45&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;20&lt;/td&gt;
+								&lt;td&gt;50&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;25&lt;/td&gt;
+								&lt;td&gt;55&lt;/td&gt;
+							&lt;/tr&gt;
+						&lt;/tbody&gt;
+					&lt;/table&gt;
+				&lt;/td&gt;
+				&lt;td valign=&quot;top&quot;&gt;
+					&lt;table&gt;
+						&lt;tbody dojoAttachPoint=&quot;amPmContainerNode&quot; 
+							dojoAttachEvent=&quot;onClick: onSetSelectedAmPm;&quot;&gt;
+							&lt;tr&gt;
+								&lt;td&gt;AM&lt;/td&gt;
+							&lt;/tr&gt;
+							&lt;tr&gt;
+								&lt;td&gt;PM&lt;/td&gt;
+							&lt;/tr&gt;
+						&lt;/tbody&gt;
+					&lt;/table&gt;
+				&lt;/td&gt;
+			&lt;/tr&gt;
+			&lt;tr&gt;
+				&lt;td&gt;&lt;/td&gt;
+				&lt;td&gt;
+					&lt;div dojoAttachPoint=&quot;anyTimeContainerNode&quot; 
+						dojoAttachEvent=&quot;onClick: onSetSelectedAnyTime;&quot; 
+						class=&quot;anyTimeContainer&quot;&gt;any&lt;/div&gt;
+				&lt;/td&gt;
+				&lt;td&gt;&lt;/td&gt;
+			&lt;/tr&gt;
+		&lt;/tbody&gt;
+	&lt;/table&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/HtmlToolbar.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlToolbar.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlToolbar.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,54 @@
+.toolbarContainer {
+	border-bottom : 0;
+	background-color : #def;
+	color : ButtonText;
+	font : Menu;
+	background-image: url(images/toolbar-bg.gif);
+}
+
+.toolbar {
+	padding : 2px 4px;
+	min-height : 26px;
+	_height : 26px;
+}
+
+.toolbarItem {
+	float : left;
+	padding : 1px 2px;
+	margin : 0 2px 1px 0;
+	cursor : pointer;
+}
+
+.toolbarItem.selected, .toolbarItem.down {
+	margin : 1px 1px 0 1px;
+	padding : 0px 1px;
+	border : 1px solid #bbf;
+	background-color : #fafaff;
+}
+
+.toolbarButton img {
+	vertical-align : bottom;
+}
+
+.toolbarButton span {
+	line-height : 16px;
+	vertical-align : middle;
+}
+
+.toolbarButton.hover {
+	padding : 0px 1px;
+	border : 1px solid #99c;
+}
+
+.toolbarItem.disabled {
+	opacity : 0.3;
+	filter : alpha(opacity=30);
+	cursor : default;
+}
+
+.toolbarSeparator {
+	cursor : default;
+}
+
+.toolbarFlexibleSpace {
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,9 @@
+.dojoTooltip {
+	border: solid black 1px;
+	background: beige;
+	color: black;
+	position: absolute;
+	font-size: small;
+	padding: 2px 2px 2px 2px;
+	z-index: 10;
+}

Added: trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/HtmlTooltipTemplate.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,2 @@
+&lt;div class='dojoTooltip' style=&quot;display:none&quot; dojoAttachPoint=&quot;containerNode&quot;&gt;
+&lt;/div&gt;
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/Menu.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/Menu.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/Menu.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,60 @@
+.dojoMenu {
+	border:1px solid #000000;
+	list-style-type:none;
+	margin:0;
+	padding:0;
+	padding-bottom: 1px;
+	background-color:#f4f4f4;
+	font-size: 8pt;
+}
+
+.dojoMenuSeparator {
+	list-style-type:none;
+	margin:0;
+	padding:1px 0;
+	border-bottom:1px solid #000000;
+	line-height:1px;
+	height:1px;
+}
+
+li:hover.dojoMenuSeparator {
+	background-color:#e5e5e5;
+	cursor:default;
+}
+
+
+
+
+.dojoContextMenu {
+	position: absolute;
+	display: none;
+	border: 2px solid;
+	border-color: ThreeDHighlight ThreeDShadow ThreeDShadow ThreeDHighlight;
+	list-style-type: none;
+	margin: 0;
+	padding: 1px;
+	background-color: ThreeDFace;
+	font-size: 8pt;
+}
+
+.dojoMenuItem {
+	white-space: nowrap;
+	padding: 2px;
+	font: menu;
+	color: WindowText;
+}
+
+.dojoMenuItem a {
+	text-decoration: none;
+	color: WindowText;
+	font: inherit;
+}
+
+.dojoMenuItemHover {
+	padding: 2px;
+	background-color: blue;
+	cursor: pointer;
+	_cursor: hand;
+	background-color: Highlight;
+	color: HighlightText;
+}
\ No newline at end of file

Added: trunk/root/static/magic/src/widget/templates/PopUpButton.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/PopUpButton.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/PopUpButton.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,35 @@
+.PopUpButton {
+	padding : 2px 6px 2px 9px;
+	border : 1px outset #ccc;
+	background : #f4f4f4;
+	color : #333;
+	text-decoration : none;
+}
+
+.PopUpButton .downArrow {
+	margin-left: 0.5em;
+	margin-bottom: 2px;
+}
+
+.downArrow.disabled {
+	background-image : url(images/dropdownButtonsArrow-disabled.gif);
+	cursor : default;
+}
+
+ul.dropdownButtons li a:hover,
+ul.dropdownButtons li span.downArrow:hover {
+	color : black;
+	background-color : #ddd;
+}
+
+ul.dropdownButtons li .downArrow.pressed, ul.dropdownButtons li .downArrow:focus {
+	border-style : inset;
+	background-position : 5px 10px;
+	padding : 2px 4px;
+}
+
+ul.dropdownButtons li a.disabled:hover,
+ul.dropdownButtons li span.downArrow.disabled:hover {
+	color : #999;
+	background-color : #f4f4f4;
+}

Added: trunk/root/static/magic/src/widget/templates/TitlePane.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/TitlePane.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/TitlePane.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,4 @@
+&lt;div dojoAttachPoint=&quot;domNode&quot;&gt;
+&lt;div dojoAttachPoint=&quot;labelNode&quot; dojoAttachEvent=&quot;onclick: onLabelClick&quot;&gt;&lt;/div&gt;
+&lt;div dojoAttachPoint=&quot;containerNode&quot;&gt;&lt;/div&gt;
+&lt;/div&gt;

Added: trunk/root/static/magic/src/widget/templates/Tree.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/Tree.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/Tree.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,29 @@
+.dojoTree {
+	font: caption;
+	font-size: 11px;
+	font-weight: normal;
+	overflow: auto;
+}
+
+.dojoTreeNodeLabel {
+	padding: 1px 2px;
+	color: WindowText;
+	cursor: default;
+}
+
+.dojoTreeNodeLabel:hover {
+	text-decoration: underline;
+}
+
+.dojoTreeNodeLabelSelected {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoTree div {
+	white-space: nowrap;
+}
+
+.dojoTree img {
+	vertical-align: middle;
+}

Added: trunk/root/static/magic/src/widget/templates/Wizard.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/Wizard.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/Wizard.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,72 @@
+.WizardContainer {
+	background: #EEEEEE;
+	border: #798EC5 1px solid;
+	padding: 2px;
+}
+
+.WizardTitle {
+	color: #003366;
+	padding: 8px 5px 15px 2px;
+	font-weight: bold;
+	font-size: x-small;
+	font-style: normal;
+	font-family: Verdana, Arial, Helvetica;
+	text-align: left;
+}
+
+.WizardText {
+	color: #000033;
+	font-weight: normal;
+	font-size: xx-small;
+	font-family: Verdana, Arial, Helvetica;
+	padding: 2 50; text-align: justify;
+}
+
+.WizardLightText {
+	color: #666666;
+	font-weight: normal;
+	font-size: xx-small;
+	font-family: verdana, arial, helvetica;
+	padding: 2px 50px;
+	text-align: justify;
+}
+
+.WizardButtonHolder {
+	text-align: right;
+	padding: 10px 5px;
+}
+
+.WizardButton {
+	color: #ffffff;
+	background: #798EC5;
+	font-size: xx-small;
+	font-family: verdana, arial, helvetica, sans-serif;
+	border-right: #000000 1px solid;
+	border-bottom: #000000 1px solid;
+	border-left: #666666 1px solid;
+	border-top: #666666 1px solid;
+	padding-right: 4px;
+	padding-left: 4px;
+	text-decoration: none; height: 18px;
+}
+
+.WizardButton:hover {
+	cursor: pointer;
+}
+
+.WizardButtonDisabled {
+	color: #eeeeee;
+	background-color: #999999;
+	font-size: xx-small;
+	FONT-FAMILY: verdana, arial, helvetica, sans-serif;
+	border-right: #000000 1px solid;
+	border-bottom: #000000 1px solid;
+	border-left: #798EC5 1px solid;
+	border-top: #798EC5 1px solid;
+	padding-right: 4px;
+	padding-left: 4px;
+	text-decoration: none;
+	height: 18px;
+}
+
+

Added: trunk/root/static/magic/src/widget/templates/Wizard.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/Wizard.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/Wizard.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,11 @@
+&lt;div class=&quot;WizardContainer&quot; dojoAttachPoint=&quot;wizardNode&quot;&gt;
+    &lt;div class=&quot;WizardText&quot; dojoAttachPoint=&quot;wizardPanelContainerNode&quot;&gt;
+    &lt;/div&gt;
+    &lt;div class=&quot;WizardButtonHolder&quot; dojoAttachPoint=&quot;wizardControlContainerNode&quot;&gt;
+        &lt;input class=&quot;WizardButton&quot; type=&quot;button&quot; dojoAttachPoint=&quot;previousButton&quot;/&gt;
+        &lt;input class=&quot;WizardButton&quot; type=&quot;button&quot; dojoAttachPoint=&quot;nextButton&quot;/&gt;
+        &lt;input class=&quot;WizardButton&quot; type=&quot;button&quot; dojoAttachPoint=&quot;cancelButton&quot;/&gt;
+        &lt;input class=&quot;WizardButton&quot; type=&quot;button&quot; dojoAttachPoint=&quot;doneButton&quot; style=&quot;display:none&quot;/&gt;
+    &lt;/div&gt;
+&lt;/div&gt;
+

Added: trunk/root/static/magic/src/widget/templates/buttons/-.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/-.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/aggregate.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/aggregate.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/backcolor.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/backcolor.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/bg-fade.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/bg-fade.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/buttons/bold.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/bold.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/cancel.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/cancel.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/copy.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/copy.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/createlink.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/createlink.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/cut.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/cut.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/delete.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/delete.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/forecolor.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/forecolor.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/hilitecolor.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/hilitecolor.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/indent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/indent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/inserthorizontalrule.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/inserthorizontalrule.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/insertimage.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/insertimage.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/insertorderedlist.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/insertorderedlist.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/inserttable.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/inserttable.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/insertunorderedlist.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/insertunorderedlist.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/italic.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/italic.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/justifycenter.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/justifycenter.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/justifyfull.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/justifyfull.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/justifyleft.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/justifyleft.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/justifyright.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/justifyright.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/left_to_right.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/left_to_right.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/list_bullet_indent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/list_bullet_indent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/list_bullet_outdent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/list_bullet_outdent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/list_num_indent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/list_num_indent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/list_num_outdent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/list_num_outdent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/outdent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/outdent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/paste.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/paste.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/redo.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/redo.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/removeformat.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/removeformat.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/right_to_left.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/right_to_left.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/save.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/save.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/space.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/space.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/strikethrough.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/strikethrough.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/subscript.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/subscript.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/superscript.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/superscript.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/underline.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/underline.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/undo.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/undo.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/buttons/wikiword.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/buttons/wikiword.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/check_disabled_off.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/check_disabled_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/check_disabled_on.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/check_disabled_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/check_hover_off.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/check_hover_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/check_hover_on.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/check_hover_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/check_off.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/check_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/check_on.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/check_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/decrementMonth.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/decrementMonth.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/decrementWeek.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/decrementWeek.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/grabCorner.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/grabCorner.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/Tree.css
===================================================================
--- trunk/root/static/magic/src/widget/templates/images/Tree/Tree.css	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/images/Tree/Tree.css	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,36 @@
+
+.dojoTree {
+	font: caption;
+	font-size: 11px;
+	font-weight: normal;
+	overflow: auto;
+}
+
+
+.dojoTreeNodeLabelTitle {
+	padding-left: 2px;
+	color: WindowText;
+}
+
+.dojoTreeNodeLabel {
+	cursor:hand;
+	cursor:pointer;
+}
+
+.dojoTreeNodeLabelTitle:hover {
+	text-decoration: underline;
+}
+
+.dojoTreeNodeLabelSelected {
+	background-color: Highlight;
+	color: HighlightText;
+}
+
+.dojoTree div {
+	white-space: nowrap;
+}
+
+.dojoTree img, .dojoTreeNodeLabel img {
+	vertical-align: middle;
+}
+

Added: trunk/root/static/magic/src/widget/templates/images/Tree/blank.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/blank.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/closed.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/closed.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/document.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/document.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/minus.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/minus.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/plus.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/plus.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/transparent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/transparent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_blank.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_blank.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_child.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_child.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_expand_minus.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_expand_minus.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_expand_plus.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_expand_plus.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_c.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_c.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_l.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_l.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_p.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_p.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_t.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_t.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_v.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_v.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_x.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_x.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_y.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_y.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_z.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_grid_z.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_loading.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_loading.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_loading.jpg
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/Tree/treenode_loading.jpg
___________________________________________________________________
Name: svn:mime-type
   + image/jpeg

Added: trunk/root/static/magic/src/widget/templates/images/bdYearBg.1.gif
===================================================================

Added: trunk/root/static/magic/src/widget/templates/images/bdYearBg.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/bdYearBg.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/blank.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/blank.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/combo_box_arrow.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/combo_box_arrow.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dateIcon.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dateIcon.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/decrementMonth.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/decrementMonth.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/decrementMonth.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/decrementMonth.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dpBg.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpBg.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/dpCurveBL.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpCurveBL.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dpCurveBR.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpCurveBR.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dpCurveTL.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpCurveTL.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dpCurveTR.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpCurveTR.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dpHorizLine.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpHorizLine.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/dpHorizLineFoot.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpHorizLineFoot.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/dpMonthBg.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpMonthBg.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/dpMonthBg.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpMonthBg.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dpVertLine.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpVertLine.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/dpYearBg.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dpYearBg.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/dropdownButtonsArrow-disabled.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dropdownButtonsArrow-disabled.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/dropdownButtonsArrow.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/dropdownButtonsArrow.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/floatingPaneClose.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/floatingPaneClose.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/floatingPaneMaximize.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/floatingPaneMaximize.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/floatingPaneMinimize.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/floatingPaneMinimize.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/floatingPaneRestore.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/floatingPaneRestore.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/incrementMonth.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/incrementMonth.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/incrementMonth.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/incrementMonth.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/no.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/no.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/no.svg
===================================================================
--- trunk/root/static/magic/src/widget/templates/images/no.svg	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/images/no.svg	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,11 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
+&lt;!-- Generator: Adobe Illustrator 12.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 51448)  --&gt;
+&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;<A HREF="http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd</A>&quot; [
+	&lt;!ENTITY ns_svg &quot;<A HREF="http://www.w3.org/2000/svg">http://www.w3.org/2000/svg</A>&quot;&gt;
+	&lt;!ENTITY ns_xlink &quot;<A HREF="http://www.w3.org/1999/xlink">http://www.w3.org/1999/xlink</A>&quot;&gt;
+]&gt;
+&lt;svg  version=&quot;1.1&quot; id=&quot;Layer_1&quot; xmlns=&quot;&amp;ns_svg;&quot; xmlns:xlink=&quot;&amp;ns_xlink;&quot; width=&quot;15.433&quot; height=&quot;15.433&quot;
+	 viewBox=&quot;0 0 15.433 15.433&quot; overflow=&quot;visible&quot; enable-background=&quot;new 0 0 15.433 15.433&quot; xml:space=&quot;preserve&quot;&gt;
+&lt;circle fill=&quot;none&quot; stroke=&quot;#D02026&quot; stroke-width=&quot;2&quot; cx=&quot;7.716&quot; cy=&quot;7.716&quot; r=&quot;6.716&quot;/&gt;
+&lt;line fill=&quot;none&quot; stroke=&quot;#D02026&quot; stroke-width=&quot;2&quot; x1=&quot;3.02&quot; y1=&quot;12.352&quot; x2=&quot;12.639&quot; y2=&quot;2.732&quot;/&gt;
+&lt;/svg&gt;

Added: trunk/root/static/magic/src/widget/templates/images/scBackground.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/scBackground.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/slider-bg-vert.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/slider-bg-vert.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/slider-bg.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/slider-bg.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/slider-button-horz.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/slider-button-horz.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/slider-button-vert.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/slider-button-vert.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/slider-button.png
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/slider-button.png
___________________________________________________________________
Name: svn:mime-type
   + image/x-png

Added: trunk/root/static/magic/src/widget/templates/images/soriaActive-c.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaActive-c.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaActive-l.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaActive-l.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaActive-r.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaActive-r.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaButton-c.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaButton-c.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaButton-l.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaButton-l.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaButton-r.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaButton-r.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaDisabled-c.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaDisabled-c.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaDisabled-l.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaDisabled-l.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaDisabled-r.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaDisabled-r.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaPressed-c.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaPressed-c.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaPressed-l.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaPressed-l.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/soriaPressed-r.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/soriaPressed-r.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/spinnerDecrement.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/spinnerDecrement.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/spinnerIncrement.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/spinnerIncrement.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/submenu_off.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/submenu_off.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/submenu_on.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/submenu_on.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_bot_left.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_bot_left.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_bot_left_curr.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_bot_left_curr.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_bot_right.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_bot_right.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_bot_right_curr.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_bot_right_curr.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_close.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_close.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_close_h.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_close_h.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_left.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_left.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_left_r.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_left_r.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_left_r_curr.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_left_r_curr.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_right.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_right.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_right_r.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_right_r.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_right_r_curr.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_right_r_curr.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_top_left.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_top_left.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/tab_top_right.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/tab_top_right.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/toolbar-bg.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/toolbar-bg.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/transparent.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/transparent.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_blank.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_blank.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_child.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_child.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_expand_minus.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_expand_minus.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_expand_plus.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_expand_plus.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_c.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_c.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_l.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_l.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_p.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_p.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_t.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_t.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_v.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_v.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_x.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_x.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_y.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_y.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_grid_z.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_grid_z.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/treenode_node.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/treenode_node.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/verticalbar.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/verticalbar.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/images/whiteDownArrow.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/images/whiteDownArrow.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/incrementMonth.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/incrementMonth.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/incrementWeek.gif
===================================================================
(Binary files differ)


Property changes on: trunk/root/static/magic/src/widget/templates/incrementWeek.gif
___________________________________________________________________
Name: svn:mime-type
   + image/gif

Added: trunk/root/static/magic/src/widget/templates/richtextframe.html
===================================================================
--- trunk/root/static/magic/src/widget/templates/richtextframe.html	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/templates/richtextframe.html	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,21 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
+
+&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;DTD/xhtml1-strict.dtd&quot;&gt;
+&lt;html&gt;
+  &lt;head&gt;
+    &lt;title&gt;&lt;/title&gt;
+    &lt;script type=&quot;text/javascript&quot;&gt;
+    function init(){
+       document.designMode = 'On';
+       parentPageDomain = document.location.href.split('#')[1];
+       if (parentPageDomain) {
+          document.domain = parentPageDomain;
+       }
+    }
+    window.onload = init;
+    &lt;/script&gt;
+  &lt;/head&gt;
+  &lt;body&gt;
+  &lt;br /&gt;
+  &lt;/body&gt;
+&lt;/html&gt;

Added: trunk/root/static/magic/src/widget/validate.js
===================================================================
--- trunk/root/static/magic/src/widget/validate.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/validate.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,858 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.validate&quot;);
+
+dojo.provide(&quot;dojo.widget.validate.Textbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.ValidationTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.IntegerTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.RealNumberTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.CurrencyTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.IpAddressTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.UrlTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.EmailTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.EmailListTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.DateTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.TimeTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.UsStateTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.UsZipTextbox&quot;);
+dojo.provide(&quot;dojo.widget.validate.UsPhoneNumberTextbox&quot;);
+
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.Manager&quot;);
+dojo.require(&quot;dojo.widget.Parse&quot;);
+dojo.require(&quot;dojo.xml.Parse&quot;);
+dojo.require(&quot;dojo.lang&quot;);
+
+dojo.require(&quot;dojo.validate.common&quot;);
+dojo.require(&quot;dojo.validate.datetime&quot;);
+dojo.require(&quot;dojo.validate.check&quot;);
+dojo.require(&quot;dojo.validate.web&quot;);
+dojo.require(&quot;dojo.validate.us&quot;);
+
+dojo.widget.manager.registerWidgetPackage(&quot;dojo.widget.validate&quot;);
+
+
+/*
+  ****** Textbox ******
+
+  This widget is a generic textbox field.
+  Serves as a base class to derive more specialized functionality in subclasses.
+  Has the following properties that can be specified as attributes in the markup.
+
+  @attr id         The textbox id attribute.
+  @attr className  The textbox class attribute.
+  @attr name       The textbox name attribute.
+  @attr value      The textbox value attribute.
+  @attr trim       Removes leading and trailing whitespace if true.  Default is false.
+  @attr uppercase  Converts all characters to uppercase if true.  Default is false.
+  @attr lowercase  Converts all characters to lowercase if true.  Default is false.
+  @attr ucFirst    Converts the first character of each word to uppercase if true.
+  @attr lowercase  Removes all characters that are not digits if true.  Default is false.
+*/
+dojo.widget.validate.Textbox = function() {  }
+
+dojo.inherits(dojo.widget.validate.Textbox, dojo.widget.HtmlWidget);
+
+dojo.lang.extend(dojo.widget.validate.Textbox, {
+	// default values for new subclass properties
+	widgetId: &quot;&quot;, 
+	widgetType: &quot;Textbox&quot;, 
+	id: &quot;&quot;,
+	className: &quot;&quot;,
+	name: &quot;&quot;,
+	value: &quot;&quot;,
+	trim: false,
+	uppercase: false,
+	lowercase: false,
+	ucFirst: false,
+	digit: false,
+	htmlfloat: &quot;none&quot;,
+	
+	templateString: &quot;&lt;span style='float:${this.htmlfloat};'&gt;&lt;input dojoAttachPoint='textbox' dojoAttachEvent='onblur;onfocus'&quot;
+					+ &quot; id='${this.widgetId}' name='${this.name}' &quot;
+					+ &quot; value='${this.value}' class='${this.className}'&gt;&lt;/input&gt;&lt;/span&gt;&quot;,
+
+	// our DOM nodes
+	textbox: null,
+
+	// Apply various filters to textbox value
+	filter: function() { 
+		if (this.trim) {
+			this.textbox.value = this.textbox.value.replace(/(^\s*|\s*$)/g, &quot;&quot;);
+		} 
+		if (this.uppercase) {
+			this.textbox.value = this.textbox.value.toUpperCase();
+		} 
+		if (this.lowercase) {
+			this.textbox.value = this.textbox.value.toLowerCase();
+		} 
+		if (this.ucFirst) {
+			this.textbox.value = this.textbox.value.replace(/\b\w+\b/g, 
+				function(word) { return word.substring(0,1).toUpperCase() + word.substring(1).toLowerCase(); });
+		} 
+		if (this.digit) {
+			this.textbox.value = this.textbox.value.replace(/\D/g, &quot;&quot;);
+		} 
+	},
+
+	// event handlers, you can over-ride these in your own subclasses
+	onfocus: function() {},
+	onblur: function() { this.filter(); },
+
+	// All functions below are called by create from dojo.widget.Widget
+	mixInProperties: function(localProperties, frag) {
+		dojo.widget.validate.Textbox.superclass.mixInProperties.apply(this, arguments);
+		if ( localProperties[&quot;class&quot;] ) { 
+			this.className = localProperties[&quot;class&quot;];
+		}
+	},
+
+	fillInTemplate: function() {
+		// apply any filters to initial value
+		this.filter();
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:Textbox&quot;);
+
+
+/*
+  ****** ValidationTextbox ******
+
+  A subclass of Textbox.
+  Over-ride isValid in subclasses to perform specific kinds of validation.
+  Has several new properties that can be specified as attributes in the markup.
+
+	@attr type          		Basic input tag type declaration.
+	@attr size          		Basic input tag size declaration.
+	@attr type          		Basic input tag maxlength declaration.	
+  @attr required          Can be true or false, default is false.
+  @attr validColor        The color textbox is highlighted for valid input. Default is #cfc.
+  @attr invalidColor      The color textbox is highlighted for invalid input. Default is #fcc.
+  @attr invalidClass			Class used to format displayed text in page if necessary to override default class
+  @attr invalidMessage    The message to display if value is invalid.
+  @attr missingMessage    The message to display if value is missing.
+  @attr missingClass		  Override default class used for missing input data
+  @attr listenOnKeyPress  Updates messages on each key press.  Default is true.
+  @attr promptMessage			Will not issue invalid message if field is populated with default user-prompt text
+*/
+dojo.widget.validate.ValidationTextbox = function() {}
+
+dojo.inherits(dojo.widget.validate.ValidationTextbox, dojo.widget.validate.Textbox);
+
+dojo.lang.extend(dojo.widget.validate.ValidationTextbox, {
+	// default values for new subclass properties
+	widgetType: &quot;ValidationTextbox&quot;, 
+	type: &quot;&quot;,
+	required: false,
+	validColor: &quot;#cfc&quot;,
+	invalidColor: &quot;#fcc&quot;,
+	rangeClass: &quot;range&quot;,
+	invalidClass: &quot;invalid&quot;,
+	missingClass: &quot;missing&quot;,
+	size: &quot;&quot;,
+	maxlength: &quot;&quot;,
+	promptMessage: &quot;&quot;,
+	invalidMessage: &quot;* The value entered is not valid.&quot;,
+	missingMessage: &quot;* This value is required.&quot;,
+	rangeMessage: &quot;* This value out of range.&quot;,
+	listenOnKeyPress: true,
+	htmlfloat: &quot;none&quot;,
+	lastCheckedValue: null,
+
+	templateString:   &quot;&lt;span style='float:${this.htmlfloat};'&gt;&quot;
+					+   &quot;&lt;input dojoAttachPoint='textbox' type='${this.type}' dojoAttachEvent='onblur;onfocus;onkeyup'&quot;
+					+     &quot; id='${this.widgetId}' name='${this.name}' size='${this.size}' maxlength='${this.maxlength}'&quot;
+					+     &quot; value='${this.value}' class='${this.className}' style=''&gt;&lt;/input&gt;&quot;
+					+   &quot;&lt;span dojoAttachPoint='invalidSpan' class='${this.invalidClass}'&gt;${this.invalidMessage}&lt;/span&gt;&quot;
+					+   &quot;&lt;span dojoAttachPoint='missingSpan' class='${this.missingClass}'&gt;${this.missingMessage}&lt;/span&gt;&quot;
+					+   &quot;&lt;span dojoAttachPoint='rangeSpan' class='${this.rangeClass}'&gt;${this.rangeMessage}&lt;/span&gt;&quot;
+					+ &quot;&lt;/span&gt;&quot;,
+
+	// new DOM nodes
+	invalidSpan: null,
+	missingSpan: null,
+	rangeSpan: null,
+
+	getValue: function() {
+		return this.textbox.value;
+	},
+
+	setValue: function(value) {
+		this.textbox.value = value;
+		this.update();
+	},
+
+	// Need to over-ride with your own validation code in subclasses
+	isValid: function() { return true; },
+
+	// Need to over-ride with your own validation code in subclasses
+	isInRange: function() { return true; },
+
+	// Returns true if value is all whitespace
+	isEmpty: function() { 
+		return ( /^\s*$/.test(this.textbox.value) );
+	},
+
+	// Returns true if value is required and it is all whitespace.
+	isMissing: function() { 
+		return ( this.required &amp;&amp; this.isEmpty() );
+	},
+
+	// Called oninit, onblur, and onkeypress.
+	// Show missing or invalid messages if appropriate, and highlight textbox field.
+	update: function() {
+		this.lastCheckedValue = this.textbox.value;
+		this.missingSpan.style.display = &quot;none&quot;;
+		this.invalidSpan.style.display = &quot;none&quot;;
+		this.rangeSpan.style.display = &quot;none&quot;;
+
+		var empty = this.isEmpty();
+		var valid = true;
+		if(this.promptMessage != this.textbox.value){ 
+			valid = this.isValid(); 
+		}
+		var missing = this.isMissing();
+
+		// Display at most one error message
+		if(missing){
+			this.missingSpan.style.display = &quot;&quot;;
+		}else if( !empty &amp;&amp; !valid ){
+			this.invalidSpan.style.display = &quot;&quot;;
+		}else if( !empty &amp;&amp; !this.isInRange() ){
+			this.rangeSpan.style.display = &quot;&quot;;
+		}
+		this.highlight();
+	},
+
+	// Called oninit, and onblur.
+	highlight: function() {
+		// highlight textbox background 
+		if ( this.isEmpty() ) {
+			this.textbox.style.backgroundColor = &quot;&quot;;
+		}else if ( this.isValid() &amp;&amp; this.isInRange() ){
+			this.textbox.style.backgroundColor = this.validColor;
+		}else if( this.textbox.value != this.promptMessage){ 
+			this.textbox.style.backgroundColor = this.invalidColor;
+		}
+	},
+
+	onfocus: function() {
+		if ( !this.listenOnKeyPress) {
+		    this.textbox.style.backgroundColor = &quot;&quot;;
+		}
+	},
+
+	onblur: function() { 
+		this.filter();
+		this.update(); 
+	},
+
+	onkeyup: function(){ 
+		if(this.listenOnKeyPress){ 
+			//this.filter();  trim is problem if you have to type two words
+			this.update(); 
+		}else if (this.textbox.value != this.lastCheckedValue){
+		    this.textbox.style.backgroundColor = &quot;&quot;;
+		}
+	},
+
+	// FIXME: why are there to fillInTemplate methods defined here?
+	fillInTemplate: function() {
+		// Attach isMissing and isValid methods to the textbox.
+		// We may use them later in connection with a submit button widget.
+		// TODO: this is unorthodox; it seems better to do it another way -- Bill
+		this.textbox.isValid = function() { this.isValid.call(this); };
+		this.textbox.isMissing = function() { this.isMissing.call(this); };
+		this.textbox.isInRange = function() { this.isInRange.call(this); };
+		this.filter();
+		this.update(); 
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:ValidationTextbox&quot;);
+
+
+/*
+  ****** IntegerTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid/isInRange to test for integer input.
+  Has 4 new properties that can be specified as attributes in the markup.
+
+  @attr signed     The leading plus-or-minus sign. Can be true or false, default is either.
+  @attr separator  The character used as the thousands separator.  Default is no separator.
+  @attr min  Minimum signed value.  Default is -Infinity
+  @attr max  Maximum signed value.  Default is +Infinity
+*/
+dojo.widget.validate.IntegerTextbox = function(node) {
+	// this property isn't a primitive and needs to be created on a per-item basis.
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.IntegerTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.IntegerTextbox, {
+	// new subclass properties
+	widgetType: &quot;IntegerTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.IntegerTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if((localProperties.signed == &quot;true&quot;)||
+			(localProperties.signed == &quot;always&quot;)){
+			this.flags.signed = true;
+		}else if((localProperties.signed == &quot;false&quot;)||
+				(localProperties.signed == &quot;never&quot;)){
+			this.flags.signed = false;
+			this.flags.min = 0;
+		}else{
+			this.flags.signed = [ true, false ]; // optional
+		}
+		if(localProperties.separator){ 
+			this.flags.separator = localProperties.separator;
+		}
+		if(localProperties.min){ 
+			this.flags.min = parseInt(localProperties.min);
+		}
+		if(localProperties.max){ 
+			this.flags.max = parseInt(localProperties.max);
+		}
+	},
+
+	// Over-ride for integer validation
+	isValid: function() { 
+		return dojo.validate.isInteger(this.textbox.value, this.flags);
+	},
+	isInRange: function() { 
+		return dojo.validate.isInRange(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:IntegerTextbox&quot;);
+
+
+/*
+  ****** RealNumberTextbox ******
+
+  A subclass that extends IntegerTextbox.
+  Over-rides isValid/isInRange to test for real number input.
+  Has 5 new properties that can be specified as attributes in the markup.
+
+  @attr places    The exact number of decimal places.  If omitted, it's unlimited and optional.
+  @attr exponent  Can be true or false.  If omitted the exponential part is optional.
+  @attr eSigned   Is the exponent signed?  Can be true or false, if omitted the sign is optional.
+  @attr min  Minimum signed value.  Default is -Infinity
+  @attr max  Maximum signed value.  Default is +Infinity
+*/
+dojo.widget.validate.RealNumberTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.RealNumberTextbox, dojo.widget.validate.IntegerTextbox);
+
+dojo.lang.extend(dojo.widget.validate.RealNumberTextbox, {
+	// new subclass properties
+	widgetType: &quot;RealNumberTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.RealNumberTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.places ) { 
+			this.flags.places = Number( localProperties.places );
+		}
+		if((localProperties.exponent == &quot;true&quot;)||
+			(localProperties.exponent == &quot;always&quot;)){
+			this.flags.exponent = true;
+		}else if((localProperties.exponent == &quot;false&quot;)||(localProperties.exponent == &quot;never&quot;)){
+			this.flags.exponent = false;
+		}else{
+			this.flags.exponent = [ true, false ]; // optional
+		}
+		if((localProperties.esigned == &quot;true&quot;)||(localProperties.esigned == &quot;always&quot;)){
+			this.flags.eSigned = true;
+		}else if((localProperties.esigned == &quot;false&quot;)||(localProperties.esigned == &quot;never&quot;)){
+			this.flags.eSigned = false;
+		}else{
+			this.flags.eSigned = [ true, false ]; // optional
+		}
+		if(localProperties.min){ 
+			this.flags.min = parseFloat(localProperties.min);
+		}
+		if(localProperties.max){ 
+			this.flags.max = parseFloat(localProperties.max);
+		}
+	},
+
+	// Over-ride for real number validation
+	isValid: function() { 
+		return dojo.validate.isRealNumber(this.textbox.value, this.flags);
+	},
+	isInRange: function() { 
+		return dojo.validate.isInRange(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:RealNumberTextbox&quot;);
+
+
+/*
+  ****** CurrencyTextbox ******
+
+  A subclass that extends IntegerTextbox.
+  Over-rides isValid/isInRange to test if input denotes a monetary value .
+  Has 5 new properties that can be specified as attributes in the markup.
+
+  @attr cents      The two decimal places for cents.  Can be true or false, optional if omitted.
+  @attr symbol     A currency symbol such as Yen &quot;???&quot;, Pound &quot;???&quot;, or the Euro &quot;???&quot;. Default is &quot;$&quot;.
+  @attr separator  Default is &quot;,&quot; instead of no separator as in IntegerTextbox.
+  @attr min  Minimum signed value.  Default is -Infinity
+  @attr max  Maximum signed value.  Default is +Infinity
+*/
+dojo.widget.validate.CurrencyTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.CurrencyTextbox, dojo.widget.validate.IntegerTextbox);
+
+dojo.lang.extend(dojo.widget.validate.CurrencyTextbox, {
+	// new subclass properties
+	widgetType: &quot;CurrencyTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.CurrencyTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.cents ) { 
+			this.flags.cents = ( localProperties.cents == &quot;true&quot; );
+		}
+		if ( localProperties.symbol ) { 
+			this.flags.symbol = localProperties.symbol;
+		}
+		if(localProperties.min){ 
+			this.flags.min = parseFloat(localProperties.min);
+		}
+		if(localProperties.max){ 
+			this.flags.max = parseFloat(localProperties.max);
+		}
+	},
+
+	// Over-ride for currency validation
+	isValid: function() { 
+		return dojo.validate.isCurrency(this.textbox.value, this.flags);
+	},
+	isInRange: function() { 
+		return dojo.validate.isInRange(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:CurrencyTextbox&quot;);
+
+
+/*
+  ****** IpAddressTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test for IP addresses.
+  Can specify formats for ipv4 or ipv6 as attributes in the markup.
+
+  @attr allowDottedDecimal  true or false, default is true.
+  @attr allowDottedHex      true or false, default is true.
+  @attr allowDottedOctal    true or false, default is true.
+  @attr allowDecimal        true or false, default is true.
+  @attr allowHex            true or false, default is true.
+  @attr allowIPv6           true or false, default is true.
+  @attr allowHybrid         true or false, default is true.
+*/
+dojo.widget.validate.IpAddressTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.IpAddressTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.IpAddressTextbox, {
+	// new subclass properties
+	widgetType: &quot;IpAddressTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.IpAddressTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.allowdotteddecimal ) { 
+			this.flags.allowDottedDecimal = ( localProperties.allowdotteddecimal == &quot;true&quot; );
+		}
+		if ( localProperties.allowdottedhex ) { 
+			this.flags.allowDottedHex = ( localProperties.allowdottedhex == &quot;true&quot; );
+		}
+		if ( localProperties.allowdottedoctal ) { 
+			this.flags.allowDottedOctal = ( localProperties.allowdottedoctal == &quot;true&quot; );
+		}
+		if ( localProperties.allowdecimal ) { 
+			this.flags.allowDecimal = ( localProperties.allowdecimal == &quot;true&quot; );
+		}
+		if ( localProperties.allowhex ) { 
+			this.flags.allowHex = ( localProperties.allowhex == &quot;true&quot; );
+		}
+		if ( localProperties.allowipv6 ) { 
+			this.flags.allowIPv6 = ( localProperties.allowipv6 == &quot;true&quot; );
+		}
+		if ( localProperties.allowhybrid ) { 
+			this.flags.allowHybrid = ( localProperties.allowhybrid == &quot;true&quot; );
+		}
+	},
+
+	// Over-ride for IP address validation
+	isValid: function() { 
+		return dojo.validate.isIpAddress(this.textbox.value, this.flags);
+	}
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:IpAddressTextbox&quot;);
+
+
+/*
+  ****** UrlTextbox ******
+
+  A subclass of IpAddressTextbox.
+  Over-rides isValid to test for URL's.
+  Can specify 5 additional attributes in the markup.
+
+  @attr scheme        Can be true or false.  If omitted the scheme is optional.
+  @attr allowIP       Allow an IP address for hostname.  Default is true.
+  @attr allowLocal    Allow the host to be &quot;localhost&quot;.  Default is false.
+  @attr allowCC       Allow 2 letter country code domains.  Default is true.
+  @attr allowGeneric  Allow generic domains.  Can be true or false, default is true.
+*/
+dojo.widget.validate.UrlTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.UrlTextbox, dojo.widget.validate.IpAddressTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UrlTextbox, {
+	// new subclass properties
+	widgetType: &quot;UrlTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.UrlTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.scheme ) { 
+			this.flags.scheme = ( localProperties.scheme == &quot;true&quot; );
+		}
+		if ( localProperties.allowip ) { 
+			this.flags.allowIP = ( localProperties.allowip == &quot;true&quot; );
+		}
+		if ( localProperties.allowlocal ) { 
+			this.flags.allowLocal = ( localProperties.allowlocal == &quot;true&quot; );
+		}
+		if ( localProperties.allowcc ) { 
+			this.flags.allowCC = ( localProperties.allowcc == &quot;true&quot; );
+		}
+		if ( localProperties.allowgeneric ) { 
+			this.flags.allowGeneric = ( localProperties.allowgeneric == &quot;true&quot; );
+		}
+	},
+
+	// Over-ride for URL validation
+	isValid: function() { 
+		return dojo.validate.isUrl(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:UrlTextbox&quot;);
+
+
+/*
+  ****** EmailTextbox ******
+
+  A subclass of UrlTextbox.
+  Over-rides isValid to test for email addresses.
+  Can use all markup attributes/properties of UrlTextbox except scheme.
+  One new attribute available in the markup.
+
+  @attr allowCruft  Allow address like &lt;mailto:<A HREF="https://lists.berlios.de/mailman/listinfo/parley-svn">foo at yahoo.com</A>&gt;.  Default is false.
+*/
+dojo.widget.validate.EmailTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.EmailTextbox, dojo.widget.validate.UrlTextbox);
+
+dojo.lang.extend(dojo.widget.validate.EmailTextbox, {
+	// new subclass properties
+	widgetType: &quot;EmailTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.EmailTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.allowcruft ) { 
+			this.flags.allowCruft = ( localProperties.allowcruft == &quot;true&quot; );
+		}
+	},
+
+	// Over-ride for email address validation
+	isValid: function() { 
+		return dojo.validate.isEmailAddress(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:EmailTextbox&quot;);
+
+
+/*
+  ****** EmailListTextbox ******
+
+  A subclass of EmailTextbox.
+  Over-rides isValid to test for a list of email addresses.
+  Can use all markup attributes/properties of EmailTextbox and ...
+
+  @attr listSeparator  The character used to separate email addresses.  
+    Default is &quot;;&quot;, &quot;,&quot;, &quot;\n&quot; or &quot; &quot;.
+*/
+dojo.widget.validate.EmailListTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.EmailListTextbox, dojo.widget.validate.EmailTextbox);
+
+dojo.lang.extend(dojo.widget.validate.EmailListTextbox, {
+	// new subclass properties
+	widgetType: &quot;EmailListTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.EmailListTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.listseparator ) { 
+			this.flags.listSeparator = localProperties.listseparator;
+		}
+	},
+
+	// Over-ride for email address list validation
+	isValid: function() { 
+		return dojo.validate.isEmailAddressList(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:EmailListTextbox&quot;);
+
+
+/*
+  ****** DateTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is in a valid date format.
+
+  @attr format  Described in dojo.validate.js.  Default is  &quot;MM/DD/YYYY&quot;.
+*/
+dojo.widget.validate.DateTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.DateTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.DateTextbox, {
+	// new subclass properties
+	widgetType: &quot;DateTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.DateTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.format ) { 
+			this.flags.format = localProperties.format;
+		}
+	},
+
+	// Over-ride for date validation
+	isValid: function() { 
+		return dojo.validate.isValidDate(this.textbox.value, this.flags.format);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:DateTextbox&quot;);
+
+
+/*
+  ****** TimeTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is in a valid time format.
+
+  @attr format    Described in dojo.validate.js.  Default is  &quot;h:mm:ss t&quot;.
+  @attr amSymbol  The symbol used for AM.  Default is &quot;AM&quot; or &quot;am&quot;.
+  @attr pmSymbol  The symbol used for PM.  Default is &quot;PM&quot; or &quot;pm&quot;.
+*/
+dojo.widget.validate.TimeTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.TimeTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.TimeTextbox, {
+	// new subclass properties
+	widgetType: &quot;TimeTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// First initialize properties in super-class.
+		dojo.widget.validate.TimeTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.format ) { 
+			this.flags.format = localProperties.format;
+		}
+		if ( localProperties.amsymbol ) { 
+			this.flags.amSymbol = localProperties.amsymbol;
+		}
+		if ( localProperties.pmsymbol ) { 
+			this.flags.pmSymbol = localProperties.pmsymbol;
+		}
+	},
+
+	// Over-ride for time validation
+	isValid: function() { 
+		return dojo.validate.isValidTime(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:TimeTextbox&quot;);
+
+
+/*
+  ****** UsStateTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a US state abbr.
+
+  @attr allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
+  @attr allowMilitary     Allow military 'states', e.g. Armed Forces Europe (AE). Default is true.
+*/
+dojo.widget.validate.UsStateTextbox = function(node) {
+	this.flags = {};
+}
+
+dojo.inherits(dojo.widget.validate.UsStateTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsStateTextbox, {
+	// new subclass properties
+	widgetType: &quot;UsStateTextbox&quot;, 
+
+	mixInProperties: function(localProperties, frag) {
+		// Initialize properties in super-class.
+		dojo.widget.validate.UsStateTextbox.superclass.mixInProperties.apply(this, arguments);
+
+		// Get properties from markup attibutes, and assign to flags object.
+		if ( localProperties.allowterritories ) { 
+			this.flags.allowTerritories = ( localProperties.allowterritories == &quot;true&quot; );
+		}
+		if ( localProperties.allowmilitary ) { 
+			this.flags.allowMilitary = ( localProperties.allowmilitary == &quot;true&quot; );
+		}
+	},
+
+	isValid: function() { 
+		return dojo.validate.us.isState(this.textbox.value, this.flags);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:UsStateTextbox&quot;);
+
+
+/*
+  ****** UsZipTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a US zip code.
+  Validates zip-5 and zip-5 plus 4.
+*/
+dojo.widget.validate.UsZipTextbox = function(node) {}
+
+dojo.inherits(dojo.widget.validate.UsZipTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsZipTextbox, {
+	// new subclass properties
+	widgetType: &quot;UsZipTextbox&quot;, 
+
+	isValid: function() { 
+		return dojo.validate.us.isZipCode(this.textbox.value);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:UsZipTextbox&quot;);
+
+
+/*
+  ****** UsSocialSecurityNumberTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a US Social Security Number.
+*/
+dojo.widget.validate.UsSocialSecurityNumberTextbox = function(node) {}
+
+dojo.inherits(dojo.widget.validate.UsSocialSecurityNumberTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsSocialSecurityNumberTextbox, {
+	// new subclass properties
+	widgetType: &quot;UsSocialSecurityNumberTextbox&quot;, 
+
+	isValid: function() { 
+		return dojo.validate.us.isSocialSecurityNumber(this.textbox.value);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:UsSocialSecurityNumberTextbox&quot;);
+
+
+/*
+  ****** UsPhoneNumberTextbox ******
+
+  A subclass of ValidationTextbox.
+  Over-rides isValid to test if input is a 10-digit US phone number, an extension is optional.
+*/
+dojo.widget.validate.UsPhoneNumberTextbox = function(node) {}
+
+dojo.inherits(dojo.widget.validate.UsPhoneNumberTextbox, dojo.widget.validate.ValidationTextbox);
+
+dojo.lang.extend(dojo.widget.validate.UsPhoneNumberTextbox, {
+	// new subclass properties
+	widgetType: &quot;UsPhoneNumberTextbox&quot;, 
+
+	isValid: function() { 
+		return dojo.validate.us.isPhoneNumber(this.textbox.value);
+	}
+
+});
+
+dojo.widget.tags.addParseTreeHandler(&quot;dojo:UsPhoneNumberTextbox&quot;);

Added: trunk/root/static/magic/src/widget/vml/Chart.js
===================================================================
--- trunk/root/static/magic/src/widget/vml/Chart.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/widget/vml/Chart.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,426 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.widget.vml.Chart&quot;);
+
+dojo.require(&quot;dojo.widget.HtmlWidget&quot;);
+dojo.require(&quot;dojo.widget.Chart&quot;);
+dojo.require(&quot;dojo.math&quot;);
+dojo.require(&quot;dojo.html&quot;);
+//dojo.require(&quot;dojo.vml&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+
+dojo.widget.vml.Chart=function(){
+	dojo.widget.Chart.call(this);
+	dojo.widget.HtmlWidget.call(this);
+};
+dojo.inherits(dojo.widget.vml.Chart, dojo.widget.HtmlWidget);
+dojo.lang.extend(dojo.widget.vml.Chart, {
+	//	widget props
+	templatePath:null,
+	templateCssPath:null,
+
+	//	state
+	_isInitialized:false,
+	hasData:false,
+
+	//	chart props
+	vectorNode:null,
+	plotArea:null,
+	dataGroup:null,
+	axisGroup:null,
+
+	properties:{
+		height:400,	//	defaults, will resize to the domNode.
+		width:600,
+		plotType:null,
+		padding:{
+			top:10,
+			bottom:2,
+			left:60,
+			right:30
+		},
+		axes:{
+			x:{
+				plotAt:0,
+				label:&quot;&quot;,
+				unitLabel:&quot;&quot;,
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
+			},
+			y:{
+				plotAt:0,
+				label:&quot;&quot;,
+				unitLabel:&quot;&quot;,
+				unitType:Number,
+				nUnitsToShow:10,
+				range:{
+					min:0,
+					max:200
+				}
+			}
+		}
+	},
+	
+	fillInTemplate:function(args,frag){
+		this.initialize();
+		this.render();
+	},
+	parseData:function(){
+	},
+	initialize:function(){
+		//	parse the data first.
+		this.parseData();
+	
+		// render the body of the chart, not the chart data.
+		if(this.vectorNode){ this.destroy(); }
+		this.vectorNode=document.createElement(&quot;div&quot;);
+		this.vectorNode.style.width=this.properties.width+&quot;px&quot;;
+		this.vectorNode.style.height=this.properties.height+&quot;px&quot;;
+		this.vectorNode.style.position=&quot;relative&quot;;
+		this.domNode.appendChild(this.vectorNode);
+
+		var plotWidth=this.properties.width-this.properties.padding.left-this.properties.padding.right;
+		var plotHeight=this.properties.height-this.properties.padding.top-this.properties.padding.bottom;
+
+		this.plotArea=document.createElement(&quot;div&quot;);
+		this.plotArea.style.position=&quot;absolute&quot;;
+		this.plotArea.style.backgroundColor=&quot;#fff&quot;;
+		this.plotArea.style.top=(this.properties.padding.top)-2+&quot;px&quot;;
+		this.plotArea.style.left=(this.properties.padding.left-1)+&quot;px&quot;;
+		this.plotArea.style.width=plotWidth+&quot;px&quot;;
+		this.plotArea.style.height=plotHeight+&quot;px&quot;;
+		this.vectorNode.appendChild(this.plotArea);
+		
+		this.dataGroup=document.createElement(&quot;div&quot;);
+		this.dataGroup.style.position=&quot;relative&quot;;
+		this.plotArea.appendChild(this.dataGroup);
+
+		//	clipping rects, what a fucking pain.
+		var bg=this.domNode.style.backgroundColor;
+		var r=document.createElement(&quot;v:rect&quot;);
+		r.setAttribute(&quot;fillcolor&quot;, bg);
+		r.setAttribute(&quot;stroked&quot;, &quot;false&quot;);
+		r.style.position=&quot;absolute&quot;;
+		r.style.top=(-1*this.properties.padding.top)-1+&quot;px&quot;;
+		r.style.left=(-1*this.properties.padding.left)+&quot;px&quot;;
+		r.style.width=(this.properties.width-3)+&quot;px&quot;;
+		r.style.height=(this.properties.padding.top)-2+&quot;px&quot;;
+		this.vectorNode.appendChild(r);
+
+		r=document.createElement(&quot;v:rect&quot;);
+		r.setAttribute(&quot;fillcolor&quot;, bg);
+		r.setAttribute(&quot;stroked&quot;, &quot;false&quot;);
+		r.style.position=&quot;absolute&quot;;
+		r.style.top=plotHeight-2+&quot;px&quot;;
+		r.style.left=(-1*this.properties.padding.left)+&quot;px&quot;;
+		r.style.width=(this.properties.width-3)+&quot;px&quot;;
+		r.style.height=(this.properties.padding.bottom)-2+&quot;px&quot;; // fixme: check this.
+		this.vectorNode.appendChild(r);
+
+		r=document.createElement(&quot;v:rect&quot;);
+		r.setAttribute(&quot;fillcolor&quot;, bg);
+		r.setAttribute(&quot;stroked&quot;, &quot;false&quot;);
+		r.style.position=&quot;absolute&quot;;
+		r.style.top=&quot;-2px&quot;;
+		r.style.left=(-1*this.properties.padding.left)+&quot;px&quot;;
+		r.style.width=(this.properties.padding.left-1)+&quot;px&quot;;
+		r.style.height=plotHeight+&quot;px&quot;;
+		this.vectorNode.appendChild(r);
+		
+		r=document.createElement(&quot;v:rect&quot;);
+		r.setAttribute(&quot;fillcolor&quot;, bg);
+		r.setAttribute(&quot;stroked&quot;, &quot;false&quot;);
+		r.style.position=&quot;absolute&quot;;
+		r.style.top=&quot;-2px&quot;;
+		r.style.right=(-1*this.properties.padding.right)+1+&quot;px&quot;;
+		r.style.width=(this.properties.padding.right-1)+&quot;px&quot;;
+		r.style.height=plotHeight+&quot;px&quot;;
+		this.vectorNode.appendChild(r);
+		//	end clipping rects.  god that sucks, i wish VML had clipping outside of that crap vmlframe...
+
+		this.axisGroup=document.createElement(&quot;div&quot;);
+		this.axisGroup.style.position=&quot;relative&quot;;
+		this.plotArea.appendChild(this.axisGroup);
+
+		var stroke=1;
+
+		//	x axis
+		var line=document.createElement(&quot;v:line&quot;);
+		var y=dojo.widget.vml.Chart.Plotter.getY(this.properties.axes.x.plotAt, this);
+		line.setAttribute(&quot;from&quot;, this.properties.padding.left-stroke + &quot;,&quot; + y);
+		line.setAttribute(&quot;to&quot;, plotWidth + &quot;,&quot; + y);
+		line.style.position=&quot;absolute&quot;;
+		line.style.antialias=&quot;false&quot;;
+		line.setAttribute(&quot;strokecolor&quot;, &quot;#666&quot;);
+		line.setAttribute(&quot;strokeweight&quot;, stroke*2+&quot;px&quot;);
+		this.axisGroup.appendChild(line);
+
+		//	y axis
+		var line=document.createElement(&quot;v:line&quot;);
+		var y=dojo.widget.vml.Chart.Plotter.getX(this.properties.axes.y.plotAt, this);
+		line.setAttribute(&quot;from&quot;, y+&quot;,&quot;+this.properties.padding.top);
+		line.setAttribute(&quot;to&quot;, y+&quot;,&quot;+this.properties.height-this.properties.padding.bottom);
+		line.style.position=&quot;absolute&quot;;
+		line.style.antialias=&quot;false&quot;;
+		line.setAttribute(&quot;strokecolor&quot;, &quot;#666&quot;);
+		line.setAttribute(&quot;strokeweight&quot;, stroke*2+&quot;px&quot;);
+		this.axisGroup.appendChild(line);
+		
+		//	labels
+		var size=10;
+
+		//	x axis labels.
+		var t=document.createElement(&quot;div&quot;);
+		t.style.position=&quot;absolute&quot;;
+		t.style.top=(this.properties.height-this.properties.padding.bottom+size+2)+&quot;px&quot;;
+		t.style.left=this.properties.padding.left+&quot;px&quot;;
+		t.style.fontFamily=&quot;sans-serif&quot;;
+		t.style.fontSize=size+&quot;px&quot;;
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.x.range.min),2);
+		this.axisGroup.appendChild(t);
+
+		t=document.createElement(&quot;div&quot;);
+		t.style.position=&quot;absolute&quot;;
+		t.style.top=(this.properties.height-this.properties.padding.bottom+size+2)+&quot;px&quot;;
+		t.style.left=(this.properties.width-this.properties.padding.right-(size/2))+&quot;px&quot;;
+		t.style.fontFamily=&quot;sans-serif&quot;;
+		t.style.fontSize=size+&quot;px&quot;;
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.x.range.max),2);
+		this.axisGroup.appendChild(t);
+
+		//	y axis labels.
+		t=document.createElement(&quot;div&quot;);
+		t.style.position=&quot;absolute&quot;;
+		t.style.top=-1*(size/2)+&quot;px&quot;;
+		t.style.right=(plotWidth+4)+&quot;px&quot;;
+		t.style.fontFamily=&quot;sans-serif&quot;;
+		t.style.fontSize=size+&quot;px&quot;;
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.y.range.max),2);
+		this.axisGroup.appendChild(t);
+		
+		t=document.createElement(&quot;div&quot;);
+		t.style.position=&quot;absolute&quot;;
+		t.style.top=(this.properties.height-this.properties.padding.bottom)+&quot;px&quot;;
+		t.style.right=(plotWidth+4)+&quot;px&quot;;
+		t.style.fontFamily=&quot;sans-serif&quot;;
+		t.style.fontSize=size+&quot;px&quot;;
+		t.innerHTML=dojo.math.round(parseFloat(this.properties.axes.y.range.min),2);
+		this.axisGroup.appendChild(t);
+		
+		//	this is last.
+		this.assignColors();
+		this._isInitialized=true;
+	},
+	destroy:function(){
+		while(this.domNode.childNodes.length&gt;0){
+			this.domNode.removeChild(this.domNode.childNodes[0]);
+		}
+		this.vectorNode=this.plotArea=this.dataGroup=this.axisGroup=null;
+	},
+	render:function(){
+		if (this.dataGroup){
+			while(this.dataGroup.childNodes.length&gt;0){
+				this.dataGroup.removeChild(this.dataGroup.childNodes[0]);
+			}
+		} else {
+			this.initialize();
+		}
+		for(var i=0; i&lt;this.series.length; i++){
+			dojo.widget.vml.Chart.Plotter.plot(this.series[i], this);
+		}
+	}
+});
+
+dojo.widget.vml.Chart.Plotter=new function(){
+	var _this=this;
+	var plotters = {};
+	var types=dojo.widget.Chart.PlotTypes;
+	
+	this.getX=function(value, chart){
+		var v=parseFloat(value);
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+		min+=ofst; max+=ofst; v+=ofst;
+
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var x=(v*((xmax-xmin)/max))+xmin;
+		return x;
+	};
+	this.getY=function(value, chart){
+		var v=parseFloat(value);
+		var max=chart.properties.axes.y.range.max;
+		var min=chart.properties.axes.y.range.min;
+		var ofst=0;
+		if(min&lt;0)ofst+=Math.abs(min);
+		min+=ofst; max+=ofst; v+=ofst;
+		
+		var ymin=chart.properties.height-chart.properties.padding.bottom;
+		var ymax=chart.properties.padding.top;
+		var y=(((ymin-ymax)/(max-min))*(max-v))+ymax;
+		return y;
+	};
+
+	this.addPlotter=function(name, func){
+		plotters[name]=func;
+	};
+	this.plot=function(series, chart){
+		if (series.values.length==0) return;
+		if (series.plotType &amp;&amp; plotters[series.plotType]){
+			return plotters[series.plotType](series, chart);
+		}
+		else if (chart.plotType &amp;&amp; plotters[chart.plotType]){
+			return plotters[chart.plotType](series, chart);
+		}
+	};
+
+	//	plotting
+	plotters[types.Bar]=function(series, chart){
+		var space=1;
+		var lastW = 0;
+		for (var i=0; i&lt;series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var w;
+			if (i==series.values.length-1){
+				w=lastW;
+			} else{
+				w=_this.getX(series.values[i+1].x, chart)-x-space;
+				lastW=w;
+			}
+			x-=(w/2);
+
+			var yA=_this.getY(chart.properties.axes.x.plotAt, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var h=Math.abs(yA-y);
+			if (parseFloat(series.values[i].value)&lt;chart.properties.axes.x.plotAt){
+				var oy=yA;
+				yA=y;
+				y=oy;
+			}
+
+			var bar=document.createElement(&quot;v:rect&quot;);
+			bar.style.position=&quot;absolute&quot;;
+			bar.style.top=x+&quot;px&quot;;
+			bar.style.left=y+&quot;px&quot;;
+			bar.style.width=w+&quot;px&quot;;
+			bar.style.height=h+&quot;px&quot;;
+			bar.setAttribute(&quot;fillColor&quot;, series.color);
+			bar.setAttribute(&quot;title&quot;, series.label + &quot;: &quot; + series.values[i].value);
+			bar.setAttribute(&quot;coordsize&quot;, chart.properties.width + &quot;,&quot; + chart.properties.height);
+			var fill=document.createElement(&quot;v:fill&quot;);
+			fill.setAttribute(&quot;opacity&quot;, &quot;0.9&quot;);
+			bar.appendChild(fill);
+			chart.dataGroup.appendChild(bar);
+		}
+	};	
+	plotters[types.Line]=function(series, chart){
+		var tension=3;
+
+		var line=document.createElement(&quot;v:shape&quot;);
+		line.setAttribute(&quot;strokeweight&quot;, &quot;2px&quot;);
+		line.setAttribute(&quot;strokecolor&quot;, series.color);
+		line.setAttribute(&quot;fillcolor&quot;, &quot;none&quot;);
+		line.setAttribute(&quot;filled&quot;, &quot;false&quot;);
+		line.setAttribute(&quot;title&quot;, series.label);
+		line.setAttribute(&quot;coordsize&quot;, chart.properties.width + &quot;,&quot; + chart.properties.height);
+		line.style.position=&quot;absolute&quot;;
+		line.style.top=&quot;0px&quot;;
+		line.style.left=&quot;0px&quot;;
+		line.style.width= chart.properties.width+&quot;px&quot;;
+		line.style.height=chart.properties.height+&quot;px&quot;;
+		var stroke=document.createElement(&quot;v:stroke&quot;);
+		stroke.setAttribute(&quot;opacity&quot;, &quot;0.85&quot;);
+		line.appendChild(stroke);
+
+		var path = [];
+		for (var i=0; i&lt;series.values.length; i++){
+			var x = _this.getX(series.values[i].x, chart)
+			var y = _this.getY(series.values[i].value, chart);
+
+			if (i==0){
+				path.push(&quot;m&quot;);
+				path.push(x+&quot;,&quot;+y);
+			}else{
+				var lastx=_this.getX(series.values[i-1].x, chart);
+				var lasty=_this.getY(series.values[i-1].value, chart);
+				var dx=x-lastx;
+				
+				path.push(&quot;v&quot;);
+				var cx=x-(tension-1)*(dx/tension);
+				path.push(cx+&quot;,0&quot;);
+				cx=x-(dx/tension);
+				path.push(cx+&quot;,&quot;+y-lasty);
+				path.push(dx, y-lasty);
+			}
+		}
+		line.setAttribute(&quot;path&quot;, path.join(&quot; &quot;)+&quot; e&quot;);
+		chart.dataGroup.appendChild(line);
+	};
+	plotters[types.Scatter]=function(series, chart){
+		var r=8;
+		for (var i=0; i&lt;series.values.length; i++){
+			var x=_this.getX(series.values[i].x, chart);
+			var y=_this.getY(series.values[i].value, chart);
+			var mod=r/2;
+
+			var point=document.createElement(&quot;v:rect&quot;);
+			point.setAttribute(&quot;fillcolor&quot;, series.color);
+			point.setAttribute(&quot;strokecolor&quot;, series.color);
+			point.setAttribute(&quot;title&quot;, series.label + &quot;: &quot; + series.values[i].value);
+			point.style.position=&quot;absolute&quot;;
+			point.style.rotation=&quot;45&quot;;
+			point.style.top=(y-mod)+&quot;px&quot;;
+			point.style.left=(x-mod)+&quot;px&quot;;
+			point.style.width=r+&quot;px&quot;;
+			point.style.height=r+&quot;px&quot;;
+			var fill=document.createElement(&quot;v:fill&quot;);
+			fill.setAttribute(&quot;opacity&quot;, &quot;0.5&quot;);
+			point.appendChild(fill);
+			chart.dataGroup.appendChild(point);
+		}
+	};	
+	plotters[types.Bubble]=function(series, chart){
+		//	added param for series[n].value: size
+		var minR=1;
+		
+		//	do this off the x axis?
+		var min=chart.properties.axes.x.range.min;
+		var max=chart.properties.axes.x.range.max;
+		var ofst=0-min;
+
+		min+=ofst; max+=ofst;
+		var xmin=chart.properties.padding.left;
+		var xmax=chart.properties.width-chart.properties.padding.right;
+		var factor=(max-min)/(xmax-xmin)*25;
+		
+		for (var i=0; i&lt;series.values.length; i++){
+			var size = series.values[i].size;
+			if (isNaN(parseFloat(size))) size=minR;
+			var mod=(parseFloat(size)*factor)/2;
+
+			var point=document.createElement(&quot;v:oval&quot;);
+			point.setAttribute(&quot;strokecolor&quot;, series.color);
+			point.setAttribute(&quot;fillcolor&quot;, series.color);
+			point.setAttribute(&quot;title&quot;, series.label + &quot;: &quot; + series.values[i].value + &quot; (&quot; + size + &quot;)&quot;);
+			point.style.position=&quot;absolute&quot;;
+			point.style.top=(_this.getY(series.values[i].value, chart)-mod) + &quot;px&quot;;
+			point.style.left=(_this.getX(series.values[i].x, chart)-mod) + &quot;px&quot;;
+			point.style.width=mod+&quot;px&quot;;
+			point.style.height=mod+&quot;px&quot;;
+			chart.dataGroup.appendChild(point);
+		}
+	};
+}();

Added: trunk/root/static/magic/src/xml/Parse.js
===================================================================
--- trunk/root/static/magic/src/xml/Parse.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/xml/Parse.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,188 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.xml.Parse&quot;);
+
+dojo.require(&quot;dojo.dom&quot;);
+
+//TODO: determine dependencies
+// currently has dependency on dojo.xml.DomUtil nodeTypes constants...
+
+/* generic method for taking a node and parsing it into an object
+
+TODO: WARNING: This comment is wrong!
+
+For example, the following xml fragment
+
+&lt;foo bar=&quot;bar&quot;&gt;
+	&lt;baz xyzzy=&quot;xyzzy&quot;/&gt;
+&lt;/foo&gt;
+
+can be described as:
+
+dojo.???.foo = {}
+dojo.???.foo.bar = {}
+dojo.???.foo.bar.value = &quot;bar&quot;;
+dojo.???.foo.baz = {}
+dojo.???.foo.baz.xyzzy = {}
+dojo.???.foo.baz.xyzzy.value = &quot;xyzzy&quot;
+
+*/
+// using documentFragment nomenclature to generalize in case we don't want to require passing a collection of nodes with a single parent
+dojo.xml.Parse = function(){
+
+	function getDojoTagName (node) {
+		var tagName = node.tagName;
+		if (tagName.substr(0,5).toLowerCase() != &quot;dojo:&quot;) {
+			
+			if (tagName.substr(0,4).toLowerCase() == &quot;dojo&quot;) {
+				// FIXME: this assuumes tag names are always lower case
+				return &quot;dojo:&quot; + tagName.substring(4).toLowerCase();
+			}
+		
+			// allow lower-casing
+			var djt = node.getAttribute(&quot;dojoType&quot;) || node.getAttribute(&quot;dojotype&quot;);
+			if (djt) { return &quot;dojo:&quot; + djt.toLowerCase(); }
+			
+			if (node.getAttributeNS &amp;&amp; node.getAttributeNS(dojo.dom.dojoml,&quot;type&quot;)) {
+				return &quot;dojo:&quot; + node.getAttributeNS(dojo.dom.dojoml,&quot;type&quot;).toLowerCase();
+			}
+			try {
+				// FIXME: IE really really doesn't like this, so we squelch
+				// errors for it
+				djt = node.getAttribute(&quot;dojo:type&quot;);
+			} catch (e) { /* FIXME: log? */ }
+
+			if (djt) { return &quot;dojo:&quot;+djt.toLowerCase(); }
+		
+			if (!dj_global[&quot;djConfig&quot;] || !djConfig[&quot;ignoreClassNames&quot;]) {
+				// FIXME: should we make this optionally enabled via djConfig?
+				var classes = node.className||node.getAttribute(&quot;class&quot;);
+				// FIXME: following line, without check for existence of classes.indexOf
+				// breaks firefox 1.5's svg widgets
+				if (classes &amp;&amp; classes.indexOf &amp;&amp; classes.indexOf(&quot;dojo-&quot;) != -1) {
+					var aclasses = classes.split(&quot; &quot;);
+					for(var x=0; x&lt;aclasses.length; x++){
+						if (aclasses[x].length &gt; 5 &amp;&amp; aclasses[x].indexOf(&quot;dojo-&quot;) &gt;= 0) {
+							return &quot;dojo:&quot;+aclasses[x].substr(5).toLowerCase();
+						}
+					}
+				}
+			}
+		
+		}
+		return tagName.toLowerCase();
+	}
+
+	this.parseElement = function(node, hasParentNodeSet, optimizeForDojoML, thisIdx){
+
+        // if parseWidgets=&quot;false&quot; don't search inside this node for widgets
+        if (node.getAttribute(&quot;parseWidgets&quot;) == &quot;false&quot;) {
+            return {};
+        }
+
+		// TODO: make this namespace aware
+		var parsedNodeSet = {};
+
+		var tagName = getDojoTagName(node);
+		parsedNodeSet[tagName] = [];
+		if((!optimizeForDojoML)||(tagName.substr(0,4).toLowerCase()==&quot;dojo&quot;)){
+			var attributeSet = parseAttributes(node);
+			for(var attr in attributeSet){
+				if((!parsedNodeSet[tagName][attr])||(typeof parsedNodeSet[tagName][attr] != &quot;array&quot;)){
+					parsedNodeSet[tagName][attr] = [];
+				}
+				parsedNodeSet[tagName][attr].push(attributeSet[attr]);
+			}
+	
+			// FIXME: we might want to make this optional or provide cloning instead of
+			// referencing, but for now, we include a node reference to allow
+			// instantiated components to figure out their &quot;roots&quot;
+			parsedNodeSet[tagName].nodeRef = node;
+			parsedNodeSet.tagName = tagName;
+			parsedNodeSet.index = thisIdx||0;
+		}
+	
+		var count = 0;
+		var tcn, i = 0, nodes = node.childNodes;
+		while(tcn = nodes[i++]){
+			switch(tcn.nodeType){
+				case  dojo.dom.ELEMENT_NODE: // element nodes, call this function recursively
+					count++;
+					var ctn = getDojoTagName(tcn);
+					if(!parsedNodeSet[ctn]){
+						parsedNodeSet[ctn] = [];
+					}
+					parsedNodeSet[ctn].push(this.parseElement(tcn, true, optimizeForDojoML, count));
+					if(	(tcn.childNodes.length == 1)&amp;&amp;
+						(tcn.childNodes.item(0).nodeType == dojo.dom.TEXT_NODE)){
+						parsedNodeSet[ctn][parsedNodeSet[ctn].length-1].value = tcn.childNodes.item(0).nodeValue;
+					}
+					break;
+				case  dojo.dom.TEXT_NODE: // if a single text node is the child, treat it as an attribute
+					if(node.childNodes.length == 1) {
+						parsedNodeSet[tagName].push({ value: node.childNodes.item(0).nodeValue });
+					}
+					break;
+				default: break;
+				/*
+				case  dojo.dom.ATTRIBUTE_NODE: // attribute node... not meaningful here
+					break;
+				case  dojo.dom.CDATA_SECTION_NODE: // cdata section... not sure if this would ever be meaningful... might be...
+					break;
+				case  dojo.dom.ENTITY_REFERENCE_NODE: // entity reference node... not meaningful here
+					break;
+				case  dojo.dom.ENTITY_NODE: // entity node... not sure if this would ever be meaningful
+					break;
+				case  dojo.dom.PROCESSING_INSTRUCTION_NODE: // processing instruction node... not meaningful here
+					break;
+				case  dojo.dom.COMMENT_NODE: // comment node... not not sure if this would ever be meaningful 
+					break;
+				case  dojo.dom.DOCUMENT_NODE: // document node... not sure if this would ever be meaningful
+					break;
+				case  dojo.dom.DOCUMENT_TYPE_NODE: // document type node... not meaningful here
+					break;
+				case  dojo.dom.DOCUMENT_FRAGMENT_NODE: // document fragment node... not meaningful here
+					break;
+				case  dojo.dom.NOTATION_<A HREF="NODE://">NODE://</A> notation node... not meaningful here
+					break;
+				*/
+			}
+		}
+		//return (hasParentNodeSet) ? parsedNodeSet[node.tagName] : parsedNodeSet;
+		return parsedNodeSet;
+	}
+
+	/* parses a set of attributes on a node into an object tree */
+	function parseAttributes(node) {
+		// TODO: make this namespace aware
+		var parsedAttributeSet = {};
+		var atts = node.attributes;
+		// TODO: should we allow for duplicate attributes at this point...
+		// would any of the relevant dom implementations even allow this?
+		var attnode, i=0;
+		while(attnode=atts[i++]) {
+			if((dojo.render.html.capable)&amp;&amp;(dojo.render.html.ie)){
+				if(!attnode){ continue; }
+				if(	(typeof attnode == &quot;object&quot;)&amp;&amp;
+					(typeof attnode.nodeValue == 'undefined')||
+					(attnode.nodeValue == null)||
+					(attnode.nodeValue == '')){ 
+					continue; 
+				}
+			}
+			var nn = (attnode.nodeName.indexOf(&quot;dojo:&quot;) == -1) ? attnode.nodeName : attnode.nodeName.split(&quot;dojo:&quot;)[1];
+			parsedAttributeSet[nn] = { 
+				value: attnode.nodeValue 
+			};
+		}
+		return parsedAttributeSet;
+	}
+}

Added: trunk/root/static/magic/src/xml/__package__.js
===================================================================
--- trunk/root/static/magic/src/xml/__package__.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/xml/__package__.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,18 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.require(&quot;dojo.xml.Parse&quot;);
+dojo.kwCompoundRequire({
+	common:		[&quot;dojo.xml.domUtil&quot;],
+    browser: 	[&quot;dojo.xml.htmlUtil&quot;],
+    dashboard: 	[&quot;dojo.xml.htmlUtil&quot;],
+    svg: 		[&quot;dojo.xml.svgUtil&quot;]
+});
+dojo.provide(&quot;dojo.xml.*&quot;);

Added: trunk/root/static/magic/src/xml/domUtil.js
===================================================================
--- trunk/root/static/magic/src/xml/domUtil.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/xml/domUtil.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,84 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.xml.domUtil&quot;);
+dojo.require(&quot;dojo.graphics.color&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+dojo.require(&quot;dojo.style&quot;);
+
+dojo.deprecated(&quot;dojo.xml.domUtil&quot;, &quot;use dojo.dom instead&quot;, &quot;0.4&quot;);
+
+// for loading script:
+dojo.xml.domUtil = new function(){
+	this.nodeTypes = {
+		ELEMENT_NODE                  : 1,
+		ATTRIBUTE_NODE                : 2,
+		TEXT_NODE                     : 3,
+		CDATA_SECTION_NODE            : 4,
+		ENTITY_REFERENCE_NODE         : 5,
+		ENTITY_NODE                   : 6,
+		PROCESSING_INSTRUCTION_NODE   : 7,
+		COMMENT_NODE                  : 8,
+		DOCUMENT_NODE                 : 9,
+		DOCUMENT_TYPE_NODE            : 10,
+		DOCUMENT_FRAGMENT_NODE        : 11,
+		NOTATION_NODE                 : 12
+	}
+	
+	this.dojoml = &quot;<A HREF="http://www.dojotoolkit.org/2004/dojoml">http://www.dojotoolkit.org/2004/dojoml</A>&quot;;
+	this.idIncrement = 0;
+	
+	this.getTagName = function(){return dojo.dom.getTagName.apply(dojo.dom, arguments);}
+	this.getUniqueId = function(){return dojo.dom.getUniqueId.apply(dojo.dom, arguments);}
+	this.getFirstChildTag = function() {return dojo.dom.getFirstChildElement.apply(dojo.dom, arguments);}
+	this.getLastChildTag = function() {return dojo.dom.getLastChildElement.apply(dojo.dom, arguments);}
+	this.getNextSiblingTag = function() {return dojo.dom.getNextSiblingElement.apply(dojo.dom, arguments);}
+	this.getPreviousSiblingTag = function() {return dojo.dom.getPreviousSiblingElement.apply(dojo.dom, arguments);}
+
+	this.forEachChildTag = function(node, unaryFunc) {
+		var child = this.getFirstChildTag(node);
+		while(child) {
+			if(unaryFunc(child) == &quot;break&quot;) { break; }
+			child = this.getNextSiblingTag(child);
+		}
+	}
+
+	this.moveChildren = function() {return dojo.dom.moveChildren.apply(dojo.dom, arguments);}
+	this.copyChildren = function() {return dojo.dom.copyChildren.apply(dojo.dom, arguments);}
+	this.clearChildren = function() {return dojo.dom.removeChildren.apply(dojo.dom, arguments);}
+	this.replaceChildren = function() {return dojo.dom.replaceChildren.apply(dojo.dom, arguments);}
+
+	this.getStyle = function() {return dojo.style.getStyle.apply(dojo.style, arguments);}
+	this.toCamelCase = function() {return dojo.style.toCamelCase.apply(dojo.style, arguments);}
+	this.toSelectorCase = function() {return dojo.style.toSelectorCase.apply(dojo.style, arguments);}
+
+	this.getAncestors = function(){return dojo.dom.getAncestors.apply(dojo.dom, arguments);}
+	this.isChildOf = function() {return dojo.dom.isDescendantOf.apply(dojo.dom, arguments);}
+	this.createDocumentFromText = function() {return dojo.dom.createDocumentFromText.apply(dojo.dom, arguments);}
+
+	if(dojo.render.html.capable || dojo.render.svg.capable) {
+		this.createNodesFromText = function(txt, wrap){return dojo.dom.createNodesFromText.apply(dojo.dom, arguments);}
+	}
+
+	this.extractRGB = function(color) { return dojo.graphics.color.extractRGB(color); }
+	this.hex2rgb = function(hex) { return dojo.graphics.color.hex2rgb(hex); }
+	this.rgb2hex = function(r, g, b) { return dojo.graphics.color.rgb2hex(r, g, b); }
+
+	this.insertBefore = function() {return dojo.dom.insertBefore.apply(dojo.dom, arguments);}
+	this.before = this.insertBefore;
+	this.insertAfter = function() {return dojo.dom.insertAfter.apply(dojo.dom, arguments);}
+	this.after = this.insertAfter
+	this.insert = function(){return dojo.dom.insertAtPosition.apply(dojo.dom, arguments);}
+	this.insertAtIndex = function(){return dojo.dom.insertAtIndex.apply(dojo.dom, arguments);}
+	this.textContent = function () {return dojo.dom.textContent.apply(dojo.dom, arguments);}
+	this.renderedTextContent = function () {return dojo.dom.renderedTextContent.apply(dojo.dom, arguments);}
+	this.remove = function (node) {return dojo.dom.removeNode.apply(dojo.dom, arguments);}
+}
+

Added: trunk/root/static/magic/src/xml/htmlUtil.js
===================================================================
--- trunk/root/static/magic/src/xml/htmlUtil.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/xml/htmlUtil.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,121 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.xml.htmlUtil&quot;);
+dojo.require(&quot;dojo.html&quot;);
+dojo.require(&quot;dojo.style&quot;);
+dojo.require(&quot;dojo.dom&quot;);
+
+dojo.deprecated(&quot;dojo.xml.htmlUtil&quot;, &quot;use dojo.html instead&quot;, &quot;0.4&quot;);
+
+dojo.xml.htmlUtil = new function(){
+	this.styleSheet = dojo.style.styleSheet;
+	
+	this._clobberSelection = function(){return dojo.html.clearSelection.apply(dojo.html, arguments);}
+	this.disableSelect = function(){return dojo.html.disableSelection.apply(dojo.html, arguments);}
+	this.enableSelect = function(){return dojo.html.enableSelection.apply(dojo.html, arguments);}
+	
+	this.getInnerWidth = function(){return dojo.style.getInnerWidth.apply(dojo.style, arguments);}
+	
+	this.getOuterWidth = function(node){
+		dojo.unimplemented(&quot;dojo.xml.htmlUtil.getOuterWidth&quot;);
+	}
+
+	this.getInnerHeight = function(){return dojo.style.getInnerHeight.apply(dojo.style, arguments);}
+
+	this.getOuterHeight = function(node){
+		dojo.unimplemented(&quot;dojo.xml.htmlUtil.getOuterHeight&quot;);
+	}
+
+	this.getTotalOffset = function(){return dojo.style.getTotalOffset.apply(dojo.style, arguments);}
+	this.totalOffsetLeft = function(){return dojo.style.totalOffsetLeft.apply(dojo.style, arguments);}
+
+	this.getAbsoluteX = this.totalOffsetLeft;
+
+	this.totalOffsetTop = function(){return dojo.style.totalOffsetTop.apply(dojo.style, arguments);}
+	
+	this.getAbsoluteY = this.totalOffsetTop;
+
+	this.getEventTarget = function(){return dojo.html.getEventTarget.apply(dojo.html, arguments);}
+	this.getScrollTop = function() {return dojo.html.getScrollTop.apply(dojo.html, arguments);}
+	this.getScrollLeft = function() {return dojo.html.getScrollLeft.apply(dojo.html, arguments);}
+
+	this.evtTgt = this.getEventTarget;
+
+	this.getParentOfType = function(){return dojo.html.getParentOfType.apply(dojo.html, arguments);}
+	this.getAttribute = function(){return dojo.html.getAttribute.apply(dojo.html, arguments);}
+	this.getAttr = function (node, attr) { // for backwards compat (may disappear!!!)
+		dojo.deprecated(&quot;dojo.xml.htmlUtil.getAttr&quot;, &quot;use dojo.xml.htmlUtil.getAttribute instead&quot;, &quot;0.4&quot;);
+		return dojo.xml.htmlUtil.getAttribute(node, attr);
+	}
+	this.hasAttribute = function(){return dojo.html.hasAttribute.apply(dojo.html, arguments);}
+
+	this.hasAttr = function (node, attr) { // for backwards compat (may disappear!!!)
+		dojo.deprecated(&quot;dojo.xml.htmlUtil.hasAttr&quot;, &quot;use dojo.xml.htmlUtil.hasAttribute instead&quot;, &quot;0.4&quot;);
+		return dojo.xml.htmlUtil.hasAttribute(node, attr);
+	}
+	
+	this.getClass = function(){return dojo.html.getClass.apply(dojo.html, arguments)}
+	this.hasClass = function(){return dojo.html.hasClass.apply(dojo.html, arguments)}
+	this.prependClass = function(){return dojo.html.prependClass.apply(dojo.html, arguments)}
+	this.addClass = function(){return dojo.html.addClass.apply(dojo.html, arguments)}
+	this.setClass = function(){return dojo.html.setClass.apply(dojo.html, arguments)}
+	this.removeClass = function(){return dojo.html.removeClass.apply(dojo.html, arguments)}
+
+	// Enum type for getElementsByClass classMatchType arg:
+	this.classMatchType = {
+		ContainsAll : 0, // all of the classes are part of the node's class (default)
+		ContainsAny : 1, // any of the classes are part of the node's class
+		IsOnly : 2 // only all of the classes are part of the node's class
+	}
+
+	this.getElementsByClass = function() {return dojo.html.getElementsByClass.apply(dojo.html, arguments)}
+	this.getElementsByClassName = this.getElementsByClass;
+	
+	this.setOpacity = function() {return dojo.style.setOpacity.apply(dojo.style, arguments)}
+	this.getOpacity = function() {return dojo.style.getOpacity.apply(dojo.style, arguments)}
+	this.clearOpacity = function() {return dojo.style.clearOpacity.apply(dojo.style, arguments)}
+	
+	this.gravity = function(){return dojo.html.gravity.apply(dojo.html, arguments)}
+	
+	this.gravity.NORTH = 1;
+	this.gravity.SOUTH = 1 &lt;&lt; 1;
+	this.gravity.EAST = 1 &lt;&lt; 2;
+	this.gravity.WEST = 1 &lt;&lt; 3;
+	
+	this.overElement = function(){return dojo.html.overElement.apply(dojo.html, arguments)}
+
+	this.insertCssRule = function(){return dojo.style.insertCssRule.apply(dojo.style, arguments)}
+	
+	this.insertCSSRule = function(selector, declaration, index){
+		dojo.deprecated(&quot;dojo.xml.htmlUtil.insertCSSRule&quot;, &quot;use dojo.style.insertCssRule instead&quot;, &quot;0.4&quot;);
+		return dojo.xml.htmlUtil.insertCssRule(selector, declaration, index);
+	}
+	
+	this.removeCssRule = function(){return dojo.style.removeCssRule.apply(dojo.style, arguments)}
+
+	this.removeCSSRule = function(index){
+		dojo.deprecated(&quot;dojo.xml.htmlUtil.removeCSSRule&quot;, &quot;use dojo.xml.htmlUtil.removeCssRule instead&quot;, &quot;0.4&quot;);
+		return dojo.xml.htmlUtil.removeCssRule(index);
+	}
+
+	this.insertCssFile = function(){return dojo.style.insertCssFile.apply(dojo.style, arguments)}
+
+	this.insertCSSFile = function(URI, doc, checkDuplicates){
+		dojo.deprecated(&quot;dojo.xml.htmlUtil.insertCSSFile&quot;, &quot;use dojo.xml.htmlUtil.insertCssFile instead&quot;, &quot;0.4&quot;);
+		return dojo.xml.htmlUtil.insertCssFile(URI, doc, checkDuplicates);
+	}
+
+	this.getBackgroundColor = function() {return dojo.style.getBackgroundColor.apply(dojo.style, arguments)}
+
+	this.getUniqueId = function() { return dojo.dom.getUniqueId(); }
+
+	this.getStyle = function() {return dojo.style.getStyle.apply(dojo.style, arguments)}
+}

Added: trunk/root/static/magic/src/xml/svgUtil.js
===================================================================
--- trunk/root/static/magic/src/xml/svgUtil.js	2006-07-19 16:19:00 UTC (rev 175)
+++ trunk/root/static/magic/src/xml/svgUtil.js	2006-07-19 16:19:27 UTC (rev 176)
@@ -0,0 +1,32 @@
+/*
+	Copyright (c) 2004-2006, The Dojo Foundation
+	All Rights Reserved.
+
+	Licensed under the Academic Free License version 2.1 or above OR the
+	modified BSD license. For more information on Dojo licensing, see:
+
+		<A HREF="http://dojotoolkit.org/community/licensing.shtml">http://dojotoolkit.org/community/licensing.shtml</A>
+*/
+
+dojo.provide(&quot;dojo.xml.svgUtil&quot;);
+// FIXME: add imports for deps!
+
+dojo.xml.svgUtil = new function(){
+
+	this.getInnerWidth = function(node){
+		// FIXME: need to find out from dylan how to 
+	}
+
+	this.getOuterWidth = function(node){
+		
+	}
+
+	this.getInnerHeight = function(node){
+		
+	}
+
+	this.getOuterHeight = function(node){
+		
+	}
+
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000064.html">[Parley-svn] r175 - / trunk/issues trunk/issues/model_method	trunk/issues/model_method/ClassMethod	trunk/issues/model_method/ClassMethod/db	trunk/issues/model_method/ClassMethod/lib	trunk/issues/model_method/ClassMethod/lib/ClassMethod	trunk/issues/model_method/ClassMethod/lib/ClassMethod/Controller	trunk/issues/model_method/ClassMethod/lib/ClassMethod/Model	trunk/issues/model_method/ClassMethod/lib/ClassMethod/Model/CMDB	trunk/issues/model_method/ClassMethod/root	trunk/issues/model_method/ClassMethod/root/static	trunk/issues/model_method/ClassMethod/root/static/images	trunk/issues/model_method/ClassMethod/script	trunk/issues/model_method/ClassMethod/t
</A></li>
	<LI>Next message: <A HREF="000065.html">[Parley-svn] r177 - / trunk/script
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#75">[ date ]</a>
              <a href="thread.html#75">[ thread ]</a>
              <a href="subject.html#75">[ subject ]</a>
              <a href="author.html#75">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/parley-svn">More information about the Parley-svn
mailing list</a><br>
</body></html>
